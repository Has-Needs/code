{
  "version": 3,
  "sources": ["../../../src/assert.ts", "../../../src/error-handler.ts", "../../../src/error-stream.ts", "../../../src/fail.ts", "../../../src/inspect.ts", "../../../src/log-method.ts", "../../../src/raise.ts", "../../../src/snoop.ts", "../../../src/stack-trace.ts", "../../../src/strings.ts", "../../../src/throw.ts", "../../../src/timeout-warning.ts", "../../../src/todo.ts", "../../../src/devtools-formatter.ts", "../../../src/equality.ts", "../../../src/exposed-modules.ts", "../../../src/inspect-custom.ts"],
  "sourcesContent": ["//\n// Copyright 2020 DXOS.org\n//\n\n/**\n * A simple syntax sugar to write `value as T` as a statement.\n *\n * NOTE: This does not provide any type safety.\n * It's just for convenience so that autocomplete works for value.\n * It's recommended to check the type URL manually beforehand or use `assertAnyType` instead.\n * @param value\n */\nexport const checkType = <T>(value: T): T => value;\n", "//\n// Copyright 2020 DXOS.org\n//\n\nimport { EventEmitter } from 'node:events';\n\n/**\n * Listens for global errors.\n */\nexport class ErrorHandler extends EventEmitter {\n  _listener: EventListener;\n\n  constructor() {\n    super();\n\n    this._listener = (event: any) => {\n      const cause = event.error || event.reason || event;\n      const message = cause.stack || cause.message || cause.toString();\n      this.emit('error', message);\n\n      // Default logging.\n      // code event.preventDefault();\n    };\n\n    // https://developer.mozilla.org/en-US/docs/Web/API/Window/error_event\n    window.addEventListener('error', this._listener);\n\n    // https://developer.mozilla.org/en-US/docs/Web/API/Window/unhandledrejection_event\n    window.addEventListener('unhandledrejection', this._listener);\n  }\n\n  reset(): void {\n    window.removeEventListener('error', this._listener);\n    window.removeEventListener('unhandledrejection', this._listener);\n  }\n}\n", "//\n// Copyright 2021 DXOS.org\n//\n\nexport type ErrorHandlerCallback = (error: Error) => void;\n\n/**\n * Represents a stream of errors that entities can expose.\n */\nexport class ErrorStream {\n  private _handler: ErrorHandlerCallback | undefined;\n\n  private _unhandledErrors = 0;\n\n  assertNoUnhandledErrors(): void {\n    if (this._unhandledErrors > 0) {\n      throw new Error(\n        `Assertion failed: expected no unhandled errors to be thrown, but ${this._unhandledErrors} were thrown.`,\n      );\n    }\n  }\n\n  raise(error: Error): void {\n    if (this._handler) {\n      this._handler(error);\n    } else {\n      this._unhandledError(error);\n    }\n  }\n\n  handle(handler: ErrorHandlerCallback): void {\n    this._handler = handler;\n  }\n\n  pipeTo(receiver: ErrorStream): void {\n    this.handle((error) => receiver.raise(error));\n  }\n\n  private _unhandledError(error: Error): void {\n    this._unhandledErrors++;\n\n    setTimeout(() => {\n      throw error;\n    });\n  }\n}\n", "//\n// Copyright 2021 DXOS.org\n//\n\n/**\n * Should be used in expressions where values are cheked not to be null or undefined.\n *\n * Example:\n *\n * ```\n * const value: string | undefined;\n *\n * callMethod(value ?? failUndefined());\n * ```\n */\n// TODO(burdon): Rename failIfUndefined().\nexport const failUndefined = () => {\n  throw new Error('Required value was null or undefined.');\n};\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { inspect } from 'node:util';\n\n/**\n * Utility to automatically log debug info.\n *\n * ```\n *   // Called via `console.log`.\n *   [inspect.custom] () {\n *     return inspectObject(this);\n *   }\n *\n *   // Called via `JSON.stringify`.\n *   toJSON () {\n *     return { ... };\n *   }\n * ```\n */\nexport const inspectObject = (obj: any) => {\n  const name = Object.getPrototypeOf(obj).constructor.name;\n  return obj.toJSON ? `${name}(${inspect(obj.toJSON())})` : String(obj);\n};\n", "//\n// Copyright 2021 DXOS.org\n//\n\nexport function logMethod(\n  target: any,\n  propertyName: string,\n  descriptor: TypedPropertyDescriptor<(...args: any) => any>,\n): void {\n  const method = descriptor.value!;\n  descriptor.value = function (this: any, ...args: any) {\n    console.log(`Called ${target.constructor.name}.${propertyName} ${args}`);\n    try {\n      const result = method.apply(this, args);\n      if (typeof result.catch === 'function') {\n        result.catch((err: any) => {\n          console.log(`Rejected ${target.constructor.name}.${propertyName}`, err);\n        });\n      }\n      return result;\n    } catch (err: any) {\n      console.log(`Thrown ${target.constructor.name}.${propertyName}`, err);\n      throw err;\n    }\n  };\n}\n", "//\n// Copyright 2020 DXOS.org\n//\n\n/**\n * Immediatelly throws an error passed as an argument.\n *\n * Usefull for throwing errors from inside expressions.\n * For example:\n * ```\n * const item = model.getById(someId) ?? raise(new Error('Not found'));\n * ```\n * @param error\n */\nexport const raise = (error: Error): never => {\n  throw error;\n};\n", "//\n// Copyright 2022 DXOS.org\n//\n\nexport enum SnoopLevel {\n  DEFAULT = 0,\n  VERBOSE = 1,\n  BOLD = 2,\n}\n\n/**\n * Utils for debug logging of functions.\n */\n// TODO(burdon): Integrate with log/spyglass.\nexport class Snoop {\n  static stackFunction(err: Error): string | undefined {\n    const stack = err.stack!.split('\\n');\n    const match = stack[2].match(/.+\\((.+)\\).*/);\n    if (match) {\n      const [file, line] = match[1].split(':');\n      return `[${file.substring(file.lastIndexOf('/') + 1)}:${line}]`;\n    }\n  }\n\n  constructor(private readonly _context?: string) {}\n\n  get verbose() {\n    return SnoopLevel.VERBOSE;\n  }\n\n  get bold() {\n    return SnoopLevel.BOLD;\n  }\n\n  format(prefix: string, name: string, args: string, level: SnoopLevel): string {\n    const pre = prefix.repeat(level === SnoopLevel.BOLD ? 8 : 2);\n    const label = this._context ? `${this._context}.${name}` : name;\n    const line = `${pre} ${label}${args}`;\n    return level === SnoopLevel.BOLD ? [pre, line, pre].join('\\n') : line;\n  }\n\n  in(label: string, level: SnoopLevel, ...args: any[]): string {\n    return this.format('<', label, level === SnoopLevel.DEFAULT ? '' : `(${String(...args)})`, level);\n  }\n\n  out(label: string, level: SnoopLevel, result: any): string {\n    return this.format('>', label, level === SnoopLevel.DEFAULT ? '' : ` = ${String(result)}`, level);\n  }\n\n  sync(f: any, label?: string, level: SnoopLevel = SnoopLevel.VERBOSE) {\n    label = label ?? Snoop.stackFunction(new Error());\n    return (...args: any[]) => {\n      console.log(this.in(label ?? '', level, ...args));\n      const r = f(...args);\n      console.log(this.out(label ?? '', level, r));\n      return r;\n    };\n  }\n\n  async(f: any, label?: string, level: SnoopLevel = SnoopLevel.VERBOSE) {\n    label = label ?? Snoop.stackFunction(new Error());\n    return async (...args: any[]) => {\n      console.log(this.in(label ?? '', level, ...args));\n      const r = await f(...args);\n      console.log(this.out(label ?? '', level, r));\n      return r;\n    };\n  }\n}\n\nexport const snoop = new Snoop();\n", "//\n// Copyright 2021 DXOS.org\n//\n\n/**\n * Will capture the stack trace at the point where the class is created.\n * Stack traces are formatted lazily only when `getStack` is called.\n * Formatting is significantly more expensive than capture so only call getStack when you need them.\n */\nexport class StackTrace {\n  private _stack: Error;\n\n  constructor() {\n    this._stack = new Error();\n  }\n\n  /**\n   * Get stack formatted as string.\n   * @param skipFrames Number of frames to skip. By default, the first frame would be the invocation of the StackTrace constructor.\n   * @returns\n   */\n  getStack(skipFrames = 0): string {\n    const stack = this._stack.stack!.split('\\n');\n    return stack.slice(skipFrames + 2).join('\\n');\n  }\n\n  getStackArray(skipFrames = 0): string[] {\n    const stack = this._stack.stack!.split('\\n');\n    return stack.slice(skipFrames + 2);\n  }\n}\n", "//\n// Copyright 2020 DXOS.org\n//\n\nexport const truncate = (str = '', length = 8, pad: boolean | string = false) => {\n  if (str.length >= length - 1) {\n    return str.substring(0, length - 1) + 'â€¦';\n  } else {\n    return pad ? str.padEnd(length, typeof pad === 'boolean' ? ' ' : pad[0]) : str;\n  }\n};\n\nexport const truncateKey = (key: any, length = 8) => {\n  const str = String(key);\n  if (str.length <= length) {\n    return str;\n  }\n\n  return str.slice(0, length);\n\n  // return start\n  //   ? `${str.slice(0, length)}...`\n  //   : `${str.substring(0, length / 2)}...${str.substring(str.length - length / 2)}`;\n};\n", "//\n// Copyright 2020 DXOS.org\n//\n\n/**\n * Wrapper for async tests.\n * @param {Function} test - Async test\n * @param errType\n * @return {Promise<void>}\n *\n * @deprecated Use vitests `expect(() => ...).toThrowError();` instead.\n */\nexport const expectToThrow = async (test: () => void, errType = Error) => {\n  let thrown;\n  try {\n    await test();\n  } catch (err) {\n    thrown = err;\n  }\n\n  if (thrown === undefined || !(thrown instanceof errType)) {\n    throw new Error(`Expected function to throw instance of ${errType.prototype.name}`);\n  }\n};\n", "//\n// Copyright 2020 DXOS.org\n//\n\nimport { StackTrace } from './stack-trace';\n\n/**\n * Prints a warning to console if the action takes longer then specified timeout. No errors are thrown.\n *\n * @param timeout Timeout in milliseconds after which warning is printed.\n * @param context Context description that would be included in the printed message.\n * @param body Action which is timed.\n */\nexport const warnAfterTimeout = async <T>(timeout: number, context: string, body: () => Promise<T>): Promise<T> => {\n  const stack = new StackTrace();\n  const timeoutId = setTimeout(() => {\n    console.warn(\n      `Action \\`${context}\\` is taking more then ${timeout.toLocaleString()}ms to complete. This might be a bug.\\n${stack.getStack()}`,\n    );\n  }, timeout);\n  try {\n    return await body();\n  } finally {\n    clearTimeout(timeoutId);\n  }\n};\n\n/**\n * A decorator that prints a warning to console if method execution time exceeds specified timeout.\n *\n * ```typescript\n * class Foo {\n *   @timed(5_000)\n *   async doStuff() {\n *     // long task\n *   }\n * }\n * ```\n *\n * This is useful for debugging code that might deadlock.\n *\n * @param timeout Timeout in milliseconds after which the warning is printed.\n */\nexport function timed(timeout: number) {\n  return (target: any, propertyName: string, descriptor: TypedPropertyDescriptor<(...args: any) => any>) => {\n    const method = descriptor.value!;\n    descriptor.value = function (this: any, ...args: any) {\n      return warnAfterTimeout(timeout, `${target.constructor.name}.${propertyName}`, () => method.apply(this, args));\n    };\n  };\n}\n", "//\n// Copyright 2020 DXOS.org\n//\n\n/**\n * Throws an error. Can be used in an expression instead of a value\n */\nexport const todo = (message?: string): never => {\n  throw new Error(message ?? 'Not implemented.');\n};\n", "//\n// Copyright 2023 DXOS.org\n//\n\n/**\n * Lets types provide custom formatters for the Chrome Devtools.\n *\n * https://www.mattzeunert.com/2016/02/19/custom-chrome-devtools-object-formatters.html\n * NOTE: Must be enabled in chrome devtools preferences.\n *\n * @example\n * ```typescript\n * class MyType {\n *  get [devtoolsFormatter] (): DevtoolsFormatter {\n *    ...\n *  }\n * ```\n */\n\nexport const devtoolsFormatter = Symbol.for('devtoolsFormatter');\n\nexport type JsonML = [string, Record<string, any>?, ...(JsonML | string)[]];\n\nexport interface DevtoolsFormatter {\n  /**\n   * NOTE: Make sure to do an instance check and return null if the object is not of the correct type.\n   */\n  header: (config?: any) => JsonML | null;\n  hasBody?: (config?: any) => boolean;\n  body?: (config?: any) => JsonML | null;\n}\n\n/**\n * Types that implement this interface can provide custom formatters for the Chrome Devtools.\n *\n * https://firefox-source-docs.mozilla.org/devtools-user/custom_formatters/index.html\n */\nexport interface CustomDevtoolsFormattable {\n  get [devtoolsFormatter](): DevtoolsFormatter;\n}\n\nconst register = () => {\n  if (typeof window !== 'undefined') {\n    ((window as any).devtoolsFormatters ??= []).push({\n      header: (value: any, config: any) => {\n        const formatter = value[devtoolsFormatter];\n        if (formatter === undefined) {\n          return null;\n        }\n        if (typeof formatter !== 'object' || formatter === null || typeof formatter.header !== 'function') {\n          throw new Error(`Invalid devtools formatter for ${value.constructor.name}`);\n        }\n\n        return formatter.header(config);\n      },\n      hasBody: (value: any, config: any) => {\n        const formatter = value[devtoolsFormatter];\n        if (!formatter || !formatter.hasBody) {\n          return false;\n        }\n\n        return formatter.hasBody(config);\n      },\n      body: (value: any, config: any) => {\n        const formatter = value[devtoolsFormatter];\n        if (!formatter || !formatter.body) {\n          return null;\n        }\n\n        return formatter.body(config);\n      },\n    });\n  }\n};\n\nregister();\n", "//\n// Copyright 2023 DXOS.org\n//\n\nexport const equalsSymbol = Symbol.for('dxos.common.equals');\n\nexport interface Equatable {\n  [equalsSymbol]: (other: any) => boolean;\n}\n\n// TODO(dmaretskyi): export to @dxos/traits.\n// TODO(dmaretskyi): Hash trait for maps?\n\nexport const isEquatable = (value: any): value is Equatable => {\n  return typeof value === 'object' && value !== null && typeof value[equalsSymbol] === 'function';\n};\n\nexport const isEqual = (value: Equatable, other: any) => {\n  return value[equalsSymbol](other);\n};\n\n/**\n * Feed this as a third argument to `_.isEqualWith` to compare objects with `Equatable` interface.\n */\nexport const loadashEqualityFn = (value: any, other: any): boolean | undefined => {\n  if (!isEquatable(value)) {\n    return undefined;\n  }\n  return isEqual(value, other);\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\n/**\n * Allows to register a module to be used later during debugging.\n *\n * ```ts\n * import * as keys from '@dxos/keys';\n * exposeModule('@dxos/keys', keys);\n *\n * ...\n *\n * const { PublicKey } = importModule('@dxos/keys');\n * ```\n *\n * Overwrites the module if it already exists.\n */\nexport const exposeModule = (name: string, module: any) => {\n  EXPOSED_MODULES[name] = module;\n};\n\n/**\n * Imports a previously exposed module by its name.\n * Throws an error if the module is not found.\n *\n * @param {string} name - The name of the module to import.\n * @returns {any} The imported module.\n * @throws {Error} If the module is not exposed.\n */\nexport const importModule = (name: string) => {\n  if (EXPOSED_MODULES[name]) {\n    return EXPOSED_MODULES[name];\n  } else {\n    throw new Error(`Module ${name} is not exposed.`);\n  }\n};\n\nconst EXPOSED_MODULES: Record<string, any> = {};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport type { InspectOptionsStylized, inspect as inspectFn } from 'node:util';\n\n/**\n * Using this allows code to be written in a portable fashion, so that the custom inspect function is used in an Node.js environment and ignored in the browser.\n */\nexport const inspectCustom = Symbol.for('nodejs.util.inspect.custom');\n\nexport type CustomInspectFunction<T = any> = (\n  this: T,\n  depth: number,\n  options: InspectOptionsStylized,\n  inspect: typeof inspectFn,\n) => any; // TODO: , inspect: inspect\n\nexport interface CustomInspectable {\n  [inspectCustom]: CustomInspectFunction;\n}\n"],
  "mappings": "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",
  "names": ["checkType", "value", "EventEmitter", "ErrorHandler", "EventEmitter", "_listener", "event", "cause", "error", "reason", "message", "stack", "toString", "emit", "window", "addEventListener", "reset", "removeEventListener", "ErrorStream", "_unhandledErrors", "assertNoUnhandledErrors", "Error", "raise", "error", "_handler", "_unhandledError", "handle", "handler", "pipeTo", "receiver", "setTimeout", "failUndefined", "Error", "inspect", "inspectObject", "obj", "name", "Object", "getPrototypeOf", "toJSON", "inspect", "String", "logMethod", "target", "propertyName", "descriptor", "method", "value", "args", "console", "log", "name", "result", "apply", "catch", "err", "raise", "error", "SnoopLevel", "Snoop", "stackFunction", "err", "stack", "split", "match", "file", "line", "substring", "lastIndexOf", "_context", "verbose", "bold", "format", "prefix", "name", "args", "level", "pre", "repeat", "label", "join", "in", "String", "out", "result", "sync", "f", "Error", "console", "log", "r", "async", "snoop", "StackTrace", "_stack", "Error", "getStack", "skipFrames", "stack", "split", "slice", "join", "getStackArray", "truncate", "str", "length", "pad", "substring", "padEnd", "truncateKey", "key", "String", "slice", "expectToThrow", "test", "errType", "Error", "thrown", "err", "undefined", "prototype", "name", "warnAfterTimeout", "timeout", "context", "body", "stack", "StackTrace", "timeoutId", "setTimeout", "console", "warn", "toLocaleString", "getStack", "clearTimeout", "timed", "target", "propertyName", "descriptor", "method", "value", "args", "name", "apply", "todo", "message", "Error", "devtoolsFormatter", "Symbol", "for", "register", "window", "devtoolsFormatters", "push", "header", "value", "config", "formatter", "undefined", "Error", "name", "hasBody", "body", "equalsSymbol", "Symbol", "for", "isEquatable", "value", "isEqual", "other", "loadashEqualityFn", "undefined", "exposeModule", "name", "module", "EXPOSED_MODULES", "importModule", "Error", "inspectCustom", "Symbol", "for"]
}
