"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var node_exports = {};
__export(node_exports, {
  ErrorHandler: () => ErrorHandler,
  ErrorStream: () => ErrorStream,
  Snoop: () => Snoop,
  SnoopLevel: () => SnoopLevel,
  StackTrace: () => StackTrace,
  checkType: () => checkType,
  devtoolsFormatter: () => devtoolsFormatter,
  equalsSymbol: () => equalsSymbol,
  expectToThrow: () => expectToThrow,
  exposeModule: () => exposeModule,
  failUndefined: () => failUndefined,
  importModule: () => importModule,
  inspectCustom: () => inspectCustom,
  inspectObject: () => inspectObject,
  isEqual: () => isEqual,
  isEquatable: () => isEquatable,
  loadashEqualityFn: () => loadashEqualityFn,
  logMethod: () => logMethod,
  raise: () => raise,
  snoop: () => snoop,
  timed: () => timed,
  todo: () => todo,
  truncate: () => truncate,
  truncateKey: () => truncateKey,
  warnAfterTimeout: () => warnAfterTimeout
});
module.exports = __toCommonJS(node_exports);
var import_node_events = require("node:events");
var import_node_util = require("node:util");
var checkType = (value) => value;
var ErrorHandler = class extends import_node_events.EventEmitter {
  constructor() {
    super();
    this._listener = (event) => {
      const cause = event.error || event.reason || event;
      const message = cause.stack || cause.message || cause.toString();
      this.emit("error", message);
    };
    window.addEventListener("error", this._listener);
    window.addEventListener("unhandledrejection", this._listener);
  }
  reset() {
    window.removeEventListener("error", this._listener);
    window.removeEventListener("unhandledrejection", this._listener);
  }
};
var ErrorStream = class {
  constructor() {
    this._unhandledErrors = 0;
  }
  assertNoUnhandledErrors() {
    if (this._unhandledErrors > 0) {
      throw new Error(`Assertion failed: expected no unhandled errors to be thrown, but ${this._unhandledErrors} were thrown.`);
    }
  }
  raise(error) {
    if (this._handler) {
      this._handler(error);
    } else {
      this._unhandledError(error);
    }
  }
  handle(handler) {
    this._handler = handler;
  }
  pipeTo(receiver) {
    this.handle((error) => receiver.raise(error));
  }
  _unhandledError(error) {
    this._unhandledErrors++;
    setTimeout(() => {
      throw error;
    });
  }
};
var failUndefined = () => {
  throw new Error("Required value was null or undefined.");
};
var inspectObject = (obj) => {
  const name = Object.getPrototypeOf(obj).constructor.name;
  return obj.toJSON ? `${name}(${(0, import_node_util.inspect)(obj.toJSON())})` : String(obj);
};
function logMethod(target, propertyName, descriptor) {
  const method = descriptor.value;
  descriptor.value = function(...args) {
    console.log(`Called ${target.constructor.name}.${propertyName} ${args}`);
    try {
      const result = method.apply(this, args);
      if (typeof result.catch === "function") {
        result.catch((err) => {
          console.log(`Rejected ${target.constructor.name}.${propertyName}`, err);
        });
      }
      return result;
    } catch (err) {
      console.log(`Thrown ${target.constructor.name}.${propertyName}`, err);
      throw err;
    }
  };
}
var raise = (error) => {
  throw error;
};
var SnoopLevel = /* @__PURE__ */ function(SnoopLevel2) {
  SnoopLevel2[SnoopLevel2["DEFAULT"] = 0] = "DEFAULT";
  SnoopLevel2[SnoopLevel2["VERBOSE"] = 1] = "VERBOSE";
  SnoopLevel2[SnoopLevel2["BOLD"] = 2] = "BOLD";
  return SnoopLevel2;
}({});
var Snoop = class _Snoop {
  static stackFunction(err) {
    const stack = err.stack.split("\n");
    const match = stack[2].match(/.+\((.+)\).*/);
    if (match) {
      const [file, line] = match[1].split(":");
      return `[${file.substring(file.lastIndexOf("/") + 1)}:${line}]`;
    }
  }
  constructor(_context) {
    this._context = _context;
  }
  get verbose() {
    return 1;
  }
  get bold() {
    return 2;
  }
  format(prefix, name, args, level) {
    const pre = prefix.repeat(level === 2 ? 8 : 2);
    const label = this._context ? `${this._context}.${name}` : name;
    const line = `${pre} ${label}${args}`;
    return level === 2 ? [
      pre,
      line,
      pre
    ].join("\n") : line;
  }
  in(label, level, ...args) {
    return this.format("<", label, level === 0 ? "" : `(${String(...args)})`, level);
  }
  out(label, level, result) {
    return this.format(">", label, level === 0 ? "" : ` = ${String(result)}`, level);
  }
  sync(f, label, level = 1) {
    label = label ?? _Snoop.stackFunction(new Error());
    return (...args) => {
      console.log(this.in(label ?? "", level, ...args));
      const r = f(...args);
      console.log(this.out(label ?? "", level, r));
      return r;
    };
  }
  async(f, label, level = 1) {
    label = label ?? _Snoop.stackFunction(new Error());
    return async (...args) => {
      console.log(this.in(label ?? "", level, ...args));
      const r = await f(...args);
      console.log(this.out(label ?? "", level, r));
      return r;
    };
  }
};
var snoop = new Snoop();
var StackTrace = class {
  constructor() {
    this._stack = new Error();
  }
  /**
  * Get stack formatted as string.
  * @param skipFrames Number of frames to skip. By default, the first frame would be the invocation of the StackTrace constructor.
  * @returns
  */
  getStack(skipFrames = 0) {
    const stack = this._stack.stack.split("\n");
    return stack.slice(skipFrames + 2).join("\n");
  }
  getStackArray(skipFrames = 0) {
    const stack = this._stack.stack.split("\n");
    return stack.slice(skipFrames + 2);
  }
};
var truncate = (str = "", length = 8, pad = false) => {
  if (str.length >= length - 1) {
    return str.substring(0, length - 1) + "\u2026";
  } else {
    return pad ? str.padEnd(length, typeof pad === "boolean" ? " " : pad[0]) : str;
  }
};
var truncateKey = (key, length = 8) => {
  const str = String(key);
  if (str.length <= length) {
    return str;
  }
  return str.slice(0, length);
};
var expectToThrow = async (test, errType = Error) => {
  let thrown;
  try {
    await test();
  } catch (err) {
    thrown = err;
  }
  if (thrown === void 0 || !(thrown instanceof errType)) {
    throw new Error(`Expected function to throw instance of ${errType.prototype.name}`);
  }
};
var warnAfterTimeout = async (timeout, context, body) => {
  const stack = new StackTrace();
  const timeoutId = setTimeout(() => {
    console.warn(`Action \`${context}\` is taking more then ${timeout.toLocaleString()}ms to complete. This might be a bug.
${stack.getStack()}`);
  }, timeout);
  try {
    return await body();
  } finally {
    clearTimeout(timeoutId);
  }
};
function timed(timeout) {
  return (target, propertyName, descriptor) => {
    const method = descriptor.value;
    descriptor.value = function(...args) {
      return warnAfterTimeout(timeout, `${target.constructor.name}.${propertyName}`, () => method.apply(this, args));
    };
  };
}
var todo = (message) => {
  throw new Error(message ?? "Not implemented.");
};
var devtoolsFormatter = Symbol.for("devtoolsFormatter");
var register = () => {
  if (typeof window !== "undefined") {
    (window.devtoolsFormatters ??= []).push({
      header: (value, config) => {
        const formatter = value[devtoolsFormatter];
        if (formatter === void 0) {
          return null;
        }
        if (typeof formatter !== "object" || formatter === null || typeof formatter.header !== "function") {
          throw new Error(`Invalid devtools formatter for ${value.constructor.name}`);
        }
        return formatter.header(config);
      },
      hasBody: (value, config) => {
        const formatter = value[devtoolsFormatter];
        if (!formatter || !formatter.hasBody) {
          return false;
        }
        return formatter.hasBody(config);
      },
      body: (value, config) => {
        const formatter = value[devtoolsFormatter];
        if (!formatter || !formatter.body) {
          return null;
        }
        return formatter.body(config);
      }
    });
  }
};
register();
var equalsSymbol = Symbol.for("dxos.common.equals");
var isEquatable = (value) => {
  return typeof value === "object" && value !== null && typeof value[equalsSymbol] === "function";
};
var isEqual = (value, other) => {
  return value[equalsSymbol](other);
};
var loadashEqualityFn = (value, other) => {
  if (!isEquatable(value)) {
    return void 0;
  }
  return isEqual(value, other);
};
var exposeModule = (name, module2) => {
  EXPOSED_MODULES[name] = module2;
};
var importModule = (name) => {
  if (EXPOSED_MODULES[name]) {
    return EXPOSED_MODULES[name];
  } else {
    throw new Error(`Module ${name} is not exposed.`);
  }
};
var EXPOSED_MODULES = {};
var inspectCustom = Symbol.for("nodejs.util.inspect.custom");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ErrorHandler,
  ErrorStream,
  Snoop,
  SnoopLevel,
  StackTrace,
  checkType,
  devtoolsFormatter,
  equalsSymbol,
  expectToThrow,
  exposeModule,
  failUndefined,
  importModule,
  inspectCustom,
  inspectObject,
  isEqual,
  isEquatable,
  loadashEqualityFn,
  logMethod,
  raise,
  snoop,
  timed,
  todo,
  truncate,
  truncateKey,
  warnAfterTimeout
});
//# sourceMappingURL=index.cjs.map
