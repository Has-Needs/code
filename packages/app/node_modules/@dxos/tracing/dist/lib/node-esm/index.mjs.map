{
  "version": 3,
  "sources": ["../../../src/api.ts", "../../../src/symbols.ts", "../../../src/trace-processor.ts", "../../../src/diagnostic.ts", "../../../src/util.ts", "../../../src/diagnostics-channel.ts", "../../../src/remote/metrics.ts", "../../../src/remote/tracing.ts", "../../../src/trace-sender.ts", "../../../src/weak-ref.ts", "../../../src/metrics/base.ts", "../../../src/metrics/unary-counter.ts", "../../../src/metrics/time-series-counter.ts", "../../../src/metrics/time-usage-counter.ts", "../../../src/metrics/map-counter.ts", "../../../src/metrics/custom-counter.ts", "../../../src/index.ts"],
  "sourcesContent": ["//\n// Copyright 2023 DXOS.org\n//\n\nimport { Context } from '@dxos/context';\nimport { type MaybePromise } from '@dxos/util';\n\nimport { getTracingContext } from './symbols';\nimport { TRACE_PROCESSOR, type TraceSpanParams, type TracingSpan } from './trace-processor';\n\n/**\n * Annotates a class as a tracked resource.\n */\nconst resource =\n  (options?: { annotation?: symbol }) =>\n  <T extends { new (...args: any[]): {} }>(constructor: T) => {\n    // Wrapping class declaration into an IIFE so it doesn't capture the `klass` class name.\n    const klass = (() =>\n      class extends constructor {\n        constructor(...rest: any[]) {\n          super(...rest);\n          TRACE_PROCESSOR.createTraceResource({ constructor, annotation: options?.annotation, instance: this });\n        }\n      })();\n    Object.defineProperty(klass, 'name', { value: constructor.name });\n    return klass;\n  };\n\nexport interface TimeAware {\n  tick(timeMs: number): void;\n}\n\nexport type InfoOptions = {\n  /**\n   * Value is of enum type and should be converted to string.\n   *\n   * Example:\n   *\n   * ```ts\n   * @trace.info({ enum: SpaceState })\n   * get state(): SpaceState { ... }\n   * ```\n   */\n  enum?: Record<string, any>;\n\n  /**\n   * Max depth of the object to be included in the resource info section.\n   *\n   * null means no limit (a limit of 8 nested objects is still imposed).\n   *\n   * Default: 0 - objects will be stringified with toString.\n   */\n  depth?: number | null;\n};\n\n/**\n * Marks a property or a method to be included in the resource info section.\n */\nconst info =\n  (opts: InfoOptions = {}) =>\n  (target: any, propertyKey: string, descriptor?: PropertyDescriptor) => {\n    getTracingContext(target).infoProperties[propertyKey] = { options: opts };\n  };\n\nconst mark = (name: string) => {\n  performance.mark(name);\n};\n\nexport type SpanOptions = {\n  showInBrowserTimeline?: boolean;\n  op?: string;\n  attributes?: Record<string, any>;\n};\n\n/**\n * Decorator that creates a span for the execution duration of the decorated method.\n */\nconst span =\n  ({ showInBrowserTimeline = false, op, attributes }: SpanOptions = {}) =>\n  (target: any, propertyKey: string, descriptor: TypedPropertyDescriptor<(...args: any) => any>) => {\n    const method = descriptor.value!;\n\n    descriptor.value = async function (this: any, ...args: any) {\n      const parentCtx = args[0] instanceof Context ? args[0] : null;\n      const span = TRACE_PROCESSOR.traceSpan({\n        parentCtx,\n        methodName: propertyKey,\n        instance: this,\n        showInBrowserTimeline,\n        op,\n        attributes,\n      });\n\n      const callArgs = span.ctx ? [span.ctx, ...args.slice(1)] : args;\n      try {\n        return await method.apply(this, callArgs);\n      } catch (err) {\n        span.markError(err);\n        throw err;\n      } finally {\n        span.markSuccess();\n      }\n    };\n  };\n\nconst spans = new Map<string, TracingSpan>();\n\n/**\n * Creates a span that must be ended manually.\n */\nconst spanStart = (params: TraceSpanParams & { id: string }) => {\n  if (spans.has(params.id)) {\n    return;\n  }\n\n  const span = TRACE_PROCESSOR.traceSpan(params);\n  spans.set(params.id, span);\n};\n\n/**\n * Ends a span that was started manually.\n */\nconst spanEnd = (id: string) => {\n  const span = spans.get(id);\n  if (span) {\n    span.markSuccess();\n    spans.delete(id);\n  }\n};\n\n/**\n * Attaches metrics counter to the resource.\n */\nconst metricsCounter = () => (target: any, propertyKey: string, descriptor?: PropertyDescriptor) => {\n  getTracingContext(target).metricsProperties[propertyKey] = {};\n};\n\nexport type AddLinkOptions = {};\n\nconst addLink = (parent: any, child: any, opts: AddLinkOptions = {}) => {\n  TRACE_PROCESSOR.addLink(parent, child, opts);\n};\n\nexport type TraceDiagnosticParams<T> = {\n  /**\n   * Unique ID.\n   */\n  id: string;\n\n  /**\n   * Human-readable name.\n   * @defaults Defaults to `id`\n   */\n  name?: string;\n\n  /**\n   * Function that will be called to fetch the diagnostic data.\n   */\n  fetch: () => MaybePromise<T>;\n};\n\nexport interface TraceDiagnostic {\n  id: string;\n  unregister(): void;\n}\n\n/**\n * Register a diagnostic that could be queried.\n */\nconst diagnostic = <T>(params: TraceDiagnosticParams<T>): TraceDiagnostic => {\n  return TRACE_PROCESSOR.diagnostics.registerDiagnostic(params);\n};\n\nexport const trace = {\n  addLink,\n  diagnostic,\n  info,\n  mark,\n  metricsCounter,\n  resource,\n  span,\n  spanStart,\n  spanEnd,\n  metrics: TRACE_PROCESSOR.remoteMetrics,\n};\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { type InfoOptions } from './api';\n\nexport const symbolTracingContext = Symbol('dxos.tracing.context');\n\nexport type TracingContext = {\n  infoProperties: Record<\n    string,\n    {\n      options: InfoOptions;\n    }\n  >;\n  metricsProperties: Record<string, {}>;\n};\n\nexport const getTracingContext = (target: any): TracingContext => {\n  return ((target[symbolTracingContext] as TracingContext | undefined) ??= {\n    infoProperties: {},\n    metricsProperties: {},\n  });\n};\n\nexport const TRACE_SPAN_ATTRIBUTE = 'dxos.trace-span';\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { unrefTimeout } from '@dxos/async';\nimport { type Context } from '@dxos/context';\nimport { LogLevel, type LogProcessor, getContextFromEntry, log } from '@dxos/log';\nimport { type LogEntry } from '@dxos/protocols/proto/dxos/client/services';\nimport { type Error as SerializedError } from '@dxos/protocols/proto/dxos/error';\nimport { type Metric, type Resource, type Span } from '@dxos/protocols/proto/dxos/tracing';\nimport { getPrototypeSpecificInstanceId } from '@dxos/util';\n\nimport type { AddLinkOptions, TimeAware } from './api';\nimport { DiagnosticsManager } from './diagnostic';\nimport { DiagnosticsChannel } from './diagnostics-channel';\nimport { type BaseCounter } from './metrics';\nimport { RemoteMetrics, RemoteTracing } from './remote';\nimport { TRACE_SPAN_ATTRIBUTE, getTracingContext } from './symbols';\nimport { TraceSender } from './trace-sender';\nimport { WeakRef } from './weak-ref';\n\nexport type Diagnostics = {\n  resources: Record<string, Resource>;\n  spans: Span[];\n  logs: LogEntry[];\n};\n\nexport type TraceResourceConstructorParams = {\n  constructor: { new (...args: any[]): {} };\n  instance: any;\n  annotation?: symbol;\n};\n\nexport type TraceSpanParams = {\n  instance: any;\n  // TODO(wittjosiah): Rename to `name`.\n  methodName: string;\n  parentCtx: Context | null;\n  showInBrowserTimeline: boolean;\n  op?: string;\n  attributes?: Record<string, any>;\n};\n\nexport class ResourceEntry {\n  /**\n   * Sometimes bundlers mangle class names: WebFile -> WebFile2.\n   *\n   * We use a heuristic to remove the suffix.\n   */\n  public readonly sanitizedClassName: string;\n\n  constructor(\n    public readonly data: Resource,\n    public readonly instance: WeakRef<any>,\n    public readonly annotation?: symbol,\n  ) {\n    this.sanitizedClassName = sanitizeClassName(data.className);\n  }\n\n  getMetric(name: string): Metric | undefined {\n    return this.data.metrics?.find((metric) => metric.name === name);\n  }\n}\n\nexport type TraceSubscription = {\n  flush: () => void;\n\n  dirtyResources: Set<number>;\n  dirtySpans: Set<number>;\n  newLogs: LogEntry[];\n};\n\nconst MAX_RESOURCE_RECORDS = 2_000;\nconst MAX_SPAN_RECORDS = 1_000;\nconst MAX_LOG_RECORDS = 1_000;\n\nconst REFRESH_INTERVAL = 1_000;\n\nconst MAX_INFO_OBJECT_DEPTH = 8;\n\nconst IS_CLOUDFLARE_WORKERS = !!globalThis?.navigator?.userAgent?.includes('Cloudflare-Workers');\n\nexport class TraceProcessor {\n  public readonly diagnostics = new DiagnosticsManager();\n  public readonly diagnosticsChannel = new DiagnosticsChannel();\n  public readonly remoteMetrics = new RemoteMetrics();\n  public readonly remoteTracing = new RemoteTracing();\n\n  readonly subscriptions: Set<TraceSubscription> = new Set();\n\n  readonly resources = new Map<number, ResourceEntry>();\n  readonly resourceInstanceIndex = new WeakMap<any, ResourceEntry>();\n  readonly resourceIdList: number[] = [];\n\n  readonly spans = new Map<number, Span>();\n  readonly spanIdList: number[] = [];\n\n  readonly logs: LogEntry[] = [];\n\n  private _instanceTag: string | null = null;\n\n  constructor() {\n    log.addProcessor(this._logProcessor.bind(this));\n\n    if (!IS_CLOUDFLARE_WORKERS) {\n      const refreshInterval = setInterval(this.refresh.bind(this), REFRESH_INTERVAL);\n      unrefTimeout(refreshInterval);\n    }\n\n    if (DiagnosticsChannel.supported) {\n      this.diagnosticsChannel.serve(this.diagnostics);\n    }\n    this.diagnosticsChannel.unref();\n  }\n\n  setInstanceTag(tag: string): void {\n    this._instanceTag = tag;\n    this.diagnostics.setInstanceTag(tag);\n  }\n\n  /**\n   * @internal\n   */\n  // TODO(burdon): Comment.\n  createTraceResource(params: TraceResourceConstructorParams): void {\n    const id = this.resources.size;\n\n    // Init metrics counters.\n    const tracingContext = getTracingContext(Object.getPrototypeOf(params.instance));\n    for (const key of Object.keys(tracingContext.metricsProperties)) {\n      (params.instance[key] as BaseCounter)._assign(params.instance, key);\n    }\n\n    const entry = new ResourceEntry(\n      {\n        id,\n        className: params.constructor.name,\n        instanceId: getPrototypeSpecificInstanceId(params.instance),\n        info: this.getResourceInfo(params.instance),\n        links: [],\n        metrics: this.getResourceMetrics(params.instance),\n      },\n      new WeakRef(params.instance),\n      params.annotation,\n    );\n\n    this.resources.set(id, entry);\n    this.resourceInstanceIndex.set(params.instance, entry);\n    this.resourceIdList.push(id);\n    if (this.resourceIdList.length > MAX_RESOURCE_RECORDS) {\n      this._clearResources();\n    }\n\n    this._markResourceDirty(id);\n  }\n\n  createTraceSender(): TraceSender {\n    return new TraceSender(this);\n  }\n\n  traceSpan(params: TraceSpanParams): TracingSpan {\n    const span = new TracingSpan(this, params);\n    this._flushSpan(span);\n    return span;\n  }\n\n  // TODO(burdon): Not implemented.\n  addLink(parent: any, child: any, opts: AddLinkOptions): void {}\n\n  //\n  // Getters\n  //\n\n  // TODO(burdon): Define type.\n  // TODO(burdon): Reconcile with system service.\n  getDiagnostics(): Diagnostics {\n    this.refresh();\n\n    return {\n      resources: Object.fromEntries(\n        Array.from(this.resources.entries()).map(([id, entry]) => [\n          `${entry.sanitizedClassName}#${entry.data.instanceId}`,\n          entry.data,\n        ]),\n      ),\n      spans: Array.from(this.spans.values()),\n      logs: this.logs.filter((log) => log.level >= LogLevel.INFO),\n    };\n  }\n\n  getResourceInfo(instance: any): Record<string, any> {\n    const res: Record<string, any> = {};\n    const tracingContext = getTracingContext(Object.getPrototypeOf(instance));\n    for (const [key, { options }] of Object.entries(tracingContext.infoProperties)) {\n      try {\n        const value = typeof instance[key] === 'function' ? instance[key]() : instance[key];\n        if (options.enum) {\n          res[key] = options.enum[value];\n        } else {\n          res[key] = sanitizeValue(\n            value,\n            options.depth === undefined ? 1 : options.depth ?? MAX_INFO_OBJECT_DEPTH,\n            this,\n          );\n        }\n      } catch (err: any) {\n        res[key] = err.message;\n      }\n    }\n\n    return res;\n  }\n\n  getResourceMetrics(instance: any): Metric[] {\n    const res: Metric[] = [];\n    const tracingContext = getTracingContext(Object.getPrototypeOf(instance));\n    for (const [key, _opts] of Object.entries(tracingContext.metricsProperties)) {\n      res.push(instance[key].getData());\n    }\n\n    return res;\n  }\n\n  getResourceId(instance: any): number | null {\n    const entry = this.resourceInstanceIndex.get(instance);\n    return entry ? entry.data.id : null;\n  }\n\n  findResourcesByClassName(className: string): ResourceEntry[] {\n    return [...this.resources.values()].filter(\n      (res) => res.data.className === className || res.sanitizedClassName === className,\n    );\n  }\n\n  findResourcesByAnnotation(annotation: symbol): ResourceEntry[] {\n    return [...this.resources.values()].filter((res) => res.annotation === annotation);\n  }\n\n  refresh(): void {\n    for (const resource of this.resources.values()) {\n      const instance = resource.instance.deref();\n      if (!instance) {\n        continue;\n      }\n\n      const tracingContext = getTracingContext(Object.getPrototypeOf(instance));\n      const time = performance.now();\n      (instance as TimeAware).tick?.(time);\n      for (const key of Object.keys(tracingContext.metricsProperties)) {\n        (instance[key] as BaseCounter)._tick?.(time);\n      }\n\n      let _changed = false;\n\n      const oldInfo = resource.data.info;\n      resource.data.info = this.getResourceInfo(instance);\n      _changed ||= !areEqualShallow(oldInfo, resource.data.info);\n\n      const oldMetrics = resource.data.metrics;\n      resource.data.metrics = this.getResourceMetrics(instance);\n      _changed ||= !areEqualShallow(oldMetrics, resource.data.metrics);\n\n      // TODO(dmaretskyi): Test if works and enable.\n      // if (changed) {\n      this._markResourceDirty(resource.data.id);\n      // }\n    }\n\n    for (const subscription of this.subscriptions) {\n      subscription.flush();\n    }\n  }\n\n  //\n  // Implementation\n  //\n\n  /**\n   * @internal\n   */\n  _flushSpan(runtimeSpan: TracingSpan): void {\n    const span = runtimeSpan.serialize();\n    this.spans.set(span.id, span);\n    this.spanIdList.push(span.id);\n    if (this.spanIdList.length > MAX_SPAN_RECORDS) {\n      this._clearSpans();\n    }\n    this._markSpanDirty(span.id);\n    this.remoteTracing.flushSpan(runtimeSpan);\n  }\n\n  private _markResourceDirty(id: number): void {\n    for (const subscription of this.subscriptions) {\n      subscription.dirtyResources.add(id);\n    }\n  }\n\n  private _markSpanDirty(id: number): void {\n    for (const subscription of this.subscriptions) {\n      subscription.dirtySpans.add(id);\n    }\n  }\n\n  private _clearResources(): void {\n    // TODO(dmaretskyi): Use FinalizationRegistry to delete finalized resources first.\n    while (this.resourceIdList.length > MAX_RESOURCE_RECORDS) {\n      const id = this.resourceIdList.shift()!;\n      this.resources.delete(id);\n    }\n  }\n\n  private _clearSpans(): void {\n    while (this.spanIdList.length > MAX_SPAN_RECORDS) {\n      const id = this.spanIdList.shift()!;\n      this.spans.delete(id);\n    }\n  }\n\n  private _pushLog(log: LogEntry): void {\n    this.logs.push(log);\n    if (this.logs.length > MAX_LOG_RECORDS) {\n      this.logs.shift();\n    }\n\n    for (const subscription of this.subscriptions) {\n      subscription.newLogs.push(log);\n    }\n  }\n\n  private _logProcessor: LogProcessor = (config, entry) => {\n    switch (entry.level) {\n      case LogLevel.ERROR:\n      case LogLevel.WARN:\n      case LogLevel.TRACE: {\n        const scope = entry.meta?.S;\n        const resource = this.resourceInstanceIndex.get(scope);\n        if (!resource) {\n          return;\n        }\n\n        const context = getContextFromEntry(entry) ?? {};\n        for (const key of Object.keys(context)) {\n          context[key] = sanitizeValue(context[key], 0, this);\n        }\n\n        const entryToPush: LogEntry = {\n          level: entry.level,\n          message: entry.message,\n          context,\n          timestamp: new Date(),\n          meta: {\n            file: entry.meta?.F ?? '',\n            line: entry.meta?.L ?? 0,\n            resourceId: resource.data.id,\n          },\n        };\n        this._pushLog(entryToPush);\n        break;\n      }\n      default:\n    }\n  };\n}\n\n// TODO(burdon): Comment.\nexport class TracingSpan {\n  static nextId = 0;\n\n  readonly id: number;\n  readonly parentId: number | null = null;\n  readonly methodName: string;\n  readonly resourceId: number | null = null;\n  readonly op: string | undefined;\n  readonly attributes: Record<string, any>;\n  startTs: number;\n  endTs: number | null = null;\n  error: SerializedError | null = null;\n\n  private _showInBrowserTimeline: boolean;\n  private readonly _ctx: Context | null = null;\n\n  constructor(\n    private _traceProcessor: TraceProcessor,\n    params: TraceSpanParams,\n  ) {\n    this.id = TracingSpan.nextId++;\n    this.methodName = params.methodName;\n    this.resourceId = _traceProcessor.getResourceId(params.instance);\n    this.startTs = performance.now();\n    this._showInBrowserTimeline = params.showInBrowserTimeline;\n    this.op = params.op;\n    this.attributes = params.attributes ?? {};\n\n    if (params.parentCtx) {\n      this._ctx = params.parentCtx.derive({\n        attributes: {\n          [TRACE_SPAN_ATTRIBUTE]: this.id,\n        },\n      });\n      const parentId = params.parentCtx.getAttribute(TRACE_SPAN_ATTRIBUTE);\n      if (typeof parentId === 'number') {\n        this.parentId = parentId;\n      }\n    }\n  }\n\n  get name() {\n    const resource = this._traceProcessor.resources.get(this.resourceId!);\n    return resource ? `${resource.sanitizedClassName}#${resource.data.instanceId}.${this.methodName}` : this.methodName;\n  }\n\n  get ctx(): Context | null {\n    return this._ctx;\n  }\n\n  markSuccess(): void {\n    this.endTs = performance.now();\n    this._traceProcessor._flushSpan(this);\n\n    if (this._showInBrowserTimeline) {\n      this._markInBrowserTimeline();\n    }\n  }\n\n  markError(err: unknown): void {\n    this.endTs = performance.now();\n    this.error = serializeError(err);\n    this._traceProcessor._flushSpan(this);\n\n    if (this._showInBrowserTimeline) {\n      this._markInBrowserTimeline();\n    }\n  }\n\n  serialize(): Span {\n    return {\n      id: this.id,\n      resourceId: this.resourceId ?? undefined,\n      methodName: this.methodName,\n      parentId: this.parentId ?? undefined,\n      startTs: this.startTs.toFixed(3),\n      endTs: this.endTs?.toFixed(3) ?? undefined,\n      error: this.error ?? undefined,\n    };\n  }\n\n  private _markInBrowserTimeline(): void {\n    if (typeof globalThis?.performance?.measure === 'function') {\n      performance.measure(this.name, { start: this.startTs, end: this.endTs! });\n    }\n  }\n}\n\n// TODO(burdon): Log cause.\nconst serializeError = (err: unknown): SerializedError => {\n  if (err instanceof Error) {\n    return {\n      name: err.name,\n      message: err.message,\n    };\n  }\n\n  return {\n    message: String(err),\n  };\n};\n\n// TODO(burdon): Rename singleton and move out of package.\nexport const TRACE_PROCESSOR: TraceProcessor = ((globalThis as any).TRACE_PROCESSOR ??= new TraceProcessor());\n\nconst sanitizeValue = (value: any, depth: number, traceProcessor: TraceProcessor): any => {\n  switch (typeof value) {\n    case 'string':\n    case 'number':\n    case 'boolean':\n    case 'undefined':\n      return value;\n    case 'object':\n    case 'function':\n      if (value === null) {\n        return value;\n      }\n\n      {\n        const resourceEntry = traceProcessor.resourceInstanceIndex.get(value);\n        if (resourceEntry) {\n          return `${resourceEntry.sanitizedClassName}#${resourceEntry.data.instanceId}`;\n        }\n      }\n\n      if (typeof value.toJSON === 'function') {\n        // TODO(dmaretskyi): This has potential to cause infinite recursion.\n        return sanitizeValue(value.toJSON(), depth, traceProcessor);\n      }\n\n      if (depth > 0) {\n        if (isSetLike(value)) {\n          return Object.fromEntries(\n            Array.from(value.entries()).map((value) => sanitizeValue(value, depth - 1, traceProcessor)),\n          );\n        } else if (isMapLike(value)) {\n          return Object.fromEntries(\n            Array.from(value.entries()).map(([key, value]) => [key, sanitizeValue(value, depth - 1, traceProcessor)]),\n          );\n        } else if (Array.isArray(value)) {\n          return value.map((item: any) => sanitizeValue(item, depth - 1, traceProcessor));\n        } else if (typeof value === 'object') {\n          const res: any = {};\n          for (const key of Object.keys(value)) {\n            res[key] = sanitizeValue(value[key], depth - 1, traceProcessor);\n          }\n          return res;\n        }\n      }\n\n      // TODO(dmaretskyi): Expose trait.\n      if (typeof value.truncate === 'function') {\n        return value.truncate();\n      }\n\n      return value.toString();\n  }\n};\n\nconst areEqualShallow = (a: any, b: any) => {\n  for (const key in a) {\n    if (!(key in b) || a[key] !== b[key]) {\n      return false;\n    }\n  }\n  for (const key in b) {\n    if (!(key in a) || a[key] !== b[key]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nexport const sanitizeClassName = (className: string) => {\n  const SANITIZE_REGEX = /[^_](\\d+)$/;\n  const m = className.match(SANITIZE_REGEX);\n  if (!m) {\n    return className;\n  } else {\n    return className.slice(0, -m[1].length);\n  }\n};\n\nconst isSetLike = (value: any): value is Set<any> =>\n  value instanceof Set ||\n  (typeof value === 'object' && value !== null && Object.getPrototypeOf(value).constructor.name === 'ComplexSet');\n\nconst isMapLike = (value: any): value is Map<any, any> =>\n  value instanceof Map ||\n  (typeof value === 'object' && value !== null && Object.getPrototypeOf(value).constructor.name === 'ComplexMap');\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { asyncTimeout } from '@dxos/async';\nimport { invariant } from '@dxos/invariant';\n\nimport { type TraceDiagnosticParams, type TraceDiagnostic } from './api';\nimport { createId } from './util';\n\nexport const DIAGNOSTICS_TIMEOUT = 10_000;\n\nexport type DiagnosticMetadata = {\n  id: string;\n  instanceId: string;\n  instanceTag: string | null;\n  name: string;\n};\n\nexport type DiagnosticsRequest = {\n  id: string;\n  instanceId?: string;\n  instanceTag?: string | null;\n};\n\nexport type DiagnosticsData = {\n  id: string;\n  instanceId: string;\n  data: any;\n  error?: string;\n};\n\nexport class TraceDiagnosticImpl implements TraceDiagnostic {\n  constructor(\n    public id: string,\n    public fetch: () => any,\n    public name: string,\n    private readonly _onUnregister: () => void,\n  ) {}\n\n  unregister(): void {\n    this._onUnregister();\n  }\n}\n\nexport class DiagnosticsManager {\n  readonly instanceId = createId();\n\n  readonly registry = new Map<string, TraceDiagnosticImpl>();\n\n  private _instanceTag: string | null = null;\n\n  get instanceTag(): string | null {\n    return this._instanceTag;\n  }\n\n  setInstanceTag(tag: string): void {\n    this._instanceTag = tag;\n  }\n\n  registerDiagnostic(params: TraceDiagnosticParams<any>): TraceDiagnostic {\n    const impl = new TraceDiagnosticImpl(params.id, params.fetch, params.name ?? params.id, () => {\n      if (this.registry.get(params.id) === impl) {\n        this.registry.delete(params.id);\n      }\n    });\n    this.registry.set(params.id, impl);\n    return impl;\n  }\n\n  list(): DiagnosticMetadata[] {\n    return Array.from(this.registry.values()).map((diagnostic) => ({\n      id: diagnostic.id,\n      instanceId: this.instanceId,\n      instanceTag: this._instanceTag,\n      name: diagnostic.name,\n    }));\n  }\n\n  async fetch(request: DiagnosticsRequest): Promise<DiagnosticsData> {\n    if (request.instanceId != null) {\n      invariant(request.instanceId === this.instanceId, 'Invalid instance id');\n    }\n    const { id } = request;\n    const diagnostic = this.registry.get(id);\n    invariant(diagnostic, 'Diagnostic not found');\n    try {\n      const data = await asyncTimeout(diagnostic.fetch(), DIAGNOSTICS_TIMEOUT);\n      return {\n        id,\n        instanceId: this.instanceId,\n        data,\n      };\n    } catch (err: any) {\n      return {\n        id,\n        instanceId: this.instanceId,\n        data: null,\n        error: err.stack,\n      };\n    }\n  }\n}\n", "// TODO(dmaretskyi): Use UUID.\n//\n// Copyright 2024 DXOS.org\n//\n\nexport const createId = () => Math.random().toString(36).slice(2);\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { Trigger, sleep } from '@dxos/async';\nimport { Context } from '@dxos/context';\nimport { invariant } from '@dxos/invariant';\n\nimport {\n  DIAGNOSTICS_TIMEOUT,\n  type DiagnosticMetadata,\n  type DiagnosticsData,\n  type DiagnosticsManager,\n  type DiagnosticsRequest,\n} from './diagnostic';\nimport { createId } from './util';\n\nconst DEFAULT_CHANNEL_NAME = 'dxos-diagnostics';\n\nconst DISCOVER_TIME = 500;\n\nexport type DiagnosticChannelMessage =\n  | {\n      type: 'DIAGNOSTICS_DISCOVER';\n    }\n  | {\n      type: 'DIAGNOSTICS_ANNOUNCE';\n      diagnostics: DiagnosticMetadata[];\n    }\n  | {\n      type: 'DIAGNOSTICS_FETCH';\n      requestId: string;\n      request: DiagnosticsRequest;\n    }\n  | {\n      type: 'DIAGNOSTICS_RESPONSE';\n      requestId: string;\n      data: DiagnosticsData;\n    };\n\nexport class DiagnosticsChannel {\n  static get supported() {\n    return globalThis.BroadcastChannel != null;\n  }\n\n  private _ctx = new Context();\n\n  // Separate channels becauase the client and server may be in the same process.\n  private readonly _serveChannel?: BroadcastChannel = undefined;\n  private readonly _clientChannel?: BroadcastChannel = undefined;\n\n  constructor(private readonly _channelName: string = DEFAULT_CHANNEL_NAME) {\n    if (DiagnosticsChannel.supported) {\n      this._serveChannel = new BroadcastChannel(_channelName);\n      this._clientChannel = new BroadcastChannel(_channelName);\n    }\n  }\n\n  destroy(): void {\n    void this._ctx.dispose();\n    this._serveChannel?.close();\n    this._clientChannel?.close();\n  }\n\n  /**\n   * In node.js, the channel will keep the process alive.\n   * This method allows the process to exit.\n   * Noop in the browser.\n   */\n  unref(): void {\n    if (this._serveChannel && typeof (this._serveChannel as any).unref === 'function') {\n      (this._serveChannel as any).unref();\n      (this._clientChannel as any).unref();\n    }\n  }\n\n  serve(manager: DiagnosticsManager): void {\n    invariant(this._serveChannel);\n    const listener = async (event: MessageEvent) => {\n      switch (event.data.type) {\n        case 'DIAGNOSTICS_DISCOVER': {\n          const diagnostics = manager.list();\n          this._serveChannel!.postMessage({\n            type: 'DIAGNOSTICS_ANNOUNCE',\n            diagnostics,\n          } satisfies DiagnosticChannelMessage);\n          break;\n        }\n        case 'DIAGNOSTICS_FETCH': {\n          const { requestId, request } = event.data;\n\n          if (request.instanceId != null && request.instanceId !== manager.instanceId) {\n            break;\n          } else if (request.instanceTag != null && request.instanceTag !== manager.instanceTag) {\n            break;\n          }\n\n          const data = await manager.fetch(request);\n          this._serveChannel!.postMessage({\n            type: 'DIAGNOSTICS_RESPONSE',\n            requestId,\n            data,\n          } satisfies DiagnosticChannelMessage);\n          break;\n        }\n      }\n    };\n\n    this._serveChannel.addEventListener('message', listener);\n    this._ctx.onDispose(() => this._serveChannel!.removeEventListener('message', listener));\n  }\n\n  async discover(): Promise<DiagnosticMetadata[]> {\n    invariant(this._clientChannel);\n    const diagnostics: DiagnosticMetadata[] = [];\n\n    const collector = (event: MessageEvent) => {\n      const data = event.data as DiagnosticChannelMessage;\n      switch (data.type) {\n        case 'DIAGNOSTICS_ANNOUNCE':\n          diagnostics.push(...data.diagnostics);\n          break;\n      }\n    };\n\n    try {\n      this._clientChannel.addEventListener('message', collector);\n      this._clientChannel.postMessage({ type: 'DIAGNOSTICS_DISCOVER' } satisfies DiagnosticChannelMessage);\n\n      await sleep(DISCOVER_TIME);\n\n      // Dedup.\n      const result: DiagnosticMetadata[] = [];\n      for (const diagnostic of diagnostics) {\n        if (!result.some((d) => d.id === diagnostic.id && d.instanceId === diagnostic.instanceId)) {\n          result.push(diagnostic);\n        }\n      }\n\n      return diagnostics;\n    } finally {\n      this._clientChannel.removeEventListener('message', collector);\n    }\n  }\n\n  async fetch(request: DiagnosticsRequest): Promise<DiagnosticsData> {\n    invariant(this._clientChannel);\n    const requestId = createId();\n\n    const trigger = new Trigger<DiagnosticsData>();\n    const listener = (event: MessageEvent) => {\n      const data = event.data as DiagnosticChannelMessage;\n      if (data.type === 'DIAGNOSTICS_RESPONSE' && data.requestId === requestId) {\n        trigger.wake(data.data);\n      }\n    };\n\n    try {\n      this._clientChannel.addEventListener('message', listener);\n      this._clientChannel.postMessage({\n        type: 'DIAGNOSTICS_FETCH',\n        requestId,\n        request,\n      } satisfies DiagnosticChannelMessage);\n\n      // NOTE: Must have await keyword in this block.\n      const result = await trigger.wait({ timeout: DIAGNOSTICS_TIMEOUT });\n\n      return result;\n    } finally {\n      this._clientChannel.removeEventListener('message', listener);\n    }\n  }\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\ntype TagType = number | string | boolean | null | undefined;\n\nexport interface MetricData {\n  unit?: string;\n  tags?: Record<string, TagType>;\n  timestamp?: number;\n}\n\ninterface MetricsMethods {\n  /**\n   * Adds a value to a counter metric\n   */\n  increment(name: string, value?: number, data?: MetricData): void;\n  /**\n   * Adds a value to a distribution metric\n   */\n  distribution(name: string, value: number, data?: MetricData): void;\n  /**\n   * Adds a value to a set metric. Value must be a string or integer.\n   */\n  set(name: string, value: number | string, data?: MetricData): void;\n  /**\n   * Adds a value to a gauge metric\n   */\n  gauge(name: string, value: number, data?: MetricData): void;\n}\n\n/**\n * Allows metrics to be recorded within SDK code without requiring specific consumers.\n */\nexport class RemoteMetrics implements MetricsMethods {\n  private _metrics = new Set<MetricsMethods>();\n\n  registerProcessor(processor: MetricsMethods): void {\n    this._metrics.add(processor);\n  }\n\n  increment(name: string, value?: number, data?: MetricData): void[] {\n    return Array.from(this._metrics.values()).map((processor) => processor.increment(name, value, data));\n  }\n\n  distribution(name: string, value: number, data?: MetricData): void[] {\n    return Array.from(this._metrics.values()).map((processor) => processor.distribution(name, value, data));\n  }\n\n  set(name: string, value: number | string, data?: MetricData): void[] {\n    return Array.from(this._metrics.values()).map((processor) => processor.set(name, value, data));\n  }\n\n  gauge(name: string, value: number, data?: MetricData): void[] {\n    return Array.from(this._metrics.values()).map((processor) => processor.gauge(name, value, data));\n  }\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { type TracingSpan } from '../trace-processor';\n\ntype RemoteSpan = {\n  end: () => void;\n};\n\nexport type StartSpanOptions = {\n  name: string;\n  op?: string;\n  attributes?: Record<string, any>;\n};\n\ninterface TracingMethods {\n  startSpan: (options: StartSpanOptions) => RemoteSpan;\n}\n\n/**\n * Allows traces to be recorded within SDK code without requiring specific consumers.\n */\n// TODO(wittjosiah): Should probably just use otel. Use `any` for now to not depend on Sentry directly.\nexport class RemoteTracing {\n  private _tracing: TracingMethods | undefined;\n  private _spanMap = new Map<TracingSpan, RemoteSpan>();\n\n  registerProcessor(processor: TracingMethods): void {\n    this._tracing = processor;\n  }\n\n  flushSpan(span: TracingSpan): void {\n    if (!this._tracing) {\n      return;\n    }\n\n    if (!span.endTs) {\n      const remoteSpan = this._tracing.startSpan({\n        name: span.methodName,\n        op: span.op ?? 'function',\n        attributes: span.attributes,\n      });\n      this._spanMap.set(span, remoteSpan);\n    } else {\n      const remoteSpan = this._spanMap.get(span);\n      if (remoteSpan) {\n        remoteSpan.end();\n        this._spanMap.delete(span);\n      }\n    }\n  }\n}\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { Stream } from '@dxos/codec-protobuf/stream';\nimport { type LogEntry } from '@dxos/protocols/proto/dxos/client/services';\nimport { type StreamTraceEvent, type TracingService } from '@dxos/protocols/proto/dxos/tracing';\n\nimport { type TraceProcessor, type TraceSubscription } from './trace-processor';\n\nexport class TraceSender implements TracingService {\n  constructor(private _traceProcessor: TraceProcessor) {}\n\n  streamTrace(request: void): Stream<StreamTraceEvent> {\n    return new Stream(({ ctx, next }) => {\n      const flushEvents = (resources: Set<number> | null, spans: Set<number> | null, logs: LogEntry[] | null) => {\n        const event: StreamTraceEvent = {\n          resourceAdded: [],\n          resourceRemoved: [],\n          spanAdded: [],\n          logAdded: [],\n        };\n\n        if (resources) {\n          for (const id of resources) {\n            const entry = this._traceProcessor.resources.get(id);\n            if (entry) {\n              event.resourceAdded!.push({ resource: entry.data });\n            } else {\n              event.resourceRemoved!.push({ id });\n            }\n          }\n        } else {\n          for (const entry of this._traceProcessor.resources.values()) {\n            event.resourceAdded!.push({ resource: entry.data });\n          }\n        }\n\n        if (spans) {\n          for (const id of spans) {\n            const span = this._traceProcessor.spans.get(id);\n            if (span) {\n              event.spanAdded!.push({ span });\n            }\n          }\n        } else {\n          for (const span of this._traceProcessor.spans.values()) {\n            event.spanAdded!.push({ span });\n          }\n        }\n\n        if (logs) {\n          for (const log of logs) {\n            event.logAdded!.push({ log });\n          }\n        } else {\n          for (const log of this._traceProcessor.logs) {\n            event.logAdded!.push({ log });\n          }\n        }\n\n        if (event.resourceAdded!.length > 0 || event.resourceRemoved!.length > 0 || event.spanAdded!.length > 0) {\n          next(event);\n        }\n      };\n\n      const flush = () => {\n        flushEvents(subscription.dirtyResources, subscription.dirtySpans, subscription.newLogs);\n        subscription.dirtyResources.clear();\n        subscription.dirtySpans.clear();\n        subscription.newLogs.length = 0;\n      };\n\n      const subscription: TraceSubscription = {\n        flush,\n        dirtyResources: new Set(),\n        dirtySpans: new Set(),\n        newLogs: [],\n      };\n      this._traceProcessor.subscriptions.add(subscription);\n      ctx.onDispose(() => {\n        this._traceProcessor.subscriptions.delete(subscription);\n      });\n\n      flushEvents(null, null, null);\n    });\n  }\n}\n", "// Workerd does not support WeakRef\n\n//\n// Copyright 2024 DXOS.org\n//\n\nclass WeakRefMock<T> {\n  // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n  constructor(target: T) {\n    // do nothing\n  }\n\n  deref(): T | undefined {\n    return undefined;\n  }\n}\n\nexport const WeakRef = globalThis.WeakRef ?? WeakRefMock;\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { type Metric } from '@dxos/protocols/proto/dxos/tracing';\n\nexport abstract class BaseCounter {\n  /**\n   * @internal\n   */\n  _instance: any;\n\n  name?: string;\n\n  /**\n   * @internal\n   */\n  _assign(instance: any, name: string): void {\n    this._instance = instance;\n    this.name = name;\n  }\n\n  abstract getData(): Metric;\n\n  _tick(time: number): void {}\n}\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { type Metric } from '@dxos/protocols/proto/dxos/tracing';\n\nimport { BaseCounter } from './base';\n\nexport class UnaryCounter extends BaseCounter {\n  value = 0;\n  units?: string;\n\n  constructor({ units }: { units?: string } = {}) {\n    super();\n    this.units = units;\n  }\n\n  inc(by = 1): void {\n    this.value += by;\n  }\n\n  getData(): Metric {\n    return {\n      name: this.name!,\n      counter: {\n        value: this.value,\n        units: this.units,\n      },\n    };\n  }\n}\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { type Metric } from '@dxos/protocols/proto/dxos/tracing';\n\nimport { BaseCounter } from './base';\n\nconst MAX_BUCKETS = 60;\n\nexport class TimeSeriesCounter extends BaseCounter {\n  private _currentValue = 0;\n  private _totalValue = 0;\n  private _buckets: number[] = [];\n  units?: string;\n\n  constructor({ units }: { units?: string } = {}) {\n    super();\n    this.units = units;\n  }\n\n  inc(by = 1): void {\n    this._currentValue += by;\n    this._totalValue += by;\n  }\n\n  override _tick(time: number): void {\n    this._buckets.push(this._currentValue);\n    if (this._buckets.length > MAX_BUCKETS) {\n      this._buckets.shift();\n    }\n    this._currentValue = 0;\n  }\n\n  override getData(): Metric {\n    return {\n      name: this.name!,\n      timeSeries: {\n        tracks: [\n          {\n            name: this.name!,\n            units: this.units,\n            points: this._buckets.map((value, index) => ({\n              value,\n            })),\n            total: this._totalValue,\n          },\n        ],\n      },\n    };\n  }\n}\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { type Metric } from '@dxos/protocols/proto/dxos/tracing';\n\nimport { BaseCounter } from './base';\n\nconst MAX_BUCKETS = 60;\n\nexport class TimeUsageCounter extends BaseCounter {\n  private _currentValue = 0;\n  private _totalValue = 0;\n  private _buckets: number[] = [];\n\n  private _lastTickTime = performance.now();\n\n  record(time: number): void {\n    this._currentValue += time;\n    this._totalValue += time;\n  }\n\n  beginRecording(): { end: () => void } {\n    const start = performance.now();\n    return {\n      end: () => {\n        const end = performance.now();\n        this.record(end - start);\n      },\n    };\n  }\n\n  override _tick(time: number): void {\n    const delta = time - this._lastTickTime;\n    this._lastTickTime = time;\n\n    const percentage = (this._currentValue / delta) * 100;\n    this._buckets.push(percentage);\n    if (this._buckets.length > MAX_BUCKETS) {\n      this._buckets.shift();\n    }\n    this._currentValue = 0;\n  }\n\n  override getData(): Metric {\n    return {\n      name: this.name!,\n      timeSeries: {\n        tracks: [\n          {\n            name: this.name!,\n            units: '%',\n            points: this._buckets.map((value, index) => ({\n              value,\n            })),\n            total: this._totalValue,\n          },\n        ],\n      },\n    };\n  }\n}\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { type Metric } from '@dxos/protocols/proto/dxos/tracing';\n\nimport { BaseCounter } from './base';\n\nexport class MapCounter extends BaseCounter {\n  values = new Map<string, number>();\n  units?: string;\n\n  constructor({ units }: { units?: string } = {}) {\n    super();\n    this.units = units;\n  }\n\n  inc(key: string, by = 1): void {\n    const prev = this.values.get(key) ?? 0;\n    this.values.set(key, prev + by);\n  }\n\n  getData(): Metric {\n    return {\n      name: this.name!,\n      multiCounter: {\n        records: Array.from(this.values.entries()).map(([key, value]) => ({\n          key,\n          value,\n        })),\n        units: this.units,\n      },\n    };\n  }\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { type Metric } from '@dxos/protocols/proto/dxos/tracing';\n\nimport { BaseCounter } from './base';\n\nexport class CustomCounter extends BaseCounter {\n  constructor(private readonly _getData: () => object) {\n    super();\n  }\n\n  override getData(): Metric {\n    return {\n      name: this.name!,\n      custom: {\n        payload: this._getData(),\n      },\n    };\n  }\n}\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { trace } from './api';\n\nexport * from './api';\nexport * from './symbols';\nexport * from './trace-processor';\nexport * from './trace-sender';\nexport * from './metrics';\nexport * from './diagnostic';\nexport * from './diagnostics-channel';\nexport * from './remote/tracing';\nexport * from './remote/metrics';\n\ntrace.diagnostic({\n  id: 'process-info',\n  name: 'Process Info',\n  fetch: async () => {\n    return {\n      platform: globalThis.process?.platform,\n      arch: globalThis.process?.arch,\n      versions: globalThis.process?.versions,\n      href: globalThis.location?.href,\n    };\n  },\n});\n"],
  "mappings": "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",
  "names": ["Context", "symbolTracingContext", "Symbol", "getTracingContext", "target", "infoProperties", "metricsProperties", "TRACE_SPAN_ATTRIBUTE", "unrefTimeout", "LogLevel", "getContextFromEntry", "log", "getPrototypeSpecificInstanceId", "asyncTimeout", "invariant", "createId", "Math", "random", "toString", "slice", "DIAGNOSTICS_TIMEOUT", "TraceDiagnosticImpl", "id", "fetch", "name", "_onUnregister", "unregister", "DiagnosticsManager", "instanceId", "createId", "registry", "Map", "_instanceTag", "instanceTag", "setInstanceTag", "tag", "registerDiagnostic", "params", "impl", "get", "delete", "set", "list", "Array", "from", "values", "map", "diagnostic", "request", "invariant", "data", "asyncTimeout", "err", "error", "stack", "Trigger", "sleep", "Context", "invariant", "DEFAULT_CHANNEL_NAME", "DISCOVER_TIME", "DiagnosticsChannel", "supported", "globalThis", "BroadcastChannel", "_channelName", "_ctx", "Context", "_serveChannel", "undefined", "_clientChannel", "destroy", "dispose", "close", "unref", "serve", "manager", "invariant", "listener", "event", "data", "type", "diagnostics", "list", "postMessage", "requestId", "request", "instanceId", "instanceTag", "fetch", "addEventListener", "onDispose", "removeEventListener", "discover", "collector", "push", "sleep", "result", "diagnostic", "some", "d", "id", "createId", "trigger", "Trigger", "wake", "wait", "timeout", "DIAGNOSTICS_TIMEOUT", "RemoteMetrics", "_metrics", "Set", "registerProcessor", "processor", "add", "increment", "name", "value", "data", "Array", "from", "values", "map", "distribution", "set", "gauge", "RemoteTracing", "_spanMap", "Map", "registerProcessor", "processor", "_tracing", "flushSpan", "span", "endTs", "remoteSpan", "startSpan", "name", "methodName", "op", "attributes", "set", "get", "end", "delete", "Stream", "TraceSender", "_traceProcessor", "streamTrace", "request", "Stream", "ctx", "next", "flushEvents", "resources", "spans", "logs", "event", "resourceAdded", "resourceRemoved", "spanAdded", "logAdded", "id", "entry", "get", "push", "resource", "data", "values", "span", "log", "length", "flush", "subscription", "dirtyResources", "dirtySpans", "newLogs", "clear", "Set", "subscriptions", "add", "onDispose", "delete", "WeakRefMock", "target", "deref", "undefined", "WeakRef", "globalThis", "ResourceEntry", "data", "instance", "annotation", "sanitizedClassName", "sanitizeClassName", "className", "getMetric", "name", "metrics", "find", "metric", "MAX_RESOURCE_RECORDS", "MAX_SPAN_RECORDS", "MAX_LOG_RECORDS", "REFRESH_INTERVAL", "MAX_INFO_OBJECT_DEPTH", "IS_CLOUDFLARE_WORKERS", "globalThis", "navigator", "userAgent", "includes", "TraceProcessor", "diagnostics", "DiagnosticsManager", "diagnosticsChannel", "DiagnosticsChannel", "remoteMetrics", "RemoteMetrics", "remoteTracing", "RemoteTracing", "subscriptions", "Set", "resources", "Map", "resourceInstanceIndex", "WeakMap", "resourceIdList", "spans", "spanIdList", "logs", "_instanceTag", "_logProcessor", "config", "entry", "level", "LogLevel", "ERROR", "WARN", "TRACE", "scope", "meta", "S", "resource", "get", "context", "getContextFromEntry", "key", "Object", "keys", "sanitizeValue", "entryToPush", "message", "timestamp", "Date", "file", "F", "line", "L", "resourceId", "id", "_pushLog", "log", "addProcessor", "bind", "refreshInterval", "setInterval", "refresh", "unrefTimeout", "supported", "serve", "unref", "setInstanceTag", "tag", "createTraceResource", "params", "size", "tracingContext", "getTracingContext", "getPrototypeOf", "metricsProperties", "_assign", "instanceId", "getPrototypeSpecificInstanceId", "info", "getResourceInfo", "links", "getResourceMetrics", "WeakRef", "set", "push", "length", "_clearResources", "_markResourceDirty", "createTraceSender", "TraceSender", "traceSpan", "span", "TracingSpan", "_flushSpan", "addLink", "parent", "child", "opts", "getDiagnostics", "fromEntries", "Array", "from", "entries", "map", "values", "filter", "INFO", "res", "options", "infoProperties", "value", "enum", "depth", "undefined", "err", "_opts", "getData", "getResourceId", "findResourcesByClassName", "findResourcesByAnnotation", "deref", "time", "performance", "now", "tick", "_tick", "_changed", "oldInfo", "areEqualShallow", "oldMetrics", "subscription", "flush", "runtimeSpan", "serialize", "_clearSpans", "_markSpanDirty", "flushSpan", "dirtyResources", "add", "dirtySpans", "shift", "delete", "newLogs", "nextId", "_traceProcessor", "parentId", "endTs", "error", "_ctx", "methodName", "startTs", "_showInBrowserTimeline", "showInBrowserTimeline", "op", "attributes", "parentCtx", "derive", "TRACE_SPAN_ATTRIBUTE", "getAttribute", "ctx", "markSuccess", "_markInBrowserTimeline", "markError", "serializeError", "toFixed", "measure", "start", "end", "Error", "String", "TRACE_PROCESSOR", "traceProcessor", "resourceEntry", "toJSON", "isSetLike", "isMapLike", "isArray", "item", "truncate", "toString", "a", "b", "SANITIZE_REGEX", "m", "match", "slice", "resource", "options", "constructor", "klass", "rest", "TRACE_PROCESSOR", "createTraceResource", "annotation", "instance", "Object", "defineProperty", "value", "name", "info", "opts", "target", "propertyKey", "descriptor", "getTracingContext", "infoProperties", "mark", "performance", "span", "showInBrowserTimeline", "op", "attributes", "method", "args", "parentCtx", "Context", "traceSpan", "methodName", "callArgs", "ctx", "slice", "apply", "err", "markError", "markSuccess", "spans", "Map", "spanStart", "params", "has", "id", "set", "spanEnd", "get", "delete", "metricsCounter", "metricsProperties", "addLink", "parent", "child", "diagnostic", "diagnostics", "registerDiagnostic", "trace", "metrics", "remoteMetrics", "BaseCounter", "_assign", "instance", "name", "_instance", "_tick", "time", "UnaryCounter", "BaseCounter", "units", "value", "inc", "by", "getData", "name", "counter", "MAX_BUCKETS", "TimeSeriesCounter", "BaseCounter", "units", "_currentValue", "_totalValue", "_buckets", "inc", "by", "_tick", "time", "push", "length", "shift", "getData", "name", "timeSeries", "tracks", "points", "map", "value", "index", "total", "MAX_BUCKETS", "TimeUsageCounter", "BaseCounter", "_currentValue", "_totalValue", "_buckets", "_lastTickTime", "performance", "now", "record", "time", "beginRecording", "start", "end", "_tick", "delta", "percentage", "push", "length", "shift", "getData", "name", "timeSeries", "tracks", "units", "points", "map", "value", "index", "total", "MapCounter", "BaseCounter", "units", "values", "Map", "inc", "key", "by", "prev", "get", "set", "getData", "name", "multiCounter", "records", "Array", "from", "entries", "map", "value", "CustomCounter", "BaseCounter", "_getData", "getData", "name", "custom", "payload", "trace", "diagnostic", "id", "name", "fetch", "platform", "globalThis", "process", "arch", "versions", "href", "location"]
}
