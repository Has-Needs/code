import { type Context } from '@dxos/context';
import { type LogEntry } from '@dxos/protocols/proto/dxos/client/services';
import { type Error as SerializedError } from '@dxos/protocols/proto/dxos/error';
import { type Metric, type Resource, type Span } from '@dxos/protocols/proto/dxos/tracing';
import type { AddLinkOptions } from './api';
import { DiagnosticsManager } from './diagnostic';
import { DiagnosticsChannel } from './diagnostics-channel';
import { RemoteMetrics, RemoteTracing } from './remote';
import { TraceSender } from './trace-sender';
export type Diagnostics = {
    resources: Record<string, Resource>;
    spans: Span[];
    logs: LogEntry[];
};
export type TraceResourceConstructorParams = {
    constructor: {
        new (...args: any[]): {};
    };
    instance: any;
    annotation?: symbol;
};
export type TraceSpanParams = {
    instance: any;
    methodName: string;
    parentCtx: Context | null;
    showInBrowserTimeline: boolean;
    op?: string;
    attributes?: Record<string, any>;
};
export declare class ResourceEntry {
    readonly data: Resource;
    readonly instance: WeakRef<any>;
    readonly annotation?: symbol | undefined;
    /**
     * Sometimes bundlers mangle class names: WebFile -> WebFile2.
     *
     * We use a heuristic to remove the suffix.
     */
    readonly sanitizedClassName: string;
    constructor(data: Resource, instance: WeakRef<any>, annotation?: symbol | undefined);
    getMetric(name: string): Metric | undefined;
}
export type TraceSubscription = {
    flush: () => void;
    dirtyResources: Set<number>;
    dirtySpans: Set<number>;
    newLogs: LogEntry[];
};
export declare class TraceProcessor {
    readonly diagnostics: DiagnosticsManager;
    readonly diagnosticsChannel: DiagnosticsChannel;
    readonly remoteMetrics: RemoteMetrics;
    readonly remoteTracing: RemoteTracing;
    readonly subscriptions: Set<TraceSubscription>;
    readonly resources: Map<number, ResourceEntry>;
    readonly resourceInstanceIndex: WeakMap<any, ResourceEntry>;
    readonly resourceIdList: number[];
    readonly spans: Map<number, Span>;
    readonly spanIdList: number[];
    readonly logs: LogEntry[];
    private _instanceTag;
    constructor();
    setInstanceTag(tag: string): void;
    createTraceSender(): TraceSender;
    traceSpan(params: TraceSpanParams): TracingSpan;
    addLink(parent: any, child: any, opts: AddLinkOptions): void;
    getDiagnostics(): Diagnostics;
    getResourceInfo(instance: any): Record<string, any>;
    getResourceMetrics(instance: any): Metric[];
    getResourceId(instance: any): number | null;
    findResourcesByClassName(className: string): ResourceEntry[];
    findResourcesByAnnotation(annotation: symbol): ResourceEntry[];
    refresh(): void;
    private _markResourceDirty;
    private _markSpanDirty;
    private _clearResources;
    private _clearSpans;
    private _pushLog;
    private _logProcessor;
}
export declare class TracingSpan {
    private _traceProcessor;
    static nextId: number;
    readonly id: number;
    readonly parentId: number | null;
    readonly methodName: string;
    readonly resourceId: number | null;
    readonly op: string | undefined;
    readonly attributes: Record<string, any>;
    startTs: number;
    endTs: number | null;
    error: SerializedError | null;
    private _showInBrowserTimeline;
    private readonly _ctx;
    constructor(_traceProcessor: TraceProcessor, params: TraceSpanParams);
    get name(): string;
    get ctx(): Context | null;
    markSuccess(): void;
    markError(err: unknown): void;
    serialize(): Span;
    private _markInBrowserTimeline;
}
export declare const TRACE_PROCESSOR: TraceProcessor;
export declare const sanitizeClassName: (className: string) => string;
//# sourceMappingURL=trace-processor.d.ts.map