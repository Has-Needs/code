/**
 * Returns a tuple containing a Promise that will be resolved when the resolver function is called.
 * @deprecated Use `Trigger` instead.
 */
export declare const trigger: <T = void>(timeout?: number) => [() => Promise<T>, (arg: T) => void];
export type TriggerOptions = {
    autoReset: boolean;
};
export declare enum TriggerState {
    WAITING = "WAITING",
    RESOLVED = "RESOLVED",
    REJECTED = "REJECTED"
}
/**
 * Enables blocked listeners to be awakened with optional timeouts.
 *
 * Has two states:
 * - WAITING: promise is in pending state and will be resolved once `wake()` is called.
 * - RESOLVED: promise is already resolved, and all calls to `wait()` resolve immediately.
 * - REJECTED: promise is rejected, and all calls to `wait()` return rejected promise.
 *
 * Trigger starts in WAITING state initially.
 * Use `reset()` to switch resolved trigger back to WAITING state.
 */
export declare class Trigger<T = void> {
    private _options;
    private _promise;
    private _resolve;
    private _reject;
    private _state;
    constructor(_options?: TriggerOptions);
    get state(): TriggerState;
    /**
     * Wait until wake is called, with optional timeout.
     */
    wait({ timeout }?: {
        timeout?: number;
    }): Promise<T>;
    /**
     * Wake blocked callers (if any).
     * NOOP if the trigger is already resolved.
     */
    wake(value: T): this;
    /**
     * Reset promise (new waiters will wait).
     */
    reset(): this;
    /**
     * Throw error to blocked callers (if any).
     * NOOP if the trigger is already resolved.
     */
    throw(error: Error): this;
}
//# sourceMappingURL=trigger.d.ts.map