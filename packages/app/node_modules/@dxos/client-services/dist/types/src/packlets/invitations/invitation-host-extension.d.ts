import { type Mutex, Trigger } from '@dxos/async';
import { Context } from '@dxos/context';
import { PublicKey } from '@dxos/keys';
import { Invitation } from '@dxos/protocols/proto/dxos/client/services';
import { type ProfileDocument } from '@dxos/protocols/proto/dxos/halo/credentials';
import { type AdmissionRequest, type AdmissionResponse, type InvitationHostService } from '@dxos/protocols/proto/dxos/halo/invitations';
import { type ExtensionContext, RpcExtension } from '@dxos/teleport';
import type { FlowLockHolder } from './invitation-state';
export declare const MAX_OTP_ATTEMPTS = 3;
type InvitationHostExtensionCallbacks = {
    activeInvitation: Invitation | null;
    onOpen: (ctx: Context, extensionCtx: ExtensionContext) => void;
    onError: (error: Error) => void;
    onStateUpdate: (newState: Invitation.State) => void;
    admit: (request: AdmissionRequest) => Promise<AdmissionResponse>;
};
/**
 * Host's side for a connection to a concrete peer in p2p network during invitation.
 */
export declare class InvitationHostExtension extends RpcExtension<{
    InvitationHostService: InvitationHostService;
}, {
    InvitationHostService: InvitationHostService;
}> implements FlowLockHolder {
    private readonly _invitationFlowMutex;
    private readonly _callbacks;
    private _remoteOptions?;
    private _remoteOptionsTrigger;
    private _challenge?;
    guestProfile?: ProfileDocument;
    authenticationPassed: boolean;
    /**
     * Retry counter for SHARED_SECRET authentication method.
     */
    authenticationRetry: number;
    /**
     * Resolved when admission is completed.
     */
    completedTrigger: Trigger<PublicKey>;
    /**
     * Held to allow only one invitation flow at a time to be active.
     */
    private _invitationFlowLock;
    constructor(_invitationFlowMutex: Mutex, _callbacks: InvitationHostExtensionCallbacks);
    hasFlowLock(): boolean;
    protected getHandlers(): Promise<{
        InvitationHostService: InvitationHostService;
    }>;
    onOpen(context: ExtensionContext): Promise<void>;
    private _requireActiveInvitation;
    private _assertInvitationState;
    onClose(): Promise<void>;
    onAbort(): Promise<void>;
    private _destroy;
}
export declare const isAuthenticationRequired: (invitation: Invitation) => boolean;
export {};
//# sourceMappingURL=invitation-host-extension.d.ts.map