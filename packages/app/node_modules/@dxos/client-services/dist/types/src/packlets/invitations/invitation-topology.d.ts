import { PublicKey } from '@dxos/keys';
import type { SwarmController, Topology } from '@dxos/network-manager';
import { InvitationOptions } from '@dxos/protocols/proto/dxos/halo/invitations';
/**
 * Hosts are listening on an invitation topic.
 * They initiate a connection with any new peer if they are not currently in the invitation flow
 * with another peer (connected.length > 0).
 * When the invitation flow ends guest leaves the swarm and topology is updated once again,
 * so we can connect to the next peer we haven't tried yet.
 * If the peer turns out to be a host or a malicious guest their ID is remembered so that we don't try
 * to establish a connection with them again.
 *
 * Guests don't initiate connections. They accept all connections because if we reject,
 * the host won't retry their offer.
 * Even if we started an invitation flow with one host we might want to try other hosts in case
 * the first one failed due to a network error, so multiple connections are accepted.
 */
export declare class InvitationTopology implements Topology {
    private readonly _role;
    private _controller?;
    /**
     * Peers we tried to establish a connection with.
     * In invitation flow peers are assigned random ids when they join the swarm, so we'll retry
     * a peer if they reload an invitation.
     *
     * Consider keeping a separate set for peers we know are hosts and have some retry timeout
     * for guests we failed an invitation flow with (potentially due to a network error).
     */
    private _seenPeers;
    constructor(_role: InvitationOptions.Role);
    init(controller: SwarmController): void;
    update(): void;
    onOffer(peer: PublicKey): Promise<boolean>;
    destroy(): Promise<void>;
    toString(): string;
}
//# sourceMappingURL=invitation-topology.d.ts.map