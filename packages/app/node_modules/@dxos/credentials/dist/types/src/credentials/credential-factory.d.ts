import { type Signer } from '@dxos/crypto';
import { PublicKey } from '@dxos/keys';
import { type TypedMessage } from '@dxos/protocols/proto';
import { type Chain, type Credential } from '@dxos/protocols/proto/dxos/halo/credentials';
export type CreateCredentialSignerParams = {
    subject: PublicKey;
    assertion: TypedMessage;
    nonce?: Uint8Array;
    parentCredentialIds?: PublicKey[];
};
export type CreateCredentialParams = {
    signer: Signer;
    issuer: PublicKey;
    signingKey?: PublicKey;
    chain?: Chain;
    subject: PublicKey;
    assertion: TypedMessage;
    nonce?: Uint8Array;
    parentCredentialIds?: PublicKey[];
};
/**
 * Construct a signed credential message.
 */
export declare const createCredential: ({ signer, issuer, subject, assertion, signingKey, chain, nonce, parentCredentialIds, }: CreateCredentialParams) => Promise<Credential>;
export declare const createCredentialMessage: (credential: Credential) => {
    '@type': string;
    credential: Credential;
};
export interface CredentialSigner {
    getIssuer(): PublicKey;
    createCredential: (params: CreateCredentialSignerParams) => Promise<Credential>;
}
/**
 * Issue credentials directly signed by the issuer.
 */
export declare const createCredentialSignerWithKey: (signer: Signer, issuer: PublicKey) => CredentialSigner;
/**
 * Issue credentials with transitive proof via a chain.
 */
export declare const createCredentialSignerWithChain: (signer: Signer, chain: Chain, signingKey: PublicKey) => CredentialSigner;
//# sourceMappingURL=credential-factory.d.ts.map