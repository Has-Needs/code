import { PublicKey } from '@dxos/keys';
import { type Credential, SpaceMember, type ProfileDocument } from '@dxos/protocols/proto/dxos/halo/credentials';
import { type ChainVertex, type CredentialGraphStateHandler, type PathState, type StateScope } from '../graph/credential-graph';
export interface MemberInfo {
    key: PublicKey;
    role: SpaceMember.Role;
    credential: Credential;
    assertion: SpaceMember;
    profile?: ProfileDocument;
}
/**
 * Tracks the list of members (with roles) for the space.
 * Provides a list of admitted feeds.
 */
export declare class MemberStateMachine implements CredentialGraphStateHandler<SpaceMember, MemberInfo> {
    private readonly _spaceKey;
    private _ownerKey;
    private _memberProfiles;
    private _hashgraph;
    readonly onMemberRoleChanged: import("@dxos/util").Callback<import("@dxos/util").AsyncCallback<MemberInfo[]>>;
    constructor(_spaceKey: PublicKey);
    get creator(): MemberInfo | undefined;
    get members(): ReadonlyMap<PublicKey, MemberInfo>;
    get membershipChainHeads(): PublicKey[];
    getRole(member: PublicKey): SpaceMember.Role;
    /**
     * Processes the SpaceMember credential.
     * Assumes the credential is already pre-verified and the issuer has been authorized to issue credentials of this type.
     */
    process(credential: Credential): Promise<void>;
    createState(credential: Credential, assertion: SpaceMember): MemberInfo;
    isUpdateAllowed(scope: StateScope<SpaceMember>, credential: Credential, assertion: SpaceMember): boolean;
    getConflictingPaths(paths: PathState<SpaceMember>[], update: ChainVertex<SpaceMember>): PathState<SpaceMember>[];
    tryPickWinningUpdate(scope1: StateScope<SpaceMember>, update1: Credential, scope2: StateScope<SpaceMember>, update2: Credential): Credential | null;
    toLogString(assertion: SpaceMember | undefined): string;
    hasStateChanged(s1?: MemberInfo, s2?: MemberInfo): boolean;
    private _getRole;
}
//# sourceMappingURL=member-state-machine.d.ts.map