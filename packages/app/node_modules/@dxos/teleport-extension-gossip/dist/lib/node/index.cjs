"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var node_exports = {};
__export(node_exports, {
  Gossip: () => Gossip,
  GossipExtension: () => GossipExtension,
  Presence: () => Presence
});
module.exports = __toCommonJS(node_exports);
var import_async = require("@dxos/async");
var import_context = require("@dxos/context");
var import_keys = require("@dxos/keys");
var import_log = require("@dxos/log");
var import_protocols = require("@dxos/protocols");
var import_util = require("@dxos/util");
var import_async2 = require("@dxos/async");
var import_invariant = require("@dxos/invariant");
var import_log2 = require("@dxos/log");
var import_proto = require("@dxos/protocols/proto");
var import_rpc = require("@dxos/rpc");
var import_async3 = require("@dxos/async");
var import_context2 = require("@dxos/context");
var import_invariant2 = require("@dxos/invariant");
var import_keys2 = require("@dxos/keys");
var import_log3 = require("@dxos/log");
var import_util2 = require("@dxos/util");
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/core/mesh/teleport-extension-gossip/src/gossip-extension.ts";
var GossipExtension = class {
  constructor(_callbacks = {}) {
    this._callbacks = _callbacks;
    this._opened = new import_async2.Trigger();
    this._closed = false;
  }
  async onOpen(context) {
    (0, import_log2.log)("onOpen", {
      localPeerId: context.localPeerId,
      remotePeerId: context.remotePeerId
    }, {
      F: __dxlog_file,
      L: 37,
      S: this,
      C: (f, a) => f(...a)
    });
    this._rpc = (0, import_rpc.createProtoRpcPeer)({
      requested: {
        GossipService: import_proto.schema.getService("dxos.mesh.teleport.gossip.GossipService")
      },
      exposed: {
        GossipService: import_proto.schema.getService("dxos.mesh.teleport.gossip.GossipService")
      },
      handlers: {
        GossipService: {
          announce: async (message) => {
            (0, import_log2.log)("received announce", {
              localPeerId: context.localPeerId,
              remotePeerId: context.remotePeerId,
              message
            }, {
              F: __dxlog_file,
              L: 49,
              S: this,
              C: (f, a) => f(...a)
            });
            await this._callbacks.onAnnounce?.(message);
          }
        }
      },
      port: await context.createPort("rpc", {
        contentType: 'application/x-protobuf; messageType="dxos.rpc.Message"'
      })
    });
    await this._rpc.open();
    this._opened.wake();
  }
  async onClose(err) {
    (0, import_log2.log)("close", {
      err
    }, {
      F: __dxlog_file,
      L: 63,
      S: this,
      C: (f, a) => f(...a)
    });
    await this._rpc?.close();
    await this._callbacks.onClose?.(err);
    this._closed = true;
  }
  async onAbort(err) {
    (0, import_log2.log)("abort", {
      err
    }, {
      F: __dxlog_file,
      L: 70,
      S: this,
      C: (f, a) => f(...a)
    });
    try {
      await this._rpc?.abort();
    } catch (err2) {
      import_log2.log.catch(err2, void 0, {
        F: __dxlog_file,
        L: 74,
        S: this,
        C: (f, a) => f(...a)
      });
    } finally {
      await this._callbacks.onClose?.(err);
    }
    this._closed = true;
  }
  async sendAnnounce(message) {
    if (this._closed) {
      return;
    }
    await this._opened.wait();
    (0, import_invariant.invariant)(this._rpc, "RPC not initialized", {
      F: __dxlog_file,
      L: 86,
      S: this,
      A: [
        "this._rpc",
        "'RPC not initialized'"
      ]
    });
    await this._rpc.rpc.GossipService.announce(message);
  }
};
var __dxlog_file2 = "/home/runner/work/dxos/dxos/packages/core/mesh/teleport-extension-gossip/src/gossip.ts";
var RECEIVED_MESSAGES_GC_INTERVAL = 12e4;
var MAX_CTX_TASKS = 50;
var Gossip = class {
  constructor(_params) {
    this._params = _params;
    this._ctx = new import_context.Context({
      onError: (err) => {
        import_log.log.catch(err, void 0, {
          F: __dxlog_file2,
          L: 32,
          S: this,
          C: (f, a) => f(...a)
        });
      }
    }, {
      F: __dxlog_file2,
      L: 30
    });
    this._listeners = /* @__PURE__ */ new Map();
    this._receivedMessages = new import_util.ComplexSet(import_keys.PublicKey.hash);
    this._toClear = new import_util.ComplexSet(import_keys.PublicKey.hash);
    this._connections = new import_util.ComplexMap(import_keys.PublicKey.hash);
    this.connectionClosed = new import_async.Event();
  }
  get localPeerId() {
    return this._params.localPeerId;
  }
  async open() {
    (0, import_async.scheduleTaskInterval)(this._ctx, async () => {
      this._performGc();
    }, RECEIVED_MESSAGES_GC_INTERVAL);
  }
  async close() {
    await this._ctx.dispose();
  }
  getConnections() {
    return Array.from(this._connections.keys());
  }
  createExtension({ remotePeerId }) {
    const extension = new GossipExtension({
      onAnnounce: async (message) => {
        if (this._receivedMessages.has(message.messageId)) {
          return;
        }
        this._receivedMessages.add(message.messageId);
        this._callListeners(message);
        if (this._ctx.disposeCallbacksLength > MAX_CTX_TASKS) {
          (0, import_log.log)(`skipping propagating gossip message due to exessive tasks (${MAX_CTX_TASKS})`, void 0, {
            F: __dxlog_file2,
            L: 84,
            S: this,
            C: (f, a) => f(...a)
          });
          return;
        }
        (0, import_async.scheduleTask)(this._ctx, async () => {
          await this._propagateAnnounce(message);
        });
      },
      onClose: async (err) => {
        if (this._connections.has(remotePeerId)) {
          this._connections.delete(remotePeerId);
        }
        this.connectionClosed.emit(remotePeerId);
      }
    });
    this._connections.set(remotePeerId, extension);
    return extension;
  }
  postMessage(channel, payload) {
    for (const extension of this._connections.values()) {
      this._sendAnnounceWithTimeoutTracking(extension, {
        peerId: this._params.localPeerId,
        messageId: import_keys.PublicKey.random(),
        channelId: channel,
        timestamp: /* @__PURE__ */ new Date(),
        payload
      }).catch(async (err) => {
        if (err instanceof import_protocols.RpcClosedError) {
          (0, import_log.log)("sendAnnounce failed because of RpcClosedError", {
            err
          }, {
            F: __dxlog_file2,
            L: 113,
            S: this,
            C: (f, a) => f(...a)
          });
        } else if (err instanceof import_protocols.TimeoutError || err.constructor.name === "TimeoutError" || err.message.startsWith("Timeout")) {
          (0, import_log.log)("sendAnnounce failed because of TimeoutError", {
            err
          }, {
            F: __dxlog_file2,
            L: 119,
            S: this,
            C: (f, a) => f(...a)
          });
        } else {
          import_log.log.catch(err, void 0, {
            F: __dxlog_file2,
            L: 121,
            S: this,
            C: (f, a) => f(...a)
          });
        }
      });
    }
  }
  listen(channel, callback) {
    if (!this._listeners.has(channel)) {
      this._listeners.set(channel, /* @__PURE__ */ new Set());
    }
    this._listeners.get(channel).add(callback);
    return {
      unsubscribe: () => {
        this._listeners.get(channel).delete(callback);
      }
    };
  }
  _callListeners(message) {
    if (this._listeners.has(message.channelId)) {
      this._listeners.get(message.channelId).forEach((callback) => {
        callback(message);
      });
    }
  }
  _propagateAnnounce(message) {
    return Promise.all([
      ...this._connections.entries()
    ].map(async ([remotePeerId, extension]) => {
      if (this._params.localPeerId.equals(message.peerId) || remotePeerId.equals(message.peerId)) {
        return;
      }
      return this._sendAnnounceWithTimeoutTracking(extension, message).catch((err) => (0, import_log.log)(err, void 0, {
        F: __dxlog_file2,
        L: 154,
        S: this,
        C: (f, a) => f(...a)
      }));
    }));
  }
  _performGc() {
    const start = performance.now();
    for (const key of this._toClear.keys()) {
      this._receivedMessages.delete(key);
    }
    this._toClear.clear();
    for (const key of this._receivedMessages.keys()) {
      this._toClear.add(key);
    }
    const elapsed = performance.now() - start;
    if (elapsed > 100) {
      import_log.log.warn("GC took too long", {
        elapsed
      }, {
        F: __dxlog_file2,
        L: 172,
        S: this,
        C: (f, a) => f(...a)
      });
    }
  }
  _sendAnnounceWithTimeoutTracking(extension, message) {
    return extension.sendAnnounce(message).catch((err) => {
    });
  }
};
var __dxlog_file3 = "/home/runner/work/dxos/dxos/packages/core/mesh/teleport-extension-gossip/src/presence.ts";
var PRESENCE_CHANNEL_ID = "dxos.mesh.presence.Presence";
var Presence = class extends import_context2.Resource {
  // remotePeerId -> PresenceExtension
  constructor(_params) {
    super(), this._params = _params, this.updated = new import_async3.Event(), this.newPeer = new import_async3.Event(), this._peerStates = new import_util2.ComplexMap(import_keys2.PublicKey.hash), this._peersByIdentityKey = new import_util2.ComplexMap(import_keys2.PublicKey.hash), this._isOnline = (message) => {
      return message.timestamp.getTime() > Date.now() - this._params.offlineTimeout;
    };
    (0, import_invariant2.invariant)(this._params.announceInterval < this._params.offlineTimeout, "Announce interval should be less than offline timeout.", {
      F: __dxlog_file3,
      L: 55,
      S: this,
      A: [
        "this._params.announceInterval < this._params.offlineTimeout",
        "'Announce interval should be less than offline timeout.'"
      ]
    });
    this._params.gossip.listen(PRESENCE_CHANNEL_ID, (message) => {
      this._receiveAnnounces(message);
    });
  }
  async _open() {
    (0, import_async3.scheduleTaskInterval)(this._ctx, async () => {
      const peerState = {
        "@type": "dxos.mesh.presence.PeerState",
        identityKey: this._params.identityKey,
        connections: this._params.gossip.getConnections()
      };
      this._params.gossip.postMessage(PRESENCE_CHANNEL_ID, peerState);
    }, this._params.announceInterval);
    (0, import_async3.scheduleTaskInterval)(this._ctx, async () => {
      this.updated.emit();
    }, this._params.offlineTimeout);
    this._params.gossip.connectionClosed.on(this._ctx, (peerId) => {
      const peerState = this._peerStates.get(peerId);
      if (peerState != null) {
        this._peerStates.delete(peerId);
        this._removePeerFromIdentityKeyIndex(peerState);
        this.updated.emit();
      }
    });
  }
  async _catch(err) {
    import_log3.log.catch(err, void 0, {
      F: __dxlog_file3,
      L: 101,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  getPeers() {
    return Array.from(this._peerStates.values()).map((message) => message.payload);
  }
  getPeersByIdentityKey(key) {
    return (this._peersByIdentityKey.get(key) ?? []).filter(this._isOnline).map((m) => m.payload);
  }
  getPeersOnline() {
    return Array.from(this._peerStates.values()).filter(this._isOnline).map((message) => message.payload);
  }
  getLocalState() {
    return {
      identityKey: this._params.identityKey,
      connections: this._params.gossip.getConnections(),
      peerId: this._params.gossip.localPeerId
    };
  }
  _receiveAnnounces(message) {
    (0, import_invariant2.invariant)(message.channelId === PRESENCE_CHANNEL_ID, `Invalid channel ID: ${message.channelId}`, {
      F: __dxlog_file3,
      L: 131,
      S: this,
      A: [
        "message.channelId === PRESENCE_CHANNEL_ID",
        "`Invalid channel ID: ${message.channelId}`"
      ]
    });
    const oldPeerState = this._peerStates.get(message.peerId);
    if (!oldPeerState || oldPeerState.timestamp.getTime() < message.timestamp.getTime()) {
      message.payload.peerId = message.peerId;
      this._peerStates.set(message.peerId, message);
      this._updatePeerInIdentityKeyIndex(message);
      this.updated.emit();
    }
  }
  _removePeerFromIdentityKeyIndex(peerState) {
    const identityPeerList = this._peersByIdentityKey.get(peerState.payload.identityKey) ?? [];
    const peerIdIndex = identityPeerList.findIndex((id) => id.peerId?.equals(peerState.peerId));
    if (peerIdIndex >= 0) {
      identityPeerList.splice(peerIdIndex, 1);
    }
  }
  _updatePeerInIdentityKeyIndex(newState) {
    const identityKey = newState.payload.identityKey;
    const identityKeyPeers = this._peersByIdentityKey.get(identityKey) ?? [];
    const existingIndex = identityKeyPeers.findIndex((p) => p.peerId && newState.peerId?.equals(p.peerId));
    if (existingIndex >= 0) {
      const oldState = identityKeyPeers.splice(existingIndex, 1, newState)[0];
      if (!this._isOnline(oldState)) {
        this.newPeer.emit(newState.payload);
      }
    } else {
      this._peersByIdentityKey.set(identityKey, identityKeyPeers);
      identityKeyPeers.push(newState);
      this.newPeer.emit(newState.payload);
    }
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Gossip,
  GossipExtension,
  Presence
});
//# sourceMappingURL=index.cjs.map
