{
  "version": 3,
  "sources": ["../../../src/document-structure.ts", "../../../src/reference.ts", "../../../src/space-doc-version.ts", "../../../src/space-id.ts", "../../../src/foreign-key.ts", "../../../src/query/ast.ts"],
  "sourcesContent": ["//\n// Copyright 2024 DXOS.org\n//\n\nimport { invariant } from '@dxos/invariant';\nimport type { DXN, ObjectId } from '@dxos/keys';\nimport { visitValues } from '@dxos/util';\n\nimport { type RawString } from './automerge';\nimport type { ForeignKey } from './foreign-key';\nimport { isEncodedReference, type EncodedReference } from './reference';\nimport { type SpaceDocVersion } from './space-doc-version';\n\nexport type SpaceState = {\n  // Url of the root automerge document.\n  rootUrl?: string;\n};\n\n/**\n * Array indexes get converted to strings.\n */\nexport type ObjectProp = string;\nexport type ObjectPropPath = ObjectProp[];\n\n/**\n * Link to all documents that hold objects in the space.\n */\nexport interface DatabaseDirectory {\n  version?: SpaceDocVersion;\n\n  access?: {\n    spaceKey: string;\n  };\n  /**\n   * Objects inlined in the current document.\n   */\n  objects?: {\n    [id: string]: ObjectStructure;\n  };\n  /**\n   * Object id points to an automerge doc url where the object is embedded.\n   */\n  links?: {\n    [echoId: string]: string | RawString;\n  };\n\n  /**\n   * @deprecated\n   * For backward compatibility.\n   */\n  experimental_spaceKey?: string;\n}\n\nexport const DatabaseDirectory = Object.freeze({\n  /**\n   * @returns Space key in hex of the space that owns the document. In hex format. Without 0x prefix.\n   */\n  getSpaceKey: (doc: DatabaseDirectory): string | null => {\n    // experimental_spaceKey is set on old documents, new ones are created with doc.access.spaceKey\n    const rawSpaceKey = doc.access?.spaceKey ?? doc.experimental_spaceKey;\n    if (rawSpaceKey == null) {\n      return null;\n    }\n\n    const rawKey = String(rawSpaceKey);\n    invariant(!rawKey.startsWith('0x'), 'Space key must not start with 0x');\n    return rawKey;\n  },\n\n  getInlineObject: (doc: DatabaseDirectory, id: ObjectId): ObjectStructure | undefined => {\n    return doc.objects?.[id];\n  },\n\n  getLink: (doc: DatabaseDirectory, id: ObjectId): string | undefined => {\n    return doc.links?.[id]?.toString();\n  },\n\n  make: ({\n    spaceKey,\n    objects,\n    links,\n  }: {\n    spaceKey: string;\n    objects?: Record<string, ObjectStructure>;\n    links?: Record<string, RawString>;\n  }): DatabaseDirectory => ({\n    access: {\n      spaceKey,\n    },\n    objects: objects ?? {},\n    links: links ?? {},\n  }),\n});\n\n/**\n * Representation of an ECHO object in an AM document.\n */\nexport type ObjectStructure = {\n  // TODO(dmaretskyi): Missing in some cases.\n  system?: ObjectSystem;\n\n  meta: ObjectMeta;\n  /**\n   * User-defined data.\n   * Adheres to schema in `system.type`\n   */\n  data: Record<string, any>;\n};\n\n// Helper methods to interact with the {@link ObjectStructure}.\nexport const ObjectStructure = Object.freeze({\n  /**\n   * @throws On invalid object structure.\n   */\n  getTypeReference: (object: ObjectStructure): EncodedReference | undefined => {\n    return object.system?.type;\n  },\n\n  /**\n   * @throws On invalid object structure.\n   */\n  getEntityKind: (object: ObjectStructure): 'object' | 'relation' => {\n    const kind = object.system?.kind ?? 'object';\n    invariant(kind === 'object' || kind === 'relation', 'Invalid kind');\n    return kind;\n  },\n\n  isDeleted: (object: ObjectStructure): boolean => {\n    return object.system?.deleted ?? false;\n  },\n\n  getRelationSource: (object: ObjectStructure): EncodedReference | undefined => {\n    return object.system?.source;\n  },\n\n  getRelationTarget: (object: ObjectStructure): EncodedReference | undefined => {\n    return object.system?.target;\n  },\n\n  /**\n   * @returns All references in the data section of the object.\n   */\n  getAllOutgoingReferences: (object: ObjectStructure): { path: ObjectPropPath; reference: EncodedReference }[] => {\n    const references: { path: ObjectPropPath; reference: EncodedReference }[] = [];\n    const visit = (path: ObjectPropPath, value: unknown) => {\n      if (isEncodedReference(value)) {\n        references.push({ path, reference: value });\n      } else {\n        visitValues(value, (value, key) => visit([...path, String(key)], value));\n      }\n    };\n    visitValues(object.data, (value, key) => visit([String(key)], value));\n    return references;\n  },\n\n  makeObject: ({\n    type,\n    data,\n    keys,\n  }: {\n    type: DXN.String;\n    deleted?: boolean;\n    keys?: ForeignKey[];\n    data?: unknown;\n  }): ObjectStructure => {\n    return {\n      system: {\n        kind: 'object',\n        type: { '/': type },\n      },\n      meta: {\n        keys: keys ?? [],\n      },\n      data: data ?? {},\n    };\n  },\n\n  makeRelation: ({\n    type,\n    source,\n    target,\n    deleted,\n    keys,\n    data,\n  }: {\n    type: DXN.String;\n    source: EncodedReference;\n    target: EncodedReference;\n    deleted?: boolean;\n    keys?: ForeignKey[];\n    data?: unknown;\n  }): ObjectStructure => {\n    return {\n      system: {\n        kind: 'relation',\n        type: { '/': type },\n        source,\n        target,\n        deleted: deleted ?? false,\n      },\n      meta: {\n        keys: keys ?? [],\n      },\n      data: data ?? {},\n    };\n  },\n});\n\n/**\n * Echo object metadata.\n */\nexport type ObjectMeta = {\n  /**\n   * Foreign keys.\n   */\n  keys: ForeignKey[];\n};\n\n/**\n * Automerge object system properties.\n * (Is automerge specific.)\n */\nexport type ObjectSystem = {\n  /**\n   * Entity kind.\n   */\n  kind?: 'object' | 'relation';\n\n  /**\n   * Object reference ('protobuf' protocol) type.\n   */\n  type?: EncodedReference;\n\n  /**\n   * Deletion marker.\n   */\n  deleted?: boolean;\n\n  /**\n   * Only for relations.\n   */\n  source?: EncodedReference;\n\n  /**\n   * Only for relations.w\n   */\n  target?: EncodedReference;\n};\n\n/**\n * Id property name.\n */\nexport const PROPERTY_ID = 'id';\n\n/**\n * Data namespace.\n * The key on {@link ObjectStructure} that contains the user-defined data.\n */\nexport const DATA_NAMESPACE = 'data';\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { DXN, LOCAL_SPACE_TAG, type PublicKey } from '@dxos/keys';\nimport { type ObjectId } from '@dxos/protocols';\nimport { type Reference as ReferenceProto } from '@dxos/protocols/proto/dxos/echo/model/document';\n\n/**\n * Runtime representation of an reference in ECHO.\n * Implemented as a DXN, but we might extend it to other URIs in the future.\n */\nexport class Reference {\n  /**\n   * Protocol references to runtime registered types.\n   * @deprecated\n   */\n  static TYPE_PROTOCOL = 'protobuf';\n\n  static fromDXN(dxn: DXN): Reference {\n    switch (dxn.kind) {\n      case DXN.kind.TYPE:\n        return new Reference(dxn.parts[0], Reference.TYPE_PROTOCOL, 'dxos.org', dxn);\n      case DXN.kind.ECHO:\n        if (dxn.parts[0] === LOCAL_SPACE_TAG) {\n          return new Reference(dxn.parts[1], undefined, undefined, dxn);\n        } else {\n          return new Reference(dxn.parts[1], undefined, dxn.parts[0], dxn);\n        }\n      default:\n        return new Reference(dxn.parts[0], undefined, dxn.parts[0], dxn);\n    }\n  }\n\n  static fromValue(value: ReferenceProto): Reference {\n    return new Reference(value.objectId, value.protocol, value.host);\n  }\n\n  /**\n   * Reference an object in the local space.\n   */\n  static localObjectReference(objectId: ObjectId): Reference {\n    return new Reference(objectId);\n  }\n\n  /**\n   * @deprecated\n   */\n  // TODO(dmaretskyi): Remove.\n  static fromLegacyTypename(type: string): Reference {\n    return new Reference(type, Reference.TYPE_PROTOCOL, 'dxos.org');\n  }\n\n  /**\n   * @deprecated\n   */\n  // TODO(dmaretskyi): Remove\n  static fromObjectIdAndSpaceKey(objectId: ObjectId, spaceKey: PublicKey): Reference {\n    // TODO(dmaretskyi): FIX ME! This should be a space ID not a space key.\n    return new Reference(objectId, undefined, spaceKey.toHex());\n  }\n\n  // prettier-ignore\n  private constructor(\n    // TODO(dmaretskyi): Remove and just leave DXN.\n    private readonly _objectId: ObjectId,\n    private readonly _protocol?: string,\n    private readonly _host?: string,\n    private readonly _dxn?: DXN,\n  ) {}\n\n  get dxn(): DXN | undefined {\n    return this._dxn;\n  }\n\n  /**\n   * @deprecated\n   */\n  // TODO(dmaretskyi): Remove.\n  get objectId(): ObjectId {\n    return this._objectId;\n  }\n\n  /**\n   * @deprecated\n   */\n  // TODO(dmaretskyi): Remove.\n  get protocol(): string | undefined {\n    return this._protocol;\n  }\n\n  /**\n   * @deprecated\n   */\n  // TODO(dmaretskyi): Remove.\n  get host(): string | undefined {\n    return this._host;\n  }\n\n  encode(): ReferenceProto {\n    return { objectId: this.objectId, host: this.host, protocol: this.protocol };\n  }\n\n  // TODO(dmaretskyi): Remove in favor of `reference.dxn`.\n  toDXN(): DXN {\n    if (this._dxn) {\n      return this._dxn;\n    }\n\n    if (this.protocol === Reference.TYPE_PROTOCOL) {\n      return new DXN(DXN.kind.TYPE, [this.objectId]);\n    } else {\n      if (this.host) {\n        // Host is assumed to be the space key.\n        // The DXN should actually have the space ID.\n        // TODO(dmaretskyi): Migrate to space id.\n        return new DXN(DXN.kind.ECHO, [this.host, this.objectId]);\n      } else {\n        return new DXN(DXN.kind.ECHO, [LOCAL_SPACE_TAG, this.objectId]);\n      }\n    }\n  }\n}\n\nexport const REFERENCE_TYPE_TAG = 'dxos.echo.model.document.Reference';\n\n/**\n * Reference as it is stored in Automerge document.\n */\nexport type EncodedReference = {\n  '/': string;\n};\n\nexport const encodeReference = (reference: Reference): EncodedReference => ({\n  '/': reference.toDXN().toString(),\n});\n\nexport const decodeReference = (value: any) => {\n  if (typeof value !== 'object' || value === null || typeof value['/'] !== 'string') {\n    throw new Error('Invalid reference');\n  }\n  const dxnString = value['/'];\n\n  if (\n    dxnString.length % 2 === 0 &&\n    dxnString.slice(0, dxnString.length / 2) === dxnString.slice(dxnString.length / 2) &&\n    dxnString.includes('dxn:echo')\n  ) {\n    throw new Error('Automerge bug detected!');\n  }\n\n  return Reference.fromDXN(DXN.parse(dxnString));\n};\n\nexport const isEncodedReference = (value: any): value is EncodedReference =>\n  typeof value === 'object' && value !== null && Object.keys(value).length === 1 && typeof value['/'] === 'string';\n", "//\n// Copyright 2024 DXOS.org\n//\n\n/**\n * Denotes the data version of the space automerge document as well as the leaf documents for each individual ECHO object.\n */\nexport type SpaceDocVersion = number & { __type: 'SpaceDocVersion' };\n\nexport const SpaceDocVersion = Object.freeze({\n  /**\n   * For the documents created before the versioning was introduced.\n   */\n  LEGACY: 0 as SpaceDocVersion,\n\n  /**\n   * Current version.\n   */\n  CURRENT: 1 as SpaceDocVersion,\n});\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { subtleCrypto } from '@dxos/crypto';\nimport { PublicKey, SpaceId } from '@dxos/keys';\nimport { ComplexMap } from '@dxos/util';\n\nconst SPACE_IDS_CACHE = new ComplexMap<PublicKey, SpaceId>(PublicKey.hash);\n\n/**\n * Space keys are generated by creating a keypair, and then taking the first 20 bytes of the SHA-256 hash of the public key and encoding them to multibase RFC4648 base-32 format (prefixed with B, see Multibase Table).\n * Inspired by how ethereum addresses are derived.\n */\nexport const createIdFromSpaceKey = async (spaceKey: PublicKey): Promise<SpaceId> => {\n  const cachedValue = SPACE_IDS_CACHE.get(spaceKey);\n  if (cachedValue !== undefined) {\n    return cachedValue;\n  }\n\n  const digest = await subtleCrypto.digest('SHA-256', spaceKey.asUint8Array());\n\n  const bytes = new Uint8Array(digest).slice(0, SpaceId.byteLength);\n  const spaceId = SpaceId.encode(bytes);\n  SPACE_IDS_CACHE.set(spaceKey, spaceId);\n  return spaceId;\n};\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { Schema, SchemaAST } from 'effect';\n\nconst ForeignKey_ = Schema.Struct({\n  /**\n   * Name of the foreign database/system.\n   * E.g., `github.com`.\n   */\n  source: Schema.String,\n\n  /**\n   * Id within the foreign database.\n   */\n  // TODO(wittjosiah): This annotation is currently used to ensure id field shows up in forms.\n  // TODO(dmaretskyi): `false` is not a valid value for the annotation.\n  id: Schema.String.annotations({ [SchemaAST.IdentifierAnnotationId]: false }),\n});\n\nexport type ForeignKey = Schema.Schema.Type<typeof ForeignKey_>;\n\n/**\n * Reference to an object in a foreign database.\n */\nexport const ForeignKey: Schema.Schema<ForeignKey> = ForeignKey_;\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { Schema } from 'effect';\n\nimport { DXN, ObjectId } from '@dxos/keys';\n\nimport { ForeignKey } from '../foreign-key';\n\nconst TypenameSpecifier = Schema.Union(DXN.Schema, Schema.Null).annotations({\n  description: 'DXN or null. Null means any type will match',\n});\n\n// NOTE: This pattern with 3 definitions per schema is need to make the types opaque, and circular references in AST to not cause compiler errors.\n\n/**\n * Filter by object type and properties.\n *\n * Clauses are combined using logical AND.\n */\n// TODO(burdon): Filter object vs. relation.\nconst FilterObject_ = Schema.Struct({\n  type: Schema.Literal('object'),\n\n  typename: TypenameSpecifier,\n\n  id: Schema.optional(Schema.Array(ObjectId)),\n\n  /**\n   * Filter by property.\n   * Must not include object ID.\n   */\n  props: Schema.Record({\n    key: Schema.String.annotations({ description: 'Property name' }),\n    value: Schema.suspend(() => Filter),\n  }),\n\n  /**\n   * Objects that have any of the given foreign keys.\n   */\n  foreignKeys: Schema.optional(Schema.Array(ForeignKey)),\n\n  // NOTE: Make sure to update `FilterStep.isNoop` if you change this.\n});\nexport interface FilterObject extends Schema.Schema.Type<typeof FilterObject_> {}\nexport const FilterObject: Schema.Schema<FilterObject> = FilterObject_;\n\nconst FilterCompare_ = Schema.Struct({\n  type: Schema.Literal('compare'),\n  operator: Schema.Literal('eq', 'neq', 'gt', 'gte', 'lt', 'lte'),\n  value: Schema.Unknown,\n});\nexport interface FilterCompare extends Schema.Schema.Type<typeof FilterCompare_> {}\nexport const FilterCompare: Schema.Schema<FilterCompare> = FilterCompare_;\n\nconst FilterIn_ = Schema.Struct({\n  type: Schema.Literal('in'),\n  values: Schema.Array(Schema.Any),\n});\nexport interface FilterIn extends Schema.Schema.Type<typeof FilterIn_> {}\nexport const FilterIn: Schema.Schema<FilterIn> = FilterIn_;\n\nconst FilterRange_ = Schema.Struct({\n  type: Schema.Literal('range'),\n  from: Schema.Any,\n  to: Schema.Any,\n});\nexport interface FilterRange extends Schema.Schema.Type<typeof FilterRange_> {}\nexport const FilterRange: Schema.Schema<FilterRange> = FilterRange_;\n\nconst FilterTextSearch_ = Schema.Struct({\n  type: Schema.Literal('text-search'),\n  text: Schema.String,\n  searchKind: Schema.optional(Schema.Literal('full-text', 'vector')),\n});\nexport interface FilterTextSearch extends Schema.Schema.Type<typeof FilterTextSearch_> {}\nexport const FilterTextSearch: Schema.Schema<FilterTextSearch> = FilterTextSearch_;\n\nconst FilterNot_ = Schema.Struct({\n  type: Schema.Literal('not'),\n  filter: Schema.suspend(() => Filter),\n});\nexport interface FilterNot extends Schema.Schema.Type<typeof FilterNot_> {}\nexport const FilterNot: Schema.Schema<FilterNot> = FilterNot_;\n\nconst FilterAnd_ = Schema.Struct({\n  type: Schema.Literal('and'),\n  filters: Schema.Array(Schema.suspend(() => Filter)),\n});\nexport interface FilterAnd extends Schema.Schema.Type<typeof FilterAnd_> {}\nexport const FilterAnd: Schema.Schema<FilterAnd> = FilterAnd_;\n\nconst FilterOr_ = Schema.Struct({\n  type: Schema.Literal('or'),\n  filters: Schema.Array(Schema.suspend(() => Filter)),\n});\nexport interface FilterOr extends Schema.Schema.Type<typeof FilterOr_> {}\nexport const FilterOr: Schema.Schema<FilterOr> = FilterOr_;\n\nexport const Filter = Schema.Union(\n  FilterObject,\n  FilterTextSearch,\n  FilterCompare,\n  FilterIn,\n  FilterRange,\n  FilterNot,\n  FilterAnd,\n  FilterOr,\n);\nexport type Filter = Schema.Schema.Type<typeof Filter>;\n\n/**\n * Query objects by type, id, and/or predicates.\n */\nconst QuerySelectClause_ = Schema.Struct({\n  type: Schema.Literal('select'),\n  filter: Schema.suspend(() => Filter),\n});\nexport interface QuerySelectClause extends Schema.Schema.Type<typeof QuerySelectClause_> {}\nexport const QuerySelectClause: Schema.Schema<QuerySelectClause> = QuerySelectClause_;\n\n/**\n * Filter objects from selection.\n */\nconst QueryFilterClause_ = Schema.Struct({\n  type: Schema.Literal('filter'),\n  selection: Schema.suspend(() => Query),\n  filter: Schema.suspend(() => Filter),\n});\nexport interface QueryFilterClause extends Schema.Schema.Type<typeof QueryFilterClause_> {}\nexport const QueryFilterClause: Schema.Schema<QueryFilterClause> = QueryFilterClause_;\n\n/**\n * Traverse references from an anchor object.\n */\nconst QueryReferenceTraversalClause_ = Schema.Struct({\n  type: Schema.Literal('reference-traversal'),\n  anchor: Schema.suspend(() => Query),\n  property: Schema.String, // TODO(dmaretskyi): Change to EscapedPropPath.\n});\nexport interface QueryReferenceTraversalClause extends Schema.Schema.Type<typeof QueryReferenceTraversalClause_> {}\nexport const QueryReferenceTraversalClause: Schema.Schema<QueryReferenceTraversalClause> =\n  QueryReferenceTraversalClause_;\n\n/**\n * Traverse incoming references to an anchor object.\n */\nconst QueryIncomingReferencesClause_ = Schema.Struct({\n  type: Schema.Literal('incoming-references'),\n  anchor: Schema.suspend(() => Query),\n  property: Schema.String,\n  typename: TypenameSpecifier,\n});\nexport interface QueryIncomingReferencesClause extends Schema.Schema.Type<typeof QueryIncomingReferencesClause_> {}\nexport const QueryIncomingReferencesClause: Schema.Schema<QueryIncomingReferencesClause> =\n  QueryIncomingReferencesClause_;\n\n/**\n * Traverse relations connecting to an anchor object.\n */\nconst QueryRelationClause_ = Schema.Struct({\n  type: Schema.Literal('relation'),\n  anchor: Schema.suspend(() => Query),\n  /**\n   * outgoing: anchor is the source of the relation.\n   * incoming: anchor is the target of the relation.\n   * both: anchor is either the source or target of the relation.\n   */\n  direction: Schema.Literal('outgoing', 'incoming', 'both'),\n  filter: Schema.optional(Schema.suspend(() => Filter)),\n});\nexport interface QueryRelationClause extends Schema.Schema.Type<typeof QueryRelationClause_> {}\nexport const QueryRelationClause: Schema.Schema<QueryRelationClause> = QueryRelationClause_;\n\n/**\n * Traverse into the source or target of a relation.\n */\nconst QueryRelationTraversalClause_ = Schema.Struct({\n  type: Schema.Literal('relation-traversal'),\n  anchor: Schema.suspend(() => Query),\n  direction: Schema.Literal('source', 'target', 'both'),\n});\nexport interface QueryRelationTraversalClause extends Schema.Schema.Type<typeof QueryRelationTraversalClause_> {}\nexport const QueryRelationTraversalClause: Schema.Schema<QueryRelationTraversalClause> = QueryRelationTraversalClause_;\n\n/**\n * Union of multiple queries.\n */\nconst QueryUnionClause_ = Schema.Struct({\n  type: Schema.Literal('union'),\n  queries: Schema.Array(Schema.suspend(() => Query)),\n});\nexport interface QueryUnionClause extends Schema.Schema.Type<typeof QueryUnionClause_> {}\nexport const QueryUnionClause: Schema.Schema<QueryUnionClause> = QueryUnionClause_;\n\n/**\n * Set difference of two queries.\n */\nconst QuerySetDifferenceClause_ = Schema.Struct({\n  type: Schema.Literal('set-difference'),\n  source: Schema.suspend(() => Query),\n  exclude: Schema.suspend(() => Query),\n});\nexport interface QuerySetDifferenceClause extends Schema.Schema.Type<typeof QuerySetDifferenceClause_> {}\nexport const QuerySetDifferenceClause: Schema.Schema<QuerySetDifferenceClause> = QuerySetDifferenceClause_;\n\n/**\n * Add options to a query.\n */\nconst QueryOptionsClause_ = Schema.Struct({\n  type: Schema.Literal('options'),\n  query: Schema.suspend(() => Query),\n  options: Schema.suspend(() => QueryOptions),\n});\nexport interface QueryOptionsClause extends Schema.Schema.Type<typeof QueryOptionsClause_> {}\nexport const QueryOptionsClause: Schema.Schema<QueryOptionsClause> = QueryOptionsClause_;\n\nconst Query_ = Schema.Union(\n  QuerySelectClause,\n  QueryFilterClause,\n  QueryReferenceTraversalClause,\n  QueryIncomingReferencesClause,\n  QueryRelationClause,\n  QueryRelationTraversalClause,\n  QueryUnionClause,\n  QuerySetDifferenceClause,\n  QueryOptionsClause,\n);\n\nexport type Query = Schema.Schema.Type<typeof Query_>;\nexport const Query: Schema.Schema<Query> = Query_;\n\nexport const QueryOptions = Schema.Struct({\n  spaceIds: Schema.optional(Schema.Array(Schema.String)),\n  deleted: Schema.optional(Schema.Literal('include', 'exclude', 'only')),\n});\nexport interface QueryOptions extends Schema.Schema.Type<typeof QueryOptions> {}\n\nexport const visit = (query: Query, visitor: (node: Query) => void) => {\n  switch (query.type) {\n    case 'filter':\n      visit(query.selection, visitor);\n      break;\n    case 'reference-traversal':\n      visit(query.anchor, visitor);\n      break;\n    case 'incoming-references':\n      visit(query.anchor, visitor);\n      break;\n    case 'relation':\n      visit(query.anchor, visitor);\n      break;\n    case 'options':\n      visit(query.query, visitor);\n      break;\n    case 'relation-traversal':\n      visit(query.anchor, visitor);\n      break;\n    case 'union':\n      query.queries.forEach((q) => visit(q, visitor));\n      break;\n    case 'set-difference':\n      visit(query.source, visitor);\n      visit(query.exclude, visitor);\n      break;\n  }\n};\n"],
  "mappings": "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",
  "names": ["invariant", "visitValues", "DXN", "LOCAL_SPACE_TAG", "Reference", "TYPE_PROTOCOL", "fromDXN", "dxn", "kind", "DXN", "TYPE", "parts", "ECHO", "LOCAL_SPACE_TAG", "undefined", "fromValue", "value", "objectId", "protocol", "host", "localObjectReference", "fromLegacyTypename", "type", "fromObjectIdAndSpaceKey", "spaceKey", "toHex", "_objectId", "_protocol", "_host", "_dxn", "encode", "toDXN", "REFERENCE_TYPE_TAG", "encodeReference", "reference", "toString", "decodeReference", "Error", "dxnString", "length", "slice", "includes", "parse", "isEncodedReference", "Object", "keys", "DatabaseDirectory", "Object", "freeze", "getSpaceKey", "doc", "rawSpaceKey", "access", "spaceKey", "experimental_spaceKey", "rawKey", "String", "invariant", "startsWith", "getInlineObject", "id", "objects", "getLink", "links", "toString", "make", "ObjectStructure", "getTypeReference", "object", "system", "type", "getEntityKind", "kind", "isDeleted", "deleted", "getRelationSource", "source", "getRelationTarget", "target", "getAllOutgoingReferences", "references", "visit", "path", "value", "isEncodedReference", "push", "reference", "visitValues", "key", "data", "makeObject", "keys", "meta", "makeRelation", "PROPERTY_ID", "DATA_NAMESPACE", "SpaceDocVersion", "Object", "freeze", "LEGACY", "CURRENT", "subtleCrypto", "PublicKey", "SpaceId", "ComplexMap", "SPACE_IDS_CACHE", "ComplexMap", "PublicKey", "hash", "createIdFromSpaceKey", "spaceKey", "cachedValue", "get", "undefined", "digest", "subtleCrypto", "asUint8Array", "bytes", "Uint8Array", "slice", "SpaceId", "byteLength", "spaceId", "encode", "set", "Schema", "SchemaAST", "ForeignKey_", "Schema", "Struct", "source", "String", "id", "annotations", "SchemaAST", "IdentifierAnnotationId", "ForeignKey", "Schema", "DXN", "ObjectId", "TypenameSpecifier", "Schema", "Union", "DXN", "Null", "annotations", "description", "FilterObject_", "Struct", "type", "Literal", "typename", "id", "optional", "Array", "ObjectId", "props", "Record", "key", "String", "value", "suspend", "Filter", "foreignKeys", "ForeignKey", "FilterObject", "FilterCompare_", "operator", "Unknown", "FilterCompare", "FilterIn_", "values", "Any", "FilterIn", "FilterRange_", "from", "to", "FilterRange", "FilterTextSearch_", "text", "searchKind", "FilterTextSearch", "FilterNot_", "filter", "FilterNot", "FilterAnd_", "filters", "FilterAnd", "FilterOr_", "FilterOr", "QuerySelectClause_", "QuerySelectClause", "QueryFilterClause_", "selection", "Query", "QueryFilterClause", "QueryReferenceTraversalClause_", "anchor", "property", "QueryReferenceTraversalClause", "QueryIncomingReferencesClause_", "QueryIncomingReferencesClause", "QueryRelationClause_", "direction", "QueryRelationClause", "QueryRelationTraversalClause_", "QueryRelationTraversalClause", "QueryUnionClause_", "queries", "QueryUnionClause", "QuerySetDifferenceClause_", "source", "exclude", "QuerySetDifferenceClause", "QueryOptionsClause_", "query", "options", "QueryOptions", "QueryOptionsClause", "Query_", "spaceIds", "deleted", "visit", "visitor", "forEach", "q"]
}
