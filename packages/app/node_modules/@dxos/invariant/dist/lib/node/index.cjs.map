{
  "version": 3,
  "sources": ["../../../src/invariant.ts", "../../../src/assert.ts"],
  "sourcesContent": ["//\n// Copyright 2023 DXOS.org\n//\n\nimport { type CallMetadata } from './meta';\n\nexport type InvariantFn = (condition: unknown, message?: string, meta?: CallMetadata) => asserts condition;\n\n/**\n * Asserts that the condition is true.\n *\n * @param message Optional message. If it starts with \"BUG\" then the program will break if this invariant fails if the debugger is attached.\n */\nexport const invariant: InvariantFn = (\n  condition: unknown,\n  message?: string,\n  meta?: CallMetadata,\n): asserts condition => {\n  if (condition) {\n    return;\n  }\n\n  if (message?.startsWith('BUG')) {\n    // This invariant is a debug bug-check: break if the debugger is attached.\n    // eslint-disable-next-line no-debugger\n    debugger;\n  }\n\n  let errorMessage = 'invariant violation';\n\n  if (message) {\n    errorMessage += `: ${message}`;\n  }\n\n  if (meta?.A) {\n    errorMessage += ` [${meta.A[0]}]`;\n  }\n\n  if (meta?.F) {\n    errorMessage += ` at ${getRelativeFilename(meta.F)}:${meta.L}`;\n  }\n\n  const error = new InvariantViolation(errorMessage);\n\n  // Do not include the invariant function in the stack trace.\n  Error.captureStackTrace(error, invariant);\n\n  throw error;\n};\n\nexport class InvariantViolation extends Error {\n  constructor(message: string) {\n    super(message);\n    // NOTE: Restores prototype chain (https://stackoverflow.com/a/48342359).\n    Object.setPrototypeOf(this, new.target.prototype);\n  }\n}\n\nconst getRelativeFilename = (filename: string) => {\n  // TODO(burdon): Hack uses \"packages\" as an anchor (pre-parse NX?)\n  // Including `packages/` part of the path so that excluded paths (e.g. from dist) are clickable in vscode.\n  const match = filename.match(/.+\\/(packages\\/.+\\/.+)/);\n  if (match) {\n    const [, filePath] = match;\n    return filePath;\n  }\n\n  return filename;\n};\n\nexport const failedInvariant = (message1?: unknown, message2?: string, meta?: CallMetadata): never => {\n  let errorMessage = 'invariant violation';\n\n  const message = [message1, message2].filter((str) => typeof str === 'string').join(' ');\n  if (message) {\n    errorMessage += `: ${message}`;\n  }\n\n  if (meta?.A) {\n    errorMessage += ` [${meta.A[0]}]`;\n  }\n\n  if (meta?.F) {\n    errorMessage += ` at ${getRelativeFilename(meta.F)}:${meta.L}`;\n  }\n\n  throw new InvariantViolation(errorMessage);\n};\n", "//\n// Copyright 2025 DXOS.org\n//\n\n/**\n * Use this to assert the arguments of a function.\n *\n * @example\n * ```ts\n * function foo(arg: string) {\n *   assertArgument(typeof arg === 'string', 'arg must be a string');\n * }\n * ```\n */\n// TODO(dmaretskyi): Rename assertParameter.\nexport const assertArgument: (condition: unknown, message: string) => asserts condition = (\n  condition: unknown,\n  message: string,\n): asserts condition => {\n  if (!condition) {\n    const error = new TypeError(message);\n    Error.captureStackTrace(error, assertArgument);\n    throw error;\n  }\n};\n\n/**\n * Use this to assert the state of an object.\n *\n * @example\n * ```ts\n * class Foo {\n *   private _bar: boolean;\n *\n *   public get bar() {\n *     assertState(this._bar, 'bar must be true');\n *     return this._bar;\n *   }\n * }\n *\n * const foo = new Foo();\n * foo.bar = false; // This will throw an InvalidStateError\n * ```\n */\nexport const assertState: (condition: unknown, message: string) => asserts condition = (\n  condition: unknown,\n  message: string,\n): asserts condition => {\n  if (!condition) {\n    const error = new InvalidStateError(message);\n    Error.captureStackTrace(error, assertState);\n    throw error;\n  }\n};\n\n// TODO(dmaretskyi): Consider how this correlates to effect errors. Intuitively, this should be a defect, not a checked error.\nexport class InvalidStateError extends Error {}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAaO,IAAMA,YAAyB,CACpCC,WACAC,SACAC,SAAAA;AAEA,MAAIF,WAAW;AACb;EACF;AAEA,MAAIC,SAASE,WAAW,KAAA,GAAQ;AAG9B;EACF;AAEA,MAAIC,eAAe;AAEnB,MAAIH,SAAS;AACXG,oBAAgB,KAAKH,OAAAA;EACvB;AAEA,MAAIC,MAAMG,GAAG;AACXD,oBAAgB,KAAKF,KAAKG,EAAE,CAAA,CAAE;EAChC;AAEA,MAAIH,MAAMI,GAAG;AACXF,oBAAgB,OAAOG,oBAAoBL,KAAKI,CAAC,CAAA,IAAKJ,KAAKM,CAAC;EAC9D;AAEA,QAAMC,QAAQ,IAAIC,mBAAmBN,YAAAA;AAGrCO,QAAMC,kBAAkBH,OAAOV,SAAAA;AAE/B,QAAMU;AACR;AAEO,IAAMC,qBAAN,cAAiCC,MAAAA;EACtC,YAAYV,SAAiB;AAC3B,UAAMA,OAAAA;AAENY,WAAOC,eAAe,MAAM,WAAWC,SAAS;EAClD;AACF;AAEA,IAAMR,sBAAsB,CAACS,aAAAA;AAG3B,QAAMC,QAAQD,SAASC,MAAM,wBAAA;AAC7B,MAAIA,OAAO;AACT,UAAM,CAAA,EAAGC,QAAAA,IAAYD;AACrB,WAAOC;EACT;AAEA,SAAOF;AACT;AAEO,IAAMG,kBAAkB,CAACC,UAAoBC,UAAmBnB,SAAAA;AACrE,MAAIE,eAAe;AAEnB,QAAMH,UAAU;IAACmB;IAAUC;IAAUC,OAAO,CAACC,QAAQ,OAAOA,QAAQ,QAAA,EAAUC,KAAK,GAAA;AACnF,MAAIvB,SAAS;AACXG,oBAAgB,KAAKH,OAAAA;EACvB;AAEA,MAAIC,MAAMG,GAAG;AACXD,oBAAgB,KAAKF,KAAKG,EAAE,CAAA,CAAE;EAChC;AAEA,MAAIH,MAAMI,GAAG;AACXF,oBAAgB,OAAOG,oBAAoBL,KAAKI,CAAC,CAAA,IAAKJ,KAAKM,CAAC;EAC9D;AAEA,QAAM,IAAIE,mBAAmBN,YAAAA;AAC/B;ACxEO,IAAMqB,iBAA6E,CACxFzB,WACAC,YAAAA;AAEA,MAAI,CAACD,WAAW;AACd,UAAMS,QAAQ,IAAIiB,UAAUzB,OAAAA;AAC5BU,UAAMC,kBAAkBH,OAAOgB,cAAAA;AAC/B,UAAMhB;EACR;AACF;AAoBO,IAAMkB,cAA0E,CACrF3B,WACAC,YAAAA;AAEA,MAAI,CAACD,WAAW;AACd,UAAMS,QAAQ,IAAImB,kBAAkB3B,OAAAA;AACpCU,UAAMC,kBAAkBH,OAAOkB,WAAAA;AAC/B,UAAMlB;EACR;AACF;AAGO,IAAMmB,oBAAN,cAAgCjB,MAAAA;AAAO;",
  "names": ["invariant", "condition", "message", "meta", "startsWith", "errorMessage", "A", "F", "getRelativeFilename", "L", "error", "InvariantViolation", "Error", "captureStackTrace", "Object", "setPrototypeOf", "prototype", "filename", "match", "filePath", "failedInvariant", "message1", "message2", "filter", "str", "join", "assertArgument", "TypeError", "assertState", "InvalidStateError"]
}
