{
  "version": 3,
  "sources": ["../../../src/client.ts", "../../../src/token-auth.ts", "../../../src/server.ts"],
  "sourcesContent": ["//\n// Copyright 2022 DXOS.org\n//\n\nimport WebSocket from 'isomorphic-ws';\n\nimport { Event, Trigger } from '@dxos/async';\nimport { log, logInfo } from '@dxos/log';\nimport { createProtoRpcPeer, type ProtoRpcPeer, type ProtoRpcPeerOptions } from '@dxos/rpc';\n\nimport { WebSocketWithTokenAuth } from './token-auth';\n\nexport type WebsocketRpcClientParams<C, S> = {\n  url: string;\n  authenticationToken?: string;\n} & Pick<ProtoRpcPeerOptions<C, S>, 'requested' | 'exposed' | 'handlers' | 'noHandshake'>;\n\nexport class WebsocketRpcClient<C, S> {\n  private _socket?: WebSocket;\n  private _rpc?: ProtoRpcPeer<C>;\n  private readonly _connectTrigger = new Trigger();\n\n  readonly connected = new Event();\n  readonly disconnected = new Event();\n  readonly error = new Event<Error>();\n\n  constructor(private readonly _params: WebsocketRpcClientParams<C, S>) {\n    this._rpc = createProtoRpcPeer({\n      requested: this._params.requested,\n      exposed: this._params.exposed,\n      handlers: this._params.handlers,\n      noHandshake: this._params.noHandshake,\n      port: {\n        send: (msg) => {\n          this._socket!.send(msg);\n        },\n        subscribe: (cb) => {\n          this._socket!.onmessage = async (msg: WebSocket.MessageEvent) => {\n            if (typeof Blob !== 'undefined' && msg.data instanceof Blob) {\n              cb(Buffer.from(await msg.data.arrayBuffer()));\n            } else {\n              cb(msg.data as any);\n            }\n          };\n        },\n      },\n    });\n  }\n\n  @logInfo\n  get url() {\n    return this._params.url;\n  }\n\n  async open(): Promise<void> {\n    if (this._params.authenticationToken) {\n      this._socket = new WebSocketWithTokenAuth(this._params.url, this._params.authenticationToken);\n    } else {\n      this._socket = new WebSocket(this._params.url);\n    }\n    this._socket.onopen = async () => {\n      log('Socket open');\n      try {\n        await this._rpc!.open();\n        log(`RPC open ${this._params.url}`);\n        this.connected.emit();\n        this._connectTrigger.wake();\n      } catch (err: any) {\n        this.error.emit(err);\n      }\n    };\n\n    this._socket.onclose = async () => {\n      log(`Disconnected ${this._params.url}`);\n      this.disconnected.emit();\n      await this.close();\n    };\n\n    this._socket.onerror = (event: WebSocket.ErrorEvent) => {\n      // Browsers do not include the error message in the event object, so we cannot discern 401 errors from other errors.\n      log.error(event.message ?? 'Socket error', { url: this._params.url });\n      const error = event.error ?? new Error(event.message);\n      this.error.emit(error);\n      this._connectTrigger.throw(error);\n    };\n\n    await this._connectTrigger.wait();\n  }\n\n  async close(): Promise<void> {\n    try {\n      await this._rpc?.close();\n    } catch (err) {\n      log.catch(err);\n    }\n    this._socket?.close();\n  }\n\n  get rpc() {\n    return this._rpc!.rpc;\n  }\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\n// Implement WS header-based auth similar to https://github.com/kubernetes/kubernetes/commit/714f97d7baf4975ad3aa47735a868a81a984d1f0\n// https://stackoverflow.com/questions/4361173/http-headers-in-websockets-client-api/77060459#77060459\n\nimport { type IncomingMessage } from 'http';\nimport WebSocket from 'isomorphic-ws';\nimport { type Socket } from 'node:net';\n\nimport { log } from '@dxos/log';\n\nconst PROTOCOL_TOKEN_PREFIX = 'base64url.bearer.authorization.dxos.org';\n\n// TODO: implement middleware which removes the token from the request\n\nexport const authenticateRequestWithTokenAuth = (\n  request: IncomingMessage,\n  socket: Socket,\n  upgradeHead: Buffer,\n  token: string,\n  cb: (request: IncomingMessage, socket: Socket, upgradeHead: Buffer) => void,\n) => {\n  const protocolHeader = request.headers['sec-websocket-protocol'];\n\n  if (!protocolHeader) {\n    log('upgrade unauthorized, header missing', { header: request.headers['sec-websocket-protocol'] });\n    socket.write('HTTP/1.1 401 Unauthorized\\r\\n\\r\\n');\n    socket.destroy();\n    return;\n  }\n\n  const tokenHeader = protocolHeader.replace(new RegExp(`^${PROTOCOL_TOKEN_PREFIX}.`), '');\n\n  // padding characters are not allowed as a websocket protocol.\n  const encodedToken = Buffer.from(token).toString('base64').replace(/=*$/, '');\n\n  if (tokenHeader !== encodedToken) {\n    log('upgrade unauthorized', { token, foo: encodedToken });\n    socket.write('HTTP/1.1 401 Unauthorized\\r\\n\\r\\n');\n    socket.destroy();\n    return;\n  }\n\n  cb(request, socket, upgradeHead);\n};\n\nexport class WebSocketWithTokenAuth extends WebSocket {\n  constructor(url: string, token: string) {\n    const encodedToken = Buffer.from(token).toString('base64').replace(/=*$/, '');\n\n    const wsProtocols = [`base64url.bearer.authorization.dxos.org.${encodedToken}`];\n    super(url, wsProtocols);\n    log('encodedToken', {\n      encodedToken,\n    });\n  }\n}\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { type IncomingMessage } from 'http';\nimport WebSocket from 'isomorphic-ws';\nimport { type Socket } from 'node:net';\n\nimport { log } from '@dxos/log';\nimport { createProtoRpcPeer, type ProtoRpcPeer, type ProtoRpcPeerOptions } from '@dxos/rpc';\n\nexport type ConnectionInfo = {\n  request: IncomingMessage;\n};\n\nexport type ConnectionHandler<C, S> = {\n  onOpen?: (rpc: ProtoRpcPeer<C>) => Promise<void>;\n  onClose?: (rpc: ProtoRpcPeer<C>) => Promise<void>;\n} & Pick<ProtoRpcPeerOptions<C, S>, 'requested' | 'exposed' | 'handlers'>;\n\nexport type WebsocketRpcServerParams<C, S> = {\n  onConnection: (info: ConnectionInfo) => Promise<ConnectionHandler<C, S>>;\n} & WebSocket.ServerOptions;\n\nexport class WebsocketRpcServer<C, S> {\n  private _server?: WebSocket.Server;\n\n  constructor(private readonly _params: WebsocketRpcServerParams<C, S>) {}\n  handleUpgrade(request: IncomingMessage, socket: Socket, head: Buffer): void {\n    this._server?.handleUpgrade(request, socket, head, (ws) => {\n      this._server?.emit('connection', ws, request);\n    });\n  }\n\n  async open(): Promise<void> {\n    this._server = new WebSocket.Server({\n      ...this._params,\n    });\n    this._server.on('connection', async (socket, request) => {\n      log('connection', { url: request.url, headers: request.headers });\n      const info: ConnectionInfo = {\n        request,\n      };\n      const { onOpen, onClose, ...options } = await this._params.onConnection(info);\n      const rpc = createProtoRpcPeer<C, S>({\n        ...options,\n        port: {\n          send: (msg) => {\n            socket.send(msg);\n          },\n          subscribe: (cb) => {\n            socket.onmessage = async (msg: WebSocket.MessageEvent) => {\n              if (typeof Blob !== 'undefined' && msg.data instanceof Blob) {\n                cb(Buffer.from(await msg.data.arrayBuffer()));\n              } else {\n                cb(msg.data as any);\n              }\n            };\n          },\n        },\n      });\n\n      await rpc.open();\n      await onOpen?.(rpc);\n      socket.onclose = async () => {\n        await onClose?.(rpc);\n        await rpc.close();\n      };\n    });\n  }\n\n  async close(): Promise<void> {\n    this._server?.close();\n  }\n}\n"],
  "mappings": "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",
  "names": ["import_isomorphic_ws", "import_log", "import_rpc", "PROTOCOL_TOKEN_PREFIX", "authenticateRequestWithTokenAuth", "request", "socket", "upgradeHead", "token", "cb", "protocolHeader", "headers", "log", "header", "write", "destroy", "tokenHeader", "replace", "RegExp", "encodedToken", "Buffer", "from", "toString", "foo", "WebSocketWithTokenAuth", "WebSocket", "url", "wsProtocols", "WebsocketRpcClient", "_params", "_connectTrigger", "Trigger", "connected", "Event", "disconnected", "error", "_rpc", "createProtoRpcPeer", "requested", "exposed", "handlers", "noHandshake", "port", "send", "msg", "_socket", "subscribe", "onmessage", "Blob", "data", "arrayBuffer", "open", "authenticationToken", "onopen", "emit", "wake", "err", "onclose", "close", "onerror", "event", "message", "Error", "throw", "wait", "catch", "rpc", "WebsocketRpcServer", "handleUpgrade", "head", "_server", "ws", "Server", "on", "info", "onOpen", "onClose", "options", "onConnection"]
}
