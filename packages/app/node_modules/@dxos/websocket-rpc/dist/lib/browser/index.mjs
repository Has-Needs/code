import "@dxos/node-std/globals";

// packages/core/mesh/websocket-rpc/src/client.ts
import WebSocket2 from "isomorphic-ws";
import { Event, Trigger } from "@dxos/async";
import { log as log2, logInfo } from "@dxos/log";
import { createProtoRpcPeer } from "@dxos/rpc";

// packages/core/mesh/websocket-rpc/src/token-auth.ts
import WebSocket from "isomorphic-ws";
import { log } from "@dxos/log";
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/core/mesh/websocket-rpc/src/token-auth.ts";
var PROTOCOL_TOKEN_PREFIX = "base64url.bearer.authorization.dxos.org";
var authenticateRequestWithTokenAuth = (request, socket, upgradeHead, token, cb) => {
  const protocolHeader = request.headers["sec-websocket-protocol"];
  if (!protocolHeader) {
    log("upgrade unauthorized, header missing", {
      header: request.headers["sec-websocket-protocol"]
    }, {
      F: __dxlog_file,
      L: 28,
      S: void 0,
      C: (f, a) => f(...a)
    });
    socket.write("HTTP/1.1 401 Unauthorized\r\n\r\n");
    socket.destroy();
    return;
  }
  const tokenHeader = protocolHeader.replace(new RegExp(`^${PROTOCOL_TOKEN_PREFIX}.`), "");
  const encodedToken = Buffer.from(token).toString("base64").replace(/=*$/, "");
  if (tokenHeader !== encodedToken) {
    log("upgrade unauthorized", {
      token,
      foo: encodedToken
    }, {
      F: __dxlog_file,
      L: 40,
      S: void 0,
      C: (f, a) => f(...a)
    });
    socket.write("HTTP/1.1 401 Unauthorized\r\n\r\n");
    socket.destroy();
    return;
  }
  cb(request, socket, upgradeHead);
};
var WebSocketWithTokenAuth = class extends WebSocket {
  constructor(url, token) {
    const encodedToken = Buffer.from(token).toString("base64").replace(/=*$/, "");
    const wsProtocols = [
      `base64url.bearer.authorization.dxos.org.${encodedToken}`
    ];
    super(url, wsProtocols);
    log("encodedToken", {
      encodedToken
    }, {
      F: __dxlog_file,
      L: 55,
      S: this,
      C: (f, a) => f(...a)
    });
  }
};

// packages/core/mesh/websocket-rpc/src/client.ts
function _ts_decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file2 = "/home/runner/work/dxos/dxos/packages/core/mesh/websocket-rpc/src/client.ts";
var WebsocketRpcClient = class {
  constructor(_params) {
    this._params = _params;
    this._connectTrigger = new Trigger();
    this.connected = new Event();
    this.disconnected = new Event();
    this.error = new Event();
    this._rpc = createProtoRpcPeer({
      requested: this._params.requested,
      exposed: this._params.exposed,
      handlers: this._params.handlers,
      noHandshake: this._params.noHandshake,
      port: {
        send: (msg) => {
          this._socket.send(msg);
        },
        subscribe: (cb) => {
          this._socket.onmessage = async (msg) => {
            if (typeof Blob !== "undefined" && msg.data instanceof Blob) {
              cb(Buffer.from(await msg.data.arrayBuffer()));
            } else {
              cb(msg.data);
            }
          };
        }
      }
    });
  }
  get url() {
    return this._params.url;
  }
  async open() {
    if (this._params.authenticationToken) {
      this._socket = new WebSocketWithTokenAuth(this._params.url, this._params.authenticationToken);
    } else {
      this._socket = new WebSocket2(this._params.url);
    }
    this._socket.onopen = async () => {
      log2("Socket open", void 0, {
        F: __dxlog_file2,
        L: 62,
        S: this,
        C: (f, a) => f(...a)
      });
      try {
        await this._rpc.open();
        log2(`RPC open ${this._params.url}`, void 0, {
          F: __dxlog_file2,
          L: 65,
          S: this,
          C: (f, a) => f(...a)
        });
        this.connected.emit();
        this._connectTrigger.wake();
      } catch (err) {
        this.error.emit(err);
      }
    };
    this._socket.onclose = async () => {
      log2(`Disconnected ${this._params.url}`, void 0, {
        F: __dxlog_file2,
        L: 74,
        S: this,
        C: (f, a) => f(...a)
      });
      this.disconnected.emit();
      await this.close();
    };
    this._socket.onerror = (event) => {
      log2.error(event.message ?? "Socket error", {
        url: this._params.url
      }, {
        F: __dxlog_file2,
        L: 81,
        S: this,
        C: (f, a) => f(...a)
      });
      const error = event.error ?? new Error(event.message);
      this.error.emit(error);
      this._connectTrigger.throw(error);
    };
    await this._connectTrigger.wait();
  }
  async close() {
    try {
      await this._rpc?.close();
    } catch (err) {
      log2.catch(err, void 0, {
        F: __dxlog_file2,
        L: 94,
        S: this,
        C: (f, a) => f(...a)
      });
    }
    this._socket?.close();
  }
  get rpc() {
    return this._rpc.rpc;
  }
};
_ts_decorate([
  logInfo
], WebsocketRpcClient.prototype, "url", null);

// packages/core/mesh/websocket-rpc/src/server.ts
import WebSocket3 from "isomorphic-ws";
import { log as log3 } from "@dxos/log";
import { createProtoRpcPeer as createProtoRpcPeer2 } from "@dxos/rpc";
var __dxlog_file3 = "/home/runner/work/dxos/dxos/packages/core/mesh/websocket-rpc/src/server.ts";
var WebsocketRpcServer = class {
  constructor(_params) {
    this._params = _params;
  }
  handleUpgrade(request, socket, head) {
    this._server?.handleUpgrade(request, socket, head, (ws) => {
      this._server?.emit("connection", ws, request);
    });
  }
  async open() {
    this._server = new WebSocket3.Server({
      ...this._params
    });
    this._server.on("connection", async (socket, request) => {
      log3("connection", {
        url: request.url,
        headers: request.headers
      }, {
        F: __dxlog_file3,
        L: 40,
        S: this,
        C: (f, a) => f(...a)
      });
      const info = {
        request
      };
      const { onOpen, onClose, ...options } = await this._params.onConnection(info);
      const rpc = createProtoRpcPeer2({
        ...options,
        port: {
          send: (msg) => {
            socket.send(msg);
          },
          subscribe: (cb) => {
            socket.onmessage = async (msg) => {
              if (typeof Blob !== "undefined" && msg.data instanceof Blob) {
                cb(Buffer.from(await msg.data.arrayBuffer()));
              } else {
                cb(msg.data);
              }
            };
          }
        }
      });
      await rpc.open();
      await onOpen?.(rpc);
      socket.onclose = async () => {
        await onClose?.(rpc);
        await rpc.close();
      };
    });
  }
  async close() {
    this._server?.close();
  }
};
export {
  WebSocketWithTokenAuth,
  WebsocketRpcClient,
  WebsocketRpcServer,
  authenticateRequestWithTokenAuth
};
//# sourceMappingURL=index.mjs.map
