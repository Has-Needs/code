import { inspect } from 'node:util';
import { Event } from '@dxos/async';
import type { ReadStreamOptions } from '@dxos/hypercore';
import { type FeedWrapper } from './feed-wrapper';
import { type FeedBlock } from './types';
export declare const defaultReadStreamOptions: ReadStreamOptions;
export type FeedQueueOptions = {};
/**
 * Async queue using an AsyncIterator created from a hypercore.
 */
export declare class FeedQueue<T extends {}> {
    private readonly _feed;
    private readonly _options;
    updated: Event<FeedQueue<T>>;
    private readonly _messageTrigger;
    private _feedConsumer?;
    private _next?;
    private _currentBlock?;
    private _index;
    constructor(_feed: FeedWrapper<T>, _options?: FeedQueueOptions);
    [inspect.custom](): string;
    toJSON(): {
        feedKey: import("@dxos/keys").PublicKey;
        index: number;
        length: number;
        open: boolean;
    };
    get feed(): FeedWrapper<T>;
    get isOpen(): boolean;
    get length(): number;
    /**
     * Index (seq) of the NEXT block to be read, or -1 if not open.
     */
    get index(): number;
    /**
     * Opens (or reopens) the queue.
     * @param options.start Starting index. First mutation to be read would have `seq == options.start`.
     */
    open(options?: ReadStreamOptions): Promise<void>;
    /**
     * Closes the queue.
     */
    close(): Promise<void>;
    /**
     * Get the block at the head of the queue without removing it.
     */
    peek(): FeedBlock<T> | undefined;
    /**
     * Pop block at the head of the queue.
     */
    pop(): Promise<FeedBlock<T>>;
    private _destroyConsumer;
}
//# sourceMappingURL=feed-queue.d.ts.map