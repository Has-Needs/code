{
  "version": 3,
  "sources": ["../../../src/feed-iterator.ts", "../../../src/feed-queue.ts", "../../../src/feed-set-iterator.ts", "../../../src/feed-writer.ts"],
  "sourcesContent": ["//\n// Copyright 2020 DXOS.org\n//\n\nimport safeRace from 'race-as-promised';\n\nimport { Trigger } from '@dxos/async';\nimport { invariant } from '@dxos/invariant';\nimport { log } from '@dxos/log';\n\nimport { FeedQueue } from './feed-queue';\nimport { type FeedWrapper } from './feed-wrapper';\nimport { type FeedBlock } from './types';\n\n/**\n * Base class for an async iterable feed.\n */\nexport abstract class AbstractFeedIterator<T> implements AsyncIterable<FeedBlock<T>> {\n  private readonly _stopTrigger = new Trigger();\n\n  protected _open = false;\n  protected _running = false;\n\n  toJSON(): { open: boolean; running: boolean } {\n    return {\n      open: this.isOpen,\n      running: this.isRunning,\n    };\n  }\n\n  get isOpen() {\n    return this._open;\n  }\n\n  get isRunning() {\n    return this._running;\n  }\n\n  async open(): Promise<void> {\n    if (!this._open) {\n      log('opening...');\n      await this._onOpen();\n      this._open = true;\n\n      await this.start();\n      log('opened');\n    }\n  }\n\n  async close(): Promise<void> {\n    if (this._open) {\n      log('closing...');\n      await this.stop();\n\n      await this._onClose();\n      this._open = false;\n      log('closed');\n    }\n  }\n\n  async start(): Promise<void> {\n    invariant(this._open);\n    if (!this._running) {\n      this._running = true;\n    }\n  }\n\n  async stop(): Promise<void> {\n    invariant(this._open);\n    if (this._running) {\n      this._running = false;\n      this._stopTrigger.wake();\n    }\n  }\n\n  //\n  // AsyncIterable\n  //\n\n  [Symbol.asyncIterator]() {\n    return this._generator();\n  }\n\n  async *_generator() {\n    log('started');\n    while (this._running) {\n      // https://github.com/nodejs/node/issues/17469\n      const block = await safeRace([this._stopTrigger.wait(), this._nextBlock()]);\n\n      if (block === undefined) {\n        break;\n      }\n\n      yield block;\n    }\n\n    log('stopped');\n  }\n\n  abstract _onOpen(): Promise<void>;\n  abstract _onClose(): Promise<void>;\n  abstract _nextBlock(): Promise<FeedBlock<T> | undefined>;\n}\n\n/**\n * Iterator that reads blocks from a single feed.\n */\nexport class FeedIterator<T extends {}> extends AbstractFeedIterator<T> {\n  private readonly _queue: FeedQueue<T>;\n\n  constructor(private readonly _feed: FeedWrapper<T>) {\n    super();\n    this._queue = new FeedQueue<T>(this._feed);\n  }\n\n  override async _onOpen(): Promise<void> {\n    await this._queue.open();\n  }\n\n  override async _onClose(): Promise<void> {\n    await this._queue.close();\n  }\n\n  override async _nextBlock(): Promise<FeedBlock<T> | undefined> {\n    return this._queue.pop();\n  }\n}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { inspect } from 'node:util';\nimport { Writable } from 'streamx';\n\nimport { Event, latch, Trigger } from '@dxos/async';\nimport { inspectObject } from '@dxos/debug';\nimport type { ReadStreamOptions } from '@dxos/hypercore';\nimport { invariant } from '@dxos/invariant';\nimport { log } from '@dxos/log';\n\nimport { type FeedWrapper } from './feed-wrapper';\nimport { type FeedBlock } from './types';\n\nexport const defaultReadStreamOptions: ReadStreamOptions = {\n  live: true, // Keep reading until closed.\n  batch: 1024, // Read in batches.\n};\n\nexport type FeedQueueOptions = {};\n\n/**\n * Async queue using an AsyncIterator created from a hypercore.\n */\nexport class FeedQueue<T extends {}> {\n  public updated = new Event<FeedQueue<T>>();\n\n  private readonly _messageTrigger = new Trigger<FeedBlock<T>>({\n    autoReset: true,\n  });\n\n  private _feedConsumer?: Writable = undefined;\n  private _next?: () => void;\n  private _currentBlock?: FeedBlock<T> = undefined;\n  private _index = -1;\n\n  // prettier-ignore\n  constructor(\n    private readonly _feed: FeedWrapper<T>,\n    private readonly _options: FeedQueueOptions = {},\n  ) {}\n\n  [inspect.custom](): string {\n    return inspectObject(this);\n  }\n\n  toJSON() {\n    return {\n      feedKey: this._feed.key,\n      index: this.index,\n      length: this.length,\n      open: this.isOpen,\n    };\n  }\n\n  get feed() {\n    return this._feed;\n  }\n\n  get isOpen(): boolean {\n    return Boolean(this._feedConsumer);\n  }\n\n  get length(): number {\n    return this._feed.properties.length;\n  }\n\n  /**\n   * Index (seq) of the NEXT block to be read, or -1 if not open.\n   */\n  get index() {\n    return this._index;\n  }\n\n  /**\n   * Opens (or reopens) the queue.\n   * @param options.start Starting index. First mutation to be read would have `seq == options.start`.\n   */\n  async open(options: ReadStreamOptions = {}): Promise<void> {\n    if (this.isOpen) {\n      // TODO(burdon): Warn if re-opening (e.g., with different starting point).\n      return;\n    }\n\n    this._index = options.start ?? 0;\n    // if (this._index !== 0) {\n    //   console.warn('Start index not yet supported.');\n    // }\n\n    log('opening', { feedKey: this._feed.key });\n\n    // TODO(burdon): Open with starting range.\n    const opts = Object.assign({}, defaultReadStreamOptions, options);\n    const feedStream = this._feed.createReadableStream(opts);\n\n    this._feedConsumer = new Writable({\n      write: (data: any, next: () => void) => {\n        this._next = () => {\n          this._next = undefined;\n          this._currentBlock = undefined;\n          this._index++;\n          next();\n        };\n\n        this._currentBlock = {\n          feedKey: this._feed.key,\n          seq: this._index,\n          data,\n        };\n\n        this._messageTrigger.wake(this._currentBlock);\n        this.updated.emit(this);\n      },\n    });\n\n    const onClose = () => {\n      this.feed.core.off('close', onClose);\n      this._feedConsumer?.off('close', onClose);\n      this._feedConsumer?.off('error', onError);\n\n      this._destroyConsumer();\n    };\n\n    const onError = (err?: Error) => {\n      if (!err) {\n        return;\n      }\n\n      if (err.message === 'Writable stream closed prematurely' || err.message === 'Feed is closed') {\n        return;\n      }\n\n      log.catch(err, { feedKey: this._feed.key });\n    };\n\n    // Called if feed is closed externally.\n    this._feed.core.once('close', onClose);\n    this._feedConsumer.on('error', onError);\n\n    // Called when queue is closed. Throws exception if waiting for `pop`.\n    this._feedConsumer.once('close', onClose);\n\n    // Pipe readable stream into writable consumer.\n    feedStream.pipe(this._feedConsumer, (err) => {\n      if (err) {\n        onError(err);\n      }\n      this._destroyConsumer();\n    });\n\n    log('opened');\n  }\n\n  /**\n   * Closes the queue.\n   */\n  async close(): Promise<void> {\n    if (this.isOpen) {\n      invariant(this._feedConsumer);\n      invariant(!this._feed.properties.closed);\n\n      log('closing', { feedKey: this._feed.key });\n      const [closed, setClosed] = latch();\n      this._feedConsumer.once('close', setClosed);\n      this._feedConsumer.destroy();\n      this._next?.(); // Release any message currently in the queue (otherwise destroy will block).\n      await closed();\n      log('closed');\n    }\n  }\n\n  /**\n   * Get the block at the head of the queue without removing it.\n   */\n  peek(): FeedBlock<T> | undefined {\n    return this._currentBlock;\n  }\n\n  /**\n   * Pop block at the head of the queue.\n   */\n  async pop(): Promise<FeedBlock<T>> {\n    if (!this.isOpen) {\n      throw new Error(`Queue closed: ${this.feed.key.truncate()}`);\n    }\n\n    let block = this.peek();\n    if (!block) {\n      block = await this._messageTrigger.wait();\n    }\n\n    if (block) {\n      this._next?.();\n    }\n\n    return block;\n  }\n\n  private _destroyConsumer(): void {\n    if (this._feedConsumer) {\n      log('queue closed', { feedKey: this._feed.key });\n      this._feedConsumer = undefined;\n      this._next = undefined;\n      this._currentBlock = undefined;\n      this._index = -1;\n    }\n  }\n}\n", "//\n// Copyright 2020 DXOS.org\n//\n\nimport { inspect } from 'node:util';\n\nimport { Event, SubscriptionList, Trigger } from '@dxos/async';\nimport { inspectObject } from '@dxos/debug';\nimport { invariant } from '@dxos/invariant';\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { ComplexMap, isNonNullable } from '@dxos/util';\n\nimport { AbstractFeedIterator } from './feed-iterator';\nimport { FeedQueue } from './feed-queue';\nimport { type FeedWrapper } from './feed-wrapper';\nimport { type FeedBlock } from './types';\n\n/**\n * Select next block.\n */\nexport type FeedBlockSelector<T> = (blocks: FeedBlock<T>[]) => number | undefined;\n\nexport type FeedIndex = {\n  feedKey: PublicKey;\n  index: number;\n};\n\nexport type FeedSetIteratorOptions = {\n  // TODO(burdon): Should we remove this and assume the feeds are positioned before adding?\n  start?: FeedIndex[];\n  stallTimeout?: number;\n};\n\nexport const defaultFeedSetIteratorOptions = {\n  stallTimeout: 1000,\n};\n\n/**\n * Iterator that reads blocks from multiple feeds, ordering them based on a traversal callback.\n */\nexport class FeedSetIterator<T extends {}> extends AbstractFeedIterator<T> {\n  private readonly _feedQueues = new ComplexMap<PublicKey, FeedQueue<T>>(PublicKey.hash);\n\n  private readonly _trigger = new Trigger({ autoReset: true });\n  private readonly _subscriptions = new SubscriptionList();\n\n  public readonly stalled = new Event<FeedSetIterator<T>>();\n\n  constructor(\n    private readonly _selector: FeedBlockSelector<T>,\n    public readonly options: FeedSetIteratorOptions = defaultFeedSetIteratorOptions,\n  ) {\n    super();\n    invariant(_selector);\n    invariant(options);\n  }\n\n  [inspect.custom](): string {\n    return inspectObject(this);\n  }\n\n  override toJSON(): { open: boolean; running: boolean; indexes: FeedIndex[] } {\n    return {\n      open: this.isOpen,\n      running: this.isRunning,\n      indexes: this.indexes,\n    };\n  }\n\n  get size() {\n    return this._feedQueues.size;\n  }\n\n  get feeds(): FeedWrapper<T>[] {\n    return Array.from(this._feedQueues.values()).map((feedQueue) => feedQueue.feed);\n  }\n\n  get indexes(): FeedIndex[] {\n    return Array.from(this._feedQueues.values()).map((feedQueue) => ({\n      feedKey: feedQueue.feed.key,\n      index: feedQueue.index,\n    }));\n  }\n\n  reiterateBlock(block: FeedBlock<T>): void {\n    this._trigger.wake();\n  }\n\n  async addFeed(feed: FeedWrapper<T>): Promise<void> {\n    invariant(!this._feedQueues.has(feed.key), `Feed already added: ${feed.key}`);\n    invariant(feed.properties.opened);\n    log('feed added', { feedKey: feed.key });\n\n    // Create queue and listen for updates.\n    const queue = new FeedQueue<T>(feed);\n    this._feedQueues.set(feed.key, queue);\n    this._subscriptions.add(\n      queue.updated.on(() => {\n        this._trigger.wake();\n      }),\n    );\n\n    await queue.open({\n      start: this.options.start?.find((index) => index.feedKey.equals(feed.key))?.index,\n    });\n\n    // Wake when feed added or queue updated.\n    this._trigger.wake();\n  }\n\n  hasFeed(feedKey: PublicKey): boolean {\n    return this._feedQueues.has(feedKey);\n  }\n\n  override async _onOpen(): Promise<void> {\n    for (const queue of this._feedQueues.values()) {\n      await queue.open();\n    }\n  }\n\n  override async _onClose(): Promise<void> {\n    this._subscriptions.clear();\n    await Promise.all(Array.from(this._feedQueues.values()).map((queue) => queue.close()));\n\n    // Wake when feed added or queue updated.\n    this._trigger.wake();\n  }\n\n  /**\n   * Gets the next block from the selected queue.\n   */\n  override async _nextBlock(): Promise<FeedBlock<T> | undefined> {\n    let t: NodeJS.Timeout | undefined;\n\n    while (this._running) {\n      // Get blocks from the head of each queue.\n      const queues = Array.from(this._feedQueues.values());\n      const blocks = queues.map((queue) => queue.peek()).filter(isNonNullable);\n      if (blocks.length) {\n        // Get the selected block from candidates.\n        const idx = this._selector(blocks);\n        log('selected', { idx, blocks });\n        if (idx === undefined) {\n          // Timeout if all candidates are rejected.\n          if (t === undefined) {\n            t = setTimeout(() => {\n              this.stalled.emit(this);\n              this._trigger.wake();\n            }, this.options.stallTimeout);\n          }\n        } else {\n          if (t !== undefined) {\n            clearTimeout(t);\n            t = undefined;\n          }\n          if (idx >= blocks.length) {\n            throw new Error(`Index out of bounds: ${idx} of ${blocks.length}`);\n          }\n\n          // Pop from queue.\n          const queue = this._feedQueues.get(blocks[idx].feedKey)!;\n          log('popping', queue.toJSON());\n          try {\n            const message = await queue.pop();\n            invariant(message === blocks[idx]);\n            return message;\n          } catch (err) {\n            // TODO(burdon): Same queue closed twice.\n            log.warn('queue closed', { feedKey: queue.feed.key });\n            // console.log(Array.from(this._feedQueues.values()));\n          }\n        }\n      }\n\n      // Wait until feed added, new block, or closing.\n      await this._trigger.wait();\n    }\n  }\n}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { type PublicKey } from '@dxos/keys';\n\nexport type WriteReceipt = {\n  feedKey: PublicKey;\n  seq: number;\n};\n\nexport type WriteOptions = {\n  /**\n   * Called after the write is complete.\n   * Runs and completes before the mutation is read from the pipeline.\n   */\n  afterWrite?: (receipt: WriteReceipt) => Promise<void>;\n};\n\nexport interface FeedWriter<T extends {}> {\n  /**\n   * Write data to the feed.\n   * Awaits `afterWrite` before returning.\n   */\n  write(data: T, options?: WriteOptions): Promise<WriteReceipt>;\n}\n\nexport const createFeedWriter = <T extends {}>(cb: (data: T) => Promise<WriteReceipt>): FeedWriter<T> => ({\n  write: async (data: T) => {\n    return cb(data);\n  },\n});\n\nexport const writeMessages = async <T extends {}>(writer: FeedWriter<T>, messages: T[]): Promise<WriteReceipt[]> => {\n  const receipts: WriteReceipt[] = [];\n  // NOTE: Write messages sequentially.\n  for (const message of messages) {\n    receipts.push(await writer.write(message));\n  }\n  return receipts;\n};\n"],
  "mappings": "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",
  "names": ["import_async", "import_invariant", "import_log", "import_node_util", "import_debug", "defaultReadStreamOptions", "live", "batch", "FeedQueue", "_feed", "_options", "updated", "Event", "_messageTrigger", "Trigger", "autoReset", "_feedConsumer", "undefined", "_currentBlock", "_index", "inspect", "custom", "inspectObject", "toJSON", "feedKey", "key", "index", "length", "open", "isOpen", "feed", "Boolean", "properties", "options", "start", "log", "opts", "Object", "assign", "feedStream", "createReadableStream", "Writable", "write", "data", "next", "_next", "seq", "wake", "emit", "onClose", "core", "off", "onError", "_destroyConsumer", "err", "message", "catch", "once", "on", "pipe", "close", "invariant", "closed", "setClosed", "latch", "destroy", "peek", "pop", "Error", "truncate", "block", "wait", "AbstractFeedIterator", "_stopTrigger", "_open", "_running", "running", "isRunning", "_onOpen", "stop", "_onClose", "Symbol", "asyncIterator", "_generator", "safeRace", "_nextBlock", "FeedIterator", "_queue", "defaultFeedSetIteratorOptions", "stallTimeout", "FeedSetIterator", "_selector", "_feedQueues", "ComplexMap", "PublicKey", "hash", "_trigger", "_subscriptions", "SubscriptionList", "stalled", "indexes", "size", "feeds", "Array", "from", "values", "map", "feedQueue", "reiterateBlock", "addFeed", "has", "opened", "queue", "set", "add", "find", "equals", "hasFeed", "clear", "Promise", "all", "t", "queues", "blocks", "filter", "isNonNullable", "idx", "setTimeout", "clearTimeout", "get", "warn", "createFeedWriter", "cb", "writeMessages", "writer", "messages", "receipts", "push"]
}
