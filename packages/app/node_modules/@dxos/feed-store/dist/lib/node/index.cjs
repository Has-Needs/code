"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var node_exports = {};
__export(node_exports, {
  AbstractFeedIterator: () => AbstractFeedIterator,
  FeedFactory: () => import_chunk_YOYJCS5J.FeedFactory,
  FeedIterator: () => FeedIterator,
  FeedQueue: () => FeedQueue,
  FeedSetIterator: () => FeedSetIterator,
  FeedStore: () => import_chunk_YOYJCS5J.FeedStore,
  FeedWrapper: () => import_chunk_YOYJCS5J.FeedWrapper,
  createFeedWriter: () => createFeedWriter,
  defaultFeedSetIteratorOptions: () => defaultFeedSetIteratorOptions,
  defaultReadStreamOptions: () => defaultReadStreamOptions,
  writeMessages: () => writeMessages
});
module.exports = __toCommonJS(node_exports);
var import_chunk_YOYJCS5J = require("./chunk-YOYJCS5J.cjs");
var import_race_as_promised = __toESM(require("race-as-promised"));
var import_async = require("@dxos/async");
var import_invariant = require("@dxos/invariant");
var import_log = require("@dxos/log");
var import_node_util = require("node:util");
var import_streamx = require("streamx");
var import_async2 = require("@dxos/async");
var import_debug = require("@dxos/debug");
var import_invariant2 = require("@dxos/invariant");
var import_log2 = require("@dxos/log");
var import_node_util2 = require("node:util");
var import_async3 = require("@dxos/async");
var import_debug2 = require("@dxos/debug");
var import_invariant3 = require("@dxos/invariant");
var import_keys = require("@dxos/keys");
var import_log3 = require("@dxos/log");
var import_util = require("@dxos/util");
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/common/feed-store/src/feed-queue.ts";
var defaultReadStreamOptions = {
  live: true,
  batch: 1024
};
var FeedQueue = class {
  // prettier-ignore
  constructor(_feed, _options = {}) {
    this._feed = _feed;
    this._options = _options;
    this.updated = new import_async2.Event();
    this._messageTrigger = new import_async2.Trigger({
      autoReset: true
    });
    this._feedConsumer = void 0;
    this._currentBlock = void 0;
    this._index = -1;
  }
  [import_node_util.inspect.custom]() {
    return (0, import_debug.inspectObject)(this);
  }
  toJSON() {
    return {
      feedKey: this._feed.key,
      index: this.index,
      length: this.length,
      open: this.isOpen
    };
  }
  get feed() {
    return this._feed;
  }
  get isOpen() {
    return Boolean(this._feedConsumer);
  }
  get length() {
    return this._feed.properties.length;
  }
  /**
  * Index (seq) of the NEXT block to be read, or -1 if not open.
  */
  get index() {
    return this._index;
  }
  /**
  * Opens (or reopens) the queue.
  * @param options.start Starting index. First mutation to be read would have `seq == options.start`.
  */
  async open(options = {}) {
    if (this.isOpen) {
      return;
    }
    this._index = options.start ?? 0;
    (0, import_log2.log)("opening", {
      feedKey: this._feed.key
    }, {
      F: __dxlog_file,
      L: 92,
      S: this,
      C: (f, a) => f(...a)
    });
    const opts = Object.assign({}, defaultReadStreamOptions, options);
    const feedStream = this._feed.createReadableStream(opts);
    this._feedConsumer = new import_streamx.Writable({
      write: (data, next) => {
        this._next = () => {
          this._next = void 0;
          this._currentBlock = void 0;
          this._index++;
          next();
        };
        this._currentBlock = {
          feedKey: this._feed.key,
          seq: this._index,
          data
        };
        this._messageTrigger.wake(this._currentBlock);
        this.updated.emit(this);
      }
    });
    const onClose = () => {
      this.feed.core.off("close", onClose);
      this._feedConsumer?.off("close", onClose);
      this._feedConsumer?.off("error", onError);
      this._destroyConsumer();
    };
    const onError = (err) => {
      if (!err) {
        return;
      }
      if (err.message === "Writable stream closed prematurely" || err.message === "Feed is closed") {
        return;
      }
      import_log2.log.catch(err, {
        feedKey: this._feed.key
      }, {
        F: __dxlog_file,
        L: 135,
        S: this,
        C: (f, a) => f(...a)
      });
    };
    this._feed.core.once("close", onClose);
    this._feedConsumer.on("error", onError);
    this._feedConsumer.once("close", onClose);
    feedStream.pipe(this._feedConsumer, (err) => {
      if (err) {
        onError(err);
      }
      this._destroyConsumer();
    });
    (0, import_log2.log)("opened", void 0, {
      F: __dxlog_file,
      L: 153,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  /**
  * Closes the queue.
  */
  async close() {
    if (this.isOpen) {
      (0, import_invariant2.invariant)(this._feedConsumer, void 0, {
        F: __dxlog_file,
        L: 161,
        S: this,
        A: [
          "this._feedConsumer",
          ""
        ]
      });
      (0, import_invariant2.invariant)(!this._feed.properties.closed, void 0, {
        F: __dxlog_file,
        L: 162,
        S: this,
        A: [
          "!this._feed.properties.closed",
          ""
        ]
      });
      (0, import_log2.log)("closing", {
        feedKey: this._feed.key
      }, {
        F: __dxlog_file,
        L: 164,
        S: this,
        C: (f, a) => f(...a)
      });
      const [closed, setClosed] = (0, import_async2.latch)();
      this._feedConsumer.once("close", setClosed);
      this._feedConsumer.destroy();
      this._next?.();
      await closed();
      (0, import_log2.log)("closed", void 0, {
        F: __dxlog_file,
        L: 170,
        S: this,
        C: (f, a) => f(...a)
      });
    }
  }
  /**
  * Get the block at the head of the queue without removing it.
  */
  peek() {
    return this._currentBlock;
  }
  /**
  * Pop block at the head of the queue.
  */
  async pop() {
    if (!this.isOpen) {
      throw new Error(`Queue closed: ${this.feed.key.truncate()}`);
    }
    let block = this.peek();
    if (!block) {
      block = await this._messageTrigger.wait();
    }
    if (block) {
      this._next?.();
    }
    return block;
  }
  _destroyConsumer() {
    if (this._feedConsumer) {
      (0, import_log2.log)("queue closed", {
        feedKey: this._feed.key
      }, {
        F: __dxlog_file,
        L: 203,
        S: this,
        C: (f, a) => f(...a)
      });
      this._feedConsumer = void 0;
      this._next = void 0;
      this._currentBlock = void 0;
      this._index = -1;
    }
  }
};
var __dxlog_file2 = "/home/runner/work/dxos/dxos/packages/common/feed-store/src/feed-iterator.ts";
var AbstractFeedIterator = class {
  constructor() {
    this._stopTrigger = new import_async.Trigger();
    this._open = false;
    this._running = false;
  }
  toJSON() {
    return {
      open: this.isOpen,
      running: this.isRunning
    };
  }
  get isOpen() {
    return this._open;
  }
  get isRunning() {
    return this._running;
  }
  async open() {
    if (!this._open) {
      (0, import_log.log)("opening...", void 0, {
        F: __dxlog_file2,
        L: 41,
        S: this,
        C: (f, a) => f(...a)
      });
      await this._onOpen();
      this._open = true;
      await this.start();
      (0, import_log.log)("opened", void 0, {
        F: __dxlog_file2,
        L: 46,
        S: this,
        C: (f, a) => f(...a)
      });
    }
  }
  async close() {
    if (this._open) {
      (0, import_log.log)("closing...", void 0, {
        F: __dxlog_file2,
        L: 52,
        S: this,
        C: (f, a) => f(...a)
      });
      await this.stop();
      await this._onClose();
      this._open = false;
      (0, import_log.log)("closed", void 0, {
        F: __dxlog_file2,
        L: 57,
        S: this,
        C: (f, a) => f(...a)
      });
    }
  }
  async start() {
    (0, import_invariant.invariant)(this._open, void 0, {
      F: __dxlog_file2,
      L: 62,
      S: this,
      A: [
        "this._open",
        ""
      ]
    });
    if (!this._running) {
      this._running = true;
    }
  }
  async stop() {
    (0, import_invariant.invariant)(this._open, void 0, {
      F: __dxlog_file2,
      L: 69,
      S: this,
      A: [
        "this._open",
        ""
      ]
    });
    if (this._running) {
      this._running = false;
      this._stopTrigger.wake();
    }
  }
  //
  // AsyncIterable
  //
  [Symbol.asyncIterator]() {
    return this._generator();
  }
  async *_generator() {
    (0, import_log.log)("started", void 0, {
      F: __dxlog_file2,
      L: 85,
      S: this,
      C: (f, a) => f(...a)
    });
    while (this._running) {
      const block = await (0, import_race_as_promised.default)([
        this._stopTrigger.wait(),
        this._nextBlock()
      ]);
      if (block === void 0) {
        break;
      }
      yield block;
    }
    (0, import_log.log)("stopped", void 0, {
      F: __dxlog_file2,
      L: 97,
      S: this,
      C: (f, a) => f(...a)
    });
  }
};
var FeedIterator = class extends AbstractFeedIterator {
  constructor(_feed) {
    super(), this._feed = _feed;
    this._queue = new FeedQueue(this._feed);
  }
  async _onOpen() {
    await this._queue.open();
  }
  async _onClose() {
    await this._queue.close();
  }
  async _nextBlock() {
    return this._queue.pop();
  }
};
var __dxlog_file3 = "/home/runner/work/dxos/dxos/packages/common/feed-store/src/feed-set-iterator.ts";
var defaultFeedSetIteratorOptions = {
  stallTimeout: 1e3
};
var FeedSetIterator = class extends AbstractFeedIterator {
  constructor(_selector, options = defaultFeedSetIteratorOptions) {
    super(), this._selector = _selector, this.options = options, this._feedQueues = new import_util.ComplexMap(import_keys.PublicKey.hash), this._trigger = new import_async3.Trigger({
      autoReset: true
    }), this._subscriptions = new import_async3.SubscriptionList(), this.stalled = new import_async3.Event();
    (0, import_invariant3.invariant)(_selector, void 0, {
      F: __dxlog_file3,
      L: 55,
      S: this,
      A: [
        "_selector",
        ""
      ]
    });
    (0, import_invariant3.invariant)(options, void 0, {
      F: __dxlog_file3,
      L: 56,
      S: this,
      A: [
        "options",
        ""
      ]
    });
  }
  [import_node_util2.inspect.custom]() {
    return (0, import_debug2.inspectObject)(this);
  }
  toJSON() {
    return {
      open: this.isOpen,
      running: this.isRunning,
      indexes: this.indexes
    };
  }
  get size() {
    return this._feedQueues.size;
  }
  get feeds() {
    return Array.from(this._feedQueues.values()).map((feedQueue) => feedQueue.feed);
  }
  get indexes() {
    return Array.from(this._feedQueues.values()).map((feedQueue) => ({
      feedKey: feedQueue.feed.key,
      index: feedQueue.index
    }));
  }
  reiterateBlock(block) {
    this._trigger.wake();
  }
  async addFeed(feed) {
    (0, import_invariant3.invariant)(!this._feedQueues.has(feed.key), `Feed already added: ${feed.key}`, {
      F: __dxlog_file3,
      L: 91,
      S: this,
      A: [
        "!this._feedQueues.has(feed.key)",
        "`Feed already added: ${feed.key}`"
      ]
    });
    (0, import_invariant3.invariant)(feed.properties.opened, void 0, {
      F: __dxlog_file3,
      L: 92,
      S: this,
      A: [
        "feed.properties.opened",
        ""
      ]
    });
    (0, import_log3.log)("feed added", {
      feedKey: feed.key
    }, {
      F: __dxlog_file3,
      L: 93,
      S: this,
      C: (f, a) => f(...a)
    });
    const queue = new FeedQueue(feed);
    this._feedQueues.set(feed.key, queue);
    this._subscriptions.add(queue.updated.on(() => {
      this._trigger.wake();
    }));
    await queue.open({
      start: this.options.start?.find((index) => index.feedKey.equals(feed.key))?.index
    });
    this._trigger.wake();
  }
  hasFeed(feedKey) {
    return this._feedQueues.has(feedKey);
  }
  async _onOpen() {
    for (const queue of this._feedQueues.values()) {
      await queue.open();
    }
  }
  async _onClose() {
    this._subscriptions.clear();
    await Promise.all(Array.from(this._feedQueues.values()).map((queue) => queue.close()));
    this._trigger.wake();
  }
  /**
  * Gets the next block from the selected queue.
  */
  async _nextBlock() {
    let t;
    while (this._running) {
      const queues = Array.from(this._feedQueues.values());
      const blocks = queues.map((queue) => queue.peek()).filter(import_util.isNonNullable);
      if (blocks.length) {
        const idx = this._selector(blocks);
        (0, import_log3.log)("selected", {
          idx,
          blocks
        }, {
          F: __dxlog_file3,
          L: 143,
          S: this,
          C: (f, a) => f(...a)
        });
        if (idx === void 0) {
          if (t === void 0) {
            t = setTimeout(() => {
              this.stalled.emit(this);
              this._trigger.wake();
            }, this.options.stallTimeout);
          }
        } else {
          if (t !== void 0) {
            clearTimeout(t);
            t = void 0;
          }
          if (idx >= blocks.length) {
            throw new Error(`Index out of bounds: ${idx} of ${blocks.length}`);
          }
          const queue = this._feedQueues.get(blocks[idx].feedKey);
          (0, import_log3.log)("popping", queue.toJSON(), {
            F: __dxlog_file3,
            L: 163,
            S: this,
            C: (f, a) => f(...a)
          });
          try {
            const message = await queue.pop();
            (0, import_invariant3.invariant)(message === blocks[idx], void 0, {
              F: __dxlog_file3,
              L: 166,
              S: this,
              A: [
                "message === blocks[idx]",
                ""
              ]
            });
            return message;
          } catch (err) {
            import_log3.log.warn("queue closed", {
              feedKey: queue.feed.key
            }, {
              F: __dxlog_file3,
              L: 170,
              S: this,
              C: (f, a) => f(...a)
            });
          }
        }
      }
      await this._trigger.wait();
    }
  }
};
var createFeedWriter = (cb) => ({
  write: async (data) => {
    return cb(data);
  }
});
var writeMessages = async (writer, messages) => {
  const receipts = [];
  for (const message of messages) {
    receipts.push(await writer.write(message));
  }
  return receipts;
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AbstractFeedIterator,
  FeedFactory,
  FeedIterator,
  FeedQueue,
  FeedSetIterator,
  FeedStore,
  FeedWrapper,
  createFeedWriter,
  defaultFeedSetIteratorOptions,
  defaultReadStreamOptions,
  writeMessages
});
//# sourceMappingURL=index.cjs.map
