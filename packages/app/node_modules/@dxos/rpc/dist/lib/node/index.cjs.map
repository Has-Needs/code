{
  "version": 3,
  "sources": ["../../../src/rpc.ts", "../../../src/errors.ts", "../../../src/service.ts", "../../../src/testing.ts", "../../../src/trace.ts"],
  "sourcesContent": ["//\n// Copyright 2021 DXOS.org\n//\n\nimport { asyncTimeout, synchronized, Trigger } from '@dxos/async';\nimport { type Any, Stream, type RequestOptions, type ProtoCodec } from '@dxos/codec-protobuf';\nimport { StackTrace } from '@dxos/debug';\nimport { invariant } from '@dxos/invariant';\nimport { log } from '@dxos/log';\nimport { encodeError, RpcClosedError, RpcNotOpenError } from '@dxos/protocols';\nimport { schema } from '@dxos/protocols/proto';\nimport { type Request, type Response, type RpcMessage } from '@dxos/protocols/proto/dxos/rpc';\nimport { exponentialBackoffInterval } from '@dxos/util';\n\nimport { decodeRpcError } from './errors';\n\nconst DEFAULT_TIMEOUT = 3_000;\nconst BYE_SEND_TIMEOUT = 2_000;\n\nconst DEBUG_CALLS = true;\n\ntype MaybePromise<T> = Promise<T> | T;\n\nexport interface RpcPeerOptions {\n  port: RpcPort;\n\n  /**\n   * Time to wait for a response to an RPC call.\n   */\n  timeout?: number;\n\n  callHandler: (method: string, request: Any, options?: RequestOptions) => MaybePromise<Any>;\n  streamHandler?: (method: string, request: Any, options?: RequestOptions) => Stream<Any>;\n\n  /**\n   * Do not require or send handshake messages.\n   */\n  noHandshake?: boolean;\n\n  /**\n   * What options get passed to the `callHandler` and `streamHandler`.\n   */\n  handlerRpcOptions?: RequestOptions;\n}\n\n/**\n * Interface for a transport-agnostic port to send/receive binary messages.\n */\nexport interface RpcPort {\n  send: (msg: Uint8Array, timeout?: number) => MaybePromise<void>;\n  subscribe: (cb: (msg: Uint8Array) => void) => (() => void) | void;\n}\n\nconst CLOSE_TIMEOUT = 3_000;\n\nexport type CloseOptions = {\n  /**\n   * Time to wait for the other side to confirm close.\n   */\n  timeout?: number;\n};\n\nclass PendingRpcRequest {\n  constructor(\n    public readonly resolve: (response: Response) => void,\n    public readonly reject: (error?: Error) => void,\n    public readonly stream: boolean,\n  ) {}\n}\n\n// NOTE: Lazy so that code that doesn't use indexing doesn't need to load the codec (breaks in workerd).\nlet RpcMessageCodec!: ProtoCodec<RpcMessage>;\nconst getRpcMessageCodec = () => (RpcMessageCodec ??= schema.getCodecForType('dxos.rpc.RpcMessage'));\n\nenum RpcState {\n  INITIAL = 'INITIAL',\n\n  OPENING = 'OPENING',\n\n  OPENED = 'OPENED',\n\n  /**\n   * Bye message sent, waiting for the other side to close.\n   * Not possible to send requests.\n   * All pending requests will be rejected.\n   */\n  CLOSING = 'CLOSING',\n\n  /**\n   * Connection fully closed.\n   * The underlying transport can be disposed.\n   */\n  CLOSED = 'CLOSED',\n}\n\n/**\n * A remote procedure call peer.\n *\n * Provides a away to make RPC calls and get a response back as a promise.\n * Does not handle encoding/decoding and only works with byte buffers.\n * For type safe approach see `createRpcClient` and `createRpcServer`.\n *\n * Must be connected with another instance on the other side via `send`/`receive` methods.\n * Both sides must be opened before making any RPC calls.\n *\n * Errors inside the handler get serialized and sent to the other side.\n *\n * Inspired by JSON-RPC 2.0 https://www.jsonrpc.org/specification.\n */\nexport class RpcPeer {\n  private readonly _params: RpcPeerOptions;\n\n  private readonly _outgoingRequests = new Map<number, PendingRpcRequest>();\n  private readonly _localStreams = new Map<number, Stream<any>>();\n  private readonly _remoteOpenTrigger = new Trigger();\n\n  /**\n   * Triggered when the peer starts closing.\n   */\n  private readonly _closingTrigger = new Trigger();\n\n  /**\n   * Triggered when peer receives a bye message.\n   */\n  private readonly _byeTrigger = new Trigger();\n\n  private _nextId = 0;\n  private _state: RpcState = RpcState.INITIAL;\n  private _unsubscribeFromPort: (() => void) | undefined = undefined;\n  private _clearOpenInterval: (() => void) | undefined = undefined;\n\n  constructor(params: RpcPeerOptions) {\n    this._params = {\n      timeout: undefined,\n      streamHandler: undefined,\n      noHandshake: false,\n      ...params,\n    };\n  }\n\n  /**\n   * Open the peer. Required before making any calls.\n   *\n   * Will block before the other peer calls `open`.\n   */\n  @synchronized\n  async open(): Promise<void> {\n    if (this._state !== RpcState.INITIAL) {\n      return;\n    }\n\n    this._unsubscribeFromPort = this._params.port.subscribe(async (msg) => {\n      try {\n        await this._receive(msg);\n      } catch (err: any) {\n        log.catch(err);\n      }\n    }) as any;\n\n    this._state = RpcState.OPENING;\n\n    if (this._params.noHandshake) {\n      this._state = RpcState.OPENED;\n      this._remoteOpenTrigger.wake();\n      return;\n    }\n\n    log('sending open message', { state: this._state });\n    await this._sendMessage({ open: true });\n\n    if (this._state !== RpcState.OPENING) {\n      return;\n    }\n\n    // Retry sending.\n    this._clearOpenInterval = exponentialBackoffInterval(() => {\n      void this._sendMessage({ open: true }).catch((err) => log.warn(err));\n    }, 50);\n\n    await Promise.race([this._remoteOpenTrigger.wait(), this._closingTrigger.wait()]);\n\n    this._clearOpenInterval?.();\n\n    if ((this._state as RpcState) !== RpcState.OPENED) {\n      // Closed while opening.\n      return; // TODO(dmaretskyi): Throw error?\n    }\n\n    // TODO(burdon): This seems error prone.\n    // Send an \"open\" message in case the other peer has missed our first \"open\" message and is still waiting.\n    log('resending open message', { state: this._state });\n    await this._sendMessage({ openAck: true });\n  }\n\n  /**\n   * Close the peer.\n   * Stop taking or making requests.\n   * Will wait for confirmation from the other side.\n   * Any responses for RPC calls made before close will be delivered.\n   */\n  async close({ timeout = CLOSE_TIMEOUT }: CloseOptions = {}): Promise<void> {\n    if (this._state === RpcState.CLOSED) {\n      return;\n    }\n\n    this._abortRequests();\n\n    if (this._state === RpcState.OPENED && !this._params.noHandshake) {\n      try {\n        this._state = RpcState.CLOSING;\n        await this._sendMessage({ bye: {} }, BYE_SEND_TIMEOUT);\n      } catch (err: any) {\n        log('error closing peer, sending bye', { err });\n      }\n      try {\n        log('closing waiting on bye');\n        await this._byeTrigger.wait({ timeout });\n      } catch (err: any) {\n        log('error closing peer', { err });\n        return;\n      }\n    }\n\n    this._disposeAndClose();\n  }\n\n  /**\n   * Dispose the connection without waiting for the other side.\n   */\n  async abort(): Promise<void> {\n    if (this._state === RpcState.CLOSED) {\n      return;\n    }\n\n    this._abortRequests();\n    this._disposeAndClose();\n  }\n\n  private _abortRequests(): void {\n    // Abort open\n    this._clearOpenInterval?.();\n    this._closingTrigger.wake();\n\n    // Abort pending requests\n    for (const req of this._outgoingRequests.values()) {\n      req.reject(new RpcClosedError());\n    }\n    this._outgoingRequests.clear();\n  }\n\n  private _disposeAndClose(): void {\n    this._unsubscribeFromPort?.();\n    this._unsubscribeFromPort = undefined;\n    this._clearOpenInterval?.();\n    this._state = RpcState.CLOSED;\n  }\n\n  /**\n   * Handle incoming message. Should be called as the result of other peer's `send` callback.\n   */\n  private async _receive(msg: Uint8Array): Promise<void> {\n    const decoded = getRpcMessageCodec().decode(msg, { preserveAny: true });\n    DEBUG_CALLS && log('received message', { type: Object.keys(decoded)[0] });\n\n    if (decoded.request) {\n      if (this._state !== RpcState.OPENED && this._state !== RpcState.OPENING) {\n        log('received request while closed');\n        await this._sendMessage({\n          response: {\n            id: decoded.request.id,\n            error: encodeError(new RpcClosedError()),\n          },\n        });\n        return;\n      }\n\n      const req = decoded.request;\n      if (req.stream) {\n        log('stream request', { method: req.method });\n        this._callStreamHandler(req, (response) => {\n          log('sending stream response', {\n            method: req.method,\n            response: response.payload?.type_url,\n            error: response.error,\n            close: response.close,\n          });\n\n          void this._sendMessage({ response }).catch((err) => {\n            log.warn('failed during close', err);\n          });\n        });\n      } else {\n        DEBUG_CALLS && log('requesting...', { method: req.method });\n        const response = await this._callHandler(req);\n        DEBUG_CALLS &&\n          log('sending response', {\n            method: req.method,\n            response: response.payload?.type_url,\n            error: response.error,\n          });\n        await this._sendMessage({ response });\n      }\n    } else if (decoded.response) {\n      if (this._state !== RpcState.OPENED) {\n        log('received response while closed');\n        return; // Ignore when not open.\n      }\n\n      const responseId = decoded.response.id;\n      invariant(typeof responseId === 'number');\n      if (!this._outgoingRequests.has(responseId)) {\n        log('received response with invalid id', { responseId });\n        return; // Ignore requests with incorrect id.\n      }\n\n      const item = this._outgoingRequests.get(responseId)!;\n      // Delete the request record if no more responses are expected.\n      if (!item.stream) {\n        this._outgoingRequests.delete(responseId);\n      }\n\n      DEBUG_CALLS && log('response', { type_url: decoded.response.payload?.type_url });\n      item.resolve(decoded.response);\n    } else if (decoded.open) {\n      log('received open message', { state: this._state });\n      if (this._params.noHandshake) {\n        return;\n      }\n\n      await this._sendMessage({ openAck: true });\n    } else if (decoded.openAck) {\n      log('received openAck message', { state: this._state });\n      if (this._params.noHandshake) {\n        return;\n      }\n\n      this._state = RpcState.OPENED;\n      this._remoteOpenTrigger.wake();\n    } else if (decoded.streamClose) {\n      if (this._state !== RpcState.OPENED) {\n        log('received stream close while closed');\n        return; // Ignore when not open.\n      }\n\n      log('received stream close', { id: decoded.streamClose.id });\n      invariant(typeof decoded.streamClose.id === 'number');\n      const stream = this._localStreams.get(decoded.streamClose.id);\n      if (!stream) {\n        log('no local stream', { id: decoded.streamClose.id });\n        return; // Ignore requests with incorrect id.\n      }\n\n      this._localStreams.delete(decoded.streamClose.id);\n      await stream.close();\n    } else if (decoded.bye) {\n      this._byeTrigger.wake();\n      // If we haven't already started closing, close now.\n      if (this._state !== RpcState.CLOSING && this._state !== RpcState.CLOSED) {\n        log('replying to bye');\n        this._state = RpcState.CLOSING;\n        await this._sendMessage({ bye: {} });\n\n        this._abortRequests();\n        this._disposeAndClose();\n      }\n    } else {\n      log.error('received malformed message', { msg });\n      throw new Error('Malformed message.');\n    }\n  }\n\n  /**\n   * Make RPC call. Will trigger a handler on the other side.\n   * Peer should be open before making this call.\n   */\n  async call(method: string, request: Any, options?: RequestOptions): Promise<Any> {\n    DEBUG_CALLS && log('calling...', { method });\n    throwIfNotOpen(this._state);\n\n    let response: Response;\n    try {\n      // Set-up response listener.\n      const id = this._nextId++;\n      const responseReceived = new Promise<Response>((resolve, reject) => {\n        this._outgoingRequests.set(id, new PendingRpcRequest(resolve, reject, false));\n      });\n\n      // Send request call.\n      const sending = this._sendMessage({\n        request: {\n          id,\n          method,\n          payload: request,\n          stream: false,\n        },\n      });\n\n      // Wait until send completes or throws an error (or response throws a timeout), the resume waiting.\n      const timeout = options?.timeout ?? this._params.timeout;\n      const waiting =\n        timeout === 0 ? responseReceived : asyncTimeout<any>(responseReceived, timeout ?? DEFAULT_TIMEOUT);\n\n      await Promise.race([sending, waiting]);\n      response = await waiting;\n      invariant(response.id === id);\n    } catch (err) {\n      if (err instanceof RpcClosedError) {\n        // Rethrow the error here to have the correct stack-trace.\n        const error = new RpcClosedError();\n        error.stack += `\\n\\n info: RPC client was closed at:\\n${err.stack?.split('\\n').slice(1).join('\\n')}`;\n        throw error;\n      }\n\n      throw err;\n    }\n\n    if (response.payload) {\n      return response.payload;\n    } else if (response.error) {\n      throw decodeRpcError(response.error, method);\n    } else {\n      throw new Error('Malformed response.');\n    }\n  }\n\n  /**\n   * Make RPC call with a streaming response.\n   * Will trigger a handler on the other side.\n   * Peer should be open before making this call.\n   */\n  callStream(method: string, request: Any, options?: RequestOptions): Stream<Any> {\n    throwIfNotOpen(this._state);\n    const id = this._nextId++;\n\n    return new Stream(({ ready, next, close }) => {\n      const onResponse = (response: Response) => {\n        if (response.streamReady) {\n          ready();\n        } else if (response.close) {\n          close();\n        } else if (response.error) {\n          // TODO(dmaretskyi): Stack trace might be lost because the stream producer function is called asynchronously.\n          close(decodeRpcError(response.error, method));\n        } else if (response.payload) {\n          next(response.payload);\n        } else {\n          throw new Error('Malformed response.');\n        }\n      };\n\n      const stack = new StackTrace();\n      const closeStream = (err?: Error) => {\n        if (!err) {\n          close();\n        } else {\n          err.stack += `\\n\\nError happened in the stream at:\\n${stack.getStack()}`;\n          close(err);\n        }\n      };\n\n      this._outgoingRequests.set(id, new PendingRpcRequest(onResponse, closeStream, true));\n\n      this._sendMessage({\n        request: {\n          id,\n          method,\n          payload: request,\n          stream: true,\n        },\n      }).catch((err) => {\n        close(err);\n      });\n\n      return () => {\n        this._sendMessage({\n          streamClose: { id },\n        }).catch((err) => {\n          log.catch(err);\n        });\n        this._outgoingRequests.delete(id);\n      };\n    });\n  }\n\n  private async _sendMessage(message: RpcMessage, timeout?: number): Promise<void> {\n    DEBUG_CALLS && log('sending message', { type: Object.keys(message)[0] });\n    await this._params.port.send(getRpcMessageCodec().encode(message, { preserveAny: true }), timeout);\n  }\n\n  private async _callHandler(req: Request): Promise<Response> {\n    try {\n      invariant(typeof req.id === 'number');\n      invariant(req.payload);\n      invariant(req.method);\n\n      const response = await this._params.callHandler(req.method, req.payload, this._params.handlerRpcOptions);\n      return {\n        id: req.id,\n        payload: response,\n      };\n    } catch (err) {\n      return {\n        id: req.id,\n        error: encodeError(err),\n      };\n    }\n  }\n\n  private _callStreamHandler(req: Request, callback: (response: Response) => void): void {\n    try {\n      invariant(this._params.streamHandler, 'Requests with streaming responses are not supported.');\n      invariant(typeof req.id === 'number');\n      invariant(req.payload);\n      invariant(req.method);\n\n      const responseStream = this._params.streamHandler(req.method, req.payload, this._params.handlerRpcOptions);\n      responseStream.onReady(() => {\n        callback({\n          id: req.id,\n          streamReady: true,\n        });\n      });\n\n      responseStream.subscribe(\n        (msg) => {\n          callback({\n            id: req.id,\n            payload: msg,\n          });\n        },\n        (error) => {\n          if (error) {\n            callback({\n              id: req.id,\n              error: encodeError(error),\n            });\n          } else {\n            callback({\n              id: req.id,\n              close: true,\n            });\n          }\n        },\n      );\n\n      this._localStreams.set(req.id, responseStream);\n    } catch (err: any) {\n      callback({\n        id: req.id,\n        error: encodeError(err),\n      });\n    }\n  }\n}\n\nconst throwIfNotOpen = (state: RpcState) => {\n  switch (state) {\n    case RpcState.OPENED: {\n      return;\n    }\n    case RpcState.INITIAL: {\n      throw new RpcNotOpenError();\n    }\n    case RpcState.CLOSED: {\n      throw new RpcClosedError();\n    }\n  }\n};\n", "//\n// Copyright 2021 DXOS.org\n//\n\nimport { StackTrace } from '@dxos/debug';\nimport { decodeError } from '@dxos/protocols';\nimport { type Error as ErrorResponse } from '@dxos/protocols/proto/dxos/error';\n\nexport const decodeRpcError = (err: ErrorResponse, rpcMethod: string): Error =>\n  decodeError(err, {\n    appendStack: `\\n    at RPC ${rpcMethod} \\n` + new StackTrace().getStack(1),\n  });\n", "//\n// Copyright 2021 DXOS.org\n//\n\nimport {\n  type EncodingOptions,\n  type ServiceDescriptor,\n  type ServiceHandler,\n  type ServiceProvider,\n} from '@dxos/codec-protobuf';\nimport { invariant } from '@dxos/invariant';\n\nimport { RpcPeer, type RpcPeerOptions } from './rpc';\n\n/**\n * Map of service definitions.\n */\n// TODO(burdon): Rename ServiceMap.\nexport type ServiceBundle<Services> = { [Key in keyof Services]: ServiceDescriptor<Services[Key]> };\n\nexport type ServiceHandlers<Services> = { [ServiceName in keyof Services]: ServiceProvider<Services[ServiceName]> };\n\nexport type ServiceTypesOf<Bundle extends ServiceBundle<any>> =\n  Bundle extends ServiceBundle<infer Services> ? Services : never;\n\n/**\n * Groups multiple services together to be served by a single RPC peer.\n */\nexport const createServiceBundle = <Service>(services: ServiceBundle<Service>): ServiceBundle<Service> => services;\n\n/**\n * Type-safe RPC peer.\n */\nexport class ProtoRpcPeer<Service> {\n  constructor(\n    public readonly rpc: Service,\n    private readonly _peer: RpcPeer,\n  ) {}\n\n  async open(): Promise<void> {\n    await this._peer.open();\n  }\n\n  async close(): Promise<void> {\n    await this._peer.close();\n  }\n\n  async abort(): Promise<void> {\n    await this._peer.abort();\n  }\n}\n\nexport interface ProtoRpcPeerOptions<Client, Server> extends Omit<RpcPeerOptions, 'callHandler' | 'streamHandler'> {\n  /**\n   * Services that are expected to be implemented by the counter-space.\n   */\n  // TODO(burdon): Rename proxy.\n  requested?: ServiceBundle<Client>;\n\n  /**\n   * Services exposed to the counter-space.\n   */\n  // TODO(burdon): Rename service.\n  exposed?: ServiceBundle<Server>;\n\n  /**\n   * Handlers for the exposed services\n   */\n  handlers?: ServiceHandlers<Server>;\n\n  /**\n   * Encoding options passed to the underlying proto codec.\n   */\n  encodingOptions?: EncodingOptions;\n}\n\n/**\n * Create type-safe RPC peer from a service bundle.\n * Can both handle and issue requests.\n */\n// TODO(burdon): Currently assumes that the proto service name is unique.\n//  Support multiple instances services definitions (e.g., halo/space invitations).\nexport const createProtoRpcPeer = <Client = {}, Server = {}>({\n  requested,\n  exposed,\n  handlers,\n  encodingOptions,\n  ...rest\n}: ProtoRpcPeerOptions<Client, Server>): ProtoRpcPeer<Client> => {\n  // Create map of RPCs.\n  const exposedRpcs: Record<string, ServiceHandler<any>> = {};\n  if (exposed) {\n    invariant(handlers);\n    for (const serviceName of Object.keys(exposed) as (keyof Server)[]) {\n      // Get full service name with the package name without '.' at the beginning.\n      const serviceFqn = exposed[serviceName].serviceProto.fullName.slice(1);\n      const serviceProvider = handlers[serviceName];\n      exposedRpcs[serviceFqn] = exposed[serviceName].createServer(serviceProvider, encodingOptions);\n    }\n  }\n\n  // Create peer.\n  const peer = new RpcPeer({\n    ...rest,\n\n    callHandler: (method, request, options) => {\n      const [serviceName, methodName] = parseMethodName(method);\n      if (!exposedRpcs[serviceName]) {\n        throw new Error(`Service not supported: ${serviceName}`);\n      }\n\n      return exposedRpcs[serviceName].call(methodName, request, options);\n    },\n\n    streamHandler: (method, request, options) => {\n      const [serviceName, methodName] = parseMethodName(method);\n      if (!exposedRpcs[serviceName]) {\n        throw new Error(`Service not supported: ${serviceName}`);\n      }\n\n      return exposedRpcs[serviceName].callStream(methodName, request, options);\n    },\n  });\n\n  const requestedRpcs: Client = {} as Client;\n  if (requested) {\n    for (const serviceName of Object.keys(requested) as (keyof Client)[]) {\n      // Get full service name with the package name without '.' at the beginning.\n      const serviceFqn = requested[serviceName].serviceProto.fullName.slice(1);\n\n      requestedRpcs[serviceName] = requested[serviceName].createClient(\n        {\n          call: (method, req, options) => peer.call(`${serviceFqn}.${method}`, req, options),\n          callStream: (method, req, options) => peer.callStream(`${serviceFqn}.${method}`, req, options),\n        },\n        encodingOptions,\n      );\n    }\n  }\n\n  return new ProtoRpcPeer(requestedRpcs, peer);\n};\n\nexport const parseMethodName = (method: string): [serviceName: string, methodName: string] => {\n  const separator = method.lastIndexOf('.');\n  const serviceName = method.slice(0, separator);\n  const methodName = method.slice(separator + 1);\n  if (serviceName.length === 0 || methodName.length === 0) {\n    throw new Error(`Invalid method: ${method}`);\n  }\n\n  return [serviceName, methodName];\n};\n\n//\n// TODO(burdon): Remove deprecated (only bot factory).\n//\n\n/**\n * Create a type-safe RPC client.\n * @deprecated Use createProtoRpcPeer instead.\n */\nexport const createRpcClient = <S>(\n  serviceDef: ServiceDescriptor<S>,\n  options: Omit<RpcPeerOptions, 'callHandler'>,\n): ProtoRpcPeer<S> => {\n  const peer = new RpcPeer({\n    ...options,\n    callHandler: () => {\n      throw new Error('Requests to client are not supported.');\n    },\n  });\n\n  const client = serviceDef.createClient({\n    call: peer.call.bind(peer),\n    callStream: peer.callStream.bind(peer),\n  });\n\n  return new ProtoRpcPeer(client, peer);\n};\n\n/**\n * @deprecated\n */\nexport interface RpcServerOptions<S> extends Omit<RpcPeerOptions, 'callHandler'> {\n  service: ServiceDescriptor<S>;\n  handlers: S;\n}\n\n/**\n * Create a type-safe RPC server.\n * @deprecated Use createProtoRpcPeer instead.\n */\nexport const createRpcServer = <S>({ service, handlers, ...rest }: RpcServerOptions<S>): RpcPeer => {\n  const server = service.createServer(handlers);\n  return new RpcPeer({\n    ...rest,\n    callHandler: server.call.bind(server),\n    streamHandler: server.callStream.bind(server),\n  });\n};\n\n/**\n * Create type-safe RPC client from a service bundle.\n * @deprecated Use createProtoRpcPeer instead.\n */\nexport const createBundledRpcClient = <S>(\n  descriptors: ServiceBundle<S>,\n  options: Omit<RpcPeerOptions, 'callHandler' | 'streamHandler'>,\n): ProtoRpcPeer<S> => {\n  return createProtoRpcPeer({\n    requested: descriptors,\n    ...options,\n  });\n};\n\n/**\n * @deprecated\n */\nexport interface RpcBundledServerOptions<S> extends Omit<RpcPeerOptions, 'callHandler'> {\n  services: ServiceBundle<S>;\n  handlers: S;\n}\n\n/**\n * Create type-safe RPC server from a service bundle.\n * @deprecated Use createProtoRpcPeer instead.\n */\n// TODO(burdon): Support late-binding via providers.\nexport const createBundledRpcServer = <S>({ services, handlers, ...rest }: RpcBundledServerOptions<S>): RpcPeer => {\n  const rpc: Record<string, ServiceHandler<any>> = {};\n  for (const serviceName of Object.keys(services) as (keyof S)[]) {\n    // Get full service name with the package name without '.' at the beginning.\n    const serviceFqn = services[serviceName].serviceProto.fullName.slice(1);\n    rpc[serviceFqn] = services[serviceName].createServer(handlers[serviceName] as any);\n  }\n\n  return new RpcPeer({\n    ...rest,\n\n    callHandler: (method, request) => {\n      const [serviceName, methodName] = parseMethodName(method);\n      if (!rpc[serviceName]) {\n        throw new Error(`Service not supported: ${serviceName}`);\n      }\n\n      return rpc[serviceName].call(methodName, request);\n    },\n\n    streamHandler: (method, request) => {\n      const [serviceName, methodName] = parseMethodName(method);\n      if (!rpc[serviceName]) {\n        throw new Error(`Service not supported: ${serviceName}`);\n      }\n\n      return rpc[serviceName].callStream(methodName, request);\n    },\n  });\n};\n", "//\n// Copyright 2021 DXOS.org\n//\n\nimport { isNode } from '@dxos/util';\n\nimport { type RpcPort } from './rpc';\n\nexport type CreateLinkedPortsOptions = {\n  delay?: number;\n};\n\n/**\n * Create bi-directionally linked ports.\n */\nexport const createLinkedPorts = ({ delay }: CreateLinkedPortsOptions = {}): [RpcPort, RpcPort] => {\n  let port1Received: RpcPort['send'] | undefined;\n  let port2Received: RpcPort['send'] | undefined;\n\n  const send = (handler: RpcPort['send'] | undefined, msg: Uint8Array) => {\n    if (delay) {\n      setTimeout(() => handler?.(msg), delay);\n    } else {\n      void handler?.(msg);\n    }\n  };\n\n  const port1: RpcPort = {\n    send: (msg) => send(port2Received, msg),\n    subscribe: (cb) => {\n      port1Received = cb;\n    },\n  };\n\n  const port2: RpcPort = {\n    send: (msg) => send(port1Received, msg),\n    subscribe: (cb) => {\n      port2Received = cb;\n    },\n  };\n\n  return [port1, port2];\n};\n\nexport const encodeMessage = (msg: string): Uint8Array => (isNode() ? Buffer.from(msg) : new TextEncoder().encode(msg));\n", "//\n// Copyright 2021 DXOS.org\n//\n\nimport { Event } from '@dxos/async';\nimport { MessageTrace } from '@dxos/protocols/proto/dxos/rpc';\n\nimport { type RpcPort } from './rpc';\n\nexport class PortTracer {\n  readonly message = new Event<MessageTrace>();\n\n  private readonly _port: RpcPort;\n\n  constructor(private readonly _wrappedPort: RpcPort) {\n    this._port = {\n      send: (msg: Uint8Array) => {\n        this.message.emit({\n          direction: MessageTrace.Direction.OUTGOING,\n          data: msg,\n        });\n\n        return this._wrappedPort.send(msg);\n      },\n      subscribe: (cb: (msg: Uint8Array) => void) => {\n        return this._wrappedPort.subscribe((msg) => {\n          this.message.emit({\n            direction: MessageTrace.Direction.INCOMING,\n            data: msg,\n          });\n          cb(msg);\n        });\n      },\n    };\n  }\n\n  public get port() {\n    return this._port;\n  }\n}\n"],
  "mappings": "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",
  "names": ["import_debug", "import_protocols", "import_invariant", "import_util", "import_async", "decodeRpcError", "err", "rpcMethod", "decodeError", "appendStack", "StackTrace", "getStack", "DEFAULT_TIMEOUT", "BYE_SEND_TIMEOUT", "DEBUG_CALLS", "CLOSE_TIMEOUT", "PendingRpcRequest", "resolve", "reject", "stream", "RpcMessageCodec", "getRpcMessageCodec", "schema", "getCodecForType", "RpcPeer", "params", "_outgoingRequests", "Map", "_localStreams", "_remoteOpenTrigger", "Trigger", "_nextId", "_state", "_unsubscribeFromPort", "undefined", "_clearOpenInterval", "_params", "timeout", "streamHandler", "noHandshake", "open", "port", "subscribe", "msg", "_receive", "log", "catch", "wake", "state", "_sendMessage", "exponentialBackoffInterval", "warn", "Promise", "race", "wait", "_closingTrigger", "openAck", "close", "_abortRequests", "bye", "_byeTrigger", "_disposeAndClose", "abort", "req", "values", "RpcClosedError", "clear", "decoded", "decode", "preserveAny", "type", "Object", "keys", "request", "response", "id", "error", "encodeError", "method", "_callStreamHandler", "payload", "type_url", "_callHandler", "responseId", "invariant", "has", "item", "get", "delete", "streamClose", "Error", "call", "options", "throwIfNotOpen", "responseReceived", "set", "sending", "waiting", "asyncTimeout", "stack", "split", "slice", "join", "callStream", "Stream", "ready", "next", "onResponse", "streamReady", "closeStream", "message", "send", "encode", "callHandler", "handlerRpcOptions", "callback", "responseStream", "onReady", "RpcNotOpenError", "createServiceBundle", "services", "ProtoRpcPeer", "rpc", "_peer", "createProtoRpcPeer", "requested", "exposed", "handlers", "encodingOptions", "rest", "exposedRpcs", "serviceName", "serviceFqn", "serviceProto", "fullName", "serviceProvider", "createServer", "peer", "methodName", "parseMethodName", "requestedRpcs", "createClient", "separator", "lastIndexOf", "length", "createRpcClient", "serviceDef", "client", "bind", "createRpcServer", "service", "server", "createBundledRpcClient", "descriptors", "createBundledRpcServer", "createLinkedPorts", "delay", "port1Received", "port2Received", "handler", "setTimeout", "port1", "cb", "port2", "encodeMessage", "isNode", "Buffer", "from", "TextEncoder", "PortTracer", "_wrappedPort", "Event", "_port", "emit", "direction", "MessageTrace", "Direction", "OUTGOING", "data", "INCOMING"]
}
