import "@dxos/node-std/globals";

// packages/core/mesh/rpc/src/rpc.ts
import { asyncTimeout, synchronized, Trigger } from "@dxos/async";
import { Stream } from "@dxos/codec-protobuf";
import { StackTrace as StackTrace2 } from "@dxos/debug";
import { invariant } from "@dxos/invariant";
import { log } from "@dxos/log";
import { encodeError, RpcClosedError, RpcNotOpenError } from "@dxos/protocols";
import { schema } from "@dxos/protocols/proto";
import { exponentialBackoffInterval } from "@dxos/util";

// packages/core/mesh/rpc/src/errors.ts
import { StackTrace } from "@dxos/debug";
import { decodeError } from "@dxos/protocols";
var decodeRpcError = (err, rpcMethod) => decodeError(err, {
  appendStack: `
    at RPC ${rpcMethod} 
` + new StackTrace().getStack(1)
});

// packages/core/mesh/rpc/src/rpc.ts
function _ts_decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts";
var DEFAULT_TIMEOUT = 3e3;
var BYE_SEND_TIMEOUT = 2e3;
var DEBUG_CALLS = true;
var CLOSE_TIMEOUT = 3e3;
var PendingRpcRequest = class {
  constructor(resolve, reject, stream) {
    this.resolve = resolve;
    this.reject = reject;
    this.stream = stream;
  }
};
var RpcMessageCodec;
var getRpcMessageCodec = () => RpcMessageCodec ??= schema.getCodecForType("dxos.rpc.RpcMessage");
var RpcPeer = class {
  constructor(params) {
    this._outgoingRequests = /* @__PURE__ */ new Map();
    this._localStreams = /* @__PURE__ */ new Map();
    this._remoteOpenTrigger = new Trigger();
    /**
    * Triggered when the peer starts closing.
    */
    this._closingTrigger = new Trigger();
    /**
    * Triggered when peer receives a bye message.
    */
    this._byeTrigger = new Trigger();
    this._nextId = 0;
    this._state = "INITIAL";
    this._unsubscribeFromPort = void 0;
    this._clearOpenInterval = void 0;
    this._params = {
      timeout: void 0,
      streamHandler: void 0,
      noHandshake: false,
      ...params
    };
  }
  /**
  * Open the peer. Required before making any calls.
  *
  * Will block before the other peer calls `open`.
  */
  async open() {
    if (this._state !== "INITIAL") {
      return;
    }
    this._unsubscribeFromPort = this._params.port.subscribe(async (msg) => {
      try {
        await this._receive(msg);
      } catch (err) {
        log.catch(err, void 0, {
          F: __dxlog_file,
          L: 156,
          S: this,
          C: (f, a) => f(...a)
        });
      }
    });
    this._state = "OPENING";
    if (this._params.noHandshake) {
      this._state = "OPENED";
      this._remoteOpenTrigger.wake();
      return;
    }
    log("sending open message", {
      state: this._state
    }, {
      F: __dxlog_file,
      L: 168,
      S: this,
      C: (f, a) => f(...a)
    });
    await this._sendMessage({
      open: true
    });
    if (this._state !== "OPENING") {
      return;
    }
    this._clearOpenInterval = exponentialBackoffInterval(() => {
      void this._sendMessage({
        open: true
      }).catch((err) => log.warn(err, void 0, {
        F: __dxlog_file,
        L: 177,
        S: this,
        C: (f, a) => f(...a)
      }));
    }, 50);
    await Promise.race([
      this._remoteOpenTrigger.wait(),
      this._closingTrigger.wait()
    ]);
    this._clearOpenInterval?.();
    if (this._state !== "OPENED") {
      return;
    }
    log("resending open message", {
      state: this._state
    }, {
      F: __dxlog_file,
      L: 191,
      S: this,
      C: (f, a) => f(...a)
    });
    await this._sendMessage({
      openAck: true
    });
  }
  /**
  * Close the peer.
  * Stop taking or making requests.
  * Will wait for confirmation from the other side.
  * Any responses for RPC calls made before close will be delivered.
  */
  async close({ timeout = CLOSE_TIMEOUT } = {}) {
    if (this._state === "CLOSED") {
      return;
    }
    this._abortRequests();
    if (this._state === "OPENED" && !this._params.noHandshake) {
      try {
        this._state = "CLOSING";
        await this._sendMessage({
          bye: {}
        }, BYE_SEND_TIMEOUT);
      } catch (err) {
        log("error closing peer, sending bye", {
          err
        }, {
          F: __dxlog_file,
          L: 213,
          S: this,
          C: (f, a) => f(...a)
        });
      }
      try {
        log("closing waiting on bye", void 0, {
          F: __dxlog_file,
          L: 216,
          S: this,
          C: (f, a) => f(...a)
        });
        await this._byeTrigger.wait({
          timeout
        });
      } catch (err) {
        log("error closing peer", {
          err
        }, {
          F: __dxlog_file,
          L: 219,
          S: this,
          C: (f, a) => f(...a)
        });
        return;
      }
    }
    this._disposeAndClose();
  }
  /**
  * Dispose the connection without waiting for the other side.
  */
  async abort() {
    if (this._state === "CLOSED") {
      return;
    }
    this._abortRequests();
    this._disposeAndClose();
  }
  _abortRequests() {
    this._clearOpenInterval?.();
    this._closingTrigger.wake();
    for (const req of this._outgoingRequests.values()) {
      req.reject(new RpcClosedError());
    }
    this._outgoingRequests.clear();
  }
  _disposeAndClose() {
    this._unsubscribeFromPort?.();
    this._unsubscribeFromPort = void 0;
    this._clearOpenInterval?.();
    this._state = "CLOSED";
  }
  /**
  * Handle incoming message. Should be called as the result of other peer's `send` callback.
  */
  async _receive(msg) {
    const decoded = getRpcMessageCodec().decode(msg, {
      preserveAny: true
    });
    DEBUG_CALLS && log("received message", {
      type: Object.keys(decoded)[0]
    }, {
      F: __dxlog_file,
      L: 263,
      S: this,
      C: (f, a) => f(...a)
    });
    if (decoded.request) {
      if (this._state !== "OPENED" && this._state !== "OPENING") {
        log("received request while closed", void 0, {
          F: __dxlog_file,
          L: 267,
          S: this,
          C: (f, a) => f(...a)
        });
        await this._sendMessage({
          response: {
            id: decoded.request.id,
            error: encodeError(new RpcClosedError())
          }
        });
        return;
      }
      const req = decoded.request;
      if (req.stream) {
        log("stream request", {
          method: req.method
        }, {
          F: __dxlog_file,
          L: 279,
          S: this,
          C: (f, a) => f(...a)
        });
        this._callStreamHandler(req, (response) => {
          log("sending stream response", {
            method: req.method,
            response: response.payload?.type_url,
            error: response.error,
            close: response.close
          }, {
            F: __dxlog_file,
            L: 281,
            S: this,
            C: (f, a) => f(...a)
          });
          void this._sendMessage({
            response
          }).catch((err) => {
            log.warn("failed during close", err, {
              F: __dxlog_file,
              L: 289,
              S: this,
              C: (f, a) => f(...a)
            });
          });
        });
      } else {
        DEBUG_CALLS && log("requesting...", {
          method: req.method
        }, {
          F: __dxlog_file,
          L: 293,
          S: this,
          C: (f, a) => f(...a)
        });
        const response = await this._callHandler(req);
        DEBUG_CALLS && log("sending response", {
          method: req.method,
          response: response.payload?.type_url,
          error: response.error
        }, {
          F: __dxlog_file,
          L: 296,
          S: this,
          C: (f, a) => f(...a)
        });
        await this._sendMessage({
          response
        });
      }
    } else if (decoded.response) {
      if (this._state !== "OPENED") {
        log("received response while closed", void 0, {
          F: __dxlog_file,
          L: 305,
          S: this,
          C: (f, a) => f(...a)
        });
        return;
      }
      const responseId = decoded.response.id;
      invariant(typeof responseId === "number", void 0, {
        F: __dxlog_file,
        L: 310,
        S: this,
        A: [
          "typeof responseId === 'number'",
          ""
        ]
      });
      if (!this._outgoingRequests.has(responseId)) {
        log("received response with invalid id", {
          responseId
        }, {
          F: __dxlog_file,
          L: 312,
          S: this,
          C: (f, a) => f(...a)
        });
        return;
      }
      const item = this._outgoingRequests.get(responseId);
      if (!item.stream) {
        this._outgoingRequests.delete(responseId);
      }
      DEBUG_CALLS && log("response", {
        type_url: decoded.response.payload?.type_url
      }, {
        F: __dxlog_file,
        L: 322,
        S: this,
        C: (f, a) => f(...a)
      });
      item.resolve(decoded.response);
    } else if (decoded.open) {
      log("received open message", {
        state: this._state
      }, {
        F: __dxlog_file,
        L: 325,
        S: this,
        C: (f, a) => f(...a)
      });
      if (this._params.noHandshake) {
        return;
      }
      await this._sendMessage({
        openAck: true
      });
    } else if (decoded.openAck) {
      log("received openAck message", {
        state: this._state
      }, {
        F: __dxlog_file,
        L: 332,
        S: this,
        C: (f, a) => f(...a)
      });
      if (this._params.noHandshake) {
        return;
      }
      this._state = "OPENED";
      this._remoteOpenTrigger.wake();
    } else if (decoded.streamClose) {
      if (this._state !== "OPENED") {
        log("received stream close while closed", void 0, {
          F: __dxlog_file,
          L: 341,
          S: this,
          C: (f, a) => f(...a)
        });
        return;
      }
      log("received stream close", {
        id: decoded.streamClose.id
      }, {
        F: __dxlog_file,
        L: 345,
        S: this,
        C: (f, a) => f(...a)
      });
      invariant(typeof decoded.streamClose.id === "number", void 0, {
        F: __dxlog_file,
        L: 346,
        S: this,
        A: [
          "typeof decoded.streamClose.id === 'number'",
          ""
        ]
      });
      const stream = this._localStreams.get(decoded.streamClose.id);
      if (!stream) {
        log("no local stream", {
          id: decoded.streamClose.id
        }, {
          F: __dxlog_file,
          L: 349,
          S: this,
          C: (f, a) => f(...a)
        });
        return;
      }
      this._localStreams.delete(decoded.streamClose.id);
      await stream.close();
    } else if (decoded.bye) {
      this._byeTrigger.wake();
      if (this._state !== "CLOSING" && this._state !== "CLOSED") {
        log("replying to bye", void 0, {
          F: __dxlog_file,
          L: 359,
          S: this,
          C: (f, a) => f(...a)
        });
        this._state = "CLOSING";
        await this._sendMessage({
          bye: {}
        });
        this._abortRequests();
        this._disposeAndClose();
      }
    } else {
      log.error("received malformed message", {
        msg
      }, {
        F: __dxlog_file,
        L: 367,
        S: this,
        C: (f, a) => f(...a)
      });
      throw new Error("Malformed message.");
    }
  }
  /**
  * Make RPC call. Will trigger a handler on the other side.
  * Peer should be open before making this call.
  */
  async call(method, request, options) {
    DEBUG_CALLS && log("calling...", {
      method
    }, {
      F: __dxlog_file,
      L: 377,
      S: this,
      C: (f, a) => f(...a)
    });
    throwIfNotOpen(this._state);
    let response;
    try {
      const id = this._nextId++;
      const responseReceived = new Promise((resolve, reject) => {
        this._outgoingRequests.set(id, new PendingRpcRequest(resolve, reject, false));
      });
      const sending = this._sendMessage({
        request: {
          id,
          method,
          payload: request,
          stream: false
        }
      });
      const timeout = options?.timeout ?? this._params.timeout;
      const waiting = timeout === 0 ? responseReceived : asyncTimeout(responseReceived, timeout ?? DEFAULT_TIMEOUT);
      await Promise.race([
        sending,
        waiting
      ]);
      response = await waiting;
      invariant(response.id === id, void 0, {
        F: __dxlog_file,
        L: 405,
        S: this,
        A: [
          "response.id === id",
          ""
        ]
      });
    } catch (err) {
      if (err instanceof RpcClosedError) {
        const error = new RpcClosedError();
        error.stack += `

 info: RPC client was closed at:
${err.stack?.split("\n").slice(1).join("\n")}`;
        throw error;
      }
      throw err;
    }
    if (response.payload) {
      return response.payload;
    } else if (response.error) {
      throw decodeRpcError(response.error, method);
    } else {
      throw new Error("Malformed response.");
    }
  }
  /**
  * Make RPC call with a streaming response.
  * Will trigger a handler on the other side.
  * Peer should be open before making this call.
  */
  callStream(method, request, options) {
    throwIfNotOpen(this._state);
    const id = this._nextId++;
    return new Stream(({ ready, next, close }) => {
      const onResponse = (response) => {
        if (response.streamReady) {
          ready();
        } else if (response.close) {
          close();
        } else if (response.error) {
          close(decodeRpcError(response.error, method));
        } else if (response.payload) {
          next(response.payload);
        } else {
          throw new Error("Malformed response.");
        }
      };
      const stack = new StackTrace2();
      const closeStream = (err) => {
        if (!err) {
          close();
        } else {
          err.stack += `

Error happened in the stream at:
${stack.getStack()}`;
          close(err);
        }
      };
      this._outgoingRequests.set(id, new PendingRpcRequest(onResponse, closeStream, true));
      this._sendMessage({
        request: {
          id,
          method,
          payload: request,
          stream: true
        }
      }).catch((err) => {
        close(err);
      });
      return () => {
        this._sendMessage({
          streamClose: {
            id
          }
        }).catch((err) => {
          log.catch(err, void 0, {
            F: __dxlog_file,
            L: 478,
            S: this,
            C: (f, a) => f(...a)
          });
        });
        this._outgoingRequests.delete(id);
      };
    });
  }
  async _sendMessage(message, timeout) {
    DEBUG_CALLS && log("sending message", {
      type: Object.keys(message)[0]
    }, {
      F: __dxlog_file,
      L: 486,
      S: this,
      C: (f, a) => f(...a)
    });
    await this._params.port.send(getRpcMessageCodec().encode(message, {
      preserveAny: true
    }), timeout);
  }
  async _callHandler(req) {
    try {
      invariant(typeof req.id === "number", void 0, {
        F: __dxlog_file,
        L: 492,
        S: this,
        A: [
          "typeof req.id === 'number'",
          ""
        ]
      });
      invariant(req.payload, void 0, {
        F: __dxlog_file,
        L: 493,
        S: this,
        A: [
          "req.payload",
          ""
        ]
      });
      invariant(req.method, void 0, {
        F: __dxlog_file,
        L: 494,
        S: this,
        A: [
          "req.method",
          ""
        ]
      });
      const response = await this._params.callHandler(req.method, req.payload, this._params.handlerRpcOptions);
      return {
        id: req.id,
        payload: response
      };
    } catch (err) {
      return {
        id: req.id,
        error: encodeError(err)
      };
    }
  }
  _callStreamHandler(req, callback) {
    try {
      invariant(this._params.streamHandler, "Requests with streaming responses are not supported.", {
        F: __dxlog_file,
        L: 511,
        S: this,
        A: [
          "this._params.streamHandler",
          "'Requests with streaming responses are not supported.'"
        ]
      });
      invariant(typeof req.id === "number", void 0, {
        F: __dxlog_file,
        L: 512,
        S: this,
        A: [
          "typeof req.id === 'number'",
          ""
        ]
      });
      invariant(req.payload, void 0, {
        F: __dxlog_file,
        L: 513,
        S: this,
        A: [
          "req.payload",
          ""
        ]
      });
      invariant(req.method, void 0, {
        F: __dxlog_file,
        L: 514,
        S: this,
        A: [
          "req.method",
          ""
        ]
      });
      const responseStream = this._params.streamHandler(req.method, req.payload, this._params.handlerRpcOptions);
      responseStream.onReady(() => {
        callback({
          id: req.id,
          streamReady: true
        });
      });
      responseStream.subscribe((msg) => {
        callback({
          id: req.id,
          payload: msg
        });
      }, (error) => {
        if (error) {
          callback({
            id: req.id,
            error: encodeError(error)
          });
        } else {
          callback({
            id: req.id,
            close: true
          });
        }
      });
      this._localStreams.set(req.id, responseStream);
    } catch (err) {
      callback({
        id: req.id,
        error: encodeError(err)
      });
    }
  }
};
_ts_decorate([
  synchronized
], RpcPeer.prototype, "open", null);
var throwIfNotOpen = (state) => {
  switch (state) {
    case "OPENED": {
      return;
    }
    case "INITIAL": {
      throw new RpcNotOpenError();
    }
    case "CLOSED": {
      throw new RpcClosedError();
    }
  }
};

// packages/core/mesh/rpc/src/service.ts
import { invariant as invariant2 } from "@dxos/invariant";
var __dxlog_file2 = "/home/runner/work/dxos/dxos/packages/core/mesh/rpc/src/service.ts";
var createServiceBundle = (services) => services;
var ProtoRpcPeer = class {
  constructor(rpc, _peer) {
    this.rpc = rpc;
    this._peer = _peer;
  }
  async open() {
    await this._peer.open();
  }
  async close() {
    await this._peer.close();
  }
  async abort() {
    await this._peer.abort();
  }
};
var createProtoRpcPeer = ({ requested, exposed, handlers, encodingOptions, ...rest }) => {
  const exposedRpcs = {};
  if (exposed) {
    invariant2(handlers, void 0, {
      F: __dxlog_file2,
      L: 93,
      S: void 0,
      A: [
        "handlers",
        ""
      ]
    });
    for (const serviceName of Object.keys(exposed)) {
      const serviceFqn = exposed[serviceName].serviceProto.fullName.slice(1);
      const serviceProvider = handlers[serviceName];
      exposedRpcs[serviceFqn] = exposed[serviceName].createServer(serviceProvider, encodingOptions);
    }
  }
  const peer = new RpcPeer({
    ...rest,
    callHandler: (method, request, options) => {
      const [serviceName, methodName] = parseMethodName(method);
      if (!exposedRpcs[serviceName]) {
        throw new Error(`Service not supported: ${serviceName}`);
      }
      return exposedRpcs[serviceName].call(methodName, request, options);
    },
    streamHandler: (method, request, options) => {
      const [serviceName, methodName] = parseMethodName(method);
      if (!exposedRpcs[serviceName]) {
        throw new Error(`Service not supported: ${serviceName}`);
      }
      return exposedRpcs[serviceName].callStream(methodName, request, options);
    }
  });
  const requestedRpcs = {};
  if (requested) {
    for (const serviceName of Object.keys(requested)) {
      const serviceFqn = requested[serviceName].serviceProto.fullName.slice(1);
      requestedRpcs[serviceName] = requested[serviceName].createClient({
        call: (method, req, options) => peer.call(`${serviceFqn}.${method}`, req, options),
        callStream: (method, req, options) => peer.callStream(`${serviceFqn}.${method}`, req, options)
      }, encodingOptions);
    }
  }
  return new ProtoRpcPeer(requestedRpcs, peer);
};
var parseMethodName = (method) => {
  const separator = method.lastIndexOf(".");
  const serviceName = method.slice(0, separator);
  const methodName = method.slice(separator + 1);
  if (serviceName.length === 0 || methodName.length === 0) {
    throw new Error(`Invalid method: ${method}`);
  }
  return [
    serviceName,
    methodName
  ];
};
var createRpcClient = (serviceDef, options) => {
  const peer = new RpcPeer({
    ...options,
    callHandler: () => {
      throw new Error("Requests to client are not supported.");
    }
  });
  const client = serviceDef.createClient({
    call: peer.call.bind(peer),
    callStream: peer.callStream.bind(peer)
  });
  return new ProtoRpcPeer(client, peer);
};
var createRpcServer = ({ service, handlers, ...rest }) => {
  const server = service.createServer(handlers);
  return new RpcPeer({
    ...rest,
    callHandler: server.call.bind(server),
    streamHandler: server.callStream.bind(server)
  });
};
var createBundledRpcClient = (descriptors, options) => {
  return createProtoRpcPeer({
    requested: descriptors,
    ...options
  });
};
var createBundledRpcServer = ({ services, handlers, ...rest }) => {
  const rpc = {};
  for (const serviceName of Object.keys(services)) {
    const serviceFqn = services[serviceName].serviceProto.fullName.slice(1);
    rpc[serviceFqn] = services[serviceName].createServer(handlers[serviceName]);
  }
  return new RpcPeer({
    ...rest,
    callHandler: (method, request) => {
      const [serviceName, methodName] = parseMethodName(method);
      if (!rpc[serviceName]) {
        throw new Error(`Service not supported: ${serviceName}`);
      }
      return rpc[serviceName].call(methodName, request);
    },
    streamHandler: (method, request) => {
      const [serviceName, methodName] = parseMethodName(method);
      if (!rpc[serviceName]) {
        throw new Error(`Service not supported: ${serviceName}`);
      }
      return rpc[serviceName].callStream(methodName, request);
    }
  });
};

// packages/core/mesh/rpc/src/testing.ts
import { isNode } from "@dxos/util";
var createLinkedPorts = ({ delay } = {}) => {
  let port1Received;
  let port2Received;
  const send = (handler, msg) => {
    if (delay) {
      setTimeout(() => handler?.(msg), delay);
    } else {
      void handler?.(msg);
    }
  };
  const port1 = {
    send: (msg) => send(port2Received, msg),
    subscribe: (cb) => {
      port1Received = cb;
    }
  };
  const port2 = {
    send: (msg) => send(port1Received, msg),
    subscribe: (cb) => {
      port2Received = cb;
    }
  };
  return [
    port1,
    port2
  ];
};
var encodeMessage = (msg) => isNode() ? Buffer.from(msg) : new TextEncoder().encode(msg);

// packages/core/mesh/rpc/src/trace.ts
import { Event } from "@dxos/async";
import { MessageTrace } from "@dxos/protocols/proto/dxos/rpc";
var PortTracer = class {
  constructor(_wrappedPort) {
    this._wrappedPort = _wrappedPort;
    this.message = new Event();
    this._port = {
      send: (msg) => {
        this.message.emit({
          direction: MessageTrace.Direction.OUTGOING,
          data: msg
        });
        return this._wrappedPort.send(msg);
      },
      subscribe: (cb) => {
        return this._wrappedPort.subscribe((msg) => {
          this.message.emit({
            direction: MessageTrace.Direction.INCOMING,
            data: msg
          });
          cb(msg);
        });
      }
    };
  }
  get port() {
    return this._port;
  }
};
export {
  PortTracer,
  ProtoRpcPeer,
  RpcPeer,
  createBundledRpcClient,
  createBundledRpcServer,
  createLinkedPorts,
  createProtoRpcPeer,
  createRpcClient,
  createRpcServer,
  createServiceBundle,
  decodeRpcError,
  encodeMessage,
  parseMethodName
};
//# sourceMappingURL=index.mjs.map
