import { type LogConfig, type LogOptions } from './config';
import { type LogContext, type LogProcessor } from './context';
import { type CallMetadata } from './meta';
/**
 * Logging function.
 */
type LogFunction = (message: string, context?: LogContext, meta?: CallMetadata) => void;
/**
 * Logging methods.
 */
export interface LogMethods {
    trace: LogFunction;
    debug: LogFunction;
    verbose: LogFunction;
    info: LogFunction;
    warn: LogFunction;
    error: LogFunction;
    catch: (error: Error | any, context?: LogContext, meta?: CallMetadata) => void;
    break: () => void;
    stack: (message?: string, context?: never, meta?: CallMetadata) => void;
    method: (arg0?: never, arg1?: never, meta?: CallMetadata) => MethodDecorator;
    func: <F extends (...args: any[]) => any>(name: string, fn: F, opts?: {
        transformOutput?: (result: ReturnType<F>) => Promise<any> | any;
    }) => F;
}
/**
 * Properties accessible on the logging function.
 */
interface Log extends LogMethods, LogFunction {
    config: (options: LogOptions) => void;
    addProcessor: (processor: LogProcessor) => void;
    runtimeConfig: LogConfig;
}
/**
 * Global logging function.
 */
export declare const log: Log;
/**
 * Log debug stack.
 */
export declare const debug: (label?: any, args?: any) => void;
/**
 * Accessible from browser console.
 */
declare global {
    const dx_log: Log;
}
export {};
//# sourceMappingURL=log.d.ts.map