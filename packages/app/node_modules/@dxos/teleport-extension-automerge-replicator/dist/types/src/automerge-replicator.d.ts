import { type PublicKey } from '@dxos/keys';
import { type PeerInfo, type SyncMessage } from '@dxos/protocols/proto/dxos/mesh/teleport/automerge';
import { type ExtensionContext, type TeleportExtension } from '@dxos/teleport';
export type AutomergeReplicatorParams = {
    /**
     * The peerId of local automerge repo.
     */
    peerId: string;
    sendSyncRetryPolicy?: {
        retriesBeforeBackoff: number;
        retryBackoff: number;
        maxRetries: number;
    };
};
export type AutomergeReplicatorCallbacks = {
    /**
     * Callback to be called when remote peer starts replication.
     */
    onStartReplication?: (info: PeerInfo, remotePeerId: PublicKey) => Promise<void>;
    /**
     * Callback to be called when a sync message is received.
     */
    onSyncMessage?: (message: SyncMessage) => Promise<void>;
    /**
     * Callback to be called when the extension is closed.
     */
    onClose?: (err?: Error) => Promise<void>;
};
export type AutomergeReplicatorFactory = (params: ConstructorParameters<typeof AutomergeReplicator>) => AutomergeReplicator;
/**
 * Sends automerge messages between two peers for a single teleport session.
 */
export declare class AutomergeReplicator implements TeleportExtension {
    private readonly _params;
    private readonly _callbacks;
    private readonly _opened;
    private _rpc?;
    private _destroyed;
    private _extensionContext?;
    constructor(_params: AutomergeReplicatorParams, _callbacks?: AutomergeReplicatorCallbacks);
    onOpen(context: ExtensionContext): Promise<void>;
    onClose(err?: Error): Promise<void>;
    onAbort(err?: Error): Promise<void>;
    private _destroy;
    sendSyncMessage(message: SyncMessage): Promise<void>;
}
//# sourceMappingURL=automerge-replicator.d.ts.map