{
  "version": 3,
  "sources": ["../../../src/automerge-replicator.ts"],
  "sourcesContent": ["//\n// Copyright 2023 DXOS.org\n//\n\nimport { Trigger, sleep } from '@dxos/async';\nimport { invariant } from '@dxos/invariant';\nimport { type PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { RpcClosedError } from '@dxos/protocols';\nimport { schema } from '@dxos/protocols/proto';\nimport {\n  type PeerInfo,\n  type AutomergeReplicatorService,\n  type SyncMessage,\n} from '@dxos/protocols/proto/dxos/mesh/teleport/automerge';\nimport { createProtoRpcPeer, type ProtoRpcPeer } from '@dxos/rpc';\nimport { type ExtensionContext, type TeleportExtension } from '@dxos/teleport';\n\nexport type AutomergeReplicatorParams = {\n  /**\n   * The peerId of local automerge repo.\n   */\n  peerId: string;\n  sendSyncRetryPolicy?: {\n    retriesBeforeBackoff: number;\n    retryBackoff: number;\n    maxRetries: number;\n  };\n};\n\nexport type AutomergeReplicatorCallbacks = {\n  /**\n   * Callback to be called when remote peer starts replication.\n   */\n  onStartReplication?: (info: PeerInfo, remotePeerId: PublicKey) => Promise<void>;\n\n  /**\n   * Callback to be called when a sync message is received.\n   */\n  onSyncMessage?: (message: SyncMessage) => Promise<void>;\n\n  /**\n   * Callback to be called when the extension is closed.\n   */\n  onClose?: (err?: Error) => Promise<void>;\n};\n\nconst RPC_TIMEOUT = 10_000;\n\nconst DEFAULT_RETRY_POLICY: NonNullable<AutomergeReplicatorParams['sendSyncRetryPolicy']> = {\n  retriesBeforeBackoff: 3,\n  retryBackoff: 1_000,\n  maxRetries: 10,\n};\n\nexport type AutomergeReplicatorFactory = (\n  params: ConstructorParameters<typeof AutomergeReplicator>,\n) => AutomergeReplicator;\n\n/**\n * Sends automerge messages between two peers for a single teleport session.\n */\nexport class AutomergeReplicator implements TeleportExtension {\n  private readonly _opened = new Trigger();\n  private _rpc?: ProtoRpcPeer<ServiceBundle>;\n\n  private _destroyed: boolean = false;\n  private _extensionContext?: ExtensionContext;\n\n  constructor(\n    private readonly _params: AutomergeReplicatorParams,\n    private readonly _callbacks: AutomergeReplicatorCallbacks = {},\n  ) {}\n\n  async onOpen(context: ExtensionContext): Promise<void> {\n    log('onOpen', { localPeerId: context.localPeerId, remotePeerId: context.remotePeerId });\n    this._extensionContext = context;\n    this._rpc = createProtoRpcPeer<ServiceBundle, ServiceBundle>({\n      timeout: RPC_TIMEOUT,\n      requested: {\n        AutomergeReplicatorService: schema.getService('dxos.mesh.teleport.automerge.AutomergeReplicatorService'),\n      },\n      exposed: {\n        AutomergeReplicatorService: schema.getService('dxos.mesh.teleport.automerge.AutomergeReplicatorService'),\n      },\n      handlers: {\n        AutomergeReplicatorService: {\n          startReplication: async (info: PeerInfo): Promise<void> => {\n            log('startReplication', { localPeerId: context.localPeerId, remotePeerId: context.remotePeerId, info });\n            await this._callbacks.onStartReplication?.(info, context.remotePeerId);\n          },\n          sendSyncMessage: async (message: SyncMessage): Promise<void> => {\n            await this._callbacks.onSyncMessage?.(message);\n          },\n        },\n      },\n      port: await context.createPort('rpc', {\n        contentType: 'application/x-protobuf; messageType=\"dxos.rpc.Message\"',\n      }),\n    });\n    await this._rpc.open();\n    // Announce to remote peer that we are ready to start replication.\n    await this._rpc.rpc.AutomergeReplicatorService.startReplication({ id: this._params.peerId });\n    this._opened.wake();\n  }\n\n  async onClose(err?: Error): Promise<void> {\n    await this._rpc?.close();\n    await this._destroy(err);\n  }\n\n  async onAbort(err?: Error): Promise<void> {\n    log('abort', { err });\n    await this._rpc?.abort();\n    await this._destroy(err);\n  }\n\n  private async _destroy(err?: Error): Promise<void> {\n    this._destroyed = true;\n    this._rpc = undefined;\n    this._extensionContext = undefined;\n    await this._callbacks.onClose?.(err);\n  }\n\n  async sendSyncMessage(message: SyncMessage): Promise<void> {\n    invariant(!this._destroyed);\n    await this._opened.wait();\n    invariant(this._rpc, 'RPC not initialized');\n\n    const retryPolicy = this._params.sendSyncRetryPolicy ?? DEFAULT_RETRY_POLICY;\n    let retries = 0;\n    while (true) {\n      try {\n        await this._rpc.rpc.AutomergeReplicatorService.sendSyncMessage(message);\n        break;\n      } catch (err) {\n        if (err instanceof RpcClosedError) {\n          return;\n        }\n\n        log('sendSyncMessage error', { err });\n\n        retries++;\n        if (retries >= retryPolicy.maxRetries) {\n          const numberOfRetriesExceededError = new Error(\n            `Failed to send sync message after ${retryPolicy.maxRetries} retries. Last attempt failed with error: ${err}`,\n          );\n          this._extensionContext?.close(numberOfRetriesExceededError);\n          throw numberOfRetriesExceededError;\n        }\n        if (retries % retryPolicy.retriesBeforeBackoff === 0) {\n          await sleep(retryPolicy.retryBackoff);\n        }\n      }\n    }\n  }\n}\n\ntype ServiceBundle = {\n  AutomergeReplicatorService: AutomergeReplicatorService;\n};\n"],
  "mappings": "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",
  "names": ["RPC_TIMEOUT", "DEFAULT_RETRY_POLICY", "retriesBeforeBackoff", "retryBackoff", "maxRetries", "AutomergeReplicator", "_params", "_callbacks", "_opened", "Trigger", "_destroyed", "onOpen", "context", "log", "localPeerId", "remotePeerId", "_extensionContext", "_rpc", "createProtoRpcPeer", "timeout", "requested", "AutomergeReplicatorService", "schema", "getService", "exposed", "handlers", "startReplication", "info", "onStartReplication", "sendSyncMessage", "message", "onSyncMessage", "port", "createPort", "contentType", "open", "rpc", "id", "peerId", "wake", "onClose", "err", "close", "_destroy", "onAbort", "abort", "undefined", "invariant", "wait", "retryPolicy", "sendSyncRetryPolicy", "retries", "RpcClosedError", "numberOfRetriesExceededError", "Error", "sleep"]
}
