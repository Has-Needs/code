{
  "version": 3,
  "sources": ["../../../src/replicator-extension.ts"],
  "sourcesContent": ["//\n// Copyright 2022 DXOS.org\n//\n\nimport type { ProtocolStream } from 'hypercore-protocol';\nimport { type Duplex } from 'node:stream';\n\nimport { asyncTimeout, DeferredTask, synchronized } from '@dxos/async';\nimport { Context } from '@dxos/context';\nimport { failUndefined } from '@dxos/debug';\nimport { type FeedWrapper } from '@dxos/feed-store';\nimport { invariant } from '@dxos/invariant';\nimport { PublicKey } from '@dxos/keys';\nimport { log, logInfo } from '@dxos/log';\nimport { RpcClosedError, TimeoutError } from '@dxos/protocols';\nimport { schema } from '@dxos/protocols/proto';\nimport { type FeedInfo, type ReplicatorService } from '@dxos/protocols/proto/dxos/mesh/teleport/replicator';\nimport { createProtoRpcPeer, type ProtoRpcPeer } from '@dxos/rpc';\nimport { type ExtensionContext, type TeleportExtension } from '@dxos/teleport';\nimport { ComplexMap } from '@dxos/util';\n\nexport type ReplicationOptions = {\n  upload: boolean;\n};\n\n/**\n * Manages replication between a set of feeds for a single teleport session.\n */\nexport class ReplicatorExtension implements TeleportExtension {\n  private readonly _ctx = new Context({\n    onError: (err) => {\n      this._extensionContext?.close(err);\n    },\n  });\n\n  private readonly _feeds = new ComplexMap<PublicKey, FeedWrapper<any>>(PublicKey.hash);\n  private readonly _streams = new ComplexMap<PublicKey, ActiveStream>(PublicKey.hash);\n\n  private _rpc?: ProtoRpcPeer<ServiceBundle>;\n  private _extensionContext?: ExtensionContext;\n\n  private _options: ReplicationOptions = {\n    upload: false,\n  };\n\n  private readonly _updateTask = new DeferredTask(this._ctx, async () => {\n    try {\n      if (this._extensionContext!.initiator === false) {\n        await this._rpc!.rpc.ReplicatorService.updateFeeds({\n          feeds: Array.from(this._feeds.values()).map((feed) => ({\n            feedKey: feed.key,\n            download: true,\n            upload: this._options.upload,\n          })),\n        });\n      } else if (this._extensionContext!.initiator === true) {\n        await this._reevaluateFeeds();\n      }\n    } catch (err) {\n      if (err instanceof RpcClosedError) {\n        return; // Some RPC requests might be pending while closing.\n      }\n      throw err;\n    }\n  });\n\n  @logInfo\n  private get extensionInfo() {\n    return {\n      initiator: this._extensionContext?.initiator,\n      localPeerId: this._extensionContext?.localPeerId,\n      remotePeerId: this._extensionContext?.remotePeerId,\n      feeds: Array.from(this._feeds.keys()),\n    };\n  }\n\n  setOptions(options: ReplicationOptions): this {\n    this._options = options;\n    log('setOptions', { options });\n    if (this._extensionContext) {\n      this._updateTask.schedule();\n    }\n    return this;\n  }\n\n  addFeed(feed: FeedWrapper<any>): void {\n    this._feeds.set(feed.key, feed);\n    log('addFeed', { feedKey: feed.key });\n    if (this._extensionContext) {\n      this._updateTask.schedule();\n    }\n  }\n\n  async onOpen(context: ExtensionContext): Promise<void> {\n    this._extensionContext = context;\n    log('open');\n\n    this._rpc = createProtoRpcPeer<ServiceBundle, ServiceBundle>({\n      requested: {\n        ReplicatorService: schema.getService('dxos.mesh.teleport.replicator.ReplicatorService'),\n      },\n      exposed: {\n        ReplicatorService: schema.getService('dxos.mesh.teleport.replicator.ReplicatorService'),\n      },\n      handlers: {\n        ReplicatorService: {\n          updateFeeds: async ({ feeds }) => {\n            log('received feed info', { feeds });\n            invariant(this._extensionContext!.initiator === true, 'Invalid call');\n            this._updateTask.schedule();\n          },\n          startReplication: async ({ info }) => {\n            log('starting replication...', { info });\n            invariant(this._extensionContext!.initiator === false, 'Invalid call');\n\n            const streamTag = await this._acceptReplication(info);\n            return {\n              streamTag,\n            };\n          },\n          stopReplication: async ({ info }) => {\n            log('stopping replication...', { info });\n            // TODO(dmaretskyi): Make sure any peer can stop replication.\n            invariant(this._extensionContext!.initiator === false, 'Invalid call');\n\n            await this._stopReplication(info.feedKey);\n          },\n        },\n      },\n      port: await context.createPort('rpc', {\n        contentType: 'application/x-protobuf; messageType=\"dxos.rpc.Message\"',\n      }),\n      timeout: 10_000,\n    });\n    await this._rpc.open();\n\n    this._updateTask.schedule();\n  }\n\n  async onClose(err?: Error | undefined): Promise<void> {\n    log('close', { err });\n    await this._ctx.dispose();\n    await this._rpc?.close();\n    for (const feedKey of this._streams.keys()) {\n      await this._stopReplication(feedKey);\n    }\n  }\n\n  async onAbort(err?: Error | undefined): Promise<void> {\n    log('abort', { err });\n\n    await this._ctx.dispose();\n    await this._rpc?.abort();\n    for (const feedKey of this._streams.keys()) {\n      await this._stopReplication(feedKey);\n    }\n  }\n\n  @synchronized\n  private async _reevaluateFeeds(): Promise<void> {\n    log('_reevaluateFeeds');\n    for (const feedKey of this._feeds.keys()) {\n      if (this._ctx.disposed) {\n        return;\n      }\n      if (this._streams.has(feedKey) && this._options.upload !== this._streams.get(feedKey)?.info.upload) {\n        try {\n          await asyncTimeout(this._stopReplication(feedKey), 1000);\n        } catch (err) {\n          log.catch(err);\n        }\n      }\n\n      if (this._ctx.disposed) {\n        return;\n      }\n      if (!this._streams.has(feedKey)) {\n        await this._initiateReplication({\n          feedKey,\n          download: true,\n          upload: this._options.upload,\n        });\n      }\n    }\n  }\n\n  /**\n   * Try to initiate feed replication.\n   */\n  private async _initiateReplication(feedInfo: FeedInfo): Promise<void> {\n    log('initiating replication', { feedInfo });\n    invariant(this._extensionContext!.initiator === true, 'Invalid call');\n    invariant(!this._streams.has(feedInfo.feedKey), `Replication already in progress for feed: ${feedInfo.feedKey}`);\n    const { streamTag } = await this._rpc!.rpc.ReplicatorService.startReplication({ info: feedInfo });\n    if (!streamTag) {\n      return;\n    }\n\n    await this._replicateFeed(feedInfo, streamTag);\n  }\n\n  /**\n   * Respond to a remote request to replicate a feed.\n   * @returns A stream tag for the replication stream or `undefined` if we don't want to replicate.\n   */\n  @synchronized\n  private async _acceptReplication(feedInfo: FeedInfo): Promise<string | undefined> {\n    invariant(this._extensionContext!.initiator === false, 'Invalid call');\n\n    if (!this._feeds.has(feedInfo.feedKey) || this._streams.has(feedInfo.feedKey)) {\n      return undefined; // We don't have the feed or we are already replicating it.\n    }\n\n    const tag = `feed-${feedInfo.feedKey.toHex()}-${PublicKey.random().toHex().slice(0, 8)}`; // Generate a unique tag for the stream.\n    await this._replicateFeed(feedInfo, tag);\n    return tag;\n  }\n\n  private async _replicateFeed(info: FeedInfo, streamTag: string): Promise<void> {\n    log('replicate', { info, streamTag });\n    invariant(!this._streams.has(info.feedKey), `Replication already in progress for feed: ${info.feedKey}`);\n\n    const feed = this._feeds.get(info.feedKey) ?? failUndefined();\n    const networkStream = await this._extensionContext!.createStream(streamTag, {\n      contentType: 'application/x-hypercore',\n    });\n    let replicationStreamErrors = 0;\n\n    // https://github.com/holepunchto/hypercore/tree/v9.12.0#var-stream--feedreplicateisinitiator-options\n    const replicationStream = feed.replicate(true, {\n      live: true,\n      upload: info.upload,\n      download: info.download,\n      noise: false,\n      encrypted: false,\n      maxRequests: 1024,\n    });\n\n    // Left for testing.\n    // const debug = true;\n    // if (debug) {\n    //   feed.on('sync', () => {\n    //     log.info('sync', { key: feed.key, length: feed.length });\n    //   });\n    //   feed.on('download', (index: number, data: any) => {\n    //     log.info('download', {\n    //       key: feed.key,\n    //       index,\n    //       length: feed.length,\n    //       data: data.length,\n    //     });\n    //   });\n    // }\n\n    replicationStream.on('error', (err) => {\n      if (err instanceof TimeoutError) {\n        log.info('replication stream timeout', { err, info });\n        return;\n      }\n      // TODO(nf): use sentinel errors\n      if (\n        err?.message === 'Writable stream closed prematurely' ||\n        err?.message === 'Cannot call write after a stream was destroyed'\n      ) {\n        log('replication stream closed', { err, info });\n        return;\n      }\n\n      // TODO(nf): WARN on first error? log full info on some subsequent errors?\n      if (replicationStreamErrors === 0) {\n        log.info('replication stream error', { err, info });\n      } else {\n        log.info('replication stream error', { err, feedKey: info.feedKey, count: replicationStreamErrors });\n      }\n      replicationStreamErrors++;\n    });\n\n    this._streams.set(info.feedKey, {\n      streamTag,\n      networkStream,\n      replicationStream,\n      info,\n    });\n\n    networkStream.pipe(replicationStream as any).pipe(networkStream);\n  }\n\n  private async _stopReplication(feedKey: PublicKey): Promise<void> {\n    const stream = this._streams.get(feedKey);\n    if (!stream) {\n      return;\n    }\n\n    stream.networkStream.destroy();\n    this._streams.delete(feedKey);\n  }\n}\n\ntype ServiceBundle = {\n  ReplicatorService: ReplicatorService;\n};\n\ntype ActiveStream = {\n  streamTag: string;\n  networkStream: Duplex;\n  replicationStream: ProtocolStream;\n  info: FeedInfo;\n};\n"],
  "mappings": "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",
  "names": ["ReplicatorExtension", "_ctx", "Context", "onError", "err", "_extensionContext", "close", "_feeds", "ComplexMap", "PublicKey", "hash", "_streams", "_options", "upload", "_updateTask", "DeferredTask", "initiator", "_rpc", "rpc", "ReplicatorService", "updateFeeds", "feeds", "Array", "from", "values", "map", "feed", "feedKey", "key", "download", "_reevaluateFeeds", "RpcClosedError", "extensionInfo", "localPeerId", "remotePeerId", "keys", "setOptions", "options", "log", "schedule", "addFeed", "set", "onOpen", "context", "createProtoRpcPeer", "requested", "schema", "getService", "exposed", "handlers", "invariant", "startReplication", "info", "streamTag", "_acceptReplication", "stopReplication", "_stopReplication", "port", "createPort", "contentType", "timeout", "open", "onClose", "dispose", "onAbort", "abort", "disposed", "has", "get", "asyncTimeout", "catch", "_initiateReplication", "feedInfo", "_replicateFeed", "undefined", "tag", "toHex", "random", "slice", "failUndefined", "networkStream", "createStream", "replicationStreamErrors", "replicationStream", "replicate", "live", "noise", "encrypted", "maxRequests", "on", "TimeoutError", "message", "count", "pipe", "stream", "destroy", "delete"]
}
