{
  "version": 3,
  "sources": ["../../../src/replicator-extension.ts"],
  "sourcesContent": ["//\n// Copyright 2022 DXOS.org\n//\n\nimport type { ProtocolStream } from 'hypercore-protocol';\nimport { type Duplex } from 'node:stream';\n\nimport { asyncTimeout, DeferredTask, synchronized } from '@dxos/async';\nimport { Context } from '@dxos/context';\nimport { failUndefined } from '@dxos/debug';\nimport { type FeedWrapper } from '@dxos/feed-store';\nimport { invariant } from '@dxos/invariant';\nimport { PublicKey } from '@dxos/keys';\nimport { log, logInfo } from '@dxos/log';\nimport { RpcClosedError, TimeoutError } from '@dxos/protocols';\nimport { schema } from '@dxos/protocols/proto';\nimport { type FeedInfo, type ReplicatorService } from '@dxos/protocols/proto/dxos/mesh/teleport/replicator';\nimport { createProtoRpcPeer, type ProtoRpcPeer } from '@dxos/rpc';\nimport { type ExtensionContext, type TeleportExtension } from '@dxos/teleport';\nimport { ComplexMap } from '@dxos/util';\n\nexport type ReplicationOptions = {\n  upload: boolean;\n};\n\n/**\n * Manages replication between a set of feeds for a single teleport session.\n */\nexport class ReplicatorExtension implements TeleportExtension {\n  private readonly _ctx = new Context({\n    onError: (err) => {\n      this._extensionContext?.close(err);\n    },\n  });\n\n  private readonly _feeds = new ComplexMap<PublicKey, FeedWrapper<any>>(PublicKey.hash);\n  private readonly _streams = new ComplexMap<PublicKey, ActiveStream>(PublicKey.hash);\n\n  private _rpc?: ProtoRpcPeer<ServiceBundle>;\n  private _extensionContext?: ExtensionContext;\n\n  private _options: ReplicationOptions = {\n    upload: false,\n  };\n\n  private readonly _updateTask = new DeferredTask(this._ctx, async () => {\n    try {\n      if (this._extensionContext!.initiator === false) {\n        await this._rpc!.rpc.ReplicatorService.updateFeeds({\n          feeds: Array.from(this._feeds.values()).map((feed) => ({\n            feedKey: feed.key,\n            download: true,\n            upload: this._options.upload,\n          })),\n        });\n      } else if (this._extensionContext!.initiator === true) {\n        await this._reevaluateFeeds();\n      }\n    } catch (err) {\n      if (err instanceof RpcClosedError) {\n        return; // Some RPC requests might be pending while closing.\n      }\n      throw err;\n    }\n  });\n\n  @logInfo\n  private get extensionInfo() {\n    return {\n      initiator: this._extensionContext?.initiator,\n      localPeerId: this._extensionContext?.localPeerId,\n      remotePeerId: this._extensionContext?.remotePeerId,\n      feeds: Array.from(this._feeds.keys()),\n    };\n  }\n\n  setOptions(options: ReplicationOptions): this {\n    this._options = options;\n    log('setOptions', { options });\n    if (this._extensionContext) {\n      this._updateTask.schedule();\n    }\n    return this;\n  }\n\n  addFeed(feed: FeedWrapper<any>): void {\n    this._feeds.set(feed.key, feed);\n    log('addFeed', { feedKey: feed.key });\n    if (this._extensionContext) {\n      this._updateTask.schedule();\n    }\n  }\n\n  async onOpen(context: ExtensionContext): Promise<void> {\n    this._extensionContext = context;\n    log('open');\n\n    this._rpc = createProtoRpcPeer<ServiceBundle, ServiceBundle>({\n      requested: {\n        ReplicatorService: schema.getService('dxos.mesh.teleport.replicator.ReplicatorService'),\n      },\n      exposed: {\n        ReplicatorService: schema.getService('dxos.mesh.teleport.replicator.ReplicatorService'),\n      },\n      handlers: {\n        ReplicatorService: {\n          updateFeeds: async ({ feeds }) => {\n            log('received feed info', { feeds });\n            invariant(this._extensionContext!.initiator === true, 'Invalid call');\n            this._updateTask.schedule();\n          },\n          startReplication: async ({ info }) => {\n            log('starting replication...', { info });\n            invariant(this._extensionContext!.initiator === false, 'Invalid call');\n\n            const streamTag = await this._acceptReplication(info);\n            return {\n              streamTag,\n            };\n          },\n          stopReplication: async ({ info }) => {\n            log('stopping replication...', { info });\n            // TODO(dmaretskyi): Make sure any peer can stop replication.\n            invariant(this._extensionContext!.initiator === false, 'Invalid call');\n\n            await this._stopReplication(info.feedKey);\n          },\n        },\n      },\n      port: await context.createPort('rpc', {\n        contentType: 'application/x-protobuf; messageType=\"dxos.rpc.Message\"',\n      }),\n      timeout: 10_000,\n    });\n    await this._rpc.open();\n\n    this._updateTask.schedule();\n  }\n\n  async onClose(err?: Error | undefined): Promise<void> {\n    log('close', { err });\n    await this._ctx.dispose();\n    await this._rpc?.close();\n    for (const feedKey of this._streams.keys()) {\n      await this._stopReplication(feedKey);\n    }\n  }\n\n  async onAbort(err?: Error | undefined): Promise<void> {\n    log('abort', { err });\n\n    await this._ctx.dispose();\n    await this._rpc?.abort();\n    for (const feedKey of this._streams.keys()) {\n      await this._stopReplication(feedKey);\n    }\n  }\n\n  @synchronized\n  private async _reevaluateFeeds(): Promise<void> {\n    log('_reevaluateFeeds');\n    for (const feedKey of this._feeds.keys()) {\n      if (this._ctx.disposed) {\n        return;\n      }\n      if (this._streams.has(feedKey) && this._options.upload !== this._streams.get(feedKey)?.info.upload) {\n        try {\n          await asyncTimeout(this._stopReplication(feedKey), 1000);\n        } catch (err) {\n          log.catch(err);\n        }\n      }\n\n      if (this._ctx.disposed) {\n        return;\n      }\n      if (!this._streams.has(feedKey)) {\n        await this._initiateReplication({\n          feedKey,\n          download: true,\n          upload: this._options.upload,\n        });\n      }\n    }\n  }\n\n  /**\n   * Try to initiate feed replication.\n   */\n  private async _initiateReplication(feedInfo: FeedInfo): Promise<void> {\n    log('initiating replication', { feedInfo });\n    invariant(this._extensionContext!.initiator === true, 'Invalid call');\n    invariant(!this._streams.has(feedInfo.feedKey), `Replication already in progress for feed: ${feedInfo.feedKey}`);\n    const { streamTag } = await this._rpc!.rpc.ReplicatorService.startReplication({ info: feedInfo });\n    if (!streamTag) {\n      return;\n    }\n\n    await this._replicateFeed(feedInfo, streamTag);\n  }\n\n  /**\n   * Respond to a remote request to replicate a feed.\n   * @returns A stream tag for the replication stream or `undefined` if we don't want to replicate.\n   */\n  @synchronized\n  private async _acceptReplication(feedInfo: FeedInfo): Promise<string | undefined> {\n    invariant(this._extensionContext!.initiator === false, 'Invalid call');\n\n    if (!this._feeds.has(feedInfo.feedKey) || this._streams.has(feedInfo.feedKey)) {\n      return undefined; // We don't have the feed or we are already replicating it.\n    }\n\n    const tag = `feed-${feedInfo.feedKey.toHex()}-${PublicKey.random().toHex().slice(0, 8)}`; // Generate a unique tag for the stream.\n    await this._replicateFeed(feedInfo, tag);\n    return tag;\n  }\n\n  private async _replicateFeed(info: FeedInfo, streamTag: string): Promise<void> {\n    log('replicate', { info, streamTag });\n    invariant(!this._streams.has(info.feedKey), `Replication already in progress for feed: ${info.feedKey}`);\n\n    const feed = this._feeds.get(info.feedKey) ?? failUndefined();\n    const networkStream = await this._extensionContext!.createStream(streamTag, {\n      contentType: 'application/x-hypercore',\n    });\n    let replicationStreamErrors = 0;\n\n    // https://github.com/holepunchto/hypercore/tree/v9.12.0#var-stream--feedreplicateisinitiator-options\n    const replicationStream = feed.replicate(true, {\n      live: true,\n      upload: info.upload,\n      download: info.download,\n      noise: false,\n      encrypted: false,\n      maxRequests: 1024,\n    });\n\n    // Left for testing.\n    // const debug = true;\n    // if (debug) {\n    //   feed.on('sync', () => {\n    //     log.info('sync', { key: feed.key, length: feed.length });\n    //   });\n    //   feed.on('download', (index: number, data: any) => {\n    //     log.info('download', {\n    //       key: feed.key,\n    //       index,\n    //       length: feed.length,\n    //       data: data.length,\n    //     });\n    //   });\n    // }\n\n    replicationStream.on('error', (err) => {\n      if (err instanceof TimeoutError) {\n        log.info('replication stream timeout', { err, info });\n        return;\n      }\n      // TODO(nf): use sentinel errors\n      if (\n        err?.message === 'Writable stream closed prematurely' ||\n        err?.message === 'Cannot call write after a stream was destroyed'\n      ) {\n        log('replication stream closed', { err, info });\n        return;\n      }\n\n      // TODO(nf): WARN on first error? log full info on some subsequent errors?\n      if (replicationStreamErrors === 0) {\n        log.info('replication stream error', { err, info });\n      } else {\n        log.info('replication stream error', { err, feedKey: info.feedKey, count: replicationStreamErrors });\n      }\n      replicationStreamErrors++;\n    });\n\n    this._streams.set(info.feedKey, {\n      streamTag,\n      networkStream,\n      replicationStream,\n      info,\n    });\n\n    networkStream.pipe(replicationStream as any).pipe(networkStream);\n  }\n\n  private async _stopReplication(feedKey: PublicKey): Promise<void> {\n    const stream = this._streams.get(feedKey);\n    if (!stream) {\n      return;\n    }\n\n    stream.networkStream.destroy();\n    this._streams.delete(feedKey);\n  }\n}\n\ntype ServiceBundle = {\n  ReplicatorService: ReplicatorService;\n};\n\ntype ActiveStream = {\n  streamTag: string;\n  networkStream: Duplex;\n  replicationStream: ProtocolStream;\n  info: FeedInfo;\n};\n"],
  "mappings": "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",
  "names": ["asyncTimeout", "DeferredTask", "synchronized", "Context", "failUndefined", "invariant", "PublicKey", "log", "logInfo", "RpcClosedError", "TimeoutError", "schema", "createProtoRpcPeer", "ComplexMap", "ReplicatorExtension", "_ctx", "onError", "err", "_extensionContext", "close", "_feeds", "hash", "_streams", "_options", "upload", "_updateTask", "initiator", "_rpc", "rpc", "ReplicatorService", "updateFeeds", "feeds", "Array", "from", "values", "map", "feed", "feedKey", "key", "download", "_reevaluateFeeds", "extensionInfo", "localPeerId", "remotePeerId", "keys", "setOptions", "options", "schedule", "addFeed", "set", "onOpen", "context", "requested", "getService", "exposed", "handlers", "startReplication", "info", "streamTag", "_acceptReplication", "stopReplication", "_stopReplication", "port", "createPort", "contentType", "timeout", "open", "onClose", "dispose", "onAbort", "abort", "disposed", "has", "get", "catch", "_initiateReplication", "feedInfo", "_replicateFeed", "undefined", "tag", "toHex", "random", "slice", "networkStream", "createStream", "replicationStreamErrors", "replicationStream", "replicate", "live", "noise", "encrypted", "maxRequests", "on", "message", "count", "pipe", "stream", "destroy", "delete"]
}
