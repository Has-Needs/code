import { createRequire } from 'node:module';const require = createRequire(import.meta.url);

// packages/core/mesh/teleport-extension-replicator/src/replicator-extension.ts
import { asyncTimeout, DeferredTask, synchronized } from "@dxos/async";
import { Context } from "@dxos/context";
import { failUndefined } from "@dxos/debug";
import { invariant } from "@dxos/invariant";
import { PublicKey } from "@dxos/keys";
import { log, logInfo } from "@dxos/log";
import { RpcClosedError, TimeoutError } from "@dxos/protocols";
import { schema } from "@dxos/protocols/proto";
import { createProtoRpcPeer } from "@dxos/rpc";
import { ComplexMap } from "@dxos/util";
function _ts_decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/core/mesh/teleport-extension-replicator/src/replicator-extension.ts";
var ReplicatorExtension = class {
  constructor() {
    this._ctx = new Context({
      onError: (err) => {
        this._extensionContext?.close(err);
      }
    }, {
      F: __dxlog_file,
      L: 30
    });
    this._feeds = new ComplexMap(PublicKey.hash);
    this._streams = new ComplexMap(PublicKey.hash);
    this._options = {
      upload: false
    };
    this._updateTask = new DeferredTask(this._ctx, async () => {
      try {
        if (this._extensionContext.initiator === false) {
          await this._rpc.rpc.ReplicatorService.updateFeeds({
            feeds: Array.from(this._feeds.values()).map((feed) => ({
              feedKey: feed.key,
              download: true,
              upload: this._options.upload
            }))
          });
        } else if (this._extensionContext.initiator === true) {
          await this._reevaluateFeeds();
        }
      } catch (err) {
        if (err instanceof RpcClosedError) {
          return;
        }
        throw err;
      }
    });
  }
  get extensionInfo() {
    return {
      initiator: this._extensionContext?.initiator,
      localPeerId: this._extensionContext?.localPeerId,
      remotePeerId: this._extensionContext?.remotePeerId,
      feeds: Array.from(this._feeds.keys())
    };
  }
  setOptions(options) {
    this._options = options;
    log("setOptions", {
      options
    }, {
      F: __dxlog_file,
      L: 79,
      S: this,
      C: (f, a) => f(...a)
    });
    if (this._extensionContext) {
      this._updateTask.schedule();
    }
    return this;
  }
  addFeed(feed) {
    this._feeds.set(feed.key, feed);
    log("addFeed", {
      feedKey: feed.key
    }, {
      F: __dxlog_file,
      L: 88,
      S: this,
      C: (f, a) => f(...a)
    });
    if (this._extensionContext) {
      this._updateTask.schedule();
    }
  }
  async onOpen(context) {
    this._extensionContext = context;
    log("open", void 0, {
      F: __dxlog_file,
      L: 96,
      S: this,
      C: (f, a) => f(...a)
    });
    this._rpc = createProtoRpcPeer({
      requested: {
        ReplicatorService: schema.getService("dxos.mesh.teleport.replicator.ReplicatorService")
      },
      exposed: {
        ReplicatorService: schema.getService("dxos.mesh.teleport.replicator.ReplicatorService")
      },
      handlers: {
        ReplicatorService: {
          updateFeeds: async ({ feeds }) => {
            log("received feed info", {
              feeds
            }, {
              F: __dxlog_file,
              L: 108,
              S: this,
              C: (f, a) => f(...a)
            });
            invariant(this._extensionContext.initiator === true, "Invalid call", {
              F: __dxlog_file,
              L: 109,
              S: this,
              A: [
                "this._extensionContext!.initiator === true",
                "'Invalid call'"
              ]
            });
            this._updateTask.schedule();
          },
          startReplication: async ({ info }) => {
            log("starting replication...", {
              info
            }, {
              F: __dxlog_file,
              L: 113,
              S: this,
              C: (f, a) => f(...a)
            });
            invariant(this._extensionContext.initiator === false, "Invalid call", {
              F: __dxlog_file,
              L: 114,
              S: this,
              A: [
                "this._extensionContext!.initiator === false",
                "'Invalid call'"
              ]
            });
            const streamTag = await this._acceptReplication(info);
            return {
              streamTag
            };
          },
          stopReplication: async ({ info }) => {
            log("stopping replication...", {
              info
            }, {
              F: __dxlog_file,
              L: 122,
              S: this,
              C: (f, a) => f(...a)
            });
            invariant(this._extensionContext.initiator === false, "Invalid call", {
              F: __dxlog_file,
              L: 124,
              S: this,
              A: [
                "this._extensionContext!.initiator === false",
                "'Invalid call'"
              ]
            });
            await this._stopReplication(info.feedKey);
          }
        }
      },
      port: await context.createPort("rpc", {
        contentType: 'application/x-protobuf; messageType="dxos.rpc.Message"'
      }),
      timeout: 1e4
    });
    await this._rpc.open();
    this._updateTask.schedule();
  }
  async onClose(err) {
    log("close", {
      err
    }, {
      F: __dxlog_file,
      L: 141,
      S: this,
      C: (f, a) => f(...a)
    });
    await this._ctx.dispose();
    await this._rpc?.close();
    for (const feedKey of this._streams.keys()) {
      await this._stopReplication(feedKey);
    }
  }
  async onAbort(err) {
    log("abort", {
      err
    }, {
      F: __dxlog_file,
      L: 150,
      S: this,
      C: (f, a) => f(...a)
    });
    await this._ctx.dispose();
    await this._rpc?.abort();
    for (const feedKey of this._streams.keys()) {
      await this._stopReplication(feedKey);
    }
  }
  async _reevaluateFeeds() {
    log("_reevaluateFeeds", void 0, {
      F: __dxlog_file,
      L: 161,
      S: this,
      C: (f, a) => f(...a)
    });
    for (const feedKey of this._feeds.keys()) {
      if (this._ctx.disposed) {
        return;
      }
      if (this._streams.has(feedKey) && this._options.upload !== this._streams.get(feedKey)?.info.upload) {
        try {
          await asyncTimeout(this._stopReplication(feedKey), 1e3);
        } catch (err) {
          log.catch(err, void 0, {
            F: __dxlog_file,
            L: 170,
            S: this,
            C: (f, a) => f(...a)
          });
        }
      }
      if (this._ctx.disposed) {
        return;
      }
      if (!this._streams.has(feedKey)) {
        await this._initiateReplication({
          feedKey,
          download: true,
          upload: this._options.upload
        });
      }
    }
  }
  /**
  * Try to initiate feed replication.
  */
  async _initiateReplication(feedInfo) {
    log("initiating replication", {
      feedInfo
    }, {
      F: __dxlog_file,
      L: 191,
      S: this,
      C: (f, a) => f(...a)
    });
    invariant(this._extensionContext.initiator === true, "Invalid call", {
      F: __dxlog_file,
      L: 192,
      S: this,
      A: [
        "this._extensionContext!.initiator === true",
        "'Invalid call'"
      ]
    });
    invariant(!this._streams.has(feedInfo.feedKey), `Replication already in progress for feed: ${feedInfo.feedKey}`, {
      F: __dxlog_file,
      L: 193,
      S: this,
      A: [
        "!this._streams.has(feedInfo.feedKey)",
        "`Replication already in progress for feed: ${feedInfo.feedKey}`"
      ]
    });
    const { streamTag } = await this._rpc.rpc.ReplicatorService.startReplication({
      info: feedInfo
    });
    if (!streamTag) {
      return;
    }
    await this._replicateFeed(feedInfo, streamTag);
  }
  /**
  * Respond to a remote request to replicate a feed.
  * @returns A stream tag for the replication stream or `undefined` if we don't want to replicate.
  */
  async _acceptReplication(feedInfo) {
    invariant(this._extensionContext.initiator === false, "Invalid call", {
      F: __dxlog_file,
      L: 208,
      S: this,
      A: [
        "this._extensionContext!.initiator === false",
        "'Invalid call'"
      ]
    });
    if (!this._feeds.has(feedInfo.feedKey) || this._streams.has(feedInfo.feedKey)) {
      return void 0;
    }
    const tag = `feed-${feedInfo.feedKey.toHex()}-${PublicKey.random().toHex().slice(0, 8)}`;
    await this._replicateFeed(feedInfo, tag);
    return tag;
  }
  async _replicateFeed(info, streamTag) {
    log("replicate", {
      info,
      streamTag
    }, {
      F: __dxlog_file,
      L: 220,
      S: this,
      C: (f, a) => f(...a)
    });
    invariant(!this._streams.has(info.feedKey), `Replication already in progress for feed: ${info.feedKey}`, {
      F: __dxlog_file,
      L: 221,
      S: this,
      A: [
        "!this._streams.has(info.feedKey)",
        "`Replication already in progress for feed: ${info.feedKey}`"
      ]
    });
    const feed = this._feeds.get(info.feedKey) ?? failUndefined();
    const networkStream = await this._extensionContext.createStream(streamTag, {
      contentType: "application/x-hypercore"
    });
    let replicationStreamErrors = 0;
    const replicationStream = feed.replicate(true, {
      live: true,
      upload: info.upload,
      download: info.download,
      noise: false,
      encrypted: false,
      maxRequests: 1024
    });
    replicationStream.on("error", (err) => {
      if (err instanceof TimeoutError) {
        log.info("replication stream timeout", {
          err,
          info
        }, {
          F: __dxlog_file,
          L: 257,
          S: this,
          C: (f, a) => f(...a)
        });
        return;
      }
      if (err?.message === "Writable stream closed prematurely" || err?.message === "Cannot call write after a stream was destroyed") {
        log("replication stream closed", {
          err,
          info
        }, {
          F: __dxlog_file,
          L: 265,
          S: this,
          C: (f, a) => f(...a)
        });
        return;
      }
      if (replicationStreamErrors === 0) {
        log.info("replication stream error", {
          err,
          info
        }, {
          F: __dxlog_file,
          L: 271,
          S: this,
          C: (f, a) => f(...a)
        });
      } else {
        log.info("replication stream error", {
          err,
          feedKey: info.feedKey,
          count: replicationStreamErrors
        }, {
          F: __dxlog_file,
          L: 273,
          S: this,
          C: (f, a) => f(...a)
        });
      }
      replicationStreamErrors++;
    });
    this._streams.set(info.feedKey, {
      streamTag,
      networkStream,
      replicationStream,
      info
    });
    networkStream.pipe(replicationStream).pipe(networkStream);
  }
  async _stopReplication(feedKey) {
    const stream = this._streams.get(feedKey);
    if (!stream) {
      return;
    }
    stream.networkStream.destroy();
    this._streams.delete(feedKey);
  }
};
_ts_decorate([
  logInfo
], ReplicatorExtension.prototype, "extensionInfo", null);
_ts_decorate([
  synchronized
], ReplicatorExtension.prototype, "_reevaluateFeeds", null);
_ts_decorate([
  synchronized
], ReplicatorExtension.prototype, "_acceptReplication", null);
export {
  ReplicatorExtension
};
//# sourceMappingURL=index.mjs.map
