"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var node_exports = {};
__export(node_exports, {
  PortMuxer: () => PortMuxer,
  createIFrame: () => createIFrame,
  createIFramePort: () => createIFramePort,
  createWorkerPort: () => createWorkerPort
});
module.exports = __toCommonJS(node_exports);
var import_ua_parser_js = require("ua-parser-js");
var import_log = require("@dxos/log");
var import_log2 = require("@dxos/log");
var import_log3 = require("@dxos/log");
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/core/mesh/rpc-tunnel/src/ports/iframe.ts";
var browser;
var os;
if (typeof navigator !== "undefined") {
  const parser = new import_ua_parser_js.UAParser(navigator.userAgent);
  browser = parser.getBrowser().name;
  os = parser.getOS().name;
}
var sendToIFrame = (iframe, origin, message) => {
  if (!iframe.contentWindow) {
    (0, import_log.log)("IFrame content window missing", {
      origin
    }, {
      F: __dxlog_file,
      L: 24,
      S: void 0,
      C: (f, a) => f(...a)
    });
    return;
  }
  if (browser === "Chrome" && os === "iOS") {
    iframe.contentWindow.postMessage(message, origin);
  } else {
    iframe.contentWindow.postMessage(message, origin, [
      message.payload
    ]);
  }
};
var sendToParentWindow = (origin, message) => {
  if (browser === "Chrome" && os === "iOS") {
    window.parent.postMessage(message, origin);
  } else {
    window.parent.postMessage(message, origin, [
      message.payload
    ]);
  }
};
var createIFramePort = ({ channel, iframe, origin, onOrigin }) => {
  return {
    send: async (data) => {
      if (!origin) {
        (0, import_log.log)("no origin set", {
          channel
        }, {
          F: __dxlog_file,
          L: 62,
          S: void 0,
          C: (f, a) => f(...a)
        });
        return;
      }
      (0, import_log.log)("sending", {
        channel,
        data: data.length
      }, {
        F: __dxlog_file,
        L: 66,
        S: void 0,
        C: (f, a) => f(...a)
      });
      const payload = data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
      const message = {
        channel,
        payload
      };
      if (iframe) {
        sendToIFrame(iframe, origin, message);
      } else {
        sendToParentWindow(origin, message);
      }
    },
    subscribe: (callback) => {
      const handler = (event) => {
        if (!iframe && event.source !== window.parent) {
          return;
        } else if (iframe && event.source !== iframe.contentWindow) {
          return;
        }
        const isMessageData = event.data && typeof event.data === "object" && "channel" in event.data && "payload" in event.data;
        const message = isMessageData ? event.data : void 0;
        if (message?.channel !== channel) {
          return;
        }
        if (!origin) {
          origin = event.origin;
          onOrigin?.(origin);
        }
        (0, import_log.log)("received", message, {
          F: __dxlog_file,
          L: 98,
          S: void 0,
          C: (f, a) => f(...a)
        });
        callback(new Uint8Array(message.payload));
      };
      window.addEventListener("message", handler);
      return () => window.removeEventListener("message", handler);
    }
  };
};
var createIFrame = (source, id, { hidden = true, allow } = {}) => {
  const create = () => {
    const iframe = document.createElement("iframe");
    iframe.id = id;
    iframe.src = source;
    hidden && iframe.setAttribute("style", "display: none;");
    allow && iframe.setAttribute("allow", allow);
    document.body.appendChild(iframe);
    return iframe;
  };
  return document.getElementById(id) ?? create();
};
var __dxlog_file2 = "/home/runner/work/dxos/dxos/packages/core/mesh/rpc-tunnel/src/ports/worker.ts";
var createWorkerPort = ({ port, channel, subscribe }) => ({
  send: async (message) => {
    const payload = message.buffer.slice(message.byteOffset, message.byteOffset + message.byteLength);
    port.postMessage({
      channel,
      payload
    }, [
      payload
    ]);
  },
  subscribe: subscribe ?? ((callback) => {
    const handler = (event) => {
      const message = event.data;
      if (channel && message.channel !== channel) {
        return;
      }
      import_log2.log.debug("received", {
        message
      }, {
        F: __dxlog_file2,
        L: 46,
        S: void 0,
        C: (f, a) => f(...a)
      });
      callback(new Uint8Array(message.payload));
    };
    port.onmessage = handler;
    return () => {
      port.onmessage = null;
    };
  })
});
var __dxlog_file3 = "/home/runner/work/dxos/dxos/packages/core/mesh/rpc-tunnel/src/port-muxer.ts";
var PortMuxer = class {
  constructor(_messagePort) {
    this._messagePort = _messagePort;
    this._activeChannels = /* @__PURE__ */ new Map();
    this._rpcPorts = /* @__PURE__ */ new Map();
    if (this._messagePort) {
      this._messagePort.onmessage = (event) => this.onWorkerMessage(event);
    }
    if (typeof window !== "undefined") {
      window.addEventListener("message", (event) => this.onWindowMessage(event));
    }
  }
  createWorkerPort(options) {
    if (!this._messagePort) {
      throw new Error("Message port is required to create worker ports");
    }
    const port = createWorkerPort({
      ...options,
      port: this._messagePort,
      subscribe: (callback) => {
        this._activeChannels.set(options.channel, callback);
        return () => this._activeChannels.delete(options.channel);
      }
    });
    this._rpcPorts.set(options.channel, port);
    return port;
  }
  createIFramePort(options) {
    const port = createIFramePort(options);
    this._rpcPorts.set(options.channel, port);
    return port;
  }
  onWorkerMessage(event) {
    const message = event.data;
    import_log3.log.debug("Recieved message from worker port", {
      channel: message.channel,
      payload: message.payload
    }, {
      F: __dxlog_file3,
      L: 56,
      S: this,
      C: (f, a) => f(...a)
    });
    const callback = this._activeChannels.get(message.channel);
    callback?.(new Uint8Array(message.payload));
  }
  onWindowMessage(event) {
    const message = event.data;
    import_log3.log.debug("Recieved message from window", {
      channel: message.channel,
      payload: message.payload
    }, {
      F: __dxlog_file3,
      L: 67,
      S: this,
      C: (f, a) => f(...a)
    });
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  PortMuxer,
  createIFrame,
  createIFramePort,
  createWorkerPort
});
//# sourceMappingURL=index.cjs.map
