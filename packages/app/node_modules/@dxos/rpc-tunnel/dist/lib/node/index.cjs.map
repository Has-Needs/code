{
  "version": 3,
  "sources": ["../../../src/ports/iframe.ts", "../../../src/ports/worker.ts", "../../../src/port-muxer.ts"],
  "sourcesContent": ["//\n// Copyright 2022 DXOS.org\n//\n\nimport { UAParser } from 'ua-parser-js';\n\nimport { log } from '@dxos/log';\nimport { type RpcPort } from '@dxos/rpc';\n\nimport { type MessageData } from '../message';\n\nlet browser: string | undefined;\nlet os: string | undefined;\n\nif (typeof navigator !== 'undefined') {\n  // TODO(wittjosiah): Stop user agent parsing.\n  const parser = new UAParser(navigator.userAgent);\n  browser = parser.getBrowser().name;\n  os = parser.getOS().name;\n}\n\nconst sendToIFrame = (iframe: HTMLIFrameElement, origin: string, message: MessageData) => {\n  if (!iframe.contentWindow) {\n    log('IFrame content window missing', { origin });\n    return;\n  }\n\n  if (browser === 'Chrome' && os === 'iOS') {\n    iframe.contentWindow.postMessage(message, origin);\n  } else {\n    iframe.contentWindow.postMessage(message, origin, [message.payload]);\n  }\n};\n\nconst sendToParentWindow = (origin: string, message: MessageData) => {\n  if (browser === 'Chrome' && os === 'iOS') {\n    window.parent.postMessage(message, origin);\n  } else {\n    window.parent.postMessage(message, origin, [message.payload]);\n  }\n};\n\nexport type IFramePortOptions = {\n  channel: string;\n  iframe?: HTMLIFrameElement;\n  origin?: string;\n  onOrigin?: (origin: string) => void;\n};\n\n/**\n * Create a RPC port with an iframe over window messaging.\n * @param options.channel Identifier for sent/recieved messages.\n * @param options.iframe Instance of the iframe if sending to child.\n * @param options.origin Origin of the destination window.\n * @param options.onOrigin Callback triggered when origin of destination window is verified.\n * @returns RPC port for messaging.\n */\nexport const createIFramePort = ({ channel, iframe, origin, onOrigin }: IFramePortOptions): RpcPort => {\n  return {\n    send: async (data) => {\n      if (!origin) {\n        log('no origin set', { channel });\n        return;\n      }\n\n      log('sending', { channel, data: data.length });\n      const payload = data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);\n      const message = { channel, payload };\n      if (iframe) {\n        sendToIFrame(iframe, origin, message);\n      } else {\n        sendToParentWindow(origin, message);\n      }\n    },\n\n    subscribe: (callback) => {\n      const handler = (event: MessageEvent<unknown>) => {\n        if (!iframe && event.source !== window.parent) {\n          // Not from parent window.\n          return;\n        } else if (iframe && event.source !== iframe.contentWindow) {\n          // Not from child window.\n          return;\n        }\n\n        const isMessageData =\n          event.data && typeof event.data === 'object' && 'channel' in event.data && 'payload' in event.data;\n        const message = isMessageData ? (event.data as MessageData) : undefined;\n        if (message?.channel !== channel) {\n          return;\n        }\n\n        if (!origin) {\n          origin = event.origin;\n          onOrigin?.(origin);\n        }\n\n        log('received', message);\n        callback(new Uint8Array(message.payload));\n      };\n\n      window.addEventListener('message', handler);\n      return () => window.removeEventListener('message', handler);\n    },\n  };\n};\n\nexport type CreateIFrameOptions = {\n  hidden?: boolean;\n  allow?: string;\n};\n\n/**\n * Create a hidden iframe and insert it into the DOM.\n * If an element with the same id already exists it will be returned instead.\n * @param source Source of the iframe.\n * @param id DOM id of the iframe.\n * @returns The created iframe.\n */\nexport const createIFrame = (source: string, id: string, { hidden = true, allow }: CreateIFrameOptions = {}) => {\n  const create = () => {\n    const iframe = document.createElement('iframe') as HTMLIFrameElement;\n    iframe.id = id;\n    iframe.src = source;\n    hidden && iframe.setAttribute('style', 'display: none;');\n    allow && iframe.setAttribute('allow', allow);\n    document.body.appendChild(iframe);\n    return iframe;\n  };\n\n  return (document.getElementById(id) as HTMLIFrameElement) ?? create();\n};\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { log } from '@dxos/log';\nimport { type RpcPort } from '@dxos/rpc';\n\nimport { type MessageData } from '../message';\n\nexport type WorkerPortOptions = {\n  port: MessagePort;\n  channel?: string;\n  subscribe?: RpcPort['subscribe'];\n};\n\n/**\n * Create a RPC port for a worker.\n * @param options.port Message port to send message on.\n * @param options.channel Identifier for sent/recieved messages.\n * @param options.subscribe\n * @returns RPC port for messaging.\n */\n// TODO(wittjosiah): Rename for more general purpose MessagePort.\nexport const createWorkerPort = ({ port, channel, subscribe }: WorkerPortOptions): RpcPort => ({\n  send: async (message) => {\n    // Based on https://stackoverflow.com/a/54646864/2804332.\n    const payload = message.buffer.slice(message.byteOffset, message.byteOffset + message.byteLength);\n    port.postMessage(\n      {\n        channel,\n        payload,\n      },\n      [payload],\n    );\n  },\n\n  subscribe:\n    subscribe ??\n    ((callback) => {\n      const handler = (event: MessageEvent<MessageData>) => {\n        const message = event.data;\n        if (channel && message.channel !== channel) {\n          return;\n        }\n\n        log.debug('received', { message });\n        callback(new Uint8Array(message.payload));\n      };\n\n      port.onmessage = handler;\n      return () => {\n        port.onmessage = null;\n      };\n    }),\n});\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { log } from '@dxos/log';\nimport { type RpcPort } from '@dxos/rpc';\n\nimport { type MessageData } from './message';\nimport { createIFramePort, createWorkerPort, type IFramePortOptions, type WorkerPortOptions } from './ports';\n\n/**\n * Facilitates the multiplexing of multiple RpcPorts over a single MessagePort.\n */\nexport class PortMuxer {\n  private readonly _activeChannels = new Map<string, (msg: Uint8Array) => void>();\n\n  private readonly _rpcPorts = new Map<string, RpcPort>();\n\n  constructor(private readonly _messagePort?: MessagePort) {\n    if (this._messagePort) {\n      this._messagePort.onmessage = (event) => this.onWorkerMessage(event);\n    }\n\n    if (typeof window !== 'undefined') {\n      window.addEventListener('message', (event) => this.onWindowMessage(event));\n    }\n  }\n\n  createWorkerPort(options: Omit<WorkerPortOptions, 'port' | 'subscribe' | 'channel'> & { channel: string }): RpcPort {\n    if (!this._messagePort) {\n      throw new Error('Message port is required to create worker ports');\n    }\n\n    const port = createWorkerPort({\n      ...options,\n      port: this._messagePort,\n      subscribe: (callback) => {\n        this._activeChannels.set(options.channel, callback);\n        return () => this._activeChannels.delete(options.channel);\n      },\n    });\n    this._rpcPorts.set(options.channel, port);\n\n    return port;\n  }\n\n  createIFramePort(options: IFramePortOptions): RpcPort {\n    const port = createIFramePort(options);\n    this._rpcPorts.set(options.channel, port);\n\n    return port;\n  }\n\n  private onWorkerMessage(event: MessageEvent<MessageData>): void {\n    const message = event.data;\n    log.debug('Recieved message from worker port', {\n      channel: message.channel,\n      payload: message.payload,\n    });\n\n    const callback = this._activeChannels.get(message.channel);\n    callback?.(new Uint8Array(message.payload));\n  }\n\n  private onWindowMessage(event: MessageEvent<MessageData>): void {\n    const message = event.data;\n    log.debug('Recieved message from window', {\n      channel: message.channel,\n      payload: message.payload,\n    });\n  }\n}\n"],
  "mappings": "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",
  "names": ["import_log", "browser", "os", "navigator", "parser", "UAParser", "userAgent", "getBrowser", "name", "getOS", "sendToIFrame", "iframe", "origin", "message", "contentWindow", "log", "postMessage", "payload", "sendToParentWindow", "window", "parent", "createIFramePort", "channel", "onOrigin", "send", "data", "length", "buffer", "slice", "byteOffset", "byteLength", "subscribe", "callback", "handler", "event", "source", "isMessageData", "undefined", "Uint8Array", "addEventListener", "removeEventListener", "createIFrame", "id", "hidden", "allow", "create", "document", "createElement", "src", "setAttribute", "body", "appendChild", "getElementById", "createWorkerPort", "port", "debug", "onmessage", "PortMuxer", "_messagePort", "_activeChannels", "Map", "_rpcPorts", "onWorkerMessage", "onWindowMessage", "options", "Error", "set", "delete", "get"]
}
