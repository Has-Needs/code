{
  "version": 3,
  "sources": ["../../../src/ports/iframe.ts", "../../../src/ports/worker.ts", "../../../src/port-muxer.ts"],
  "sourcesContent": ["//\n// Copyright 2022 DXOS.org\n//\n\nimport { UAParser } from 'ua-parser-js';\n\nimport { log } from '@dxos/log';\nimport { type RpcPort } from '@dxos/rpc';\n\nimport { type MessageData } from '../message';\n\nlet browser: string | undefined;\nlet os: string | undefined;\n\nif (typeof navigator !== 'undefined') {\n  // TODO(wittjosiah): Stop user agent parsing.\n  const parser = new UAParser(navigator.userAgent);\n  browser = parser.getBrowser().name;\n  os = parser.getOS().name;\n}\n\nconst sendToIFrame = (iframe: HTMLIFrameElement, origin: string, message: MessageData) => {\n  if (!iframe.contentWindow) {\n    log('IFrame content window missing', { origin });\n    return;\n  }\n\n  if (browser === 'Chrome' && os === 'iOS') {\n    iframe.contentWindow.postMessage(message, origin);\n  } else {\n    iframe.contentWindow.postMessage(message, origin, [message.payload]);\n  }\n};\n\nconst sendToParentWindow = (origin: string, message: MessageData) => {\n  if (browser === 'Chrome' && os === 'iOS') {\n    window.parent.postMessage(message, origin);\n  } else {\n    window.parent.postMessage(message, origin, [message.payload]);\n  }\n};\n\nexport type IFramePortOptions = {\n  channel: string;\n  iframe?: HTMLIFrameElement;\n  origin?: string;\n  onOrigin?: (origin: string) => void;\n};\n\n/**\n * Create a RPC port with an iframe over window messaging.\n * @param options.channel Identifier for sent/recieved messages.\n * @param options.iframe Instance of the iframe if sending to child.\n * @param options.origin Origin of the destination window.\n * @param options.onOrigin Callback triggered when origin of destination window is verified.\n * @returns RPC port for messaging.\n */\nexport const createIFramePort = ({ channel, iframe, origin, onOrigin }: IFramePortOptions): RpcPort => {\n  return {\n    send: async (data) => {\n      if (!origin) {\n        log('no origin set', { channel });\n        return;\n      }\n\n      log('sending', { channel, data: data.length });\n      const payload = data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);\n      const message = { channel, payload };\n      if (iframe) {\n        sendToIFrame(iframe, origin, message);\n      } else {\n        sendToParentWindow(origin, message);\n      }\n    },\n\n    subscribe: (callback) => {\n      const handler = (event: MessageEvent<unknown>) => {\n        if (!iframe && event.source !== window.parent) {\n          // Not from parent window.\n          return;\n        } else if (iframe && event.source !== iframe.contentWindow) {\n          // Not from child window.\n          return;\n        }\n\n        const isMessageData =\n          event.data && typeof event.data === 'object' && 'channel' in event.data && 'payload' in event.data;\n        const message = isMessageData ? (event.data as MessageData) : undefined;\n        if (message?.channel !== channel) {\n          return;\n        }\n\n        if (!origin) {\n          origin = event.origin;\n          onOrigin?.(origin);\n        }\n\n        log('received', message);\n        callback(new Uint8Array(message.payload));\n      };\n\n      window.addEventListener('message', handler);\n      return () => window.removeEventListener('message', handler);\n    },\n  };\n};\n\nexport type CreateIFrameOptions = {\n  hidden?: boolean;\n  allow?: string;\n};\n\n/**\n * Create a hidden iframe and insert it into the DOM.\n * If an element with the same id already exists it will be returned instead.\n * @param source Source of the iframe.\n * @param id DOM id of the iframe.\n * @returns The created iframe.\n */\nexport const createIFrame = (source: string, id: string, { hidden = true, allow }: CreateIFrameOptions = {}) => {\n  const create = () => {\n    const iframe = document.createElement('iframe') as HTMLIFrameElement;\n    iframe.id = id;\n    iframe.src = source;\n    hidden && iframe.setAttribute('style', 'display: none;');\n    allow && iframe.setAttribute('allow', allow);\n    document.body.appendChild(iframe);\n    return iframe;\n  };\n\n  return (document.getElementById(id) as HTMLIFrameElement) ?? create();\n};\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { log } from '@dxos/log';\nimport { type RpcPort } from '@dxos/rpc';\n\nimport { type MessageData } from '../message';\n\nexport type WorkerPortOptions = {\n  port: MessagePort;\n  channel?: string;\n  subscribe?: RpcPort['subscribe'];\n};\n\n/**\n * Create a RPC port for a worker.\n * @param options.port Message port to send message on.\n * @param options.channel Identifier for sent/recieved messages.\n * @param options.subscribe\n * @returns RPC port for messaging.\n */\n// TODO(wittjosiah): Rename for more general purpose MessagePort.\nexport const createWorkerPort = ({ port, channel, subscribe }: WorkerPortOptions): RpcPort => ({\n  send: async (message) => {\n    // Based on https://stackoverflow.com/a/54646864/2804332.\n    const payload = message.buffer.slice(message.byteOffset, message.byteOffset + message.byteLength);\n    port.postMessage(\n      {\n        channel,\n        payload,\n      },\n      [payload],\n    );\n  },\n\n  subscribe:\n    subscribe ??\n    ((callback) => {\n      const handler = (event: MessageEvent<MessageData>) => {\n        const message = event.data;\n        if (channel && message.channel !== channel) {\n          return;\n        }\n\n        log.debug('received', { message });\n        callback(new Uint8Array(message.payload));\n      };\n\n      port.onmessage = handler;\n      return () => {\n        port.onmessage = null;\n      };\n    }),\n});\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { log } from '@dxos/log';\nimport { type RpcPort } from '@dxos/rpc';\n\nimport { type MessageData } from './message';\nimport { createIFramePort, createWorkerPort, type IFramePortOptions, type WorkerPortOptions } from './ports';\n\n/**\n * Facilitates the multiplexing of multiple RpcPorts over a single MessagePort.\n */\nexport class PortMuxer {\n  private readonly _activeChannels = new Map<string, (msg: Uint8Array) => void>();\n\n  private readonly _rpcPorts = new Map<string, RpcPort>();\n\n  constructor(private readonly _messagePort?: MessagePort) {\n    if (this._messagePort) {\n      this._messagePort.onmessage = (event) => this.onWorkerMessage(event);\n    }\n\n    if (typeof window !== 'undefined') {\n      window.addEventListener('message', (event) => this.onWindowMessage(event));\n    }\n  }\n\n  createWorkerPort(options: Omit<WorkerPortOptions, 'port' | 'subscribe' | 'channel'> & { channel: string }): RpcPort {\n    if (!this._messagePort) {\n      throw new Error('Message port is required to create worker ports');\n    }\n\n    const port = createWorkerPort({\n      ...options,\n      port: this._messagePort,\n      subscribe: (callback) => {\n        this._activeChannels.set(options.channel, callback);\n        return () => this._activeChannels.delete(options.channel);\n      },\n    });\n    this._rpcPorts.set(options.channel, port);\n\n    return port;\n  }\n\n  createIFramePort(options: IFramePortOptions): RpcPort {\n    const port = createIFramePort(options);\n    this._rpcPorts.set(options.channel, port);\n\n    return port;\n  }\n\n  private onWorkerMessage(event: MessageEvent<MessageData>): void {\n    const message = event.data;\n    log.debug('Recieved message from worker port', {\n      channel: message.channel,\n      payload: message.payload,\n    });\n\n    const callback = this._activeChannels.get(message.channel);\n    callback?.(new Uint8Array(message.payload));\n  }\n\n  private onWindowMessage(event: MessageEvent<MessageData>): void {\n    const message = event.data;\n    log.debug('Recieved message from window', {\n      channel: message.channel,\n      payload: message.payload,\n    });\n  }\n}\n"],
  "mappings": "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",
  "names": ["UAParser", "log", "browser", "os", "navigator", "parser", "userAgent", "getBrowser", "name", "getOS", "sendToIFrame", "iframe", "origin", "message", "contentWindow", "postMessage", "payload", "sendToParentWindow", "window", "parent", "createIFramePort", "channel", "onOrigin", "send", "data", "length", "buffer", "slice", "byteOffset", "byteLength", "subscribe", "callback", "handler", "event", "source", "isMessageData", "undefined", "Uint8Array", "addEventListener", "removeEventListener", "createIFrame", "id", "hidden", "allow", "create", "document", "createElement", "src", "setAttribute", "body", "appendChild", "getElementById", "log", "createWorkerPort", "port", "channel", "subscribe", "send", "message", "payload", "buffer", "slice", "byteOffset", "byteLength", "postMessage", "callback", "handler", "event", "data", "debug", "Uint8Array", "onmessage", "log", "PortMuxer", "_messagePort", "_activeChannels", "Map", "_rpcPorts", "onmessage", "event", "onWorkerMessage", "window", "addEventListener", "onWindowMessage", "createWorkerPort", "options", "Error", "port", "subscribe", "callback", "set", "channel", "delete", "createIFramePort", "message", "data", "log", "debug", "payload", "get", "Uint8Array"]
}
