"use strict";
//
// Copyright 2021 DXOS.org
//
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuthorizationError = exports.UnknownModelError = exports.EntityNotFoundError = exports.SpaceNotFoundError = exports.InvalidStorageVersionError = exports.UnknownProtocolError = exports.RateLimitExceededError = exports.ConnectivityError = exports.ProtocolError = exports.TimeoutError = exports.ConnectionResetError = exports.AlreadyJoinedError = exports.InvalidInvitationError = exports.IdentityNotInitializedError = exports.InvalidInvitationExtensionRoleError = exports.DataCorruptionError = exports.RemoteServiceConnectionTimeout = exports.RemoteServiceConnectionError = exports.InvalidConfigError = exports.CancelledError = exports.RpcNotOpenError = exports.RpcClosedError = void 0;
const keys_1 = require("@dxos/keys");
const base_errors_js_1 = require("./base-errors.js");
const helpers_js_1 = require("./helpers.js");
/**
 * Thrown when request was terminated because the RPC endpoint has been closed.
 */
class RpcClosedError extends base_errors_js_1.SystemError {
    constructor() {
        super('RPC_CLOSED', 'Request was terminated because the RPC endpoint is closed.');
    }
}
exports.RpcClosedError = RpcClosedError;
(0, helpers_js_1.registerErrorNoArgs)('RPC_CLOSED', RpcClosedError);
/**
 * Thrown when `request` is called when RPC has not been opened.
 */
class RpcNotOpenError extends base_errors_js_1.SystemError {
    constructor() {
        super('RPC_NOT_OPEN', 'RPC has not been opened.');
    }
}
exports.RpcNotOpenError = RpcNotOpenError;
(0, helpers_js_1.registerErrorNoArgs)('RPC_NOT_OPEN', RpcNotOpenError);
class CancelledError extends base_errors_js_1.SystemError {
    constructor(message, context) {
        super('CANCELLED', message, context);
    }
}
exports.CancelledError = CancelledError;
(0, helpers_js_1.registerErrorMessageContext)('CANCELLED', CancelledError);
class InvalidConfigError extends base_errors_js_1.ApiError {
    constructor(message, context) {
        super('INVALID_CONFIG', message, context);
    }
}
exports.InvalidConfigError = InvalidConfigError;
(0, helpers_js_1.registerErrorMessageContext)('INVALID_CONFIG', InvalidConfigError);
/**
 * Explicit failure to connect with remote client services.
 */
class RemoteServiceConnectionError extends base_errors_js_1.ApiError {
    constructor(message, context) {
        super('REMOTE_SERVICE_CONNECTION_ERROR', message, context);
    }
}
exports.RemoteServiceConnectionError = RemoteServiceConnectionError;
(0, helpers_js_1.registerErrorMessageContext)('REMOTE_SERVICE_CONNECTION_ERROR', RemoteServiceConnectionError);
/**
 * Failed to open a connection to remote client services.
 */
class RemoteServiceConnectionTimeout extends base_errors_js_1.ApiError {
    constructor(message, context) {
        super('REMOTE_SERVICE_CONNECTION_TIMEOUT', message, context);
    }
}
exports.RemoteServiceConnectionTimeout = RemoteServiceConnectionTimeout;
(0, helpers_js_1.registerErrorMessageContext)('REMOTE_SERVICE_CONNECTION_TIMEOUT', RemoteServiceConnectionTimeout);
class DataCorruptionError extends base_errors_js_1.SystemError {
    constructor(message, context) {
        super('DATA_CORRUPTION', message, context);
    }
}
exports.DataCorruptionError = DataCorruptionError;
(0, helpers_js_1.registerErrorMessageContext)('DATA_CORRUPTION', DataCorruptionError);
class InvalidInvitationExtensionRoleError extends base_errors_js_1.SystemError {
    constructor(message, context) {
        super('INVALID_INVITATION_EXTENSION_ROLE', message, context);
    }
}
exports.InvalidInvitationExtensionRoleError = InvalidInvitationExtensionRoleError;
(0, helpers_js_1.registerErrorMessageContext)('INVALID_INVITATION_EXTENSION_ROLE', InvalidInvitationExtensionRoleError);
class IdentityNotInitializedError extends base_errors_js_1.DatabaseError {
    constructor(message, context) {
        super('IDENTITY_NOT_INITIALIZED', message, context);
    }
}
exports.IdentityNotInitializedError = IdentityNotInitializedError;
(0, helpers_js_1.registerErrorMessageContext)('IDENTITY_NOT_INITIALIZED', IdentityNotInitializedError);
class InvalidInvitationError extends base_errors_js_1.DatabaseError {
    constructor(message, context) {
        super('INVALID_INVITATION', message, context);
    }
}
exports.InvalidInvitationError = InvalidInvitationError;
(0, helpers_js_1.registerErrorMessageContext)('INVALID_INVITATION', InvalidInvitationError);
class AlreadyJoinedError extends base_errors_js_1.DatabaseError {
    constructor(message, context) {
        super('ALREADY_JOINED', message, context);
    }
}
exports.AlreadyJoinedError = AlreadyJoinedError;
(0, helpers_js_1.registerErrorMessageContext)('ALREADY_JOINED', AlreadyJoinedError);
class ConnectionResetError extends base_errors_js_1.BaseError {
    constructor(message, context) {
        super('CONNECTION_RESET', message, context);
    }
}
exports.ConnectionResetError = ConnectionResetError;
(0, helpers_js_1.registerErrorMessageContext)('CONNECTION_RESET', ConnectionResetError);
class TimeoutError extends base_errors_js_1.BaseError {
    constructor(message, context) {
        super('TIMEOUT', message, context);
    }
}
exports.TimeoutError = TimeoutError;
(0, helpers_js_1.registerErrorMessageContext)('TIMEOUT', TimeoutError);
// General protocol error.
class ProtocolError extends base_errors_js_1.BaseError {
    constructor(message, context) {
        super('PROTOCOL_ERROR', message, context);
    }
}
exports.ProtocolError = ProtocolError;
(0, helpers_js_1.registerErrorMessageContext)('PROTOCOL_ERROR', ProtocolError);
// General connectivity errors.
class ConnectivityError extends base_errors_js_1.BaseError {
    constructor(message, context) {
        super('CONNECTIVITY_ERROR', message, context);
    }
}
exports.ConnectivityError = ConnectivityError;
(0, helpers_js_1.registerErrorMessageContext)('CONNECTIVITY_ERROR', ConnectivityError);
class RateLimitExceededError extends base_errors_js_1.BaseError {
    constructor(message, context) {
        super('RATE_LIMIT_EXCEEDED', message, context);
    }
}
exports.RateLimitExceededError = RateLimitExceededError;
(0, helpers_js_1.registerErrorMessageContext)('RATE_LIMIT_EXCEEDED', RateLimitExceededError);
// TODO(nf): Rename? the protocol isn't what's unknown...
class UnknownProtocolError extends base_errors_js_1.BaseError {
    constructor(message, innerError) {
        super('UNKNOWN_PROTOCOL_ERROR', message, innerError);
    }
}
exports.UnknownProtocolError = UnknownProtocolError;
(0, helpers_js_1.registerErrorMessageContext)('UNKNOWN_PROTOCOL_ERROR', UnknownProtocolError);
class InvalidStorageVersionError extends base_errors_js_1.DatabaseError {
    constructor(expected, actual) {
        super('INVALID_STORAGE_VERSION', 'Invalid storage version.', { expected, actual });
    }
}
exports.InvalidStorageVersionError = InvalidStorageVersionError;
(0, helpers_js_1.registerError)('INVALID_STORAGE_VERSION', (_, context) => {
    var _a, _b;
    return new InvalidStorageVersionError((_a = context.expected) !== null && _a !== void 0 ? _a : NaN, (_b = context.actual) !== null && _b !== void 0 ? _b : NaN);
});
class SpaceNotFoundError extends base_errors_js_1.DatabaseError {
    constructor(spaceKey) {
        super('SPACE_NOT_FOUND', 'Space not found.', { spaceKey });
    }
}
exports.SpaceNotFoundError = SpaceNotFoundError;
(0, helpers_js_1.registerError)('SPACE_NOT_FOUND', (_, context) => {
    var _a;
    return new SpaceNotFoundError((_a = keys_1.PublicKey.safeFrom(context.spaceKey)) !== null && _a !== void 0 ? _a : keys_1.PublicKey.from('00'));
});
class EntityNotFoundError extends base_errors_js_1.DatabaseError {
    constructor(entityId) {
        super('ITEM_NOT_FOUND', 'Item not found.', { entityId });
    }
}
exports.EntityNotFoundError = EntityNotFoundError;
(0, helpers_js_1.registerError)('ITEM_NOT_FOUND', (_, context) => {
    return new EntityNotFoundError(context.entityId);
});
class UnknownModelError extends base_errors_js_1.DatabaseError {
    constructor(model) {
        super('UNKNOWN_MODEL', 'Unknown model.', { model });
    }
}
exports.UnknownModelError = UnknownModelError;
(0, helpers_js_1.registerError)('UNKNOWN_MODEL', (_, context) => {
    return new UnknownModelError(context.model);
});
class AuthorizationError extends base_errors_js_1.ApiError {
    constructor(message, context) {
        super('AUTHORIZATION_ERROR', message, context);
    }
}
exports.AuthorizationError = AuthorizationError;
(0, helpers_js_1.registerErrorMessageContext)('AUTHORIZATION_ERROR', AuthorizationError);
//# sourceMappingURL=errors.js.map