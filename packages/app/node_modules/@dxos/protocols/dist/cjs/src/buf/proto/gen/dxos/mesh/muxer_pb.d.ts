import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import type { Message } from "@bufbuild/protobuf";
/**
 * Describes the file dxos/mesh/muxer.proto.
 */
export declare const file_dxos_mesh_muxer: GenFile;
/**
 * / Root type for messages sent over the stream.
 *
 * @generated from message dxos.mesh.muxer.Command
 */
export type Command = Message<"dxos.mesh.muxer.Command"> & {
    /**
     * @generated from oneof dxos.mesh.muxer.Command.payload
     */
    payload: {
        /**
         * @generated from field: dxos.mesh.muxer.OpenChannel open_channel = 1;
         */
        value: OpenChannel;
        case: "openChannel";
    } | {
        /**
         * @generated from field: dxos.mesh.muxer.Data data = 2;
         */
        value: Data;
        case: "data";
    } | {
        /**
         * deprecated.
         *
         * @generated from field: dxos.mesh.muxer.Destroy destroy = 3;
         */
        value: Destroy;
        case: "destroy";
    } | {
        /**
         * @generated from field: dxos.mesh.muxer.Close close = 4;
         */
        value: Close;
        case: "close";
    } | {
        case: undefined;
        value?: undefined;
    };
};
/**
 * Describes the message dxos.mesh.muxer.Command.
 * Use `create(CommandSchema)` to create a new message.
 */
export declare const CommandSchema: GenMessage<Command>;
/**
 * *
 * Notify the remote peer that we are opening a channel.
 *
 * Means that we are ready to receive data on the channel.
 * The remote peer could now send data messages with this channel id that will be atributed to this channel.
 *
 * The local peer must buffer any data messages until the remote peer replies with OpenChannel for this tag.
 *
 * @generated from message dxos.mesh.muxer.OpenChannel
 */
export type OpenChannel = Message<"dxos.mesh.muxer.OpenChannel"> & {
    /**
     * / Session-specific ID for the channel.
     *
     * @generated from field: int32 id = 1;
     */
    id: number;
    /**
     * / Stable identifier for the channel that is agreed upon by both peers.
     *
     * @generated from field: string tag = 2;
     */
    tag: string;
    /**
     * / Optional Mime-type or URL describing the protocol that is hosted ober this stream. Used for introspection.
     *
     * @generated from field: optional string content_type = 3;
     */
    contentType?: string;
};
/**
 * Describes the message dxos.mesh.muxer.OpenChannel.
 * Use `create(OpenChannelSchema)` to create a new message.
 */
export declare const OpenChannelSchema: GenMessage<OpenChannel>;
/**
 * @generated from message dxos.mesh.muxer.Data
 */
export type Data = Message<"dxos.mesh.muxer.Data"> & {
    /**
     * *
     * Identifier for the channel as assigned by the remote peer.
     * NOTE: An OpenChannel message must received before any data is sent on a channel.
     * Any data messages sent before that, should be ignored.
     *
     * @generated from field: int32 channel_id = 1;
     */
    channelId: number;
    /**
     * @generated from field: bytes data = 2;
     */
    data: Uint8Array;
};
/**
 * Describes the message dxos.mesh.muxer.Data.
 * Use `create(DataSchema)` to create a new message.
 */
export declare const DataSchema: GenMessage<Data>;
/**
 * / Terminate the connection. The other peer can expect the connection to be closed.
 *
 * @generated from message dxos.mesh.muxer.Destroy
 */
export type Destroy = Message<"dxos.mesh.muxer.Destroy"> & {
    /**
     * / Error that caused the termination.
     *
     * @generated from field: optional string error = 1;
     */
    error?: string;
};
/**
 * Describes the message dxos.mesh.muxer.Destroy.
 * Use `create(DestroySchema)` to create a new message.
 */
export declare const DestroySchema: GenMessage<Destroy>;
/**
 * @generated from message dxos.mesh.muxer.Close
 */
export type Close = Message<"dxos.mesh.muxer.Close"> & {
    /**
     * / Error that caused the termination.
     *
     * @generated from field: optional string error = 1;
     */
    error?: string;
};
/**
 * Describes the message dxos.mesh.muxer.Close.
 * Use `create(CloseSchema)` to create a new message.
 */
export declare const CloseSchema: GenMessage<Close>;
//# sourceMappingURL=muxer_pb.d.ts.map