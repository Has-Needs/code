"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var node_exports = {};
__export(node_exports, {
  DXN: () => DXN,
  IdentityDid: () => IdentityDid,
  LOCAL_SPACE_TAG: () => LOCAL_SPACE_TAG,
  ObjectId: () => ObjectId,
  PUBLIC_KEY_LENGTH: () => PUBLIC_KEY_LENGTH,
  PublicKey: () => PublicKey,
  QueueSubspaceTags: () => QueueSubspaceTags,
  SECRET_KEY_LENGTH: () => SECRET_KEY_LENGTH,
  SpaceId: () => SpaceId
});
module.exports = __toCommonJS(node_exports);
var import_effect = require("effect");
var import_debug = require("@dxos/debug");
var import_invariant = require("@dxos/invariant");
var import_effect2 = require("effect");
var import_ulidx = require("ulidx");
var import_effect3 = require("effect");
var import_invariant2 = require("@dxos/invariant");
var import_invariant3 = require("@dxos/invariant");
var import_debug2 = require("@dxos/debug");
var import_invariant4 = require("@dxos/invariant");
var __create = Object.create;
var __defProp2 = Object.defineProperty;
var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames2 = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps2 = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames2(from))
      if (!__hasOwnProp2.call(to, key) && key !== except)
        __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps2(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var require_base32_decode = __commonJS({
  "node_modules/.pnpm/base32-decode@1.0.0/node_modules/base32-decode/index.js"(exports2, module2) {
    var RFC46482 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
    var RFC4648_HEX2 = "0123456789ABCDEFGHIJKLMNOPQRSTUV";
    var CROCKFORD2 = "0123456789ABCDEFGHJKMNPQRSTVWXYZ";
    function readChar(alphabet, char) {
      var idx = alphabet.indexOf(char);
      if (idx === -1) {
        throw new Error("Invalid character found: " + char);
      }
      return idx;
    }
    module2.exports = function base32Decode4(input, variant) {
      var alphabet;
      switch (variant) {
        case "RFC3548":
        case "RFC4648":
          alphabet = RFC46482;
          input = input.replace(/=+$/, "");
          break;
        case "RFC4648-HEX":
          alphabet = RFC4648_HEX2;
          input = input.replace(/=+$/, "");
          break;
        case "Crockford":
          alphabet = CROCKFORD2;
          input = input.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1");
          break;
        default:
          throw new Error("Unknown base32 variant: " + variant);
      }
      var length = input.length;
      var bits = 0;
      var value = 0;
      var index = 0;
      var output = new Uint8Array(length * 5 / 8 | 0);
      for (var i = 0; i < length; i++) {
        value = value << 5 | readChar(alphabet, input[i]);
        bits += 5;
        if (bits >= 8) {
          output[index++] = value >>> bits - 8 & 255;
          bits -= 8;
        }
      }
      return output.buffer;
    };
  }
});
var ObjectIdSchema = import_effect2.Schema.String.pipe(import_effect2.Schema.pattern(/^[0-7][0-9A-HJKMNP-TV-Z]{25}$/i)).annotations({
  description: "a Universally Unique Lexicographically Sortable Identifier",
  pattern: "^[0-7][0-9A-HJKMNP-TV-Z]{25}$"
});
var ObjectId = class extends ObjectIdSchema {
  static isValid(id) {
    try {
      import_effect2.Schema.decodeSync(ObjectId)(id);
      return true;
    } catch (err) {
      return false;
    }
  }
  static random() {
    return (0, import_ulidx.ulid)();
  }
};
var import_base32_decode = __toESM(require_base32_decode(), 1);
function toDataView(data) {
  if (data instanceof Int8Array || data instanceof Uint8Array || data instanceof Uint8ClampedArray) {
    return new DataView(data.buffer, data.byteOffset, data.byteLength);
  }
  if (data instanceof ArrayBuffer) {
    return new DataView(data);
  }
  throw new TypeError("Expected `data` to be an ArrayBuffer, Buffer, Int8Array, Uint8Array or Uint8ClampedArray");
}
var RFC4648 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
var RFC4648_HEX = "0123456789ABCDEFGHIJKLMNOPQRSTUV";
var CROCKFORD = "0123456789ABCDEFGHJKMNPQRSTVWXYZ";
function base32Encode(data, variant, options) {
  options = options || {};
  let alphabet, defaultPadding;
  switch (variant) {
    case "RFC3548":
    case "RFC4648":
      alphabet = RFC4648;
      defaultPadding = true;
      break;
    case "RFC4648-HEX":
      alphabet = RFC4648_HEX;
      defaultPadding = true;
      break;
    case "Crockford":
      alphabet = CROCKFORD;
      defaultPadding = false;
      break;
    default:
      throw new Error("Unknown base32 variant: " + variant);
  }
  const padding = options.padding !== void 0 ? options.padding : defaultPadding;
  const view = toDataView(data);
  let bits = 0;
  let value = 0;
  let output = "";
  for (let i = 0; i < view.byteLength; i++) {
    value = value << 8 | view.getUint8(i);
    bits += 8;
    while (bits >= 5) {
      output += alphabet[value >>> bits - 5 & 31];
      bits -= 5;
    }
  }
  if (bits > 0) {
    output += alphabet[value << 5 - bits & 31];
  }
  if (padding) {
    while (output.length % 8 !== 0) {
      output += "=";
    }
  }
  return output;
}
var randomBytes = (length) => {
  const webCrypto = globalThis.crypto ?? __require("node:crypto").webcrypto;
  const bytes = new Uint8Array(length);
  webCrypto.getRandomValues(bytes);
  return bytes;
};
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/common/keys/src/space-id.ts";
var MULTIBASE_PREFIX = "B";
var ENCODED_LENGTH = 33;
var isValid = (value) => {
  return typeof value === "string" && value.startsWith(MULTIBASE_PREFIX) && value.length === ENCODED_LENGTH;
};
var SpaceId = class extends import_effect3.Schema.String.pipe(import_effect3.Schema.filter(isValid)) {
  static {
    this.byteLength = 20;
  }
  static {
    this.encode = (value) => {
      (0, import_invariant2.invariant)(value instanceof Uint8Array, "Invalid type", {
        F: __dxlog_file,
        L: 43,
        S: this,
        A: [
          "value instanceof Uint8Array",
          "'Invalid type'"
        ]
      });
      (0, import_invariant2.invariant)(value.length === SpaceId.byteLength, "Invalid length", {
        F: __dxlog_file,
        L: 44,
        S: this,
        A: [
          "value.length === SpaceId.byteLength",
          "'Invalid length'"
        ]
      });
      return MULTIBASE_PREFIX + base32Encode(value, "RFC4648");
    };
  }
  static {
    this.decode = (value) => {
      (0, import_invariant2.invariant)(value.startsWith(MULTIBASE_PREFIX), "Invalid multibase32 encoding", {
        F: __dxlog_file,
        L: 49,
        S: this,
        A: [
          "value.startsWith(MULTIBASE_PREFIX)",
          "'Invalid multibase32 encoding'"
        ]
      });
      return new Uint8Array((0, import_base32_decode.default)(value.slice(1), "RFC4648"));
    };
  }
  static {
    this.isValid = isValid;
  }
  static {
    this.random = () => {
      return SpaceId.encode(randomBytes(SpaceId.byteLength));
    };
  }
};
var __dxlog_file2 = "/home/runner/work/dxos/dxos/packages/common/keys/src/dxn.ts";
var LOCAL_SPACE_TAG = "@";
var QueueSubspaceTags = Object.freeze({
  DATA: "data",
  TRACE: "trace"
});
var DXN = class _DXN {
  static {
    this.Schema = import_effect.Schema.NonEmptyString.pipe(
      import_effect.Schema.pattern(/^dxn:([^:]+):(?:[^:]+:?)+[^:]$/),
      // TODO(dmaretskyi): To set the format we need to move the annotation IDs out of the echo-schema package.
      // FormatAnnotation.set(FormatEnum.DXN),
      import_effect.Schema.annotations({
        title: "DXN",
        description: "DXN URI",
        examples: [
          "dxn:type:example.com/type/MyType",
          "dxn:echo:@:01J00J9B45YHYSGZQTQMSKMGJ6"
        ]
      })
    );
  }
  static hash(dxn) {
    return dxn.toString();
  }
  static {
    this.kind = Object.freeze({
      /**
      * dxn:type:<type name>[:<version>]
      */
      TYPE: "type",
      /**
      * dxn:echo:<space id>:<echo id>
      * dxn:echo:@:<echo id>
      */
      // TODO(burdon): Rename to OBJECT? (BREAKING CHANGE).
      // TODO(burdon): Add separate Kind for space.
      ECHO: "echo",
      /**
      * The subspace tag enables us to partition queues by usage within the context of a space.
      * dxn:queue:<subspace_tag>:<space_id>:<queue_id>[:object_id]
      * dxn:queue:data:BA25QRC2FEWCSAMRP4RZL65LWJ7352CKE:01J00J9B45YHYSGZQTQMSKMGJ6
      * dxn:queue:trace:BA25QRC2FEWCSAMRP4RZL65LWJ7352CKE:01J00J9B45YHYSGZQTQMSKMGJ6
      */
      QUEUE: "queue"
    });
  }
  get kind() {
    return this.#kind;
  }
  static equals(a, b) {
    return a.kind === b.kind && a.parts.length === b.parts.length && a.parts.every((part, i) => part === b.parts[i]);
  }
  // TODO(burdon): Rename isValid.
  static isDXNString(dxn) {
    return dxn.startsWith("dxn:");
  }
  static parse(dxn) {
    if (typeof dxn !== "string") {
      throw new Error(`Invalid DXN: ${dxn}`);
    }
    const [prefix, kind, ...parts] = dxn.split(":");
    if (!(prefix === "dxn")) {
      throw new Error(`Invalid DXN: ${dxn}`);
    }
    if (!(typeof kind === "string" && kind.length > 0)) {
      throw new Error(`Invalid DXN: ${dxn}`);
    }
    if (!(parts.length > 0)) {
      throw new Error(`Invalid DXN: ${dxn}`);
    }
    return new _DXN(kind, parts);
  }
  static tryParse(dxn) {
    try {
      return _DXN.parse(dxn);
    } catch (error) {
      return void 0;
    }
  }
  /**
  * @example `dxn:type:example.com/type/Contact`
  */
  static fromTypename(typename) {
    return new _DXN(_DXN.kind.TYPE, [
      typename
    ]);
  }
  /**
  * @example `dxn:type:example.com/type/Contact:0.1.0`
  */
  // TODO(dmaretskyi): Consider using @ as the version separator.
  static fromTypenameAndVersion(typename, version) {
    return new _DXN(_DXN.kind.TYPE, [
      typename,
      version
    ]);
  }
  /**
  * @example `dxn:echo:@:01J00J9B45YHYSGZQTQMSKMGJ6`
  */
  static fromLocalObjectId(id) {
    return new _DXN(_DXN.kind.ECHO, [
      LOCAL_SPACE_TAG,
      id
    ]);
  }
  static fromQueue(subspaceTag, spaceId, queueId, objectId) {
    (0, import_invariant.invariant)(SpaceId.isValid(spaceId), void 0, {
      F: __dxlog_file2,
      L: 150,
      S: this,
      A: [
        "SpaceId.isValid(spaceId)",
        ""
      ]
    });
    (0, import_invariant.invariant)(ObjectId.isValid(queueId), void 0, {
      F: __dxlog_file2,
      L: 151,
      S: this,
      A: [
        "ObjectId.isValid(queueId)",
        ""
      ]
    });
    (0, import_invariant.invariant)(!objectId || ObjectId.isValid(objectId), void 0, {
      F: __dxlog_file2,
      L: 152,
      S: this,
      A: [
        "!objectId || ObjectId.isValid(objectId)",
        ""
      ]
    });
    return new _DXN(_DXN.kind.QUEUE, [
      subspaceTag,
      spaceId,
      queueId,
      ...objectId ? [
        objectId
      ] : []
    ]);
  }
  #kind;
  #parts;
  constructor(kind, parts) {
    (0, import_invariant.invariant)(parts.length > 0, void 0, {
      F: __dxlog_file2,
      L: 161,
      S: this,
      A: [
        "parts.length > 0",
        ""
      ]
    });
    (0, import_invariant.invariant)(parts.every((part) => typeof part === "string" && part.length > 0 && part.indexOf(":") === -1), void 0, {
      F: __dxlog_file2,
      L: 162,
      S: this,
      A: [
        "parts.every((part) => typeof part === 'string' && part.length > 0 && part.indexOf(':') === -1)",
        ""
      ]
    });
    switch (kind) {
      case _DXN.kind.TYPE:
        if (parts.length > 2) {
          throw new Error('Invalid "type" DXN');
        }
        break;
      case _DXN.kind.ECHO:
        if (parts.length !== 2) {
          throw new Error('Invalid "echo" DXN');
        }
        break;
    }
    this.#kind = kind;
    this.#parts = parts;
  }
  get parts() {
    return this.#parts;
  }
  // TODO(burdon): Should getters fail?
  get typename() {
    (0, import_invariant.invariant)(this.#kind === _DXN.kind.TYPE, void 0, {
      F: __dxlog_file2,
      L: 188,
      S: this,
      A: [
        "this.#kind === DXN.kind.TYPE",
        ""
      ]
    });
    return this.#parts[0];
  }
  hasTypenameOf(typename) {
    return this.#kind === _DXN.kind.TYPE && this.#parts.length === 1 && this.#parts[0] === typename;
  }
  isLocalObjectId() {
    return this.#kind === _DXN.kind.ECHO && this.#parts[0] === LOCAL_SPACE_TAG && this.#parts.length === 2;
  }
  asTypeDXN() {
    if (this.kind !== _DXN.kind.TYPE) {
      return void 0;
    }
    const [type, version] = this.#parts;
    return {
      type,
      version
    };
  }
  asEchoDXN() {
    if (this.kind !== _DXN.kind.ECHO) {
      return void 0;
    }
    const [spaceId, echoId] = this.#parts;
    return {
      spaceId: spaceId === LOCAL_SPACE_TAG ? void 0 : spaceId,
      echoId
    };
  }
  asQueueDXN() {
    if (this.kind !== _DXN.kind.QUEUE) {
      return void 0;
    }
    const [subspaceTag, spaceId, queueId, objectId] = this.#parts;
    if (typeof queueId !== "string") {
      return void 0;
    }
    return {
      subspaceTag,
      spaceId,
      queueId,
      objectId
    };
  }
  toString() {
    return `dxn:${this.#kind}:${this.#parts.join(":")}`;
  }
  /**
  * Used by Node.js to get textual representation of this object when it's printed with a `console.log` statement.
  */
  [import_debug.inspectCustom](depth, options, inspectFn) {
    const printControlCode = (code) => {
      return `\x1B[${code}m`;
    };
    return printControlCode(inspectFn.colors.blueBright[0]) + this.toString() + printControlCode(inspectFn.colors.reset[0]);
  }
  get [import_debug.devtoolsFormatter]() {
    return {
      header: () => {
        return [
          "span",
          {
            style: "font-weight: bold;"
          },
          this.toString()
        ];
      }
    };
  }
};
var import_base32_decode2 = __toESM(require_base32_decode(), 1);
var __dxlog_file3 = "/home/runner/work/dxos/dxos/packages/common/keys/src/identity-did.ts";
var IdentityDid = Object.freeze({
  byteLength: 20,
  encode: (value) => {
    (0, import_invariant3.invariant)(value instanceof Uint8Array, "Invalid type", {
      F: __dxlog_file3,
      L: 22,
      S: void 0,
      A: [
        "value instanceof Uint8Array",
        "'Invalid type'"
      ]
    });
    (0, import_invariant3.invariant)(value.length === IdentityDid.byteLength, "Invalid length", {
      F: __dxlog_file3,
      L: 23,
      S: void 0,
      A: [
        "value.length === IdentityDid.byteLength",
        "'Invalid length'"
      ]
    });
    return DID_PREFIX + MULTIBASE_PREFIX2 + base32Encode(value, "RFC4648");
  },
  decode: (value) => {
    (0, import_invariant3.invariant)(value.startsWith(DID_PREFIX + MULTIBASE_PREFIX2), "Invalid multibase32 encoding", {
      F: __dxlog_file3,
      L: 28,
      S: void 0,
      A: [
        "value.startsWith(DID_PREFIX + MULTIBASE_PREFIX)",
        "'Invalid multibase32 encoding'"
      ]
    });
    return new Uint8Array((0, import_base32_decode2.default)(value.slice(10), "RFC4648"));
  },
  isValid: (value) => {
    return typeof value === "string" && value.startsWith(DID_PREFIX + MULTIBASE_PREFIX2) && value.length === ENCODED_LENGTH2;
  },
  random: () => {
    return IdentityDid.encode(randomBytes(IdentityDid.byteLength));
  }
});
var MULTIBASE_PREFIX2 = "B";
var DID_PREFIX = "did:halo:";
var ENCODED_LENGTH2 = 42;
var import_base32_decode3 = __toESM(require_base32_decode(), 1);
var __dxlog_file4 = "/home/runner/work/dxos/dxos/packages/common/keys/src/public-key.ts";
var PUBLIC_KEY_LENGTH = 32;
var SECRET_KEY_LENGTH = 64;
var isLikeArrayBuffer = (value) => typeof value === "object" && value !== null && Object.getPrototypeOf(value).constructor.name === "ArrayBuffer";
var PublicKey = class _PublicKey {
  static {
    this.ZERO = _PublicKey.from("00".repeat(PUBLIC_KEY_LENGTH));
  }
  /**
  * Creates new instance of PublicKey automatically determining the input format.
  * @param source A Buffer, or Uint8Array, or hex encoded string, or something with an `asUint8Array` method on it
  * @returns PublicKey
  */
  static from(source) {
    (0, import_invariant4.invariant)(source, void 0, {
      F: __dxlog_file4,
      L: 49,
      S: this,
      A: [
        "source",
        ""
      ]
    });
    if (source instanceof _PublicKey) {
      return source;
    } else if (source instanceof Buffer) {
      return new _PublicKey(new Uint8Array(source.buffer, source.byteOffset, source.byteLength));
    } else if (source instanceof Uint8Array) {
      return new _PublicKey(source);
    } else if (source instanceof ArrayBuffer || isLikeArrayBuffer(source)) {
      return new _PublicKey(new Uint8Array(source));
    } else if (typeof source === "string") {
      return _PublicKey.fromHex(source);
    } else if (source.asUint8Array) {
      return new _PublicKey(source.asUint8Array());
    } else {
      throw new TypeError(`Unable to create PublicKey from ${source}`);
    }
  }
  /**
  * Same as `PublicKey.from` but does not throw and instead returns a `{ key: PublicKey }` or `{ error: Error }`
  * @param source Same PublicKeyLike argument as for `PublicKey.from`
  * @returns PublicKey
  */
  static safeFrom(source) {
    if (!source) {
      return void 0;
    }
    try {
      const key = _PublicKey.from(source);
      return key;
    } catch (err) {
      return void 0;
    }
  }
  /**
  * Creates new instance of PublicKey from hex string.
  */
  static fromHex(hex) {
    if (hex.startsWith("0x")) {
      hex = hex.slice(2);
    }
    const buf = Buffer.from(hex, "hex");
    return new _PublicKey(new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength));
  }
  /**
  * Creates a new key.
  */
  static random() {
    return _PublicKey.from(randomBytes(PUBLIC_KEY_LENGTH));
  }
  static randomOfLength(length) {
    return _PublicKey.from(randomBytes(length));
  }
  static *randomSequence() {
    for (let i = 0; i < 1e4; i++) {
      yield _PublicKey.random();
    }
    throw new Error("Too many keys requested");
  }
  /**
  * Tests if provided values is an instance of PublicKey.
  */
  static isPublicKey(value) {
    return value instanceof _PublicKey;
  }
  /**
  * Asserts that provided values is an instance of PublicKey.
  */
  static assertValidPublicKey(value) {
    if (!this.isPublicKey(value)) {
      throw new TypeError("Invalid PublicKey");
    }
  }
  /**
  * Tests two keys for equality.
  */
  static equals(left, right) {
    return _PublicKey.from(left).equals(right);
  }
  /**
  * @param str string representation of key.
  * @return Key buffer.
  * @deprecated All keys should be represented as instances of PublicKey.
  */
  static bufferize(str) {
    (0, import_invariant4.invariant)(typeof str === "string", "Invalid type", {
      F: __dxlog_file4,
      L: 152,
      S: this,
      A: [
        "typeof str === 'string'",
        "'Invalid type'"
      ]
    });
    const buffer = Buffer.from(str, "hex");
    return buffer;
  }
  /**
  * @param key key like data structure (but not PublicKey which should use toString).
  * @return Hex string representation of key.
  * @deprecated All keys should be represented as instances of PublicKey.
  */
  static stringify(key) {
    if (key instanceof _PublicKey) {
      key = key.asBuffer();
    } else if (key instanceof Uint8Array) {
      key = Buffer.from(key.buffer, key.byteOffset, key.byteLength);
    }
    (0, import_invariant4.invariant)(key instanceof Buffer, "Invalid type", {
      F: __dxlog_file4,
      L: 171,
      S: this,
      A: [
        "key instanceof Buffer",
        "'Invalid type'"
      ]
    });
    return key.toString("hex");
  }
  /**
  * To be used with ComplexMap and ComplexSet.
  * Returns a scalar representation for this key.
  */
  static hash(key) {
    return key.toHex();
  }
  static fromMultibase32(encoded) {
    (0, import_invariant4.invariant)(encoded.startsWith("B"), "Invalid multibase32 encoding", {
      F: __dxlog_file4,
      L: 184,
      S: this,
      A: [
        "encoded.startsWith('B')",
        "'Invalid multibase32 encoding'"
      ]
    });
    return new _PublicKey(new Uint8Array((0, import_base32_decode3.default)(encoded.slice(1), "RFC4648")));
  }
  constructor(_value) {
    this._value = _value;
    if (!(_value instanceof Uint8Array)) {
      throw new TypeError(`Expected Uint8Array, got: ${_value}`);
    }
  }
  toString() {
    return this.toHex();
  }
  toJSON() {
    return this.toHex();
  }
  toJSONL() {
    return this.truncate();
  }
  get length() {
    return this._value.length;
  }
  toHex() {
    return this.asBuffer().toString("hex");
  }
  toMultibase32() {
    return "B" + base32Encode(this._value, "RFC4648");
  }
  truncate(length = void 0) {
    return (0, import_debug2.truncateKey)(this, length);
  }
  asBuffer() {
    return Buffer.from(this._value.buffer, this._value.byteOffset, this._value.byteLength);
  }
  asUint8Array() {
    return this._value;
  }
  getInsecureHash(modulo) {
    return Math.abs(this._value.reduce((acc, val) => acc ^ val | 0, 0)) % modulo;
  }
  /**
  * Used by Node.js to get textual representation of this object when it's printed with a `console.log` statement.
  */
  [import_debug2.inspectCustom](depth, options, inspectFn) {
    if (!options.colors || typeof process.stdout.hasColors !== "function" || !process.stdout.hasColors()) {
      return `<PublicKey ${this.truncate()}>`;
    }
    const printControlCode = (code) => {
      return `\x1B[${code}m`;
    };
    const colors = [
      "red",
      "green",
      "yellow",
      "blue",
      "magenta",
      "cyan",
      "redBright",
      "greenBright",
      "yellowBright",
      "blueBright",
      "magentaBright",
      "cyanBright",
      "whiteBright"
    ];
    const color = colors[this.getInsecureHash(colors.length)];
    return `PublicKey(${printControlCode(inspectFn.colors[color][0])}${this.truncate()}${printControlCode(inspectFn.colors.reset[0])})`;
  }
  get [import_debug2.devtoolsFormatter]() {
    return {
      header: () => {
        const colors = [
          "darkred",
          "green",
          "orange",
          "blue",
          "darkmagenta",
          "darkcyan",
          "red",
          "green",
          "orange",
          "blue",
          "magenta",
          "darkcyan",
          "black"
        ];
        const color = colors[this.getInsecureHash(colors.length)];
        return [
          "span",
          {},
          [
            "span",
            {},
            "PublicKey("
          ],
          [
            "span",
            {
              style: `color: ${color};`
            },
            this.truncate()
          ],
          [
            "span",
            {},
            ")"
          ]
        ];
      }
    };
  }
  /**
  * Test this key for equality with some other key.
  */
  equals(other) {
    const otherConverted = _PublicKey.from(other);
    if (this._value.length !== otherConverted._value.length) {
      return false;
    }
    let equal = true;
    for (let i = 0; i < this._value.length; i++) {
      equal &&= this._value[i] === otherConverted._value[i];
    }
    return equal;
  }
  [import_debug2.equalsSymbol](other) {
    if (!_PublicKey.isPublicKey(other)) {
      return false;
    }
    return this.equals(other);
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  DXN,
  IdentityDid,
  LOCAL_SPACE_TAG,
  ObjectId,
  PUBLIC_KEY_LENGTH,
  PublicKey,
  QueueSubspaceTags,
  SECRET_KEY_LENGTH,
  SpaceId
});
//# sourceMappingURL=index.cjs.map
