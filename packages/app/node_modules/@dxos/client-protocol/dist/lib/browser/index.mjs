// packages/sdk/client-protocol/src/client.ts
var ClientServicesProviderResource = Symbol.for("dxos.resource.ClientServices");

// packages/sdk/client-protocol/src/config.ts
var DEFAULT_INTERNAL_CHANNEL = "dxos:vault";
var DEFAULT_CLIENT_CHANNEL = "dxos:app";
var DEFAULT_SHELL_CHANNEL = "dxos:shell";
var DEFAULT_WORKER_BROADCAST_CHANNEL = "dxos:shared-worker";
var DEFAULT_VAULT_URL = "https://halo.dxos.org/vault.html";
var EXPECTED_CONFIG_VERSION = 1;
var defaultConfig = {
  version: 1
};
var HOME = typeof process !== "undefined" ? process?.env?.HOME ?? "" : "";
var getProfilePath = (root, profile, file = void 0) => `${root}/profile/${profile}` + (file ? `/${file}` : "");
var DX_CONFIG = `${HOME}/.config/dx`;
var DX_CACHE = `${HOME}/.cache/dx`;
var DX_DATA = `${HOME}/.local/share/dx`;
var DX_STATE = `${HOME}/.local/state/dx`;
var DX_RUNTIME = "/tmp/dx/run";
var ENV_DX_CONFIG = "DX_CONFIG";
var ENV_DX_NO_AGENT = "DX_NO_AGENT";
var ENV_DX_PROFILE = "DX_PROFILE";
var ENV_DX_PROFILE_DEFAULT = "default";

// packages/sdk/client-protocol/src/invitations/encoder.ts
import base from "base-x";
import { schema } from "@dxos/protocols/proto";
import { Invitation } from "@dxos/protocols/proto/dxos/client/services";
var base62 = base("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ");
var codec = schema.getCodecForType("dxos.client.services.Invitation");
var InvitationEncoder = class {
  static decode(text) {
    const decodedInvitation = codec.decode(base62.decode(text));
    if (decodedInvitation.type === Invitation.Type.MULTIUSE) {
      decodedInvitation.type = Invitation.Type.INTERACTIVE;
      decodedInvitation.multiUse = true;
    }
    return decodedInvitation;
  }
  static encode(invitation) {
    return base62.encode(codec.encode({
      invitationId: invitation.invitationId,
      type: invitation.type,
      kind: invitation.kind,
      authMethod: invitation.authMethod,
      swarmKey: invitation.swarmKey,
      state: invitation.state,
      timeout: invitation.timeout,
      guestKeypair: invitation.guestKeypair,
      spaceId: invitation.spaceId,
      lifetime: invitation.lifetime,
      created: invitation.created,
      // TODO(wittjosiah): Make these optional to encode for greater privacy.
      ...invitation.spaceKey ? {
        spaceKey: invitation.spaceKey
      } : {},
      ...invitation.target ? {
        target: invitation.target
      } : {}
    }));
  }
};

// packages/sdk/client-protocol/src/invitations/invitations.ts
import { MulticastObservable } from "@dxos/async";
import { invariant } from "@dxos/invariant";
import { Invitation as Invitation2 } from "@dxos/protocols/proto/dxos/client/services";
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/sdk/client-protocol/src/invitations/invitations.ts";
var AUTHENTICATION_CODE_LENGTH = 6;
var INVITATION_TIMEOUT = 3 * 6e4;
var CancellableInvitation = class extends MulticastObservable {
  constructor({ subscriber, initialInvitation, onCancel }) {
    super(subscriber, initialInvitation);
    this._onCancel = onCancel;
  }
  cancel() {
    return this._onCancel();
  }
  get expired() {
    const expiration = getExpirationTime(this.get());
    return expiration && expiration.getTime() < Date.now();
  }
  get expiry() {
    return getExpirationTime(this.get());
  }
};
var AuthenticatingInvitation = class extends CancellableInvitation {
  constructor({ subscriber, initialInvitation, onCancel, onAuthenticate }) {
    super({
      subscriber,
      initialInvitation,
      onCancel
    });
    this._onAuthenticate = onAuthenticate;
  }
  async authenticate(authCode) {
    return this._onAuthenticate(authCode);
  }
};
var wrapObservable = async (observable) => {
  return new Promise((resolve, reject) => {
    const subscription = observable.subscribe((invitation) => {
      invariant(invitation?.state === Invitation2.State.SUCCESS, void 0, {
        F: __dxlog_file,
        L: 90,
        S: void 0,
        A: [
          "invitation?.state === Invitation.State.SUCCESS",
          ""
        ]
      });
      subscription.unsubscribe();
      resolve(invitation);
    }, (err) => {
      subscription.unsubscribe();
      reject(err);
    });
  });
};
var getExpirationTime = (invitation) => {
  if (!(invitation.created && invitation.lifetime)) {
    return;
  }
  return new Date(invitation.created.getTime() + invitation.lifetime * 1e3);
};

// packages/sdk/client-protocol/src/service-definitions.ts
import { schema as schema2 } from "@dxos/protocols/proto";
import { createServiceBundle } from "@dxos/rpc";
var clientServiceBundle = createServiceBundle({
  SystemService: schema2.getService("dxos.client.services.SystemService"),
  NetworkService: schema2.getService("dxos.client.services.NetworkService"),
  LoggingService: schema2.getService("dxos.client.services.LoggingService"),
  IdentityService: schema2.getService("dxos.client.services.IdentityService"),
  QueryService: schema2.getService("dxos.echo.query.QueryService"),
  InvitationsService: schema2.getService("dxos.client.services.InvitationsService"),
  DevicesService: schema2.getService("dxos.client.services.DevicesService"),
  SpacesService: schema2.getService("dxos.client.services.SpacesService"),
  DataService: schema2.getService("dxos.echo.service.DataService"),
  ContactsService: schema2.getService("dxos.client.services.ContactsService"),
  EdgeAgentService: schema2.getService("dxos.client.services.EdgeAgentService"),
  // Agent-only.
  FunctionRegistryService: schema2.getService("dxos.agent.functions.FunctionRegistryService"),
  // TODO(burdon): Deprecated.
  DevtoolsHost: schema2.getService("dxos.devtools.host.DevtoolsHost"),
  TracingService: schema2.getService("dxos.tracing.TracingService")
});
var iframeServiceBundle = {
  BridgeService: schema2.getService("dxos.mesh.bridge.BridgeService")
};
var workerServiceBundle = {
  WorkerService: schema2.getService("dxos.iframe.WorkerService")
};
var appServiceBundle = {
  AppService: schema2.getService("dxos.iframe.AppService")
};
var shellServiceBundle = {
  ShellService: schema2.getService("dxos.iframe.ShellService")
};

// packages/sdk/client-protocol/src/timeouts.ts
var PROXY_CONNECTION_TIMEOUT = 3e4;
var AUTH_TIMEOUT = 3e4;
var STATUS_TIMEOUT = 1e4;
var RESOURCE_LOCK_TIMEOUT = 3e3;
var LOAD_PROPERTIES_TIMEOUT = 3e3;
var CREATE_SPACE_TIMEOUT = 5e3;
var LOAD_CONTROL_FEEDS_TIMEOUT = 3e3;

// packages/sdk/client-protocol/src/schema.ts
import { Schema } from "effect";
import { Type } from "@dxos/echo";
import { TypedObject } from "@dxos/echo-schema";
var TYPE_PROPERTIES = "dxos.org/type/Properties";
var PropertiesType = class extends TypedObject({
  typename: TYPE_PROPERTIES,
  version: "0.1.0"
})({
  name: Schema.optional(Schema.String),
  // TODO(wittjosiah): Make generic?
  hue: Schema.optional(Schema.String),
  icon: Schema.optional(Schema.String),
  invocationTraceQueue: Schema.optional(Type.Ref(Type.Expando))
}, {
  record: true
}) {
};
export {
  AUTHENTICATION_CODE_LENGTH,
  AUTH_TIMEOUT,
  AuthenticatingInvitation,
  CREATE_SPACE_TIMEOUT,
  CancellableInvitation,
  ClientServicesProviderResource,
  DEFAULT_CLIENT_CHANNEL,
  DEFAULT_INTERNAL_CHANNEL,
  DEFAULT_SHELL_CHANNEL,
  DEFAULT_VAULT_URL,
  DEFAULT_WORKER_BROADCAST_CHANNEL,
  DX_CACHE,
  DX_CONFIG,
  DX_DATA,
  DX_RUNTIME,
  DX_STATE,
  ENV_DX_CONFIG,
  ENV_DX_NO_AGENT,
  ENV_DX_PROFILE,
  ENV_DX_PROFILE_DEFAULT,
  EXPECTED_CONFIG_VERSION,
  INVITATION_TIMEOUT,
  InvitationEncoder,
  LOAD_CONTROL_FEEDS_TIMEOUT,
  LOAD_PROPERTIES_TIMEOUT,
  PROXY_CONNECTION_TIMEOUT,
  PropertiesType,
  RESOURCE_LOCK_TIMEOUT,
  STATUS_TIMEOUT,
  TYPE_PROPERTIES,
  appServiceBundle,
  clientServiceBundle,
  defaultConfig,
  getExpirationTime,
  getProfilePath,
  iframeServiceBundle,
  shellServiceBundle,
  workerServiceBundle,
  wrapObservable
};
//# sourceMappingURL=index.mjs.map
