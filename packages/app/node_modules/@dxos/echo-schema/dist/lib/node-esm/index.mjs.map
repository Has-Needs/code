{
  "version": 3,
  "sources": ["../../../src/index.ts", "../../../src/formats/number.ts", "../../../src/formats/types.ts", "../../../src/formats/object.ts", "../../../src/formats/format.ts", "../../../src/formats/date.ts", "../../../src/formats/string.ts", "../../../src/formats/select.ts", "../../../src/json/json-schema.ts", "../../../src/json/annotations.ts", "../../../src/json-schema/json-schema-type.ts", "../../../src/json-schema/json-schema-normalize.ts", "../../../src/query/query.ts", "../../../src/types/types.ts", "../../../src/projection/compose.ts", "../../../src/schema/echo-schema.ts", "../../../src/schema/manipulation.ts", "../../../src/schema/snapshot.ts", "../../../src/schema/stored-schema.ts", "../../../src/schema/runtime-schema-registry.ts"],
  "sourcesContent": ["//\n// Copyright 2024 DXOS.org\n//\n\nexport { JsonPath, splitJsonPath, JsonProp } from '@dxos/effect';\n\n// TODO(dmaretskyi): Remove.\nexport { ObjectId } from '@dxos/keys';\nexport { ForeignKey } from '@dxos/echo-protocol';\n\nexport * from './ast';\nexport * from './formats';\nexport * from './json';\nexport * from './json-schema';\nexport * from './object';\nexport * from './query';\nexport * from './types';\nexport * from './utils';\nexport * from './ref';\nexport * from './projection';\nexport * from './schema';\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { Schema } from 'effect';\n\nimport { FormatAnnotation, FormatEnum } from './types';\n\nconst encodeMultipleOf = (divisor: number) => 1 / Math.pow(10, divisor);\n\nconst encodeMultiple =\n  <A extends number>(divisor?: number) =>\n  <I, R>(self: Schema.Schema<A, I, R>) =>\n    divisor === undefined || divisor === 0 ? self : self.pipe(Schema.multipleOf(encodeMultipleOf(divisor)));\n\n/**\n * Convert number of digits to multipleOf annotation.\n */\nexport const DecimalPrecision = Schema.transform(Schema.Number, Schema.Number, {\n  strict: true,\n  encode: (value) => encodeMultipleOf(value),\n  decode: (value) => Math.log10(1 / value),\n}).annotations({\n  title: 'Number of digits',\n});\n\nexport const CurrencyAnnotationId = Symbol.for('@dxos/schema/annotation/Currency');\n\nexport type CurrencyAnnotation = {\n  decimals?: number;\n  code?: string;\n};\n\n/**\n * ISO 4217 currency code.\n */\nexport const Currency = ({ decimals, code }: CurrencyAnnotation = { decimals: 2 }) =>\n  Schema.Number.pipe(\n    encodeMultiple(decimals),\n    FormatAnnotation.set(FormatEnum.Currency),\n    Schema.annotations({\n      title: 'Currency',\n      description: 'Currency value',\n      ...(code ? { [CurrencyAnnotationId]: code.toUpperCase() } : {}),\n    }),\n  );\n\nexport type PercentAnnotation = {\n  decimals?: number;\n};\n\n/**\n * Integer.\n */\nexport const Integer = () =>\n  Schema.Number.pipe(\n    Schema.int(),\n    FormatAnnotation.set(FormatEnum.Integer),\n    Schema.annotations({\n      title: 'Integer',\n      description: 'Integer value',\n    }),\n  );\n\n/**\n * Percent.\n */\n// TODO(burdon): Define min/max (e.g., 0, 1).\nexport const Percent = ({ decimals }: PercentAnnotation = { decimals: 2 }) =>\n  Schema.Number.pipe(\n    encodeMultiple(decimals),\n    FormatAnnotation.set(FormatEnum.Percent),\n    Schema.annotations({\n      title: 'Percent',\n      description: 'Percentage value',\n    }),\n  );\n\n/**\n * Unix timestamp.\n * https://en.wikipedia.org/wiki/Unix_time\n */\nexport const Timestamp = Schema.Number.pipe(\n  FormatAnnotation.set(FormatEnum.Timestamp),\n  Schema.annotations({\n    title: 'Timestamp',\n    description: 'Unix timestamp',\n  }),\n);\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { Option, SchemaAST, type JSONSchema, pipe } from 'effect';\n\nimport { createAnnotationHelper } from '../ast';\nimport { type JsonSchemaType } from '../json-schema';\n\n// TODO(burdon): Rename PropertyType.\nexport type ScalarType =\n  | JSONSchema.JsonSchema7Object\n  | JSONSchema.JsonSchema7String\n  | JSONSchema.JsonSchema7Number\n  | JSONSchema.JsonSchema7Boolean\n  | JSONSchema.JsonSchema7Ref;\n\n// TODO(burdon): Rename ValueType and change to disciminated union.\n// export type ValueType = 'array' | 'object' | 'string' | 'number' | 'boolean' | 'ref';\nexport enum TypeEnum {\n  Array = 'array', // TODO(burdon): Remove?\n  Object = 'object',\n  String = 'string',\n  Number = 'number',\n  Boolean = 'boolean',\n  Ref = 'ref',\n}\n\n// TODO(burdon): Ref?\nexport const getTypeEnum = (property: JsonSchemaType): TypeEnum | undefined => {\n  switch (property.type) {\n    case 'array':\n      return TypeEnum.Array;\n    case 'object':\n      return TypeEnum.Object;\n    case 'string':\n      return TypeEnum.String;\n    case 'number':\n      return TypeEnum.Number;\n    case 'boolean':\n      return TypeEnum.Boolean;\n    default:\n      return undefined;\n  }\n};\n\n/**\n * https://json-schema.org/understanding-json-schema/reference/schema\n * https://json-schema.org/understanding-json-schema/reference/string#built-in-formats\n */\nexport const FormatAnnotationId = Symbol.for('@dxos/schema/annotation/Format');\n\nexport const FormatAnnotation = createAnnotationHelper<FormatEnum>(FormatAnnotationId);\n\nexport const getFormatAnnotation = (node: SchemaAST.AST): FormatEnum | undefined =>\n  pipe(SchemaAST.getAnnotation<FormatEnum>(FormatAnnotationId)(node), Option.getOrUndefined);\n\n// TODO(burdon): Rename to FormatType and change to discriminated union.\nexport enum FormatEnum {\n  None = 'none',\n  String = 'string',\n  Number = 'number',\n  Boolean = 'boolean',\n  Ref = 'ref',\n\n  //\n  // { type: 'string' }\n  //\n\n  DID = 'did', // Users, etc.\n  DXN = 'dxn',\n  Email = 'email',\n  Formula = 'formula', // Spreadsheet formula.\n  Hostname = 'hostname',\n  JSON = 'json',\n  Markdown = 'markdown',\n  Regex = 'regex',\n  SingleSelect = 'single-select',\n  MultiSelect = 'multi-select',\n  URL = 'url',\n  UUID = 'uuid',\n\n  //\n  // { type: 'number' }\n  //\n\n  Currency = 'currency',\n  Integer = 'integer',\n  Percent = 'percent',\n  Timestamp = 'timestamp',\n\n  //\n  // { type: 'date' }\n  //\n\n  DateTime = 'date-time',\n  Date = 'date',\n  Time = 'time',\n  Duration = 'duration',\n\n  //\n  // { type: 'object' }\n  //\n\n  GeoPoint = 'latlng',\n}\n\nexport const FormatEnums = Object.values(FormatEnum).sort();\n\nexport const PropertyKind = {\n  type: TypeEnum,\n  format: FormatEnum,\n};\n\n/**\n * Default formats\n */\nexport const typeToFormat: Partial<Record<TypeEnum, FormatEnum>> = {\n  [TypeEnum.String]: FormatEnum.String,\n  [TypeEnum.Number]: FormatEnum.Number,\n  [TypeEnum.Boolean]: FormatEnum.Boolean,\n};\n\n/**\n * Map of format to type.\n */\nexport const formatToType: Record<FormatEnum, TypeEnum> = {\n  [FormatEnum.None]: undefined as any,\n  [FormatEnum.String]: TypeEnum.String,\n  [FormatEnum.Number]: TypeEnum.Number,\n  [FormatEnum.Boolean]: TypeEnum.Boolean,\n  [FormatEnum.Ref]: TypeEnum.Ref,\n\n  // Strings\n  [FormatEnum.DID]: TypeEnum.String,\n  [FormatEnum.DXN]: TypeEnum.String,\n  [FormatEnum.Email]: TypeEnum.String,\n  [FormatEnum.Formula]: TypeEnum.String,\n  [FormatEnum.Hostname]: TypeEnum.String,\n  [FormatEnum.JSON]: TypeEnum.String,\n  [FormatEnum.Markdown]: TypeEnum.String,\n  [FormatEnum.Regex]: TypeEnum.String,\n  [FormatEnum.URL]: TypeEnum.String,\n  [FormatEnum.UUID]: TypeEnum.String,\n  [FormatEnum.SingleSelect]: TypeEnum.String,\n  [FormatEnum.MultiSelect]: TypeEnum.Object,\n\n  // Dates\n  [FormatEnum.Date]: TypeEnum.String,\n  [FormatEnum.DateTime]: TypeEnum.String,\n  [FormatEnum.Duration]: TypeEnum.String,\n  [FormatEnum.Time]: TypeEnum.String,\n\n  // Numbers\n  [FormatEnum.Currency]: TypeEnum.Number,\n  [FormatEnum.Integer]: TypeEnum.Number,\n  [FormatEnum.Percent]: TypeEnum.Number,\n  [FormatEnum.Timestamp]: TypeEnum.Number,\n\n  // Objects\n  [FormatEnum.GeoPoint]: TypeEnum.Object,\n};\n\n/**\n * Allowed value options for select.\n */\nexport const OptionsAnnotationId = Symbol.for('@dxos/schema/annotation/Options');\n\nexport const getOptionsAnnotation = (node: SchemaAST.AST): OptionsAnnotationType[] | undefined =>\n  pipe(SchemaAST.getAnnotation<OptionsAnnotationType[]>(OptionsAnnotationId)(node), Option.getOrUndefined);\n\nexport type OptionsAnnotationType = string | number;\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { Schema } from 'effect';\n\nimport { clamp } from '@dxos/util';\n\nimport { FormatAnnotation, FormatEnum } from './types';\n\n/**\n * GeoJSON Format\n * https://datatracker.ietf.org/doc/html/rfc7946\n * https://datatracker.ietf.org/doc/html/rfc7946#section-3.1.1\n * https://en.wikipedia.org/wiki/Geographic_coordinate_system\n * https://geojson.org\n * {\n *   \"type\": \"Point\",\n *   \"coordinates\": [0, 51.47] // [longitude, latitude]\n * }\n * Note: optional third element for altitude.\n */\nexport const GeoPoint = Schema.Tuple(\n  Schema.Number.pipe(Schema.clamp(-180, 180), Schema.multipleOf(0.00001)).annotations({\n    title: 'Longitude',\n  }),\n  Schema.Number.pipe(Schema.clamp(-90, 90), Schema.multipleOf(0.00001)).annotations({\n    title: 'Latitude',\n  }),\n  Schema.optionalElement(Schema.Number).annotations({\n    title: 'Height ASL (m)',\n  }),\n).pipe(\n  FormatAnnotation.set(FormatEnum.GeoPoint),\n  Schema.annotations({\n    title: 'GeoPoint',\n    description: 'GeoJSON Position',\n  }),\n);\n\nexport type GeoPoint = Schema.Schema.Type<typeof GeoPoint>;\n\nexport type GeoLocation = {\n  longitude: number;\n  latitude: number;\n  height?: number;\n};\n\n/**\n * Geolocation utilities for working with GeoPoint format.\n */\nexport namespace GeoLocation {\n  /**\n   * Convert latitude and longitude to GeoPoint (GeoJSON format [longitude, latitude, height?]).\n   * Clamps values to valid ranges: latitude [-90, 90], longitude [-180, 180].\n   */\n  export const toGeoPoint = ({ longitude, latitude, height }: GeoLocation): GeoPoint => {\n    // TODO(ZaymonFC): Use schema validation instead of doing this manually.\n    const clampedLongitude = clamp(longitude, -180, 180);\n    const clampedLatitude = clamp(latitude, -90, 90);\n    return height !== undefined ? [clampedLongitude, clampedLatitude, height] : [clampedLongitude, clampedLatitude];\n  };\n\n  /**\n   * Extract latitude and longitude from GeoPoint (GeoJSON format [longitude, latitude, height?]).\n   */\n  export const fromGeoPoint = (geoPoint: GeoPoint | undefined): GeoLocation => {\n    if (!geoPoint) {\n      return { longitude: 0, latitude: 0 };\n    }\n\n    const result: GeoLocation = {\n      longitude: geoPoint[0],\n      latitude: geoPoint[1],\n    };\n\n    // Add height if defined.\n    if (geoPoint[2] !== undefined) {\n      result.height = geoPoint[2];\n    }\n\n    return result;\n  };\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { Schema } from 'effect';\n\nimport * as Keys from '@dxos/keys';\n\nimport * as DateUtil from './date';\nimport * as NumberUtil from './number';\nimport * as ObjectUtil from './object';\nimport * as StringUtil from './string';\n\n// TODO(burdon): Consider factoring out to separate `@dxos/json-schema`\n// TODO(burdon): Media encoding.\n//  - https://json-schema.org/understanding-json-schema/reference/non_json_data\n\n/**\n * Formats.\n * https://json-schema.org/understanding-json-schema/reference/string#built-in-formats\n * NOTE: A JSON Schema validator will ignore any format type that it does not understand.\n */\n// TODO(burdon): Add fields for `examples`, `message`, etc.\nexport namespace Format {\n  // Strings\n  export const DXN = Keys.DXN;\n  export const Email = StringUtil.Email;\n  export const Formula = StringUtil.Formula;\n  export const Hostname = StringUtil.Hostname;\n  export const JSON = StringUtil.JSON;\n  export const Markdown = StringUtil.Markdown;\n  export const Regex = StringUtil.Regex;\n  export const URL = StringUtil.URL;\n  export const UUID = Schema.UUID;\n\n  // Numbers\n  // TODO(burdon): BigInt.\n  export const Currency = NumberUtil.Currency;\n  export const Integer = NumberUtil.Integer;\n  export const Percent = NumberUtil.Percent;\n  export const Timestamp = NumberUtil.Timestamp;\n\n  // Dates and times\n  export const DateTime = DateUtil.DateTime;\n  export const Date = DateUtil.DateOnly;\n  export const Time = DateUtil.TimeOnly;\n  export const Duration = DateUtil.Duration;\n\n  // Objects\n  export const GeoPoint = ObjectUtil.GeoPoint;\n  export type GeoPoint = ObjectUtil.GeoPoint;\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { Schema, SchemaAST } from 'effect';\n\nimport { FormatAnnotation, FormatEnum } from './types';\n\n/**\n * Datetime values should be stored as ISO strings or unix numbers (ms) in UTC.\n *\n * NOTE: HyperFormula uses Excel's time format (null date 1900/01/01)\n * It can be configured to use a different parser via `parseDateTime`.\n * https://hyperformula.handsontable.com/guide/date-and-time-handling.html#date-and-time-handling\n * https://github.com/handsontable/hyperformula/blob/master/src/DateTimeHelper.ts\n */\n\n// TODO(burdon): Annotations not present in JSON.\n// TODO(burdon): Timezone.\n// TODO(burdon): Format for timestamp (Unix UTC or ISO 8601)?\n// TODO(burdon): Refs\n//  - https://www.npmjs.com/package/numfmt\n//  - https://date-fns.org/docs/Getting-Started\n//  - https://github.com/date-fns/tz\n\n/**\n * Simple date compatible with HF.\n */\nexport const SimpleDate = Schema.Struct({\n  year: Schema.Number.pipe(Schema.between(1900, 9999)),\n  month: Schema.Number.pipe(Schema.between(1, 12)),\n  day: Schema.Number.pipe(Schema.between(1, 31)),\n});\n\nexport type SimpleDate = Schema.Schema.Type<typeof SimpleDate>;\n\nexport const toSimpleDate = (date: Date): SimpleDate => ({\n  year: date.getUTCFullYear(),\n  month: date.getUTCMonth() + 1,\n  day: date.getUTCDate(),\n});\n\n/**\n * Simple time compatible with HF.\n */\nexport const SimpleTime = Schema.Struct({\n  hours: Schema.Number.pipe(Schema.between(0, 23)),\n  minutes: Schema.Number.pipe(Schema.between(0, 59)),\n  seconds: Schema.Number.pipe(Schema.between(0, 59)),\n});\n\nexport type SimpleTime = Schema.Schema.Type<typeof SimpleTime>;\n\nexport const toSimpleTime = (date: Date): SimpleTime => ({\n  hours: date.getUTCHours(),\n  minutes: date.getUTCSeconds(),\n  seconds: date.getUTCSeconds(),\n});\n\n/**\n * Simple date-time compatible with HF.\n */\nexport const SimpleDateTime = Schema.extend(SimpleDate, SimpleTime);\n\nexport type SimpleDateTime = Schema.Schema.Type<typeof SimpleDateTime>;\n\nexport const toSimpleDateTime = (date: Date): SimpleDateTime => ({\n  ...toSimpleDate(date),\n  ...toSimpleTime(date),\n});\n\n/**\n * https://effect.website/docs/guides/schema/transformations#date-transformations\n */\n\n// TODO(burdon): Consider if transformations should be supported with Automerge.\n\n/**\n * Format: 2018-11-13\n */\nexport const DateOnly = /* Schema.transformOrFail(Schema.String, SimpleDate, {\n  strict: true,\n  decode: (str, _, ast) => {\n    if (!isValidDateFormat(str)) {\n      return ParseResult.fail(new ParseResult.Type(ast, str, 'Expected YYYY-MM-DD format'));\n    }\n    if (!isValidDate(str)) {\n      return ParseResult.fail(new ParseResult.Type(ast, str, 'Invalid date'));\n    }\n\n    const [year, month, day] = str.split('-').map(Number);\n    return ParseResult.succeed({ year, month, day });\n  },\n  encode: (date) => {\n    return ParseResult.succeed(\n      [\n        date.year.toString().padStart(4, '0'),\n        date.month.toString().padStart(2, '0'),\n        date.day.toString().padStart(2, '0'),\n      ].join('-'),\n    );\n  },\n}) */ Schema.String.pipe(\n  FormatAnnotation.set(FormatEnum.Date),\n  Schema.annotations({\n    title: 'Date',\n    description: 'Valid date in ISO format',\n  }),\n);\n\n/**\n * Format: 20:20:39+00:00\n */\nexport const TimeOnly = /* Schema.transformOrFail(Schema.String, SimpleTime, {\n  strict: true,\n  decode: (str, _, ast) => {\n    if (!isValidTimeFormat(str)) {\n      return ParseResult.fail(new ParseResult.Type(ast, str, 'Expected HH:mm:ss format'));\n    }\n\n    const [hours, minutes, seconds] = str.split(':').map(Number);\n    return ParseResult.succeed({ hours, minutes, seconds });\n  },\n  encode: (time) => {\n    return ParseResult.succeed(\n      [\n        time.hours.toString().padStart(2, '0'),\n        time.minutes.toString().padStart(2, '0'),\n        time.seconds.toString().padStart(2, '0'),\n      ].join(':'),\n    );\n  },\n}) */ Schema.String.pipe(\n  FormatAnnotation.set(FormatEnum.Time),\n  Schema.annotations({\n    title: 'Time',\n    description: 'Valid time in ISO format',\n  }),\n);\n\n/**\n * Format: 2018-11-13T20:20:39+00:00\n */\nexport const DateTime = /* Schema.transformOrFail(Schema.String, SimpleDateTime, {\n  strict: false,\n  decode: (str, _, ast) => {\n    const [date, time] = str.split('T');\n    if (!isValidDateFormat(date)) {\n      return ParseResult.fail(new ParseResult.Type(ast, date, 'Expected YYYY-MM-DD format'));\n    }\n    if (!isValidDate(date)) {\n      return ParseResult.fail(new ParseResult.Type(ast, date, 'Invalid date'));\n    }\n    if (!isValidTimeFormat(time)) {\n      return ParseResult.fail(new ParseResult.Type(ast, str, 'Expected HH:mm:ss format'));\n    }\n\n    const [year, month, day] = date.split('-').map(Number);\n    const [hours, minutes, seconds] = time.split(':').map(Number);\n    return ParseResult.succeed({ year, month, day, hours, minutes, seconds });\n  },\n  encode: (datetime) => {\n    return ParseResult.succeed(\n      [\n        [\n          datetime.year.toString().padStart(4, '0'),\n          datetime.month.toString().padStart(2, '0'),\n          datetime.day.toString().padStart(2, '0'),\n        ].join('-'),\n        [\n          datetime.hours.toString().padStart(2, '0'),\n          datetime.minutes.toString().padStart(2, '0'),\n          datetime.seconds.toString().padStart(2, '0'),\n        ].join(':'),\n      ].join('T'),\n    );\n  },\n}) */ Schema.String.pipe(\n  FormatAnnotation.set(FormatEnum.DateTime),\n  Schema.annotations({\n    title: 'DateTime',\n    description: 'Valid date and time in ISO format',\n  }),\n);\n\n/**\n * https://datatracker.ietf.org/doc/html/rfc3339#appendix-A\n */\n// TODO(burdon): Define duration type.\nexport const Duration = Schema.String.pipe(\n  FormatAnnotation.set(FormatEnum.Duration),\n  Schema.annotations({\n    title: 'Duration',\n    description: 'Duration in ISO 8601 format',\n    [SchemaAST.ExamplesAnnotationId]: ['1h', '3D'],\n  }),\n);\n\n//\n// Utils\n//\n\n// YYYY-MM-DD\nconst DATE_REGEX = /^\\d{4}-\\d{2}-\\d{2}$/;\n\nconst _isValidDateFormat = (str: string) => DATE_REGEX.test(str);\n\nconst _isValidDate = (str: string) => {\n  const date = new Date(str);\n  return !isNaN(date.getTime()) && date.toISOString().startsWith(str);\n};\n\n// HH:mm:ss\nconst TIME_REGEX = /^([01]\\d|2[0-3]):([0-5]\\d):([0-5]\\d)$/;\n\nconst _isValidTimeFormat = (str: string) => TIME_REGEX.test(str);\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { SchemaAST, Schema } from 'effect';\n\nimport { FormatAnnotation, FormatEnum } from './types';\n\n/**\n * Email address (RFC 5321)\n * https://datatracker.ietf.org/doc/html/rfc5321#section-4.1.2\n */\nexport const Email = Schema.String.pipe(\n  Schema.pattern(/^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/),\n  FormatAnnotation.set(FormatEnum.Email),\n  Schema.annotations({\n    title: 'Email',\n    description: 'Email address',\n  }),\n);\n\n/**\n *\n */\n// TODO(burdon): Implement.\nexport const Formula = Schema.String.pipe(FormatAnnotation.set(FormatEnum.Formula));\n\n/**\n *\n */\n// TODO(burdon): Implement.\nexport const Hostname = Schema.String.pipe(FormatAnnotation.set(FormatEnum.Hostname));\n\n/**\n *\n */\n// TODO(burdon): Implement.\nexport const JSON = Schema.String.pipe(FormatAnnotation.set(FormatEnum.JSON));\n\n/**\n *\n */\n// TODO(burdon): Implement.\nexport const Markdown = Schema.String.pipe(FormatAnnotation.set(FormatEnum.Markdown));\n\n/**\n * Regex\n * https://json-schema.org/understanding-json-schema/reference/regular_expressions\n * https://ecma-international.org/publications-and-standards/standards/ecma-262\n */\n// TODO(burdon): Implement.\nexport const Regex = Schema.String.pipe(FormatAnnotation.set(FormatEnum.Regex));\n\n/**\n * https://datatracker.ietf.org/doc/html/rfc3986#section-1.1.3\n */\nexport const URL = Schema.String.pipe(\n  Schema.pattern(/^(\\w+?:\\/\\/)?([\\da-z.-]+)\\.([a-z.]{2,6})([/\\w .-]*)*\\/?$/i),\n  FormatAnnotation.set(FormatEnum.URL),\n  Schema.annotations({\n    title: 'URL',\n    description: 'URL',\n  }),\n);\n\n/**\n * UUID (RFC 4122)\n * https://datatracker.ietf.org/doc/html/rfc4122\n */\nexport const UUID = Schema.UUID.pipe(\n  FormatAnnotation.set(FormatEnum.UUID),\n  Schema.annotations({\n    [SchemaAST.ExamplesAnnotationId]: ['3e4666bf-d5e5-4aa7-b8ce-cefe41c7568a'],\n  }),\n);\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { Schema } from 'effect';\n\n/** Schema for a single select option. Used to define choices in a {single|multi}-select field. */\nexport const SelectOptionSchema = Schema.Struct({\n  /** Stable identifier for the option. */\n  id: Schema.NonEmptyString,\n  title: Schema.String,\n  /** Color palette used for visual styling. */\n  color: Schema.String,\n}).pipe(Schema.mutable);\n\nexport type SelectOption = Schema.Schema.Type<typeof SelectOptionSchema>;\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { JSONSchema, Option, Schema, SchemaAST, type Types } from 'effect';\nimport type { Mutable } from 'effect/Types';\n\nimport { raise } from '@dxos/debug';\nimport { mapAst } from '@dxos/effect';\nimport { invariant } from '@dxos/invariant';\nimport { DXN, ObjectId } from '@dxos/keys';\nimport { clearUndefined, orderKeys, removeProperties } from '@dxos/util';\n\nimport { CustomAnnotations, DecodedAnnotations, EchoAnnotations } from './annotations';\nimport {\n  getTypeAnnotation,\n  getTypeIdentifierAnnotation,\n  type TypeAnnotation,\n  TypeAnnotationId,\n  TypeIdentifierAnnotationId,\n} from '../ast';\nimport { EntityKind, EntityKindSchema } from '../ast';\nimport {\n  ECHO_ANNOTATIONS_NS_DEPRECATED_KEY,\n  ECHO_ANNOTATIONS_NS_KEY,\n  getNormalizedEchoAnnotations,\n  type JsonSchemaEchoAnnotations,\n  type JsonSchemaType,\n} from '../json-schema';\nimport { Expando } from '../object';\nimport { createEchoReferenceSchema, Ref, type JsonSchemaReferenceInfo } from '../ref';\n\n/**\n * Create object jsonSchema.\n */\nexport const createJsonSchema = (schema: Schema.Struct<any> = Schema.Struct({})): JsonSchemaType => {\n  const jsonSchema = _toJsonSchema(schema);\n\n  // TODO(dmaretskyi): Fix those in the serializer.\n  jsonSchema.type = 'object';\n  delete jsonSchema.anyOf;\n  return jsonSchema;\n};\n\n// TODO(burdon): Are these values stored (can they be changed?)\nexport enum PropType {\n  NONE = 0,\n  STRING = 1, // TODO(burdon): vs TEXT?\n  NUMBER = 2,\n  BOOLEAN = 3,\n  DATE = 4,\n  REF = 5,\n  RECORD = 6,\n  ENUM = 7,\n}\n\n// TODO(burdon): Reconcile with @dxos/schema.\nexport const toPropType = (type?: PropType): string => {\n  switch (type) {\n    case PropType.STRING:\n      return 'string';\n    case PropType.NUMBER:\n      return 'number';\n    case PropType.BOOLEAN:\n      return 'boolean';\n    case PropType.DATE:\n      return 'date';\n    case PropType.REF:\n      return 'ref';\n    case PropType.RECORD:\n      return 'object';\n    default:\n      throw new Error(`Invalid type: ${type}`);\n  }\n};\n\nconst JSON_SCHEMA_URL = 'http://json-schema.org/draft-07/schema#';\n\nexport type JsonSchemaOptions = {\n  strict?: boolean;\n};\n\n/**\n * Convert effect schema to JSON Schema.\n * @param schema\n */\nexport const toJsonSchema = (schema: Schema.Schema.All, options: JsonSchemaOptions = {}): JsonSchemaType => {\n  let jsonSchema = _toJsonSchema(schema);\n  if (options.strict) {\n    // TOOD(burdon): Workaround to ensure JSON schema is valid (for agv parsing).\n    jsonSchema = removeProperties(jsonSchema, (key, value) => {\n      if (key === '$id' && value === '/schemas/any') {\n        return true;\n      }\n      if (key === '$ref' && value === '#/$defs/dependency') {\n        return true;\n      }\n      if (key === '$ref' && value === '#/$defs/jsonSchema') {\n        return true;\n      }\n\n      return false;\n    });\n  }\n\n  return jsonSchema;\n};\n\nconst _toJsonSchema = (schema: Schema.Schema.All): JsonSchemaType => {\n  invariant(schema);\n  const withRefinements = withEchoRefinements(schema.ast, '#');\n  let jsonSchema = JSONSchema.fromAST(withRefinements, {\n    definitions: {},\n  }) as JsonSchemaType;\n\n  jsonSchema.$schema = JSON_SCHEMA_URL;\n\n  if (jsonSchema.properties && 'id' in jsonSchema.properties) {\n    jsonSchema.properties = orderKeys(jsonSchema.properties, ['id']); // Put id first.\n  }\n\n  const echoIdentifier = getTypeIdentifierAnnotation(schema);\n  if (echoIdentifier) {\n    jsonSchema.$id = echoIdentifier;\n  }\n\n  const objectAnnotation = getTypeAnnotation(schema);\n  if (objectAnnotation) {\n    // EchoIdentifier annotation takes precedence but the id can also be defined by the typename.\n    if (!jsonSchema.$id) {\n      // TODO(dmaretskyi): Should this include the version?\n      jsonSchema.$id = DXN.fromTypename(objectAnnotation.typename).toString();\n    }\n    jsonSchema.entityKind = objectAnnotation.kind;\n    jsonSchema.version = objectAnnotation.version;\n    jsonSchema.typename = objectAnnotation.typename;\n    if (jsonSchema.entityKind === EntityKind.Relation) {\n      jsonSchema.relationTarget = {\n        $ref: objectAnnotation.sourceSchema,\n      };\n      jsonSchema.relationSource = {\n        $ref: objectAnnotation.targetSchema,\n      };\n    }\n  }\n\n  // Fix field order.\n  // TODO(dmaretskyi): Makes sure undefined is not left on optional fields for the resulting object.\n  // TODO(dmaretskyi): `orderFields` util.\n  jsonSchema = orderKeys(jsonSchema, [\n    '$schema',\n    '$id',\n\n    'entityKind',\n    'typename',\n    'version',\n    'relationTarget',\n    'relationSource',\n\n    'type',\n    'enum',\n\n    'properties',\n    'required',\n    'propertyOrder', // Custom.\n    'items',\n    'additionalProperties',\n\n    'anyOf',\n    'oneOf',\n  ]);\n\n  return jsonSchema;\n};\n\nconst withEchoRefinements = (\n  ast: SchemaAST.AST,\n  path: string | undefined,\n  suspendCache = new Map<SchemaAST.AST, string>(),\n): SchemaAST.AST => {\n  if (path) {\n    suspendCache.set(ast, path);\n  }\n\n  let recursiveResult: SchemaAST.AST;\n  if (SchemaAST.isSuspend(ast)) {\n    // Precompute JSON schema for suspended AST since effect serializer does not support it.\n    const suspendedAst = ast.f();\n    const cachedPath = suspendCache.get(suspendedAst);\n    if (cachedPath) {\n      recursiveResult = new SchemaAST.Suspend(() => withEchoRefinements(suspendedAst, path, suspendCache), {\n        [SchemaAST.JSONSchemaAnnotationId]: {\n          $ref: cachedPath,\n        },\n      });\n    } else {\n      const jsonSchema = _toJsonSchema(Schema.make(suspendedAst));\n      recursiveResult = new SchemaAST.Suspend(() => withEchoRefinements(suspendedAst, path, suspendCache), {\n        [SchemaAST.JSONSchemaAnnotationId]: jsonSchema,\n      });\n    }\n  } else if (SchemaAST.isTypeLiteral(ast)) {\n    // Add property order annotations\n    recursiveResult = mapAst(ast, (ast, key) =>\n      withEchoRefinements(ast, path && typeof key === 'string' ? `${path}/${key}` : undefined, suspendCache),\n    );\n    recursiveResult = addJsonSchemaFields(recursiveResult, {\n      propertyOrder: [...ast.propertySignatures.map((p) => p.name)] as string[],\n    });\n  } else if (SchemaAST.isUndefinedKeyword(ast)) {\n    // Ignore undefined keyword that appears in the optional fields.\n    return ast;\n  } else {\n    recursiveResult = mapAst(ast, (ast, key) =>\n      withEchoRefinements(\n        ast,\n        path && (typeof key === 'string' || typeof key === 'number') ? `${path}/${key}` : undefined,\n        suspendCache,\n      ),\n    );\n  }\n\n  const annotationFields = annotations_toJsonSchemaFields(ast.annotations);\n  if (Object.keys(annotationFields).length === 0) {\n    return recursiveResult;\n  } else {\n    return addJsonSchemaFields(recursiveResult, annotationFields);\n  }\n};\n\n/**\n * Convert JSON schema to effect schema.\n * @param root\n * @param definitions\n */\nexport const toEffectSchema = (root: JsonSchemaType, _defs?: JsonSchemaType['$defs']): Schema.Schema.AnyNoContext => {\n  const defs = root.$defs ? { ..._defs, ...root.$defs } : _defs ?? {};\n  if ('type' in root && root.type === 'object') {\n    return objectToEffectSchema(root, defs);\n  }\n\n  let result: Schema.Schema.AnyNoContext = Schema.Unknown;\n  if ('$id' in root) {\n    switch (root.$id as string) {\n      case '/schemas/any': {\n        result = anyToEffectSchema(root as JSONSchema.JsonSchema7Any);\n        break;\n      }\n      case '/schemas/unknown': {\n        result = Schema.Unknown;\n        break;\n      }\n      case '/schemas/{}':\n      case '/schemas/object': {\n        result = Schema.Object;\n        break;\n      }\n      // Custom ECHO object reference.\n      case '/schemas/echo/ref': {\n        result = refToEffectSchema(root);\n      }\n    }\n  } else if ('enum' in root) {\n    result = Schema.Union(...root.enum!.map((e) => Schema.Literal(e)));\n  } else if ('oneOf' in root) {\n    result = Schema.Union(...root.oneOf!.map((v) => toEffectSchema(v, defs)));\n  } else if ('anyOf' in root) {\n    result = Schema.Union(...root.anyOf!.map((v) => toEffectSchema(v, defs)));\n  } else if ('type' in root) {\n    switch (root.type) {\n      case 'string': {\n        result = Schema.String;\n        if (root.pattern) {\n          result = result.pipe(Schema.pattern(new RegExp(root.pattern)));\n        }\n        break;\n      }\n      case 'number': {\n        result = Schema.Number;\n        break;\n      }\n      case 'integer': {\n        result = Schema.Number.pipe(Schema.int());\n        break;\n      }\n      case 'boolean': {\n        result = Schema.Boolean;\n        break;\n      }\n      case 'array': {\n        if (Array.isArray(root.items)) {\n          result = Schema.Tuple(...root.items.map((v) => toEffectSchema(v, defs)));\n        } else {\n          invariant(root.items);\n          const items = root.items;\n          result = Array.isArray(items)\n            ? Schema.Tuple(...items.map((v) => toEffectSchema(v, defs)))\n            : Schema.Array(toEffectSchema(items as JsonSchemaType, defs));\n        }\n        break;\n      }\n      case 'null': {\n        result = Schema.Null;\n        break;\n      }\n    }\n  } else if ('$ref' in root) {\n    const refSegments = root.$ref!.split('/');\n    const jsonSchema = defs[refSegments[refSegments.length - 1]];\n    invariant(jsonSchema, `missing definition for ${root.$ref}`);\n    result = toEffectSchema(jsonSchema, defs).pipe(\n      Schema.annotations({ identifier: refSegments[refSegments.length - 1] }),\n    );\n  }\n\n  const annotations = jsonSchemaFieldsToAnnotations(root);\n\n  // log.info('toEffectSchema', { root, annotations });\n  result = result.annotations(annotations);\n\n  return result;\n};\n\nconst objectToEffectSchema = (root: JsonSchemaType, defs: JsonSchemaType['$defs']): Schema.Schema.AnyNoContext => {\n  invariant('type' in root && root.type === 'object', `not an object: ${root}`);\n\n  const echoRefinement: JsonSchemaEchoAnnotations = (root as any)[ECHO_ANNOTATIONS_NS_DEPRECATED_KEY];\n  const isEchoObject =\n    echoRefinement != null || ('$id' in root && typeof root.$id === 'string' && root.$id.startsWith('dxn:'));\n\n  let fields: Schema.Struct.Fields = {};\n  const propertyList = Object.entries(root.properties ?? {});\n  let immutableIdField: Schema.Schema.AnyNoContext | undefined;\n  for (const [key, value] of propertyList) {\n    if (isEchoObject && key === 'id') {\n      immutableIdField = toEffectSchema(value, defs);\n    } else {\n      // TODO(burdon): Mutable cast.\n      (fields as any)[key] = root.required?.includes(key)\n        ? toEffectSchema(value, defs)\n        : Schema.optional(toEffectSchema(value, defs));\n    }\n  }\n\n  if (root.propertyOrder) {\n    fields = orderKeys(fields, root.propertyOrder as any);\n  }\n\n  let schema: Schema.Schema<any, any, unknown>;\n  if (root.patternProperties) {\n    invariant(propertyList.length === 0, 'pattern properties mixed with regular properties are not supported');\n    invariant(\n      Object.keys(root.patternProperties).length === 1 && Object.keys(root.patternProperties)[0] === '',\n      'only one pattern property is supported',\n    );\n\n    schema = Schema.Record({ key: Schema.String, value: toEffectSchema(root.patternProperties[''], defs) });\n  } else if (typeof root.additionalProperties !== 'object') {\n    schema = Schema.Struct(fields);\n  } else {\n    const indexValue = toEffectSchema(root.additionalProperties, defs);\n    if (propertyList.length > 0) {\n      schema = Schema.Struct(fields, { key: Schema.String, value: indexValue });\n    } else {\n      schema = Schema.Record({ key: Schema.String, value: indexValue });\n    }\n  }\n\n  if (immutableIdField) {\n    schema = Schema.extend(Schema.mutable(schema), Schema.Struct({ id: immutableIdField }));\n  }\n\n  const annotations = jsonSchemaFieldsToAnnotations(root);\n  return schema.annotations(annotations) as any;\n};\n\nconst anyToEffectSchema = (root: JSONSchema.JsonSchema7Any): Schema.Schema.AnyNoContext => {\n  const echoRefinement: JsonSchemaEchoAnnotations = (root as any)[ECHO_ANNOTATIONS_NS_DEPRECATED_KEY];\n  // TODO(dmaretskyi): Is this branch still taken?\n  if ((echoRefinement as any)?.reference != null) {\n    const echoId = root.$id.startsWith('dxn:echo:') ? root.$id : undefined;\n    return createEchoReferenceSchema(\n      echoId,\n      (echoRefinement as any).reference.typename,\n      (echoRefinement as any).reference.version,\n    );\n  }\n\n  return Schema.Any;\n};\n\n// TODO(dmaretskyi): Types.\nconst refToEffectSchema = (root: any): Schema.Schema.AnyNoContext => {\n  if (!('reference' in root)) {\n    return Ref(Expando);\n  }\n  const reference: JsonSchemaReferenceInfo = root.reference;\n  if (typeof reference !== 'object') {\n    throw new Error('Invalid reference field in ref schema');\n  }\n\n  const targetSchemaDXN = DXN.parse(reference.schema.$ref);\n  invariant(targetSchemaDXN.kind === DXN.kind.TYPE);\n\n  return createEchoReferenceSchema(\n    targetSchemaDXN.toString(),\n    targetSchemaDXN.kind === DXN.kind.TYPE ? targetSchemaDXN.parts[0] : undefined,\n    reference.schemaVersion,\n  );\n};\n\n//\n// Annotations\n//\n\nconst annotations_toJsonSchemaFields = (annotations: SchemaAST.Annotations): Record<symbol, any> => {\n  const schemaFields: Record<string, any> = {};\n\n  const echoAnnotations: JsonSchemaEchoAnnotations = {};\n  for (const [key, annotationId] of Object.entries(EchoAnnotations)) {\n    if (annotations[annotationId] != null) {\n      echoAnnotations[key as keyof JsonSchemaEchoAnnotations] = annotations[annotationId] as any;\n    }\n  }\n  if (Object.keys(echoAnnotations).length > 0) {\n    // TODO(dmaretskyi): use new namespace.\n    schemaFields[ECHO_ANNOTATIONS_NS_KEY] = echoAnnotations;\n  }\n\n  const echoIdentifier = annotations[TypeIdentifierAnnotationId];\n  if (echoIdentifier) {\n    schemaFields[ECHO_ANNOTATIONS_NS_KEY] ??= {};\n    schemaFields[ECHO_ANNOTATIONS_NS_KEY].schemaId = echoIdentifier;\n  }\n\n  // Custom (at end).\n  for (const [key, annotationId] of Object.entries(CustomAnnotations)) {\n    const value = annotations[annotationId];\n    if (value != null) {\n      schemaFields[key] = value;\n    }\n  }\n\n  return schemaFields;\n};\n\nconst decodeTypeIdentifierAnnotation = (schema: JsonSchemaType): string | undefined => {\n  // Limit to dxn:echo: URIs.\n  if (schema.$id && schema.$id.startsWith('dxn:echo:')) {\n    return schema.$id;\n  } else if (schema.$id && schema.$id.startsWith('dxn:type:') && schema?.echo?.type?.schemaId) {\n    const id = schema?.echo?.type?.schemaId;\n    if (ObjectId.isValid(id)) {\n      return DXN.fromLocalObjectId(id).toString();\n    }\n  }\n  return undefined;\n};\n\nconst decodeTypeAnnotation = (schema: JsonSchemaType): TypeAnnotation | undefined => {\n  if (schema.typename) {\n    const annotation: Mutable<TypeAnnotation> = {\n      // TODO(dmaretskyi): Decoding default.\n      kind: schema.entityKind ? Schema.decodeSync(EntityKindSchema)(schema.entityKind) : EntityKind.Object,\n      typename: schema.typename,\n      version: schema.version ?? '0.1.0',\n    };\n\n    if (annotation.kind === EntityKind.Relation) {\n      const source = schema.relationSource?.$ref ?? raise(new Error('Relation source not set'));\n      const target = schema.relationTarget?.$ref ?? raise(new Error('Relation target not set'));\n      annotation.sourceSchema = DXN.parse(source).toString();\n      annotation.targetSchema = DXN.parse(target).toString();\n    }\n\n    return annotation;\n  }\n\n  // Decode legacy schema.\n  if (!schema.typename && schema?.echo?.type) {\n    return {\n      kind: EntityKind.Object,\n      typename: schema.echo.type.typename,\n      version: schema.echo.type.version,\n    };\n  }\n\n  return undefined;\n};\n\nconst jsonSchemaFieldsToAnnotations = (schema: JsonSchemaType): SchemaAST.Annotations => {\n  const annotations: Types.Mutable<Schema.Annotations.Schema<any>> = {};\n\n  const echoAnnotations: JsonSchemaEchoAnnotations = getNormalizedEchoAnnotations(schema) ?? {};\n  if (echoAnnotations) {\n    for (const [key, annotationId] of Object.entries(EchoAnnotations)) {\n      if (echoAnnotations[key as keyof JsonSchemaEchoAnnotations]) {\n        annotations[annotationId] = echoAnnotations[key as keyof JsonSchemaEchoAnnotations];\n      }\n    }\n  }\n\n  annotations[TypeIdentifierAnnotationId] = decodeTypeIdentifierAnnotation(schema);\n  annotations[TypeAnnotationId] = decodeTypeAnnotation(schema);\n\n  // Custom (at end).\n  for (const [key, annotationId] of Object.entries({ ...CustomAnnotations, ...DecodedAnnotations })) {\n    if (key in schema) {\n      annotations[annotationId] = (schema as any)[key];\n    }\n  }\n\n  return clearUndefined(annotations);\n};\n\nconst makeAnnotatedRefinement = (ast: SchemaAST.AST, annotations: SchemaAST.Annotations): SchemaAST.Refinement => {\n  return new SchemaAST.Refinement(ast, () => Option.none(), annotations);\n};\n\nconst addJsonSchemaFields = (ast: SchemaAST.AST, schema: JsonSchemaType): SchemaAST.AST =>\n  makeAnnotatedRefinement(ast, { [SchemaAST.JSONSchemaAnnotationId]: schema });\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { SchemaAST } from 'effect';\n\nimport { GeneratorAnnotationId, LabelAnnotationId, PropertyMetaAnnotationId } from '../ast';\nimport { FormatAnnotationId, CurrencyAnnotationId } from '../formats';\nimport { type JsonSchemaEchoAnnotations, type JsonSchemaType } from '../json-schema';\n\n//\n// This file configures annotations for JSON encoding/decoding.\n//\n\n// Go on the root level.\ntype RootJsonSchemaProperty = keyof JsonSchemaType;\n\n// Go on the namespaced `annotations` property.\ntype NamespacedJsonSchemaProperty = keyof JsonSchemaEchoAnnotations;\n\n/**\n * List of annotations for JSON encoding/decoding.\n * Omits default effect-schema annotations since they are encoded with default serializer.\n */\n// TODO(burdon): Reconcile with `EchoAnnotations`.\nexport const CustomAnnotations: Partial<Record<RootJsonSchemaProperty, symbol>> = {\n  format: FormatAnnotationId,\n  currency: CurrencyAnnotationId,\n};\n\n/**\n * List of annotations for JSON decoding only.\n * Includes default effect annotations.\n */\nexport const DecodedAnnotations: Partial<Record<RootJsonSchemaProperty, symbol>> = {\n  title: SchemaAST.TitleAnnotationId,\n  description: SchemaAST.DescriptionAnnotationId,\n};\n\n/**\n * Annotations that go into ECHO namespace in json-schema.\n */\n// TODO(dmaretskyi): Consider removing ECHO namespace and putting them at the top level.\n// TODO(dmaretskyi): Move to format.ts when circular imports are solved\nexport const EchoAnnotations: Partial<Record<NamespacedJsonSchemaProperty, symbol>> = {\n  // TODO(dmaretskyi): `FieldLookupAnnotationId` might go here, but lets remove it entirely and use LabelAnnotation instead.\n  meta: PropertyMetaAnnotationId,\n  generator: GeneratorAnnotationId,\n  labelProp: LabelAnnotationId,\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { Schema } from 'effect';\n\nimport { JsonPath, type JsonProp } from '@dxos/effect';\n\nimport { EntityKindSchema } from '../ast';\nimport { FormatAnnotation, FormatEnum } from '../formats';\n\n//\n// JSON Schema\n//\n\n// TODO(burdon): Reuse/reconcile with ScalarTypeEnum (handle arrays).\nconst SimpleTypes = Schema.Literal('array', 'boolean', 'integer', 'null', 'number', 'object', 'string');\n\nconst NonNegativeInteger = Schema.Number.pipe(Schema.greaterThanOrEqualTo(0));\n\nconst StringArray = Schema.Array(Schema.String).pipe(Schema.mutable);\n\nconst JsonSchemaOrBoolean = Schema.Union(\n  Schema.suspend(() => JsonSchemaType),\n  Schema.Boolean,\n);\n\n/**\n * Go under the `annotations` property.\n */\nexport const JsonSchemaEchoAnnotations = Schema.Struct({\n  /**\n   * Label for this schema.\n   * Mapped from {@link LabelAnnotationId}.\n   */\n  labelProp: Schema.optional(Schema.Union(JsonPath, Schema.Array(JsonPath))),\n\n  /**\n   * Generator function for this schema.\n   * Mapped from {@link GeneratorAnnotationId}.\n   */\n  generator: Schema.optional(Schema.Union(Schema.String, Schema.Tuple(Schema.String, Schema.Number))),\n\n  /**\n   * {@link PropertyMeta} annotations get serialized here.\n   */\n  meta: Schema.optional(\n    Schema.Record({\n      key: Schema.String,\n      value: Schema.Any,\n    }).pipe(Schema.mutable),\n  ),\n\n  /**\n   * @deprecated\n   */\n  // TODO(dmaretskyi): We risk old schema not passing validation due to the extra fields. Remove when we are sure this is safe\n  type: Schema.optional(\n    Schema.Struct({\n      typename: Schema.String,\n      version: Schema.String,\n\n      // Not used.\n      schemaId: Schema.optional(Schema.String),\n    }).pipe(Schema.mutable),\n  ),\n\n  /**\n   * @deprecated Superseded by `meta`.\n   */\n  annotations: Schema.optional(\n    Schema.Record({\n      key: Schema.String,\n      value: Schema.Any,\n    }).pipe(Schema.mutable),\n  ),\n}).pipe(Schema.mutable);\nexport type JsonSchemaEchoAnnotations = Schema.Schema.Type<typeof JsonSchemaEchoAnnotations>;\n\n/**\n * Describes a schema for the JSON-schema objects stored in ECHO.\n * Contains extensions for ECHO (e.g., references).\n * Ref: https://json-schema.org/draft-07/schema\n */\n// TODO(burdon): Integrate with Effect Serializable?\n// TODO(dmaretskyi): Update to latest draft: https://json-schema.org/draft/2020-12\nconst _JsonSchemaType = Schema.Struct({\n  /**\n   * Identifier for this schema.\n   * This schema might be referenced by $ref clause in other schemas.\n   */\n  // TODO(dmaretskyi): Specify how the ids are generated.\n  // TODO(dmaretskyi): For type dxns, should this include the version?\n  $id: Schema.optional(Schema.String),\n\n  /**\n   * Schema of this schema.\n   * Set to \"https://json-schema.org/draft-07/schema\".\n   */\n  $schema: Schema.optional(Schema.String),\n\n  /**\n   * Reference to another schema.\n   */\n  $ref: Schema.optional(Schema.String),\n\n  /**\n   * Comments are ignored when interpreting the schema.\n   */\n  $comment: Schema.optional(Schema.String),\n\n  /**\n   * Defines whether this schema is an object schema or a relation schema.\n   */\n  entityKind: Schema.optional(EntityKindSchema),\n\n  /**\n   * Typename of this schema.\n   * Only on schema representing an ECHO object.\n   *\n   * @example 'example.com/type/MyType'\n   */\n  typename: Schema.optional(Schema.String),\n\n  /**\n   * Version of this schema.\n   * Custom dialect for ECHO.\n   */\n  version: Schema.optional(Schema.String),\n\n  /**\n   * Target of this relation.\n   * Only for relation schemas.\n   * The referenced schema must be an object schema.\n   */\n  relationTarget: Schema.optional(Schema.suspend(() => JsonSchemaType)),\n\n  /**\n   * Source of this relation.\n   * Only for relation schemas.\n   * The referenced schema must be an object schema.\n   */\n  relationSource: Schema.optional(Schema.suspend(() => JsonSchemaType)),\n\n  /**\n   * Title of this schema.\n   */\n  title: Schema.optional(Schema.String),\n\n  /**\n   * Description of this schema.\n   */\n  description: Schema.optional(Schema.String),\n\n  /**\n   * Whether this schema is read-only.\n   */\n  readOnly: Schema.optional(Schema.Boolean),\n\n  /**\n   * Whether this schema is write-only.\n   */\n  writeOnly: Schema.optional(Schema.Boolean),\n\n  /**\n   * Examples of instances of this schema.\n   */\n  examples: Schema.optional(Schema.Array(Schema.Any)),\n\n  /**\n   * Default value for this schema.\n   */\n  default: Schema.optional(Schema.Any),\n\n  /**\n   * This schema only matches values that are equal to this value.\n   */\n  const: Schema.optional(Schema.Any),\n\n  /**\n   * This schema only matches one of the values in this array.\n   */\n  enum: Schema.optional(Schema.Array(Schema.Any)),\n\n  /**\n   * Base type of the schema.\n   */\n  type: Schema.optional(Schema.Union(SimpleTypes, Schema.Array(SimpleTypes))),\n\n  //\n  // Numbers.\n  //\n\n  multipleOf: Schema.optional(Schema.Number.pipe(Schema.greaterThan(0))),\n  maximum: Schema.optional(Schema.Number),\n  exclusiveMaximum: Schema.optional(Schema.Number),\n  minimum: Schema.optional(Schema.Number),\n  exclusiveMinimum: Schema.optional(Schema.Number),\n\n  //\n  // Strings.\n  //\n\n  maxLength: Schema.optional(NonNegativeInteger),\n\n  /**\n   * Regex pattern for strings.\n   */\n  pattern: Schema.optional(Schema.String.pipe(FormatAnnotation.set(FormatEnum.Regex))),\n\n  /**\n   * Serialized from {@link FormatAnnotationId}.\n   */\n  format: Schema.optional(Schema.String),\n\n  //\n  // Arrays\n  //\n\n  minLength: Schema.optional(NonNegativeInteger),\n  items: Schema.optional(\n    Schema.Union(\n      Schema.suspend(() => JsonSchemaType),\n      Schema.Array(Schema.suspend(() => JsonSchemaType)),\n    ),\n  ),\n  additionalItems: Schema.optional(\n    Schema.Union(\n      Schema.suspend(() => JsonSchemaType),\n      Schema.Boolean,\n    ),\n  ),\n  maxItems: Schema.optional(NonNegativeInteger),\n  minItems: Schema.optional(NonNegativeInteger),\n  uniqueItems: Schema.optional(Schema.Boolean),\n  contains: Schema.optional(Schema.suspend(() => JsonSchemaType)),\n\n  //\n  // Objects\n  //\n\n  maxProperties: Schema.optional(NonNegativeInteger),\n  minProperties: Schema.optional(NonNegativeInteger),\n  required: Schema.optional(StringArray),\n\n  /**\n   * Non-standard JSON Schema extension.\n   * Defines the order of properties in the object.\n   * The unmentioned properties are placed at the end.\n   *\n   * Related: https://github.com/json-schema/json-schema/issues/119\n   */\n  propertyOrder: Schema.optional(StringArray),\n\n  additionalProperties: Schema.optional(JsonSchemaOrBoolean),\n  properties: Schema.optional(\n    Schema.Record({\n      key: Schema.String,\n      value: Schema.suspend(() => JsonSchemaType),\n    }).pipe(Schema.mutable),\n  ),\n  patternProperties: Schema.optional(\n    Schema.Record({\n      key: Schema.String,\n      value: Schema.suspend(() => JsonSchemaType),\n    }).pipe(Schema.mutable),\n  ),\n  propertyNames: Schema.optional(Schema.suspend(() => JsonSchemaType)),\n\n  definitions: Schema.optional(\n    Schema.mutable(\n      Schema.Record({\n        key: Schema.String,\n        value: Schema.suspend(() => JsonSchemaType),\n      }),\n    ),\n  ),\n  dependencies: Schema.optional(\n    Schema.Record({\n      key: Schema.String,\n      value: Schema.suspend(() => Schema.Union(Schema.String, StringArray, JsonSchemaType)).annotations({\n        identifier: 'dependency',\n        description: 'Dependency',\n      }),\n    }),\n  ),\n\n  contentMediaType: Schema.optional(Schema.String),\n  contentEncoding: Schema.optional(Schema.String),\n\n  if: Schema.optional(Schema.suspend(() => JsonSchemaType)),\n  then: Schema.optional(Schema.suspend(() => JsonSchemaType)),\n  else: Schema.optional(Schema.suspend(() => JsonSchemaType)),\n  allOf: Schema.optional(Schema.Array(Schema.suspend(() => JsonSchemaType))),\n  anyOf: Schema.optional(Schema.Array(Schema.suspend(() => JsonSchemaType))),\n  oneOf: Schema.optional(Schema.Array(Schema.suspend(() => JsonSchemaType))),\n  not: Schema.optional(Schema.suspend(() => JsonSchemaType)),\n  $defs: Schema.optional(\n    Schema.mutable(\n      Schema.Record({\n        key: Schema.String,\n        value: Schema.suspend(() => JsonSchemaType),\n      }),\n    ),\n  ),\n\n  //\n  // ECHO extensions.\n  //\n\n  currency: Schema.optional(Schema.String),\n\n  reference: Schema.optional(\n    Schema.mutable(\n      Schema.Struct({\n        schema: Schema.suspend(() => JsonSchemaType),\n        schemaVersion: Schema.optional(Schema.String),\n        schemaObject: Schema.optional(Schema.String),\n      }),\n    ),\n  ),\n\n  /**\n   * ECHO-specific annotations.\n   */\n  // TODO(dmaretskyi): Since we are adding a lot of new extensions to the JSON Schema, it is safer to namespace them here.\n  annotations: Schema.optional(Schema.mutable(JsonSchemaEchoAnnotations)),\n\n  /**\n   * @deprecated Use `annotations` instead.\n   */\n  echo: Schema.optional(Schema.mutable(JsonSchemaEchoAnnotations)),\n}).annotations({ identifier: 'jsonSchema', description: 'JSON Schema' });\n\nexport const JsonSchemaFields = Object.keys(_JsonSchemaType.fields);\n\n/**\n * https://json-schema.org/draft-07/schema\n */\nexport interface JsonSchemaType extends Schema.Schema.Type<Schema.mutable<typeof _JsonSchemaType>> {}\n\nexport const JsonSchemaType: Schema.Schema<JsonSchemaType> = _JsonSchemaType.pipe(Schema.mutable);\n\n// TODO(burdon): Factor out JSON schema utils.\n\nexport const getSchemaProperty = (schema: JsonSchemaType, property: JsonProp): JsonSchemaType | undefined => {\n  return schema.properties?.[property];\n};\n\n// TODO(burdon): Properties should be ordered.\nexport const setSchemaProperty = (schema: JsonSchemaType, property: JsonProp, value: JsonSchemaType) => {\n  schema.properties ??= {};\n  schema.properties[property] = value;\n  return schema;\n};\n\n/**\n * @internal\n */\nexport const ECHO_ANNOTATIONS_NS_DEPRECATED_KEY: keyof JsonSchemaType = 'echo';\n\n/**\n * @internal\n */\nexport const ECHO_ANNOTATIONS_NS_KEY = 'annotations';\n\n/**\n * @internal\n * @returns ECHO annotations namespace object in its normalized form.\n *\n * `meta` holds PropertyMeta annotations.\n * `annotations` holds other annotations.\n */\nexport const getNormalizedEchoAnnotations = (obj: JsonSchemaType): JsonSchemaEchoAnnotations | undefined => {\n  if (obj[ECHO_ANNOTATIONS_NS_KEY] != null && obj[ECHO_ANNOTATIONS_NS_DEPRECATED_KEY] != null) {\n    return normalizeEchoAnnotations({\n      ...obj[ECHO_ANNOTATIONS_NS_DEPRECATED_KEY],\n      ...obj[ECHO_ANNOTATIONS_NS_KEY],\n    });\n  } else if (obj[ECHO_ANNOTATIONS_NS_KEY] != null) {\n    return normalizeEchoAnnotations(obj[ECHO_ANNOTATIONS_NS_KEY]!);\n  } else if (obj[ECHO_ANNOTATIONS_NS_DEPRECATED_KEY] != null) {\n    return normalizeEchoAnnotations(obj[ECHO_ANNOTATIONS_NS_DEPRECATED_KEY]!);\n  } else {\n    return undefined;\n  }\n};\n\nconst normalizeEchoAnnotations = (obj: JsonSchemaEchoAnnotations): JsonSchemaEchoAnnotations => {\n  if (!obj.annotations) {\n    return obj;\n  } else {\n    const res = {\n      ...obj,\n      meta: {\n        ...obj.annotations,\n        ...(obj.meta ?? {}),\n      },\n    };\n    delete res.annotations;\n    return res;\n  }\n};\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { JsonSchemaFields, type JsonSchemaType } from './json-schema-type';\n\n/**\n * Normalize schema to to draft-07 format.\n * Note: the input type does not necessarily match the {@link JsonSchemaType} type.\n */\nexport const normalizeSchema = (schema: JsonSchemaType): JsonSchemaType => {\n  const copy = structuredClone(schema);\n  go(copy);\n  return copy;\n};\n\nconst go = (schema: JsonSchemaType) => {\n  if (typeof schema !== 'object' || schema === null) {\n    return;\n  }\n\n  if ((schema as any).exclusiveMaximum === true) {\n    schema.exclusiveMaximum = schema.maximum;\n    delete (schema as any).exclusiveMaximum;\n  } else if ((schema as any).exclusiveMaximum === false) {\n    delete (schema as any).exclusiveMaximum;\n  }\n\n  if ((schema as any).exclusiveMinimum === true) {\n    schema.exclusiveMinimum = schema.minimum;\n    delete (schema as any).exclusiveMinimum;\n  } else if ((schema as any).exclusiveMinimum === false) {\n    delete (schema as any).exclusiveMinimum;\n  }\n\n  // Delete all properties that are not in the JsonSchemaFields.\n  for (const key of Object.keys(schema)) {\n    if (!JsonSchemaFields.includes(key)) {\n      delete (schema as any)[key];\n    }\n  }\n\n  // Recursively normalize the schema.\n  // Recursively normalize the schema.\n  if (schema.properties) {\n    goOnRecord(schema.properties);\n  }\n  if (schema.patternProperties) {\n    goOnRecord(schema.patternProperties);\n  }\n  if (schema.propertyNames) {\n    go(schema.propertyNames);\n  }\n  if (schema.definitions) {\n    goOnRecord(schema.definitions);\n  }\n  if (schema.items) {\n    maybeGoOnArray(schema.items);\n  }\n  if (schema.additionalItems) {\n    maybeGoOnArray(schema.additionalItems);\n  }\n  if (schema.contains) {\n    go(schema.contains);\n  }\n  if (schema.if) {\n    go(schema.if);\n  }\n  if (schema.then) {\n    go(schema.then);\n  }\n  if (schema.else) {\n    go(schema.else);\n  }\n  if (schema.allOf) {\n    maybeGoOnArray(schema.allOf);\n  }\n  if (schema.anyOf) {\n    maybeGoOnArray(schema.anyOf);\n  }\n  if (schema.oneOf) {\n    maybeGoOnArray(schema.oneOf);\n  }\n  if (schema.not) {\n    go(schema.not);\n  }\n  if (schema.$defs) {\n    goOnRecord(schema.$defs);\n  }\n  if (schema.reference) {\n    go(schema.reference.schema);\n  }\n};\n\nconst maybeGoOnArray = (value: any) => {\n  if (Array.isArray(value)) {\n    for (const item of value) {\n      go(item);\n    }\n  } else if (typeof value === 'object' && value !== null) {\n    go(value);\n  }\n};\n\nconst goOnRecord = (record: Record<string, any>) => {\n  for (const key of Object.keys(record)) {\n    go(record[key]);\n  }\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { Schema } from 'effect';\n\n// TODO(ZaymonFC): Where should this live?\nconst SortDirection = Schema.Union(Schema.Literal('asc'), Schema.Literal('desc'));\nexport type SortDirectionType = Schema.Schema.Type<typeof SortDirection>;\n\n// TODO(ZaymonFC): Struct vs pair?\nconst FieldSort = Schema.Struct({\n  fieldId: Schema.String,\n  direction: SortDirection,\n}).pipe(Schema.mutable);\n\nexport interface FieldSortType extends Schema.Schema.Type<typeof FieldSort> {}\n\nexport const FieldSortType: Schema.Schema<FieldSortType> = FieldSort;\n\n/**\n * ECHO query object.\n */\nconst QuerySchema = Schema.Struct({\n  typename: Schema.optional(Schema.String),\n  sort: Schema.optional(Schema.Array(FieldSort)),\n}).pipe(Schema.mutable);\n\nexport interface QueryType extends Schema.Schema.Type<typeof QuerySchema> {}\n\nexport const QueryType: Schema.Schema<QueryType> = QuerySchema;\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { SchemaAST, Schema } from 'effect';\n\nimport { Reference } from '@dxos/echo-protocol';\nimport { splitJsonPath, type JsonPath } from '@dxos/effect';\nimport { DXN } from '@dxos/keys';\nimport { getDeep, setDeep } from '@dxos/util';\n\nimport { getSchemaDXN } from '../ast';\nimport { getType, getTypename, type ObjectMeta, type EntityKindId } from '../object';\nimport { ATTR_META } from '../object/model';\n\n/**\n * Base type for all data objects (reactive, ECHO, and other raw objects).\n * NOTE: This describes the base type for all database objects.\n * It is stricter than `T extends {}` or `T extends object`.\n */\n// TODO(dmaretskyi): Rename AnyProperties.\nexport type BaseObject = Record<string, any>;\n\n/**\n * Marker interface for object with an `id`.\n */\nexport type HasId = {\n  readonly id: string;\n};\n\n// TODO(burdon): Reconcile with AnyLiveObject. This type is used in some places (e.g. Ref) to mean LiveObject? Do we need branded types?\nexport type WithId = BaseObject & HasId;\n\nexport type ExcludeId<T extends BaseObject> = Omit<T, 'id'>;\n\nexport type CreationProps<T extends BaseObject> = Omit<T, 'id' | typeof EntityKindId>;\n\nexport type PropertyKey<T extends BaseObject> = Extract<keyof ExcludeId<T>, string>;\n\nexport type WithMeta = { [ATTR_META]?: ObjectMeta };\n\n/**\n * The raw object should not include the ECHO id, but may include metadata.\n */\nexport const RawObject = <S extends Schema.Schema.AnyNoContext>(\n  schema: S,\n): Schema.Schema<ExcludeId<Schema.Schema.Type<S>> & WithMeta, Schema.Schema.Encoded<S>> => {\n  return Schema.make(SchemaAST.omit(schema.ast, ['id']));\n};\n\n//\n// Data\n//\n\n/**\n * @deprecated No longer used.\n */\nexport interface CommonObjectData {\n  id: string;\n  // TODO(dmaretskyi): Document cases when this can be null.\n  // TODO(dmaretskyi): Convert to @typename and @meta.\n  __typename: string | null;\n  __meta: ObjectMeta;\n}\n\n/**\n * @deprecated No longer used.\n */\nexport interface AnyObjectData extends CommonObjectData {\n  /**\n   * Fields of the object.\n   */\n  [key: string]: any;\n}\n\n/**\n * Object data type in JSON-encodable format.\n * References are encoded in the IPLD format.\n * `__typename` is the string DXN of the object type.\n * Meta is added under `__meta` key.\n * @deprecated No longer used.\n */\nexport type ObjectData<S> = Schema.Schema.Encoded<S> & CommonObjectData;\n\n//\n// Utils\n//\n\n/**\n * Utility to split meta property from raw object.\n * @deprecated Bad API.\n */\nexport const splitMeta = <T>(object: T & WithMeta): { object: T; meta?: ObjectMeta } => {\n  const meta = object[ATTR_META];\n  delete object[ATTR_META];\n  return { meta, object };\n};\n\n// TODO(burdon): Move to `@dxos/util`.\nexport const getValue = <T extends object>(obj: T, path: JsonPath): any => {\n  return getDeep(\n    obj,\n    splitJsonPath(path).map((p) => p.replace(/[[\\]]/g, '')),\n  );\n};\n\n// TODO(burdon): Move to `@dxos/util`.\nexport const setValue = <T extends object>(obj: T, path: JsonPath, value: any): T => {\n  return setDeep(\n    obj,\n    splitJsonPath(path).map((p) => p.replace(/[[\\]]/g, '')),\n    value,\n  );\n};\n\n/**\n * Returns a reference that will be used to point to a schema.\n * @deprecated Use {@link getSchemaDXN} instead.\n */\nexport const getTypeReference = (schema: Schema.Schema.All | undefined): Reference | undefined => {\n  if (!schema) {\n    return undefined;\n  }\n\n  const schemaDXN = getSchemaDXN(schema);\n  if (!schemaDXN) {\n    return undefined;\n  }\n  return Reference.fromDXN(schemaDXN);\n};\n\n/**\n * Returns a reference that will be used to point to a schema.\n * @throws If it is not possible to reference this schema.\n *\n * @deprecated Use {@link getSchemaDXN} instead.\n */\nexport const requireTypeReference = (schema: Schema.Schema.AnyNoContext): Reference => {\n  const typeReference = getTypeReference(schema);\n  if (typeReference == null) {\n    // TODO(burdon): Catalog user-facing errors (this is too verbose).\n    throw new Error('Schema must be defined via TypedObject.');\n  }\n\n  return typeReference;\n};\n\n// TODO(burdon): Can we use `Schema.is`?\n/**\n * Checks if the object is an instance of the schema.\n * Only typename is compared, the schema version is ignored.\n *\n * The following cases are considered to mean that the object is an instance of the schema:\n *  - Object was created with this exact schema.\n *  - Object was created with a different version of this schema.\n *  - Object was created with a different schema (maybe dynamic) that has the same typename.\n */\nexport const isInstanceOf = <Schema extends Schema.Schema.AnyNoContext>(\n  schema: Schema,\n  object: any,\n): object is Schema.Schema.Type<Schema> => {\n  if (object == null) {\n    return false;\n  }\n\n  const schemaDXN = getSchemaDXN(schema);\n  if (!schemaDXN) {\n    throw new Error('Schema must have an object annotation.');\n  }\n\n  const type = getType(object);\n  if (type && DXN.equals(type, schemaDXN)) {\n    return true;\n  }\n\n  const typename = getTypename(object);\n  if (!typename) {\n    return false;\n  }\n\n  const typeDXN = schemaDXN.asTypeDXN();\n  if (!typeDXN) {\n    return false;\n  }\n\n  return typeDXN.type === typename;\n};\n\n/**\n * Object that has an associated typename.\n * The typename is retrievable using {@link getTypename}.\n * The object can be used with {@link isInstanceOf} to check if it is an instance of a schema.\n */\nexport type HasTypename = {};\n\n/**\n * Canonical type for all ECHO objects.\n * @deprecated Use `AnyEchoObject` instead.\n */\nexport interface BaseEchoObject extends HasId, HasTypename {}\n\n// TODO(burdon): Reconcile with Type.Any.\nexport interface AnyEchoObject extends BaseEchoObject {}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { invariant } from '@dxos/invariant';\n\nimport { type JsonSchemaType } from '../json-schema';\nimport { getSnapshot } from '../schema';\n\n/**\n * Creates a composite schema from the source and projection schemas.\n */\n// TODO(burdon): Use effect schema projections.\n// TODO(burdon): Can avoid having to call this every time we modify any property on the view?\nexport const composeSchema = (source: JsonSchemaType, target: JsonSchemaType): JsonSchemaType => {\n  const result: JsonSchemaType = getSnapshot(target);\n  invariant('type' in result && result.type === 'object', 'source schema must be an object');\n  invariant('type' in source && source.type === 'object', 'target schema must be an object');\n\n  for (const prop in result.properties) {\n    const propSchema = source.properties![prop]; // TODO(dmaretskyi): Find by json-path instead.\n    const annotations = (propSchema as JsonSchemaType)?.annotations?.meta;\n    if (annotations) {\n      (result.properties[prop] as JsonSchemaType).annotations ??= {};\n      (result.properties[prop] as JsonSchemaType).annotations!.meta ??= {};\n      for (const key in annotations) {\n        (result.properties[prop] as JsonSchemaType).annotations!.meta![key] ??= {};\n        Object.assign((result.properties[prop] as JsonSchemaType).annotations!.meta![key], annotations[key], {\n          ...(result.properties[prop] as JsonSchemaType).annotations!.meta![key],\n        });\n      }\n    }\n  }\n\n  return result;\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { Schema, SchemaAST } from 'effect';\n\nimport { invariant } from '@dxos/invariant';\nimport { type ObjectId } from '@dxos/keys';\n\nimport {\n  addFieldsToSchema,\n  removeFieldsFromSchema,\n  setTypenameInSchema,\n  updateFieldNameInSchema,\n  updateFieldsInSchema,\n} from './manipulation';\nimport { getSnapshot } from './snapshot';\nimport { StoredSchema } from './stored-schema';\nimport { getTypeAnnotation, SchemaMetaSymbol, type SchemaMeta, type TypeAnnotation } from '../ast';\nimport { toEffectSchema, toJsonSchema } from '../json';\nimport { type JsonSchemaType } from '../json-schema';\nimport { type TypedObject, type TypedObjectPrototype } from '../object';\n\n/**\n * Base schema type.\n */\n// TODO(burdon): Merge with ImmutableSchema.\nexport interface BaseSchema<A = any, I = any> extends TypedObject<A, I> {\n  get readonly(): boolean;\n  // TODO(burdon): Change to external function.\n  get mutable(): EchoSchema<A, I>;\n  get snapshot(): Schema.Schema<A, I>;\n  get jsonSchema(): JsonSchemaType;\n}\n\n/**\n * Immutable schema type.\n * @deprecated Use `Schema.Schema.AnyNoContext` instead.\n */\n// TODO(burdon): Common abstract base class?\nexport class ImmutableSchema<A = any, I = any> implements BaseSchema<A, I> {\n  private readonly _objectAnnotation: TypeAnnotation;\n  constructor(private readonly _schema: Schema.Schema<A, I>) {\n    this._objectAnnotation = getTypeAnnotation(this._schema)!;\n    invariant(this._objectAnnotation);\n  }\n\n  //\n  // Effect Schema (push to abstract base class).\n  //\n\n  public get [Schema.TypeId]() {\n    return schemaVariance;\n  }\n\n  public get Type() {\n    return this._schema.Type;\n  }\n\n  public get Encoded() {\n    return this._schema.Encoded;\n  }\n\n  public get Context() {\n    return this._schema.Context;\n  }\n\n  public get ast(): SchemaAST.AST {\n    return this._schema.ast;\n  }\n\n  public get annotations() {\n    return this._schema.annotations;\n  }\n\n  public get pipe() {\n    return this._schema.pipe;\n  }\n\n  //\n  // TypedObject\n  //\n\n  get typename(): string {\n    return this._objectAnnotation.typename;\n  }\n\n  get version(): string {\n    return this._objectAnnotation.version;\n  }\n\n  //\n  // BaseSchema\n  //\n\n  get readonly(): boolean {\n    return true;\n  }\n\n  get snapshot(): Schema.Schema.AnyNoContext {\n    return this._schema;\n  }\n\n  // TODO(burdon): Change from getter since this is expensive.\n  get jsonSchema(): JsonSchemaType {\n    return toJsonSchema(this._schema);\n  }\n\n  get mutable(): EchoSchema {\n    throw new Error('Schema is readonly.');\n  }\n}\n\n/**\n * Defines an effect-schema for the `EchoSchema` type.\n *\n * This is here so that `EchoSchema` class can be used as a part of another schema definition (e.g., `ref(EchoSchema)`).\n */\nconst EchoSchemaConstructor = (): TypedObjectPrototype => {\n  /**\n   * Return class definition satisfying Schema.Schema.\n   */\n  return class {\n    private static get _schema() {\n      // The field is DynamicEchoSchema in runtime, but is serialized as StoredEchoSchema in automerge.\n      return Schema.Union(StoredSchema, Schema.instanceOf(EchoSchema)).annotations(StoredSchema.ast.annotations);\n    }\n\n    static readonly [Schema.TypeId] = schemaVariance;\n\n    static get ast() {\n      const schema = this._schema;\n      return schema.ast;\n    }\n\n    static get annotations() {\n      const schema = this._schema;\n      return schema.annotations.bind(schema);\n    }\n\n    static get pipe() {\n      const schema = this._schema;\n      return schema.pipe.bind(schema);\n    }\n  } as any;\n};\n\nexport const isMutable = (schema: Schema.Schema.AnyNoContext): schema is EchoSchema => {\n  return schema instanceof EchoSchema;\n};\n\n// NOTE: Keep in this file.\nconst schemaVariance = {\n  _A: (_: any) => _,\n  _I: (_: any) => _,\n  _R: (_: never) => _,\n};\n\n/**\n * Represents a schema that is stored in the ECHO database.\n * Schema can me mutable or readonly (specified by the {@link EchoSchema.readonly} field).\n *\n * Schema that can be modified at runtime via the API.\n * Is an instance of effect-schema (`Schema.Schema.AnyNoContext`) so it can be used in the same way as a regular schema.\n * IMPORTANT: The schema AST will change reactively when the schema is updated, including synced updates from remote peers.\n *\n * The class constructor is a schema instance itself, and can be used in the echo object definitions:\n *\n * @example\n * ```ts\n * export class TableType extends TypedObject({ typename: 'example.org/type/Table', version: '0.1.0' })({\n *   title: Schema.String,\n *   schema: Schema.optional(ref(EchoSchema)),\n *   props: Schema.mutable(S.Array(TablePropSchema)),\n * }) {}\n * ```\n *\n * The ECHO API will translate any references to StoredSchema objects to be resolved as EchoSchema objects.\n */\nexport class EchoSchema<A = any, I = any> extends EchoSchemaConstructor() implements BaseSchema<A, I> {\n  private _schema: Schema.Schema.AnyNoContext | undefined;\n  private _isDirty = true;\n\n  constructor(private readonly _storedSchema: StoredSchema) {\n    super();\n  }\n\n  //\n  // Effect Schema (push to abstract base class).\n  //\n\n  public get [Schema.TypeId]() {\n    return schemaVariance;\n  }\n\n  public get Type() {\n    return this._storedSchema as A;\n  }\n\n  public get Encoded() {\n    return this._storedSchema as I;\n  }\n\n  public get Context() {\n    const schema = this._getSchema();\n    return schema.Context;\n  }\n\n  public get ast() {\n    const schema = this._getSchema();\n    return schema.ast;\n  }\n\n  public get annotations() {\n    const schema = this._getSchema();\n    return schema.annotations.bind(schema);\n  }\n\n  public get pipe(): Schema.Schema.AnyNoContext['pipe'] {\n    const schema = this._getSchema();\n    return schema.pipe.bind(schema);\n  }\n\n  //\n  // BaseSchema\n  //\n\n  public get typename(): string {\n    return this._storedSchema.typename;\n  }\n\n  public get version(): string {\n    return this._storedSchema.version;\n  }\n\n  public get readonly(): boolean {\n    return false;\n  }\n\n  /**\n   * Returns an immutable schema snapshot of the current state of the schema.\n   */\n  public get snapshot(): Schema.Schema.AnyNoContext {\n    return this._getSchema();\n  }\n\n  /**\n   * @reactive\n   */\n  public get jsonSchema(): JsonSchemaType {\n    return this._storedSchema.jsonSchema;\n  }\n\n  /**\n   * Returns a mutable schema.\n   */\n  public get mutable(): EchoSchema {\n    invariant(!this.readonly, 'Schema is not mutable');\n    return this;\n  }\n\n  //\n  // Mutable Schema\n  //\n\n  /**\n   * Id of the ECHO object containing the schema.\n   */\n  public get id(): ObjectId {\n    return this._storedSchema.id;\n  }\n\n  public get [SchemaMetaSymbol](): SchemaMeta {\n    return { id: this.id, typename: this.typename, version: this._storedSchema.version };\n  }\n\n  /**\n   * Reference to the underlying stored schema object.\n   */\n  public get storedSchema(): StoredSchema {\n    return this._storedSchema;\n  }\n\n  public getProperties(): SchemaAST.PropertySignature[] {\n    const ast = this._getSchema().ast;\n    invariant(SchemaAST.isTypeLiteral(ast));\n    return [...ast.propertySignatures].filter((p) => p.name !== 'id').map(unwrapOptionality);\n  }\n\n  //\n  // Mutation methods.\n  // TODO(burdon): Create separate interface for dynamic schema.\n  // TODO(burdon): Deprecate direct manipulation? Use JSONSchema directly.\n  //\n\n  /**\n   * @throws Error if the schema is readonly.\n   */\n  public updateTypename(typename: string): void {\n    const updated = setTypenameInSchema(this._getSchema(), typename);\n    this._storedSchema.typename = typename;\n    this._storedSchema.jsonSchema = toJsonSchema(updated);\n  }\n\n  /**\n   * @throws Error if the schema is readonly.\n   */\n  public addFields(fields: Schema.Struct.Fields): void {\n    const extended = addFieldsToSchema(this._getSchema(), fields);\n    this._storedSchema.jsonSchema = toJsonSchema(extended);\n  }\n\n  /**\n   * @throws Error if the schema is readonly.\n   */\n  public updateFields(fields: Schema.Struct.Fields): void {\n    const updated = updateFieldsInSchema(this._getSchema(), fields);\n    this._storedSchema.jsonSchema = toJsonSchema(updated);\n  }\n\n  /**\n   * @throws Error if the schema is readonly.\n   */\n  public updateFieldPropertyName({ before, after }: { before: PropertyKey; after: PropertyKey }): void {\n    const renamed = updateFieldNameInSchema(this._getSchema(), { before, after });\n    this._storedSchema.jsonSchema = toJsonSchema(renamed);\n  }\n\n  /**\n   * @throws Error if the schema is readonly.\n   */\n  public removeFields(fieldNames: string[]): void {\n    const removed = removeFieldsFromSchema(this._getSchema(), fieldNames);\n    this._storedSchema.jsonSchema = toJsonSchema(removed);\n  }\n\n  //\n  // Internals\n  //\n\n  /**\n   * Called by EchoSchemaRegistry on update.\n   */\n  _invalidate(): void {\n    this._isDirty = true;\n  }\n\n  /**\n   * Rebuilds this schema if it is dirty.\n   */\n  _rebuild(): void {\n    if (this._isDirty || this._schema == null) {\n      this._schema = toEffectSchema(getSnapshot(this._storedSchema.jsonSchema));\n      this._isDirty = false;\n    }\n  }\n\n  private _getSchema(): Schema.Schema.AnyNoContext {\n    this._rebuild();\n    return this._schema!;\n  }\n}\n\n// TODO(burdon): Move to effect.\nconst unwrapOptionality = (property: SchemaAST.PropertySignature): SchemaAST.PropertySignature => {\n  if (!SchemaAST.isUnion(property.type)) {\n    return property;\n  }\n\n  return {\n    ...property,\n    type: property.type.types.find((type) => !SchemaAST.isUndefinedKeyword(type))!,\n  } as any;\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { SchemaAST, Schema } from 'effect';\n\nimport { invariant } from '@dxos/invariant';\n\nimport { type TypeAnnotation, TypeAnnotationId } from '../ast';\n\n// TODO(ZaymonFC): Do this one at a time. This might be dangerous.\nexport const addFieldsToSchema = (\n  schema: Schema.Schema.AnyNoContext,\n  fields: Schema.Struct.Fields,\n): Schema.Schema.AnyNoContext => {\n  const schemaExtension = Schema.partial(Schema.Struct(fields));\n  return Schema.extend(schema, schemaExtension).annotations(\n    schema.ast.annotations,\n  ) as any as Schema.Schema.AnyNoContext;\n};\n\nexport const updateFieldsInSchema = (\n  schema: Schema.Schema.AnyNoContext,\n  fields: Schema.Struct.Fields,\n): Schema.Schema.AnyNoContext => {\n  const ast = schema.ast as SchemaAST.TypeLiteral;\n  invariant(SchemaAST.isTypeLiteral(ast));\n\n  const updatedProperties = [...ast.propertySignatures];\n  const propertiesToUpdate = (Schema.partial(Schema.Struct(fields)).ast as SchemaAST.TypeLiteral).propertySignatures;\n  for (const property of propertiesToUpdate) {\n    const index = updatedProperties.findIndex((p) => p.name === property.name);\n    if (index !== -1) {\n      updatedProperties[index] = property;\n    } else {\n      updatedProperties.push(property);\n    }\n  }\n\n  return Schema.make(new SchemaAST.TypeLiteral(updatedProperties, ast.indexSignatures, ast.annotations));\n};\n\nexport const removeFieldsFromSchema = (\n  schema: Schema.Schema.AnyNoContext,\n  fieldNames: string[],\n): Schema.Schema.AnyNoContext => {\n  return Schema.make(SchemaAST.omit(schema.ast, fieldNames)).annotations(schema.ast.annotations);\n};\n\nexport const updateFieldNameInSchema = (\n  schema: Schema.Schema.AnyNoContext,\n  { before, after }: { before: PropertyKey; after: PropertyKey },\n): Schema.Schema.AnyNoContext => {\n  const ast = schema.ast as SchemaAST.TypeLiteral;\n  invariant(SchemaAST.isTypeLiteral(ast));\n\n  return Schema.make(\n    new SchemaAST.TypeLiteral(\n      ast.propertySignatures.map((p) =>\n        p.name === before\n          ? new SchemaAST.PropertySignature(after, p.type, p.isOptional, p.isReadonly, p.annotations)\n          : p,\n      ),\n      ast.indexSignatures,\n      ast.annotations,\n    ),\n  );\n};\n\nexport const setTypenameInSchema = (\n  schema: Schema.Schema.AnyNoContext,\n  typename: string,\n): Schema.Schema.AnyNoContext => {\n  const existingAnnotation = schema.ast.annotations[TypeAnnotationId] as TypeAnnotation;\n  invariant(existingAnnotation, `Missing ${String(TypeAnnotationId)}`);\n\n  return schema.annotations({\n    ...schema.ast.annotations,\n    [TypeAnnotationId]: {\n      kind: existingAnnotation.kind,\n      typename,\n      version: existingAnnotation.version,\n    } satisfies TypeAnnotation,\n  });\n};\n", "//\n// Copyright 2025 DXOS.org\n//\n\n/**\n * Returns a non-reactive snapshot of the given live object.\n */\n// TODO(wittjosiah): Types.\nexport const getSnapshot = (object: any): any => {\n  if (typeof object !== 'object') {\n    return object;\n  }\n\n  if (Array.isArray(object)) {\n    return object.map(getSnapshot);\n  }\n\n  const result: any = {};\n  for (const key in object) {\n    result[key] = getSnapshot(object[key]);\n  }\n\n  return result;\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { Schema } from 'effect';\n\nimport { Typename, Version } from '../ast';\nimport { JsonSchemaType } from '../json-schema';\nimport { EchoObject } from '../object';\n\n/**\n * Persistent representation of a schema.\n */\nexport const StoredSchema = Schema.Struct({\n  typename: Typename,\n  version: Version,\n  jsonSchema: JsonSchemaType,\n}).pipe(\n  EchoObject({\n    typename: 'dxos.org/type/Schema',\n    version: '0.1.0',\n  }),\n);\n\nexport type StoredSchema = Schema.Schema.Type<typeof StoredSchema>;\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { type Schema } from 'effect';\n\nimport { raise } from '@dxos/debug';\nimport { invariant } from '@dxos/invariant';\nimport { type DXN } from '@dxos/keys';\nimport { defaultMap } from '@dxos/util';\n\nimport { StoredSchema } from './stored-schema';\nimport { getSchemaTypename, getSchemaVersion } from '../ast';\n\n/**\n * Runtime registry of static schema objects (i.e., not Dynamic .\n */\n// TODO(burdon): Reconcile with EchoSchemaRegistry.\nexport class RuntimeSchemaRegistry {\n  private readonly _registry = new Map<string, Schema.Schema.AnyNoContext[]>();\n\n  constructor() {\n    this._registry.set(StoredSchema.typename, [StoredSchema]);\n  }\n\n  get schemas(): Schema.Schema.AnyNoContext[] {\n    return Array.from(this._registry.values()).flat();\n  }\n\n  hasSchema<S extends Schema.Schema.AnyNoContext>(schema: S): boolean {\n    const typename = getSchemaTypename(schema);\n    const version = getSchemaVersion(schema);\n    invariant(typename);\n    const schemas = this._registry.get(typename);\n    return schemas?.some((schema) => getSchemaVersion(schema) === version) ?? false;\n  }\n\n  getSchemaByDXN(dxn: DXN): Schema.Schema.AnyNoContext | undefined {\n    const components = dxn.asTypeDXN();\n    if (!components) {\n      return undefined;\n    }\n\n    const { type, version } = components;\n    const allSchemas = this._registry.get(type) ?? [];\n    if (version) {\n      return allSchemas.find((s) => getSchemaVersion(s) === version);\n    } else {\n      // If no version is specified, return the earliest version for backwards compatibility.\n      // TODO(dmaretskyi): Probably not correct to compare lexicographically, but it's good enough for now.\n      return allSchemas.sort((a, b) =>\n        (getSchemaVersion(a) ?? '0.0.0').localeCompare(getSchemaVersion(b) ?? '0.0.0'),\n      )[0];\n    }\n  }\n\n  /**\n   * @deprecated Use getSchemaByDXN.\n   */\n  getSchema(typename: string): Schema.Schema.AnyNoContext | undefined {\n    return this._registry.get(typename)?.[0];\n  }\n\n  addSchema(types: Schema.Schema.AnyNoContext[]): void {\n    types.forEach((schema) => {\n      const typename = getSchemaTypename(schema) ?? raise(new TypeError('Schema has no typename'));\n      const version = getSchemaVersion(schema) ?? raise(new TypeError('Schema has no version'));\n      const versions = defaultMap(this._registry, typename, () => []);\n      if (versions.some((schema) => getSchemaVersion(schema) === version)) {\n        throw new Error(`Schema version already registered: ${typename}:${version}`);\n      }\n\n      versions.push(schema);\n    });\n  }\n}\n"],
  "mappings": "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",
  "names": ["JsonPath", "splitJsonPath", "JsonProp", "ObjectId", "ForeignKey", "Schema", "Option", "SchemaAST", "pipe", "TypeEnum", "getTypeEnum", "property", "type", "undefined", "FormatAnnotationId", "Symbol", "for", "FormatAnnotation", "createAnnotationHelper", "getFormatAnnotation", "node", "pipe", "SchemaAST", "getAnnotation", "Option", "getOrUndefined", "FormatEnum", "FormatEnums", "Object", "values", "sort", "PropertyKind", "format", "typeToFormat", "formatToType", "OptionsAnnotationId", "getOptionsAnnotation", "encodeMultipleOf", "divisor", "Math", "pow", "encodeMultiple", "self", "undefined", "pipe", "Schema", "multipleOf", "DecimalPrecision", "transform", "Number", "strict", "encode", "value", "decode", "log10", "annotations", "title", "CurrencyAnnotationId", "Symbol", "for", "Currency", "decimals", "code", "FormatAnnotation", "set", "FormatEnum", "description", "toUpperCase", "Integer", "int", "Percent", "Timestamp", "Schema", "clamp", "GeoPoint", "Schema", "Tuple", "Number", "pipe", "clamp", "multipleOf", "annotations", "title", "optionalElement", "FormatAnnotation", "set", "FormatEnum", "description", "GeoLocation", "toGeoPoint", "longitude", "latitude", "height", "clampedLongitude", "clampedLatitude", "undefined", "fromGeoPoint", "geoPoint", "result", "Schema", "Keys", "Schema", "SchemaAST", "SimpleDate", "Schema", "Struct", "year", "Number", "pipe", "between", "month", "day", "SimpleTime", "Schema", "Struct", "hours", "Number", "pipe", "between", "minutes", "seconds", "SimpleDateTime", "Schema", "extend", "SimpleDate", "SimpleTime", "DateOnly", "Schema", "String", "pipe", "FormatAnnotation", "set", "FormatEnum", "Date", "annotations", "title", "description", "TimeOnly", "Time", "DateTime", "Duration", "SchemaAST", "ExamplesAnnotationId", "SchemaAST", "Schema", "Email", "Schema", "String", "pipe", "pattern", "FormatAnnotation", "set", "FormatEnum", "annotations", "title", "description", "Formula", "Hostname", "JSON", "Markdown", "Regex", "URL", "UUID", "SchemaAST", "ExamplesAnnotationId", "Format", "DXN", "Email", "Formula", "Hostname", "JSON", "Markdown", "Regex", "URL", "UUID", "Schema", "Currency", "Integer", "Percent", "Timestamp", "DateTime", "Date", "DateOnly", "Time", "TimeOnly", "Duration", "GeoPoint", "Schema", "SelectOptionSchema", "Schema", "Struct", "id", "NonEmptyString", "title", "String", "color", "pipe", "mutable", "JSONSchema", "Option", "Schema", "SchemaAST", "raise", "mapAst", "invariant", "DXN", "ObjectId", "clearUndefined", "orderKeys", "removeProperties", "SchemaAST", "CustomAnnotations", "format", "FormatAnnotationId", "currency", "CurrencyAnnotationId", "DecodedAnnotations", "title", "SchemaAST", "TitleAnnotationId", "description", "DescriptionAnnotationId", "EchoAnnotations", "meta", "PropertyMetaAnnotationId", "generator", "GeneratorAnnotationId", "labelProp", "LabelAnnotationId", "Schema", "JsonPath", "SimpleTypes", "Schema", "Literal", "NonNegativeInteger", "Number", "pipe", "greaterThanOrEqualTo", "StringArray", "Array", "String", "mutable", "JsonSchemaOrBoolean", "Union", "suspend", "JsonSchemaType", "Boolean", "JsonSchemaEchoAnnotations", "Struct", "labelProp", "optional", "JsonPath", "generator", "Tuple", "meta", "Record", "key", "value", "Any", "type", "typename", "version", "schemaId", "annotations", "_JsonSchemaType", "$id", "$schema", "$ref", "$comment", "entityKind", "EntityKindSchema", "relationTarget", "relationSource", "title", "description", "readOnly", "writeOnly", "examples", "default", "const", "enum", "multipleOf", "greaterThan", "maximum", "exclusiveMaximum", "minimum", "exclusiveMinimum", "maxLength", "pattern", "FormatAnnotation", "set", "FormatEnum", "Regex", "format", "minLength", "items", "additionalItems", "maxItems", "minItems", "uniqueItems", "contains", "maxProperties", "minProperties", "required", "propertyOrder", "additionalProperties", "properties", "patternProperties", "propertyNames", "definitions", "dependencies", "identifier", "contentMediaType", "contentEncoding", "if", "then", "else", "allOf", "anyOf", "oneOf", "not", "$defs", "currency", "reference", "schema", "schemaVersion", "schemaObject", "echo", "JsonSchemaFields", "Object", "keys", "fields", "getSchemaProperty", "property", "setSchemaProperty", "ECHO_ANNOTATIONS_NS_DEPRECATED_KEY", "ECHO_ANNOTATIONS_NS_KEY", "getNormalizedEchoAnnotations", "obj", "normalizeEchoAnnotations", "undefined", "res", "normalizeSchema", "schema", "copy", "structuredClone", "go", "exclusiveMaximum", "maximum", "exclusiveMinimum", "minimum", "key", "Object", "keys", "JsonSchemaFields", "includes", "properties", "goOnRecord", "patternProperties", "propertyNames", "definitions", "items", "maybeGoOnArray", "additionalItems", "contains", "if", "then", "else", "allOf", "anyOf", "oneOf", "not", "$defs", "reference", "value", "Array", "isArray", "item", "record", "createJsonSchema", "schema", "Schema", "Struct", "jsonSchema", "_toJsonSchema", "type", "anyOf", "PropType", "toPropType", "Error", "JSON_SCHEMA_URL", "toJsonSchema", "options", "strict", "removeProperties", "key", "value", "invariant", "withRefinements", "withEchoRefinements", "ast", "JSONSchema", "fromAST", "definitions", "$schema", "properties", "orderKeys", "echoIdentifier", "getTypeIdentifierAnnotation", "$id", "objectAnnotation", "getTypeAnnotation", "DXN", "fromTypename", "typename", "toString", "entityKind", "kind", "version", "EntityKind", "Relation", "relationTarget", "$ref", "sourceSchema", "relationSource", "targetSchema", "path", "suspendCache", "Map", "set", "recursiveResult", "SchemaAST", "isSuspend", "suspendedAst", "f", "cachedPath", "get", "Suspend", "JSONSchemaAnnotationId", "make", "isTypeLiteral", "mapAst", "undefined", "addJsonSchemaFields", "propertyOrder", "propertySignatures", "map", "p", "name", "isUndefinedKeyword", "annotationFields", "annotations_toJsonSchemaFields", "annotations", "Object", "keys", "length", "toEffectSchema", "root", "_defs", "defs", "$defs", "objectToEffectSchema", "result", "Unknown", "anyToEffectSchema", "refToEffectSchema", "Union", "enum", "e", "Literal", "oneOf", "v", "String", "pattern", "pipe", "RegExp", "Number", "int", "Boolean", "Array", "isArray", "items", "Tuple", "Null", "refSegments", "split", "identifier", "jsonSchemaFieldsToAnnotations", "echoRefinement", "ECHO_ANNOTATIONS_NS_DEPRECATED_KEY", "isEchoObject", "startsWith", "fields", "propertyList", "entries", "immutableIdField", "required", "includes", "optional", "patternProperties", "Record", "additionalProperties", "indexValue", "extend", "mutable", "id", "reference", "echoId", "createEchoReferenceSchema", "Any", "Ref", "Expando", "targetSchemaDXN", "parse", "TYPE", "parts", "schemaVersion", "schemaFields", "echoAnnotations", "annotationId", "EchoAnnotations", "ECHO_ANNOTATIONS_NS_KEY", "TypeIdentifierAnnotationId", "schemaId", "CustomAnnotations", "decodeTypeIdentifierAnnotation", "echo", "ObjectId", "isValid", "fromLocalObjectId", "decodeTypeAnnotation", "annotation", "decodeSync", "EntityKindSchema", "source", "raise", "target", "getNormalizedEchoAnnotations", "TypeAnnotationId", "DecodedAnnotations", "clearUndefined", "makeAnnotatedRefinement", "Refinement", "Option", "none", "Schema", "SortDirection", "Schema", "Union", "Literal", "FieldSort", "Struct", "fieldId", "String", "direction", "pipe", "mutable", "FieldSortType", "QuerySchema", "typename", "optional", "sort", "Array", "QueryType", "SchemaAST", "Schema", "Reference", "splitJsonPath", "DXN", "getDeep", "setDeep", "RawObject", "schema", "Schema", "make", "SchemaAST", "omit", "ast", "splitMeta", "object", "meta", "ATTR_META", "getValue", "obj", "path", "getDeep", "splitJsonPath", "map", "p", "replace", "setValue", "value", "setDeep", "getTypeReference", "undefined", "schemaDXN", "getSchemaDXN", "Reference", "fromDXN", "requireTypeReference", "typeReference", "Error", "isInstanceOf", "type", "getType", "DXN", "equals", "typename", "getTypename", "typeDXN", "asTypeDXN", "invariant", "Schema", "SchemaAST", "invariant", "SchemaAST", "Schema", "invariant", "addFieldsToSchema", "schema", "fields", "schemaExtension", "Schema", "partial", "Struct", "extend", "annotations", "ast", "updateFieldsInSchema", "invariant", "SchemaAST", "isTypeLiteral", "updatedProperties", "propertySignatures", "propertiesToUpdate", "property", "index", "findIndex", "p", "name", "push", "make", "TypeLiteral", "indexSignatures", "removeFieldsFromSchema", "fieldNames", "omit", "updateFieldNameInSchema", "before", "after", "map", "PropertySignature", "type", "isOptional", "isReadonly", "setTypenameInSchema", "typename", "existingAnnotation", "TypeAnnotationId", "String", "kind", "version", "getSnapshot", "object", "Array", "isArray", "map", "result", "key", "Schema", "StoredSchema", "Schema", "Struct", "typename", "Typename", "version", "Version", "jsonSchema", "JsonSchemaType", "pipe", "EchoObject", "ImmutableSchema", "_schema", "_objectAnnotation", "getTypeAnnotation", "invariant", "Schema", "TypeId", "schemaVariance", "Type", "Encoded", "Context", "ast", "annotations", "pipe", "typename", "version", "readonly", "snapshot", "jsonSchema", "toJsonSchema", "mutable", "Error", "EchoSchemaConstructor", "Union", "StoredSchema", "instanceOf", "EchoSchema", "schema", "bind", "isMutable", "_A", "_", "_I", "_R", "_storedSchema", "_isDirty", "_getSchema", "id", "SchemaMetaSymbol", "storedSchema", "getProperties", "SchemaAST", "isTypeLiteral", "propertySignatures", "filter", "p", "name", "map", "unwrapOptionality", "updateTypename", "updated", "setTypenameInSchema", "addFields", "fields", "extended", "addFieldsToSchema", "updateFields", "updateFieldsInSchema", "updateFieldPropertyName", "before", "after", "renamed", "updateFieldNameInSchema", "removeFields", "fieldNames", "removed", "removeFieldsFromSchema", "_invalidate", "_rebuild", "toEffectSchema", "getSnapshot", "property", "isUnion", "type", "types", "find", "isUndefinedKeyword", "raise", "invariant", "defaultMap", "RuntimeSchemaRegistry", "_registry", "Map", "set", "StoredSchema", "typename", "schemas", "Array", "from", "values", "flat", "hasSchema", "schema", "getSchemaTypename", "version", "getSchemaVersion", "invariant", "get", "some", "getSchemaByDXN", "dxn", "components", "asTypeDXN", "undefined", "type", "allSchemas", "find", "s", "sort", "a", "b", "localeCompare", "getSchema", "addSchema", "types", "forEach", "raise", "TypeError", "versions", "defaultMap", "Error", "push", "composeSchema", "source", "target", "result", "getSnapshot", "invariant", "type", "prop", "properties", "propSchema", "annotations", "meta", "key", "Object", "assign"]
}
