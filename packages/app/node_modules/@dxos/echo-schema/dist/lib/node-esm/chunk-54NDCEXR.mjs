import { createRequire } from 'node:module';const require = createRequire(import.meta.url);

// packages/core/echo/echo-schema/src/ast/annotation-helper.ts
import { SchemaAST } from "effect";
var createAnnotationHelper = (id) => {
  return {
    get: (schema) => SchemaAST.getAnnotation(schema, id),
    set: (value) => (schema) => schema.annotations({
      [id]: value
    })
  };
};

// packages/core/echo/echo-schema/src/ast/entity-kind.ts
import { Schema } from "effect";
var EntityKind = /* @__PURE__ */ function(EntityKind2) {
  EntityKind2["Object"] = "object";
  EntityKind2["Relation"] = "relation";
  return EntityKind2;
}({});
var EntityKindSchema = Schema.Enums(EntityKind);

// packages/core/echo/echo-schema/src/ast/annotations.ts
import { flow, Option, pipe, Schema as Schema2, SchemaAST as SchemaAST2 } from "effect";
import { assertArgument } from "@dxos/invariant";
import { DXN } from "@dxos/keys";
var TypeIdentifierAnnotationId = Symbol.for("@dxos/schema/annotation/TypeIdentifier");
var getTypeIdentifierAnnotation = (schema) => flow(SchemaAST2.getAnnotation(TypeIdentifierAnnotationId), Option.getOrElse(() => void 0))(schema.ast);
var TypeAnnotationId = Symbol.for("@dxos/schema/annotation/Type");
var Typename = Schema2.String.pipe(Schema2.pattern(/^[a-zA-Z]\w+\.[a-zA-Z]\w{1,}\/[\w/_-]+$/));
var Version = Schema2.String.pipe(Schema2.pattern(/^\d+.\d+.\d+$/));
var TypeAnnotation = Schema2.Struct({
  kind: Schema2.Enums(EntityKind),
  typename: Typename,
  version: Version,
  /**
  * If this is a relation, the schema of the source object.
  * Must be present if entity kind is {@link EntityKind.Relation}.
  */
  sourceSchema: Schema2.optional(DXN.Schema),
  /**
  * If this is a relation, the schema of the target object.
  * Must be present if entity kind is {@link EntityKind.Relation}.
  */
  targetSchema: Schema2.optional(DXN.Schema)
});
var getTypeAnnotation = (schema) => {
  assertArgument(schema != null && schema.ast != null, "invalid schema");
  return flow(SchemaAST2.getAnnotation(TypeAnnotationId), Option.getOrElse(() => void 0))(schema.ast);
};
var getEntityKind = (schema) => getTypeAnnotation(schema)?.kind;
var getSchemaTypename = (schema) => getTypeAnnotation(schema)?.typename;
var getSchemaVersion = (schema) => getTypeAnnotation(schema)?.version;
var PropertyMetaAnnotationId = Symbol.for("@dxos/schema/annotation/PropertyMeta");
var PropertyMeta = (name, value) => {
  return (self) => {
    const existingMeta = self.ast.annotations[PropertyMetaAnnotationId];
    return self.annotations({
      [PropertyMetaAnnotationId]: {
        ...existingMeta,
        [name]: value
      }
    });
  };
};
var getPropertyMetaAnnotation = (prop, name) => pipe(SchemaAST2.getAnnotation(PropertyMetaAnnotationId)(prop.type), Option.map((meta) => meta[name]), Option.getOrElse(() => void 0));
var ReferenceAnnotationId = Symbol.for("@dxos/schema/annotation/Reference");
var getReferenceAnnotation = (schema) => pipe(SchemaAST2.getAnnotation(ReferenceAnnotationId)(schema.ast), Option.getOrElse(() => void 0));
var SchemaMetaSymbol = Symbol.for("@dxos/schema/SchemaMeta");
var LabelAnnotationId = Symbol.for("@dxos/schema/annotation/Label");
var LabelAnnotation = createAnnotationHelper(LabelAnnotationId);
var FieldLookupAnnotationId = Symbol.for("@dxos/schema/annotation/FieldLookup");
var GeneratorAnnotationId = Symbol.for("@dxos/schema/annotation/Generator");
var GeneratorAnnotation = createAnnotationHelper(GeneratorAnnotationId);
var getSchemaDXN = (schema) => {
  assertArgument(Schema2.isSchema(schema), "invalid schema");
  const id = getTypeIdentifierAnnotation(schema);
  if (id) {
    return DXN.parse(id);
  }
  const objectAnnotation = getTypeAnnotation(schema);
  if (!objectAnnotation) {
    return void 0;
  }
  return DXN.fromTypenameAndVersion(objectAnnotation.typename, objectAnnotation.version);
};

// packages/core/echo/echo-schema/src/ast/types.ts
var FIELD_PATH_ANNOTATION = "path";
var FieldPath = (path) => PropertyMeta(FIELD_PATH_ANNOTATION, path);

// packages/core/echo/echo-schema/src/object/model.ts
import { invariant } from "@dxos/invariant";
import { DXN as DXN2, ObjectId } from "@dxos/keys";
import { assumeType } from "@dxos/util";
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/core/echo/echo-schema/src/object/model.ts";
var EntityKindId = Symbol("@dxos/echo/EntityKind");
var SelfDXNId = Symbol("@dxos/echo/Self");
var ATTR_SELF_DXN = "@self";
var TypeId = Symbol("@dxos/echo/Type");
var ATTR_TYPE = "@type";
var SchemaId = Symbol("@dxos/echo/Schema");
var DeletedId = Symbol("@dxos/echo/Deleted");
var ATTR_DELETED = "@deleted";
var MetaId = Symbol("@dxos/echo/Meta");
var ATTR_META = "@meta";
var RelationSourceDXNId = Symbol("@dxos/echo/RelationSourceDXN");
var ATTR_RELATION_SOURCE = "@relationSource";
var RelationTargetDXNId = Symbol("@dxos/echo/RelationTargetDXN");
var ATTR_RELATION_TARGET = "@relationTarget";
var RelationSourceId = Symbol("@dxos/echo/RelationSource");
var RelationTargetId = Symbol("@dxos/echo/RelationTarget");
function assertObjectModelShape(obj) {
  invariant(typeof obj === "object" && obj !== null, "Invalid object model: not an object", {
    F: __dxlog_file,
    L: 147,
    S: this,
    A: [
      "typeof obj === 'object' && obj !== null",
      "'Invalid object model: not an object'"
    ]
  });
  assumeType(obj);
  invariant(ObjectId.isValid(obj.id), "Invalid object model: invalid id", {
    F: __dxlog_file,
    L: 149,
    S: this,
    A: [
      "ObjectId.isValid(obj.id)",
      "'Invalid object model: invalid id'"
    ]
  });
  invariant(obj[TypeId] === void 0 || obj[TypeId] instanceof DXN2, "Invalid object model: invalid type", {
    F: __dxlog_file,
    L: 150,
    S: this,
    A: [
      "obj[TypeId] === undefined || obj[TypeId] instanceof DXN",
      "'Invalid object model: invalid type'"
    ]
  });
  invariant(obj[EntityKindId] === EntityKind.Object || obj[EntityKindId] === EntityKind.Relation, "Invalid object model: invalid entity kind", {
    F: __dxlog_file,
    L: 151,
    S: this,
    A: [
      "obj[EntityKindId] === EntityKind.Object || obj[EntityKindId] === EntityKind.Relation",
      "'Invalid object model: invalid entity kind'"
    ]
  });
  if (obj[EntityKindId] === EntityKind.Relation) {
    invariant(obj[RelationSourceDXNId] instanceof DXN2, "Invalid object model: invalid relation source", {
      F: __dxlog_file,
      L: 156,
      S: this,
      A: [
        "obj[RelationSourceDXNId] instanceof DXN",
        "'Invalid object model: invalid relation source'"
      ]
    });
    invariant(obj[RelationTargetDXNId] instanceof DXN2, "Invalid object model: invalid relation target", {
      F: __dxlog_file,
      L: 157,
      S: this,
      A: [
        "obj[RelationTargetDXNId] instanceof DXN",
        "'Invalid object model: invalid relation target'"
      ]
    });
    invariant(!(obj[RelationSourceId] instanceof DXN2), "Invalid object model: source pointer is a DXN", {
      F: __dxlog_file,
      L: 158,
      S: this,
      A: [
        "!(obj[RelationSourceId] instanceof DXN)",
        "'Invalid object model: source pointer is a DXN'"
      ]
    });
    invariant(!(obj[RelationTargetId] instanceof DXN2), "Invalid object model: target pointer is a DXN", {
      F: __dxlog_file,
      L: 159,
      S: this,
      A: [
        "!(obj[RelationTargetId] instanceof DXN)",
        "'Invalid object model: target pointer is a DXN'"
      ]
    });
  }
}

// packages/core/echo/echo-schema/src/object/accessors.ts
import { Schema as Schema3 } from "effect";
import { getField } from "@dxos/effect";
import { assertArgument as assertArgument2, invariant as invariant2 } from "@dxos/invariant";
import { DXN as DXN3, ObjectId as ObjectId2 } from "@dxos/keys";
import { assumeType as assumeType2 } from "@dxos/util";
var __dxlog_file2 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-schema/src/object/accessors.ts";
var getObjectDXN = (object) => {
  invariant2(!Schema3.isSchema(object), "schema not allowed in this function", {
    F: __dxlog_file2,
    L: 24,
    S: void 0,
    A: [
      "!Schema.isSchema(object)",
      "'schema not allowed in this function'"
    ]
  });
  assertArgument2(typeof object === "object" && object != null, "expected object");
  assumeType2(object);
  if (!ObjectId2.isValid(object.id)) {
    throw new TypeError("Object id is not valid.");
  }
  return DXN3.fromLocalObjectId(object.id);
};
var getSchema = (obj) => {
  if (obj) {
    return obj[SchemaId];
  }
};
var setSchema = (obj, schema) => {
  Object.defineProperty(obj, SchemaId, {
    value: schema,
    writable: false,
    enumerable: false,
    configurable: false
  });
};
var getLabelForObject = (obj) => {
  const schema = getSchema(obj);
  if (schema) {
    return getLabel(schema, obj);
  }
};
var getLabel = (schema, object) => {
  let annotation = schema.ast.annotations[LabelAnnotationId];
  if (!annotation) {
    return void 0;
  }
  if (!Array.isArray(annotation)) {
    annotation = [
      annotation
    ];
  }
  for (const accessor of annotation) {
    assertArgument2(typeof accessor === "string", "Label annotation must be a string or an array of strings");
    const value = getField(object, accessor);
    switch (typeof value) {
      case "string":
      case "number":
      case "boolean":
      case "bigint":
      case "symbol":
        return value.toString();
      case "undefined":
      case "object":
      case "function":
        continue;
    }
  }
  return void 0;
};

// packages/core/echo/echo-schema/src/object/typename.ts
import { invariant as invariant3 } from "@dxos/invariant";
import { DXN as DXN4 } from "@dxos/keys";
var __dxlog_file3 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-schema/src/object/typename.ts";
var getTypename = (obj) => {
  const schema = getSchema(obj);
  if (schema != null) {
    return getSchemaTypename(schema);
  } else {
    const type = getType(obj);
    return type?.asTypeDXN()?.type;
  }
};
var setTypename = (obj, typename) => {
  invariant3(typename instanceof DXN4, "Invalid type.", {
    F: __dxlog_file3,
    L: 34,
    S: void 0,
    A: [
      "typename instanceof DXN",
      "'Invalid type.'"
    ]
  });
  Object.defineProperty(obj, TypeId, {
    value: typename,
    writable: false,
    enumerable: false,
    configurable: false
  });
};
var getType = (obj) => {
  if (!obj) {
    return void 0;
  }
  const type = obj[TypeId];
  if (!type) {
    return void 0;
  }
  invariant3(type instanceof DXN4, "Invalid object.", {
    F: __dxlog_file3,
    L: 58,
    S: void 0,
    A: [
      "type instanceof DXN",
      "'Invalid object.'"
    ]
  });
  return type;
};

// packages/core/echo/echo-schema/src/object/common.ts
import { Schema as Schema4 } from "effect";
var makeTypedEntityClass = (typename, version, baseSchema) => {
  var _a2;
  return class {
    static {
      // Implement TypedObject properties.
      this.typename = typename;
    }
    static {
      this.version = version;
    }
    static {
      // Implement Schema.Schema properties.
      // TODO(burdon): Comment required.
      this[_a2] = schemaVariance;
    }
    static {
      this.ast = baseSchema.ast;
    }
    static {
      this.annotations = baseSchema.annotations.bind(baseSchema);
    }
    static {
      this.pipe = baseSchema.pipe.bind(baseSchema);
    }
    // TODO(burdon): Comment required.
    static [(_a2 = Schema4.TypeId, Symbol.hasInstance)](obj) {
      return obj != null && getTypename(obj) === typename;
    }
    // TODO(burdon): Throw APIError.
    constructor() {
      throw new Error("Use live(Typename, { ...fields }) to instantiate an object.");
    }
  };
};
var schemaVariance = {
  _A: (_) => _,
  _I: (_) => _,
  _R: (_) => _
};

// packages/core/echo/echo-schema/src/object/meta.ts
import { Schema as Schema5 } from "effect";
import { ForeignKey } from "@dxos/echo-protocol";
import { invariant as invariant4 } from "@dxos/invariant";
import { intersection } from "@dxos/util";
var __dxlog_file4 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-schema/src/object/meta.ts";
var ObjectMetaSchema = Schema5.Struct({
  keys: Schema5.mutable(Schema5.Array(ForeignKey))
});
var foreignKey = (source, id) => ({
  source,
  id
});
var foreignKeyEquals = (a, b) => a.source === b.source && a.id === b.id;
var getObjectMeta = (object) => {
  return getMeta(object);
};
var getMeta = (obj) => {
  const metadata = obj[MetaId];
  invariant4(metadata, "ObjectMeta not found.", {
    F: __dxlog_file4,
    L: 44,
    S: void 0,
    A: [
      "metadata",
      "'ObjectMeta not found.'"
    ]
  });
  return metadata;
};
var compareForeignKeys = (a, b) => intersection(getMeta(a).keys, getMeta(b).keys, foreignKeyEquals).length > 0;

// packages/core/echo/echo-schema/src/ref/ref.ts
import { Effect, Option as Option2, ParseResult, Schema as Schema6, SchemaAST as SchemaAST3 } from "effect";
import { Reference } from "@dxos/echo-protocol";
import { compositeRuntime } from "@dxos/echo-signals/runtime";
import { assertArgument as assertArgument3, invariant as invariant5 } from "@dxos/invariant";
import { DXN as DXN5, ObjectId as ObjectId3 } from "@dxos/keys";
var __dxlog_file5 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-schema/src/ref/ref.ts";
var JSON_SCHEMA_ECHO_REF_ID = "/schemas/echo/ref";
var getSchemaReference = (property) => {
  const { $id, reference: { schema: { $ref } = {} } = {} } = property;
  if ($id === JSON_SCHEMA_ECHO_REF_ID && $ref) {
    return {
      typename: DXN5.parse($ref).typename
    };
  }
};
var createSchemaReference = (typename) => {
  return {
    $id: JSON_SCHEMA_ECHO_REF_ID,
    reference: {
      schema: {
        $ref: DXN5.fromTypename(typename).toString()
      }
    }
  };
};
var RefTypeId = Symbol("@dxos/echo-schema/Ref");
var Ref = (schema) => {
  assertArgument3(Schema6.isSchema(schema), "Must call with an instance of effect-schema");
  const annotation = getTypeAnnotation(schema);
  if (annotation == null) {
    throw new Error("Reference target must be an ECHO schema.");
  }
  return createEchoReferenceSchema(getTypeIdentifierAnnotation(schema), annotation.typename, annotation.version, getSchemaExpectedName(schema.ast));
};
Ref.isRef = (obj) => {
  return obj && typeof obj === "object" && RefTypeId in obj;
};
Ref.hasObjectId = (id) => (ref) => ref.dxn.isLocalObjectId() && ref.dxn.parts[1] === id;
Ref.isRefSchema = (schema) => {
  return Ref.isRefSchemaAST(schema.ast);
};
Ref.isRefSchemaAST = (ast) => {
  return SchemaAST3.getAnnotation(ast, ReferenceAnnotationId).pipe(Option2.isSome);
};
Ref.make = (obj) => {
  if (typeof obj !== "object" || obj === null) {
    throw new TypeError("Expected: ECHO object.");
  }
  const id = obj.id;
  invariant5(ObjectId3.isValid(id), "Invalid object ID", {
    F: __dxlog_file5,
    L: 188,
    S: void 0,
    A: [
      "ObjectId.isValid(id)",
      "'Invalid object ID'"
    ]
  });
  const dxn = Reference.localObjectReference(id).toDXN();
  return new RefImpl(dxn, obj);
};
Ref.fromDXN = (dxn) => {
  return new RefImpl(dxn);
};
var createEchoReferenceSchema = (echoId, typename, version, schemaName) => {
  if (!echoId && !typename) {
    throw new TypeError("Either echoId or typename must be provided.");
  }
  const referenceInfo = {
    schema: {
      // TODO(dmaretskyi): Include version?
      $ref: echoId ?? DXN5.fromTypename(typename).toString()
    },
    schemaVersion: version
  };
  const refSchema = Schema6.declare([], {
    encode: () => {
      return (value) => {
        return Effect.succeed({
          "/": value.dxn.toString()
        });
      };
    },
    decode: () => {
      return (value) => {
        if (Ref.isRef(value)) {
          return Effect.succeed(value);
        }
        if (typeof value !== "object" || value == null || typeof value["/"] !== "string") {
          return Effect.fail(new ParseResult.Unexpected(value, "reference"));
        }
        return Effect.succeed(Ref.fromDXN(DXN5.parse(value["/"])));
      };
    }
  }, {
    jsonSchema: {
      $id: JSON_SCHEMA_ECHO_REF_ID,
      reference: referenceInfo
    },
    [ReferenceAnnotationId]: {
      typename: typename ?? "",
      version
    }
  });
  return refSchema;
};
var getSchemaExpectedName = (ast) => {
  return SchemaAST3.getIdentifierAnnotation(ast).pipe(Option2.orElse(() => SchemaAST3.getTitleAnnotation(ast)), Option2.orElse(() => SchemaAST3.getDescriptionAnnotation(ast)), Option2.getOrElse(() => void 0));
};
var _a;
_a = RefTypeId;
var RefImpl = class {
  constructor(dxn, target) {
    this.#resolver = void 0;
    this.#signal = compositeRuntime.createSignal();
    /**
    * Target is set when the reference is created from a specific object.
    * In this case, the target might not be in the database.
    */
    this.#target = void 0;
    /**
    * Callback to issue a reactive notification when object is resolved.
    */
    this.#resolverCallback = () => {
      this.#signal.notifyWrite();
    };
    this[_a] = refVariance;
    this.#dxn = dxn;
    this.#target = target;
  }
  #dxn;
  #resolver;
  #signal;
  #target;
  #resolverCallback;
  /**
  * @inheritdoc
  */
  get dxn() {
    return this.#dxn;
  }
  /**
  * @inheritdoc
  */
  get target() {
    this.#signal.notifyRead();
    if (this.#target) {
      return this.#target;
    }
    invariant5(this.#resolver, "Resolver is not set", {
      F: __dxlog_file5,
      L: 334,
      S: this,
      A: [
        "this.#resolver",
        "'Resolver is not set'"
      ]
    });
    return this.#resolver.resolveSync(this.#dxn, true, this.#resolverCallback);
  }
  /**
  * @inheritdoc
  */
  async load() {
    invariant5(this.#resolver, "Resolver is not set", {
      F: __dxlog_file5,
      L: 342,
      S: this,
      A: [
        "this.#resolver",
        "'Resolver is not set'"
      ]
    });
    const obj = await this.#resolver.resolve(this.#dxn);
    if (obj == null) {
      throw new Error("Object not found");
    }
    return obj;
  }
  /**
  * @inheritdoc
  */
  async tryLoad() {
    invariant5(this.#resolver, "Resolver is not set", {
      F: __dxlog_file5,
      L: 354,
      S: this,
      A: [
        "this.#resolver",
        "'Resolver is not set'"
      ]
    });
    return await this.#resolver.resolve(this.#dxn);
  }
  /**
  * Do not inline the target object in the reference.
  * Makes .target unavailable unless the reference is connected to a database context.
  */
  noInline() {
    this.#target = void 0;
    return this;
  }
  encode() {
    return {
      "/": this.#dxn.toString(),
      ...this.#target ? {
        target: this.#target
      } : {}
    };
  }
  /**
  * Serializes the reference to a JSON object.
  * The serialization format is compatible with the IPLD-style encoded references.
  * When a reference has a saved target (i.e. the target or object holding the reference is not in the database),
  * the target is included in the serialized object.
  */
  toJSON() {
    return this.encode();
  }
  toString() {
    if (this.#target) {
      return `Ref(${this.#target.toString()})`;
    }
    return `Ref(${this.#dxn.toString()})`;
  }
  /**
  * Internal method to set the resolver.
  * @internal
  */
  _setResolver(resolver) {
    this.#resolver = resolver;
  }
  /**
  * Internal method to get the saved target.
  * Not the same as `target` which is resolved from the resolver.
  * @internal
  */
  _getSavedTarget() {
    return this.#target;
  }
};
var setRefResolver = (ref, resolver) => {
  invariant5(ref instanceof RefImpl, "Ref is not an instance of RefImpl", {
    F: __dxlog_file5,
    L: 416,
    S: void 0,
    A: [
      "ref instanceof RefImpl",
      "'Ref is not an instance of RefImpl'"
    ]
  });
  ref._setResolver(resolver);
};
var getRefSavedTarget = (ref) => {
  invariant5(ref instanceof RefImpl, "Ref is not an instance of RefImpl", {
    F: __dxlog_file5,
    L: 424,
    S: void 0,
    A: [
      "ref instanceof RefImpl",
      "'Ref is not an instance of RefImpl'"
    ]
  });
  return ref._getSavedTarget();
};
var refVariance = {
  _T: null
};
var refFromEncodedReference = (encodedReference, resolver) => {
  const dxn = DXN5.parse(encodedReference["/"]);
  const ref = new RefImpl(dxn);
  if (resolver) {
    setRefResolver(ref, resolver);
  }
  return ref;
};
var StaticRefResolver = class {
  constructor() {
    this.objects = /* @__PURE__ */ new Map();
    this.schemas = /* @__PURE__ */ new Map();
  }
  addObject(obj) {
    this.objects.set(obj.id, obj);
    return this;
  }
  addSchema(schema) {
    const dxn = getSchemaDXN(schema);
    invariant5(dxn, "Schema has no DXN", {
      F: __dxlog_file5,
      L: 456,
      S: this,
      A: [
        "dxn",
        "'Schema has no DXN'"
      ]
    });
    this.schemas.set(dxn.toString(), schema);
    return this;
  }
  resolveSync(dxn, _load, _onLoad) {
    const id = dxn?.asEchoDXN()?.echoId;
    if (id == null) {
      return void 0;
    }
    return this.objects.get(id);
  }
  async resolve(dxn) {
    const id = dxn?.asEchoDXN()?.echoId;
    if (id == null) {
      return void 0;
    }
    return this.objects.get(id);
  }
  async resolveSchema(dxn) {
    return this.schemas.get(dxn.toString());
  }
};

// packages/core/echo/echo-schema/src/ref/ref-array.ts
import { isNonNullable } from "@dxos/util";
var RefArray = Object.freeze({
  /**
  * @returns all resolved targets.
  */
  targets: (refs) => {
    return refs.map((ref) => ref.target).filter(isNonNullable);
  },
  /**
  * Load all referenced objects.
  */
  loadAll: (refs) => {
    return Promise.all(refs.map((ref) => ref.load()));
  },
  /**
  * Removes the ref with the given id.
  */
  removeById: (refs, id) => {
    const index = refs.findIndex(Ref.hasObjectId(id));
    if (index >= 0) {
      refs.splice(index, 1);
    }
  }
});

// packages/core/echo/echo-schema/src/utils.ts
var defineHiddenProperty = (object, key, value) => {
  Object.defineProperty(object, key, {
    enumerable: false,
    configurable: true,
    value
  });
};

// packages/core/echo/echo-schema/src/object/json-serializer.ts
import { Schema as Schema7 } from "effect";
import { raise } from "@dxos/debug";
import { isEncodedReference } from "@dxos/echo-protocol";
import { assertArgument as assertArgument4, invariant as invariant6 } from "@dxos/invariant";
import { DXN as DXN6, ObjectId as ObjectId4 } from "@dxos/keys";
import { assumeType as assumeType3, deepMapValues, visitValues } from "@dxos/util";
var __dxlog_file6 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-schema/src/object/json-serializer.ts";
var objectToJSON = (obj) => {
  const typename = getType(obj)?.toString();
  invariant6(typename && typeof typename === "string", void 0, {
    F: __dxlog_file6,
    L: 48,
    S: void 0,
    A: [
      "typename && typeof typename === 'string'",
      ""
    ]
  });
  return typedJsonSerializer.call(obj);
};
var objectFromJSON = async (jsonData, { refResolver } = {}) => {
  assumeType3(jsonData);
  assertArgument4(typeof jsonData === "object" && jsonData !== null, "expect object");
  assertArgument4(typeof jsonData[ATTR_TYPE] === "string", "expected object to have a type");
  assertArgument4(typeof jsonData.id === "string", "expected object to have an id");
  const type = DXN6.parse(jsonData[ATTR_TYPE]);
  const schema = await refResolver?.resolveSchema(type);
  invariant6(schema === void 0 || Schema7.isSchema(schema), void 0, {
    F: __dxlog_file6,
    L: 70,
    S: void 0,
    A: [
      "schema === undefined || Schema.isSchema(schema)",
      ""
    ]
  });
  let obj;
  if (schema != null) {
    obj = await schema.pipe(Schema7.decodeUnknownPromise)(jsonData);
    if (refResolver) {
      setRefResolverOnData(obj, refResolver);
    }
  } else {
    obj = decodeGeneric(jsonData, {
      refResolver
    });
  }
  invariant6(ObjectId4.isValid(obj.id), "Invalid object id", {
    F: __dxlog_file6,
    L: 82,
    S: void 0,
    A: [
      "ObjectId.isValid(obj.id)",
      "'Invalid object id'"
    ]
  });
  setTypename(obj, type);
  if (schema) {
    setSchema(obj, schema);
  }
  const isRelation = typeof jsonData[ATTR_RELATION_SOURCE] === "string" || typeof jsonData[ATTR_RELATION_TARGET] === "string";
  if (isRelation) {
    const sourceDxn = DXN6.parse(jsonData[ATTR_RELATION_SOURCE] ?? raise(new TypeError("Missing relation source")));
    const targetDxn = DXN6.parse(jsonData[ATTR_RELATION_TARGET] ?? raise(new TypeError("Missing relation target")));
    const source = await refResolver?.resolve(sourceDxn);
    const target = await refResolver?.resolve(targetDxn);
    defineHiddenProperty(obj, EntityKindId, EntityKind.Relation);
    defineHiddenProperty(obj, RelationSourceDXNId, sourceDxn);
    defineHiddenProperty(obj, RelationTargetDXNId, targetDxn);
    defineHiddenProperty(obj, RelationSourceId, source);
    defineHiddenProperty(obj, RelationTargetId, target);
  } else {
    defineHiddenProperty(obj, EntityKindId, EntityKind.Object);
  }
  if (typeof jsonData[ATTR_META] === "object") {
    const meta = await ObjectMetaSchema.pipe(Schema7.decodeUnknownPromise)(jsonData[ATTR_META]);
    invariant6(Array.isArray(meta.keys), void 0, {
      F: __dxlog_file6,
      L: 112,
      S: void 0,
      A: [
        "Array.isArray(meta.keys)",
        ""
      ]
    });
    defineHiddenProperty(obj, MetaId, meta);
  }
  assertObjectModelShape(obj);
  invariant6(obj[ATTR_TYPE] === void 0, "Invalid object model", {
    F: __dxlog_file6,
    L: 118,
    S: void 0,
    A: [
      "(obj as any)[ATTR_TYPE] === undefined",
      "'Invalid object model'"
    ]
  });
  invariant6(obj[ATTR_SELF_DXN] === void 0, "Invalid object model", {
    F: __dxlog_file6,
    L: 119,
    S: void 0,
    A: [
      "(obj as any)[ATTR_SELF_DXN] === undefined",
      "'Invalid object model'"
    ]
  });
  invariant6(obj[ATTR_DELETED] === void 0, "Invalid object model", {
    F: __dxlog_file6,
    L: 120,
    S: void 0,
    A: [
      "(obj as any)[ATTR_DELETED] === undefined",
      "'Invalid object model'"
    ]
  });
  invariant6(obj[ATTR_RELATION_SOURCE] === void 0, "Invalid object model", {
    F: __dxlog_file6,
    L: 121,
    S: void 0,
    A: [
      "(obj as any)[ATTR_RELATION_SOURCE] === undefined",
      "'Invalid object model'"
    ]
  });
  invariant6(obj[ATTR_RELATION_TARGET] === void 0, "Invalid object model", {
    F: __dxlog_file6,
    L: 122,
    S: void 0,
    A: [
      "(obj as any)[ATTR_RELATION_TARGET] === undefined",
      "'Invalid object model'"
    ]
  });
  invariant6(obj[ATTR_META] === void 0, "Invalid object model", {
    F: __dxlog_file6,
    L: 123,
    S: void 0,
    A: [
      "(obj as any)[ATTR_META] === undefined",
      "'Invalid object model'"
    ]
  });
  return obj;
};
var decodeGeneric = (jsonData, options) => {
  const { [ATTR_TYPE]: _type, [ATTR_META]: _meta, [ATTR_DELETED]: _deleted, [ATTR_RELATION_SOURCE]: _relationSource, [ATTR_RELATION_TARGET]: _relationTarget, [ATTR_SELF_DXN]: _selfDxn, ...props } = jsonData;
  return deepMapValues(props, (value, recurse) => {
    if (isEncodedReference(value)) {
      return refFromEncodedReference(value, options.refResolver);
    }
    return recurse(value);
  });
};
var setRefResolverOnData = (obj, refResolver) => {
  const go = (value) => {
    if (Ref.isRef(value)) {
      setRefResolver(value, refResolver);
    } else {
      visitValues(value, go);
    }
  };
  go(obj);
};
var attachTypedJsonSerializer = (obj) => {
  const descriptor = Object.getOwnPropertyDescriptor(obj, "toJSON");
  if (descriptor) {
    return;
  }
  Object.defineProperty(obj, "toJSON", {
    value: typedJsonSerializer,
    writable: false,
    enumerable: false,
    configurable: false
  });
};
var typedJsonSerializer = function() {
  const { id, [TypeId]: typename, [MetaId]: meta, ...rest } = this;
  const result = {
    id,
    [ATTR_TYPE]: typename.toString()
  };
  if (this[RelationSourceDXNId]) {
    const sourceDXN = this[RelationSourceDXNId];
    invariant6(sourceDXN instanceof DXN6, void 0, {
      F: __dxlog_file6,
      L: 185,
      S: this,
      A: [
        "sourceDXN instanceof DXN",
        ""
      ]
    });
    result[ATTR_RELATION_SOURCE] = sourceDXN.toString();
  }
  if (this[RelationTargetDXNId]) {
    const targetDXN = this[RelationTargetDXNId];
    invariant6(targetDXN instanceof DXN6, void 0, {
      F: __dxlog_file6,
      L: 190,
      S: this,
      A: [
        "targetDXN instanceof DXN",
        ""
      ]
    });
    result[ATTR_RELATION_TARGET] = targetDXN.toString();
  }
  if (meta) {
    result[ATTR_META] = serializeData(meta);
  }
  Object.assign(result, serializeData(rest));
  return result;
};
var serializeData = (data) => {
  return deepMapValues(data, (value, recurse) => {
    if (Ref.isRef(value)) {
      return value.noInline().encode();
    }
    return recurse(value);
  });
};

// packages/core/echo/echo-schema/src/object/create.ts
import { raise as raise2 } from "@dxos/debug";
import { assertArgument as assertArgument5, failedInvariant } from "@dxos/invariant";
import { ObjectId as ObjectId5 } from "@dxos/keys";

// packages/core/echo/echo-schema/src/object/inspect.ts
import { inspectCustom } from "@dxos/debug";
var attachedTypedObjectInspector = (obj) => {
  const descriptor = Object.getOwnPropertyDescriptor(obj, inspectCustom);
  if (descriptor) {
    return;
  }
  Object.defineProperty(obj, inspectCustom, {
    value: typedObjectInspectFunction,
    writable: false,
    enumerable: false,
    configurable: true
  });
};
var typedObjectInspectFunction = function(depth, options, inspect) {
  const { id, ...props } = this;
  return inspect({
    id,
    [ATTR_TYPE]: getType(this),
    ...props,
    [ATTR_META]: this[MetaId]
  }, options);
};

// packages/core/echo/echo-schema/src/object/create.ts
var create = (schema, data) => {
  const annotation = getTypeAnnotation(schema);
  if (!annotation) {
    throw new Error("Schema is not an object schema");
  }
  assertArgument5(!("@type" in data), "@type is not allowed");
  assertArgument5(!(RelationSourceDXNId in data), "Relation source DXN is not allowed in the constructor");
  assertArgument5(!(RelationTargetDXNId in data), "Relation target DXN is not allowed in the constructor");
  assertArgument5(RelationSourceId in data === RelationTargetId in data, "Relation source and target must be provided together");
  const obj = {
    ...data,
    id: data.id ?? ObjectId5.random()
  };
  const kind = RelationSourceId in data ? EntityKind.Relation : EntityKind.Object;
  defineHiddenProperty(obj, EntityKindId, kind);
  setTypename(obj, getSchemaDXN(schema) ?? failedInvariant("Missing schema DXN"));
  setSchema(obj, schema);
  attachTypedJsonSerializer(obj);
  attachedTypedObjectInspector(obj);
  defineHiddenProperty(obj, MetaId, {
    keys: []
  });
  if (kind === EntityKind.Relation) {
    const sourceDXN = getObjectDXN(data[RelationSourceId]) ?? raise2(new Error("Unresolved relation source"));
    const targetDXN = getObjectDXN(data[RelationTargetId]) ?? raise2(new Error("Unresolved relation target"));
    defineHiddenProperty(obj, RelationSourceDXNId, sourceDXN);
    defineHiddenProperty(obj, RelationTargetDXNId, targetDXN);
  }
  assertObjectModelShape(obj);
  return obj;
};

// packages/core/echo/echo-schema/src/object/entity.ts
import { Schema as Schema8, SchemaAST as SchemaAST4 } from "effect";
import { raise as raise3 } from "@dxos/debug";
import { invariant as invariant7 } from "@dxos/invariant";
import { DXN as DXN7 } from "@dxos/keys";
var __dxlog_file7 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-schema/src/object/entity.ts";
var EchoObject = ({ typename, version }) => {
  return (self) => {
    invariant7(typeof TypeAnnotationId === "symbol", "Sanity.", {
      F: __dxlog_file7,
      L: 33,
      S: void 0,
      A: [
        "typeof TypeAnnotationId === 'symbol'",
        "'Sanity.'"
      ]
    });
    invariant7(SchemaAST4.isTypeLiteral(self.ast), "Schema must be a TypeLiteral.", {
      F: __dxlog_file7,
      L: 34,
      S: void 0,
      A: [
        "SchemaAST.isTypeLiteral(self.ast)",
        "'Schema must be a TypeLiteral.'"
      ]
    });
    const schemaWithId = Schema8.extend(Schema8.mutable(self), Schema8.Struct({
      id: Schema8.String
    }));
    const ast = SchemaAST4.annotations(schemaWithId.ast, {
      // TODO(dmaretskyi): `extend` kills the annotations.
      ...self.ast.annotations,
      [TypeAnnotationId]: {
        kind: EntityKind.Object,
        typename,
        version
      }
    });
    return makeEchoObjectSchema(
      /* self.fields, */
      ast,
      typename,
      version
    );
  };
};
var getDXNForRelationSchemaRef = (schema) => {
  const identifier = getTypeIdentifierAnnotation(schema);
  if (identifier) {
    return identifier;
  }
  const typename = getSchemaTypename(schema);
  if (!typename) {
    throw new Error("Schema must have a typename");
  }
  return DXN7.fromTypename(typename).toString();
};
var EchoRelation = (options) => {
  const sourceDXN = getDXNForRelationSchemaRef(options.source);
  const targetDXN = getDXNForRelationSchemaRef(options.target);
  if (getEntityKind(options.source) !== EntityKind.Object) {
    raise3(new Error("Source schema must be an echo object schema."));
  }
  if (getEntityKind(options.target) !== EntityKind.Object) {
    raise3(new Error("Target schema must be an echo object schema."));
  }
  return (self) => {
    invariant7(SchemaAST4.isTypeLiteral(self.ast), "Schema must be a TypeLiteral.", {
      F: __dxlog_file7,
      L: 89,
      S: void 0,
      A: [
        "SchemaAST.isTypeLiteral(self.ast)",
        "'Schema must be a TypeLiteral.'"
      ]
    });
    const schemaWithId = Schema8.extend(Schema8.mutable(self), Schema8.Struct({
      id: Schema8.String
    }));
    const ast = SchemaAST4.annotations(schemaWithId.ast, {
      // TODO(dmaretskyi): `extend` kills the annotations.
      ...self.ast.annotations,
      [TypeAnnotationId]: {
        kind: EntityKind.Relation,
        typename: options.typename,
        version: options.version,
        sourceSchema: sourceDXN,
        targetSchema: targetDXN
      }
    });
    return makeEchoObjectSchema(
      /* self.fields, */
      ast,
      options.typename,
      options.version
    );
  };
};
var makeEchoObjectSchema = (ast, typename, version) => {
  return class EchoObjectSchemaClass extends Schema8.make(ast) {
    static {
      this.typename = typename;
    }
    static {
      this.version = version;
    }
    static annotations(annotations) {
      const schema = Schema8.make(ast).annotations(annotations);
      return makeEchoObjectSchema(
        /* fields, */
        schema.ast,
        typename,
        version
      );
    }
    // static make(
    //   props: RequiredKeys<Schema.TypeLiteral.Constructor<Fields, []>> extends never
    //     ? void | Simplify<Schema.TypeLiteral.Constructor<Fields, []>>
    //     : Simplify<Schema.TypeLiteral.Constructor<Fields, []>>,
    //   options?: MakeOptions,
    // ): Simplify<Schema.TypeLiteral.Type<Fields, []>> {
    //   const propsWithDefaults: any = _lazilyMergeDefaults(fields, { ...(props as any) });
    //   return _getDisableValidationMakeOption(options)
    //     ? propsWithDefaults
    //     : ParseResult.validateSync(this)(propsWithDefaults);
    // }
    static instanceOf(value) {
      return Schema8.is(this)(value);
    }
  };
};

// packages/core/echo/echo-schema/src/object/expando.ts
import { Schema as Schema9 } from "effect";
var EXPANDO_TYPENAME = "dxos.org/type/Expando";
var ExpandoSchema = Schema9.Struct({}, {
  key: Schema9.String,
  value: Schema9.Any
}).pipe(EchoObject({
  typename: EXPANDO_TYPENAME,
  version: "0.1.0"
}));
var Expando = ExpandoSchema;

// packages/core/echo/echo-schema/src/object/ids.ts
import { DXN as DXN8, ObjectId as ObjectId6, QueueSubspaceTags, SpaceId } from "@dxos/keys";
var createQueueDXN = (spaceId = SpaceId.random(), queueId = ObjectId6.random()) => new DXN8(DXN8.kind.QUEUE, [
  QueueSubspaceTags.DATA,
  spaceId,
  queueId
]);

// packages/core/echo/echo-schema/src/object/typed-object.ts
import { Schema as Schema10 } from "effect";
import { invariant as invariant8 } from "@dxos/invariant";
var __dxlog_file8 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-schema/src/object/typed-object.ts";
var TypedObject = ({ typename: _typename, version: _version, disableValidation }) => {
  const typename = Typename.make(_typename, {
    disableValidation
  });
  const version = Version.make(_version, {
    disableValidation
  });
  return (fields, options) => {
    const schema = options?.record ? Schema10.Struct(fields, {
      key: Schema10.String,
      value: Schema10.Any
    }) : Schema10.Struct(fields);
    const typeSchema = Schema10.extend(Schema10.mutable(options?.partial ? Schema10.partial(schema) : schema), Schema10.Struct({
      id: Schema10.String
    }));
    invariant8(typeof EntityKind.Object === "string", void 0, {
      F: __dxlog_file8,
      L: 64,
      S: void 0,
      A: [
        "typeof EntityKind.Object === 'string'",
        ""
      ]
    });
    const annotatedSchema = typeSchema.annotations({
      [TypeAnnotationId]: {
        kind: EntityKind.Object,
        typename,
        version
      }
    });
    return class TypedObject extends makeTypedEntityClass(typename, version, annotatedSchema) {
    };
  };
};

// packages/core/echo/echo-schema/src/object/typed-relation.ts
import { Schema as Schema11 } from "effect";
import { invariant as invariant9 } from "@dxos/invariant";
var __dxlog_file9 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-schema/src/object/typed-relation.ts";
var TypedRelation = ({ typename: _typename, version: _version, disableValidation }) => {
  const typename = Typename.make(_typename, {
    disableValidation
  });
  const version = Version.make(_version, {
    disableValidation
  });
  return (fields, options) => {
    const schema = options?.record ? Schema11.Struct(fields, {
      key: Schema11.String,
      value: Schema11.Any
    }) : Schema11.Struct(fields);
    const typeSchema = Schema11.extend(Schema11.mutable(options?.partial ? Schema11.partial(schema) : schema), Schema11.Struct({
      id: Schema11.String
    }));
    invariant9(typeof EntityKind.Relation === "string", void 0, {
      F: __dxlog_file9,
      L: 68,
      S: void 0,
      A: [
        "typeof EntityKind.Relation === 'string'",
        ""
      ]
    });
    const annotatedSchema = typeSchema.annotations({
      [TypeAnnotationId]: {
        kind: EntityKind.Relation,
        typename,
        version
      }
    });
    return class TypedRelation extends makeTypedEntityClass(typename, version, annotatedSchema) {
    };
  };
};

// packages/core/echo/echo-schema/src/object/deleted.ts
var isDeleted = (obj) => {
  if (obj[DeletedId] === void 0) {
    throw new Error("Object does not support deletion marker");
  }
  return obj[DeletedId] ?? false;
};

// packages/core/echo/echo-schema/src/object/schema-validator.ts
import { SchemaAST as SchemaAST5, Schema as Schema12 } from "effect";
import { invariant as invariant10 } from "@dxos/invariant";
var __dxlog_file10 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-schema/src/object/schema-validator.ts";
var SchemaValidator = class {
  /**
  * Recursively check that schema specifies constructions we can handle.
  * Validates there are no ambiguous discriminated union types.
  */
  static validateSchema(schema) {
    const visitAll = (nodes) => nodes.forEach((node) => this.validateSchema(Schema12.make(node)));
    if (SchemaAST5.isUnion(schema.ast)) {
      const typeAstList = schema.ast.types.filter((type) => SchemaAST5.isTypeLiteral(type));
      if (typeAstList.length > 1) {
        getTypeDiscriminators(typeAstList);
      }
      visitAll(typeAstList);
    } else if (SchemaAST5.isTupleType(schema.ast)) {
      const positionalTypes = schema.ast.elements.map((t) => t.type);
      const allTypes = positionalTypes.concat(schema.ast.rest.map((t) => t.type));
      visitAll(allTypes);
    } else if (SchemaAST5.isTypeLiteral(schema.ast)) {
      visitAll(SchemaAST5.getPropertySignatures(schema.ast).map((p) => p.type));
    }
  }
  static hasTypeAnnotation(rootObjectSchema, property, annotation) {
    try {
      let type = this.getPropertySchema(rootObjectSchema, [
        property
      ]);
      if (SchemaAST5.isTupleType(type.ast)) {
        type = this.getPropertySchema(rootObjectSchema, [
          property,
          "0"
        ]);
      }
      return type.ast.annotations[annotation] != null;
    } catch (err) {
      return false;
    }
  }
  static getPropertySchema(rootObjectSchema, propertyPath, getProperty = () => null) {
    let schema = rootObjectSchema;
    for (let i = 0; i < propertyPath.length; i++) {
      const propertyName = propertyPath[i];
      const tupleAst = unwrapArray(schema.ast);
      if (tupleAst != null) {
        schema = getArrayElementSchema(tupleAst, propertyName);
      } else {
        const propertyType = getPropertyType(schema.ast, propertyName.toString(), (propertyName2) => getProperty([
          ...propertyPath.slice(0, i),
          propertyName2
        ]));
        if (propertyType == null) {
          throw new TypeError(`unknown property: ${String(propertyName)} on object. Path: ${propertyPath}`);
        }
        schema = Schema12.make(propertyType).annotations(propertyType.annotations);
      }
    }
    return schema;
  }
  static getTargetPropertySchema(target, prop) {
    const schema = target[SchemaId];
    invariant10(schema, "target has no schema", {
      F: __dxlog_file10,
      L: 81,
      S: this,
      A: [
        "schema",
        "'target has no schema'"
      ]
    });
    const arrayAst = unwrapArray(schema.ast);
    if (arrayAst != null) {
      return getArrayElementSchema(arrayAst, prop);
    }
    const propertyType = getPropertyType(schema.ast, prop.toString(), (prop2) => target[prop2]);
    if (propertyType == null) {
      return Schema12.Any;
    }
    invariant10(propertyType, `invalid property: ${prop.toString()}`, {
      F: __dxlog_file10,
      L: 92,
      S: this,
      A: [
        "propertyType",
        "`invalid property: ${prop.toString()}`"
      ]
    });
    return Schema12.make(propertyType);
  }
};
var getArrayElementSchema = (tupleAst, property) => {
  const elementIndex = typeof property === "string" ? parseInt(property, 10) : Number.NaN;
  if (Number.isNaN(elementIndex)) {
    invariant10(property === "length", `invalid array property: ${String(property)}`, {
      F: __dxlog_file10,
      L: 108,
      S: void 0,
      A: [
        "property === 'length'",
        "`invalid array property: ${String(property)}`"
      ]
    });
    return Schema12.Number;
  }
  if (elementIndex < tupleAst.elements.length) {
    const elementType = tupleAst.elements[elementIndex].type;
    return Schema12.make(elementType).annotations(elementType.annotations);
  }
  const restType = tupleAst.rest;
  return Schema12.make(restType[0].type).annotations(restType[0].annotations);
};
var flattenUnion = (typeAst) => SchemaAST5.isUnion(typeAst) ? typeAst.types.flatMap(flattenUnion) : [
  typeAst
];
var getProperties = (typeAst, getTargetPropertyFn) => {
  const astCandidates = flattenUnion(typeAst);
  const typeAstList = astCandidates.filter((type) => SchemaAST5.isTypeLiteral(type));
  if (typeAstList.length === 0) {
    return [];
  }
  if (typeAstList.length === 1) {
    return SchemaAST5.getPropertySignatures(typeAstList[0]);
  }
  const typeDiscriminators = getTypeDiscriminators(typeAstList);
  const targetPropertyValue = getTargetPropertyFn(String(typeDiscriminators[0].name));
  const typeIndex = typeDiscriminators.findIndex((p) => targetPropertyValue === p.type.literal);
  invariant10(typeIndex !== -1, "discriminator field not set on target", {
    F: __dxlog_file10,
    L: 139,
    S: void 0,
    A: [
      "typeIndex !== -1",
      "'discriminator field not set on target'"
    ]
  });
  return SchemaAST5.getPropertySignatures(typeAstList[typeIndex]);
};
var getPropertyType = (ast, propertyName, getTargetPropertyFn) => {
  const anyOrObject = unwrapAst(ast, (candidate) => SchemaAST5.isAnyKeyword(candidate) || SchemaAST5.isObjectKeyword(candidate));
  if (anyOrObject != null) {
    return ast;
  }
  const typeOrDiscriminatedUnion = unwrapAst(ast, (t) => {
    return SchemaAST5.isTypeLiteral(t) || SchemaAST5.isUnion(t) && t.types.some((t2) => SchemaAST5.isTypeLiteral(t2));
  });
  if (typeOrDiscriminatedUnion == null) {
    return null;
  }
  const targetProperty = getProperties(typeOrDiscriminatedUnion, getTargetPropertyFn).find((p) => p.name === propertyName);
  if (targetProperty != null) {
    return unwrapAst(targetProperty.type);
  }
  const indexSignatureType = unwrapAst(ast, SchemaAST5.isTypeLiteral);
  if (indexSignatureType && SchemaAST5.isTypeLiteral(indexSignatureType) && indexSignatureType.indexSignatures.length > 0) {
    return unwrapAst(indexSignatureType.indexSignatures[0].type);
  }
  return null;
};
var getTypeDiscriminators = (typeAstList) => {
  const discriminatorPropCandidates = typeAstList.flatMap(SchemaAST5.getPropertySignatures).filter((p) => SchemaAST5.isLiteral(p.type));
  const propertyName = discriminatorPropCandidates[0].name;
  const isValidDiscriminator = discriminatorPropCandidates.every((p) => p.name === propertyName && !p.isOptional);
  const everyTypeHasDiscriminator = discriminatorPropCandidates.length === typeAstList.length;
  const isDiscriminatedUnion = isValidDiscriminator && everyTypeHasDiscriminator;
  invariant10(isDiscriminatedUnion, "type ambiguity: every type in a union must have a single unique-literal field", {
    F: __dxlog_file10,
    L: 190,
    S: void 0,
    A: [
      "isDiscriminatedUnion",
      "'type ambiguity: every type in a union must have a single unique-literal field'"
    ]
  });
  return discriminatorPropCandidates;
};
var unwrapAst = (rootAst, predicate) => {
  let ast = rootAst;
  while (ast != null) {
    if (predicate?.(ast)) {
      return ast;
    }
    if (SchemaAST5.isUnion(ast)) {
      const next = ast.types.find((t) => predicate != null && predicate(t) || SchemaAST5.isSuspend(t));
      if (next != null) {
        ast = next;
        continue;
      }
    }
    if (SchemaAST5.isSuspend(ast)) {
      ast = ast.f();
    } else {
      return predicate == null ? ast : null;
    }
  }
  return null;
};
var unwrapArray = (ast) => unwrapAst(ast, SchemaAST5.isTupleType);
var checkIdNotPresentOnSchema = (schema) => {
  invariant10(SchemaAST5.isTypeLiteral(schema.ast), void 0, {
    F: __dxlog_file10,
    L: 233,
    S: void 0,
    A: [
      "SchemaAST.isTypeLiteral(schema.ast)",
      ""
    ]
  });
  const idProperty = SchemaAST5.getPropertySignatures(schema.ast).find((prop) => prop.name === "id");
  if (idProperty != null) {
    throw new Error('"id" property name is reserved');
  }
};

export {
  createAnnotationHelper,
  EntityKind,
  EntityKindSchema,
  TypeIdentifierAnnotationId,
  getTypeIdentifierAnnotation,
  TypeAnnotationId,
  Typename,
  Version,
  TypeAnnotation,
  getTypeAnnotation,
  getEntityKind,
  getSchemaTypename,
  getSchemaVersion,
  PropertyMetaAnnotationId,
  PropertyMeta,
  getPropertyMetaAnnotation,
  ReferenceAnnotationId,
  getReferenceAnnotation,
  SchemaMetaSymbol,
  LabelAnnotationId,
  LabelAnnotation,
  FieldLookupAnnotationId,
  GeneratorAnnotationId,
  GeneratorAnnotation,
  getSchemaDXN,
  FIELD_PATH_ANNOTATION,
  FieldPath,
  EntityKindId,
  SelfDXNId,
  ATTR_SELF_DXN,
  TypeId,
  ATTR_TYPE,
  SchemaId,
  DeletedId,
  ATTR_DELETED,
  MetaId,
  ATTR_META,
  RelationSourceDXNId,
  ATTR_RELATION_SOURCE,
  RelationTargetDXNId,
  ATTR_RELATION_TARGET,
  RelationSourceId,
  RelationTargetId,
  assertObjectModelShape,
  getObjectDXN,
  getSchema,
  setSchema,
  getLabelForObject,
  getLabel,
  getTypename,
  setTypename,
  getType,
  makeTypedEntityClass,
  ObjectMetaSchema,
  foreignKey,
  foreignKeyEquals,
  getObjectMeta,
  getMeta,
  compareForeignKeys,
  JSON_SCHEMA_ECHO_REF_ID,
  getSchemaReference,
  createSchemaReference,
  RefTypeId,
  Ref,
  createEchoReferenceSchema,
  RefImpl,
  setRefResolver,
  getRefSavedTarget,
  refFromEncodedReference,
  StaticRefResolver,
  RefArray,
  defineHiddenProperty,
  objectToJSON,
  objectFromJSON,
  attachTypedJsonSerializer,
  create,
  EchoObject,
  EchoRelation,
  EXPANDO_TYPENAME,
  Expando,
  createQueueDXN,
  TypedObject,
  TypedRelation,
  isDeleted,
  SchemaValidator,
  checkIdNotPresentOnSchema
};
//# sourceMappingURL=chunk-54NDCEXR.mjs.map
