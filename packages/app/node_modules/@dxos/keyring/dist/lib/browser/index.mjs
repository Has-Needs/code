import "@dxos/node-std/globals";

// packages/core/halo/keyring/src/keyring.ts
import { Event, synchronized } from "@dxos/async";
import { subtleCrypto } from "@dxos/crypto";
import { todo } from "@dxos/debug";
import { invariant } from "@dxos/invariant";
import { PublicKey } from "@dxos/keys";
import { schema } from "@dxos/protocols/proto";
import { createStorage, StorageType } from "@dxos/random-access-storage";
import { ComplexMap, arrayToBuffer } from "@dxos/util";
function _ts_decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/core/halo/keyring/src/keyring.ts";
var KeyRecord = schema.getCodecForType("dxos.halo.keyring.KeyRecord");
var Keyring = class {
  constructor(_storage = createStorage({
    type: StorageType.RAM
  }).createDirectory("keyring")) {
    this._storage = _storage;
    this._keyCache = new ComplexMap(PublicKey.hash);
    this.keysUpdate = new Event();
    invariant(subtleCrypto, "SubtleCrypto not available in this environment.", {
      F: __dxlog_file,
      L: 30,
      S: this,
      A: [
        "subtleCrypto",
        "'SubtleCrypto not available in this environment.'"
      ]
    });
  }
  async sign(key, message) {
    const keyPair = await this._getKey(key);
    return new Uint8Array(await subtleCrypto.sign({
      name: "ECDSA",
      hash: "SHA-256"
    }, keyPair.privateKey, message));
  }
  async createKey() {
    const keyPair = await subtleCrypto.generateKey({
      name: "ECDSA",
      namedCurve: "P-256"
    }, true, [
      "sign",
      "verify"
    ]);
    await this._setKey(keyPair);
    return keyPairToPublicKey(keyPair);
  }
  async _getKey(key) {
    if (!this._keyCache.has(key)) {
      const file = this._storage.getOrCreateFile(key.toHex());
      const { size } = await file.stat();
      if (size === 0) {
        throw new Error(`Key not found: ${key.toHex()}`);
      }
      const recordBytes = await file.read(0, size);
      await file.close();
      const record = KeyRecord.decode(recordBytes);
      const publicKey = PublicKey.from(record.publicKey);
      invariant(key.equals(publicKey), "Corrupted keyring: Key mismatch", {
        F: __dxlog_file,
        L: 77,
        S: this,
        A: [
          "key.equals(publicKey)",
          "'Corrupted keyring: Key mismatch'"
        ]
      });
      invariant(record.privateKey, "Corrupted keyring: Missing private key", {
        F: __dxlog_file,
        L: 78,
        S: this,
        A: [
          "record.privateKey",
          "'Corrupted keyring: Missing private key'"
        ]
      });
      const keyPair = {
        publicKey: await subtleCrypto.importKey("raw", record.publicKey, {
          name: "ECDSA",
          namedCurve: "P-256"
        }, true, [
          "verify"
        ]),
        privateKey: await subtleCrypto.importKey("pkcs8", record.privateKey, {
          name: "ECDSA",
          namedCurve: "P-256"
        }, true, [
          "sign"
        ])
      };
      this._keyCache.set(publicKey, keyPair);
    }
    return this._keyCache.get(key);
  }
  async _setKey(keyPair) {
    const publicKey = await keyPairToPublicKey(keyPair);
    this._keyCache.set(publicKey, keyPair);
    const record = {
      publicKey: publicKey.asUint8Array(),
      privateKey: new Uint8Array(await subtleCrypto.exportKey("pkcs8", keyPair.privateKey))
    };
    const file = this._storage.getOrCreateFile(publicKey.toHex());
    await file.write(0, arrayToBuffer(KeyRecord.encode(record)));
    await file.close();
    await file.flush?.();
    this.keysUpdate.emit();
  }
  // TODO(burdon): ???
  deleteKey(key) {
    return todo("We need a method to delete a file.");
  }
  async list() {
    const keys = [];
    for (const path of await this._storage.list()) {
      const fileName = path.split("/").pop();
      invariant(fileName, "Invalid file name", {
        F: __dxlog_file,
        L: 134,
        S: this,
        A: [
          "fileName",
          "'Invalid file name'"
        ]
      });
      keys.push({
        publicKey: PublicKey.fromHex(fileName).asUint8Array()
      });
    }
    return keys;
  }
  async importKeyPair(keyPair) {
    await this._setKey(keyPair);
    return keyPairToPublicKey(keyPair);
  }
};
_ts_decorate([
  synchronized
], Keyring.prototype, "_getKey", null);
_ts_decorate([
  synchronized
], Keyring.prototype, "_setKey", null);
var keyPairToPublicKey = async (keyPair) => {
  return PublicKey.from(new Uint8Array(await subtleCrypto.exportKey("raw", keyPair.publicKey)));
};

// packages/core/halo/keyring/src/testing.ts
import { subtleCrypto as subtleCrypto2 } from "@dxos/crypto";
var generateJWKKeyPair = async () => {
  const keyPair = await subtleCrypto2.generateKey({
    name: "ECDSA",
    namedCurve: "P-256"
  }, true, [
    "sign",
    "verify"
  ]);
  const privateKeyExported = await subtleCrypto2.exportKey("jwk", keyPair.privateKey);
  const publicKeyExported = await subtleCrypto2.exportKey("jwk", keyPair.publicKey);
  const publicKeyBuffer = new Uint8Array(await subtleCrypto2.exportKey("raw", keyPair.publicKey));
  const publicKeyHex = Array.from(publicKeyBuffer).map((byte) => byte.toString(16).padStart(2, "0")).join("");
  return {
    privateKey: privateKeyExported,
    publicKey: publicKeyExported,
    publicKeyHex
  };
};
var parseJWKKeyPair = async (privateKey, publicKey) => {
  return {
    privateKey: await subtleCrypto2.importKey("jwk", privateKey, {
      name: "ECDSA",
      namedCurve: "P-256"
    }, true, [
      "sign"
    ]),
    publicKey: await subtleCrypto2.importKey("jwk", publicKey, {
      name: "ECDSA",
      namedCurve: "P-256"
    }, true, [
      "verify"
    ])
  };
};
export {
  Keyring,
  generateJWKKeyPair,
  parseJWKKeyPair
};
//# sourceMappingURL=index.mjs.map
