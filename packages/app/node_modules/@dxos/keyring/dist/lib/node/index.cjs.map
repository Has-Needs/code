{
  "version": 3,
  "sources": ["../../../src/keyring.ts", "../../../src/testing.ts"],
  "sourcesContent": ["//\n// Copyright 2022 DXOS.org\n//\n\nimport { Event, synchronized } from '@dxos/async';\nimport { type ProtoCodec } from '@dxos/codec-protobuf';\nimport { subtleCrypto, type Signer } from '@dxos/crypto';\nimport { todo } from '@dxos/debug';\nimport { invariant } from '@dxos/invariant';\nimport { PublicKey } from '@dxos/keys';\nimport { schema } from '@dxos/protocols/proto';\nimport { type KeyRecord } from '@dxos/protocols/proto/dxos/halo/keyring';\nimport { createStorage, type Directory, StorageType } from '@dxos/random-access-storage';\nimport { ComplexMap, arrayToBuffer } from '@dxos/util';\n\nconst KeyRecord: ProtoCodec<KeyRecord> = schema.getCodecForType('dxos.halo.keyring.KeyRecord');\n\n/**\n * Manages keys.\n */\nexport class Keyring implements Signer {\n  private readonly _keyCache = new ComplexMap<PublicKey, CryptoKeyPair>(PublicKey.hash);\n  readonly keysUpdate = new Event();\n\n  constructor(\n    private readonly _storage: Directory = createStorage({\n      type: StorageType.RAM,\n    }).createDirectory('keyring'),\n  ) {\n    invariant(subtleCrypto, 'SubtleCrypto not available in this environment.');\n  }\n\n  async sign(key: PublicKey, message: Uint8Array): Promise<Uint8Array> {\n    const keyPair = await this._getKey(key);\n\n    return new Uint8Array(\n      await subtleCrypto.sign(\n        {\n          name: 'ECDSA',\n          hash: 'SHA-256',\n        },\n        keyPair.privateKey,\n        message,\n      ),\n    );\n  }\n\n  async createKey(): Promise<PublicKey> {\n    const keyPair = await subtleCrypto.generateKey(\n      {\n        name: 'ECDSA',\n        namedCurve: 'P-256',\n      },\n      true,\n      ['sign', 'verify'],\n    );\n\n    await this._setKey(keyPair);\n\n    return keyPairToPublicKey(keyPair);\n  }\n\n  @synchronized\n  private async _getKey(key: PublicKey): Promise<CryptoKeyPair> {\n    if (!this._keyCache.has(key)) {\n      const file = this._storage.getOrCreateFile(key.toHex());\n      const { size } = await file.stat();\n      if (size === 0) {\n        throw new Error(`Key not found: ${key.toHex()}`);\n      }\n\n      const recordBytes = await file.read(0, size);\n      await file.close();\n\n      const record = KeyRecord.decode(recordBytes);\n      const publicKey = PublicKey.from(record.publicKey);\n      invariant(key.equals(publicKey), 'Corrupted keyring: Key mismatch');\n      invariant(record.privateKey, 'Corrupted keyring: Missing private key');\n      const keyPair: CryptoKeyPair = {\n        publicKey: await subtleCrypto.importKey(\n          'raw',\n          record.publicKey,\n          {\n            name: 'ECDSA',\n            namedCurve: 'P-256',\n          },\n          true,\n          ['verify'],\n        ),\n        privateKey: await subtleCrypto.importKey(\n          'pkcs8',\n          record.privateKey,\n          {\n            name: 'ECDSA',\n            namedCurve: 'P-256',\n          },\n          true,\n          ['sign'],\n        ),\n      };\n\n      this._keyCache.set(publicKey, keyPair);\n    }\n\n    return this._keyCache.get(key)!; // TODO(burdon): Fail if null?\n  }\n\n  @synchronized\n  private async _setKey(keyPair: CryptoKeyPair): Promise<void> {\n    const publicKey = await keyPairToPublicKey(keyPair);\n    this._keyCache.set(publicKey, keyPair);\n\n    const record: KeyRecord = {\n      publicKey: publicKey.asUint8Array(),\n      privateKey: new Uint8Array(await subtleCrypto.exportKey('pkcs8', keyPair.privateKey)),\n    };\n\n    const file = this._storage.getOrCreateFile(publicKey.toHex());\n    await file.write(0, arrayToBuffer(KeyRecord.encode(record)));\n    await file.close();\n    await file.flush?.();\n    this.keysUpdate.emit();\n  }\n\n  // TODO(burdon): ???\n  deleteKey(key: PublicKey): Promise<void> {\n    return todo('We need a method to delete a file.');\n  }\n\n  async list(): Promise<KeyRecord[]> {\n    const keys: KeyRecord[] = [];\n    for (const path of await this._storage.list()) {\n      const fileName = path.split('/').pop(); // get last portion of the path\n      invariant(fileName, 'Invalid file name');\n      keys.push({ publicKey: PublicKey.fromHex(fileName).asUint8Array() });\n    }\n    return keys;\n  }\n\n  async importKeyPair(keyPair: CryptoKeyPair): Promise<PublicKey> {\n    await this._setKey(keyPair);\n    return keyPairToPublicKey(keyPair);\n  }\n}\n\nconst keyPairToPublicKey = async (keyPair: CryptoKeyPair): Promise<PublicKey> => {\n  return PublicKey.from(new Uint8Array(await subtleCrypto.exportKey('raw', keyPair.publicKey)));\n};\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { subtleCrypto } from '@dxos/crypto';\n\nexport type TestKeyPair = {\n  privateKey: JsonWebKey;\n  publicKey: JsonWebKey;\n  publicKeyHex: string;\n};\n\n/**\n * Generate a key pair which for testing purposes.\n * @returns {Promise<TestKeyPair>}\n */\nexport const generateJWKKeyPair = async (): Promise<TestKeyPair> => {\n  const keyPair = await subtleCrypto.generateKey(\n    {\n      name: 'ECDSA',\n      namedCurve: 'P-256',\n    },\n    true,\n    ['sign', 'verify'],\n  );\n\n  const privateKeyExported = await subtleCrypto.exportKey('jwk', keyPair.privateKey);\n  const publicKeyExported = await subtleCrypto.exportKey('jwk', keyPair.publicKey);\n\n  // Convert the public key to hex format\n  const publicKeyBuffer = new Uint8Array(await subtleCrypto.exportKey('raw', keyPair.publicKey));\n  const publicKeyHex = Array.from(publicKeyBuffer)\n    .map((byte) => byte.toString(16).padStart(2, '0'))\n    .join('');\n\n  return {\n    privateKey: privateKeyExported,\n    publicKey: publicKeyExported,\n    publicKeyHex,\n  };\n};\n\n/**\n * Parse a key pair from JWK format.\n */\nexport const parseJWKKeyPair = async (privateKey: JsonWebKey, publicKey: JsonWebKey): Promise<CryptoKeyPair> => {\n  return {\n    privateKey: await subtleCrypto.importKey('jwk', privateKey, { name: 'ECDSA', namedCurve: 'P-256' }, true, ['sign']),\n    publicKey: await subtleCrypto.importKey('jwk', publicKey, { name: 'ECDSA', namedCurve: 'P-256' }, true, ['verify']),\n  };\n};\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;AAIA,mBAAoC;AAEpC,oBAA0C;AAC1C,mBAAqB;AACrB,uBAA0B;AAC1B,kBAA0B;AAC1B,mBAAuB;AAEvB,mCAA2D;AAC3D,kBAA0C;ACT1C,IAAAA,iBAA6B;;;;;;;;ADW7B,IAAMC,YAAmCC,oBAAOC,gBAAgB,6BAAA;AAKzD,IAAMC,UAAN,MAAMA;EAIX,YACmBC,eAAsBC,4CAAc;IACnDC,MAAMC,yCAAYC;EACpB,CAAA,EAAGC,gBAAgB,SAAA,GACnB;SAHiBL,WAAAA;SAJFM,YAAY,IAAIC,uBAAqCC,sBAAUC,IAAI;SAC3EC,aAAa,IAAIC,mBAAAA;AAOxBC,oCAAUC,4BAAc,mDAAA;;;;;;;;;EAC1B;EAEA,MAAMC,KAAKC,KAAgBC,SAA0C;AACnE,UAAMC,UAAU,MAAM,KAAKC,QAAQH,GAAAA;AAEnC,WAAO,IAAII,WACT,MAAMN,2BAAaC,KACjB;MACEM,MAAM;MACNX,MAAM;IACR,GACAQ,QAAQI,YACRL,OAAAA,CAAAA;EAGN;EAEA,MAAMM,YAAgC;AACpC,UAAML,UAAU,MAAMJ,2BAAaU,YACjC;MACEH,MAAM;MACNI,YAAY;IACd,GACA,MACA;MAAC;MAAQ;KAAS;AAGpB,UAAM,KAAKC,QAAQR,OAAAA;AAEnB,WAAOS,mBAAmBT,OAAAA;EAC5B;EAEA,MACcC,QAAQH,KAAwC;AAC5D,QAAI,CAAC,KAAKT,UAAUqB,IAAIZ,GAAAA,GAAM;AAC5B,YAAMa,OAAO,KAAK5B,SAAS6B,gBAAgBd,IAAIe,MAAK,CAAA;AACpD,YAAM,EAAEC,KAAI,IAAK,MAAMH,KAAKI,KAAI;AAChC,UAAID,SAAS,GAAG;AACd,cAAM,IAAIE,MAAM,kBAAkBlB,IAAIe,MAAK,CAAA,EAAI;MACjD;AAEA,YAAMI,cAAc,MAAMN,KAAKO,KAAK,GAAGJ,IAAAA;AACvC,YAAMH,KAAKQ,MAAK;AAEhB,YAAMC,SAASzC,UAAU0C,OAAOJ,WAAAA;AAChC,YAAMK,YAAY/B,sBAAUgC,KAAKH,OAAOE,SAAS;AACjD3B,sCAAUG,IAAI0B,OAAOF,SAAAA,GAAY,mCAAA;;;;;;;;;AACjC3B,sCAAUyB,OAAOhB,YAAY,0CAAA;;;;;;;;;AAC7B,YAAMJ,UAAyB;QAC7BsB,WAAW,MAAM1B,2BAAa6B,UAC5B,OACAL,OAAOE,WACP;UACEnB,MAAM;UACNI,YAAY;QACd,GACA,MACA;UAAC;SAAS;QAEZH,YAAY,MAAMR,2BAAa6B,UAC7B,SACAL,OAAOhB,YACP;UACED,MAAM;UACNI,YAAY;QACd,GACA,MACA;UAAC;SAAO;MAEZ;AAEA,WAAKlB,UAAUqC,IAAIJ,WAAWtB,OAAAA;IAChC;AAEA,WAAO,KAAKX,UAAUsC,IAAI7B,GAAAA;EAC5B;EAEA,MACcU,QAAQR,SAAuC;AAC3D,UAAMsB,YAAY,MAAMb,mBAAmBT,OAAAA;AAC3C,SAAKX,UAAUqC,IAAIJ,WAAWtB,OAAAA;AAE9B,UAAMoB,SAAoB;MACxBE,WAAWA,UAAUM,aAAY;MACjCxB,YAAY,IAAIF,WAAW,MAAMN,2BAAaiC,UAAU,SAAS7B,QAAQI,UAAU,CAAA;IACrF;AAEA,UAAMO,OAAO,KAAK5B,SAAS6B,gBAAgBU,UAAUT,MAAK,CAAA;AAC1D,UAAMF,KAAKmB,MAAM,OAAGC,2BAAcpD,UAAUqD,OAAOZ,MAAAA,CAAAA,CAAAA;AACnD,UAAMT,KAAKQ,MAAK;AAChB,UAAMR,KAAKsB,QAAK;AAChB,SAAKxC,WAAWyC,KAAI;EACtB;;EAGAC,UAAUrC,KAA+B;AACvC,eAAOsC,mBAAK,oCAAA;EACd;EAEA,MAAMC,OAA6B;AACjC,UAAMC,OAAoB,CAAA;AAC1B,eAAWC,QAAQ,MAAM,KAAKxD,SAASsD,KAAI,GAAI;AAC7C,YAAMG,WAAWD,KAAKE,MAAM,GAAA,EAAKC,IAAG;AACpC/C,sCAAU6C,UAAU,qBAAA;;;;;;;;;AACpBF,WAAKK,KAAK;QAAErB,WAAW/B,sBAAUqD,QAAQJ,QAAAA,EAAUZ,aAAY;MAAG,CAAA;IACpE;AACA,WAAOU;EACT;EAEA,MAAMO,cAAc7C,SAA4C;AAC9D,UAAM,KAAKQ,QAAQR,OAAAA;AACnB,WAAOS,mBAAmBT,OAAAA;EAC5B;AACF;;;;;;;AAEA,IAAMS,qBAAqB,OAAOT,YAAAA;AAChC,SAAOT,sBAAUgC,KAAK,IAAIrB,WAAW,MAAMN,2BAAaiC,UAAU,OAAO7B,QAAQsB,SAAS,CAAA,CAAA;AAC5F;ACnIO,IAAMwB,qBAAqB,YAAA;AAChC,QAAM9C,UAAU,MAAMJ,eAAAA,aAAaU,YACjC;IACEH,MAAM;IACNI,YAAY;EACd,GACA,MACA;IAAC;IAAQ;GAAS;AAGpB,QAAMwC,qBAAqB,MAAMnD,eAAAA,aAAaiC,UAAU,OAAO7B,QAAQI,UAAU;AACjF,QAAM4C,oBAAoB,MAAMpD,eAAAA,aAAaiC,UAAU,OAAO7B,QAAQsB,SAAS;AAG/E,QAAM2B,kBAAkB,IAAI/C,WAAW,MAAMN,eAAAA,aAAaiC,UAAU,OAAO7B,QAAQsB,SAAS,CAAA;AAC5F,QAAM4B,eAAeC,MAAM5B,KAAK0B,eAAAA,EAC7BG,IAAI,CAACC,SAASA,KAAKC,SAAS,EAAA,EAAIC,SAAS,GAAG,GAAA,CAAA,EAC5CC,KAAK,EAAA;AAER,SAAO;IACLpD,YAAY2C;IACZzB,WAAW0B;IACXE;EACF;AACF;AAKO,IAAMO,kBAAkB,OAAOrD,YAAwBkB,cAAAA;AAC5D,SAAO;IACLlB,YAAY,MAAMR,eAAAA,aAAa6B,UAAU,OAAOrB,YAAY;MAAED,MAAM;MAASI,YAAY;IAAQ,GAAG,MAAM;MAAC;KAAO;IAClHe,WAAW,MAAM1B,eAAAA,aAAa6B,UAAU,OAAOH,WAAW;MAAEnB,MAAM;MAASI,YAAY;IAAQ,GAAG,MAAM;MAAC;KAAS;EACpH;AACF;",
  "names": ["import_crypto", "KeyRecord", "schema", "getCodecForType", "Keyring", "_storage", "createStorage", "type", "StorageType", "RAM", "createDirectory", "_keyCache", "ComplexMap", "PublicKey", "hash", "keysUpdate", "Event", "invariant", "subtleCrypto", "sign", "key", "message", "keyPair", "_getKey", "Uint8Array", "name", "privateKey", "createKey", "generateKey", "namedCurve", "_setKey", "keyPairToPublicKey", "has", "file", "getOrCreateFile", "toHex", "size", "stat", "Error", "recordBytes", "read", "close", "record", "decode", "publicKey", "from", "equals", "importKey", "set", "get", "asUint8Array", "exportKey", "write", "arrayToBuffer", "encode", "flush", "emit", "deleteKey", "todo", "list", "keys", "path", "fileName", "split", "pop", "push", "fromHex", "importKeyPair", "generateJWKKeyPair", "privateKeyExported", "publicKeyExported", "publicKeyBuffer", "publicKeyHex", "Array", "map", "byte", "toString", "padStart", "join", "parseJWKKeyPair"]
}
