import { type Event } from '@dxos/async';
import { type FeedWrapper } from '@dxos/feed-store';
import { PublicKey } from '@dxos/keys';
import { type SwarmNetworkManager, type WireProtocol, type WireProtocolParams } from '@dxos/network-manager';
import type { FeedMessage } from '@dxos/protocols/proto/dxos/echo/feed';
import { type MuxerStats, Teleport } from '@dxos/teleport';
import { type BlobStore, BlobSync } from '@dxos/teleport-extension-object-sync';
import { ReplicatorExtension } from '@dxos/teleport-extension-replicator';
import { CallbackCollection, type AsyncCallback } from '@dxos/util';
import { type AuthProvider, type AuthVerifier } from './auth';
export declare const MOCK_AUTH_PROVIDER: AuthProvider;
export declare const MOCK_AUTH_VERIFIER: AuthVerifier;
export interface SwarmIdentity {
    peerKey: PublicKey;
    identityKey: PublicKey;
    credentialProvider: AuthProvider;
    credentialAuthenticator: AuthVerifier;
}
export type SpaceProtocolOptions = {
    topic: PublicKey;
    swarmIdentity: SwarmIdentity;
    networkManager: SwarmNetworkManager;
    blobStore: BlobStore;
    onFeed?: (feed: FeedWrapper<FeedMessage>) => Promise<void>;
    /**
     * Called when new session is authenticated.
     * Additional extensions can be added here.
     */
    onSessionAuth?: (session: Teleport) => void;
    onAuthFailure?: (session: Teleport) => void;
    disableP2pReplication?: boolean;
};
/**
 * Manages Teleport protocol stream creation and joining swarms with replication and presence extensions.
 */
export declare class SpaceProtocol {
    private readonly _networkManager;
    private readonly _swarmIdentity;
    private readonly _onSessionAuth?;
    private readonly _onAuthFailure?;
    readonly blobSync: BlobSync;
    private readonly _disableP2pReplication;
    private readonly _topic;
    private readonly _spaceKey;
    private readonly _feeds;
    private readonly _sessions;
    private readonly _topology;
    private _connection?;
    readonly feedAdded: CallbackCollection<AsyncCallback<FeedWrapper<FeedMessage>>>;
    get sessions(): ReadonlyMap<PublicKey, SpaceProtocolSession>;
    get feeds(): ReadonlySet<FeedWrapper<FeedMessage>>;
    private get _ownPeerKey();
    constructor({ topic, swarmIdentity, networkManager, onSessionAuth, onAuthFailure, blobStore, disableP2pReplication, }: SpaceProtocolOptions);
    addFeed(feed: FeedWrapper<FeedMessage>): Promise<void>;
    start(): Promise<void>;
    updateTopology(): void;
    stop(): Promise<void>;
    private _createProtocolProvider;
}
export type SpaceProtocolSessionParams = {
    wireParams: WireProtocolParams;
    swarmIdentity: SwarmIdentity;
    blobSync: BlobSync;
    /**
     * Called when new session is authenticated.
     * Additional extensions can be added here.
     */
    onSessionAuth?: (session: Teleport) => void;
    onAuthFailure?: (session: Teleport) => void;
    disableP2pReplication?: boolean;
};
export declare enum AuthStatus {
    INITIAL = "INITIAL",
    SUCCESS = "SUCCESS",
    FAILURE = "FAILURE"
}
/**
 * Represents a single connection to a remote peer
 */
export declare class SpaceProtocolSession implements WireProtocol {
    private readonly _wireParams;
    private readonly _disableP2pReplication;
    private readonly _onSessionAuth?;
    private readonly _onAuthFailure?;
    private readonly _swarmIdentity;
    private readonly _blobSync;
    private readonly _teleport;
    readonly replicator: ReplicatorExtension;
    private _authStatus;
    get authStatus(): AuthStatus;
    get stats(): Event<MuxerStats>;
    constructor({ wireParams, swarmIdentity, onSessionAuth, onAuthFailure, blobSync, disableP2pReplication, }: SpaceProtocolSessionParams);
    get stream(): import("stream").Duplex;
    open(sessionId?: PublicKey): Promise<void>;
    close(): Promise<void>;
    abort(): Promise<void>;
}
//# sourceMappingURL=space-protocol.d.ts.map