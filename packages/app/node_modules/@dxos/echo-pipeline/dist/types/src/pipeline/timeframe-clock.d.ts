import { Event } from '@dxos/async';
import { type FeedIndex } from '@dxos/feed-store';
import { type PublicKey } from '@dxos/keys';
import { Timeframe } from '@dxos/timeframe';
export declare const mapTimeframeToFeedIndexes: (timeframe: Timeframe) => FeedIndex[];
export declare const mapFeedIndexesToTimeframe: (indexes: FeedIndex[]) => Timeframe;
export declare const startAfter: (timeframe: Timeframe) => FeedIndex[];
/**
 * Keeps state of the last timeframe that was processed by ECHO.
 */
export declare class TimeframeClock {
    private _timeframe;
    readonly update: Event<Timeframe>;
    private _pendingTimeframe;
    constructor(_timeframe?: Timeframe);
    /**
     * Timeframe that was processed by ECHO.
     */
    get timeframe(): Timeframe;
    /**
     * Timeframe that is currently being processed by ECHO.
     * Will be equal to `timeframe` after the processing is complete.
     */
    get pendingTimeframe(): Timeframe;
    setTimeframe(timeframe: Timeframe): void;
    updatePendingTimeframe(key: PublicKey, seq: number): void;
    updateTimeframe(): void;
    hasGaps(timeframe: Timeframe): boolean;
    waitUntilReached(target: Timeframe): Promise<void>;
}
//# sourceMappingURL=timeframe-clock.d.ts.map