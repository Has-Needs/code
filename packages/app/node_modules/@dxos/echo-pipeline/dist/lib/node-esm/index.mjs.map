{
  "version": 3,
  "sources": ["../../../src/db-host/data-service.ts", "../../../src/db-host/documents-synchronizer.ts", "../../../src/automerge/automerge-host.ts", "../../../src/automerge/collection-synchronizer.ts", "../../../src/automerge/echo-network-adapter.ts", "../../../src/automerge/network-protocol.ts", "../../../src/automerge/heads-store.ts", "../../../src/automerge/leveldb-storage-adapter.ts", "../../../src/automerge/mesh-echo-replicator.ts", "../../../src/automerge/mesh-echo-replicator-connection.ts", "../../../src/automerge/space-collection.ts", "../../../src/automerge/echo-data-monitor.ts", "../../../src/db-host/echo-host.ts", "../../../src/db-host/documents-iterator.ts", "../../../src/db-host/query-service.ts", "../../../src/query/query-executor.ts", "../../../src/query/query-planner.ts", "../../../src/query/errors.ts", "../../../src/query/plan.ts", "../../../src/db-host/space-state-manager.ts", "../../../src/db-host/database-root.ts", "../../../src/db-host/automerge-metrics.ts", "../../../src/edge/echo-edge-replicator.ts", "../../../src/edge/inflight-request-limiter.ts", "../../../src/util.ts"],
  "sourcesContent": ["//\n// Copyright 2021 DXOS.org\n//\n\nimport { type DocumentId } from '@automerge/automerge-repo';\n\nimport { UpdateScheduler } from '@dxos/async';\nimport { type RequestOptions } from '@dxos/codec-protobuf';\nimport { Stream } from '@dxos/codec-protobuf/stream';\nimport { invariant } from '@dxos/invariant';\nimport { SpaceId } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport {\n  type DataService,\n  type FlushRequest,\n  type SubscribeRequest,\n  type BatchedDocumentUpdates,\n  type UpdateSubscriptionRequest,\n  type GetDocumentHeadsRequest,\n  type GetDocumentHeadsResponse,\n  type ReIndexHeadsRequest,\n  type WaitUntilHeadsReplicatedRequest,\n  type UpdateRequest,\n  type GetSpaceSyncStateRequest,\n  type SpaceSyncState,\n} from '@dxos/protocols/proto/dxos/echo/service';\n\nimport { DocumentsSynchronizer } from './documents-synchronizer';\nimport { type SpaceStateManager } from './space-state-manager';\nimport { deriveCollectionIdFromSpaceId, type AutomergeHost } from '../automerge';\n\nexport type DataServiceParams = {\n  automergeHost: AutomergeHost;\n  spaceStateManager: SpaceStateManager;\n  updateIndexes: () => Promise<void>;\n};\n\n/**\n * Data sync between client and services.\n */\n// TODO(burdon): Move to client-services.\nexport class DataServiceImpl implements DataService {\n  /**\n   * Map of subscriptions.\n   * subscriptionId -> DocumentsSynchronizer\n   */\n  private readonly _subscriptions = new Map<string, DocumentsSynchronizer>();\n\n  private readonly _automergeHost: AutomergeHost;\n  private readonly _spaceStateManager: SpaceStateManager;\n  private readonly _updateIndexes: () => Promise<void>;\n\n  constructor(params: DataServiceParams) {\n    this._automergeHost = params.automergeHost;\n    this._spaceStateManager = params.spaceStateManager;\n    this._updateIndexes = params.updateIndexes;\n  }\n\n  subscribe(request: SubscribeRequest): Stream<BatchedDocumentUpdates> {\n    return new Stream<BatchedDocumentUpdates>(({ next, ready }) => {\n      const synchronizer = new DocumentsSynchronizer({\n        repo: this._automergeHost.repo,\n        sendUpdates: (updates) => next(updates),\n      });\n      synchronizer\n        .open()\n        .then(() => {\n          this._subscriptions.set(request.subscriptionId, synchronizer);\n          ready();\n        })\n        .catch((err) => log.catch(err));\n      return () => synchronizer.close();\n    });\n  }\n\n  async updateSubscription(request: UpdateSubscriptionRequest): Promise<void> {\n    const synchronizer = this._subscriptions.get(request.subscriptionId);\n    invariant(synchronizer, 'Subscription not found');\n\n    if (request.addIds?.length) {\n      await synchronizer.addDocuments(request.addIds as DocumentId[]);\n    }\n    if (request.removeIds?.length) {\n      await synchronizer.removeDocuments(request.removeIds as DocumentId[]);\n    }\n  }\n\n  async update(request: UpdateRequest): Promise<void> {\n    if (!request.updates) {\n      return;\n    }\n    const synchronizer = this._subscriptions.get(request.subscriptionId);\n    invariant(synchronizer, 'Subscription not found');\n\n    await synchronizer.update(request.updates);\n  }\n\n  async flush(request: FlushRequest): Promise<void> {\n    await this._automergeHost.flush(request);\n  }\n\n  async getDocumentHeads(request: GetDocumentHeadsRequest): Promise<GetDocumentHeadsResponse> {\n    const documentIds = request.documentIds;\n    if (!documentIds) {\n      return { heads: { entries: [] } };\n    }\n    const heads = await this._automergeHost.getHeads(documentIds as DocumentId[]);\n    return {\n      heads: {\n        entries: heads.map((heads, idx) => ({ documentId: documentIds[idx], heads })),\n      },\n    };\n  }\n\n  async waitUntilHeadsReplicated(\n    request: WaitUntilHeadsReplicatedRequest,\n    options?: RequestOptions | undefined,\n  ): Promise<void> {\n    await this._automergeHost.waitUntilHeadsReplicated(request.heads);\n  }\n\n  async reIndexHeads(request: ReIndexHeadsRequest, options?: RequestOptions): Promise<void> {\n    await this._automergeHost.reIndexHeads((request.documentIds ?? []) as DocumentId[]);\n  }\n\n  async updateIndexes(): Promise<void> {\n    await this._updateIndexes();\n  }\n\n  subscribeSpaceSyncState(request: GetSpaceSyncStateRequest): Stream<SpaceSyncState> {\n    return new Stream<SpaceSyncState>(({ ctx, next, ready }) => {\n      const spaceId = request.spaceId;\n      invariant(SpaceId.isValid(spaceId));\n\n      const rootDocumentId = this._spaceStateManager.getSpaceRootDocumentId(spaceId);\n      let collectionId = rootDocumentId && deriveCollectionIdFromSpaceId(spaceId, rootDocumentId);\n      this._spaceStateManager.spaceDocumentListUpdated.on(ctx, (event) => {\n        const newId = deriveCollectionIdFromSpaceId(spaceId, event.spaceRootId);\n        if (newId !== collectionId) {\n          collectionId = newId;\n          scheduler.trigger();\n        }\n      });\n\n      const scheduler = new UpdateScheduler(ctx, async () => {\n        const state = collectionId ? await this._automergeHost.getCollectionSyncState(collectionId) : { peers: [] };\n\n        next({\n          peers: state.peers.map((peer) => ({\n            peerId: peer.peerId,\n            missingOnRemote: peer.missingOnRemote,\n            missingOnLocal: peer.missingOnLocal,\n            differentDocuments: peer.differentDocuments,\n            localDocumentCount: peer.localDocumentCount,\n            remoteDocumentCount: peer.remoteDocumentCount,\n          })),\n        });\n      });\n\n      this._automergeHost.collectionStateUpdated.on(ctx, (e) => {\n        if (e.collectionId === collectionId) {\n          scheduler.trigger();\n        }\n      });\n      scheduler.trigger();\n    });\n  }\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { next as A, type Heads } from '@automerge/automerge';\nimport { type Repo, type DocHandle, type DocumentId } from '@automerge/automerge-repo';\n\nimport { UpdateScheduler } from '@dxos/async';\nimport { Resource } from '@dxos/context';\nimport { type DatabaseDirectory } from '@dxos/echo-protocol';\nimport { invariant } from '@dxos/invariant';\nimport { log } from '@dxos/log';\nimport { type BatchedDocumentUpdates, type DocumentUpdate } from '@dxos/protocols/proto/dxos/echo/service';\n\nimport { FIND_PARAMS } from '../automerge';\n\nconst MAX_UPDATE_FREQ = 10; // [updates/sec]\n\nexport type DocumentsSynchronizerParams = {\n  repo: Repo;\n  sendUpdates: (updates: BatchedDocumentUpdates) => void;\n};\n\ninterface DocSyncState {\n  handle: DocHandle<DatabaseDirectory>;\n  lastSentHead?: Heads;\n  clearSubscriptions?: () => void;\n}\n\n/**\n * Manages a connection and replication between worker's Automerge Repo and the client's Repo.\n */\nexport class DocumentsSynchronizer extends Resource {\n  private readonly _syncStates = new Map<DocumentId, DocSyncState>();\n  /**\n   * Documents that have pending updates.\n   * Used to batch updates.\n   */\n  private readonly _pendingUpdates = new Set<DocumentId>();\n\n  /**\n   * Job that schedules if there are pending updates.\n   */\n  private _sendUpdatesJob?: UpdateScheduler = undefined;\n\n  constructor(private readonly _params: DocumentsSynchronizerParams) {\n    super();\n  }\n\n  addDocuments(documentIds: DocumentId[], retryCounter = 0): void {\n    if (retryCounter > 3) {\n      log.warn('Failed to load document, retry limit reached', { documentIds });\n      return;\n    }\n\n    for (const documentId of documentIds) {\n      this._params.repo\n        .find<DatabaseDirectory>(documentId as DocumentId)\n        .then(async (doc) => {\n          await doc.whenReady();\n          this._startSync(doc);\n          this._pendingUpdates.add(doc.documentId);\n          this._sendUpdatesJob!.trigger();\n        })\n        .catch((error) => {\n          log.warn('Failed to load document, wraparound', { documentId, error });\n          this.addDocuments([documentId], retryCounter + 1);\n        });\n    }\n  }\n\n  removeDocuments(documentIds: DocumentId[]): void {\n    for (const documentId of documentIds) {\n      this._syncStates.get(documentId)?.clearSubscriptions?.();\n      this._syncStates.delete(documentId);\n      this._pendingUpdates.delete(documentId);\n    }\n  }\n\n  protected override async _open(): Promise<void> {\n    this._sendUpdatesJob = new UpdateScheduler(this._ctx, this._checkAndSendUpdates.bind(this), {\n      maxFrequency: MAX_UPDATE_FREQ,\n    });\n  }\n\n  protected override async _close(): Promise<void> {\n    await this._sendUpdatesJob!.join();\n    this._syncStates.clear();\n  }\n\n  async update(updates: DocumentUpdate[]): Promise<void> {\n    for (const { documentId, mutation, isNew } of updates) {\n      if (isNew) {\n        const doc = await this._params.repo.find<DatabaseDirectory>(documentId as DocumentId, FIND_PARAMS);\n        doc.update((doc) => A.loadIncremental(doc, mutation));\n        this._startSync(doc);\n      } else {\n        this._writeMutation(documentId as DocumentId, mutation);\n      }\n    }\n  }\n\n  private _startSync(doc: DocHandle<DatabaseDirectory>): void {\n    if (this._syncStates.has(doc.documentId)) {\n      log('Document already being synced', { documentId: doc.documentId });\n      return;\n    }\n\n    const syncState: DocSyncState = { handle: doc };\n    this._subscribeForChanges(syncState);\n    this._syncStates.set(doc.documentId, syncState);\n  }\n\n  _subscribeForChanges(syncState: DocSyncState): void {\n    const handler = () => {\n      this._pendingUpdates.add(syncState.handle.documentId);\n      this._sendUpdatesJob!.trigger();\n    };\n    syncState.handle.on('heads-changed', handler);\n    syncState.clearSubscriptions = () => syncState.handle.off('heads-changed', handler);\n  }\n\n  private async _checkAndSendUpdates(): Promise<void> {\n    const updates: DocumentUpdate[] = [];\n\n    const docsWithPendingUpdates = Array.from(this._pendingUpdates);\n    this._pendingUpdates.clear();\n\n    for (const documentId of docsWithPendingUpdates) {\n      const update = this._getPendingChanges(documentId);\n      if (update) {\n        updates.push({\n          documentId,\n          mutation: update,\n        });\n      }\n    }\n\n    if (updates.length > 0) {\n      this._params.sendUpdates({ updates });\n    }\n  }\n\n  private _getPendingChanges(documentId: DocumentId): Uint8Array | void {\n    const syncState = this._syncStates.get(documentId);\n    invariant(syncState, 'Sync state for document not found');\n    const handle = syncState.handle;\n    if (!handle || !handle.isReady() || !handle.doc()) {\n      return;\n    }\n    const doc = handle.doc();\n    const mutation = syncState.lastSentHead ? A.saveSince(doc, syncState.lastSentHead) : A.save(doc);\n    if (mutation.length === 0) {\n      return;\n    }\n    syncState.lastSentHead = A.getHeads(doc);\n    return mutation;\n  }\n\n  private _writeMutation(documentId: DocumentId, mutation: Uint8Array): void {\n    const syncState = this._syncStates.get(documentId);\n    invariant(syncState, 'Sync state for document not found');\n    syncState.handle.update((doc) => {\n      const headsBefore = A.getHeads(doc);\n      const newDoc = A.loadIncremental(doc, mutation);\n      if (A.equals(headsBefore, syncState.lastSentHead)) {\n        syncState.lastSentHead = A.getHeads(newDoc);\n      }\n      return newDoc;\n    });\n  }\n}\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport {\n  getBackend,\n  getHeads,\n  isAutomerge,\n  equals as headsEquals,\n  save,\n  type Doc,\n  type Heads,\n} from '@automerge/automerge';\nimport {\n  type DocHandleChangePayload,\n  Repo,\n  type AnyDocumentId,\n  type DocHandle,\n  type DocumentId,\n  type PeerCandidatePayload,\n  type PeerDisconnectedPayload,\n  type PeerId,\n  type StorageAdapterInterface,\n  type StorageKey,\n  interpretAsDocumentId,\n  type HandleState,\n} from '@automerge/automerge-repo';\n\nimport { Event, asyncTimeout } from '@dxos/async';\nimport { Context, Resource, cancelWithContext, type Lifecycle } from '@dxos/context';\nimport { DatabaseDirectory, type CollectionId } from '@dxos/echo-protocol';\nimport { type IndexMetadataStore } from '@dxos/indexing';\nimport { invariant } from '@dxos/invariant';\nimport { PublicKey } from '@dxos/keys';\nimport { type LevelDB } from '@dxos/kv-store';\nimport { log } from '@dxos/log';\nimport { objectPointerCodec } from '@dxos/protocols';\nimport { type DocHeadsList, type FlushRequest } from '@dxos/protocols/proto/dxos/echo/service';\nimport { trace } from '@dxos/tracing';\nimport { bufferToArray } from '@dxos/util';\n\nimport { CollectionSynchronizer, diffCollectionState, type CollectionState } from './collection-synchronizer';\nimport { type EchoDataMonitor } from './echo-data-monitor';\nimport { EchoNetworkAdapter, isEchoPeerMetadata } from './echo-network-adapter';\nimport { type EchoReplicator, type RemoteDocumentExistenceCheckParams } from './echo-replicator';\nimport { HeadsStore } from './heads-store';\nimport { LevelDBStorageAdapter, type BeforeSaveParams } from './leveldb-storage-adapter';\n\nexport type PeerIdProvider = () => string | undefined;\n\nexport type RootDocumentSpaceKeyProvider = (documentId: string) => PublicKey | undefined;\n\nexport type AutomergeHostParams = {\n  db: LevelDB;\n\n  indexMetadataStore: IndexMetadataStore;\n  dataMonitor?: EchoDataMonitor;\n\n  /**\n   * Used for creating stable ids. A random key is generated on open, if no value is provided.\n   */\n  peerIdProvider?: PeerIdProvider;\n  getSpaceKeyByRootDocumentId?: RootDocumentSpaceKeyProvider;\n};\n\nexport type LoadDocOptions = {\n  timeout?: number;\n};\n\nexport type CreateDocOptions = {\n  /**\n   * Import the document together with its history.\n   */\n  preserveHistory?: boolean;\n};\n\nexport const FIND_PARAMS = {\n  allowableStates: ['ready', 'requesting'] satisfies HandleState[],\n};\n\n/**\n * Abstracts over the AutomergeRepo.\n */\n@trace.resource()\nexport class AutomergeHost extends Resource {\n  private readonly _db: LevelDB;\n  private readonly _indexMetadataStore: IndexMetadataStore;\n  private readonly _echoNetworkAdapter: EchoNetworkAdapter;\n\n  private readonly _collectionSynchronizer = new CollectionSynchronizer({\n    queryCollectionState: this._queryCollectionState.bind(this),\n    sendCollectionState: this._sendCollectionState.bind(this),\n    shouldSyncCollection: this._shouldSyncCollection.bind(this),\n  });\n\n  private _repo!: Repo;\n  private _storage!: StorageAdapterInterface & Lifecycle;\n  private readonly _headsStore: HeadsStore;\n\n  @trace.info()\n  private _peerId!: PeerId;\n\n  private readonly _peerIdProvider?: PeerIdProvider;\n  private readonly _getSpaceKeyByRootDocumentId?: RootDocumentSpaceKeyProvider;\n\n  public readonly collectionStateUpdated = new Event<{ collectionId: CollectionId }>();\n\n  /**\n   * Fired after a batch of documents was saved to disk.\n   */\n  public readonly documentsSaved = new Event();\n\n  constructor({\n    db,\n    indexMetadataStore,\n    dataMonitor,\n    peerIdProvider,\n    getSpaceKeyByRootDocumentId,\n  }: AutomergeHostParams) {\n    super();\n    this._db = db;\n    this._storage = new LevelDBStorageAdapter({\n      db: db.sublevel('automerge'),\n      callbacks: {\n        beforeSave: async (params) => this._beforeSave(params),\n        afterSave: async (key) => this._afterSave(key),\n      },\n      monitor: dataMonitor,\n    });\n    this._echoNetworkAdapter = new EchoNetworkAdapter({\n      getContainingSpaceForDocument: this._getContainingSpaceForDocument.bind(this),\n      isDocumentInRemoteCollection: this._isDocumentInRemoteCollection.bind(this),\n      onCollectionStateQueried: this._onCollectionStateQueried.bind(this),\n      onCollectionStateReceived: this._onCollectionStateReceived.bind(this),\n      monitor: dataMonitor,\n    });\n    this._headsStore = new HeadsStore({ db: db.sublevel('heads') });\n    this._indexMetadataStore = indexMetadataStore;\n    this._peerIdProvider = peerIdProvider;\n    this._getSpaceKeyByRootDocumentId = getSpaceKeyByRootDocumentId;\n  }\n\n  protected override async _open(): Promise<void> {\n    this._peerId = `host-${this._peerIdProvider?.() ?? PublicKey.random().toHex()}` as PeerId;\n\n    await this._storage.open?.();\n\n    // Construct the automerge repo.\n    this._repo = new Repo({\n      peerId: this._peerId as PeerId,\n      sharePolicy: this._sharePolicy.bind(this),\n      storage: this._storage,\n      network: [\n        // Upstream swarm.\n        this._echoNetworkAdapter,\n      ],\n    });\n\n    let updatingAuthScope = false;\n    Event.wrap(this._echoNetworkAdapter, 'peer-candidate').on(\n      this._ctx,\n      ((e: PeerCandidatePayload) => !updatingAuthScope && this._onPeerConnected(e.peerId)) as any,\n    );\n    Event.wrap(this._echoNetworkAdapter, 'peer-disconnected').on(\n      this._ctx,\n      ((e: PeerDisconnectedPayload) => !updatingAuthScope && this._onPeerDisconnected(e.peerId)) as any,\n    );\n\n    this._collectionSynchronizer.remoteStateUpdated.on(this._ctx, ({ collectionId, peerId, newDocsAppeared }) => {\n      this._onRemoteCollectionStateUpdated(collectionId, peerId);\n      this.collectionStateUpdated.emit({ collectionId: collectionId as CollectionId });\n      // We use collection lookups during share policy check, so we might need to update share policy for the new doc\n      if (newDocsAppeared) {\n        updatingAuthScope = true;\n        try {\n          this._echoNetworkAdapter.onConnectionAuthScopeChanged(peerId);\n        } finally {\n          updatingAuthScope = false;\n        }\n      }\n    });\n\n    await this._echoNetworkAdapter.open();\n    await this._collectionSynchronizer.open();\n    await this._echoNetworkAdapter.open();\n    await this._echoNetworkAdapter.whenConnected();\n  }\n\n  protected override async _close(): Promise<void> {\n    await this._collectionSynchronizer.close();\n    await this._storage.close?.();\n    await this._echoNetworkAdapter.close();\n    await this._ctx.dispose();\n  }\n\n  /**\n   * @deprecated To be abstracted away.\n   */\n  get repo(): Repo {\n    return this._repo;\n  }\n\n  get peerId(): PeerId {\n    return this._peerId;\n  }\n\n  get loadedDocsCount(): number {\n    return Object.keys(this._repo.handles).length;\n  }\n\n  async addReplicator(replicator: EchoReplicator): Promise<void> {\n    await this._echoNetworkAdapter.addReplicator(replicator);\n  }\n\n  async removeReplicator(replicator: EchoReplicator): Promise<void> {\n    await this._echoNetworkAdapter.removeReplicator(replicator);\n  }\n\n  /**\n   * Loads the document handle from the repo and waits for it to be ready.\n   */\n  async loadDoc<T>(ctx: Context, documentId: AnyDocumentId, opts?: LoadDocOptions): Promise<DocHandle<T>> {\n    let handle: DocHandle<T> | undefined;\n    if (typeof documentId === 'string') {\n      // NOTE: documentId might also be a URL, in which case this lookup will fail.\n      handle = this._repo.handles[documentId as DocumentId];\n    }\n    if (!handle) {\n      handle = await this._repo.find(documentId as DocumentId, FIND_PARAMS);\n    }\n\n    // `whenReady` creates a timeout so we guard it with an if to skip it if the handle is already ready.\n    if (!handle.isReady()) {\n      if (!opts?.timeout) {\n        await cancelWithContext(ctx, handle.whenReady());\n      } else {\n        await cancelWithContext(ctx, asyncTimeout(handle.whenReady(), opts.timeout));\n      }\n    }\n\n    return handle;\n  }\n\n  async exportDoc(ctx: Context, id: AnyDocumentId): Promise<Uint8Array> {\n    const documentId = interpretAsDocumentId(id);\n\n    const chunks = await this._storage.loadRange([documentId]);\n    return bufferToArray(Buffer.concat(chunks.map((c) => c.data!)));\n  }\n\n  /**\n   * Create new persisted document.\n   */\n  createDoc<T>(initialValue?: T | Doc<T> | Uint8Array, opts?: CreateDocOptions): DocHandle<T> {\n    if (opts?.preserveHistory) {\n      if (initialValue instanceof Uint8Array) {\n        return this._repo.import(initialValue);\n      }\n\n      if (!isAutomerge(initialValue)) {\n        throw new TypeError('Initial value must be an Automerge document');\n      }\n\n      // TODO(dmaretskyi): There's a more efficient way.\n      return this._repo.import(save(initialValue as Doc<T>));\n    } else {\n      if (initialValue instanceof Uint8Array) {\n        throw new Error('Cannot create document from Uint8Array without preserving history');\n      }\n\n      return this._repo.create(initialValue);\n    }\n  }\n\n  async waitUntilHeadsReplicated(heads: DocHeadsList): Promise<void> {\n    const entries = heads.entries;\n    if (!entries?.length) {\n      return;\n    }\n    const documentIds = entries.map((entry) => entry.documentId as DocumentId);\n    const documentHeads = await this.getHeads(documentIds);\n    const headsToWait = entries.filter((entry, index) => {\n      const targetHeads = entry.heads;\n      if (!targetHeads || targetHeads.length === 0) {\n        return false;\n      }\n      const currentHeads = documentHeads[index];\n      return !(currentHeads !== null && headsEquals(currentHeads, targetHeads));\n    });\n    if (headsToWait.length > 0) {\n      await Promise.all(\n        headsToWait.map(async (entry, index) => {\n          const handle = await this.loadDoc<DatabaseDirectory>(Context.default(), entry.documentId as DocumentId);\n          await waitForHeads(handle, entry.heads!);\n        }),\n      );\n    }\n\n    // Flush to disk handles loaded to memory also so that the indexer can pick up the changes.\n    await this._repo.flush(\n      documentIds.filter((documentId) => this._repo.handles[documentId] && this._repo.handles[documentId].isReady()),\n    );\n  }\n\n  async reIndexHeads(documentIds: DocumentId[]): Promise<void> {\n    for (const documentId of documentIds) {\n      log('re-indexing heads for document', { documentId });\n      const handle = await this._repo.find(documentId, FIND_PARAMS);\n      if (!handle.isReady()) {\n        log.warn('document is not available locally, skipping', { documentId });\n        continue; // Handle not available locally.\n      }\n\n      const heads = handle.heads();\n      const batch = this._db.batch();\n      this._headsStore.setHeads(documentId, heads, batch);\n      await batch.write();\n    }\n    log('done re-indexing heads');\n  }\n\n  // TODO(dmaretskyi): Share based on HALO permissions and space affinity.\n  // Hosts, running in the worker, don't share documents unless requested by other peers.\n  // NOTE: If both peers return sharePolicy=false the replication will not happen\n  // https://github.com/automerge/automerge-repo/pull/292\n  private async _sharePolicy(peerId: PeerId, documentId?: DocumentId): Promise<boolean> {\n    if (peerId.startsWith('client-')) {\n      return false; // Only send docs to clients if they are requested.\n    }\n\n    if (!documentId) {\n      return false;\n    }\n\n    const peerMetadata = this.repo.peerMetadataByPeerId[peerId];\n    if (isEchoPeerMetadata(peerMetadata)) {\n      return this._echoNetworkAdapter.shouldAdvertise(peerId, { documentId });\n    }\n\n    return false;\n  }\n\n  private async _beforeSave({ path, batch }: BeforeSaveParams): Promise<void> {\n    const handle = this._repo.handles[path[0] as DocumentId];\n    if (!handle || !handle.isReady()) {\n      return;\n    }\n    const doc = handle.doc();\n    if (!doc) {\n      return;\n    }\n\n    const heads = getHeads(doc);\n    this._headsStore.setHeads(handle.documentId, heads, batch);\n\n    const spaceKey = DatabaseDirectory.getSpaceKey(doc) ?? undefined;\n    const objectIds = Object.keys(doc.objects ?? {});\n    const encodedIds = objectIds.map((objectId) =>\n      objectPointerCodec.encode({ documentId: handle.documentId, objectId, spaceKey }),\n    );\n    const idToLastHash = new Map(encodedIds.map((id) => [id, heads]));\n    this._indexMetadataStore.markDirty(idToLastHash, batch);\n  }\n\n  private _shouldSyncCollection(collectionId: string, peerId: PeerId): boolean {\n    const peerMetadata = this._repo.peerMetadataByPeerId[peerId];\n    if (isEchoPeerMetadata(peerMetadata)) {\n      return this._echoNetworkAdapter.shouldSyncCollection(peerId, { collectionId });\n    }\n\n    return false;\n  }\n\n  /**\n   * Called by AutomergeStorageAdapter after levelDB batch commit.\n   */\n  private async _afterSave(path: StorageKey): Promise<void> {\n    this._indexMetadataStore.notifyMarkedDirty();\n\n    const documentId = path[0] as DocumentId;\n    const document = this._repo.handles[documentId]?.doc();\n    if (document) {\n      const heads = getHeads(document);\n      this._onHeadsChanged(documentId, heads);\n    }\n    this.documentsSaved.emit();\n  }\n\n  @trace.info({ depth: null })\n  private _automergePeers(): PeerId[] {\n    return this._repo.peers;\n  }\n\n  private async _isDocumentInRemoteCollection(params: RemoteDocumentExistenceCheckParams): Promise<boolean> {\n    for (const collectionId of this._collectionSynchronizer.getRegisteredCollectionIds()) {\n      const remoteCollections = this._collectionSynchronizer.getRemoteCollectionStates(collectionId);\n      const remotePeerDocs = remoteCollections.get(params.peerId as PeerId)?.documents;\n      if (remotePeerDocs && params.documentId in remotePeerDocs) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private async _getContainingSpaceForDocument(documentId: string): Promise<PublicKey | null> {\n    const handle = this._repo.handles[documentId as any];\n    if (handle.state === 'loading') {\n      await handle.whenReady();\n    }\n    if (handle && handle.isReady() && handle.doc()) {\n      const spaceKeyHex = DatabaseDirectory.getSpaceKey(handle.doc());\n      if (spaceKeyHex) {\n        return PublicKey.from(spaceKeyHex);\n      }\n    }\n    /**\n     * Edge case on the initial space setup.\n     * A peer is maybe trying to share space root document with us after a successful invitation.\n     * We don't have a document to check access block locally, so we need to rely on external sources (space metada).\n     */\n    const rootDocSpaceKey = this._getSpaceKeyByRootDocumentId?.(documentId);\n    if (rootDocSpaceKey) {\n      return rootDocSpaceKey;\n    }\n\n    return null;\n  }\n\n  /**\n   * Flush documents to disk.\n   */\n  @trace.span({ showInBrowserTimeline: true })\n  async flush({ documentIds }: FlushRequest = {}): Promise<void> {\n    // Note: Sync protocol for client and services ensures that all handles should have all changes.\n\n    const loadedDocuments = documentIds?.filter((documentId): documentId is DocumentId => {\n      const handle = this._repo.handles[documentId as DocumentId];\n      return handle && handle.isReady();\n    });\n    await this._repo.flush(loadedDocuments);\n  }\n\n  async getHeads(documentIds: DocumentId[]): Promise<(Heads | undefined)[]> {\n    const result: (Heads | undefined)[] = [];\n    const storeRequestIds: DocumentId[] = [];\n    const storeResultIndices: number[] = [];\n    for (const documentId of documentIds) {\n      const handle = this._repo.handles[documentId];\n      if (handle && handle.isReady() && handle.doc()) {\n        result.push(getHeads(handle.doc()!));\n      } else {\n        storeRequestIds.push(documentId);\n        storeResultIndices.push(result.length);\n        result.push(undefined);\n      }\n    }\n    if (storeRequestIds.length > 0) {\n      const storedHeads = await this._headsStore.getHeads(storeRequestIds);\n      for (let i = 0; i < storedHeads.length; i++) {\n        result[storeResultIndices[i]] = storedHeads[i];\n      }\n    }\n    return result;\n  }\n\n  //\n  // Collection sync.\n  //\n\n  getLocalCollectionState(collectionId: string): CollectionState | undefined {\n    return this._collectionSynchronizer.getLocalCollectionState(collectionId);\n  }\n\n  getRemoteCollectionStates(collectionId: string): ReadonlyMap<PeerId, CollectionState> {\n    return this._collectionSynchronizer.getRemoteCollectionStates(collectionId);\n  }\n\n  refreshCollection(collectionId: string): void {\n    this._collectionSynchronizer.refreshCollection(collectionId);\n  }\n\n  async getCollectionSyncState(collectionId: string): Promise<CollectionSyncState> {\n    const result: CollectionSyncState = {\n      peers: [],\n    };\n\n    const localState = this.getLocalCollectionState(collectionId);\n    const remoteState = this.getRemoteCollectionStates(collectionId);\n\n    if (!localState) {\n      return result;\n    }\n\n    for (const [peerId, state] of remoteState) {\n      const diff = diffCollectionState(localState, state);\n      result.peers.push({\n        peerId,\n        missingOnRemote: diff.missingOnRemote.length,\n        missingOnLocal: diff.missingOnLocal.length,\n        differentDocuments: diff.different.length,\n        localDocumentCount: Object.keys(localState.documents).length,\n        remoteDocumentCount: Object.keys(state.documents).length,\n      });\n    }\n\n    return result;\n  }\n\n  /**\n   * Update the local collection state based on the locally stored document heads.\n   */\n  async updateLocalCollectionState(collectionId: string, documentIds: DocumentId[]): Promise<void> {\n    const heads = await this.getHeads(documentIds);\n    const documents: Record<DocumentId, Heads> = Object.fromEntries(\n      heads.map((heads, index) => [documentIds[index], heads ?? []]),\n    );\n    this._collectionSynchronizer.setLocalCollectionState(collectionId, { documents });\n  }\n\n  async clearLocalCollectionState(collectionId: string): Promise<void> {\n    this._collectionSynchronizer.clearLocalCollectionState(collectionId);\n  }\n\n  private _onCollectionStateQueried(collectionId: string, peerId: PeerId): void {\n    this._collectionSynchronizer.onCollectionStateQueried(collectionId, peerId);\n  }\n\n  private _onCollectionStateReceived(collectionId: string, peerId: PeerId, state: unknown): void {\n    this._collectionSynchronizer.onRemoteStateReceived(collectionId, peerId, decodeCollectionState(state));\n  }\n\n  private _queryCollectionState(collectionId: string, peerId: PeerId): void {\n    this._echoNetworkAdapter.queryCollectionState(collectionId, peerId);\n  }\n\n  private _sendCollectionState(collectionId: string, peerId: PeerId, state: CollectionState): void {\n    this._echoNetworkAdapter.sendCollectionState(collectionId, peerId, encodeCollectionState(state));\n  }\n\n  private _onPeerConnected(peerId: PeerId): void {\n    this._collectionSynchronizer.onConnectionOpen(peerId);\n  }\n\n  private _onPeerDisconnected(peerId: PeerId): void {\n    this._collectionSynchronizer.onConnectionClosed(peerId);\n  }\n\n  private _onRemoteCollectionStateUpdated(collectionId: string, peerId: PeerId): void {\n    const localState = this._collectionSynchronizer.getLocalCollectionState(collectionId);\n    const remoteState = this._collectionSynchronizer.getRemoteCollectionStates(collectionId).get(peerId);\n\n    if (!localState || !remoteState) {\n      return;\n    }\n\n    const { different, missingOnLocal, missingOnRemote } = diffCollectionState(localState, remoteState);\n    const toReplicate = [...missingOnLocal, ...missingOnRemote, ...different];\n\n    if (toReplicate.length === 0) {\n      return;\n    }\n\n    log('replicating documents after collection sync', {\n      collectionId,\n      peerId,\n      toReplicate,\n      count: toReplicate.length,\n    });\n\n    // Load the documents so they will start syncing.\n    for (const documentId of toReplicate) {\n      this._repo.findWithProgress(documentId);\n    }\n  }\n\n  private _onHeadsChanged(documentId: DocumentId, heads: Heads): void {\n    const collectionsChanged = new Set<CollectionId>();\n    for (const collectionId of this._collectionSynchronizer.getRegisteredCollectionIds()) {\n      const state = this._collectionSynchronizer.getLocalCollectionState(collectionId);\n      if (state?.documents[documentId]) {\n        const newState = structuredClone(state);\n        newState.documents[documentId] = heads;\n        this._collectionSynchronizer.setLocalCollectionState(collectionId, newState);\n        collectionsChanged.add(collectionId as CollectionId);\n      }\n    }\n    for (const collectionId of collectionsChanged) {\n      this.collectionStateUpdated.emit({ collectionId });\n    }\n  }\n}\n\nconst waitForHeads = async (handle: DocHandle<DatabaseDirectory>, heads: Heads) => {\n  const unavailableHeads = new Set(heads);\n\n  await handle.whenReady();\n  await Event.wrap<DocHandleChangePayload<DatabaseDirectory>>(handle, 'change').waitForCondition(() => {\n    // Check if unavailable heads became available.\n    for (const changeHash of unavailableHeads.values()) {\n      if (changeIsPresentInDoc(handle.doc()!, changeHash)) {\n        unavailableHeads.delete(changeHash);\n      }\n    }\n\n    return unavailableHeads.size === 0;\n  });\n};\n\nconst changeIsPresentInDoc = (doc: Doc<any>, changeHash: string): boolean => {\n  return !!getBackend(doc).getChangeByHash(changeHash);\n};\n\nconst decodeCollectionState = (state: unknown): CollectionState => {\n  invariant(typeof state === 'object' && state !== null, 'Invalid state');\n\n  return state as CollectionState;\n};\n\nconst encodeCollectionState = (state: CollectionState): unknown => {\n  return state;\n};\n\nexport type CollectionSyncState = {\n  peers: PeerSyncState[];\n};\n\nexport type PeerSyncState = {\n  peerId: PeerId;\n  /**\n   * Documents that are present locally but not on the remote peer.\n   */\n  missingOnRemote: number;\n\n  /**\n   * Documents that are present on the remote peer but not locally.\n   */\n  missingOnLocal: number;\n\n  /**\n   * Documents that are present on both peers but have different heads.\n   */\n  differentDocuments: number;\n\n  /**\n   * Total number of documents locally.\n   */\n  localDocumentCount: number;\n\n  /**\n   * Total number of documents on the remote peer.\n   */\n  remoteDocumentCount: number;\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { next as am } from '@automerge/automerge';\nimport type { DocumentId, PeerId } from '@automerge/automerge-repo';\n\nimport { asyncReturn, Event, scheduleTask, scheduleTaskInterval } from '@dxos/async';\nimport { Resource, type Context } from '@dxos/context';\nimport { log } from '@dxos/log';\nimport { trace } from '@dxos/tracing';\nimport { defaultMap } from '@dxos/util';\n\nconst MIN_QUERY_INTERVAL = 5_000;\n\nconst POLL_INTERVAL = 30_000;\n\nexport type CollectionSynchronizerParams = {\n  sendCollectionState: (collectionId: string, peerId: PeerId, state: CollectionState) => void;\n  queryCollectionState: (collectionId: string, peerId: PeerId) => void;\n  shouldSyncCollection: (collectionId: string, peerId: PeerId) => boolean;\n};\n\n/**\n * Implements collection sync protocol.\n */\n@trace.resource()\nexport class CollectionSynchronizer extends Resource {\n  private readonly _sendCollectionState: CollectionSynchronizerParams['sendCollectionState'];\n  private readonly _queryCollectionState: CollectionSynchronizerParams['queryCollectionState'];\n  private readonly _shouldSyncCollection: CollectionSynchronizerParams['shouldSyncCollection'];\n\n  /**\n   * CollectionId -> State.\n   */\n  private readonly _perCollectionStates = new Map<string, PerCollectionState>();\n  private readonly _activeCollections = new Set<string>();\n\n  private readonly _connectedPeers = new Set<PeerId>();\n\n  public readonly remoteStateUpdated = new Event<{ collectionId: string; peerId: PeerId; newDocsAppeared: boolean }>();\n\n  constructor(params: CollectionSynchronizerParams) {\n    super();\n    this._sendCollectionState = params.sendCollectionState;\n    this._queryCollectionState = params.queryCollectionState;\n    this._shouldSyncCollection = params.shouldSyncCollection;\n  }\n\n  protected override async _open(ctx: Context): Promise<void> {\n    scheduleTaskInterval(\n      this._ctx,\n      async () => {\n        for (const collectionId of this._perCollectionStates.keys()) {\n          if (this._activeCollections.has(collectionId)) {\n            this.refreshCollection(collectionId);\n            await asyncReturn();\n          }\n        }\n      },\n      POLL_INTERVAL,\n    );\n  }\n\n  getRegisteredCollectionIds(): string[] {\n    return [...this._activeCollections];\n  }\n\n  getLocalCollectionState(collectionId: string): CollectionState | undefined {\n    return this._perCollectionStates.get(collectionId)?.localState;\n  }\n\n  setLocalCollectionState(collectionId: string, state: CollectionState): void {\n    this._activeCollections.add(collectionId);\n\n    log('setLocalCollectionState', { collectionId, state });\n    this._getOrCreatePerCollectionState(collectionId).localState = state;\n\n    queueMicrotask(async () => {\n      if (!this._ctx.disposed && this._activeCollections.has(collectionId)) {\n        this._refreshInterestedPeers(collectionId);\n        this.refreshCollection(collectionId);\n      }\n    });\n  }\n\n  clearLocalCollectionState(collectionId: string): void {\n    this._activeCollections.delete(collectionId);\n    this._perCollectionStates.delete(collectionId);\n    log('clearLocalCollectionState', { collectionId });\n  }\n\n  getRemoteCollectionStates(collectionId: string): ReadonlyMap<PeerId, CollectionState> {\n    return this._getOrCreatePerCollectionState(collectionId).remoteStates;\n  }\n\n  refreshCollection(collectionId: string): void {\n    let scheduleAnotherRefresh = false;\n    const state = this._getOrCreatePerCollectionState(collectionId);\n    for (const peerId of this._connectedPeers) {\n      if (state.interestedPeers.has(peerId)) {\n        const lastQueried = state.lastQueried.get(peerId) ?? 0;\n        if (Date.now() - lastQueried > MIN_QUERY_INTERVAL) {\n          state.lastQueried.set(peerId, Date.now());\n          this._queryCollectionState(collectionId, peerId);\n        } else {\n          scheduleAnotherRefresh = true;\n        }\n      }\n    }\n    if (scheduleAnotherRefresh) {\n      scheduleTask(this._ctx, () => this.refreshCollection(collectionId), MIN_QUERY_INTERVAL);\n    }\n  }\n\n  /**\n   * Callback when a connection to a peer is established.\n   */\n  onConnectionOpen(peerId: PeerId): void {\n    const spanId = getSpanName(peerId);\n    trace.spanStart({\n      id: spanId,\n      methodName: spanId,\n      instance: this,\n      parentCtx: this._ctx,\n      showInBrowserTimeline: true,\n      attributes: { peerId },\n    });\n    this._connectedPeers.add(peerId);\n\n    queueMicrotask(async () => {\n      if (this._ctx.disposed) {\n        return;\n      }\n      for (const [collectionId, state] of this._perCollectionStates.entries()) {\n        if (this._activeCollections.has(collectionId) && this._shouldSyncCollection(collectionId, peerId)) {\n          state.interestedPeers.add(peerId);\n          state.lastQueried.set(peerId, Date.now());\n          this._queryCollectionState(collectionId, peerId);\n        }\n      }\n    });\n  }\n\n  /**\n   * Callback when a connection to a peer is closed.\n   */\n  onConnectionClosed(peerId: PeerId): void {\n    this._connectedPeers.delete(peerId);\n\n    for (const perCollectionState of this._perCollectionStates.values()) {\n      perCollectionState.remoteStates.delete(peerId);\n    }\n  }\n\n  /**\n   * Callback when a peer queries the state of a collection.\n   */\n  onCollectionStateQueried(collectionId: string, peerId: PeerId): void {\n    const perCollectionState = this._getOrCreatePerCollectionState(collectionId);\n\n    if (perCollectionState.localState) {\n      this._sendCollectionState(collectionId, peerId, perCollectionState.localState);\n    }\n  }\n\n  /**\n   * Callback when a peer sends the state of a collection.\n   */\n  onRemoteStateReceived(collectionId: string, peerId: PeerId, state: CollectionState): void {\n    log('onRemoteStateReceived', { collectionId, peerId, state });\n    validateCollectionState(state);\n    const perCollectionState = this._getOrCreatePerCollectionState(collectionId);\n    const existingState = perCollectionState.remoteStates.get(peerId) ?? { documents: {} };\n    const diff = diffCollectionState(existingState, state);\n    const spanId = getSpanName(peerId);\n    if (diff.different.length === 0) {\n      trace.spanEnd(spanId);\n    } else {\n      trace.spanStart({\n        id: spanId,\n        methodName: spanId,\n        instance: this,\n        parentCtx: this._ctx,\n        showInBrowserTimeline: true,\n        attributes: { peerId },\n      });\n    }\n    if (diff.missingOnLocal.length > 0 || diff.different.length > 0) {\n      perCollectionState.remoteStates.set(peerId, state);\n      this.remoteStateUpdated.emit({ peerId, collectionId, newDocsAppeared: diff.missingOnLocal.length > 0 });\n    }\n  }\n\n  private _getOrCreatePerCollectionState(collectionId: string): PerCollectionState {\n    return defaultMap(this._perCollectionStates, collectionId, () => ({\n      localState: undefined,\n      remoteStates: new Map(),\n      interestedPeers: new Set(),\n      lastQueried: new Map(),\n    }));\n  }\n\n  private _refreshInterestedPeers(collectionId: string): void {\n    for (const peerId of this._connectedPeers) {\n      if (this._shouldSyncCollection(collectionId, peerId)) {\n        this._getOrCreatePerCollectionState(collectionId).interestedPeers.add(peerId);\n      } else {\n        this._getOrCreatePerCollectionState(collectionId).interestedPeers.delete(peerId);\n      }\n    }\n  }\n}\n\ntype PerCollectionState = {\n  localState?: CollectionState;\n  remoteStates: Map<PeerId, CollectionState>;\n  interestedPeers: Set<PeerId>;\n  lastQueried: Map<PeerId, number>;\n};\n\nexport type CollectionState = {\n  /**\n   * DocumentId -> Heads.\n   */\n  documents: Record<string, string[]>;\n};\n\nexport type CollectionStateDiff = {\n  missingOnRemote: DocumentId[];\n  missingOnLocal: DocumentId[];\n  different: DocumentId[];\n};\n\nexport const diffCollectionState = (local: CollectionState, remote: CollectionState): CollectionStateDiff => {\n  const allDocuments = new Set<DocumentId>([...Object.keys(local.documents), ...Object.keys(remote.documents)] as any);\n\n  const missingOnRemote: DocumentId[] = [];\n  const missingOnLocal: DocumentId[] = [];\n  const different: DocumentId[] = [];\n  for (const documentId of allDocuments) {\n    if (!local.documents[documentId]) {\n      missingOnLocal.push(documentId as DocumentId);\n    } else if (!remote.documents[documentId]) {\n      missingOnRemote.push(documentId as DocumentId);\n    } else if (!am.equals(local.documents[documentId], remote.documents[documentId])) {\n      different.push(documentId as DocumentId);\n    }\n  }\n\n  return {\n    missingOnRemote,\n    missingOnLocal,\n    different,\n  };\n};\n\nconst validateCollectionState = (state: CollectionState) => {\n  Object.entries(state.documents).forEach(([documentId, heads]) => {\n    if (!isValidDocumentId(documentId as DocumentId)) {\n      throw new Error(`Invalid documentId: ${documentId}`);\n    }\n    if (Array.isArray(heads) && heads.some((head) => typeof head !== 'string')) {\n      throw new Error(`Invalid heads: ${heads}`);\n    }\n  });\n};\n\nconst isValidDocumentId = (documentId: DocumentId) => {\n  return typeof documentId === 'string' && !documentId.includes(':');\n};\n\nconst getSpanName = (peerId: PeerId) => {\n  return `collection-sync-${peerId}`;\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { NetworkAdapter, type Message, type PeerId, type PeerMetadata } from '@automerge/automerge-repo';\n\nimport { synchronized, Trigger } from '@dxos/async';\nimport { LifecycleState } from '@dxos/context';\nimport { invariant } from '@dxos/invariant';\nimport { type PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport type { AutomergeProtocolMessage } from '@dxos/protocols';\nimport { isNonNullable } from '@dxos/util';\n\nimport {\n  type EchoReplicator,\n  type RemoteDocumentExistenceCheckParams,\n  type ReplicatorConnection,\n  type ShouldAdvertiseParams,\n  type ShouldSyncCollectionParams,\n} from './echo-replicator';\nimport {\n  isCollectionQueryMessage,\n  isCollectionStateMessage,\n  type CollectionQueryMessage,\n  type CollectionStateMessage,\n} from './network-protocol';\nimport { createIdFromSpaceKey } from '../common/space-id';\n\nexport interface NetworkDataMonitor {\n  recordPeerConnected(peerId: string): void;\n  recordPeerDisconnected(peerId: string): void;\n  recordMessageSent(message: Message, duration: number): void;\n  recordMessageReceived(message: Message): void;\n  recordMessageSendingFailed(message: Message): void;\n}\n\nexport type EchoNetworkAdapterParams = {\n  getContainingSpaceForDocument: (documentId: string) => Promise<PublicKey | null>;\n  isDocumentInRemoteCollection: (params: RemoteDocumentExistenceCheckParams) => Promise<boolean>;\n  onCollectionStateQueried: (collectionId: string, peerId: PeerId) => void;\n  onCollectionStateReceived: (collectionId: string, peerId: PeerId, state: unknown) => void;\n  monitor?: NetworkDataMonitor;\n};\n\ntype ConnectionEntry = {\n  isOpen: boolean;\n  connection: ReplicatorConnection;\n  reader: ReadableStreamDefaultReader<AutomergeProtocolMessage>;\n  writer: WritableStreamDefaultWriter<AutomergeProtocolMessage>;\n};\n\n/**\n * Manages a set of {@link EchoReplicator} instances.\n */\nexport class EchoNetworkAdapter extends NetworkAdapter {\n  private readonly _replicators = new Set<EchoReplicator>();\n  /**\n   * Remote peer id -> connection.\n   */\n  private readonly _connections = new Map<PeerId, ConnectionEntry>();\n  private _lifecycleState: LifecycleState = LifecycleState.CLOSED;\n  private readonly _connected = new Trigger();\n  private readonly _ready = new Trigger();\n\n  constructor(private readonly _params: EchoNetworkAdapterParams) {\n    super();\n  }\n\n  override isReady(): boolean {\n    return this._lifecycleState === LifecycleState.OPEN;\n  }\n\n  override whenReady(): Promise<void> {\n    return this._ready.wait();\n  }\n\n  override connect(peerId: PeerId, peerMetadata?: PeerMetadata | undefined): void {\n    this.peerId = peerId;\n    this.peerMetadata = peerMetadata;\n    this._connected.wake();\n  }\n\n  override send(message: Message): void {\n    this._send(message);\n  }\n\n  override disconnect(): void {\n    // No-op\n  }\n\n  @synchronized\n  async open(): Promise<void> {\n    if (this._lifecycleState === LifecycleState.OPEN) {\n      return;\n    }\n    this._lifecycleState = LifecycleState.OPEN;\n    this._ready.wake();\n  }\n\n  @synchronized\n  async close(): Promise<this | undefined> {\n    if (this._lifecycleState === LifecycleState.CLOSED) {\n      return this;\n    }\n\n    for (const replicator of this._replicators) {\n      await replicator.disconnect();\n    }\n    this._replicators.clear();\n\n    this._ready.reset();\n    this._lifecycleState = LifecycleState.CLOSED;\n  }\n\n  async whenConnected(): Promise<void> {\n    await this._connected.wait({ timeout: 10_000 });\n  }\n\n  public onConnectionAuthScopeChanged(peer: PeerId): void {\n    const entry = this._connections.get(peer);\n    if (entry) {\n      this._onConnectionAuthScopeChanged(entry.connection);\n    }\n  }\n\n  @synchronized\n  async addReplicator(replicator: EchoReplicator): Promise<void> {\n    invariant(this._lifecycleState === LifecycleState.OPEN);\n    invariant(this.peerId);\n    invariant(!this._replicators.has(replicator));\n\n    this._replicators.add(replicator);\n    await replicator.connect({\n      peerId: this.peerId,\n      onConnectionOpen: this._onConnectionOpen.bind(this),\n      onConnectionClosed: this._onConnectionClosed.bind(this),\n      onConnectionAuthScopeChanged: this._onConnectionAuthScopeChanged.bind(this),\n      isDocumentInRemoteCollection: this._params.isDocumentInRemoteCollection,\n      getContainingSpaceForDocument: this._params.getContainingSpaceForDocument,\n      getContainingSpaceIdForDocument: async (documentId) => {\n        const key = await this._params.getContainingSpaceForDocument(documentId);\n        return key ? createIdFromSpaceKey(key) : null;\n      },\n    });\n  }\n\n  @synchronized\n  async removeReplicator(replicator: EchoReplicator): Promise<void> {\n    invariant(this._lifecycleState === LifecycleState.OPEN);\n    invariant(this._replicators.has(replicator));\n    await replicator.disconnect();\n    this._replicators.delete(replicator);\n  }\n\n  async shouldAdvertise(peerId: PeerId, params: ShouldAdvertiseParams): Promise<boolean> {\n    const connection = this._connections.get(peerId);\n    if (!connection) {\n      return false;\n    }\n\n    return connection.connection.shouldAdvertise(params);\n  }\n\n  shouldSyncCollection(peerId: PeerId, params: ShouldSyncCollectionParams): boolean {\n    const connection = this._connections.get(peerId);\n    if (!connection) {\n      return false;\n    }\n\n    return connection.connection.shouldSyncCollection(params);\n  }\n\n  queryCollectionState(collectionId: string, targetId: PeerId): void {\n    const message: CollectionQueryMessage = {\n      type: 'collection-query',\n      senderId: this.peerId as PeerId,\n      targetId,\n      collectionId,\n    };\n    this._send(message);\n  }\n\n  sendCollectionState(collectionId: string, targetId: PeerId, state: unknown): void {\n    const message: CollectionStateMessage = {\n      type: 'collection-state',\n      senderId: this.peerId as PeerId,\n      targetId,\n      collectionId,\n      state,\n    };\n    this._send(message);\n  }\n\n  // TODO(dmaretskyi): Remove.\n  getPeersInterestedInCollection(collectionId: string): PeerId[] {\n    return Array.from(this._connections.values())\n      .map((connection) => {\n        return connection.connection.shouldSyncCollection({ collectionId })\n          ? (connection.connection.peerId as PeerId)\n          : null;\n      })\n      .filter(isNonNullable);\n  }\n\n  private _send(message: Message): void {\n    const connectionEntry = this._connections.get(message.targetId);\n    if (!connectionEntry) {\n      throw new Error('Connection not found.');\n    }\n\n    // TODO(dmaretskyi): Find a way to enforce backpressure on AM-repo.\n    const start = Date.now();\n    connectionEntry.writer\n      .write(message as AutomergeProtocolMessage)\n      .then(() => {\n        this._params.monitor?.recordMessageSent(message, Date.now() - start);\n      })\n      .catch((err) => {\n        if (connectionEntry.isOpen) {\n          log.catch(err);\n        }\n\n        this._params.monitor?.recordMessageSendingFailed(message);\n      });\n  }\n\n  private _onConnectionOpen(connection: ReplicatorConnection): void {\n    log('connection opened', { peerId: connection.peerId });\n    invariant(!this._connections.has(connection.peerId as PeerId));\n    const connectionEntry: ConnectionEntry = {\n      isOpen: true,\n      connection,\n      reader: connection.readable.getReader(),\n      writer: connection.writable.getWriter(),\n    };\n\n    this._connections.set(connection.peerId as PeerId, connectionEntry);\n\n    // Read inbound messages.\n    queueMicrotask(async () => {\n      try {\n        while (true) {\n          // TODO(dmaretskyi): Find a way to enforce backpressure on AM-repo.\n          const { done, value } = await connectionEntry.reader.read();\n          if (done) {\n            break;\n          }\n\n          this._onMessage(value as Message);\n        }\n      } catch (err) {\n        if (connectionEntry.isOpen) {\n          log.catch(err);\n        }\n      }\n    });\n\n    log('emit peer-candidate', { peerId: connection.peerId });\n    this._emitPeerCandidate(connection);\n    this._params.monitor?.recordPeerConnected(connection.peerId);\n  }\n\n  private _onMessage(message: Message): void {\n    if (isCollectionQueryMessage(message)) {\n      this._params.onCollectionStateQueried(message.collectionId, message.senderId);\n    } else if (isCollectionStateMessage(message)) {\n      this._params.onCollectionStateReceived(message.collectionId, message.senderId, message.state);\n    } else {\n      this.emit('message', message);\n    }\n    this._params.monitor?.recordMessageReceived(message);\n  }\n\n  private _onConnectionClosed(connection: ReplicatorConnection): void {\n    log('connection closed', { peerId: connection.peerId });\n    const entry = this._connections.get(connection.peerId as PeerId);\n    invariant(entry);\n\n    entry.isOpen = false;\n    this.emit('peer-disconnected', { peerId: connection.peerId as PeerId });\n    this._params.monitor?.recordPeerDisconnected(connection.peerId);\n\n    void entry.reader.cancel().catch((err) => log.catch(err));\n    void entry.writer.abort().catch((err) => log.catch(err));\n    this._connections.delete(connection.peerId as PeerId);\n  }\n\n  /**\n   * Trigger doc-synchronizer shared documents set recalculation. Happens on peer-candidate.\n   * TODO(y): replace with a proper API call when sharePolicy update becomes supported by automerge-repo\n   */\n  private _onConnectionAuthScopeChanged(connection: ReplicatorConnection): void {\n    log('Connection auth scope changed', { peerId: connection.peerId });\n    const entry = this._connections.get(connection.peerId as PeerId);\n    invariant(entry);\n    this.emit('peer-disconnected', { peerId: connection.peerId as PeerId });\n    this._emitPeerCandidate(connection);\n  }\n\n  private _emitPeerCandidate(connection: ReplicatorConnection): void {\n    this.emit('peer-candidate', {\n      peerId: connection.peerId as PeerId,\n      peerMetadata: createEchoPeerMetadata(),\n    });\n  }\n}\n\nexport const createEchoPeerMetadata = (): PeerMetadata =>\n  ({\n    // TODO(dmaretskyi): Refactor this.\n    dxos_peerSource: 'EchoNetworkAdapter',\n  }) as any;\n\nexport const isEchoPeerMetadata = (metadata: PeerMetadata): boolean =>\n  (metadata as any)?.dxos_peerSource === 'EchoNetworkAdapter';\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport type { Message } from '@automerge/automerge-repo';\n\nimport {\n  type CollectionQueryMessage,\n  type CollectionStateMessage,\n  MESSAGE_TYPE_COLLECTION_QUERY,\n  MESSAGE_TYPE_COLLECTION_STATE,\n} from '@dxos/protocols';\n\nexport { type CollectionStateMessage, type CollectionQueryMessage };\n\nexport const isCollectionQueryMessage = (message: Message): message is CollectionQueryMessage =>\n  message.type === MESSAGE_TYPE_COLLECTION_QUERY;\n\nexport const isCollectionStateMessage = (message: Message): message is CollectionStateMessage =>\n  message.type === MESSAGE_TYPE_COLLECTION_STATE;\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport type { Heads } from '@automerge/automerge';\nimport type { DocumentId } from '@automerge/automerge-repo';\n\nimport { headsEncoding } from '@dxos/indexing';\nimport type { BatchLevel, SublevelDB } from '@dxos/kv-store';\n\nexport type HeadsStoreParams = {\n  db: SublevelDB;\n};\n\nexport class HeadsStore {\n  private readonly _db: SublevelDB;\n\n  constructor({ db }: HeadsStoreParams) {\n    this._db = db;\n  }\n\n  setHeads(documentId: DocumentId, heads: Heads, batch: BatchLevel): void {\n    batch.put<DocumentId, Heads>(documentId, heads, {\n      sublevel: this._db,\n      keyEncoding: 'utf8',\n      valueEncoding: headsEncoding,\n    });\n  }\n\n  // TODO(dmaretskyi): Make batched.\n  async getHeads(documentIds: DocumentId[]): Promise<Array<Heads | undefined>> {\n    return this._db.getMany<DocumentId, Heads>(documentIds, {\n      keyEncoding: 'utf8',\n      valueEncoding: headsEncoding,\n    });\n  }\n}\n", "//\n// Copyright 2024 DXOS.org\n// s\n\nimport { type StorageAdapterInterface, type Chunk, type StorageKey } from '@automerge/automerge-repo';\nimport { type MixedEncoding } from 'level-transcoder';\n\nimport { LifecycleState, Resource } from '@dxos/context';\nimport { type BatchLevel, type SublevelDB } from '@dxos/kv-store';\nimport { type MaybePromise } from '@dxos/util';\n\nexport interface StorageAdapterDataMonitor {\n  recordBytesStored(count: number): void;\n  recordBytesLoaded(count: number): void;\n  recordLoadDuration(durationMs: number): void;\n  recordStoreDuration(durationMs: number): void;\n}\n\nexport type LevelDBStorageAdapterParams = {\n  db: SublevelDB;\n  callbacks?: StorageCallbacks;\n  monitor?: StorageAdapterDataMonitor;\n};\n\nexport type BeforeSaveParams = { path: StorageKey; batch: BatchLevel };\n\nexport interface StorageCallbacks {\n  beforeSave(params: BeforeSaveParams): MaybePromise<void>;\n  afterSave(path: StorageKey): MaybePromise<void>;\n}\n\nexport class LevelDBStorageAdapter extends Resource implements StorageAdapterInterface {\n  constructor(private readonly _params: LevelDBStorageAdapterParams) {\n    super();\n  }\n\n  async load(keyArray: StorageKey): Promise<Uint8Array | undefined> {\n    try {\n      if (this._lifecycleState !== LifecycleState.OPEN) {\n        // TODO(mykola): this should be an error.\n        return undefined;\n      }\n      const startMs = Date.now();\n      const chunk = await this._params.db.get<StorageKey, Uint8Array>(keyArray, { ...encodingOptions });\n      this._params.monitor?.recordBytesLoaded(chunk.byteLength);\n      this._params.monitor?.recordLoadDuration(Date.now() - startMs);\n      return chunk;\n    } catch (err: any) {\n      if (isLevelDbNotFoundError(err)) {\n        return undefined;\n      }\n      throw err;\n    }\n  }\n\n  async save(keyArray: StorageKey, binary: Uint8Array): Promise<void> {\n    if (this._lifecycleState !== LifecycleState.OPEN) {\n      return undefined;\n    }\n    const startMs = Date.now();\n    const batch = this._params.db.batch();\n\n    await this._params.callbacks?.beforeSave?.({ path: keyArray, batch });\n    batch.put<StorageKey, Uint8Array>(keyArray, Buffer.from(binary), {\n      ...encodingOptions,\n    });\n    await batch.write();\n    this._params.monitor?.recordBytesStored(binary.byteLength);\n\n    await this._params.callbacks?.afterSave?.(keyArray);\n    this._params.monitor?.recordStoreDuration(Date.now() - startMs);\n  }\n\n  async remove(keyArray: StorageKey): Promise<void> {\n    if (this._lifecycleState !== LifecycleState.OPEN) {\n      return undefined;\n    }\n    await this._params.db.del<StorageKey>(keyArray, { ...encodingOptions });\n  }\n\n  async loadRange(keyPrefix: StorageKey): Promise<Chunk[]> {\n    if (this._lifecycleState !== LifecycleState.OPEN) {\n      return [];\n    }\n    const startMs = Date.now();\n    const result: Chunk[] = [];\n    for await (const [key, value] of this._params.db.iterator<StorageKey, Uint8Array>({\n      gte: keyPrefix,\n      lte: [...keyPrefix, '\\uffff'],\n      ...encodingOptions,\n    })) {\n      result.push({\n        key,\n        data: value,\n      });\n      this._params.monitor?.recordBytesLoaded(value.byteLength);\n    }\n    this._params.monitor?.recordLoadDuration(Date.now() - startMs);\n    return result;\n  }\n\n  async removeRange(keyPrefix: StorageKey): Promise<void> {\n    if (this._lifecycleState !== LifecycleState.OPEN) {\n      return undefined;\n    }\n    const batch = this._params.db.batch();\n\n    for await (const [key] of this._params.db.iterator<StorageKey, Uint8Array>({\n      gte: keyPrefix,\n      lte: [...keyPrefix, '\\uffff'],\n      ...encodingOptions,\n    })) {\n      batch.del<StorageKey>(key, { ...encodingOptions });\n    }\n    await batch.write();\n  }\n}\n\nconst keyEncoder: MixedEncoding<StorageKey, Uint8Array, StorageKey> = {\n  encode: (key: StorageKey): Uint8Array =>\n    Buffer.from(key.map((k) => k.replaceAll('%', '%25').replaceAll('-', '%2D')).join('-')),\n  decode: (key: Uint8Array): StorageKey =>\n    Buffer.from(key)\n      .toString()\n      .split('-')\n      .map((k) => k.replaceAll('%2D', '-').replaceAll('%25', '%')),\n  format: 'buffer',\n};\n\nexport const encodingOptions = {\n  keyEncoding: keyEncoder,\n  valueEncoding: 'buffer',\n};\n\nconst isLevelDbNotFoundError = (err: any): boolean => err.code === 'LEVEL_NOT_FOUND';\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport type { CollectionId } from '@dxos/echo-protocol';\nimport { invariant } from '@dxos/invariant';\nimport { PublicKey, type SpaceId } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport {\n  type AutomergeReplicator,\n  type AutomergeReplicatorFactory,\n} from '@dxos/teleport-extension-automerge-replicator';\nimport { ComplexSet, defaultMap } from '@dxos/util';\n\nimport { type EchoReplicator, type EchoReplicatorContext, type ShouldAdvertiseParams } from './echo-replicator';\nimport { MeshReplicatorConnection } from './mesh-echo-replicator-connection';\nimport { getSpaceIdFromCollectionId } from './space-collection';\nimport { createIdFromSpaceKey } from '../common/space-id';\n\n// TODO(dmaretskyi): Move out of @dxos/echo-pipeline.\n\n/**\n * Used to replicate with other peers over the network.\n */\nexport class MeshEchoReplicator implements EchoReplicator {\n  /**\n   * We might have multiple connections open with a peer (one per space), but there'll be only one enabled\n   * connection at any given moment, because there's a single repo for all the spaces.\n   * When a connection closes (space was closed) it gets removed from the list and the next connection\n   * in the line gets enabled.\n   */\n  private readonly _connectionsPerPeer = new Map<string, MeshReplicatorConnection[]>();\n  /**\n   * A set of all connections (enabled and disabled).\n   */\n  private readonly _connections = new Set<MeshReplicatorConnection>();\n\n  /**\n   * spaceId -> deviceKey[]\n   */\n  private readonly _authorizedDevices = new Map<SpaceId, ComplexSet<PublicKey>>();\n\n  private _context: EchoReplicatorContext | null = null;\n\n  async connect(context: EchoReplicatorContext): Promise<void> {\n    this._context = context;\n  }\n\n  async disconnect(): Promise<void> {\n    for (const connection of this._connections) {\n      if (connection.isEnabled) {\n        this._context?.onConnectionClosed(connection);\n      }\n    }\n\n    for (const connection of this._connections) {\n      await connection.close();\n    }\n\n    this._connections.clear();\n    this._connectionsPerPeer.clear();\n\n    this._context = null;\n  }\n\n  createExtension(extensionFactory?: AutomergeReplicatorFactory): AutomergeReplicator {\n    invariant(this._context);\n\n    const connection: MeshReplicatorConnection = new MeshReplicatorConnection({\n      ownPeerId: this._context.peerId,\n      replicatorFactory: extensionFactory,\n      onRemoteConnected: async () => {\n        log('onRemoteConnected', { peerId: connection.peerId });\n        invariant(this._context);\n\n        const existingConnections = this._connectionsPerPeer.get(connection.peerId);\n        if (existingConnections?.length) {\n          const enabledConnection = existingConnections[0];\n          this._context.onConnectionAuthScopeChanged(enabledConnection);\n          existingConnections.push(connection);\n        } else {\n          this._connectionsPerPeer.set(connection.peerId, [connection]);\n          this._context.onConnectionOpen(connection);\n          connection.enable();\n        }\n      },\n      onRemoteDisconnected: async () => {\n        log('onRemoteDisconnected', { peerId: connection.peerId });\n\n        this._connections.delete(connection);\n\n        const existingConnections = this._connectionsPerPeer.get(connection.peerId) ?? [];\n\n        const index = existingConnections.indexOf(connection);\n        if (index < 0) {\n          log.warn('disconnected connection not found', { peerId: connection.peerId });\n          return;\n        }\n\n        existingConnections.splice(index, 1);\n\n        if (connection.isEnabled) {\n          this._context?.onConnectionClosed(connection);\n          connection.disable();\n\n          // Promote the next connection to enabled\n          if (existingConnections.length > 0) {\n            this._context?.onConnectionOpen(existingConnections[0]);\n            existingConnections[0].enable();\n          }\n        }\n      },\n      shouldAdvertise: async (params: ShouldAdvertiseParams) => {\n        log('shouldAdvertise', { peerId: connection.peerId, documentId: params.documentId });\n        invariant(this._context);\n        try {\n          const spaceKey = await this._context.getContainingSpaceForDocument(params.documentId);\n          if (!spaceKey) {\n            const remoteDocumentExists = await this._context.isDocumentInRemoteCollection({\n              documentId: params.documentId,\n              peerId: connection.peerId,\n            });\n            log('document not found locally for share policy check', {\n              peerId: connection.peerId,\n              documentId: params.documentId,\n              acceptDocument: remoteDocumentExists,\n            });\n\n            // If a document is not present locally return true if another peer claims to have it.\n            // Simply returning true will add the peer to \"generous peers list\" for this document which will\n            // start replication of the document after we receive, even if the peer is not in the corresponding space.\n            return remoteDocumentExists;\n          }\n\n          const spaceId = await createIdFromSpaceKey(spaceKey);\n\n          const authorizedDevices = this._authorizedDevices.get(spaceId);\n\n          if (!connection.remoteDeviceKey) {\n            log('device key not found for share policy check', {\n              peerId: connection.peerId,\n              documentId: params.documentId,\n            });\n            return false;\n          }\n\n          const isAuthorized = authorizedDevices?.has(connection.remoteDeviceKey) ?? false;\n          log('share policy check', {\n            localPeer: this._context.peerId,\n            remotePeer: connection.peerId,\n            documentId: params.documentId,\n            deviceKey: connection.remoteDeviceKey,\n            spaceKey,\n            isAuthorized,\n          });\n          return isAuthorized;\n        } catch (err) {\n          log.catch(err);\n          return false;\n        }\n      },\n      shouldSyncCollection: ({ collectionId }) => {\n        const spaceId = getSpaceIdFromCollectionId(collectionId as CollectionId);\n\n        const authorizedDevices = this._authorizedDevices.get(spaceId);\n\n        if (!connection.remoteDeviceKey) {\n          log('device key not found for collection sync check', {\n            peerId: connection.peerId,\n            collectionId,\n          });\n          return false;\n        }\n\n        const isAuthorized = authorizedDevices?.has(connection.remoteDeviceKey) ?? false;\n        return isAuthorized;\n      },\n    });\n    this._connections.add(connection);\n\n    return connection.replicatorExtension;\n  }\n\n  async authorizeDevice(spaceKey: PublicKey, deviceKey: PublicKey): Promise<void> {\n    log('authorizeDevice', { spaceKey, deviceKey });\n    const spaceId = await createIdFromSpaceKey(spaceKey);\n    defaultMap(this._authorizedDevices, spaceId, () => new ComplexSet(PublicKey.hash)).add(deviceKey);\n    for (const connection of this._connections) {\n      if (connection.isEnabled && connection.remoteDeviceKey && connection.remoteDeviceKey.equals(deviceKey)) {\n        if (this._connectionsPerPeer.has(connection.peerId)) {\n          this._context?.onConnectionAuthScopeChanged(connection);\n        }\n      }\n    }\n  }\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport * as A from '@automerge/automerge';\nimport { cbor } from '@automerge/automerge-repo';\n\nimport { Resource } from '@dxos/context';\nimport { invariant } from '@dxos/invariant';\nimport { type PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport type { AutomergeProtocolMessage } from '@dxos/protocols';\nimport { AutomergeReplicator, type AutomergeReplicatorFactory } from '@dxos/teleport-extension-automerge-replicator';\n\nimport type { ReplicatorConnection, ShouldAdvertiseParams, ShouldSyncCollectionParams } from './echo-replicator';\n\nconst DEFAULT_FACTORY: AutomergeReplicatorFactory = (params) => new AutomergeReplicator(...params);\n\nexport type MeshReplicatorConnectionParams = {\n  ownPeerId: string;\n  onRemoteConnected: () => void;\n  onRemoteDisconnected: () => void;\n  shouldAdvertise: (params: ShouldAdvertiseParams) => Promise<boolean>;\n  shouldSyncCollection: (params: ShouldSyncCollectionParams) => boolean;\n  replicatorFactory?: AutomergeReplicatorFactory;\n};\n\nexport class MeshReplicatorConnection extends Resource implements ReplicatorConnection {\n  public readable: ReadableStream<AutomergeProtocolMessage>;\n  public writable: WritableStream<AutomergeProtocolMessage>;\n  public remoteDeviceKey: PublicKey | null = null;\n\n  public readonly replicatorExtension: AutomergeReplicator;\n\n  private _remotePeerId: string | null = null;\n  private _isEnabled = false;\n\n  constructor(private readonly _params: MeshReplicatorConnectionParams) {\n    super();\n\n    let readableStreamController!: ReadableStreamDefaultController<AutomergeProtocolMessage>;\n    this.readable = new ReadableStream<AutomergeProtocolMessage>({\n      start: (controller) => {\n        readableStreamController = controller;\n        this._ctx.onDispose(() => controller.close());\n      },\n    });\n\n    this.writable = new WritableStream<AutomergeProtocolMessage>({\n      write: async (message: AutomergeProtocolMessage, controller) => {\n        invariant(this._isEnabled, 'Writing to a disabled connection');\n        try {\n          logSendSync(message);\n          await this.replicatorExtension.sendSyncMessage({ payload: cbor.encode(message) });\n        } catch (err) {\n          controller.error(err);\n          this._disconnectIfEnabled();\n        }\n      },\n    });\n\n    const createAutomergeReplicator = this._params.replicatorFactory ?? DEFAULT_FACTORY;\n    this.replicatorExtension = createAutomergeReplicator([\n      {\n        peerId: this._params.ownPeerId,\n      },\n      {\n        onStartReplication: async (info, remotePeerId /** Teleport ID */) => {\n          // Note: We store only one enabled extension per peer.\n          //       There can be a case where two connected peers have more than one teleport connection between them\n          //       and each of them uses different teleport connections to send messages.\n          //       It works because we receive messages from all teleport connections and Automerge Repo dedup them.\n          // TODO(mykola): Use only one teleport connection per peer.\n\n          this.remoteDeviceKey = remotePeerId;\n\n          // Set automerge id.\n          this._remotePeerId = info.id;\n\n          log('onStartReplication', { id: info.id, thisPeerId: this.peerId, remotePeerId: remotePeerId.toHex() });\n\n          this._params.onRemoteConnected();\n        },\n        onSyncMessage: async ({ payload }) => {\n          if (!this._isEnabled) {\n            return;\n          }\n          const message = cbor.decode(payload) as AutomergeProtocolMessage;\n          // Note: automerge Repo dedup messages.\n          readableStreamController.enqueue(message);\n        },\n        onClose: async () => {\n          this._disconnectIfEnabled();\n        },\n      },\n    ]);\n  }\n\n  private _disconnectIfEnabled(): void {\n    if (this._isEnabled) {\n      this._params.onRemoteDisconnected();\n    }\n  }\n\n  get peerId(): string {\n    invariant(this._remotePeerId != null, 'Remote peer has not connected yet.');\n    return this._remotePeerId;\n  }\n\n  get isEnabled() {\n    return this._isEnabled;\n  }\n\n  async shouldAdvertise(params: ShouldAdvertiseParams): Promise<boolean> {\n    return this._params.shouldAdvertise(params);\n  }\n\n  shouldSyncCollection(params: ShouldSyncCollectionParams): boolean {\n    return this._params.shouldSyncCollection(params);\n  }\n\n  /**\n   * Start exchanging messages with the remote peer.\n   * Call after the remote peer has connected.\n   */\n  enable(): void {\n    invariant(this._remotePeerId != null, 'Remote peer has not connected yet.');\n    this._isEnabled = true;\n  }\n\n  /**\n   * Stop exchanging messages with the remote peer.\n   */\n  disable(): void {\n    this._isEnabled = false;\n  }\n}\n\nconst logSendSync = (message: AutomergeProtocolMessage) => {\n  log('sendSyncMessage', () => {\n    const decodedSyncMessage = message.type === 'sync' && message.data ? A.decodeSyncMessage(message.data) : undefined;\n    return {\n      sync: decodedSyncMessage && {\n        headsLength: decodedSyncMessage.heads.length,\n        requesting: decodedSyncMessage.need.length > 0,\n        sendingChanges: decodedSyncMessage.changes.length > 0,\n      },\n      type: message.type,\n      from: message.senderId,\n      to: message.targetId,\n    };\n  });\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { type DocumentId } from '@automerge/automerge-repo';\n\nimport type { CollectionId } from '@dxos/echo-protocol';\nimport { invariant } from '@dxos/invariant';\nimport { SpaceId } from '@dxos/keys';\n\nexport const deriveCollectionIdFromSpaceId = (spaceId: SpaceId, rootDocumentId?: DocumentId): CollectionId =>\n  (rootDocumentId ? `space:${spaceId}:${rootDocumentId}` : `space:${spaceId}`) as CollectionId;\n\nexport const getSpaceIdFromCollectionId = (collectionId: CollectionId): SpaceId => {\n  const spaceId = collectionId.split(':')[1];\n  invariant(SpaceId.isValid(spaceId));\n  return spaceId;\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { type Message } from '@automerge/automerge-repo';\n\nimport { type TimeAware, trace } from '@dxos/tracing';\nimport { CircularBuffer, mapValues, SlidingWindowSummary, type SlidingWindowSummaryConfig } from '@dxos/util';\n\nimport { type NetworkDataMonitor } from './echo-network-adapter';\nimport { type StorageAdapterDataMonitor } from './leveldb-storage-adapter';\nimport { isCollectionQueryMessage, isCollectionStateMessage } from './network-protocol';\n\nconst PER_SECOND_RATE_AVG_WINDOW_SIZE = 5;\nconst DEFAULT_AVG_WINDOW_SIZE = 25;\n\nexport type EchoDataMonitorOptions = {\n  timeSeriesLength: number;\n};\n\n@trace.resource()\nexport class EchoDataMonitor implements StorageAdapterDataMonitor, NetworkDataMonitor, TimeAware {\n  private _lastTick = 0;\n\n  private _activeCounters = createLocalCounters();\n  private _lastCompleteCounters: LocalCounters | undefined;\n  private readonly _localTimeSeries = createLocalTimeSeries();\n  private readonly _storageAverages = createStorageAverages();\n  private readonly _replicationAverages = createNetworkAverages();\n  private readonly _sizeByMessage: { [type: string]: SlidingWindowSummary } = {};\n  private readonly _lastReceivedMessages = new CircularBuffer<StoredMessage>(100);\n  private readonly _lastSentMessages = new CircularBuffer<StoredMessage>(100);\n\n  private _connectionsCount = 0;\n\n  constructor(private readonly _params: EchoDataMonitorOptions = { timeSeriesLength: 30 }) {}\n\n  public tick(timeMs: number): void {\n    this._advanceTimeWindow(timeMs - this._lastTick);\n    this._lastTick = timeMs;\n  }\n\n  public computeStats(): EchoDataStats {\n    return {\n      meta: {\n        rateAverageOverSeconds: PER_SECOND_RATE_AVG_WINDOW_SIZE,\n      },\n      storage: {\n        reads: {\n          payloadSize: this._storageAverages.loadedChunkSize.average(),\n          opDuration: this._storageAverages.loadDuration.average(),\n          countPerSecond: this._storageAverages.loadsPerSecond.average(),\n        },\n        writes: {\n          payloadSize: this._storageAverages.storedChunkSize.average(),\n          opDuration: this._storageAverages.storeDuration.average(),\n          countPerSecond: this._storageAverages.storesPerSecond.average(),\n        },\n      },\n      replicator: {\n        connections: this._connectionsCount,\n        receivedMessages: {\n          payloadSize: this._replicationAverages.receivedMessageSize.average(),\n          countPerSecond: this._replicationAverages.receivedPerSecond.average(),\n        },\n        sentMessages: {\n          payloadSize: this._replicationAverages.sentMessageSize.average(),\n          opDuration: this._replicationAverages.sendDuration.average(),\n          countPerSecond: this._replicationAverages.sentPerSecond.average(),\n          failedPerSecond: this._replicationAverages.sendsFailedPerSecond.average(),\n        },\n        countByMessage: this._computeMessageHistogram('type'),\n        avgSizeByMessage: mapValues(this._sizeByMessage, (summary) => summary.average()),\n      },\n    };\n  }\n\n  public get connectionsCount() {\n    return this._connectionsCount;\n  }\n\n  /**\n   * @internal\n   */\n  get lastPerSecondStats() {\n    return this._lastCompleteCounters;\n  }\n\n  /**\n   * @internal\n   */\n  get timeSeries() {\n    return { ...this._localTimeSeries.storage, ...this._localTimeSeries.replication };\n  }\n\n  /**\n   * @internal\n   */\n  get messagesByPeerId() {\n    return this._computeMessageHistogram('peerId');\n  }\n\n  private _advanceTimeWindow(millisPassed: number): void {\n    const oldMetrics = Object.freeze(this._activeCounters);\n    this._activeCounters = createLocalCounters();\n    this._lastCompleteCounters = oldMetrics;\n    for (const peerId of Object.keys(oldMetrics.byPeerId)) {\n      this._activeCounters.byPeerId[peerId] = createMessageCounter();\n    }\n    this._addToTimeSeries(oldMetrics.replication, this._localTimeSeries.replication);\n    this._addToTimeSeries(oldMetrics.storage, this._localTimeSeries.storage);\n    // Prevent skewed measurements of incomplete buckets / after CPU freezes.\n    if (Math.abs(millisPassed - 1000) < 100) {\n      this._reportPerSecondRate(oldMetrics);\n    }\n  }\n\n  private _addToTimeSeries<T extends object>(values: T, timeSeries: TimeSeries<T>): void {\n    for (const [key, value] of Object.entries(values)) {\n      const values: (typeof value)[] = (timeSeries as any)[key];\n      values.push(value);\n      if (values.length > this._params.timeSeriesLength) {\n        values.shift();\n      }\n    }\n  }\n\n  private _reportPerSecondRate(metrics: LocalCounters): void {\n    const toReport: [string, number, SlidingWindowSummary][] = [\n      ['storage.load', metrics.storage.loadedChunks, this._storageAverages.loadsPerSecond],\n      ['storage.store', metrics.storage.storedChunks, this._storageAverages.storesPerSecond],\n      ['network.receive', metrics.replication.received, this._replicationAverages.receivedPerSecond],\n      ['network.send', metrics.replication.sent, this._replicationAverages.sentPerSecond],\n    ];\n    for (const [metricName, metric, summary] of toReport) {\n      summary.record(metric);\n      if (metric > 0) {\n        trace.metrics.distribution(`dxos.echo.${metricName}-rate`, metric);\n        trace.metrics.increment(`dxos.echo.${metricName}`, 1, { tags: { status: 'busy' } });\n      } else {\n        trace.metrics.increment(`dxos.echo.${metricName}`, 1, { tags: { status: 'idle' } });\n      }\n    }\n    this._replicationAverages.sendsFailedPerSecond.record(metrics.replication.failed);\n  }\n\n  public recordPeerConnected(peerId: string): void {\n    this._activeCounters.byPeerId[peerId] = createMessageCounter();\n    this._connectionsCount++;\n  }\n\n  public recordPeerDisconnected(peerId: string): void {\n    this._connectionsCount--;\n    delete this._activeCounters.byPeerId[peerId];\n  }\n\n  public recordBytesStored(count: number): void {\n    this._activeCounters.storage.storedChunks++;\n    this._activeCounters.storage.storedBytes += count;\n    this._storageAverages.storedChunkSize.record(count);\n    trace.metrics.distribution('dxos.echo.storage.bytes-stored', count, { unit: 'bytes' });\n  }\n\n  public recordLoadDuration(durationMs: number): void {\n    this._storageAverages.loadDuration.record(durationMs);\n  }\n\n  public recordStoreDuration(durationMs: number): void {\n    this._storageAverages.storeDuration.record(durationMs);\n  }\n\n  public recordBytesLoaded(count: number): void {\n    this._activeCounters.storage.loadedChunks++;\n    this._activeCounters.storage.loadedBytes += count;\n    this._storageAverages.loadedChunkSize.record(count);\n    trace.metrics.distribution('dxos.echo.storage.bytes-loaded', count, { unit: 'bytes' });\n  }\n\n  public recordMessageSent(message: Message, duration: number): void {\n    let metricsGroupName;\n    const bytes = getByteCount(message);\n    const tags = { type: message.type };\n    if (isAutomergeProtocolMessage(message)) {\n      this._activeCounters.replication.sent++;\n      this._replicationAverages.sendDuration.record(duration);\n      this._replicationAverages.sentMessageSize.record(bytes);\n      metricsGroupName = 'replication';\n    } else {\n      metricsGroupName = 'collection-sync';\n    }\n    trace.metrics.distribution(`dxos.echo.${metricsGroupName}.bytes-sent`, bytes, { unit: 'bytes', tags });\n    trace.metrics.distribution(`dxos.echo.${metricsGroupName}.send-duration`, duration, { unit: 'millisecond', tags });\n    trace.metrics.increment(`dxos.echo.${metricsGroupName}.send-status`, 1, { tags: { ...tags, success: true } });\n    const { messageSize, messageCounts } = this._getStatsForType(message);\n    messageSize.record(bytes);\n    messageCounts.sent++;\n    this._lastSentMessages.push({ type: message.type, peerId: message.targetId });\n  }\n\n  public recordMessageReceived(message: Message): void {\n    const bytes = getByteCount(message);\n    const tags = { type: message.type };\n    if (isAutomergeProtocolMessage(message)) {\n      this._activeCounters.replication.received++;\n      this._replicationAverages.receivedMessageSize.record(bytes);\n      trace.metrics.distribution('dxos.echo.replication.bytes-received', bytes, { unit: 'bytes', tags });\n    } else {\n      trace.metrics.distribution('dxos.echo.collection-sync.bytes-received', bytes, { unit: 'bytes', tags });\n    }\n    const { messageSize, messageCounts } = this._getStatsForType(message);\n    messageSize.record(bytes);\n    messageCounts.received++;\n    this._lastReceivedMessages.push({ type: message.type, peerId: message.senderId });\n  }\n\n  public recordMessageSendingFailed(message: Message): void {\n    const tags = { type: message.type, success: false };\n    if (isAutomergeProtocolMessage(message)) {\n      this._activeCounters.replication.failed++;\n      trace.metrics.increment('dxos.echo.replication.send-status', 1, { unit: 'bytes', tags });\n    } else {\n      trace.metrics.increment('dxos.echo.collection-sync.send-status', 1, { unit: 'bytes', tags });\n    }\n    const { messageCounts } = this._getStatsForType(message);\n    messageCounts.failed++;\n  }\n\n  private _getStatsForType(message: Message): { messageCounts: MessageCounts; messageSize: SlidingWindowSummary } {\n    const messageSize = (this._sizeByMessage[message.type] ??= createSlidingWindow());\n    const messageCounts = (this._activeCounters.byType[message.type] ??= createMessageCounter());\n    return { messageCounts, messageSize };\n  }\n\n  private _computeMessageHistogram(groupKey: keyof StoredMessage): MessageAttributeHistogram {\n    const result: MessageAttributeHistogram = {};\n    for (const receivedMessage of this._lastReceivedMessages) {\n      const counters = (result[receivedMessage[groupKey]] ??= { received: 0, sent: 0 });\n      counters.received++;\n    }\n    for (const receivedMessage of this._lastSentMessages) {\n      const counters = (result[receivedMessage[groupKey]] ??= { received: 0, sent: 0 });\n      counters.sent++;\n    }\n    return result;\n  }\n}\n\ntype BaseDataOpStats = {\n  payloadSize: number;\n  countPerSecond: number;\n};\n\nexport type TimedDataOpStats = BaseDataOpStats & { opDuration: number };\n\ntype TimeSeries<T extends object> = { [key in keyof T]: T[key][] };\n\ntype StorageCounts = {\n  storedChunks: number;\n  storedBytes: number;\n  loadedChunks: number;\n  loadedBytes: number;\n};\ntype StorageCountTimeSeries = TimeSeries<StorageCounts>;\n\ntype MessageCounts = {\n  sent: number;\n  received: number;\n  failed: number;\n};\ntype MessageCountTimeSeries = TimeSeries<MessageCounts>;\n\ntype MessageAttributeHistogram = {\n  [Message: string]: {\n    received: number;\n    sent: number;\n  };\n};\n\nexport type EchoDataStats = {\n  meta: {\n    rateAverageOverSeconds: number;\n  };\n  storage: {\n    reads: TimedDataOpStats;\n    writes: TimedDataOpStats;\n  };\n  replicator: {\n    connections: number;\n    receivedMessages: BaseDataOpStats;\n    sentMessages: TimedDataOpStats & { failedPerSecond: number };\n    avgSizeByMessage: { [Message: string]: number };\n    countByMessage: MessageAttributeHistogram;\n  };\n};\n\ntype StoredMessage = { type: string; peerId: string };\n\ntype StorageAverages = {\n  storedChunkSize: SlidingWindowSummary;\n  storesPerSecond: SlidingWindowSummary;\n  loadedChunkSize: SlidingWindowSummary;\n  loadsPerSecond: SlidingWindowSummary;\n  loadDuration: SlidingWindowSummary;\n  storeDuration: SlidingWindowSummary;\n};\n\n// TODO(burdon): Standardize: `sent`/`recv`.\ntype NetworkAverages = {\n  receivedMessageSize: SlidingWindowSummary;\n  receivedPerSecond: SlidingWindowSummary;\n  sentMessageSize: SlidingWindowSummary;\n  sentPerSecond: SlidingWindowSummary;\n  sendDuration: SlidingWindowSummary;\n  sendsFailedPerSecond: SlidingWindowSummary;\n};\n\ntype LocalCounters = {\n  storage: StorageCounts;\n  replication: MessageCounts;\n  byPeerId: { [peerId: string]: MessageCounts };\n  byType: { [type: string]: MessageCounts };\n};\n\ntype LocalTimeSeries = {\n  storage: StorageCountTimeSeries;\n  replication: MessageCountTimeSeries;\n};\n\nconst isAutomergeProtocolMessage = (message: Message) => {\n  return !(isCollectionQueryMessage(message) || isCollectionStateMessage(message));\n};\n\nconst createSlidingWindow = (overrides?: SlidingWindowSummaryConfig) =>\n  new SlidingWindowSummary({ dataPoints: DEFAULT_AVG_WINDOW_SIZE, precision: 2, ...overrides });\n\nconst createLocalCounters = (): LocalCounters => ({\n  storage: { loadedBytes: 0, storedBytes: 0, storedChunks: 0, loadedChunks: 0 },\n  replication: createMessageCounter(),\n  byPeerId: {},\n  byType: {},\n});\n\nconst createLocalTimeSeries = (): LocalTimeSeries => ({\n  storage: { loadedBytes: [], storedBytes: [], storedChunks: [], loadedChunks: [] },\n  replication: { sent: [], failed: [], received: [] },\n});\n\nconst createMessageCounter = (): MessageCounts => ({ sent: 0, received: 0, failed: 0 });\n\nconst createNetworkAverages = (): NetworkAverages => ({\n  receivedMessageSize: createSlidingWindow(),\n  sentMessageSize: createSlidingWindow(),\n  sendDuration: createSlidingWindow(),\n  receivedPerSecond: createSlidingWindow({ dataPoints: PER_SECOND_RATE_AVG_WINDOW_SIZE }),\n  sentPerSecond: createSlidingWindow({ dataPoints: PER_SECOND_RATE_AVG_WINDOW_SIZE }),\n  sendsFailedPerSecond: createSlidingWindow({ dataPoints: PER_SECOND_RATE_AVG_WINDOW_SIZE }),\n});\n\nconst createStorageAverages = (): StorageAverages => ({\n  storedChunkSize: createSlidingWindow(),\n  loadedChunkSize: createSlidingWindow(),\n  loadDuration: createSlidingWindow(),\n  storeDuration: createSlidingWindow(),\n  loadsPerSecond: createSlidingWindow({ dataPoints: PER_SECOND_RATE_AVG_WINDOW_SIZE }),\n  storesPerSecond: createSlidingWindow({ dataPoints: PER_SECOND_RATE_AVG_WINDOW_SIZE }),\n});\n\nconst getByteCount = (message: Message): number => {\n  return (\n    message.type.length +\n    message.senderId.length +\n    message.targetId.length +\n    (message.data?.byteLength ?? 0) +\n    (message.documentId?.length ?? 0)\n  );\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport {\n  type AnyDocumentId,\n  type AutomergeUrl,\n  type DocHandle,\n  type DocumentId,\n  type Repo,\n} from '@automerge/automerge-repo';\n\nimport { LifecycleState, Resource, type Context } from '@dxos/context';\nimport { todo } from '@dxos/debug';\nimport { createIdFromSpaceKey, SpaceDocVersion, type DatabaseDirectory } from '@dxos/echo-protocol';\nimport { IndexMetadataStore, IndexStore, Indexer } from '@dxos/indexing';\nimport { invariant } from '@dxos/invariant';\nimport { type PublicKey, type SpaceId } from '@dxos/keys';\nimport { type LevelDB } from '@dxos/kv-store';\nimport { IndexKind } from '@dxos/protocols/proto/dxos/echo/indexing';\nimport { trace } from '@dxos/tracing';\n\nimport { DataServiceImpl } from './data-service';\nimport { type DatabaseRoot } from './database-root';\nimport { createSelectedDocumentsIterator } from './documents-iterator';\nimport { QueryServiceImpl } from './query-service';\nimport { SpaceStateManager } from './space-state-manager';\nimport {\n  AutomergeHost,\n  FIND_PARAMS,\n  EchoDataMonitor,\n  deriveCollectionIdFromSpaceId,\n  type LoadDocOptions,\n  type CreateDocOptions,\n  type EchoReplicator,\n  type EchoDataStats,\n  type PeerIdProvider,\n  type RootDocumentSpaceKeyProvider,\n} from '../automerge';\n\nexport interface EchoHostIndexingConfig {\n  /**\n   * @default true\n   */\n  fullText: boolean;\n\n  /**\n   * @default false\n   */\n  vector: boolean;\n}\n\nconst DEFAULT_INDEXING_CONFIG: EchoHostIndexingConfig = {\n  // TODO(dmaretskyi): Disabled by default since embedding generation is expensive.\n  fullText: false,\n  vector: false,\n};\n\nexport type EchoHostParams = {\n  kv: LevelDB;\n  peerIdProvider?: PeerIdProvider;\n  getSpaceKeyByRootDocumentId?: RootDocumentSpaceKeyProvider;\n\n  indexing?: Partial<EchoHostIndexingConfig>;\n};\n\n/**\n * Host for the Echo database.\n * Manages multiple spaces.\n * Stores data to disk.\n * Can sync with pluggable data replicators.\n */\nexport class EchoHost extends Resource {\n  private readonly _indexMetadataStore: IndexMetadataStore;\n  private readonly _indexer: Indexer;\n  private readonly _automergeHost: AutomergeHost;\n  private readonly _queryService: QueryServiceImpl;\n  private readonly _dataService: DataServiceImpl;\n  private readonly _spaceStateManager = new SpaceStateManager();\n  private readonly _echoDataMonitor: EchoDataMonitor;\n\n  constructor({ kv, indexing = {}, peerIdProvider, getSpaceKeyByRootDocumentId }: EchoHostParams) {\n    super();\n\n    const indexingConfig = { ...DEFAULT_INDEXING_CONFIG, ...indexing };\n\n    this._indexMetadataStore = new IndexMetadataStore({ db: kv.sublevel('index-metadata') });\n    this._echoDataMonitor = new EchoDataMonitor();\n    this._automergeHost = new AutomergeHost({\n      db: kv,\n      dataMonitor: this._echoDataMonitor,\n      indexMetadataStore: this._indexMetadataStore,\n      peerIdProvider,\n      getSpaceKeyByRootDocumentId,\n    });\n\n    this._indexer = new Indexer({\n      db: kv,\n      indexStore: new IndexStore({ db: kv.sublevel('index-storage') }),\n      metadataStore: this._indexMetadataStore,\n      loadDocuments: createSelectedDocumentsIterator(this._automergeHost),\n      indexCooldownTime: process.env.NODE_ENV === 'test' ? 0 : undefined,\n    });\n    void this._indexer.setConfig({\n      enabled: true,\n      indexes: [\n        //\n        { kind: IndexKind.Kind.SCHEMA_MATCH },\n        { kind: IndexKind.Kind.GRAPH },\n\n        ...(indexingConfig.fullText ? [{ kind: IndexKind.Kind.FULL_TEXT }] : []),\n        ...(indexingConfig.vector ? [{ kind: IndexKind.Kind.VECTOR }] : []),\n      ],\n    });\n\n    this._queryService = new QueryServiceImpl({\n      automergeHost: this._automergeHost,\n      indexer: this._indexer,\n      spaceStateManager: this._spaceStateManager,\n    });\n\n    this._dataService = new DataServiceImpl({\n      automergeHost: this._automergeHost,\n      spaceStateManager: this._spaceStateManager,\n      updateIndexes: async () => {\n        await this._indexer.updateIndexes();\n      },\n    });\n\n    trace.diagnostic<EchoStatsDiagnostic>({\n      id: 'echo-stats',\n      name: 'Echo Stats',\n      fetch: async () => {\n        return {\n          dataStats: this._echoDataMonitor.computeStats(),\n          loadedDocsCount: this._automergeHost.loadedDocsCount,\n        };\n      },\n    });\n\n    trace.diagnostic({\n      id: 'database-roots',\n      name: 'Database Roots',\n      fetch: async () => {\n        return Array.from(this._spaceStateManager.roots.values()).map((root) => ({\n          url: root.url,\n          isLoaded: root.isLoaded,\n          spaceKey: root.getSpaceKey(),\n          inlineObjects: root.getInlineObjectCount(),\n          linkedObjects: root.getLinkedObjectCount(),\n        }));\n      },\n    });\n\n    trace.diagnostic({\n      id: 'database-root-metrics',\n      name: 'Database Roots (with metrics)',\n      fetch: async () => {\n        return Array.from(this._spaceStateManager.roots.values()).map((root) => ({\n          url: root.url,\n          isLoaded: root.isLoaded,\n          spaceKey: root.getSpaceKey(),\n          inlineObjects: root.getInlineObjectCount(),\n          linkedObjects: root.getLinkedObjectCount(),\n          ...(root.measureMetrics() ?? {}),\n        }));\n      },\n    });\n  }\n\n  get queryService(): QueryServiceImpl {\n    return this._queryService;\n  }\n\n  get dataService(): DataServiceImpl {\n    return this._dataService;\n  }\n\n  /**\n   * @deprecated To be abstracted away.\n   */\n  get automergeRepo(): Repo {\n    return this._automergeHost.repo;\n  }\n\n  get roots(): ReadonlyMap<DocumentId, DatabaseRoot> {\n    return this._spaceStateManager.roots;\n  }\n\n  protected override async _open(ctx: Context): Promise<void> {\n    await this._automergeHost.open();\n    await this._indexer.open(ctx);\n    await this._queryService.open(ctx);\n    await this._spaceStateManager.open(ctx);\n\n    this._spaceStateManager.spaceDocumentListUpdated.on(this._ctx, (e) => {\n      if (e.previousRootId) {\n        void this._automergeHost.clearLocalCollectionState(deriveCollectionIdFromSpaceId(e.spaceId, e.previousRootId));\n      }\n      // TODO(yaroslav): remove collection without spaceRootId after release (production<->staging interop)\n      void this._automergeHost.updateLocalCollectionState(deriveCollectionIdFromSpaceId(e.spaceId), e.documentIds);\n      void this._automergeHost.updateLocalCollectionState(\n        deriveCollectionIdFromSpaceId(e.spaceId, e.spaceRootId),\n        e.documentIds,\n      );\n    });\n    this._automergeHost.documentsSaved.on(this._ctx, () => {\n      this._queryService.invalidateQueries();\n    });\n  }\n\n  protected override async _close(ctx: Context): Promise<void> {\n    await this._queryService.close(ctx);\n    await this._spaceStateManager.close(ctx);\n    await this._indexer.close(ctx);\n    await this._automergeHost.close();\n  }\n\n  /**\n   * Flush all pending writes to the underlying storage.\n   */\n  async flush(): Promise<void> {\n    await this._automergeHost.repo.flush();\n  }\n\n  /**\n   * Perform any pending index updates.\n   */\n  async updateIndexes(): Promise<void> {\n    await this._indexer.updateIndexes();\n  }\n\n  /**\n   * Loads the document handle from the repo and waits for it to be ready.\n   */\n  async loadDoc<T>(ctx: Context, documentId: AnyDocumentId, opts?: LoadDocOptions): Promise<DocHandle<T>> {\n    return await this._automergeHost.loadDoc(ctx, documentId, opts);\n  }\n\n  async exportDoc(ctx: Context, id: AnyDocumentId): Promise<Uint8Array> {\n    return await this._automergeHost.exportDoc(ctx, id);\n  }\n\n  /**\n   * Create new persisted document.\n   */\n  createDoc<T>(initialValue?: T, opts?: CreateDocOptions): DocHandle<T> {\n    return this._automergeHost.createDoc(initialValue, opts);\n  }\n\n  /**\n   * Create new space root.\n   */\n  async createSpaceRoot(spaceKey: PublicKey): Promise<DatabaseRoot> {\n    invariant(this._lifecycleState === LifecycleState.OPEN);\n    const spaceId = await createIdFromSpaceKey(spaceKey);\n\n    const automergeRoot = this._automergeHost.createDoc<DatabaseDirectory>({\n      version: SpaceDocVersion.CURRENT,\n      access: { spaceKey: spaceKey.toHex() },\n\n      // Better to initialize them right away to avoid merge conflicts and data loss that can occur if those maps get created on the fly.\n      objects: {},\n      links: {},\n    });\n\n    await this._automergeHost.flush({ documentIds: [automergeRoot.documentId] });\n\n    return await this.openSpaceRoot(spaceId, automergeRoot.url);\n  }\n\n  // TODO(dmaretskyi): Change to document id.\n  async openSpaceRoot(spaceId: SpaceId, automergeUrl: AutomergeUrl): Promise<DatabaseRoot> {\n    invariant(this._lifecycleState === LifecycleState.OPEN);\n    const handle = await this._automergeHost.repo.find<DatabaseDirectory>(automergeUrl, FIND_PARAMS);\n    await handle.whenReady();\n\n    return this._spaceStateManager.assignRootToSpace(spaceId, handle);\n  }\n\n  // TODO(dmaretskyi): Change to document id.\n  async closeSpaceRoot(automergeUrl: AutomergeUrl): Promise<void> {\n    todo();\n  }\n\n  /**\n   * Install data replicator.\n   */\n  async addReplicator(replicator: EchoReplicator): Promise<void> {\n    await this._automergeHost.addReplicator(replicator);\n  }\n\n  /**\n   * Remove data replicator.\n   */\n  async removeReplicator(replicator: EchoReplicator): Promise<void> {\n    await this._automergeHost.removeReplicator(replicator);\n  }\n}\n\nexport type { EchoDataStats };\n\nexport type EchoStatsDiagnostic = {\n  loadedDocsCount: number;\n  dataStats: EchoDataStats;\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport * as A from '@automerge/automerge';\nimport { type DocumentId } from '@automerge/automerge-repo';\n\nimport { Context } from '@dxos/context';\nimport { DatabaseDirectory, SpaceDocVersion } from '@dxos/echo-protocol';\nimport { type IdToHeads, type ObjectSnapshot } from '@dxos/indexing';\nimport { invariant } from '@dxos/invariant';\nimport { log } from '@dxos/log';\nimport { ObjectPointerVersion, objectPointerCodec } from '@dxos/protocols';\n\nimport { type AutomergeHost } from '../automerge';\n\nconst LOG_VIEW_OPERATION_THRESHOLD = 300;\n\n/**\n * Factory for `loadDocuments` iterator.\n */\nexport const createSelectedDocumentsIterator = (automergeHost: AutomergeHost) =>\n  /**\n   * Get object data blobs from Automerge Repo by ids.\n   */\n  // TODO(mykola): Unload automerge handles after usage.\n  async function* loadDocuments(objects: IdToHeads): AsyncGenerator<ObjectSnapshot[], void, void> {\n    for (const [id, heads] of objects.entries()) {\n      try {\n        const { documentId, objectId } = objectPointerCodec.decode(id);\n        const handle = await automergeHost.loadDoc<DatabaseDirectory>(Context.default(), documentId as DocumentId);\n\n        let doc = handle.doc();\n        invariant(doc);\n\n        const currentHeads = A.getHeads(doc);\n\n        // Checkout the requested version of the document.\n        if (!A.equals(currentHeads, heads)) {\n          const begin = Date.now();\n          // `view` can take a long time even if the document is already at the right version.\n          doc = A.view(doc, heads);\n          const end = Date.now();\n          if (end - begin > LOG_VIEW_OPERATION_THRESHOLD) {\n            log('Checking out document version is taking too long', {\n              duration: end - begin,\n              requestedHeads: heads,\n              originalHeads: currentHeads,\n            });\n          }\n        }\n\n        // Skip outdated docs.\n        if (doc.version !== SpaceDocVersion.CURRENT) {\n          continue;\n        }\n\n        if (!doc.objects?.[objectId]) {\n          continue;\n        }\n\n        // Upgrade V0 object pointers to V1.\n        let newId = id;\n        if (objectPointerCodec.getVersion(id) === ObjectPointerVersion.V0) {\n          const spaceKey = DatabaseDirectory.getSpaceKey(doc) ?? undefined;\n          newId = objectPointerCodec.encode({ documentId, objectId, spaceKey });\n        }\n\n        yield [{ id: newId, object: doc.objects![objectId], heads }];\n      } catch (error) {\n        log.error('Error loading document', { heads, id, error });\n      }\n    }\n  };\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { getHeads } from '@automerge/automerge';\nimport { type DocHandle, type DocumentId } from '@automerge/automerge-repo';\nimport { Schema } from 'effect';\n\nimport { DeferredTask, scheduleMicroTask, synchronized } from '@dxos/async';\nimport { Stream } from '@dxos/codec-protobuf/stream';\nimport { Context, Resource } from '@dxos/context';\nimport { raise } from '@dxos/debug';\nimport { DatabaseDirectory, QueryAST } from '@dxos/echo-protocol';\nimport { type IdToHeads, type Indexer, type ObjectSnapshot } from '@dxos/indexing';\nimport { log } from '@dxos/log';\nimport { objectPointerCodec } from '@dxos/protocols';\nimport { type IndexConfig } from '@dxos/protocols/proto/dxos/echo/indexing';\nimport {\n  type QueryRequest,\n  type QueryResponse,\n  type QueryResult,\n  type QueryService,\n} from '@dxos/protocols/proto/dxos/echo/query';\nimport { trace } from '@dxos/tracing';\n\nimport type { SpaceStateManager } from './space-state-manager';\nimport { type AutomergeHost } from '../automerge';\nimport { QueryExecutor } from '../query';\n\nexport type QueryServiceParams = {\n  indexer: Indexer;\n  automergeHost: AutomergeHost;\n  spaceStateManager: SpaceStateManager;\n};\n\n/**\n * Represents an active query (stream and query state connected to that stream).\n */\ntype ActiveQuery = {\n  executor: QueryExecutor;\n  /**\n   * Schedule re-execution of the query if true.\n   */\n  dirty: boolean;\n\n  open: boolean;\n\n  firstResult: boolean;\n\n  sendResults: (results: QueryResult[]) => void;\n  onError: (err: Error) => void;\n\n  close: () => Promise<void>;\n};\n\n@trace.resource()\nexport class QueryServiceImpl extends Resource implements QueryService {\n  private readonly _queries = new Set<ActiveQuery>();\n\n  private _updateQueries!: DeferredTask;\n\n  // TODO(burdon): OK for options, but not params. Pass separately and type readonly here.\n  constructor(private readonly _params: QueryServiceParams) {\n    super();\n\n    trace.diagnostic({\n      id: 'active-queries',\n      name: 'Active Queries',\n      fetch: () => {\n        return Array.from(this._queries).map((query) => {\n          return {\n            query: JSON.stringify(query.executor.query),\n            plan: JSON.stringify(query.executor.plan),\n            trace: JSON.stringify(query.executor.trace),\n          };\n        });\n      },\n    });\n  }\n\n  override async _open(): Promise<void> {\n    this._params.indexer.updated.on(this._ctx, () => this.invalidateQueries());\n\n    this._updateQueries = new DeferredTask(this._ctx, this._executeQueries.bind(this));\n  }\n\n  @synchronized\n  override async _close(): Promise<void> {\n    await this._updateQueries.join();\n    await Promise.all(Array.from(this._queries).map((query) => query.close()));\n  }\n\n  async setConfig(config: IndexConfig): Promise<void> {\n    await this._params.indexer.setConfig(config);\n  }\n\n  execQuery(request: QueryRequest): Stream<QueryResponse> {\n    return new Stream<QueryResponse>(({ next, close, ctx }) => {\n      const queryEntry = this._createQuery(ctx, request, next, close, close);\n      scheduleMicroTask(ctx, async () => {\n        await queryEntry.executor.open();\n        queryEntry.open = true;\n        this._updateQueries.schedule();\n      });\n      return queryEntry.close;\n    });\n  }\n\n  /**\n   * Re-index all loaded documents.\n   */\n  async reindex(): Promise<void> {\n    log('Reindexing all documents...');\n    const iterator = createDocumentsIterator(this._params.automergeHost);\n    const ids: IdToHeads = new Map();\n    for await (const documents of iterator()) {\n      for (const { id, heads } of documents) {\n        ids.set(id, heads);\n      }\n      if (ids.size % 100 === 0) {\n        log('Collected documents...', { count: ids.size });\n      }\n    }\n\n    log('Marking all documents as dirty...', { count: ids.size });\n    await this._params.indexer.reindex(ids);\n  }\n\n  /**\n   * Schedule re-execution of all queries.\n   */\n  invalidateQueries() {\n    for (const query of this._queries) {\n      query.dirty = true;\n    }\n    this._updateQueries.schedule();\n  }\n\n  private _createQuery(\n    ctx: Context,\n    request: QueryRequest,\n    onResults: (respose: QueryResponse) => void,\n    onError: (err: Error) => void,\n    onClose: () => void,\n  ): ActiveQuery {\n    const parsedQuery = QueryAST.Query.pipe(Schema.decodeUnknownSync)(JSON.parse(request.query));\n    const queryEntry: ActiveQuery = {\n      executor: new QueryExecutor({\n        indexer: this._params.indexer,\n        automergeHost: this._params.automergeHost,\n        queryId: request.queryId ?? raise(new Error('query id required')),\n        query: parsedQuery,\n        reactivity: request.reactivity,\n        spaceStateManager: this._params.spaceStateManager,\n      }),\n      dirty: true,\n      open: false,\n      firstResult: true,\n      sendResults: (results) => {\n        if (ctx.disposed) {\n          return;\n        }\n        onResults({ queryId: request.queryId, results });\n      },\n      onError,\n      close: async () => {\n        onClose();\n        await queryEntry.executor.close();\n        this._queries.delete(queryEntry);\n      },\n    };\n    this._queries.add(queryEntry);\n    return queryEntry;\n  }\n\n  @trace.span({ showInBrowserTimeline: true })\n  private async _executeQueries() {\n    // TODO(dmaretskyi): How do we integrate this tracing info into the tracing API.\n    const begin = performance.now();\n    let count = 0;\n    await Promise.all(\n      Array.from(this._queries).map(async (query) => {\n        if (!query.dirty || !query.open) {\n          return;\n        }\n        count++;\n\n        try {\n          const { changed } = await query.executor.execQuery();\n          query.dirty = false;\n          if (changed || query.firstResult) {\n            query.firstResult = false;\n            query.sendResults(query.executor.getResults());\n          }\n        } catch (err) {\n          log.catch(err);\n        }\n      }),\n    );\n    log.verbose('executed queries', { count, duration: performance.now() - begin });\n  }\n}\n\n/**\n * Factory for `getAllDocuments` iterator.\n */\n// TODO(dmaretskyi): Get roots from echo-host.\nconst createDocumentsIterator = (automergeHost: AutomergeHost) =>\n  /**\n   * Recursively get all object data blobs from loaded documents from Automerge Repo.\n   */\n  // TODO(mykola): Unload automerge handles after usage.\n  async function* getAllDocuments(): AsyncGenerator<ObjectSnapshot[], void, void> {\n    /** visited automerge handles */\n    const visited = new Set<string>();\n\n    async function* getObjectsFromHandle(handle: DocHandle<DatabaseDirectory>): AsyncGenerator<ObjectSnapshot[]> {\n      if (visited.has(handle.documentId) || !handle.isReady()) {\n        return;\n      }\n\n      const doc = handle.doc()!;\n      const spaceKey = DatabaseDirectory.getSpaceKey(doc) ?? undefined;\n      if (doc.objects) {\n        yield Object.entries(doc.objects as { [key: string]: any }).map(([objectId, object]) => {\n          return {\n            id: objectPointerCodec.encode({ documentId: handle.documentId, objectId, spaceKey }),\n            object,\n            heads: getHeads(doc),\n          };\n        });\n      }\n\n      if (doc.links) {\n        for (const id of Object.values(doc.links as { [echoId: string]: string })) {\n          const urlString = id.toString();\n          if (visited.has(urlString)) {\n            continue;\n          }\n          const linkHandle = await automergeHost.loadDoc<DatabaseDirectory>(Context.default(), urlString as DocumentId);\n          for await (const result of getObjectsFromHandle(linkHandle)) {\n            yield result;\n          }\n        }\n      }\n\n      visited.add(handle.documentId);\n    }\n\n    // TODO(mykola): Use list of roots instead of iterating over all handles.\n    for (const handle of Object.values(automergeHost.repo.handles)) {\n      if (visited.has(handle.documentId)) {\n        continue;\n      }\n      for await (const result of getObjectsFromHandle(handle)) {\n        yield result;\n      }\n      visited.add(handle.documentId);\n    }\n  };\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport type { AutomergeUrl, DocumentId } from '@automerge/automerge-repo';\nimport { Match } from 'effect';\n\nimport { Context, ContextDisposedError, LifecycleState, Resource } from '@dxos/context';\nimport { DatabaseDirectory, isEncodedReference, ObjectStructure, type QueryAST } from '@dxos/echo-protocol';\nimport { EscapedPropPath, type FindResult, type Indexer } from '@dxos/indexing';\nimport { invariant } from '@dxos/invariant';\nimport { DXN, type ObjectId, PublicKey, type SpaceId } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { objectPointerCodec } from '@dxos/protocols';\nimport { type QueryReactivity, type QueryResult } from '@dxos/protocols/proto/dxos/echo/query';\nimport { getDeep, isNonNullable } from '@dxos/util';\n\nimport type { QueryPlan } from './plan';\nimport { QueryPlanner } from './query-planner';\nimport type { AutomergeHost } from '../automerge';\nimport { createIdFromSpaceKey } from '../common';\nimport type { SpaceStateManager } from '../db-host';\nimport { filterMatchObject } from '../filter';\n\ntype QueryExecutorOptions = {\n  indexer: Indexer;\n  automergeHost: AutomergeHost;\n  spaceStateManager: SpaceStateManager;\n\n  queryId: string;\n  query: QueryAST.Query;\n  reactivity: QueryReactivity;\n};\n\ntype QueryExecutionResult = {\n  /**\n   * Whether the query results have changed since the last execution.\n   */\n  changed: boolean;\n};\n\n/**\n * Represents an item in the query working set during execution.\n */\ntype QueryItem = {\n  objectId: ObjectId;\n  documentId: DocumentId;\n  spaceId: SpaceId;\n  doc: ObjectStructure;\n};\n\n/**\n * Recursive data structure that represents the execution trace of a query.\n */\nexport type ExecutionTrace = {\n  name: string;\n  details: string;\n\n  objectCount: number;\n  documentsLoaded: number;\n  indexHits: number;\n\n  executionTime: number;\n  indexQueryTime: number;\n  documentLoadTime: number;\n\n  children: ExecutionTrace[];\n};\n\nexport const ExecutionTrace = Object.freeze({\n  makeEmpty: (): ExecutionTrace => ({\n    name: 'Empty',\n    details: '',\n    objectCount: 0,\n    documentsLoaded: 0,\n    indexHits: 0,\n    indexQueryTime: 0,\n    documentLoadTime: 0,\n    executionTime: 0,\n    children: [],\n  }),\n  format: (trace: ExecutionTrace): string => {\n    const go = (trace: ExecutionTrace, indent: number): string => {\n      return [\n        `${' '.repeat(indent)} - ${trace.name}(${trace.details})`,\n        `${' '.repeat(indent)}   objects: ${trace.objectCount}  docs: ${trace.documentsLoaded}  index hits: ${trace.indexHits} | total: ${trace.executionTime.toFixed(0)}ms  index: ${trace.indexQueryTime.toFixed(0)}ms  load: ${trace.documentLoadTime.toFixed(0)}ms`,\n        '',\n        ...trace.children.map((child) => go(child, indent + 2)),\n      ].join('\\n');\n    };\n    return go(trace, 0);\n  },\n});\n\ntype StepExecutionResult = {\n  workingSet: QueryItem[];\n  trace: ExecutionTrace;\n};\n\nconst TRACE_QUERY_EXECUTION = false;\n\n/**\n * Executes query plans against the Indexer and AutomergeHost.\n *\n * The QueryExecutor is responsible for:\n * - Executing query plans step by step\n * - Managing the working set of query results\n * - Loading documents from the database\n * - Tracking execution performance metrics\n * - Handling different types of query operations (select, filter, traverse, etc.)\n */\nexport class QueryExecutor extends Resource {\n  private readonly _indexer: Indexer;\n  private readonly _automergeHost: AutomergeHost;\n  private readonly _spaceStateManager: SpaceStateManager;\n  /**\n   * Id of this query.\n   */\n  private readonly _id: string;\n  private readonly _query: QueryAST.Query;\n  // TODO(dmaretskyi): Might be used in the future.\n  private readonly _reactivity: QueryReactivity;\n\n  private _plan: QueryPlan.Plan;\n  private _trace: ExecutionTrace = ExecutionTrace.makeEmpty();\n  private _lastResultSet: QueryItem[] = [];\n\n  constructor(options: QueryExecutorOptions) {\n    super();\n\n    this._indexer = options.indexer;\n    this._automergeHost = options.automergeHost;\n    this._spaceStateManager = options.spaceStateManager;\n\n    this._id = options.queryId;\n    this._query = options.query;\n    this._reactivity = options.reactivity;\n\n    const queryPlanner = new QueryPlanner();\n    this._plan = queryPlanner.createPlan(this._query);\n  }\n\n  get query(): QueryAST.Query {\n    return this._query;\n  }\n\n  get plan(): QueryPlan.Plan {\n    return this._plan;\n  }\n\n  get trace(): ExecutionTrace {\n    return this._trace;\n  }\n\n  protected override async _open(ctx: Context): Promise<void> {}\n\n  protected override async _close(ctx: Context): Promise<void> {}\n\n  getResults(): QueryResult[] {\n    return this._lastResultSet.map(\n      (item): QueryResult => ({\n        id: item.objectId,\n        documentId: item.documentId,\n        spaceId: item.spaceId,\n\n        // TODO(dmaretskyi): Plumb through the rank.\n        rank: 0,\n      }),\n    );\n  }\n\n  async execQuery(): Promise<QueryExecutionResult> {\n    invariant(this._lifecycleState === LifecycleState.OPEN);\n\n    const prevResultSet = this._lastResultSet;\n    const { workingSet, trace } = await this._execPlan(this._plan, []);\n    this._lastResultSet = workingSet;\n    trace.name = 'Root';\n    trace.details = JSON.stringify({ id: this._id });\n    this._trace = trace;\n\n    const changed =\n      prevResultSet.length !== workingSet.length ||\n      prevResultSet.some(\n        (item, index) =>\n          workingSet[index].objectId !== item.objectId ||\n          workingSet[index].spaceId !== item.spaceId ||\n          workingSet[index].documentId !== item.documentId,\n      );\n\n    if (TRACE_QUERY_EXECUTION) {\n      // eslint-disable-next-line no-console\n      console.log(ExecutionTrace.format(trace));\n    }\n\n    return {\n      changed,\n    };\n  }\n\n  private async _execPlan(plan: QueryPlan.Plan, workingSet: QueryItem[]): Promise<StepExecutionResult> {\n    const trace = ExecutionTrace.makeEmpty();\n    const begin = performance.now();\n    for (const step of plan.steps) {\n      if (this._ctx.disposed) {\n        throw new ContextDisposedError();\n      }\n\n      const result = await this._execStep(step, workingSet);\n      workingSet = result.workingSet;\n      trace.children.push(result.trace);\n    }\n    trace.objectCount = workingSet.length;\n    trace.executionTime = performance.now() - begin;\n    return { workingSet, trace };\n  }\n\n  private async _execStep(step: QueryPlan.Step, workingSet: QueryItem[]): Promise<StepExecutionResult> {\n    if (this._ctx.disposed) {\n      return { workingSet, trace: ExecutionTrace.makeEmpty() };\n    }\n    let newWorkingSet: QueryItem[], trace: ExecutionTrace;\n\n    const begin = performance.now();\n    switch (step._tag) {\n      case 'ClearWorkingSetStep':\n        newWorkingSet = [];\n        trace = ExecutionTrace.makeEmpty();\n        break;\n      case 'SelectStep':\n        ({ workingSet: newWorkingSet, trace } = await this._execSelectStep(step, workingSet));\n        break;\n      case 'FilterStep':\n        ({ workingSet: newWorkingSet, trace } = await this._execFilterStep(step, workingSet));\n        break;\n      case 'FilterDeletedStep':\n        ({ workingSet: newWorkingSet, trace } = await this._execFilterDeletedStep(step, workingSet));\n        break;\n      case 'UnionStep':\n        ({ workingSet: newWorkingSet, trace } = await this._execUnionStep(step, workingSet));\n        break;\n      case 'SetDifferenceStep':\n        ({ workingSet: newWorkingSet, trace } = await this._execSetDifferenceStep(step, workingSet));\n        break;\n      case 'TraverseStep':\n        ({ workingSet: newWorkingSet, trace } = await this._execTraverseStep(step, workingSet));\n        break;\n      default:\n        throw new Error(`Unknown step type: ${(step as any)._tag}`);\n    }\n    trace.executionTime = performance.now() - begin;\n\n    return { workingSet: newWorkingSet, trace };\n  }\n\n  private async _execSelectStep(step: QueryPlan.SelectStep, workingSet: QueryItem[]): Promise<StepExecutionResult> {\n    workingSet = [...workingSet];\n\n    const trace: ExecutionTrace = {\n      ...ExecutionTrace.makeEmpty(),\n      name: 'Select',\n      details: JSON.stringify(step.selector),\n    };\n\n    switch (step.selector._tag) {\n      case 'WildcardSelector': {\n        const beginIndexQuery = performance.now();\n        const indexHits = await this._indexer.execQuery({\n          typenames: [],\n          inverted: false,\n        });\n        trace.indexHits = +indexHits.length;\n        trace.indexQueryTime += performance.now() - beginIndexQuery;\n\n        if (this._ctx.disposed) {\n          return { workingSet, trace };\n        }\n\n        const documentLoadStart = performance.now();\n        const results = await this._loadDocumentsAfterIndexQuery(indexHits);\n        trace.documentsLoaded += results.length;\n        trace.documentLoadTime += performance.now() - documentLoadStart;\n\n        workingSet.push(...results.filter(isNonNullable).filter((item) => step.spaces.includes(item.spaceId)));\n        trace.objectCount = workingSet.length;\n\n        break;\n      }\n      case 'IdSelector': {\n        const beginLoad = performance.now();\n        const items = await Promise.all(\n          step.selector.objectIds.map((id) =>\n            this._loadFromDXN(DXN.fromLocalObjectId(id), { sourceSpaceId: step.spaces[0] }),\n          ),\n        );\n        trace.documentLoadTime += performance.now() - beginLoad;\n\n        workingSet.push(...items.filter(isNonNullable));\n        trace.objectCount = workingSet.length;\n        break;\n      }\n      case 'TypeSelector': {\n        const beginIndexQuery = performance.now();\n        const indexHits = await this._indexer.execQuery({\n          typenames: step.selector.typename,\n          inverted: step.selector.inverted,\n        });\n        trace.indexHits = +indexHits.length;\n        trace.indexQueryTime += performance.now() - beginIndexQuery;\n\n        if (this._ctx.disposed) {\n          return { workingSet, trace };\n        }\n\n        const documentLoadStart = performance.now();\n        const results = await this._loadDocumentsAfterIndexQuery(indexHits);\n        trace.documentsLoaded += results.length;\n        trace.documentLoadTime += performance.now() - documentLoadStart;\n\n        workingSet.push(...results.filter(isNonNullable).filter((item) => step.spaces.includes(item.spaceId)));\n        trace.objectCount = workingSet.length;\n\n        break;\n      }\n      case 'TextSelector': {\n        const beginIndexQuery = performance.now();\n        const indexHits = await this._indexer.execQuery({\n          typenames: [],\n          text: {\n            query: step.selector.text,\n            kind: Match.type<QueryPlan.TextSearchKind>().pipe(\n              Match.withReturnType<'text' | 'vector'>(),\n              Match.when('full-text', () => 'text'),\n              Match.when('vector', () => 'vector'),\n              Match.orElseAbsurd,\n            )(step.selector.searchKind),\n          },\n        });\n        trace.indexHits = +indexHits.length;\n        trace.indexQueryTime += performance.now() - beginIndexQuery;\n\n        if (this._ctx.disposed) {\n          return { workingSet, trace };\n        }\n\n        const documentLoadStart = performance.now();\n        const results = await this._loadDocumentsAfterIndexQuery(indexHits);\n        trace.documentsLoaded += results.length;\n        trace.documentLoadTime += performance.now() - documentLoadStart;\n\n        workingSet.push(...results.filter(isNonNullable).filter((item) => step.spaces.includes(item.spaceId)));\n        trace.objectCount = workingSet.length;\n        break;\n      }\n      default:\n        throw new Error(`Unknown selector type: ${(step.selector as any)._tag}`);\n    }\n\n    return { workingSet, trace };\n  }\n\n  private async _execFilterStep(step: QueryPlan.FilterStep, workingSet: QueryItem[]): Promise<StepExecutionResult> {\n    const result = workingSet.filter((item) =>\n      filterMatchObject(step.filter, {\n        id: item.objectId,\n        spaceId: item.spaceId,\n        doc: item.doc,\n      }),\n    );\n    return {\n      workingSet: result,\n      trace: {\n        ...ExecutionTrace.makeEmpty(),\n        name: 'Filter',\n        details: JSON.stringify(step.filter),\n        objectCount: result.length,\n      },\n    };\n  }\n\n  private async _execFilterDeletedStep(\n    step: QueryPlan.FilterDeletedStep,\n    workingSet: QueryItem[],\n  ): Promise<StepExecutionResult> {\n    if (workingSet.length === 6) {\n      log.info('FilterDeletedStep', { step, workingSet });\n    }\n\n    const expected = step.mode === 'only-deleted';\n    const result = workingSet.filter((item) => ObjectStructure.isDeleted(item.doc) === expected);\n    return {\n      workingSet: result,\n      trace: {\n        ...ExecutionTrace.makeEmpty(),\n        name: 'FilterDeleted',\n        details: step.mode,\n        objectCount: result.length,\n      },\n    };\n  }\n\n  // TODO(dmaretskyi): This needs to be completed.\n  private async _execTraverseStep(step: QueryPlan.TraverseStep, workingSet: QueryItem[]): Promise<StepExecutionResult> {\n    const trace: ExecutionTrace = {\n      ...ExecutionTrace.makeEmpty(),\n      name: 'Traverse',\n      details: JSON.stringify(step.traversal),\n    };\n\n    const newWorkingSet: QueryItem[] = [];\n\n    switch (step.traversal._tag) {\n      case 'ReferenceTraversal': {\n        switch (step.traversal.direction) {\n          case 'outgoing': {\n            const property = EscapedPropPath.unescape(step.traversal.property);\n\n            const refs = workingSet\n              .flatMap((item) => {\n                const ref = getDeep(item.doc.data, property);\n                const refs = Array.isArray(ref) ? ref : [ref];\n                return refs.map((ref) => {\n                  try {\n                    return isEncodedReference(ref)\n                      ? {\n                          ref: DXN.parse(ref['/']),\n                          spaceId: item.spaceId,\n                        }\n                      : null;\n                  } catch {\n                    log.warn('Invalid reference', { ref: ref['/'] });\n                    return null;\n                  }\n                });\n              })\n              .filter(isNonNullable);\n\n            const beginLoad = performance.now();\n            const items = await Promise.all(\n              refs.map(({ ref, spaceId }) => this._loadFromDXN(ref, { sourceSpaceId: spaceId })),\n            );\n            trace.documentLoadTime += performance.now() - beginLoad;\n\n            newWorkingSet.push(...items.filter(isNonNullable));\n            trace.objectCount = newWorkingSet.length;\n\n            break;\n          }\n          case 'incoming': {\n            const indexHits = await this._indexer.execQuery({\n              typenames: [],\n              inverted: false,\n              graph: {\n                kind: 'inbound-reference',\n                property: step.traversal.property,\n                anchors: workingSet.map((item) => item.objectId),\n              },\n            });\n            trace.indexHits += indexHits.length;\n\n            const documentLoadStart = performance.now();\n            const results = await this._loadDocumentsAfterIndexQuery(indexHits);\n            trace.documentsLoaded += results.length;\n            trace.documentLoadTime += performance.now() - documentLoadStart;\n\n            newWorkingSet.push(...results.filter(isNonNullable));\n            trace.objectCount = newWorkingSet.length;\n\n            break;\n          }\n        }\n        break;\n      }\n      case 'RelationTraversal': {\n        switch (step.traversal.direction) {\n          case 'relation-to-source':\n          case 'relation-to-target': {\n            const refs = workingSet\n              .map((item) => {\n                const ref =\n                  step.traversal.direction === 'relation-to-source'\n                    ? ObjectStructure.getRelationSource(item.doc)\n                    : ObjectStructure.getRelationTarget(item.doc);\n\n                if (!isEncodedReference(ref)) {\n                  return null;\n                }\n                try {\n                  return {\n                    ref: DXN.parse(ref['/']),\n                    spaceId: item.spaceId,\n                  };\n                } catch {\n                  log.warn('Invalid reference', { ref: ref['/'] });\n                  return null;\n                }\n              })\n              .filter(isNonNullable);\n\n            const beginLoad = performance.now();\n            const items = await Promise.all(\n              refs.map(({ ref, spaceId }) => this._loadFromDXN(ref, { sourceSpaceId: spaceId })),\n            );\n            trace.documentLoadTime += performance.now() - beginLoad;\n\n            newWorkingSet.push(...items.filter(isNonNullable));\n            trace.objectCount = newWorkingSet.length;\n\n            break;\n          }\n\n          case 'source-to-relation':\n          case 'target-to-relation': {\n            const indexHits = await this._indexer.execQuery({\n              typenames: [],\n              inverted: false,\n              graph: {\n                kind: step.traversal.direction === 'source-to-relation' ? 'relation-source' : 'relation-target',\n                anchors: workingSet.map((item) => item.objectId),\n                property: null,\n              },\n            });\n\n            trace.indexHits += indexHits.length;\n\n            const documentLoadStart = performance.now();\n            const results = await this._loadDocumentsAfterIndexQuery(indexHits);\n            trace.documentsLoaded += results.length;\n            trace.documentLoadTime += performance.now() - documentLoadStart;\n\n            newWorkingSet.push(...results.filter(isNonNullable));\n            trace.objectCount = newWorkingSet.length;\n\n            break;\n          }\n        }\n        break;\n      }\n      default:\n        throw new Error(`Unknown traversal type: ${(step.traversal as any)._tag}`);\n    }\n\n    return { workingSet: newWorkingSet, trace };\n  }\n\n  private async _execUnionStep(step: QueryPlan.UnionStep, workingSet: QueryItem[]): Promise<StepExecutionResult> {\n    const results = new Map<ObjectId, QueryItem>();\n\n    const resultSets = await Promise.all(step.plans.map((plan) => this._execPlan(plan, [...workingSet])));\n\n    const trace: ExecutionTrace = {\n      ...ExecutionTrace.makeEmpty(),\n      name: 'Union',\n    };\n\n    // NOTE: Doing insertion after execution to ensure deterministic results. Probably not needed.\n    for (const resultSet of resultSets) {\n      for (const item of resultSet.workingSet) {\n        // Could be duplicate object ids in different spaces or in different epochs of the same space.\n        results.set(`${item.spaceId}:${item.documentId}:${item.objectId}`, item);\n      }\n      trace.children.push(resultSet.trace);\n    }\n\n    return {\n      workingSet: [...results.values()],\n      trace,\n    };\n  }\n\n  private async _execSetDifferenceStep(\n    step: QueryPlan.SetDifferenceStep,\n    workingSet: QueryItem[],\n  ): Promise<StepExecutionResult> {\n    const trace: ExecutionTrace = {\n      ...ExecutionTrace.makeEmpty(),\n      name: 'SetDifference',\n    };\n\n    const sourceResult = await this._execPlan(step.source, [...workingSet]);\n    const excludeResult = await this._execPlan(step.exclude, [...workingSet]);\n    trace.children.push(sourceResult.trace, excludeResult.trace);\n\n    return {\n      workingSet: sourceResult.workingSet.filter((item) => {\n        const index = excludeResult.workingSet.findIndex((i) => i.objectId === item.objectId);\n        return index === -1;\n      }),\n      trace,\n    };\n  }\n\n  private async _loadDocumentsAfterIndexQuery(indexHits: FindResult[]): Promise<(QueryItem | null)[]> {\n    return Promise.all(\n      indexHits.map(async (hit): Promise<QueryItem | null> => {\n        return this._loadFromIndexHit(hit);\n      }),\n    );\n  }\n\n  private async _loadFromIndexHit(hit: FindResult): Promise<QueryItem | null> {\n    const { objectId, documentId, spaceKey: spaceKeyInIndex } = objectPointerCodec.decode(hit.id);\n\n    const handle = await this._automergeHost.loadDoc<DatabaseDirectory>(Context.default(), documentId as DocumentId);\n    const doc = handle.doc();\n    if (!doc) {\n      return null;\n    }\n\n    const spaceKey = spaceKeyInIndex ?? DatabaseDirectory.getSpaceKey(doc);\n    if (!spaceKey) {\n      return null;\n    }\n\n    const object = DatabaseDirectory.getInlineObject(doc, objectId);\n    if (!object) {\n      return null;\n    }\n\n    return {\n      objectId,\n      documentId: documentId as DocumentId,\n      spaceId: await createIdFromSpaceKey(PublicKey.from(spaceKey)),\n      doc: object,\n    };\n  }\n\n  private async _loadFromDXN(dxn: DXN, { sourceSpaceId }: { sourceSpaceId: SpaceId }): Promise<QueryItem | null> {\n    const echoDxn = dxn.asEchoDXN();\n    if (!echoDxn) {\n      log.warn('unable to resolve DXN', { dxn });\n      return null;\n    }\n\n    const spaceId = echoDxn.spaceId ?? sourceSpaceId;\n\n    const spaceRoot = this._spaceStateManager.getRootBySpaceId(spaceId);\n    if (!spaceRoot) {\n      log.warn('no space state found for', { spaceId });\n      return null;\n    }\n    const dbDirectory = spaceRoot.doc();\n    if (!dbDirectory) {\n      log.warn('no space state found for', { spaceId });\n      return null;\n    }\n\n    const inlineObject = DatabaseDirectory.getInlineObject(dbDirectory, echoDxn.echoId);\n    if (inlineObject) {\n      return {\n        objectId: echoDxn.echoId,\n        documentId: spaceRoot.documentId,\n        spaceId,\n        doc: inlineObject,\n      };\n    }\n\n    const link = DatabaseDirectory.getLink(dbDirectory, echoDxn.echoId);\n    if (!link) {\n      return null;\n    }\n\n    const handle = await this._automergeHost.loadDoc<DatabaseDirectory>(Context.default(), link as AutomergeUrl);\n    const doc = handle.doc();\n    if (!doc) {\n      return null;\n    }\n\n    const object = DatabaseDirectory.getInlineObject(doc, echoDxn.echoId);\n    if (!object) {\n      return null;\n    }\n\n    return {\n      objectId: echoDxn.echoId,\n      documentId: handle.documentId,\n      spaceId,\n      doc: object,\n    };\n  }\n}\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { type QueryAST } from '@dxos/echo-protocol';\nimport { invariant } from '@dxos/invariant';\nimport type { DXN, SpaceId } from '@dxos/keys';\n\nimport { QueryError } from './errors';\nimport { QueryPlan } from './plan';\n\nexport type QueryPlannerOptions = {\n  defaultTextSearchKind: QueryPlan.TextSearchKind;\n};\n\nconst DEFAULT_OPTIONS: QueryPlannerOptions = {\n  defaultTextSearchKind: 'full-text',\n};\n\n/**\n * Constructs an optimized query plan.\n */\n// TODO(dmaretskyi): Implement inefficient versions of complex queries.\nexport class QueryPlanner {\n  private readonly _options: QueryPlannerOptions;\n\n  constructor(options?: Partial<QueryPlannerOptions>) {\n    this._options = {\n      ...DEFAULT_OPTIONS,\n      ...options,\n    };\n  }\n\n  createPlan(query: QueryAST.Query): QueryPlan.Plan {\n    let plan = this._generate(query, { ...DEFAULT_CONTEXT, originalQuery: query });\n    plan = this._optimizeEmptyFilters(plan);\n    plan = this._optimizeSoloUnions(plan);\n    return plan;\n  }\n\n  private _generate(query: QueryAST.Query, context: GenerationContext): QueryPlan.Plan {\n    switch (query.type) {\n      case 'options':\n        return this._generateOptionsClause(query, context);\n      case 'select':\n        return this._generateSelectClause(query, context);\n      case 'filter':\n        return this._generateFilterClause(query, context);\n      case 'incoming-references':\n        return this._generateIncomingReferencesClause(query, context);\n      case 'relation':\n        return this._generateRelationClause(query, context);\n      case 'relation-traversal':\n        return this._generateRelationTraversalClause(query, context);\n      case 'reference-traversal':\n        return this._generateReferenceTraversalClause(query, context);\n      case 'union':\n        return this._generateUnionClause(query, context);\n      case 'set-difference':\n        return this._generateSetDifferenceClause(query, context);\n      default:\n        throw new QueryError(`Unsupported query type: ${(query as any).type}`, {\n          context: { query: context.originalQuery },\n        });\n    }\n  }\n\n  private _generateOptionsClause(query: QueryAST.QueryOptionsClause, context: GenerationContext): QueryPlan.Plan {\n    const newContext = {\n      ...context,\n    };\n    if (query.options.spaceIds) {\n      newContext.selectionSpaces = query.options.spaceIds as readonly SpaceId[];\n    }\n    if (query.options.deleted) {\n      newContext.deletedHandling = query.options.deleted;\n    }\n    return this._generate(query.query, newContext);\n  }\n\n  private _generateSelectClause(query: QueryAST.QuerySelectClause, context: GenerationContext): QueryPlan.Plan {\n    return this._generateSelectionFromFilter(query.filter, context);\n  }\n\n  // TODO(dmaretskyi): This can be rewritten as a function of (filter[]) -> (selection ? undefined, rest: filter[]) that recurses onto itself.\n  // TODO(dmaretskyi): If the tip of the query ast is a [select, ...filter] shape we can reorder the filters so the query is most efficient.\n  private _generateSelectionFromFilter(filter: QueryAST.Filter, context: GenerationContext): QueryPlan.Plan {\n    switch (filter.type) {\n      case 'object': {\n        if (\n          context.selectionInverted &&\n          filter.id === undefined &&\n          filter.typename === null &&\n          Object.keys(filter.props).length === 0\n        ) {\n          // filter of nothing -> clear working set.\n          return QueryPlan.Plan.make([\n            {\n              _tag: 'ClearWorkingSetStep',\n            },\n            ...this._generateDeletedHandlingSteps(context),\n          ]);\n        }\n        if (context.selectionInverted) {\n          throw new QueryError('Query too complex', { context: { query: context.originalQuery } });\n        }\n\n        // Try to utilize indexes during selection, prioritizing selecting by id, then by typename.\n        // After selection, filter out using the remaining predicates.\n        if (filter.id && filter.id?.length > 0) {\n          return QueryPlan.Plan.make([\n            {\n              _tag: 'SelectStep',\n              spaces: context.selectionSpaces,\n              selector: {\n                _tag: 'IdSelector',\n                objectIds: filter.id,\n              },\n            },\n            ...this._generateDeletedHandlingSteps(context),\n            {\n              _tag: 'FilterStep',\n              filter: { ...filter, id: undefined },\n            },\n          ]);\n        } else if (filter.typename) {\n          return QueryPlan.Plan.make([\n            {\n              _tag: 'SelectStep',\n              spaces: context.selectionSpaces,\n              selector: {\n                _tag: 'TypeSelector',\n                typename: [filter.typename as DXN.String],\n                inverted: false,\n              },\n            },\n            ...this._generateDeletedHandlingSteps(context),\n            {\n              _tag: 'FilterStep',\n              filter: { ...filter, typename: null },\n            },\n          ]);\n        } else {\n          return QueryPlan.Plan.make([\n            {\n              _tag: 'SelectStep',\n              spaces: context.selectionSpaces,\n              selector: {\n                _tag: 'WildcardSelector',\n              },\n            },\n            ...this._generateDeletedHandlingSteps(context),\n            {\n              _tag: 'FilterStep',\n              filter: { ...filter },\n            },\n          ]);\n        }\n      }\n      case 'text-search': {\n        return QueryPlan.Plan.make([\n          {\n            _tag: 'SelectStep',\n            spaces: context.selectionSpaces,\n            selector: {\n              _tag: 'TextSelector',\n              text: filter.text,\n              searchKind: filter.searchKind ?? this._options.defaultTextSearchKind,\n            },\n          },\n          ...this._generateDeletedHandlingSteps(context),\n        ]);\n      }\n      case 'compare':\n        throw new QueryError('Query too complex', { context: { query: context.originalQuery } });\n      case 'in':\n        throw new QueryError('Query too complex', { context: { query: context.originalQuery } });\n      case 'range':\n        throw new QueryError('Query too complex', { context: { query: context.originalQuery } });\n      case 'not':\n        return this._generateSelectionFromFilter(filter.filter, {\n          ...context,\n          selectionInverted: !context.selectionInverted,\n        });\n      case 'and':\n        throw new QueryError('Query too complex', { context: { query: context.originalQuery } });\n      case 'or':\n        // Optimized case\n        if (filter.filters.every(isTrivialTypenameFilter)) {\n          const typenames = filter.filters.map((f) => {\n            invariant(f.type === 'object' && f.typename !== null);\n            return f.typename;\n          });\n          return QueryPlan.Plan.make([\n            {\n              _tag: 'SelectStep',\n              spaces: context.selectionSpaces,\n              selector: {\n                _tag: 'TypeSelector',\n                typename: typenames as DXN.String[],\n                inverted: context.selectionInverted,\n              },\n            },\n            ...this._generateDeletedHandlingSteps(context),\n          ]);\n        } else {\n          throw new QueryError('Query too complex', { context: { query: context.originalQuery } });\n        }\n\n      default:\n        throw new QueryError(`Unsupported filter type: ${(filter as any).type}`, {\n          context: { query: context.originalQuery },\n        });\n    }\n  }\n\n  private _generateDeletedHandlingSteps(context: GenerationContext): QueryPlan.Step[] {\n    switch (context.deletedHandling) {\n      case 'include':\n        return [];\n      case 'exclude':\n        return [\n          {\n            _tag: 'FilterDeletedStep',\n            mode: 'only-non-deleted',\n          },\n        ];\n      case 'only':\n        return [\n          {\n            _tag: 'FilterDeletedStep',\n            mode: 'only-deleted',\n          },\n        ];\n    }\n  }\n\n  private _generateUnionClause(query: QueryAST.QueryUnionClause, context: GenerationContext): QueryPlan.Plan {\n    return QueryPlan.Plan.make([\n      {\n        _tag: 'UnionStep',\n        plans: query.queries.map((query) => this._generate(query, context)),\n      },\n    ]);\n  }\n\n  private _generateSetDifferenceClause(\n    query: QueryAST.QuerySetDifferenceClause,\n    context: GenerationContext,\n  ): QueryPlan.Plan {\n    return QueryPlan.Plan.make([\n      {\n        _tag: 'SetDifferenceStep',\n        source: this._generate(query.source, context),\n        exclude: this._generate(query.exclude, context),\n      },\n    ]);\n  }\n\n  private _generateReferenceTraversalClause(\n    query: QueryAST.QueryReferenceTraversalClause,\n    context: GenerationContext,\n  ): QueryPlan.Plan {\n    return QueryPlan.Plan.make([\n      ...this._generate(query.anchor, context).steps,\n      {\n        _tag: 'TraverseStep',\n        traversal: {\n          _tag: 'ReferenceTraversal',\n          direction: 'outgoing',\n          property: query.property,\n        },\n      },\n      ...this._generateDeletedHandlingSteps(context),\n    ]);\n  }\n\n  private _generateIncomingReferencesClause(\n    query: QueryAST.QueryIncomingReferencesClause,\n    context: GenerationContext,\n  ): QueryPlan.Plan {\n    return QueryPlan.Plan.make([\n      ...this._generate(query.anchor, context).steps,\n      {\n        _tag: 'TraverseStep',\n        traversal: {\n          _tag: 'ReferenceTraversal',\n          direction: 'incoming',\n          property: query.property,\n        },\n      },\n      ...this._generateDeletedHandlingSteps(context),\n      {\n        _tag: 'FilterStep',\n        filter: {\n          type: 'object',\n          typename: query.typename,\n          props: {},\n        },\n      },\n    ]);\n  }\n\n  private _generateRelationTraversalClause(\n    query: QueryAST.QueryRelationTraversalClause,\n    context: GenerationContext,\n  ): QueryPlan.Plan {\n    switch (query.direction) {\n      case 'source': {\n        return QueryPlan.Plan.make([\n          ...this._generate(query.anchor, context).steps,\n          createRelationTraversalStep('relation-to-source'),\n          ...this._generateDeletedHandlingSteps(context),\n        ]);\n      }\n      case 'target': {\n        return QueryPlan.Plan.make([\n          ...this._generate(query.anchor, context).steps,\n          createRelationTraversalStep('relation-to-target'),\n          ...this._generateDeletedHandlingSteps(context),\n        ]);\n      }\n      case 'both': {\n        const anchorPlan = this._generate(query.anchor, context);\n        return QueryPlan.Plan.make([\n          ...anchorPlan.steps,\n          {\n            _tag: 'UnionStep',\n            plans: [\n              QueryPlan.Plan.make([createRelationTraversalStep('relation-to-source')]),\n              QueryPlan.Plan.make([createRelationTraversalStep('relation-to-target')]),\n            ],\n          },\n          ...this._generateDeletedHandlingSteps(context),\n        ]);\n      }\n    }\n  }\n\n  private _generateRelationClause(query: QueryAST.QueryRelationClause, context: GenerationContext): QueryPlan.Plan {\n    switch (query.direction) {\n      case 'outgoing': {\n        return QueryPlan.Plan.make([\n          ...this._generate(query.anchor, context).steps,\n          createRelationTraversalStep('source-to-relation'),\n          ...this._generateDeletedHandlingSteps(context),\n          {\n            _tag: 'FilterStep',\n            filter: query.filter ?? NOOP_FILTER,\n          },\n        ]);\n      }\n      case 'incoming': {\n        return QueryPlan.Plan.make([\n          ...this._generate(query.anchor, context).steps,\n          createRelationTraversalStep('target-to-relation'),\n          ...this._generateDeletedHandlingSteps(context),\n          {\n            _tag: 'FilterStep',\n            filter: query.filter ?? NOOP_FILTER,\n          },\n        ]);\n      }\n      case 'both': {\n        const anchorPlan = this._generate(query.anchor, context);\n        return QueryPlan.Plan.make([\n          ...anchorPlan.steps,\n          {\n            _tag: 'UnionStep',\n            plans: [\n              QueryPlan.Plan.make([createRelationTraversalStep('source-to-relation')]),\n              QueryPlan.Plan.make([createRelationTraversalStep('target-to-relation')]),\n            ],\n          },\n          ...this._generateDeletedHandlingSteps(context),\n          {\n            _tag: 'FilterStep',\n            filter: query.filter ?? NOOP_FILTER,\n          },\n        ]);\n      }\n    }\n  }\n\n  private _generateFilterClause(query: QueryAST.QueryFilterClause, context: GenerationContext): QueryPlan.Plan {\n    return QueryPlan.Plan.make([\n      ...this._generate(query.selection, context).steps,\n      {\n        _tag: 'FilterStep',\n        filter: query.filter,\n      },\n    ]);\n  }\n\n  /**\n   * Removes filter steps that have no predicates.\n   */\n  private _optimizeEmptyFilters(plan: QueryPlan.Plan): QueryPlan.Plan {\n    return QueryPlan.Plan.make(\n      plan.steps\n        .filter((step) => {\n          if (step._tag === 'FilterStep') {\n            return !QueryPlan.FilterStep.isNoop(step);\n          } else {\n            return true;\n          }\n        })\n        .map((step) => {\n          if (step._tag === 'UnionStep') {\n            return {\n              _tag: 'UnionStep',\n              plans: step.plans.map((plan) => this._optimizeEmptyFilters(plan)),\n            };\n          } else {\n            return step;\n          }\n        }),\n    );\n  }\n\n  /**\n   * Removes union steps that have only one child.\n   */\n  private _optimizeSoloUnions(plan: QueryPlan.Plan): QueryPlan.Plan {\n    // TODO(dmaretskyi): Implement this.\n    return plan;\n  }\n}\n\n/**\n * Context for query planning.\n */\ntype GenerationContext = {\n  /**\n   * The original query.\n   */\n  originalQuery: QueryAST.Query | null;\n\n  /**\n   * Which spaces to select from.\n   */\n  selectionSpaces: readonly SpaceId[];\n\n  /**\n   * How to handle deleted objects.\n   */\n  deletedHandling: 'include' | 'exclude' | 'only';\n\n  /**\n   * When generating a selection clause, whether to invert the filter.\n   */\n  selectionInverted: boolean;\n};\n\nconst DEFAULT_CONTEXT: GenerationContext = {\n  originalQuery: null,\n  selectionSpaces: [],\n  deletedHandling: 'exclude',\n  selectionInverted: false,\n};\n\nconst NOOP_FILTER: QueryAST.Filter = {\n  type: 'object',\n  typename: null,\n  id: [],\n  props: {},\n};\n\nconst createRelationTraversalStep = (direction: QueryPlan.RelationTraversal['direction']): QueryPlan.Step => ({\n  _tag: 'TraverseStep',\n  traversal: {\n    _tag: 'RelationTraversal',\n    direction,\n  },\n});\n\nconst isTrivialTypenameFilter = (filter: QueryAST.Filter): boolean => {\n  return (\n    filter.type === 'object' &&\n    filter.typename !== null &&\n    Object.keys(filter.props).length === 0 &&\n    (filter.id === undefined || filter.id.length === 0) &&\n    (filter.foreignKeys === undefined || filter.foreignKeys.length === 0)\n  );\n};\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { BaseError } from '@dxos/errors';\n\nexport class QueryError extends BaseError.extend('QUERY_ERROR') {}\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport type { QueryAST } from '@dxos/echo-protocol';\nimport type { EscapedPropPath } from '@dxos/indexing';\nimport type { DXN, ObjectId, SpaceId } from '@dxos/keys';\n\nexport namespace QueryPlan {\n  export type TextSearchKind = 'full-text' | 'vector' | 'hybrid';\n\n  /**\n   * A series of linear steps to execute a query.\n   * Steps can potentially contain sub-plans in case of unions.\n   *\n   * The query executor will execute each step in sequence.\n   * The plans start with a select step, which adds objects to the current working set.\n   * Then the next steps will act on the current working set, preforming filters, traversals, etc.\n   */\n  export type Plan = {\n    steps: Step[];\n  };\n\n  export const Plan = Object.freeze({\n    make: (steps: Step[]): Plan => ({ steps }),\n  });\n\n  export type Step =\n    | ClearWorkingSetStep\n    | SelectStep\n    | FilterStep\n    | FilterDeletedStep\n    | TraverseStep\n    | UnionStep\n    | SetDifferenceStep;\n\n  /**\n   * Clear the current working set.\n   */\n  export type ClearWorkingSetStep = {\n    _tag: 'ClearWorkingSetStep';\n  };\n\n  /**\n   * Select objects based on id, typename, or other predicates.\n   * Specifies the spaces to select from.\n   */\n  export type SelectStep = {\n    _tag: 'SelectStep';\n\n    spaces: readonly SpaceId[];\n    selector: Selector;\n  };\n\n  /**\n   * Specifier to scan the database for objects.\n   * Optimized to utilize database indexes.\n   */\n  export type Selector = WildcardSelector | IdSelector | TypeSelector | TextSelector;\n\n  export type WildcardSelector = {\n    _tag: 'WildcardSelector';\n  };\n\n  export type IdSelector = {\n    _tag: 'IdSelector';\n\n    objectIds: readonly ObjectId[];\n  };\n\n  /**\n   * Select objects by typename.\n   * Supports passing an array of typenames and an optional inverse flag to optimize for index implementation.\n   */\n  export type TypeSelector = {\n    _tag: 'TypeSelector';\n\n    typename: DXN.String[];\n    /**\n     * If true, select objects that do not match the typename.\n     */\n    inverted: boolean;\n  };\n\n  /**\n   * Select objects by preforming a full-text or vector search.\n   */\n  export type TextSelector = {\n    _tag: 'TextSelector';\n\n    text: string;\n    searchKind: TextSearchKind;\n  };\n\n  /**\n   * Filter objects in the current working set based on a predicate.\n   */\n  export type FilterStep = {\n    _tag: 'FilterStep';\n\n    filter: QueryAST.Filter;\n  };\n\n  export const FilterStep = Object.freeze({\n    isNoop: (step: FilterStep): boolean => {\n      switch (step.filter.type) {\n        case 'object': {\n          // TODO(dmaretskyi): This is error-prone, it could easily break if we add more clauses.\n          return (\n            step.filter.typename === null &&\n            (step.filter.id === undefined || step.filter.id.length === 0) &&\n            (step.filter.props === undefined || Object.keys(step.filter.props).length === 0) &&\n            (step.filter.foreignKeys === undefined || step.filter.foreignKeys.length === 0)\n          );\n        }\n        default:\n          return false;\n      }\n    },\n  });\n\n  /**\n   * Filter objects in the current working set based on the deleted state.\n   */\n  export type FilterDeletedStep = {\n    _tag: 'FilterDeletedStep';\n\n    mode: 'only-deleted' | 'only-non-deleted';\n  };\n\n  /**\n   * Traverse the object graph, starting from objects in the current working set.\n   */\n  export type TraverseStep = {\n    _tag: 'TraverseStep';\n\n    traversal: Traversal;\n  };\n\n  /**\n   * Describes a traversal of the object graph.\n   */\n  export type Traversal = ReferenceTraversal | RelationTraversal;\n\n  /**\n   * Traverse a reference connection.\n   */\n  export type ReferenceTraversal = {\n    _tag: 'ReferenceTraversal';\n\n    /**\n     * Property path where the reference is located.\n     */\n    property: EscapedPropPath;\n\n    /**\n     * outgoing: the reference points from the anchor object to the target.\n     * incoming: the reference points to the anchor object from the target.\n     */\n    direction: 'outgoing' | 'incoming';\n  };\n\n  /**\n   * Traverse a relation.\n   */\n  export type RelationTraversal = {\n    _tag: 'RelationTraversal';\n\n    /**\n     * The direction of the traversal.\n     * There are for variants since each relation has two connectors (source & target) and there are two directions to traverse each.\n     */\n    direction: 'source-to-relation' | 'relation-to-source' | 'target-to-relation' | 'relation-to-target';\n  };\n\n  /**\n   * Combine results from multiple plans.\n   * Each of the plans starts with a copy of the current working set.\n   * This supports plans where we first perform a selection, then traverse in different directions, and then combine the results.\n   */\n  export type UnionStep = {\n    _tag: 'UnionStep';\n\n    plans: Plan[];\n  };\n\n  /**\n   * Subtract the results of one plan from another.\n   */\n  export type SetDifferenceStep = {\n    _tag: 'SetDifferenceStep';\n\n    source: Plan;\n    exclude: Plan;\n  };\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { interpretAsDocumentId, type DocHandle, type DocumentId } from '@automerge/automerge-repo';\nimport isEqual from 'lodash.isequal';\n\nimport { Event, UpdateScheduler } from '@dxos/async';\nimport { Resource, Context, LifecycleState } from '@dxos/context';\nimport { type DatabaseDirectory } from '@dxos/echo-protocol';\nimport { invariant } from '@dxos/invariant';\nimport { type SpaceId } from '@dxos/keys';\n\nimport { DatabaseRoot } from './database-root';\n\nexport class SpaceStateManager extends Resource {\n  private readonly _roots = new Map<DocumentId, DatabaseRoot>();\n  private readonly _rootBySpace = new Map<SpaceId, DocumentId>();\n  private readonly _perRootContext = new Map<DocumentId, Context>();\n  private readonly _lastSpaceDocumentList = new Map<SpaceId, DocumentId[]>();\n\n  public readonly spaceDocumentListUpdated = new Event<SpaceDocumentListUpdatedEvent>();\n\n  protected override async _close(ctx: Context): Promise<void> {\n    for (const [_, rootCtx] of this._perRootContext) {\n      await rootCtx.dispose();\n    }\n    this._roots.clear();\n  }\n\n  get roots(): ReadonlyMap<DocumentId, DatabaseRoot> {\n    return this._roots;\n  }\n\n  getRootByDocumentId(documentId: DocumentId): DatabaseRoot | undefined {\n    return this._roots.get(documentId);\n  }\n\n  getSpaceRootDocumentId(spaceId: SpaceId): DocumentId | undefined {\n    return this._rootBySpace.get(spaceId);\n  }\n\n  getRootBySpaceId(spaceId: SpaceId): DatabaseRoot | undefined {\n    invariant(this._lifecycleState === LifecycleState.OPEN);\n    const documentId = this._rootBySpace.get(spaceId);\n    if (!documentId) {\n      return undefined;\n    }\n    return this._roots.get(documentId);\n  }\n\n  async assignRootToSpace(spaceId: SpaceId, handle: DocHandle<DatabaseDirectory>): Promise<DatabaseRoot> {\n    let root: DatabaseRoot;\n    if (this._roots.has(handle.documentId)) {\n      root = this._roots.get(handle.documentId)!;\n    } else {\n      root = new DatabaseRoot(handle);\n      this._roots.set(handle.documentId, root);\n    }\n\n    if (this._rootBySpace.get(spaceId) === root.handle.documentId) {\n      return root;\n    }\n\n    const prevRootId = this._rootBySpace.get(spaceId);\n    if (prevRootId) {\n      void this._perRootContext.get(prevRootId)?.dispose();\n      this._perRootContext.delete(prevRootId);\n    }\n\n    this._rootBySpace.set(spaceId, root.handle.documentId);\n    const ctx = new Context();\n\n    this._perRootContext.set(root.handle.documentId, ctx);\n\n    await root.handle.whenReady();\n\n    const documentListCheckScheduler = new UpdateScheduler(\n      ctx,\n      async () => {\n        const documentIds = [root.documentId, ...root.getAllLinkedDocuments().map((url) => interpretAsDocumentId(url))];\n        if (!isEqual(documentIds, this._lastSpaceDocumentList.get(spaceId))) {\n          this._lastSpaceDocumentList.set(spaceId, documentIds);\n          this.spaceDocumentListUpdated.emit(\n            new SpaceDocumentListUpdatedEvent(spaceId, root.documentId, prevRootId, documentIds),\n          );\n        }\n      },\n      { maxFrequency: 50 },\n    );\n    const triggerCheckOnChange = () => documentListCheckScheduler.trigger();\n    root.handle.addListener('change', triggerCheckOnChange);\n    ctx.onDispose(() => root.handle.removeListener('change', triggerCheckOnChange));\n\n    documentListCheckScheduler.trigger();\n\n    return root;\n  }\n}\n\nexport class SpaceDocumentListUpdatedEvent {\n  constructor(\n    public readonly spaceId: SpaceId,\n    public readonly spaceRootId: DocumentId,\n    public readonly previousRootId: DocumentId | undefined,\n    public readonly documentIds: DocumentId[],\n  ) {}\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport type * as A from '@automerge/automerge';\nimport { interpretAsDocumentId, type AutomergeUrl, type DocHandle, type DocumentId } from '@automerge/automerge-repo';\n\nimport { DatabaseDirectory, SpaceDocVersion } from '@dxos/echo-protocol';\nimport { invariant } from '@dxos/invariant';\n\nimport { measureDocMetrics, type DocMetrics } from './automerge-metrics';\n\nexport class DatabaseRoot {\n  static mapLinks(doc: DocHandle<DatabaseDirectory>, mapping: Record<DocumentId, DocumentId>): void {\n    doc.change((d) => {\n      if (!d.links) {\n        return;\n      }\n      for (const [key, value] of Object.entries(d.links)) {\n        const documentId = interpretAsDocumentId(value.toString() as any);\n        if (mapping[documentId]) {\n          d.links[key] = `automerge:${mapping[documentId]}`;\n        }\n      }\n    });\n  }\n\n  constructor(private readonly _rootHandle: DocHandle<DatabaseDirectory>) {}\n\n  get documentId(): DocumentId {\n    return this._rootHandle.documentId;\n  }\n\n  get url() {\n    return this._rootHandle.url;\n  }\n\n  get isLoaded(): boolean {\n    return this._rootHandle.isReady();\n  }\n\n  get handle(): DocHandle<DatabaseDirectory> {\n    return this._rootHandle;\n  }\n\n  doc(): A.Doc<DatabaseDirectory> | null {\n    return this._rootHandle.isReady() ? this._rootHandle.doc() : null;\n  }\n\n  getVersion(): SpaceDocVersion | null {\n    const doc = this.doc();\n    if (!doc) {\n      return null;\n    }\n\n    return doc.version ?? SpaceDocVersion.LEGACY;\n  }\n\n  getSpaceKey(): string | null {\n    const doc = this.doc();\n    if (!doc) {\n      return null;\n    }\n\n    return DatabaseDirectory.getSpaceKey(doc);\n  }\n\n  getInlineObjectCount(): number | null {\n    const doc = this.doc();\n    if (!doc) {\n      return null;\n    }\n\n    return Object.keys(doc.objects ?? {}).length;\n  }\n\n  getLinkedObjectCount(): number | null {\n    const doc = this.doc();\n    if (!doc) {\n      return null;\n    }\n\n    return Object.keys(doc.links ?? {}).length;\n  }\n\n  getAllLinkedDocuments(): AutomergeUrl[] {\n    const doc = this.doc();\n    invariant(doc);\n\n    // .toString() to handle RawString.\n    return Object.values(doc.links ?? {}).map((s) => s.toString()) as AutomergeUrl[];\n  }\n\n  measureMetrics(): DocMetrics | null {\n    const doc = this.doc();\n    if (!doc) {\n      return null;\n    }\n    return measureDocMetrics(doc);\n  }\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport * as A from '@automerge/automerge';\n\nimport { log } from '@dxos/log';\n\nexport type DocMetrics = {\n  compressedByteSize: number;\n  loadTime: number;\n  mutationCount: number;\n};\n\n/**\n * WARN: Slow to run on large docs.\n */\nexport const measureDocMetrics = (doc: A.Doc<any>): DocMetrics => {\n  const snapshot = A.save(doc);\n\n  const start = Date.now();\n  const temp = A.load(snapshot);\n  const end = Date.now();\n  A.free(temp);\n\n  const getAllChangesStart = Date.now();\n  const mutationCount = A.getAllChanges(doc).length;\n  const getAllChangesEnd = Date.now();\n\n  if (getAllChangesEnd - getAllChangesStart > 300) {\n    log.warn('getAllChanges took too long', { elapsed: getAllChangesEnd - getAllChangesStart });\n  }\n\n  return {\n    compressedByteSize: snapshot.byteLength,\n    loadTime: end - start,\n    mutationCount,\n  };\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { cbor } from '@automerge/automerge-repo';\n\nimport { Mutex, scheduleTask, scheduleMicroTask } from '@dxos/async';\nimport { Context, Resource } from '@dxos/context';\nimport { randomUUID } from '@dxos/crypto';\nimport type { CollectionId } from '@dxos/echo-protocol';\nimport { type EdgeConnection } from '@dxos/edge-client';\nimport { invariant } from '@dxos/invariant';\nimport type { SpaceId } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { EdgeService, type AutomergeProtocolMessage, type PeerId } from '@dxos/protocols';\nimport { buf } from '@dxos/protocols/buf';\nimport {\n  type Message as RouterMessage,\n  MessageSchema as RouterMessageSchema,\n} from '@dxos/protocols/buf/dxos/edge/messenger_pb';\nimport { bufferToArray } from '@dxos/util';\n\nimport { InflightRequestLimiter } from './inflight-request-limiter';\nimport {\n  getSpaceIdFromCollectionId,\n  type EchoReplicator,\n  type EchoReplicatorContext,\n  type ReplicatorConnection,\n  type ShouldAdvertiseParams,\n  type ShouldSyncCollectionParams,\n} from '../automerge';\n\n/**\n * Delay before restarting the connection after receiving a forbidden error.\n */\nconst INITIAL_RESTART_DELAY = 500;\nconst RESTART_DELAY_JITTER = 250;\nconst MAX_RESTART_DELAY = 5000;\n\nexport type EchoEdgeReplicatorParams = {\n  edgeConnection: EdgeConnection;\n  disableSharePolicy?: boolean;\n};\n\nexport class EchoEdgeReplicator implements EchoReplicator {\n  private readonly _edgeConnection: EdgeConnection;\n  private readonly _mutex = new Mutex();\n\n  private _ctx?: Context = undefined;\n  private _context: EchoReplicatorContext | null = null;\n  private _connectedSpaces = new Set<SpaceId>();\n  private _connections = new Map<SpaceId, EdgeReplicatorConnection>();\n  private _sharePolicyEnabled = true;\n\n  constructor({ edgeConnection, disableSharePolicy }: EchoEdgeReplicatorParams) {\n    this._edgeConnection = edgeConnection;\n    this._sharePolicyEnabled = !disableSharePolicy;\n  }\n\n  async connect(context: EchoReplicatorContext): Promise<void> {\n    log('connecting...', { peerId: context.peerId, connectedSpaces: this._connectedSpaces.size });\n    this._context = context;\n    this._ctx = Context.default();\n    this._ctx.onDispose(\n      this._edgeConnection.onReconnected(() => {\n        this._ctx && scheduleMicroTask(this._ctx, () => this._handleReconnect());\n      }),\n    );\n  }\n\n  private async _handleReconnect(): Promise<void> {\n    using _guard = await this._mutex.acquire();\n\n    const spaces = [...this._connectedSpaces];\n    for (const connection of this._connections.values()) {\n      await connection.close();\n    }\n    this._connections.clear();\n\n    if (this._context !== null) {\n      for (const spaceId of spaces) {\n        await this._openConnection(spaceId);\n      }\n    }\n  }\n\n  async disconnect(): Promise<void> {\n    using _guard = await this._mutex.acquire();\n    await this._ctx?.dispose();\n\n    for (const connection of this._connections.values()) {\n      await connection.close();\n    }\n    this._connections.clear();\n  }\n\n  async connectToSpace(spaceId: SpaceId): Promise<void> {\n    using _guard = await this._mutex.acquire();\n\n    if (this._connectedSpaces.has(spaceId)) {\n      return;\n    }\n    this._connectedSpaces.add(spaceId);\n\n    // Check if AM-repo requested that we connect to remote peers.\n    if (this._context !== null) {\n      await this._openConnection(spaceId);\n    }\n  }\n\n  async disconnectFromSpace(spaceId: SpaceId): Promise<void> {\n    using _guard = await this._mutex.acquire();\n\n    this._connectedSpaces.delete(spaceId);\n\n    const connection = this._connections.get(spaceId);\n    if (connection) {\n      await connection.close();\n      this._connections.delete(spaceId);\n    }\n  }\n\n  private async _openConnection(spaceId: SpaceId, reconnects: number = 0): Promise<void> {\n    invariant(this._context);\n    invariant(!this._connections.has(spaceId));\n\n    let restartScheduled = false;\n\n    const connection = new EdgeReplicatorConnection({\n      edgeConnection: this._edgeConnection,\n      spaceId,\n      context: this._context,\n      sharedPolicyEnabled: this._sharePolicyEnabled,\n      onRemoteConnected: async () => {\n        this._context?.onConnectionOpen(connection);\n      },\n      onRemoteDisconnected: async () => {\n        this._context?.onConnectionClosed(connection);\n      },\n      onRestartRequested: async () => {\n        if (!this._ctx || restartScheduled) {\n          return;\n        }\n\n        const restartDelay =\n          Math.min(MAX_RESTART_DELAY, INITIAL_RESTART_DELAY * reconnects) + Math.random() * RESTART_DELAY_JITTER;\n\n        log('connection restart scheduled', { spaceId, reconnects, restartDelay });\n\n        restartScheduled = true;\n        scheduleTask(\n          this._ctx,\n          async () => {\n            using _guard = await this._mutex.acquire();\n            if (this._connections.get(spaceId) !== connection) {\n              return;\n            }\n\n            const ctx = this._ctx;\n            await connection.close(); // Will call onRemoteDisconnected\n            this._connections.delete(spaceId);\n            if (ctx?.disposed) {\n              return;\n            }\n            await this._openConnection(spaceId, reconnects + 1);\n          },\n          restartDelay,\n        );\n      },\n    });\n    this._connections.set(spaceId, connection);\n\n    await connection.open();\n  }\n}\n\ntype EdgeReplicatorConnectionsParams = {\n  edgeConnection: EdgeConnection;\n  spaceId: SpaceId;\n  context: EchoReplicatorContext;\n  sharedPolicyEnabled: boolean;\n  onRemoteConnected: () => Promise<void>;\n  onRemoteDisconnected: () => Promise<void>;\n  onRestartRequested: () => Promise<void>;\n};\n\nconst MAX_INFLIGHT_REQUESTS = 5;\nconst MAX_RATE_LIMIT_WAIT_TIME_MS = 3000;\n\nclass EdgeReplicatorConnection extends Resource implements ReplicatorConnection {\n  private readonly _edgeConnection: EdgeConnection;\n  private readonly _remotePeerId: string | null = null;\n  private readonly _targetServiceId: string;\n  private readonly _spaceId: SpaceId;\n  private readonly _context: EchoReplicatorContext;\n  private readonly _sharedPolicyEnabled: boolean;\n  private readonly _onRemoteConnected: () => Promise<void>;\n  private readonly _onRemoteDisconnected: () => Promise<void>;\n  private readonly _onRestartRequested: () => void;\n\n  private _requestLimiter = new InflightRequestLimiter({\n    maxInflightRequests: MAX_INFLIGHT_REQUESTS,\n    resetBalanceTimeoutMs: MAX_RATE_LIMIT_WAIT_TIME_MS,\n  });\n\n  private _readableStreamController!: ReadableStreamDefaultController<AutomergeProtocolMessage>;\n\n  public readable: ReadableStream<AutomergeProtocolMessage>;\n  public writable: WritableStream<AutomergeProtocolMessage>;\n\n  constructor({\n    edgeConnection,\n    spaceId,\n    context,\n    sharedPolicyEnabled,\n    onRemoteConnected,\n    onRemoteDisconnected,\n    onRestartRequested,\n  }: EdgeReplicatorConnectionsParams) {\n    super();\n    this._edgeConnection = edgeConnection;\n    this._spaceId = spaceId;\n    this._context = context;\n    // Generate a unique peer id for every connection.\n    // This way automerge-repo will have separate sync states for every connection.\n    // This is important because the previous connection might have had some messages that failed to deliver\n    // abd if we don't clear the sync-state, automerge will not attempt to deliver them again.\n    this._remotePeerId = `${EdgeService.AUTOMERGE_REPLICATOR}:${spaceId}-${randomUUID()}`;\n    this._targetServiceId = `${EdgeService.AUTOMERGE_REPLICATOR}:${spaceId}`;\n    this._sharedPolicyEnabled = sharedPolicyEnabled;\n    this._onRemoteConnected = onRemoteConnected;\n    this._onRemoteDisconnected = onRemoteDisconnected;\n    this._onRestartRequested = onRestartRequested;\n\n    this.readable = new ReadableStream<AutomergeProtocolMessage>({\n      start: (controller) => {\n        this._readableStreamController = controller;\n      },\n    });\n\n    this.writable = new WritableStream<AutomergeProtocolMessage>({\n      write: async (message: AutomergeProtocolMessage, controller) => {\n        await this._requestLimiter.rateLimit(message);\n\n        await this._sendMessage(message);\n      },\n    });\n  }\n\n  protected override async _open(ctx: Context): Promise<void> {\n    log('opening...');\n\n    await this._requestLimiter.open();\n\n    // TODO: handle reconnects\n    this._ctx.onDispose(\n      this._edgeConnection.onMessage((msg: RouterMessage) => {\n        this._onMessage(msg);\n      }),\n    );\n\n    await this._onRemoteConnected();\n  }\n\n  protected override async _close(): Promise<void> {\n    log('closing...');\n    this._readableStreamController.close();\n\n    await this._requestLimiter.close();\n\n    await this._onRemoteDisconnected();\n  }\n\n  get peerId(): string {\n    invariant(this._remotePeerId, 'Not connected');\n    return this._remotePeerId;\n  }\n\n  async shouldAdvertise(params: ShouldAdvertiseParams): Promise<boolean> {\n    if (!this._sharedPolicyEnabled) {\n      return true;\n    }\n    const spaceId = await this._context.getContainingSpaceIdForDocument(params.documentId);\n    if (!spaceId) {\n      const remoteDocumentExists = await this._context.isDocumentInRemoteCollection({\n        documentId: params.documentId,\n        peerId: this._remotePeerId as PeerId,\n      });\n\n      log.verbose('document not found locally for share policy check', {\n        documentId: params.documentId,\n        acceptDocument: remoteDocumentExists,\n        remoteId: this._remotePeerId,\n      });\n\n      // If a document is not present locally return true only if it already exists on edge.\n      // Simply returning true will add edge to \"generous peers list\" for this document which will\n      // start replication of the document after we receive it potentially pushing it to replicator of the wrong space.\n      return remoteDocumentExists;\n    }\n    return spaceId === this._spaceId;\n  }\n\n  shouldSyncCollection(params: ShouldSyncCollectionParams): boolean {\n    if (!this._sharedPolicyEnabled) {\n      return true;\n    }\n    const spaceId = getSpaceIdFromCollectionId(params.collectionId as CollectionId);\n    // Only sync collections of form space:id:rootDoc, edge ignores legacy space:id collections\n    return spaceId === this._spaceId && params.collectionId.split(':').length === 3;\n  }\n\n  private _onMessage(message: RouterMessage): void {\n    if (message.serviceId !== this._targetServiceId) {\n      return;\n    }\n\n    const payload = cbor.decode(message.payload!.value) as AutomergeProtocolMessage;\n    log.verbose('received', {\n      type: payload.type,\n      documentId: payload.type === 'sync' && payload.documentId,\n      remoteId: this._remotePeerId,\n    });\n\n    // Fix the peer id.\n    payload.senderId = this._remotePeerId! as PeerId;\n    this._processMessage(payload);\n  }\n\n  private _processMessage(message: AutomergeProtocolMessage): void {\n    // There's a race between the credentials being replicated that are needed for access control and the data replication.\n    // AutomergeReplicator might return a Forbidden error if the credentials are not yet replicated.\n    // We restart the connection with some delay to account for that.\n    if (isForbiddenErrorMessage(message)) {\n      this._onRestartRequested();\n      return;\n    }\n\n    this._requestLimiter.handleResponse(message);\n\n    this._readableStreamController.enqueue(message);\n  }\n\n  private async _sendMessage(message: AutomergeProtocolMessage): Promise<void> {\n    // Fix the peer id.\n    (message as any).targetId = this._targetServiceId as PeerId;\n\n    log.verbose('sending...', {\n      type: message.type,\n      documentId: message.type === 'sync' && message.documentId,\n      remoteId: this._remotePeerId,\n    });\n\n    const encoded = cbor.encode(message);\n\n    await this._edgeConnection.send(\n      buf.create(RouterMessageSchema, {\n        serviceId: this._targetServiceId,\n        source: {\n          identityKey: this._edgeConnection.identityKey,\n          peerKey: this._edgeConnection.peerKey,\n        },\n        payload: { value: bufferToArray(encoded) },\n      }),\n    );\n  }\n}\n\n/**\n * This message is sent by EDGE AutomergeReplicator when the authorization is denied.\n */\nconst isForbiddenErrorMessage = (message: AutomergeProtocolMessage) =>\n  message.type === 'error' && message.message === 'Forbidden';\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { Trigger } from '@dxos/async';\nimport { Resource } from '@dxos/context';\nimport { log } from '@dxos/log';\nimport { type AutomergeProtocolMessage } from '@dxos/protocols';\n\ntype InflightRequestLimiterConfig = {\n  maxInflightRequests: number;\n  resetBalanceTimeoutMs: number;\n};\n\nexport class InflightRequestLimiter extends Resource {\n  /**\n   * Decrement when we receive a sync message, increment when we send one.\n   * Can't exceed _config.maxInflightRequests.\n   * Resets after timeout to avoid replicator being stuck.\n   */\n  private _inflightRequestBalance = 0;\n  private _requestBarrier = new Trigger();\n  private _resetBalanceTimeout: NodeJS.Timeout | undefined;\n\n  constructor(private readonly _config: InflightRequestLimiterConfig) {\n    super();\n  }\n\n  protected override async _open(): Promise<void> {\n    this._inflightRequestBalance = 0;\n    this._requestBarrier.reset();\n    this._requestBarrier.wake();\n  }\n\n  protected override async _close(): Promise<void> {\n    this._inflightRequestBalance = 0;\n    this._requestBarrier.throw(new Error('Rate limiter closed.'));\n    clearTimeout(this._resetBalanceTimeout);\n  }\n\n  public async rateLimit(message: AutomergeProtocolMessage): Promise<void> {\n    if (message.type !== 'sync') {\n      return;\n    }\n    while (this._inflightRequestBalance >= this._config.maxInflightRequests) {\n      await this._requestBarrier.wait();\n    }\n    this._inflightRequestBalance++;\n    if (this._inflightRequestBalance === this._config.maxInflightRequests) {\n      this._requestBarrier.reset();\n      this._resetBalanceTimeout = setTimeout(() => {\n        log.warn('Request balance has not changed during specified timeout, resetting request limiter.');\n        this._inflightRequestBalance = 0;\n        this._requestBarrier.wake();\n      }, this._config.resetBalanceTimeoutMs);\n    }\n  }\n\n  public handleResponse(message: AutomergeProtocolMessage): void {\n    if (message.type !== 'sync') {\n      return;\n    }\n    this._inflightRequestBalance--;\n    if (this._inflightRequestBalance + 1 === this._config.maxInflightRequests) {\n      this._requestBarrier.wake();\n      clearInterval(this._resetBalanceTimeout);\n    }\n  }\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { decodeReference, ObjectStructure, type DatabaseDirectory } from '@dxos/echo-protocol';\n\n/**\n * Assumes properties are at root.\n */\nexport const findInlineObjectOfType = (\n  spaceDoc: DatabaseDirectory,\n  typename: string,\n): [string, ObjectStructure] | undefined => {\n  for (const id in spaceDoc.objects ?? {}) {\n    const obj = spaceDoc.objects![id];\n    const objType = ObjectStructure.getTypeReference(obj);\n    if (objType && decodeReference(objType).objectId === typename) {\n      return [id, obj];\n    }\n  }\n\n  return undefined;\n};\n"],
  "mappings": "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",
  "names": ["UpdateScheduler", "Stream", "invariant", "SpaceId", "log", "next", "A", "UpdateScheduler", "Resource", "invariant", "log", "getBackend", "getHeads", "isAutomerge", "equals", "headsEquals", "save", "Repo", "interpretAsDocumentId", "Event", "asyncTimeout", "Context", "Resource", "cancelWithContext", "DatabaseDirectory", "invariant", "PublicKey", "log", "objectPointerCodec", "trace", "bufferToArray", "next", "am", "asyncReturn", "Event", "scheduleTask", "scheduleTaskInterval", "Resource", "log", "trace", "defaultMap", "MIN_QUERY_INTERVAL", "POLL_INTERVAL", "CollectionSynchronizer", "params", "_perCollectionStates", "Map", "_activeCollections", "Set", "_connectedPeers", "remoteStateUpdated", "_sendCollectionState", "sendCollectionState", "_queryCollectionState", "queryCollectionState", "_shouldSyncCollection", "shouldSyncCollection", "_open", "ctx", "_ctx", "collectionId", "keys", "has", "refreshCollection", "getRegisteredCollectionIds", "getLocalCollectionState", "get", "localState", "setLocalCollectionState", "state", "add", "_getOrCreatePerCollectionState", "queueMicrotask", "disposed", "_refreshInterestedPeers", "clearLocalCollectionState", "delete", "getRemoteCollectionStates", "remoteStates", "scheduleAnotherRefresh", "peerId", "interestedPeers", "lastQueried", "Date", "now", "set", "onConnectionOpen", "spanId", "getSpanName", "spanStart", "id", "methodName", "instance", "parentCtx", "showInBrowserTimeline", "attributes", "entries", "onConnectionClosed", "perCollectionState", "values", "onCollectionStateQueried", "onRemoteStateReceived", "validateCollectionState", "existingState", "documents", "diff", "diffCollectionState", "different", "length", "spanEnd", "missingOnLocal", "emit", "newDocsAppeared", "undefined", "resource", "local", "remote", "allDocuments", "Object", "missingOnRemote", "documentId", "push", "equals", "forEach", "heads", "isValidDocumentId", "Error", "Array", "isArray", "some", "head", "includes", "NetworkAdapter", "synchronized", "Trigger", "LifecycleState", "invariant", "log", "isNonNullable", "MESSAGE_TYPE_COLLECTION_QUERY", "MESSAGE_TYPE_COLLECTION_STATE", "isCollectionQueryMessage", "message", "type", "MESSAGE_TYPE_COLLECTION_QUERY", "isCollectionStateMessage", "MESSAGE_TYPE_COLLECTION_STATE", "EchoNetworkAdapter", "NetworkAdapter", "_params", "_replicators", "Set", "_connections", "Map", "_lifecycleState", "LifecycleState", "CLOSED", "_connected", "Trigger", "_ready", "isReady", "OPEN", "whenReady", "wait", "connect", "peerId", "peerMetadata", "wake", "send", "message", "_send", "disconnect", "open", "close", "replicator", "clear", "reset", "whenConnected", "timeout", "onConnectionAuthScopeChanged", "peer", "entry", "get", "_onConnectionAuthScopeChanged", "connection", "addReplicator", "invariant", "has", "add", "onConnectionOpen", "_onConnectionOpen", "bind", "onConnectionClosed", "_onConnectionClosed", "isDocumentInRemoteCollection", "getContainingSpaceForDocument", "getContainingSpaceIdForDocument", "documentId", "key", "createIdFromSpaceKey", "removeReplicator", "delete", "shouldAdvertise", "params", "shouldSyncCollection", "queryCollectionState", "collectionId", "targetId", "type", "senderId", "sendCollectionState", "state", "getPeersInterestedInCollection", "Array", "from", "values", "map", "filter", "isNonNullable", "connectionEntry", "Error", "start", "Date", "now", "writer", "write", "then", "monitor", "recordMessageSent", "catch", "err", "isOpen", "log", "recordMessageSendingFailed", "reader", "readable", "getReader", "writable", "getWriter", "set", "queueMicrotask", "done", "value", "read", "_onMessage", "_emitPeerCandidate", "recordPeerConnected", "isCollectionQueryMessage", "onCollectionStateQueried", "isCollectionStateMessage", "onCollectionStateReceived", "emit", "recordMessageReceived", "recordPeerDisconnected", "cancel", "abort", "createEchoPeerMetadata", "dxos_peerSource", "isEchoPeerMetadata", "metadata", "headsEncoding", "HeadsStore", "db", "_db", "setHeads", "documentId", "heads", "batch", "put", "sublevel", "keyEncoding", "valueEncoding", "headsEncoding", "getHeads", "documentIds", "getMany", "LifecycleState", "Resource", "LevelDBStorageAdapter", "Resource", "_params", "load", "keyArray", "_lifecycleState", "LifecycleState", "OPEN", "undefined", "startMs", "Date", "now", "chunk", "db", "get", "encodingOptions", "monitor", "recordBytesLoaded", "byteLength", "recordLoadDuration", "err", "isLevelDbNotFoundError", "save", "binary", "batch", "callbacks", "beforeSave", "path", "put", "Buffer", "from", "write", "recordBytesStored", "afterSave", "recordStoreDuration", "remove", "del", "loadRange", "keyPrefix", "result", "key", "value", "iterator", "gte", "lte", "push", "data", "removeRange", "keyEncoder", "encode", "map", "k", "replaceAll", "join", "decode", "toString", "split", "format", "keyEncoding", "valueEncoding", "code", "FIND_PARAMS", "allowableStates", "AutomergeHost", "Resource", "db", "indexMetadataStore", "dataMonitor", "peerIdProvider", "getSpaceKeyByRootDocumentId", "_collectionSynchronizer", "CollectionSynchronizer", "queryCollectionState", "_queryCollectionState", "bind", "sendCollectionState", "_sendCollectionState", "shouldSyncCollection", "_shouldSyncCollection", "collectionStateUpdated", "Event", "documentsSaved", "_db", "_storage", "LevelDBStorageAdapter", "sublevel", "callbacks", "beforeSave", "params", "_beforeSave", "afterSave", "key", "_afterSave", "monitor", "_echoNetworkAdapter", "EchoNetworkAdapter", "getContainingSpaceForDocument", "_getContainingSpaceForDocument", "isDocumentInRemoteCollection", "_isDocumentInRemoteCollection", "onCollectionStateQueried", "_onCollectionStateQueried", "onCollectionStateReceived", "_onCollectionStateReceived", "_headsStore", "HeadsStore", "_indexMetadataStore", "_peerIdProvider", "_getSpaceKeyByRootDocumentId", "_open", "_peerId", "PublicKey", "random", "toHex", "open", "_repo", "Repo", "peerId", "sharePolicy", "_sharePolicy", "storage", "network", "updatingAuthScope", "wrap", "on", "_ctx", "e", "_onPeerConnected", "_onPeerDisconnected", "remoteStateUpdated", "collectionId", "newDocsAppeared", "_onRemoteCollectionStateUpdated", "emit", "onConnectionAuthScopeChanged", "whenConnected", "_close", "close", "dispose", "repo", "loadedDocsCount", "Object", "keys", "handles", "length", "addReplicator", "replicator", "removeReplicator", "loadDoc", "ctx", "documentId", "opts", "handle", "find", "isReady", "timeout", "cancelWithContext", "whenReady", "asyncTimeout", "exportDoc", "id", "interpretAsDocumentId", "chunks", "loadRange", "bufferToArray", "Buffer", "concat", "map", "c", "data", "createDoc", "initialValue", "preserveHistory", "Uint8Array", "import", "isAutomerge", "TypeError", "save", "Error", "create", "waitUntilHeadsReplicated", "heads", "entries", "documentIds", "entry", "documentHeads", "getHeads", "headsToWait", "filter", "index", "targetHeads", "currentHeads", "headsEquals", "Promise", "all", "Context", "default", "waitForHeads", "flush", "reIndexHeads", "log", "warn", "batch", "setHeads", "write", "startsWith", "peerMetadata", "peerMetadataByPeerId", "isEchoPeerMetadata", "shouldAdvertise", "path", "doc", "spaceKey", "DatabaseDirectory", "getSpaceKey", "undefined", "objectIds", "objects", "encodedIds", "objectId", "objectPointerCodec", "encode", "idToLastHash", "Map", "markDirty", "notifyMarkedDirty", "document", "_onHeadsChanged", "_automergePeers", "peers", "getRegisteredCollectionIds", "remoteCollections", "getRemoteCollectionStates", "remotePeerDocs", "get", "documents", "state", "spaceKeyHex", "from", "rootDocSpaceKey", "loadedDocuments", "result", "storeRequestIds", "storeResultIndices", "push", "storedHeads", "i", "getLocalCollectionState", "refreshCollection", "getCollectionSyncState", "localState", "remoteState", "diff", "diffCollectionState", "missingOnRemote", "missingOnLocal", "differentDocuments", "different", "localDocumentCount", "remoteDocumentCount", "updateLocalCollectionState", "fromEntries", "setLocalCollectionState", "clearLocalCollectionState", "onRemoteStateReceived", "decodeCollectionState", "encodeCollectionState", "onConnectionOpen", "onConnectionClosed", "toReplicate", "count", "findWithProgress", "collectionsChanged", "Set", "newState", "structuredClone", "add", "info", "depth", "span", "showInBrowserTimeline", "resource", "unavailableHeads", "waitForCondition", "changeHash", "values", "changeIsPresentInDoc", "delete", "size", "getBackend", "getChangeByHash", "invariant", "invariant", "PublicKey", "log", "ComplexSet", "defaultMap", "A", "cbor", "Resource", "invariant", "log", "AutomergeReplicator", "DEFAULT_FACTORY", "params", "MeshReplicatorConnection", "_params", "remoteDeviceKey", "_remotePeerId", "_isEnabled", "readableStreamController", "readable", "ReadableStream", "start", "controller", "_ctx", "onDispose", "close", "writable", "WritableStream", "write", "message", "logSendSync", "replicatorExtension", "sendSyncMessage", "payload", "encode", "err", "error", "_disconnectIfEnabled", "createAutomergeReplicator", "replicatorFactory", "peerId", "ownPeerId", "onStartReplication", "info", "remotePeerId", "id", "thisPeerId", "toHex", "onRemoteConnected", "onSyncMessage", "decode", "enqueue", "onClose", "onRemoteDisconnected", "isEnabled", "shouldAdvertise", "shouldSyncCollection", "enable", "disable", "decodedSyncMessage", "type", "data", "decodeSyncMessage", "undefined", "sync", "headsLength", "heads", "length", "requesting", "need", "sendingChanges", "changes", "from", "senderId", "to", "targetId", "invariant", "SpaceId", "deriveCollectionIdFromSpaceId", "spaceId", "rootDocumentId", "getSpaceIdFromCollectionId", "collectionId", "split", "isValid", "MeshEchoReplicator", "_connectionsPerPeer", "Map", "_connections", "Set", "_authorizedDevices", "_context", "connect", "context", "disconnect", "connection", "isEnabled", "onConnectionClosed", "close", "clear", "createExtension", "extensionFactory", "invariant", "MeshReplicatorConnection", "ownPeerId", "peerId", "replicatorFactory", "onRemoteConnected", "log", "existingConnections", "get", "length", "enabledConnection", "onConnectionAuthScopeChanged", "push", "set", "onConnectionOpen", "enable", "onRemoteDisconnected", "delete", "index", "indexOf", "warn", "splice", "disable", "shouldAdvertise", "params", "documentId", "spaceKey", "getContainingSpaceForDocument", "remoteDocumentExists", "isDocumentInRemoteCollection", "acceptDocument", "spaceId", "createIdFromSpaceKey", "authorizedDevices", "remoteDeviceKey", "isAuthorized", "has", "localPeer", "remotePeer", "deviceKey", "err", "catch", "shouldSyncCollection", "collectionId", "getSpaceIdFromCollectionId", "add", "replicatorExtension", "authorizeDevice", "defaultMap", "ComplexSet", "PublicKey", "hash", "equals", "trace", "CircularBuffer", "mapValues", "SlidingWindowSummary", "PER_SECOND_RATE_AVG_WINDOW_SIZE", "DEFAULT_AVG_WINDOW_SIZE", "EchoDataMonitor", "_params", "timeSeriesLength", "_lastTick", "_activeCounters", "createLocalCounters", "_localTimeSeries", "createLocalTimeSeries", "_storageAverages", "createStorageAverages", "_replicationAverages", "createNetworkAverages", "_sizeByMessage", "_lastReceivedMessages", "CircularBuffer", "_lastSentMessages", "_connectionsCount", "tick", "timeMs", "_advanceTimeWindow", "computeStats", "meta", "rateAverageOverSeconds", "storage", "reads", "payloadSize", "loadedChunkSize", "average", "opDuration", "loadDuration", "countPerSecond", "loadsPerSecond", "writes", "storedChunkSize", "storeDuration", "storesPerSecond", "replicator", "connections", "receivedMessages", "receivedMessageSize", "receivedPerSecond", "sentMessages", "sentMessageSize", "sendDuration", "sentPerSecond", "failedPerSecond", "sendsFailedPerSecond", "countByMessage", "_computeMessageHistogram", "avgSizeByMessage", "mapValues", "summary", "connectionsCount", "lastPerSecondStats", "_lastCompleteCounters", "timeSeries", "replication", "messagesByPeerId", "millisPassed", "oldMetrics", "Object", "freeze", "peerId", "keys", "byPeerId", "createMessageCounter", "_addToTimeSeries", "Math", "abs", "_reportPerSecondRate", "values", "key", "value", "entries", "push", "length", "shift", "metrics", "toReport", "loadedChunks", "storedChunks", "received", "sent", "metricName", "metric", "record", "trace", "distribution", "increment", "tags", "status", "failed", "recordPeerConnected", "recordPeerDisconnected", "recordBytesStored", "count", "storedBytes", "unit", "recordLoadDuration", "durationMs", "recordStoreDuration", "recordBytesLoaded", "loadedBytes", "recordMessageSent", "message", "duration", "metricsGroupName", "bytes", "getByteCount", "type", "isAutomergeProtocolMessage", "success", "messageSize", "messageCounts", "_getStatsForType", "targetId", "recordMessageReceived", "senderId", "recordMessageSendingFailed", "createSlidingWindow", "byType", "groupKey", "result", "receivedMessage", "counters", "resource", "isCollectionQueryMessage", "isCollectionStateMessage", "overrides", "SlidingWindowSummary", "dataPoints", "precision", "data", "byteLength", "documentId", "MAX_UPDATE_FREQ", "DocumentsSynchronizer", "Resource", "_params", "_syncStates", "Map", "_pendingUpdates", "Set", "_sendUpdatesJob", "undefined", "addDocuments", "documentIds", "retryCounter", "log", "warn", "documentId", "repo", "find", "then", "doc", "whenReady", "_startSync", "add", "trigger", "catch", "error", "removeDocuments", "get", "clearSubscriptions", "delete", "_open", "UpdateScheduler", "_ctx", "_checkAndSendUpdates", "bind", "maxFrequency", "_close", "join", "clear", "update", "updates", "mutation", "isNew", "FIND_PARAMS", "A", "loadIncremental", "_writeMutation", "has", "syncState", "handle", "_subscribeForChanges", "set", "handler", "on", "off", "docsWithPendingUpdates", "Array", "from", "_getPendingChanges", "push", "length", "sendUpdates", "invariant", "isReady", "lastSentHead", "saveSince", "save", "getHeads", "headsBefore", "newDoc", "equals", "DataServiceImpl", "params", "_subscriptions", "Map", "_automergeHost", "automergeHost", "_spaceStateManager", "spaceStateManager", "_updateIndexes", "updateIndexes", "subscribe", "request", "Stream", "next", "ready", "synchronizer", "DocumentsSynchronizer", "repo", "sendUpdates", "updates", "open", "then", "set", "subscriptionId", "catch", "err", "log", "close", "updateSubscription", "get", "invariant", "addIds", "length", "addDocuments", "removeIds", "removeDocuments", "update", "flush", "getDocumentHeads", "documentIds", "heads", "entries", "getHeads", "map", "idx", "documentId", "waitUntilHeadsReplicated", "options", "reIndexHeads", "subscribeSpaceSyncState", "ctx", "spaceId", "SpaceId", "isValid", "rootDocumentId", "getSpaceRootDocumentId", "collectionId", "deriveCollectionIdFromSpaceId", "spaceDocumentListUpdated", "on", "event", "newId", "spaceRootId", "scheduler", "trigger", "UpdateScheduler", "state", "getCollectionSyncState", "peers", "peer", "peerId", "missingOnRemote", "missingOnLocal", "differentDocuments", "localDocumentCount", "remoteDocumentCount", "collectionStateUpdated", "e", "LifecycleState", "Resource", "todo", "createIdFromSpaceKey", "SpaceDocVersion", "IndexMetadataStore", "IndexStore", "Indexer", "invariant", "IndexKind", "trace", "A", "Context", "DatabaseDirectory", "SpaceDocVersion", "invariant", "log", "ObjectPointerVersion", "objectPointerCodec", "LOG_VIEW_OPERATION_THRESHOLD", "createSelectedDocumentsIterator", "automergeHost", "loadDocuments", "objects", "id", "heads", "entries", "documentId", "objectId", "decode", "handle", "loadDoc", "default", "doc", "currentHeads", "getHeads", "equals", "begin", "Date", "now", "view", "end", "duration", "requestedHeads", "originalHeads", "version", "CURRENT", "newId", "getVersion", "V0", "spaceKey", "getSpaceKey", "undefined", "encode", "object", "error", "getHeads", "Schema", "DeferredTask", "scheduleMicroTask", "synchronized", "Stream", "Context", "Resource", "raise", "DatabaseDirectory", "QueryAST", "log", "objectPointerCodec", "trace", "Match", "Context", "ContextDisposedError", "LifecycleState", "Resource", "DatabaseDirectory", "isEncodedReference", "ObjectStructure", "EscapedPropPath", "invariant", "DXN", "PublicKey", "log", "objectPointerCodec", "getDeep", "isNonNullable", "invariant", "BaseError", "QueryError", "BaseError", "extend", "QueryPlan", "Plan", "Object", "freeze", "make", "steps", "FilterStep", "isNoop", "step", "filter", "type", "typename", "id", "undefined", "length", "props", "keys", "foreignKeys", "DEFAULT_OPTIONS", "defaultTextSearchKind", "QueryPlanner", "options", "_options", "createPlan", "query", "plan", "_generate", "DEFAULT_CONTEXT", "originalQuery", "_optimizeEmptyFilters", "_optimizeSoloUnions", "context", "type", "_generateOptionsClause", "_generateSelectClause", "_generateFilterClause", "_generateIncomingReferencesClause", "_generateRelationClause", "_generateRelationTraversalClause", "_generateReferenceTraversalClause", "_generateUnionClause", "_generateSetDifferenceClause", "QueryError", "newContext", "spaceIds", "selectionSpaces", "deleted", "deletedHandling", "_generateSelectionFromFilter", "filter", "selectionInverted", "id", "undefined", "typename", "Object", "keys", "props", "length", "QueryPlan", "Plan", "make", "_tag", "_generateDeletedHandlingSteps", "spaces", "selector", "objectIds", "inverted", "text", "searchKind", "filters", "every", "isTrivialTypenameFilter", "typenames", "map", "f", "invariant", "mode", "plans", "queries", "source", "exclude", "anchor", "steps", "traversal", "direction", "property", "createRelationTraversalStep", "anchorPlan", "NOOP_FILTER", "selection", "step", "FilterStep", "isNoop", "foreignKeys", "ExecutionTrace", "Object", "freeze", "makeEmpty", "name", "details", "objectCount", "documentsLoaded", "indexHits", "indexQueryTime", "documentLoadTime", "executionTime", "children", "format", "trace", "go", "indent", "repeat", "toFixed", "map", "child", "join", "TRACE_QUERY_EXECUTION", "QueryExecutor", "Resource", "options", "_trace", "_lastResultSet", "_indexer", "indexer", "_automergeHost", "automergeHost", "_spaceStateManager", "spaceStateManager", "_id", "queryId", "_query", "query", "_reactivity", "reactivity", "queryPlanner", "QueryPlanner", "_plan", "createPlan", "plan", "_open", "ctx", "_close", "getResults", "item", "id", "objectId", "documentId", "spaceId", "rank", "execQuery", "invariant", "_lifecycleState", "LifecycleState", "OPEN", "prevResultSet", "workingSet", "_execPlan", "JSON", "stringify", "changed", "length", "some", "index", "console", "log", "begin", "performance", "now", "step", "steps", "_ctx", "disposed", "ContextDisposedError", "result", "_execStep", "push", "newWorkingSet", "_tag", "_execSelectStep", "_execFilterStep", "_execFilterDeletedStep", "_execUnionStep", "_execSetDifferenceStep", "_execTraverseStep", "Error", "selector", "beginIndexQuery", "typenames", "inverted", "documentLoadStart", "results", "_loadDocumentsAfterIndexQuery", "filter", "isNonNullable", "spaces", "includes", "beginLoad", "items", "Promise", "all", "objectIds", "_loadFromDXN", "DXN", "fromLocalObjectId", "sourceSpaceId", "typename", "text", "kind", "Match", "type", "pipe", "withReturnType", "when", "orElseAbsurd", "searchKind", "filterMatchObject", "doc", "info", "expected", "mode", "ObjectStructure", "isDeleted", "traversal", "direction", "property", "EscapedPropPath", "unescape", "refs", "flatMap", "ref", "getDeep", "data", "Array", "isArray", "isEncodedReference", "parse", "warn", "graph", "anchors", "getRelationSource", "getRelationTarget", "Map", "resultSets", "plans", "resultSet", "set", "values", "sourceResult", "source", "excludeResult", "exclude", "findIndex", "i", "hit", "_loadFromIndexHit", "spaceKey", "spaceKeyInIndex", "objectPointerCodec", "decode", "handle", "loadDoc", "Context", "default", "DatabaseDirectory", "getSpaceKey", "object", "getInlineObject", "createIdFromSpaceKey", "PublicKey", "from", "dxn", "echoDxn", "asEchoDXN", "spaceRoot", "getRootBySpaceId", "dbDirectory", "inlineObject", "echoId", "link", "getLink", "QueryServiceImpl", "Resource", "_params", "_queries", "Set", "trace", "diagnostic", "id", "name", "fetch", "Array", "from", "map", "query", "JSON", "stringify", "executor", "plan", "_open", "indexer", "updated", "on", "_ctx", "invalidateQueries", "_updateQueries", "DeferredTask", "_executeQueries", "bind", "_close", "join", "Promise", "all", "close", "setConfig", "config", "execQuery", "request", "Stream", "next", "ctx", "queryEntry", "_createQuery", "scheduleMicroTask", "open", "schedule", "reindex", "log", "iterator", "createDocumentsIterator", "automergeHost", "ids", "Map", "documents", "heads", "set", "size", "count", "dirty", "onResults", "onError", "onClose", "parsedQuery", "QueryAST", "Query", "pipe", "Schema", "decodeUnknownSync", "parse", "QueryExecutor", "queryId", "raise", "Error", "reactivity", "spaceStateManager", "firstResult", "sendResults", "results", "disposed", "delete", "add", "begin", "performance", "now", "changed", "getResults", "err", "catch", "verbose", "duration", "span", "showInBrowserTimeline", "resource", "getAllDocuments", "visited", "getObjectsFromHandle", "handle", "has", "documentId", "isReady", "doc", "spaceKey", "DatabaseDirectory", "getSpaceKey", "undefined", "objects", "Object", "entries", "objectId", "object", "objectPointerCodec", "encode", "getHeads", "links", "values", "urlString", "toString", "linkHandle", "loadDoc", "Context", "default", "result", "repo", "handles", "interpretAsDocumentId", "isEqual", "Event", "UpdateScheduler", "Resource", "Context", "LifecycleState", "invariant", "interpretAsDocumentId", "DatabaseDirectory", "SpaceDocVersion", "invariant", "A", "log", "measureDocMetrics", "doc", "snapshot", "save", "start", "Date", "now", "temp", "load", "end", "free", "getAllChangesStart", "mutationCount", "getAllChanges", "length", "getAllChangesEnd", "warn", "elapsed", "compressedByteSize", "byteLength", "loadTime", "DatabaseRoot", "mapLinks", "doc", "mapping", "change", "d", "links", "key", "value", "Object", "entries", "documentId", "interpretAsDocumentId", "toString", "_rootHandle", "url", "isLoaded", "isReady", "handle", "getVersion", "version", "SpaceDocVersion", "LEGACY", "getSpaceKey", "DatabaseDirectory", "getInlineObjectCount", "keys", "objects", "length", "getLinkedObjectCount", "getAllLinkedDocuments", "invariant", "values", "map", "s", "measureMetrics", "measureDocMetrics", "SpaceStateManager", "Resource", "_roots", "Map", "_rootBySpace", "_perRootContext", "_lastSpaceDocumentList", "spaceDocumentListUpdated", "Event", "_close", "ctx", "_", "rootCtx", "dispose", "clear", "roots", "getRootByDocumentId", "documentId", "get", "getSpaceRootDocumentId", "spaceId", "getRootBySpaceId", "invariant", "_lifecycleState", "LifecycleState", "OPEN", "undefined", "assignRootToSpace", "handle", "root", "has", "DatabaseRoot", "set", "prevRootId", "delete", "Context", "whenReady", "documentListCheckScheduler", "UpdateScheduler", "documentIds", "getAllLinkedDocuments", "map", "url", "interpretAsDocumentId", "isEqual", "emit", "SpaceDocumentListUpdatedEvent", "maxFrequency", "triggerCheckOnChange", "trigger", "addListener", "onDispose", "removeListener", "spaceRootId", "previousRootId", "DEFAULT_INDEXING_CONFIG", "fullText", "vector", "EchoHost", "Resource", "kv", "indexing", "peerIdProvider", "getSpaceKeyByRootDocumentId", "_spaceStateManager", "SpaceStateManager", "indexingConfig", "_indexMetadataStore", "IndexMetadataStore", "db", "sublevel", "_echoDataMonitor", "EchoDataMonitor", "_automergeHost", "AutomergeHost", "dataMonitor", "indexMetadataStore", "_indexer", "Indexer", "indexStore", "IndexStore", "metadataStore", "loadDocuments", "createSelectedDocumentsIterator", "indexCooldownTime", "process", "env", "NODE_ENV", "undefined", "setConfig", "enabled", "indexes", "kind", "IndexKind", "Kind", "SCHEMA_MATCH", "GRAPH", "FULL_TEXT", "VECTOR", "_queryService", "QueryServiceImpl", "automergeHost", "indexer", "spaceStateManager", "_dataService", "DataServiceImpl", "updateIndexes", "trace", "diagnostic", "id", "name", "fetch", "dataStats", "computeStats", "loadedDocsCount", "Array", "from", "roots", "values", "map", "root", "url", "isLoaded", "spaceKey", "getSpaceKey", "inlineObjects", "getInlineObjectCount", "linkedObjects", "getLinkedObjectCount", "measureMetrics", "queryService", "dataService", "automergeRepo", "repo", "_open", "ctx", "open", "spaceDocumentListUpdated", "on", "_ctx", "e", "previousRootId", "clearLocalCollectionState", "deriveCollectionIdFromSpaceId", "spaceId", "updateLocalCollectionState", "documentIds", "spaceRootId", "documentsSaved", "invalidateQueries", "_close", "close", "flush", "loadDoc", "documentId", "opts", "exportDoc", "createDoc", "initialValue", "createSpaceRoot", "invariant", "_lifecycleState", "LifecycleState", "OPEN", "createIdFromSpaceKey", "automergeRoot", "version", "SpaceDocVersion", "CURRENT", "access", "toHex", "objects", "links", "openSpaceRoot", "automergeUrl", "handle", "find", "FIND_PARAMS", "whenReady", "assignRootToSpace", "closeSpaceRoot", "todo", "addReplicator", "replicator", "removeReplicator", "cbor", "Mutex", "scheduleTask", "scheduleMicroTask", "Context", "Resource", "randomUUID", "invariant", "log", "EdgeService", "buf", "MessageSchema", "RouterMessageSchema", "bufferToArray", "Trigger", "Resource", "log", "InflightRequestLimiter", "_config", "_inflightRequestBalance", "_requestBarrier", "_open", "reset", "wake", "_close", "throw", "Error", "clearTimeout", "_resetBalanceTimeout", "rateLimit", "message", "type", "maxInflightRequests", "wait", "setTimeout", "warn", "resetBalanceTimeoutMs", "handleResponse", "clearInterval", "INITIAL_RESTART_DELAY", "RESTART_DELAY_JITTER", "MAX_RESTART_DELAY", "EchoEdgeReplicator", "edgeConnection", "disableSharePolicy", "_mutex", "Mutex", "_ctx", "undefined", "_context", "_connectedSpaces", "Set", "_connections", "Map", "_sharePolicyEnabled", "_edgeConnection", "connect", "context", "log", "peerId", "connectedSpaces", "size", "Context", "default", "onDispose", "onReconnected", "scheduleMicroTask", "_handleReconnect", "_guard", "acquire", "spaces", "connection", "values", "close", "clear", "spaceId", "_openConnection", "disconnect", "dispose", "connectToSpace", "has", "add", "disconnectFromSpace", "delete", "get", "reconnects", "invariant", "restartScheduled", "EdgeReplicatorConnection", "sharedPolicyEnabled", "onRemoteConnected", "onConnectionOpen", "onRemoteDisconnected", "onConnectionClosed", "onRestartRequested", "restartDelay", "Math", "min", "random", "scheduleTask", "ctx", "disposed", "set", "open", "MAX_INFLIGHT_REQUESTS", "MAX_RATE_LIMIT_WAIT_TIME_MS", "Resource", "_remotePeerId", "_requestLimiter", "InflightRequestLimiter", "maxInflightRequests", "resetBalanceTimeoutMs", "_spaceId", "EdgeService", "AUTOMERGE_REPLICATOR", "randomUUID", "_targetServiceId", "_sharedPolicyEnabled", "_onRemoteConnected", "_onRemoteDisconnected", "_onRestartRequested", "readable", "ReadableStream", "start", "controller", "_readableStreamController", "writable", "WritableStream", "write", "message", "rateLimit", "_sendMessage", "_open", "onMessage", "msg", "_onMessage", "_close", "shouldAdvertise", "params", "getContainingSpaceIdForDocument", "documentId", "remoteDocumentExists", "isDocumentInRemoteCollection", "verbose", "acceptDocument", "remoteId", "shouldSyncCollection", "getSpaceIdFromCollectionId", "collectionId", "split", "length", "serviceId", "payload", "cbor", "decode", "value", "type", "senderId", "_processMessage", "isForbiddenErrorMessage", "handleResponse", "enqueue", "targetId", "encoded", "encode", "send", "buf", "create", "RouterMessageSchema", "source", "identityKey", "peerKey", "bufferToArray", "decodeReference", "ObjectStructure", "findInlineObjectOfType", "spaceDoc", "typename", "id", "objects", "obj", "objType", "ObjectStructure", "getTypeReference", "decodeReference", "objectId", "undefined"]
}
