{
  "version": 3,
  "sources": ["../../../src/filter/filter-match.ts"],
  "sourcesContent": ["//\n// Copyright 2025 DXOS.org\n//\n\nimport { decodeReference, isEncodedReference, type QueryAST, type ObjectStructure } from '@dxos/echo-protocol';\nimport { EXPANDO_TYPENAME } from '@dxos/echo-schema';\nimport { DXN, type ObjectId, type SpaceId } from '@dxos/keys';\n\nexport type MatchedObject = {\n  id: ObjectId;\n  spaceId: SpaceId;\n  doc: ObjectStructure;\n};\n\n/**\n * Matches an object against a filter AST.\n */\nexport const filterMatchObject = (filter: QueryAST.Filter, obj: MatchedObject): boolean => {\n  switch (filter.type) {\n    case 'object': {\n      // Check typename if specified\n      if (filter.typename !== null) {\n        // TODO(dmaretskyi): `system` is missing in some cases.\n        if (!obj.doc.system?.type?.['/']) {\n          // Objects with no type are considered to be expando objects\n          const expectedDXN = DXN.parse(filter.typename).asTypeDXN();\n          if (expectedDXN?.type !== EXPANDO_TYPENAME) {\n            return false;\n          }\n        } else {\n          const actualDXN = DXN.parse(obj.doc.system.type['/']);\n          const expectedDXN = DXN.parse(filter.typename);\n\n          if (!compareTypename(expectedDXN, actualDXN)) {\n            return false;\n          }\n        }\n      }\n\n      // Check IDs if specified\n      if (filter.id && filter.id.length > 0 && !filter.id.includes(obj.id)) {\n        return false;\n      }\n\n      // Check properties\n      if (filter.props) {\n        for (const [key, valueFilter] of Object.entries(filter.props)) {\n          const value = obj.doc.data[key];\n          if (!filterMatchValue(valueFilter, value)) {\n            return false;\n          }\n        }\n      }\n\n      // Check foreign keys if specified\n      if (filter.foreignKeys && filter.foreignKeys.length > 0) {\n        const hasMatchingKey = filter.foreignKeys.some((filterKey) =>\n          obj.doc.meta.keys.some((objKey) => objKey.source === filterKey.source && objKey.id === filterKey.id),\n        );\n        if (!hasMatchingKey) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    case 'text-search': {\n      // TODO: Implement text search\n      return false;\n    }\n\n    case 'not': {\n      return !filterMatchObject(filter.filter, obj);\n    }\n\n    case 'and': {\n      return filter.filters.every((f) => filterMatchObject(f, obj));\n    }\n\n    case 'or': {\n      return filter.filters.some((f) => filterMatchObject(f, obj));\n    }\n\n    default:\n      return false;\n  }\n};\n\nexport const filterMatchValue = (filter: QueryAST.Filter, value: unknown): boolean => {\n  switch (filter.type) {\n    case 'compare': {\n      const compareValue = filter.value as any;\n      switch (filter.operator) {\n        case 'eq':\n          if (isEncodedReference(compareValue)) {\n            if (!isEncodedReference(value)) {\n              return false;\n            }\n            return DXN.equals(decodeReference(value).toDXN(), decodeReference(compareValue).toDXN());\n          }\n          return value === compareValue;\n        case 'neq':\n          return value !== compareValue;\n        case 'gt':\n          return (value as any) > compareValue;\n        case 'gte':\n          return (value as any) >= compareValue;\n        case 'lt':\n          return (value as any) < compareValue;\n        case 'lte':\n          return (value as any) <= compareValue;\n      }\n      break;\n    }\n    case 'in': {\n      return filter.values.includes(value);\n    }\n    case 'range': {\n      return (value as any) >= filter.from && (value as any) <= filter.to;\n    }\n    case 'not': {\n      return !filterMatchValue(filter.filter, value);\n    }\n    case 'and': {\n      return filter.filters.every((f) => filterMatchValue(f, value));\n    }\n    case 'or': {\n      return filter.filters.some((f) => filterMatchValue(f, value));\n    }\n    default:\n      return false;\n  }\n};\n\n/**\n * Compares typename DXNs.\n * @returns true if they match\n *\n * Compares typename string.\n * Missing version (on either actual or expected) matches any version.\n * non `type` DXNs are compared exactly.\n *\n * Examples: (expected) (actual)\n *\n * dxn:type:example.org/type/Task       !== dxn:type:example.org/type/Contact\n * dxn:type:example.org/type/Task       === dxn:type:example.org/type/Task\n * dxn:type:example.org/type/Task:0.1.0 !== dxn:type:example.org/type/Task:0.2.0\n * dxn:type:example.org/type/Task       === dxn:type:example.org/type/Task:0.1.0\n * dxn:type:example.org/type/Task:0.1.0 === dxn:type:example.org/type/Task\n *\n */\nconst compareTypename = (expectedDXN: DXN, actualDXN: DXN): boolean => {\n  const expectedTypeDXN = expectedDXN.asTypeDXN();\n  if (expectedTypeDXN) {\n    const actualTypeDXN = actualDXN.asTypeDXN();\n    if (!actualTypeDXN) {\n      return false;\n    }\n    if (\n      actualTypeDXN.type !== expectedTypeDXN.type ||\n      (expectedTypeDXN.version !== undefined &&\n        actualTypeDXN.version !== undefined &&\n        actualTypeDXN.version !== expectedTypeDXN.version)\n    ) {\n      return false;\n    }\n  } else {\n    if (!DXN.equals(actualDXN, expectedDXN)) {\n      return false;\n    }\n  }\n  return true;\n};\n"],
  "mappings": "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",
  "names": ["filterMatchObject", "filter", "obj", "type", "typename", "doc", "system", "expectedDXN", "DXN", "parse", "asTypeDXN", "EXPANDO_TYPENAME", "actualDXN", "compareTypename", "id", "length", "includes", "props", "key", "valueFilter", "Object", "entries", "value", "data", "filterMatchValue", "foreignKeys", "hasMatchingKey", "some", "filterKey", "meta", "keys", "objKey", "source", "filters", "every", "f", "compareValue", "operator", "isEncodedReference", "equals", "decodeReference", "toDXN", "values", "from", "to", "expectedTypeDXN", "actualTypeDXN", "version", "undefined"]
}
