"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var chunk_JXX6LF5U_exports = {};
__export(chunk_JXX6LF5U_exports, {
  AuthExtension: () => AuthExtension,
  AuthStatus: () => AuthStatus,
  CredentialRetrieverExtension: () => CredentialRetrieverExtension,
  CredentialServerExtension: () => CredentialServerExtension,
  MOCK_AUTH_PROVIDER: () => MOCK_AUTH_PROVIDER,
  MOCK_AUTH_VERIFIER: () => MOCK_AUTH_VERIFIER,
  MetadataStore: () => MetadataStore,
  Pipeline: () => Pipeline,
  Space: () => Space,
  SpaceManager: () => SpaceManager,
  SpaceProtocol: () => SpaceProtocol,
  SpaceProtocolSession: () => SpaceProtocolSession,
  TimeframeClock: () => TimeframeClock,
  codec: () => codec,
  createIdFromSpaceKey: () => createIdFromSpaceKey,
  createMappedFeedWriter: () => createMappedFeedWriter,
  hasInvitationExpired: () => hasInvitationExpired,
  mapFeedIndexesToTimeframe: () => mapFeedIndexesToTimeframe,
  mapTimeframeToFeedIndexes: () => mapTimeframeToFeedIndexes,
  startAfter: () => startAfter,
  valueEncoding: () => valueEncoding
});
module.exports = __toCommonJS(chunk_JXX6LF5U_exports);
var import_hypercore = require("@dxos/hypercore");
var import_proto = require("@dxos/protocols/proto");
var import_invariant = require("@dxos/invariant");
var import_crypto = require("@dxos/crypto");
var import_keys = require("@dxos/keys");
var import_util = require("@dxos/util");
var import_crc_32 = __toESM(require("crc-32"));
var import_async = require("@dxos/async");
var import_context = require("@dxos/context");
var import_invariant2 = require("@dxos/invariant");
var import_keys2 = require("@dxos/keys");
var import_log = require("@dxos/log");
var import_protocols = require("@dxos/protocols");
var import_proto2 = require("@dxos/protocols/proto");
var import_services = require("@dxos/protocols/proto/dxos/client/services");
var import_util2 = require("@dxos/util");
var import_async2 = require("@dxos/async");
var import_debug = require("@dxos/debug");
var import_log2 = require("@dxos/log");
var import_timeframe = require("@dxos/timeframe");
var import_async3 = require("@dxos/async");
var import_context2 = require("@dxos/context");
var import_debug2 = require("@dxos/debug");
var import_feed_store = require("@dxos/feed-store");
var import_invariant3 = require("@dxos/invariant");
var import_keys3 = require("@dxos/keys");
var import_log3 = require("@dxos/log");
var import_timeframe2 = require("@dxos/timeframe");
var import_util3 = require("@dxos/util");
var import_invariant4 = require("@dxos/invariant");
var import_log4 = require("@dxos/log");
var import_async4 = require("@dxos/async");
var import_context3 = require("@dxos/context");
var import_crypto2 = require("@dxos/crypto");
var import_invariant5 = require("@dxos/invariant");
var import_log5 = require("@dxos/log");
var import_proto3 = require("@dxos/protocols/proto");
var import_teleport = require("@dxos/teleport");
var import_async5 = require("@dxos/async");
var import_context4 = require("@dxos/context");
var import_invariant6 = require("@dxos/invariant");
var import_log6 = require("@dxos/log");
var import_credentials = require("@dxos/protocols/proto/dxos/halo/credentials");
var import_tracing = require("@dxos/tracing");
var import_util4 = require("@dxos/util");
var import_async6 = require("@dxos/async");
var import_context5 = require("@dxos/context");
var import_credentials2 = require("@dxos/credentials");
var import_keys4 = require("@dxos/keys");
var import_log7 = require("@dxos/log");
var import_credentials3 = require("@dxos/protocols/proto/dxos/halo/credentials");
var import_timeframe3 = require("@dxos/timeframe");
var import_tracing2 = require("@dxos/tracing");
var import_util5 = require("@dxos/util");
var import_async7 = require("@dxos/async");
var import_context6 = require("@dxos/context");
var import_protocols2 = require("@dxos/protocols");
var import_proto4 = require("@dxos/protocols/proto");
var import_teleport2 = require("@dxos/teleport");
var import_crypto3 = require("@dxos/crypto");
var import_keys5 = require("@dxos/keys");
var import_log8 = require("@dxos/log");
var import_network_manager = require("@dxos/network-manager");
var import_teleport3 = require("@dxos/teleport");
var import_teleport_extension_object_sync = require("@dxos/teleport-extension-object-sync");
var import_teleport_extension_replicator = require("@dxos/teleport-extension-replicator");
var import_tracing3 = require("@dxos/tracing");
var import_util6 = require("@dxos/util");
var import_automerge_repo = require("@automerge/automerge-repo");
var import_async8 = require("@dxos/async");
var import_credentials4 = require("@dxos/credentials");
var import_debug3 = require("@dxos/debug");
var import_keys6 = require("@dxos/keys");
var import_log9 = require("@dxos/log");
var import_protocols3 = require("@dxos/protocols");
var import_util7 = require("@dxos/util");
var codec = import_proto.schema.getCodecForType("dxos.echo.feed.FeedMessage");
var valueEncoding = (0, import_hypercore.createCodecEncoding)(codec);
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/core/echo/echo-pipeline/src/common/feeds.ts";
var createMappedFeedWriter = (mapper, writer) => {
  (0, import_invariant.invariant)(mapper, void 0, {
    F: __dxlog_file,
    L: 16,
    S: void 0,
    A: [
      "mapper",
      ""
    ]
  });
  (0, import_invariant.invariant)(writer, void 0, {
    F: __dxlog_file,
    L: 17,
    S: void 0,
    A: [
      "writer",
      ""
    ]
  });
  return {
    write: async (data, options) => await writer.write(await mapper(data), options)
  };
};
var SPACE_IDS_CACHE = new import_util.ComplexMap(import_keys.PublicKey.hash);
var createIdFromSpaceKey = async (spaceKey) => {
  const cachedValue = SPACE_IDS_CACHE.get(spaceKey);
  if (cachedValue !== void 0) {
    return cachedValue;
  }
  const digest = await import_crypto.subtleCrypto.digest("SHA-256", spaceKey.asUint8Array());
  const bytes = new Uint8Array(digest).slice(0, import_keys.SpaceId.byteLength);
  const spaceId = import_keys.SpaceId.encode(bytes);
  SPACE_IDS_CACHE.set(spaceKey, spaceId);
  return spaceId;
};
function _ts_decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file2 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-pipeline/src/metadata/metadata-store.ts";
var EXPIRED_INVITATION_CLEANUP_INTERVAL = 60 * 60 * 1e3;
var emptyEchoMetadata = () => ({
  version: import_protocols.STORAGE_VERSION,
  spaces: [],
  created: /* @__PURE__ */ new Date(),
  updated: /* @__PURE__ */ new Date()
});
var emptyLargeSpaceMetadata = () => ({});
var EchoMetadata = import_proto2.schema.getCodecForType("dxos.echo.metadata.EchoMetadata");
var LargeSpaceMetadata = import_proto2.schema.getCodecForType("dxos.echo.metadata.LargeSpaceMetadata");
var MetadataStore = class {
  constructor(directory) {
    this._metadata = emptyEchoMetadata();
    this._spaceLargeMetadata = new import_util2.ComplexMap(import_keys2.PublicKey.hash);
    this._metadataFile = void 0;
    this.update = new import_async.Event();
    this._invitationCleanupCtx = new import_context.Context(void 0, {
      F: __dxlog_file2,
      L: 55
    });
    this._directory = directory;
  }
  get metadata() {
    return this._metadata;
  }
  get version() {
    return this._metadata.version ?? 0;
  }
  /**
  * Returns a list of currently saved spaces. The list and objects in it can be modified addSpace and
  * addSpaceFeed functions.
  */
  get spaces() {
    return this._metadata.spaces ?? [];
  }
  async _readFile(file, codec2) {
    try {
      const { size: fileLength } = await file.stat();
      if (fileLength < 8) {
        return;
      }
      const dataSize = fromBytesInt32(await file.read(0, 4));
      const checksum = fromBytesInt32(await file.read(4, 4));
      (0, import_log.log)("loaded", {
        size: dataSize,
        checksum,
        name: file.filename
      }, {
        F: __dxlog_file2,
        L: 91,
        S: this,
        C: (f, a) => f(...a)
      });
      if (fileLength < dataSize + 8) {
        throw new import_protocols.DataCorruptionError("Metadata size is smaller than expected.", {
          fileLength,
          dataSize
        });
      }
      const data = await file.read(8, dataSize);
      const calculatedChecksum = import_crc_32.default.buf(data);
      if (calculatedChecksum !== checksum) {
        throw new import_protocols.DataCorruptionError("Metadata checksum is invalid.");
      }
      return codec2.decode(data);
    } finally {
      await file.close();
    }
  }
  /**
  * @internal
  */
  async _writeFile(file, codec2, data) {
    const encoded = (0, import_util2.arrayToBuffer)(codec2.encode(data));
    const checksum = import_crc_32.default.buf(encoded);
    const result = Buffer.alloc(8 + encoded.length);
    result.writeInt32LE(encoded.length, 0);
    result.writeInt32LE(checksum, 4);
    encoded.copy(result, 8);
    await file.write(0, result);
    (0, import_log.log)("saved", {
      size: encoded.length,
      checksum
    }, {
      F: __dxlog_file2,
      L: 126,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  async close() {
    await this._invitationCleanupCtx.dispose();
    await this.flush();
    await this._metadataFile?.close();
    this._metadataFile = void 0;
    this._metadata = emptyEchoMetadata();
    this._spaceLargeMetadata.clear();
  }
  /**
  * Loads metadata from persistent storage.
  */
  async load() {
    if (!this._metadataFile || this._metadataFile.closed) {
      this._metadataFile = this._directory.getOrCreateFile("EchoMetadata");
    }
    try {
      const metadata = await this._readFile(this._metadataFile, EchoMetadata);
      if (metadata) {
        this._metadata = metadata;
      }
      this._metadata.spaces?.forEach((space) => {
        space.state ??= import_services.SpaceState.SPACE_ACTIVE;
      });
    } catch (err) {
      import_log.log.error("failed to load metadata", {
        err
      }, {
        F: __dxlog_file2,
        L: 158,
        S: this,
        C: (f, a) => f(...a)
      });
      this._metadata = emptyEchoMetadata();
    }
    await (0, import_util2.forEachAsync)([
      this._metadata.identity?.haloSpace.key,
      ...this._metadata.spaces?.map((space) => space.key) ?? []
    ].filter(import_util2.isNonNullable), async (key) => {
      try {
        await this._loadSpaceLargeMetadata(key);
      } catch (err) {
        import_log.log.error("failed to load space large metadata", {
          err
        }, {
          F: __dxlog_file2,
          L: 170,
          S: this,
          C: (f, a) => f(...a)
        });
      }
    });
    (0, import_async.scheduleTaskInterval)(this._invitationCleanupCtx, async () => {
      for (const invitation of this._metadata.invitations ?? []) {
        if (hasInvitationExpired(invitation) || isLegacyInvitationFormat(invitation)) {
          await this.removeInvitation(invitation.invitationId);
        }
      }
    }, EXPIRED_INVITATION_CLEANUP_INTERVAL);
  }
  async _save() {
    const data = {
      ...this._metadata,
      version: import_protocols.STORAGE_VERSION,
      created: this._metadata.created ?? /* @__PURE__ */ new Date(),
      updated: /* @__PURE__ */ new Date()
    };
    this.update.emit(data);
    const file = this._directory.getOrCreateFile("EchoMetadata");
    await this._writeFile(file, EchoMetadata, data);
  }
  async _loadSpaceLargeMetadata(key) {
    const file = this._directory.getOrCreateFile(`space_${key.toHex()}_large`);
    try {
      const metadata = await this._readFile(file, LargeSpaceMetadata);
      if (metadata) {
        this._spaceLargeMetadata.set(key, metadata);
      }
    } catch (err) {
      import_log.log.error("failed to load space large metadata", {
        err
      }, {
        F: __dxlog_file2,
        L: 212,
        S: this,
        C: (f, a) => f(...a)
      });
    }
  }
  async _saveSpaceLargeMetadata(key) {
    const data = this._getLargeSpaceMetadata(key);
    const file = this._directory.getOrCreateFile(`space_${key.toHex()}_large`);
    await this._writeFile(file, LargeSpaceMetadata, data);
  }
  async flush() {
    await this._directory.flush();
  }
  _getSpace(spaceKey) {
    if (this._metadata.identity?.haloSpace.key.equals(spaceKey)) {
      return this._metadata.identity.haloSpace;
    }
    const space = this.spaces.find((space2) => space2.key.equals(spaceKey));
    (0, import_invariant2.invariant)(space, "Space not found", {
      F: __dxlog_file2,
      L: 234,
      S: this,
      A: [
        "space",
        "'Space not found'"
      ]
    });
    return space;
  }
  hasSpace(spaceKey) {
    if (this._metadata.identity?.haloSpace.key.equals(spaceKey)) {
      return true;
    }
    return !!this.spaces.find((space) => space.key.equals(spaceKey));
  }
  _getLargeSpaceMetadata(key) {
    let entry = this._spaceLargeMetadata.get(key);
    if (entry) {
      return entry;
    }
    entry = emptyLargeSpaceMetadata();
    this._spaceLargeMetadata.set(key, entry);
    return entry;
  }
  /**
  * Clears storage - doesn't work for now.
  */
  async clear() {
    (0, import_log.log)("clearing all metadata", void 0, {
      F: __dxlog_file2,
      L: 262,
      S: this,
      C: (f, a) => f(...a)
    });
    await this._directory.delete();
    this._metadata = emptyEchoMetadata();
  }
  getIdentityRecord() {
    return this._metadata.identity;
  }
  async setIdentityRecord(record) {
    (0, import_invariant2.invariant)(!this._metadata.identity, "Cannot overwrite existing identity in metadata", {
      F: __dxlog_file2,
      L: 272,
      S: this,
      A: [
        "!this._metadata.identity",
        "'Cannot overwrite existing identity in metadata'"
      ]
    });
    this._metadata.identity = record;
    await this._save();
    await this.flush();
  }
  getInvitations() {
    return this._metadata.invitations ?? [];
  }
  async addInvitation(invitation) {
    if (this._metadata.invitations?.find((i) => i.invitationId === invitation.invitationId)) {
      return;
    }
    (this._metadata.invitations ??= []).push(invitation);
    await this._save();
    await this.flush();
  }
  async removeInvitation(invitationId) {
    this._metadata.invitations = (this._metadata.invitations ?? []).filter((i) => i.invitationId !== invitationId);
    await this._save();
    await this.flush();
  }
  async addSpace(record) {
    (0, import_invariant2.invariant)(!(this._metadata.spaces ?? []).find((space) => space.key.equals(record.key)), "Cannot overwrite existing space in metadata", {
      F: __dxlog_file2,
      L: 300,
      S: this,
      A: [
        "!(this._metadata.spaces ?? []).find((space) => space.key.equals(record.key))",
        "'Cannot overwrite existing space in metadata'"
      ]
    });
    (this._metadata.spaces ??= []).push(record);
    await this._save();
    await this.flush();
  }
  async setSpaceDataLatestTimeframe(spaceKey, timeframe) {
    this._getSpace(spaceKey).dataTimeframe = timeframe;
    await this._save();
  }
  async setSpaceControlLatestTimeframe(spaceKey, timeframe) {
    this._getSpace(spaceKey).controlTimeframe = timeframe;
    await this._save();
    await this.flush();
  }
  async setCache(spaceKey, cache) {
    this._getSpace(spaceKey).cache = cache;
    await this._save();
  }
  async setWritableFeedKeys(spaceKey, controlFeedKey, dataFeedKey) {
    const space = this._getSpace(spaceKey);
    space.controlFeedKey = controlFeedKey;
    space.dataFeedKey = dataFeedKey;
    await this._save();
    await this.flush();
  }
  async setSpaceState(spaceKey, state) {
    this._getSpace(spaceKey).state = state;
    await this._save();
    await this.flush();
  }
  getSpaceControlPipelineSnapshot(spaceKey) {
    return this._getLargeSpaceMetadata(spaceKey).controlPipelineSnapshot;
  }
  async setSpaceControlPipelineSnapshot(spaceKey, snapshot) {
    this._getLargeSpaceMetadata(spaceKey).controlPipelineSnapshot = snapshot;
    await this._saveSpaceLargeMetadata(spaceKey);
    await this.flush();
  }
  getSpaceEdgeReplicationSetting(spaceKey) {
    return this.hasSpace(spaceKey) ? this._getSpace(spaceKey).edgeReplication : void 0;
  }
  async setSpaceEdgeReplicationSetting(spaceKey, setting) {
    this._getSpace(spaceKey).edgeReplication = setting;
    await this._save();
    await this.flush();
  }
};
_ts_decorate([
  import_async.synchronized
], MetadataStore.prototype, "load", null);
_ts_decorate([
  import_async.synchronized
], MetadataStore.prototype, "_save", null);
_ts_decorate([
  import_async.synchronized
], MetadataStore.prototype, "_saveSpaceLargeMetadata", null);
var fromBytesInt32 = (buf) => buf.readInt32LE(0);
var hasInvitationExpired = (invitation) => {
  return Boolean(invitation.created && invitation.lifetime && invitation.lifetime !== 0 && invitation.created.getTime() + invitation.lifetime * 1e3 < Date.now());
};
var isLegacyInvitationFormat = (invitation) => {
  return invitation.type === import_services.Invitation.Type.MULTIUSE;
};
function _ts_decorate2(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file3 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-pipeline/src/pipeline/timeframe-clock.ts";
var mapTimeframeToFeedIndexes = (timeframe) => timeframe.frames().map(([feedKey, index]) => ({
  feedKey,
  index
}));
var mapFeedIndexesToTimeframe = (indexes) => new import_timeframe.Timeframe(indexes.map(({ feedKey, index }) => [
  feedKey,
  index
]));
var startAfter = (timeframe) => timeframe.frames().map(([feedKey, index]) => ({
  feedKey,
  index: index + 1
}));
var TimeframeClock = class {
  constructor(_timeframe = new import_timeframe.Timeframe()) {
    this._timeframe = _timeframe;
    this.update = new import_async2.Event();
    this._pendingTimeframe = _timeframe;
  }
  /**
  * Timeframe that was processed by ECHO.
  */
  get timeframe() {
    return this._timeframe;
  }
  /**
  * Timeframe that is currently being processed by ECHO.
  * Will be equal to `timeframe` after the processing is complete.
  */
  get pendingTimeframe() {
    return this._pendingTimeframe;
  }
  setTimeframe(timeframe) {
    this._timeframe = timeframe;
    this._pendingTimeframe = timeframe;
    this.update.emit(this._timeframe);
  }
  updatePendingTimeframe(key, seq) {
    this._pendingTimeframe = import_timeframe.Timeframe.merge(this._pendingTimeframe, new import_timeframe.Timeframe([
      [
        key,
        seq
      ]
    ]));
  }
  updateTimeframe() {
    this._timeframe = this._pendingTimeframe;
    this.update.emit(this._timeframe);
  }
  hasGaps(timeframe) {
    const gaps = import_timeframe.Timeframe.dependencies(timeframe, this._timeframe);
    return !gaps.isEmpty();
  }
  async waitUntilReached(target) {
    (0, import_log2.log)("waitUntilReached", {
      target,
      current: this._timeframe
    }, {
      F: __dxlog_file3,
      L: 70,
      S: this,
      C: (f, a) => f(...a)
    });
    await this.update.waitForCondition(() => {
      (0, import_log2.log)("check if reached", {
        target,
        current: this._timeframe,
        deps: import_timeframe.Timeframe.dependencies(target, this._timeframe)
      }, {
        F: __dxlog_file3,
        L: 72,
        S: this,
        C: (f, a) => f(...a)
      });
      return import_timeframe.Timeframe.dependencies(target, this._timeframe).isEmpty();
    });
  }
};
_ts_decorate2([
  (0, import_debug.timed)(5e3)
], TimeframeClock.prototype, "waitUntilReached", null);
var __dxlog_file4 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-pipeline/src/pipeline/message-selector.ts";
var createMessageSelector = (timeframeClock) => {
  return (messages) => {
    for (let i = 0; i < messages.length; i++) {
      const { data: { timeframe } } = messages[i];
      (0, import_invariant4.invariant)(timeframe, void 0, {
        F: __dxlog_file4,
        L: 25,
        S: void 0,
        A: [
          "timeframe",
          ""
        ]
      });
      if (!timeframeClock.hasGaps(timeframe)) {
        return i;
      }
    }
    (0, import_log4.log)("Skipping...", void 0, {
      F: __dxlog_file4,
      L: 33,
      S: void 0,
      C: (f, a) => f(...a)
    });
  };
};
function _ts_decorate3(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file5 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-pipeline/src/pipeline/pipeline.ts";
var PipelineState = class {
  constructor(_feeds, _timeframeClock) {
    this._feeds = _feeds;
    this._timeframeClock = _timeframeClock;
    this._ctx = new import_context2.Context(void 0, {
      F: __dxlog_file5,
      L: 41
    });
    this.timeframeUpdate = this._timeframeClock.update;
    this.stalled = new import_async3.Event();
    this._startTimeframe = new import_timeframe2.Timeframe();
    this._reachedTarget = false;
  }
  /**
  * Latest theoretical timeframe based on the last mutation in each feed.
  * NOTE: This might never be reached if the mutation dependencies
  */
  // TODO(dmaretskyi): Rename `totalTimeframe`? or `lastTimeframe`.
  get endTimeframe() {
    return mapFeedIndexesToTimeframe(Array.from(this._feeds.values()).filter((feed) => feed.length > 0).map((feed) => ({
      feedKey: feed.key,
      index: feed.length - 1
    })));
  }
  get startTimeframe() {
    return this._startTimeframe;
  }
  get timeframe() {
    return this._timeframeClock.timeframe;
  }
  get pendingTimeframe() {
    return this._timeframeClock.pendingTimeframe;
  }
  get targetTimeframe() {
    return this._targetTimeframe ? this._targetTimeframe : new import_timeframe2.Timeframe();
  }
  get reachedTarget() {
    return this._reachedTarget;
  }
  get feeds() {
    return Array.from(this._feeds.values());
  }
  async waitUntilTimeframe(target) {
    await this._timeframeClock.waitUntilReached(target);
  }
  setTargetTimeframe(target) {
    this._targetTimeframe = target;
  }
  /**
  * Wait until the pipeline processes all messages in the feed and reaches the target timeframe if that is set.
  *
  * This function will resolve immediately if the pipeline is stalled.
  *
  * @param timeout Timeout in milliseconds to specify the maximum wait time.
  */
  async waitUntilReachedTargetTimeframe({ ctx = new import_context2.Context(void 0, {
    F: __dxlog_file5,
    L: 129
  }), timeout, breakOnStall = true } = {}) {
    (0, import_log3.log)("waitUntilReachedTargetTimeframe", {
      timeout,
      current: this.timeframe,
      target: this.targetTimeframe
    }, {
      F: __dxlog_file5,
      L: 133,
      S: this,
      C: (f, a) => f(...a)
    });
    this._reachedTargetPromise ??= Promise.race([
      this._timeframeClock.update.waitForCondition(() => {
        return import_timeframe2.Timeframe.dependencies(this.targetTimeframe, this.timeframe).isEmpty();
      }),
      ...breakOnStall ? [
        this.stalled.discardParameter().waitForCount(1)
      ] : []
    ]);
    let done = false;
    if (timeout) {
      return Promise.race([
        (0, import_context2.rejectOnDispose)(ctx),
        (0, import_context2.rejectOnDispose)(this._ctx),
        this._reachedTargetPromise.then(() => {
          done = true;
          this._reachedTarget = true;
        }),
        (0, import_async3.sleepWithContext)(this._ctx, timeout).then(() => {
          if (done) {
            return;
          }
          import_log3.log.warn("waitUntilReachedTargetTimeframe timed out", {
            timeout,
            current: this.timeframe,
            target: this.targetTimeframe,
            dependencies: import_timeframe2.Timeframe.dependencies(this.targetTimeframe, this.timeframe)
          }, {
            F: __dxlog_file5,
            L: 161,
            S: this,
            C: (f, a) => f(...a)
          });
        })
      ]);
    } else {
      return this._reachedTargetPromise;
    }
  }
};
var Pipeline = class {
  constructor() {
    this._timeframeClock = new TimeframeClock(new import_timeframe2.Timeframe());
    this._feeds = new import_util3.ComplexMap(import_keys3.PublicKey.hash);
    this._state = new PipelineState(this._feeds, this._timeframeClock);
    this._processingTrigger = new import_async3.Trigger().wake();
    this._pauseTrigger = new import_async3.Trigger().wake();
    this._downloads = new import_util3.ComplexMap((value) => import_keys3.PublicKey.hash(value.key));
    this._isStopping = false;
    this._isStarted = false;
    this._isBeingConsumed = false;
    this._isPaused = false;
  }
  get state() {
    return this._state;
  }
  get writer() {
    (0, import_invariant3.invariant)(this._writer, "Writer not set.", {
      F: __dxlog_file5,
      L: 243,
      S: this,
      A: [
        "this._writer",
        "'Writer not set.'"
      ]
    });
    return this._writer;
  }
  hasFeed(feedKey) {
    return this._feeds.has(feedKey);
  }
  getFeeds() {
    return this._feedSetIterator.feeds;
  }
  // NOTE: This cannot be synchronized with `stop` because stop waits for the mutation processing to complete,
  // which might be opening feeds during the mutation processing, which w
  async addFeed(feed) {
    this._feeds.set(feed.key, feed);
    if (this._feedSetIterator) {
      await this._feedSetIterator.addFeed(feed);
    }
    if (this._isStarted && !this._isPaused) {
      this._setFeedDownloadState(feed);
    }
  }
  setWriteFeed(feed) {
    (0, import_invariant3.invariant)(!this._writer, "Writer already set.", {
      F: __dxlog_file5,
      L: 270,
      S: this,
      A: [
        "!this._writer",
        "'Writer already set.'"
      ]
    });
    (0, import_invariant3.invariant)(feed.properties.writable, "Feed must be writable.", {
      F: __dxlog_file5,
      L: 271,
      S: this,
      A: [
        "feed.properties.writable",
        "'Feed must be writable.'"
      ]
    });
    this._writer = createMappedFeedWriter((payload) => ({
      timeframe: this._timeframeClock.timeframe,
      payload
    }), feed.createFeedWriter());
  }
  async start() {
    (0, import_invariant3.invariant)(!this._isStarted, "Pipeline is already started.", {
      F: __dxlog_file5,
      L: 284,
      S: this,
      A: [
        "!this._isStarted",
        "'Pipeline is already started.'"
      ]
    });
    (0, import_log3.log)("starting...", void 0, {
      F: __dxlog_file5,
      L: 285,
      S: this,
      C: (f, a) => f(...a)
    });
    await this._initIterator();
    await this._feedSetIterator.open();
    this._isStarted = true;
    (0, import_log3.log)("started", void 0, {
      F: __dxlog_file5,
      L: 289,
      S: this,
      C: (f, a) => f(...a)
    });
    if (!this._isPaused) {
      for (const feed of this._feeds.values()) {
        this._setFeedDownloadState(feed);
      }
    }
  }
  async stop() {
    (0, import_log3.log)("stopping...", void 0, {
      F: __dxlog_file5,
      L: 300,
      S: this,
      C: (f, a) => f(...a)
    });
    this._isStopping = true;
    for (const [feed, handle] of this._downloads.entries()) {
      feed.undownload(handle);
    }
    this._downloads.clear();
    await this._feedSetIterator?.close();
    await this._processingTrigger.wait();
    await this._state._ctx.dispose();
    this._state._ctx = new import_context2.Context(void 0, {
      F: __dxlog_file5,
      L: 309
    });
    this._state._reachedTargetPromise = void 0;
    this._state._reachedTarget = false;
    this._isStarted = false;
    (0, import_log3.log)("stopped", void 0, {
      F: __dxlog_file5,
      L: 313,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  /**
  * @param timeframe Timeframe of already processed messages.
  *  The pipeline will start processing messages AFTER this timeframe.
  */
  async setCursor(timeframe) {
    (0, import_invariant3.invariant)(!this._isStarted || this._isPaused, "Invalid state.", {
      F: __dxlog_file5,
      L: 322,
      S: this,
      A: [
        "!this._isStarted || this._isPaused",
        "'Invalid state.'"
      ]
    });
    this._state._startTimeframe = timeframe;
    this._timeframeClock.setTimeframe(timeframe);
    if (this._feedSetIterator) {
      await this._feedSetIterator.close();
      await this._initIterator();
      await this._feedSetIterator.open();
    }
  }
  /**
  * Calling pause while processing will cause a deadlock.
  */
  async pause() {
    if (this._isPaused) {
      return;
    }
    this._pauseTrigger.reset();
    await this._processingTrigger.wait();
    this._isPaused = true;
  }
  async unpause() {
    (0, import_invariant3.invariant)(this._isPaused, "Pipeline is not paused.", {
      F: __dxlog_file5,
      L: 351,
      S: this,
      A: [
        "this._isPaused",
        "'Pipeline is not paused.'"
      ]
    });
    this._pauseTrigger.wake();
    this._isPaused = false;
    for (const feed of this._feeds.values()) {
      this._setFeedDownloadState(feed);
    }
  }
  /**
  * Starts to iterate over the ordered messages from the added feeds.
  * Updates the timeframe clock after the message has bee processed.
  */
  async *consume() {
    (0, import_invariant3.invariant)(!this._isBeingConsumed, "Pipeline is already being consumed.", {
      F: __dxlog_file5,
      L: 366,
      S: this,
      A: [
        "!this._isBeingConsumed",
        "'Pipeline is already being consumed.'"
      ]
    });
    this._isBeingConsumed = true;
    (0, import_invariant3.invariant)(this._feedSetIterator, "Iterator not initialized.", {
      F: __dxlog_file5,
      L: 369,
      S: this,
      A: [
        "this._feedSetIterator",
        "'Iterator not initialized.'"
      ]
    });
    let lastFeedSetIterator = this._feedSetIterator;
    let iterable = lastFeedSetIterator[Symbol.asyncIterator]();
    while (!this._isStopping) {
      await this._pauseTrigger.wait();
      if (lastFeedSetIterator !== this._feedSetIterator) {
        (0, import_invariant3.invariant)(this._feedSetIterator, "Iterator not initialized.", {
          F: __dxlog_file5,
          L: 378,
          S: this,
          A: [
            "this._feedSetIterator",
            "'Iterator not initialized.'"
          ]
        });
        lastFeedSetIterator = this._feedSetIterator;
        iterable = lastFeedSetIterator[Symbol.asyncIterator]();
      }
      const { done, value } = await iterable.next();
      if (!done) {
        const block = value ?? (0, import_debug2.failUndefined)();
        this._processingTrigger.reset();
        this._timeframeClock.updatePendingTimeframe(import_keys3.PublicKey.from(block.feedKey), block.seq);
        yield block;
        this._processingTrigger.wake();
        this._timeframeClock.updateTimeframe();
      }
    }
    this._isBeingConsumed = false;
  }
  _setFeedDownloadState(feed) {
    let handle = this._downloads.get(feed);
    if (handle) {
      feed.undownload(handle);
    }
    const timeframe = this._state._startTimeframe;
    const seq = timeframe.get(feed.key) ?? -1;
    (0, import_log3.log)("download", {
      feed: feed.key.truncate(),
      seq,
      length: feed.length
    }, {
      F: __dxlog_file5,
      L: 407,
      S: this,
      C: (f, a) => f(...a)
    });
    handle = feed.download({
      start: seq + 1,
      linear: true
    }, (err, data) => {
      if (err) {
      } else {
        (0, import_log3.log)("downloaded", {
          data
        }, {
          F: __dxlog_file5,
          L: 412,
          S: this,
          C: (f, a) => f(...a)
        });
      }
    });
    this._downloads.set(feed, handle);
  }
  async _initIterator() {
    this._feedSetIterator = new import_feed_store.FeedSetIterator(createMessageSelector(this._timeframeClock), {
      start: startAfter(this._timeframeClock.timeframe),
      stallTimeout: 1e3
    });
    this._feedSetIterator.stalled.on((iterator) => {
      import_log3.log.warn(`Stalled after ${iterator.options.stallTimeout}ms with ${iterator.size} feeds.`, {
        currentTimeframe: this._timeframeClock.timeframe,
        targetTimeframe: this._state.targetTimeframe
      }, {
        F: __dxlog_file5,
        L: 426,
        S: this,
        C: (f, a) => f(...a)
      });
      this._state.stalled.emit();
    });
    for (const feed of this._feeds.values()) {
      await this._feedSetIterator.addFeed(feed);
    }
  }
};
_ts_decorate3([
  import_async3.synchronized
], Pipeline.prototype, "start", null);
_ts_decorate3([
  import_async3.synchronized
], Pipeline.prototype, "stop", null);
_ts_decorate3([
  import_async3.synchronized
], Pipeline.prototype, "setCursor", null);
_ts_decorate3([
  import_async3.synchronized
], Pipeline.prototype, "pause", null);
_ts_decorate3([
  import_async3.synchronized
], Pipeline.prototype, "unpause", null);
var __dxlog_file6 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-pipeline/src/space/auth.ts";
var AuthExtension = class extends import_teleport.RpcExtension {
  constructor(_authParams) {
    super({
      requested: {
        AuthService: import_proto3.schema.getService("dxos.mesh.teleport.auth.AuthService")
      },
      exposed: {
        AuthService: import_proto3.schema.getService("dxos.mesh.teleport.auth.AuthService")
      },
      timeout: 60 * 1e3
    }), this._authParams = _authParams, this._ctx = new import_context3.Context({
      onError: (err) => {
        import_log5.log.catch(err, void 0, {
          F: __dxlog_file6,
          L: 28,
          S: this,
          C: (f, a) => f(...a)
        });
      }
    }, {
      F: __dxlog_file6,
      L: 26
    });
  }
  async getHandlers() {
    return {
      AuthService: {
        authenticate: async ({ challenge }) => {
          try {
            const credential = await this._authParams.provider(challenge);
            if (!credential) {
              throw new Error("auth rejected");
            }
            return {
              credential
            };
          } catch (err) {
            import_log5.log.error("failed to generate auth credentials", err, {
              F: __dxlog_file6,
              L: 55,
              S: this,
              C: (f, a) => f(...a)
            });
            throw new Error("auth rejected");
          }
        }
      }
    };
  }
  async onOpen(context) {
    await super.onOpen(context);
    (0, import_async4.scheduleTask)(this._ctx, async () => {
      try {
        const challenge = (0, import_crypto2.randomBytes)(32);
        const { credential } = await this.rpc.AuthService.authenticate({
          challenge
        });
        (0, import_invariant5.invariant)(credential?.length > 0, "invalid credential", {
          F: __dxlog_file6,
          L: 69,
          S: this,
          A: [
            "credential?.length > 0",
            "'invalid credential'"
          ]
        });
        const success = await this._authParams.verifier(challenge, credential);
        (0, import_invariant5.invariant)(success, "credential not verified", {
          F: __dxlog_file6,
          L: 71,
          S: this,
          A: [
            "success",
            "'credential not verified'"
          ]
        });
        (0, import_async4.runInContext)(this._ctx, () => this._authParams.onAuthSuccess());
      } catch (err) {
        (0, import_log5.log)("auth failed", err, {
          F: __dxlog_file6,
          L: 74,
          S: this,
          C: (f, a) => f(...a)
        });
        this.close();
        this._authParams.onAuthFailure();
      }
    });
  }
  async onClose() {
    await this._ctx.dispose();
    await super.onClose();
  }
  async onAbort() {
    await this._ctx.dispose();
    await super.onAbort();
  }
};
function _ts_decorate4(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file7 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-pipeline/src/space/control-pipeline.ts";
var TIMEFRAME_SAVE_DEBOUNCE_INTERVAL = 500;
var CONTROL_PIPELINE_SNAPSHOT_DELAY = 1e4;
var USE_SNAPSHOTS = true;
var ControlPipeline = class {
  constructor({ spaceKey, genesisFeed, feedProvider, metadataStore }) {
    this._ctx = new import_context5.Context(void 0, {
      F: __dxlog_file7,
      L: 47
    });
    this._lastTimeframeSaveTime = Date.now();
    this.onFeedAdmitted = new import_util5.Callback();
    this._usage = new import_tracing2.TimeUsageCounter();
    this._mutations = new import_tracing2.TimeSeriesCounter();
    this._snapshotTask = new import_async6.DeferredTask(this._ctx, async () => {
      await (0, import_async6.sleepWithContext)(this._ctx, CONTROL_PIPELINE_SNAPSHOT_DELAY);
      await this._saveSnapshot();
    });
    this._spaceKey = spaceKey;
    this._metadata = metadataStore;
    this._pipeline = new Pipeline();
    void this._pipeline.addFeed(genesisFeed);
    this._spaceStateMachine = new import_credentials2.SpaceStateMachine(spaceKey);
    this._spaceStateMachine.onFeedAdmitted.set(async (info) => {
      (0, import_log7.log)("feed admitted", {
        key: info.key
      }, {
        F: __dxlog_file7,
        L: 82,
        S: this,
        C: (f, a) => f(...a)
      });
      if (info.assertion.designation === import_credentials3.AdmittedFeed.Designation.CONTROL && !info.key.equals(genesisFeed.key)) {
        queueMicrotask(async () => {
          try {
            const feed = await feedProvider(info.key);
            if (!this._pipeline.hasFeed(feed.key)) {
              await this._pipeline.addFeed(feed);
            }
          } catch (err) {
            import_log7.log.catch(err, void 0, {
              F: __dxlog_file7,
              L: 93,
              S: this,
              C: (f, a) => f(...a)
            });
          }
        });
      }
      await this.onFeedAdmitted.callIfSet(info);
    });
    this.onMemberRoleChanged = this._spaceStateMachine.onMemberRoleChanged;
    this.onCredentialProcessed = this._spaceStateMachine.onCredentialProcessed;
    this.onDelegatedInvitation = this._spaceStateMachine.onDelegatedInvitation;
    this.onDelegatedInvitationRemoved = this._spaceStateMachine.onDelegatedInvitationRemoved;
  }
  get spaceState() {
    return this._spaceStateMachine;
  }
  get pipeline() {
    return this._pipeline;
  }
  async setWriteFeed(feed) {
    await this._pipeline.addFeed(feed);
    this._pipeline.setWriteFeed(feed);
  }
  async start() {
    const snapshot = this._metadata.getSpaceControlPipelineSnapshot(this._spaceKey);
    (0, import_log7.log)("load snapshot", {
      key: this._spaceKey,
      present: !!snapshot,
      tf: snapshot?.timeframe
    }, {
      F: __dxlog_file7,
      L: 123,
      S: this,
      C: (f, a) => f(...a)
    });
    if (USE_SNAPSHOTS && snapshot) {
      await this._processSnapshot(snapshot);
    }
    (0, import_log7.log)("starting...", void 0, {
      F: __dxlog_file7,
      L: 128,
      S: this,
      C: (f, a) => f(...a)
    });
    setTimeout(async () => {
      void this._consumePipeline(new import_context5.Context(void 0, {
        F: __dxlog_file7,
        L: 130
      }));
    });
    await this._pipeline.start();
    (0, import_log7.log)("started", void 0, {
      F: __dxlog_file7,
      L: 134,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  async _processSnapshot(snapshot) {
    await this._pipeline.setCursor(snapshot.timeframe);
    for (const message of snapshot.messages ?? []) {
      const result = await this._spaceStateMachine.process(message.credential, {
        sourceFeed: message.feedKey,
        skipVerification: true
      });
      if (!result) {
        import_log7.log.warn("credential processing failed from snapshot", {
          message
        }, {
          F: __dxlog_file7,
          L: 147,
          S: this,
          C: (f, a) => f(...a)
        });
      }
    }
  }
  async _saveSnapshot() {
    await this._pipeline.pause();
    const snapshot = {
      timeframe: this._pipeline.state.timeframe,
      messages: this._spaceStateMachine.credentialEntries.map((entry) => ({
        feedKey: entry.sourceFeed,
        credential: entry.credential
      }))
    };
    await this._pipeline.unpause();
    (0, import_log7.log)("save snapshot", {
      key: this._spaceKey,
      snapshot: getSnapshotLoggerContext(snapshot)
    }, {
      F: __dxlog_file7,
      L: 163,
      S: this,
      C: (f, a) => f(...a)
    });
    await this._metadata.setSpaceControlPipelineSnapshot(this._spaceKey, snapshot);
  }
  async _consumePipeline(ctx) {
    for await (const msg of this._pipeline.consume()) {
      const span = this._usage.beginRecording();
      this._mutations.inc();
      try {
        await this._processMessage(ctx, msg);
      } catch (err) {
        import_log7.log.catch(err, void 0, {
          F: __dxlog_file7,
          L: 176,
          S: this,
          C: (f, a) => f(...a)
        });
      }
      span.end();
    }
  }
  async _processMessage(ctx, msg) {
    (0, import_log7.log)("processing", {
      key: msg.feedKey,
      seq: msg.seq
    }, {
      F: __dxlog_file7,
      L: 185,
      S: this,
      C: (f, a) => f(...a)
    });
    if (msg.data.payload.credential) {
      const timer = import_util5.tracer.mark("dxos.echo.pipeline.control");
      const result = await this._spaceStateMachine.process(msg.data.payload.credential.credential, {
        sourceFeed: import_keys4.PublicKey.from(msg.feedKey)
      });
      timer.end();
      if (!result) {
        import_log7.log.warn("processing failed", {
          msg
        }, {
          F: __dxlog_file7,
          L: 194,
          S: this,
          C: (f, a) => f(...a)
        });
      } else {
        await this._noteTargetStateIfNeeded(this._pipeline.state.pendingTimeframe);
      }
      this._snapshotTask.schedule();
    }
  }
  async _noteTargetStateIfNeeded(timeframe) {
    if (Date.now() - this._lastTimeframeSaveTime > TIMEFRAME_SAVE_DEBOUNCE_INTERVAL) {
      this._lastTimeframeSaveTime = Date.now();
      await this._saveTargetTimeframe(timeframe);
    }
  }
  async stop() {
    (0, import_log7.log)("stopping...", void 0, {
      F: __dxlog_file7,
      L: 214,
      S: this,
      C: (f, a) => f(...a)
    });
    await this._ctx.dispose();
    await this._pipeline.stop();
    await this._saveTargetTimeframe(this._pipeline.state.timeframe);
    (0, import_log7.log)("stopped", void 0, {
      F: __dxlog_file7,
      L: 218,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  async _saveTargetTimeframe(timeframe) {
    try {
      const newTimeframe = import_timeframe3.Timeframe.merge(this._targetTimeframe ?? new import_timeframe3.Timeframe(), timeframe);
      await this._metadata.setSpaceControlLatestTimeframe(this._spaceKey, newTimeframe);
      this._targetTimeframe = newTimeframe;
    } catch (err) {
      (0, import_log7.log)(err, void 0, {
        F: __dxlog_file7,
        L: 227,
        S: this,
        C: (f, a) => f(...a)
      });
    }
  }
};
_ts_decorate4([
  import_tracing2.trace.metricsCounter()
], ControlPipeline.prototype, "_usage", void 0);
_ts_decorate4([
  import_tracing2.trace.metricsCounter()
], ControlPipeline.prototype, "_mutations", void 0);
_ts_decorate4([
  import_tracing2.trace.span({
    showInBrowserTimeline: true
  })
], ControlPipeline.prototype, "start", null);
_ts_decorate4([
  import_tracing2.trace.span()
], ControlPipeline.prototype, "_consumePipeline", null);
_ts_decorate4([
  import_tracing2.trace.span()
], ControlPipeline.prototype, "_processMessage", null);
ControlPipeline = _ts_decorate4([
  import_tracing2.trace.resource(),
  (0, import_async6.trackLeaks)("start", "stop")
], ControlPipeline);
var getSnapshotLoggerContext = (snapshot) => {
  return snapshot.messages?.map((msg) => {
    const issuer = msg.credential.issuer;
    const subject = msg.credential.subject.id;
    const type = msg.credential.subject.assertion["@type"];
    return {
      issuer,
      subject,
      type
    };
  });
};
function _ts_decorate5(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file8 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-pipeline/src/space/space.ts";
var Space = class extends import_context4.Resource {
  constructor(params) {
    super();
    this.onCredentialProcessed = new import_util4.Callback();
    this.stateUpdate = new import_async5.Event();
    (0, import_invariant6.invariant)(params.spaceKey && params.feedProvider, void 0, {
      F: __dxlog_file8,
      L: 72,
      S: this,
      A: [
        "params.spaceKey && params.feedProvider",
        ""
      ]
    });
    this._id = params.id;
    this._key = params.spaceKey;
    this._genesisFeedKey = params.genesisFeed.key;
    this._feedProvider = params.feedProvider;
    this._controlPipeline = new ControlPipeline({
      spaceKey: params.spaceKey,
      genesisFeed: params.genesisFeed,
      feedProvider: params.feedProvider,
      metadataStore: params.metadataStore
    });
    this._controlPipeline.onFeedAdmitted.set(async (info) => {
      const sparse = info.assertion.designation === import_credentials.AdmittedFeed.Designation.DATA;
      if (!info.key.equals(params.genesisFeed.key)) {
        (0, import_async5.scheduleMicroTask)(this._ctx, async () => {
          await this.protocol.addFeed(await params.feedProvider(info.key, {
            sparse
          }));
        });
      }
    });
    this._controlPipeline.onCredentialProcessed.set(async (credential) => {
      await this.onCredentialProcessed.callIfSet(credential);
      (0, import_log6.log)("onCredentialProcessed", {
        credential
      }, {
        F: __dxlog_file8,
        L: 99,
        S: this,
        C: (f, a) => f(...a)
      });
      this.stateUpdate.emit();
    });
    this._controlPipeline.onDelegatedInvitation.set(async (invitation) => {
      (0, import_log6.log)("onDelegatedInvitation", {
        invitation
      }, {
        F: __dxlog_file8,
        L: 103,
        S: this,
        C: (f, a) => f(...a)
      });
      await params.onDelegatedInvitationStatusChange(invitation, true);
    });
    this._controlPipeline.onDelegatedInvitationRemoved.set(async (invitation) => {
      (0, import_log6.log)("onDelegatedInvitationRemoved", {
        invitation
      }, {
        F: __dxlog_file8,
        L: 107,
        S: this,
        C: (f, a) => f(...a)
      });
      await params.onDelegatedInvitationStatusChange(invitation, false);
    });
    this._controlPipeline.onMemberRoleChanged.set(async (changedMembers) => {
      (0, import_log6.log)("onMemberRoleChanged", () => ({
        changedMembers: changedMembers.map((m) => [
          m.key,
          m.role
        ])
      }), {
        F: __dxlog_file8,
        L: 111,
        S: this,
        C: (f, a) => f(...a)
      });
      await params.onMemberRolesChanged(changedMembers);
    });
    this.protocol = params.protocol;
  }
  get id() {
    return this._id;
  }
  get key() {
    return this._key;
  }
  get genesisFeedKey() {
    return this._genesisFeedKey;
  }
  get controlFeedKey() {
    return this._controlFeed?.key;
  }
  get dataFeedKey() {
    return this._dataFeed?.key;
  }
  get spaceState() {
    return this._controlPipeline.spaceState;
  }
  /**
  * @test-only
  */
  get controlPipeline() {
    return this._controlPipeline.pipeline;
  }
  async setControlFeed(feed) {
    (0, import_invariant6.invariant)(!this._controlFeed, "Control feed already set.", {
      F: __dxlog_file8,
      L: 155,
      S: this,
      A: [
        "!this._controlFeed",
        "'Control feed already set.'"
      ]
    });
    this._controlFeed = feed;
    await this._controlPipeline.setWriteFeed(feed);
    return this;
  }
  async setDataFeed(feed) {
    (0, import_invariant6.invariant)(!this._dataFeed, "Data feed already set.", {
      F: __dxlog_file8,
      L: 162,
      S: this,
      A: [
        "!this._dataFeed",
        "'Data feed already set.'"
      ]
    });
    this._dataFeed = feed;
    return this;
  }
  /**
  * Use for diagnostics.
  */
  getControlFeeds() {
    return Array.from(this._controlPipeline.spaceState.feeds.values());
  }
  async _open(ctx) {
    (0, import_log6.log)("opening...", void 0, {
      F: __dxlog_file8,
      L: 176,
      S: this,
      C: (f, a) => f(...a)
    });
    await this._controlPipeline.start();
    (0, import_log6.log)("opened", void 0, {
      F: __dxlog_file8,
      L: 181,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  async startProtocol() {
    (0, import_invariant6.invariant)(this.isOpen, void 0, {
      F: __dxlog_file8,
      L: 186,
      S: this,
      A: [
        "this.isOpen",
        ""
      ]
    });
    await this.protocol.start();
    await this.protocol.addFeed(await this._feedProvider(this._genesisFeedKey));
  }
  async _close() {
    (0, import_log6.log)("closing...", {
      key: this._key
    }, {
      F: __dxlog_file8,
      L: 193,
      S: this,
      C: (f, a) => f(...a)
    });
    await this.protocol.stop();
    await this._controlPipeline.stop();
    (0, import_log6.log)("closed", void 0, {
      F: __dxlog_file8,
      L: 199,
      S: this,
      C: (f, a) => f(...a)
    });
  }
};
_ts_decorate5([
  import_tracing.trace.info()
], Space.prototype, "protocol", void 0);
_ts_decorate5([
  import_tracing.trace.info()
], Space.prototype, "_controlPipeline", void 0);
_ts_decorate5([
  import_log6.logInfo,
  import_tracing.trace.info()
], Space.prototype, "id", null);
_ts_decorate5([
  import_log6.logInfo,
  import_tracing.trace.info()
], Space.prototype, "key", null);
_ts_decorate5([
  import_tracing.trace.span()
], Space.prototype, "_open", null);
_ts_decorate5([
  import_async5.synchronized
], Space.prototype, "startProtocol", null);
_ts_decorate5([
  import_async5.synchronized
], Space.prototype, "_close", null);
Space = _ts_decorate5([
  (0, import_async5.trackLeaks)("open", "close"),
  import_tracing.trace.resource()
], Space);
var __dxlog_file9 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-pipeline/src/space/admission-discovery-extension.ts";
var CredentialRetrieverExtension = class extends import_teleport2.RpcExtension {
  constructor(_request, _onResult) {
    super({
      requested: {
        AdmissionDiscoveryService: import_proto4.schema.getService("dxos.mesh.teleport.AdmissionDiscoveryService")
      }
    }), this._request = _request, this._onResult = _onResult, this._ctx = new import_context6.Context(void 0, {
      F: __dxlog_file9,
      L: 26
    });
  }
  async getHandlers() {
    return {};
  }
  async onOpen(context) {
    await super.onOpen(context);
    (0, import_async7.scheduleTask)(this._ctx, async () => {
      try {
        const result = await this.rpc.AdmissionDiscoveryService.getAdmissionCredential(this._request);
        this._onResult.wake(result.admissionCredential);
      } catch (err) {
        context.close(err);
      }
    });
  }
  async onClose() {
    await this._ctx.dispose();
  }
  async onAbort() {
    await this._ctx.dispose();
  }
};
var CredentialServerExtension = class extends import_teleport2.RpcExtension {
  constructor(_space) {
    super({
      exposed: {
        AdmissionDiscoveryService: import_proto4.schema.getService("dxos.mesh.teleport.AdmissionDiscoveryService")
      }
    }), this._space = _space;
  }
  async getHandlers() {
    return {
      AdmissionDiscoveryService: {
        getAdmissionCredential: async (request) => {
          const memberInfo = this._space.spaceState.members.get(request.memberKey);
          if (!memberInfo?.credential) {
            throw new import_protocols2.ProtocolError("Space member not found.", request);
          }
          return {
            admissionCredential: memberInfo.credential
          };
        }
      }
    };
  }
};
function _ts_decorate6(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file10 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-pipeline/src/space/space-protocol.ts";
var MOCK_AUTH_PROVIDER = async (nonce) => Buffer.from("mock");
var MOCK_AUTH_VERIFIER = async (nonce, credential) => true;
var SpaceProtocol = class {
  constructor({ topic, swarmIdentity, networkManager, onSessionAuth, onAuthFailure, blobStore, disableP2pReplication }) {
    this._feeds = /* @__PURE__ */ new Set();
    this._sessions = new import_util6.ComplexMap(import_keys5.PublicKey.hash);
    this._topology = new import_network_manager.MMSTTopology({
      originateConnections: 4,
      maxPeers: 10,
      sampleSize: 20
    });
    this.feedAdded = new import_util6.CallbackCollection();
    this._spaceKey = topic;
    this._networkManager = networkManager;
    this._swarmIdentity = swarmIdentity;
    this._onSessionAuth = onSessionAuth;
    this._onAuthFailure = onAuthFailure;
    this.blobSync = new import_teleport_extension_object_sync.BlobSync({
      blobStore
    });
    this._topic = import_crypto3.subtleCrypto.digest("SHA-256", topic.asBuffer()).then(import_crypto3.discoveryKey).then(import_keys5.PublicKey.from);
    this._disableP2pReplication = disableP2pReplication ?? false;
  }
  get sessions() {
    return this._sessions;
  }
  get feeds() {
    return this._feeds;
  }
  get _ownPeerKey() {
    return this._swarmIdentity.peerKey;
  }
  // TODO(burdon): Create abstraction for Space (e.g., add keys and have provider).
  async addFeed(feed) {
    (0, import_log8.log)("addFeed", {
      key: feed.key
    }, {
      F: __dxlog_file10,
      L: 128,
      S: this,
      C: (f, a) => f(...a)
    });
    this._feeds.add(feed);
    for (const session of this._sessions.values()) {
      session.replicator.addFeed(feed);
    }
    await this.feedAdded.callSerial(feed);
  }
  // TODO(burdon): Rename open? Common open/close interfaces for all services?
  async start() {
    if (this._connection) {
      return;
    }
    const credentials = await this._swarmIdentity.credentialProvider(Buffer.from(""));
    await this.blobSync.open();
    (0, import_log8.log)("starting...", void 0, {
      F: __dxlog_file10,
      L: 149,
      S: this,
      C: (f, a) => f(...a)
    });
    const topic = await this._topic;
    this._connection = await this._networkManager.joinSwarm({
      protocolProvider: this._createProtocolProvider(credentials),
      topic,
      topology: this._topology,
      label: `swarm ${topic.truncate()} for space ${this._spaceKey.truncate()}`
    });
    (0, import_log8.log)("started", void 0, {
      F: __dxlog_file10,
      L: 158,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  updateTopology() {
    this._topology.forceUpdate();
  }
  async stop() {
    await this.blobSync.close();
    if (this._connection) {
      (0, import_log8.log)("stopping...", void 0, {
        F: __dxlog_file10,
        L: 169,
        S: this,
        C: (f, a) => f(...a)
      });
      await this._connection.close();
      (0, import_log8.log)("stopped", void 0, {
        F: __dxlog_file10,
        L: 171,
        S: this,
        C: (f, a) => f(...a)
      });
    }
  }
  _createProtocolProvider(credentials) {
    return (wireParams) => {
      const session = new SpaceProtocolSession({
        wireParams,
        swarmIdentity: this._swarmIdentity,
        onSessionAuth: this._onSessionAuth,
        onAuthFailure: this._onAuthFailure,
        blobSync: this.blobSync,
        disableP2pReplication: this._disableP2pReplication
      });
      this._sessions.set(wireParams.remotePeerId, session);
      for (const feed of this._feeds) {
        session.replicator.addFeed(feed);
      }
      return session;
    };
  }
};
_ts_decorate6([
  import_log8.logInfo,
  import_tracing3.trace.info()
], SpaceProtocol.prototype, "_topic", void 0);
_ts_decorate6([
  import_tracing3.trace.info()
], SpaceProtocol.prototype, "_spaceKey", void 0);
_ts_decorate6([
  import_log8.logInfo
], SpaceProtocol.prototype, "_ownPeerKey", null);
SpaceProtocol = _ts_decorate6([
  import_tracing3.trace.resource()
], SpaceProtocol);
var AuthStatus = /* @__PURE__ */ function(AuthStatus2) {
  AuthStatus2["INITIAL"] = "INITIAL";
  AuthStatus2["SUCCESS"] = "SUCCESS";
  AuthStatus2["FAILURE"] = "FAILURE";
  return AuthStatus2;
}({});
var SpaceProtocolSession = class {
  // TODO(dmaretskyi): Allow to pass in extra extensions.
  constructor({ wireParams, swarmIdentity, onSessionAuth, onAuthFailure, blobSync, disableP2pReplication }) {
    this.replicator = new import_teleport_extension_replicator.ReplicatorExtension().setOptions({
      upload: true
    });
    this._authStatus = "INITIAL";
    this._wireParams = wireParams;
    this._swarmIdentity = swarmIdentity;
    this._onSessionAuth = onSessionAuth;
    this._onAuthFailure = onAuthFailure;
    this._blobSync = blobSync;
    this._teleport = new import_teleport3.Teleport(wireParams);
    this._disableP2pReplication = disableP2pReplication ?? false;
  }
  get authStatus() {
    return this._authStatus;
  }
  get stats() {
    return this._teleport.stats;
  }
  get stream() {
    return this._teleport.stream;
  }
  async open(sessionId) {
    await this._teleport.open(sessionId);
    this._teleport.addExtension("dxos.mesh.teleport.auth", new AuthExtension({
      provider: this._swarmIdentity.credentialProvider,
      verifier: this._swarmIdentity.credentialAuthenticator,
      onAuthSuccess: () => {
        (0, import_log8.log)("Peer authenticated", void 0, {
          F: __dxlog_file10,
          L: 282,
          S: this,
          C: (f, a) => f(...a)
        });
        this._authStatus = "SUCCESS";
        this._onSessionAuth?.(this._teleport);
      },
      onAuthFailure: () => {
        this._authStatus = "FAILURE";
        this._onAuthFailure?.(this._teleport);
      }
    }));
    if (!this._disableP2pReplication) {
      this._teleport.addExtension("dxos.mesh.teleport.replicator", this.replicator);
    }
    this._teleport.addExtension("dxos.mesh.teleport.blobsync", this._blobSync.createExtension());
  }
  async close() {
    (0, import_log8.log)("close", void 0, {
      F: __dxlog_file10,
      L: 301,
      S: this,
      C: (f, a) => f(...a)
    });
    await this._teleport.close();
  }
  async abort() {
    await this._teleport.abort();
  }
};
_ts_decorate6([
  import_log8.logInfo
], SpaceProtocolSession.prototype, "_wireParams", void 0);
_ts_decorate6([
  import_log8.logInfo
], SpaceProtocolSession.prototype, "authStatus", null);
function _ts_decorate7(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file11 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-pipeline/src/space/space-manager.ts";
var SpaceManager = class {
  constructor({ feedStore, networkManager, metadataStore, blobStore, disableP2pReplication }) {
    this._spaces = new import_util7.ComplexMap(import_keys6.PublicKey.hash);
    this._instanceId = import_keys6.PublicKey.random().toHex();
    this._feedStore = feedStore;
    this._networkManager = networkManager;
    this._metadataStore = metadataStore;
    this._blobStore = blobStore;
    this._disableP2pReplication = disableP2pReplication ?? false;
  }
  // TODO(burdon): Remove.
  get spaces() {
    return this._spaces;
  }
  async open() {
  }
  async close() {
    await Promise.all([
      ...this._spaces.values()
    ].map((space) => space.close()));
  }
  async constructSpace({ metadata, swarmIdentity, onAuthorizedConnection, onAuthFailure, onDelegatedInvitationStatusChange, onMemberRolesChanged, memberKey }) {
    import_log9.log.trace("dxos.echo.space-manager.construct-space", import_protocols3.trace.begin({
      id: this._instanceId
    }), {
      F: __dxlog_file11,
      L: 102,
      S: this,
      C: (f, a) => f(...a)
    });
    (0, import_log9.log)("constructing space...", {
      spaceKey: metadata.genesisFeedKey
    }, {
      F: __dxlog_file11,
      L: 103,
      S: this,
      C: (f, a) => f(...a)
    });
    const genesisFeed = await this._feedStore.openFeed(metadata.genesisFeedKey ?? (0, import_debug3.failUndefined)());
    const spaceKey = metadata.key;
    const spaceId = await createIdFromSpaceKey(spaceKey);
    const protocol = new SpaceProtocol({
      topic: spaceKey,
      swarmIdentity,
      networkManager: this._networkManager,
      onSessionAuth: onAuthorizedConnection,
      onAuthFailure,
      blobStore: this._blobStore,
      disableP2pReplication: this._disableP2pReplication
    });
    const space = new Space({
      id: spaceId,
      spaceKey,
      protocol,
      genesisFeed,
      feedProvider: (feedKey, opts) => this._feedStore.openFeed(feedKey, opts),
      metadataStore: this._metadataStore,
      memberKey,
      onDelegatedInvitationStatusChange,
      onMemberRolesChanged
    });
    this._spaces.set(space.key, space);
    import_log9.log.trace("dxos.echo.space-manager.construct-space", import_protocols3.trace.end({
      id: this._instanceId
    }), {
      F: __dxlog_file11,
      L: 133,
      S: this,
      C: (f, a) => f(...a)
    });
    return space;
  }
  async requestSpaceAdmissionCredential(params) {
    const traceKey = "dxos.echo.space-manager.request-space-admission";
    import_log9.log.trace(traceKey, import_protocols3.trace.begin({
      id: this._instanceId
    }), {
      F: __dxlog_file11,
      L: 139,
      S: this,
      C: (f, a) => f(...a)
    });
    (0, import_log9.log)("requesting space admission credential...", {
      spaceKey: params.spaceKey
    }, {
      F: __dxlog_file11,
      L: 140,
      S: this,
      C: (f, a) => f(...a)
    });
    const onCredentialResolved = new import_async8.Trigger();
    const protocol = new SpaceProtocol({
      topic: params.spaceKey,
      swarmIdentity: params.swarmIdentity,
      networkManager: this._networkManager,
      onSessionAuth: (session) => {
        session.addExtension("dxos.mesh.teleport.admission-discovery", new CredentialRetrieverExtension({
          spaceKey: params.spaceKey,
          memberKey: params.identityKey
        }, onCredentialResolved));
      },
      onAuthFailure: (session) => session.close(),
      blobStore: this._blobStore,
      disableP2pReplication: this._disableP2pReplication
    });
    try {
      await protocol.start();
      const credential = await onCredentialResolved.wait({
        timeout: params.timeout
      });
      import_log9.log.trace(traceKey, import_protocols3.trace.end({
        id: this._instanceId
      }), {
        F: __dxlog_file11,
        L: 164,
        S: this,
        C: (f, a) => f(...a)
      });
      return credential;
    } catch (err) {
      import_log9.log.trace(traceKey, import_protocols3.trace.error({
        id: this._instanceId,
        error: err
      }), {
        F: __dxlog_file11,
        L: 167,
        S: this,
        C: (f, a) => f(...a)
      });
      throw err;
    } finally {
      await protocol.stop();
    }
  }
  findSpaceByRootDocumentId(documentId) {
    return [
      ...this._spaces.values()
    ].find((space) => {
      return space.spaceState.credentials.some((credential) => {
        const assertion = (0, import_credentials4.getCredentialAssertion)(credential);
        if (assertion["@type"] !== "dxos.halo.credentials.Epoch") {
          return false;
        }
        if (!assertion?.automergeRoot) {
          return false;
        }
        return (0, import_automerge_repo.parseAutomergeUrl)(assertion.automergeRoot).documentId === documentId;
      });
    });
  }
};
_ts_decorate7([
  import_async8.synchronized
], SpaceManager.prototype, "open", null);
_ts_decorate7([
  import_async8.synchronized
], SpaceManager.prototype, "close", null);
SpaceManager = _ts_decorate7([
  (0, import_async8.trackLeaks)("open", "close")
], SpaceManager);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AuthExtension,
  AuthStatus,
  CredentialRetrieverExtension,
  CredentialServerExtension,
  MOCK_AUTH_PROVIDER,
  MOCK_AUTH_VERIFIER,
  MetadataStore,
  Pipeline,
  Space,
  SpaceManager,
  SpaceProtocol,
  SpaceProtocolSession,
  TimeframeClock,
  codec,
  createIdFromSpaceKey,
  createMappedFeedWriter,
  hasInvitationExpired,
  mapFeedIndexesToTimeframe,
  mapTimeframeToFeedIndexes,
  startAfter,
  valueEncoding
});
//# sourceMappingURL=chunk-JXX6LF5U.cjs.map
