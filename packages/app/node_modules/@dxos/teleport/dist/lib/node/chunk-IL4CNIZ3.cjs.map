{
  "version": 3,
  "sources": ["../../../../../../../node_modules/.pnpm/varint@6.0.0/node_modules/varint/encode.js", "../../../../../../../node_modules/.pnpm/varint@6.0.0/node_modules/varint/decode.js", "../../../../../../../node_modules/.pnpm/varint@6.0.0/node_modules/varint/length.js", "../../../../../../../node_modules/.pnpm/varint@6.0.0/node_modules/varint/index.js", "../../../src/testing/test-builder.ts", "../../../src/teleport.ts", "../../../src/control-extension.ts", "../../../src/muxing/framer.ts", "../../../src/muxing/muxer.ts", "../../../src/muxing/balancer.ts", "../../../src/testing/test-extension.ts", "../../../src/testing/test-extension-with-streams.ts"],
  "sourcesContent": ["module.exports = encode\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31)\n\nfunction encode(num, out, offset) {\n  if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {\n    encode.bytes = 0\n    throw new RangeError('Could not encode varint')\n  }\n  out = out || []\n  offset = offset || 0\n  var oldOffset = offset\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB\n    num /= 128\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB\n    num >>>= 7\n  }\n  out[offset] = num | 0\n  \n  encode.bytes = offset - oldOffset + 1\n  \n  return out\n}\n", "module.exports = read\n\nvar MSB = 0x80\n  , REST = 0x7F\n\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length\n\n  do {\n    if (counter >= l || shift > 49) {\n      read.bytes = 0\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++]\n    res += shift < 28\n      ? (b & REST) << shift\n      : (b & REST) * Math.pow(2, shift)\n    shift += 7\n  } while (b >= MSB)\n\n  read.bytes = counter - offset\n\n  return res\n}\n", "\nvar N1 = Math.pow(2,  7)\nvar N2 = Math.pow(2, 14)\nvar N3 = Math.pow(2, 21)\nvar N4 = Math.pow(2, 28)\nvar N5 = Math.pow(2, 35)\nvar N6 = Math.pow(2, 42)\nvar N7 = Math.pow(2, 49)\nvar N8 = Math.pow(2, 56)\nvar N9 = Math.pow(2, 63)\n\nmodule.exports = function (value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n}\n", "module.exports = {\n    encode: require('./encode.js')\n  , decode: require('./decode.js')\n  , encodingLength: require('./length.js')\n}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { type Duplex, pipeline } from 'node:stream';\n\nimport { waitForCondition } from '@dxos/async';\nimport { invariant } from '@dxos/invariant';\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\n\nimport { Teleport } from '../teleport';\n\ntype CreatePeerOpts<T extends TestPeer> = {\n  factory: () => T;\n};\n\nexport class TestBuilder {\n  private readonly _peers = new Set<TestPeer>();\n\n  createPeer<T extends TestPeer>(opts: CreatePeerOpts<T>): T {\n    const peer = opts.factory();\n    this._peers.add(peer);\n    return peer;\n  }\n\n  *createPeers<T extends TestPeer>(opts: CreatePeerOpts<T>): Generator<T> {\n    while (true) {\n      yield this.createPeer(opts);\n    }\n  }\n\n  async destroy(): Promise<void> {\n    await Promise.all(Array.from(this._peers).map((agent) => agent.destroy()));\n  }\n\n  async connect(peer1: TestPeer, peer2: TestPeer): Promise<TestConnection[]> {\n    invariant(peer1 !== peer2);\n    invariant(this._peers.has(peer1));\n    invariant(this._peers.has(peer1));\n\n    const connection1 = peer1.createConnection({ initiator: true, remotePeerId: peer2.peerId });\n    const connection2 = peer2.createConnection({ initiator: false, remotePeerId: peer1.peerId });\n\n    pipeStreams(connection1.teleport.stream, connection2.teleport.stream);\n    await Promise.all([peer1.openConnection(connection1), peer2.openConnection(connection2)]);\n\n    return [connection1, connection2];\n  }\n\n  async disconnect(peer1: TestPeer, peer2: TestPeer): Promise<void> {\n    invariant(peer1 !== peer2);\n    invariant(this._peers.has(peer1));\n    invariant(this._peers.has(peer1));\n\n    const connection1 = Array.from(peer1.connections).find((connection) =>\n      connection.remotePeerId.equals(peer2.peerId),\n    );\n    const connection2 = Array.from(peer2.connections).find((connection) =>\n      connection.remotePeerId.equals(peer1.peerId),\n    );\n\n    invariant(connection1);\n    invariant(connection2);\n\n    await Promise.all([peer1.closeConnection(connection1), peer2.closeConnection(connection2)]);\n  }\n}\n\nexport class TestPeer {\n  public readonly connections = new Set<TestConnection>();\n\n  constructor(public readonly peerId: PublicKey = PublicKey.random()) {}\n\n  protected async onOpen(connection: TestConnection): Promise<void> {}\n  protected async onClose(connection: TestConnection): Promise<void> {}\n\n  createConnection({ initiator, remotePeerId }: { initiator: boolean; remotePeerId: PublicKey }): TestConnection {\n    const connection = new TestConnection(this.peerId, remotePeerId, initiator);\n    this.connections.add(connection);\n    return connection;\n  }\n\n  async openConnection(connection: TestConnection): Promise<void> {\n    invariant(this.connections.has(connection));\n    await connection.teleport.open(PublicKey.random());\n    await this.onOpen(connection);\n  }\n\n  async closeConnection(connection: TestConnection): Promise<void> {\n    invariant(this.connections.has(connection));\n    await this.onClose(connection);\n    await connection.teleport.close();\n    this.connections.delete(connection);\n  }\n\n  async destroy(): Promise<void> {\n    for (const teleport of this.connections) {\n      await this.closeConnection(teleport);\n    }\n  }\n}\n\nconst pipeStreams = (stream1: Duplex, stream2: Duplex) => {\n  pipeline(stream1, stream2, (err) => {\n    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n      log.catch(err);\n    }\n  });\n  pipeline(stream2, stream1, (err) => {\n    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n      log.catch(err);\n    }\n  });\n};\n\nexport class TestConnection {\n  public teleport: Teleport;\n\n  constructor(\n    public readonly localPeerId: PublicKey,\n    public readonly remotePeerId: PublicKey,\n    public readonly initiator: boolean,\n  ) {\n    this.teleport = new Teleport({\n      initiator,\n      localPeerId,\n      remotePeerId,\n    });\n  }\n\n  public whenOpen(open: boolean): Promise<boolean> {\n    return waitForCondition({ condition: () => this.teleport.isOpen === open });\n  }\n}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { type Duplex } from 'node:stream';\n\nimport { runInContextAsync, synchronized, scheduleTask, type Event } from '@dxos/async';\nimport { Context } from '@dxos/context';\nimport { failUndefined } from '@dxos/debug';\nimport { invariant } from '@dxos/invariant';\nimport { PublicKey } from '@dxos/keys';\nimport { log, logInfo } from '@dxos/log';\nimport { RpcClosedError, TimeoutError } from '@dxos/protocols';\n\nimport { ControlExtension } from './control-extension';\nimport { type CreateChannelOpts, Muxer, type MuxerStats, type RpcPort } from './muxing';\n\nexport type TeleportParams = {\n  initiator: boolean;\n  localPeerId: PublicKey;\n  remotePeerId: PublicKey;\n  controlHeartbeatInterval?: number;\n  controlHeartbeatTimeout?: number;\n};\n\nconst CONTROL_HEARTBEAT_INTERVAL = 10_000;\nconst CONTROL_HEARTBEAT_TIMEOUT = 60_000;\n\n/**\n * TODO(burdon): Comment: what is this?\n */\nexport class Teleport {\n  public readonly initiator: boolean;\n  public readonly localPeerId: PublicKey;\n  public readonly remotePeerId: PublicKey;\n  public _sessionId?: PublicKey;\n\n  private readonly _ctx = new Context({\n    onError: (err) => {\n      log.info('error in teleport context', { err });\n      void this.destroy(err).catch(() => {\n        log.error('Error during destroy', err);\n      });\n    },\n  });\n\n  private readonly _muxer = new Muxer();\n\n  private readonly _control;\n\n  private readonly _extensions = new Map<string, TeleportExtension>();\n  private readonly _remoteExtensions = new Set<string>();\n\n  private _open = false;\n  private _destroying = false;\n  private _aborting = false;\n\n  public get isOpen() {\n    return this._open;\n  }\n\n  constructor({ initiator, localPeerId, remotePeerId, ...rest }: TeleportParams) {\n    invariant(typeof initiator === 'boolean');\n    invariant(PublicKey.isPublicKey(localPeerId));\n    invariant(PublicKey.isPublicKey(remotePeerId));\n    this.initiator = initiator;\n    this.localPeerId = localPeerId;\n    this.remotePeerId = remotePeerId;\n\n    this._control = new ControlExtension(\n      {\n        heartbeatInterval: rest.controlHeartbeatInterval ?? CONTROL_HEARTBEAT_INTERVAL,\n        heartbeatTimeout: rest.controlHeartbeatTimeout ?? CONTROL_HEARTBEAT_TIMEOUT,\n        onTimeout: () => {\n          if (this._destroying || this._aborting) {\n            return;\n          }\n          log.info('abort teleport due to onTimeout in ControlExtension');\n          this.abort(new TimeoutError('control extension')).catch((err) => log.catch(err));\n        },\n      },\n      this.localPeerId,\n      this.remotePeerId,\n    );\n\n    this._control.onExtensionRegistered.set(async (name) => {\n      log('remote extension', { name });\n      invariant(!this._remoteExtensions.has(name), 'Remote extension already exists');\n      this._remoteExtensions.add(name);\n\n      if (this._extensions.has(name)) {\n        try {\n          await this._openExtension(name);\n        } catch (err: any) {\n          await this.destroy(err);\n        }\n      }\n    });\n\n    {\n      // Destroy Teleport when the stream is closed.\n      this._muxer.stream.on('close', async () => {\n        if (this._destroying || this._aborting) {\n          log('destroy teleport due to muxer stream close, skipping due to already destroying/aborting');\n          return;\n        }\n        await this.destroy();\n      });\n\n      this._muxer.stream.on('error', async (err) => {\n        await this.destroy(err);\n      });\n    }\n\n    // let last: MuxerStats | undefined;\n    this._muxer.statsUpdated.on((stats) => {\n      log.trace('dxos.mesh.teleport.stats', {\n        localPeerId,\n        remotePeerId,\n        bytesSent: stats.bytesSent,\n        bytesSentRate: stats.bytesSentRate,\n        bytesReceived: stats.bytesReceived,\n        bytesReceivedRate: stats.bytesReceivedRate,\n        channels: stats.channels,\n      });\n\n      // last = stats;\n    });\n  }\n\n  @logInfo\n  get sessionIdString(): string {\n    return this._sessionId ? this._sessionId.truncate() : 'none';\n  }\n\n  get stream(): Duplex {\n    return this._muxer.stream;\n  }\n\n  get stats(): Event<MuxerStats> {\n    return this._muxer.statsUpdated;\n  }\n\n  /**\n   * Blocks until the handshake is complete.\n   */\n\n  async open(sessionId: PublicKey = PublicKey.random()): Promise<void> {\n    // invariant(sessionId);\n    this._sessionId = sessionId;\n    log('open');\n    this._setExtension('dxos.mesh.teleport.control', this._control);\n    await this._openExtension('dxos.mesh.teleport.control');\n    this._open = true;\n    this._muxer.setSessionId(sessionId);\n  }\n\n  async close(err?: Error): Promise<void> {\n    // TODO(dmaretskyi): Try soft close.\n    await this.destroy(err);\n  }\n\n  @synchronized\n  async abort(err?: Error): Promise<void> {\n    if (this._aborting || this._destroying) {\n      return;\n    }\n    this._aborting = true;\n    this._open = false;\n\n    if (this._ctx.disposed) {\n      return;\n    }\n\n    await this._ctx.dispose();\n\n    for (const extension of this._extensions.values()) {\n      try {\n        await extension.onAbort(err);\n      } catch (err: any) {\n        log.catch(err);\n      }\n    }\n\n    await this._muxer.destroy(err);\n  }\n\n  @synchronized\n  // TODO(nf): analyze callers and consider abort instead\n  async destroy(err?: Error): Promise<void> {\n    if (this._destroying || this._aborting) {\n      return;\n    }\n    log('destroying teleport...', { extensionsCount: this._extensions.size });\n    this._destroying = true;\n    this._open = false;\n\n    if (this._ctx.disposed) {\n      return;\n    }\n\n    await this._ctx.dispose();\n\n    for (const extension of this._extensions.values()) {\n      try {\n        log('destroying extension', { name: extension.constructor.name });\n        await extension.onClose(err);\n        log('destroyed extension', { name: extension.constructor.name });\n      } catch (err: any) {\n        log.catch(err);\n      }\n    }\n\n    await this._muxer.close();\n    log('teleport destroyed');\n  }\n\n  addExtension(name: string, extension: TeleportExtension): void {\n    if (!this._open) {\n      throw new Error('Not open');\n    }\n\n    log('addExtension', { name });\n    this._setExtension(name, extension);\n\n    // Perform the registration in a separate tick as this might block while the remote side is opening the extension.\n    scheduleTask(this._ctx, async () => {\n      try {\n        await this._control.registerExtension(name);\n      } catch (err) {\n        if (err instanceof RpcClosedError) {\n          return;\n        }\n        throw err;\n      }\n    });\n\n    if (this._remoteExtensions.has(name)) {\n      // Open the extension in a separate tick.\n      scheduleTask(this._ctx, async () => {\n        await this._openExtension(name);\n      });\n    }\n  }\n\n  private _setExtension(extensionName: string, extension: TeleportExtension): void {\n    invariant(!extensionName.includes('/'), 'Invalid extension name');\n    invariant(!this._extensions.has(extensionName), 'Extension already exists');\n    this._extensions.set(extensionName, extension);\n  }\n\n  private async _openExtension(extensionName: string): Promise<void> {\n    log('open extension', { extensionName });\n    const extension = this._extensions.get(extensionName) ?? failUndefined();\n\n    const context: ExtensionContext = {\n      initiator: this.initiator,\n      localPeerId: this.localPeerId,\n      remotePeerId: this.remotePeerId,\n      createPort: async (channelName: string, opts?: CreateChannelOpts) => {\n        invariant(!channelName.includes('/'), 'Invalid channel name');\n        return this._muxer.createPort(`${extensionName}/${channelName}`, opts);\n      },\n      createStream: async (channelName: string, opts?: CreateChannelOpts) => {\n        invariant(!channelName.includes('/'), 'Invalid channel name');\n        return this._muxer.createStream(`${extensionName}/${channelName}`, opts);\n      },\n      close: (err) => {\n        void runInContextAsync(this._ctx, async () => {\n          await this.close(err);\n        });\n      },\n    };\n\n    await extension.onOpen(context);\n    log('extension opened', { extensionName });\n  }\n}\n\nexport type ExtensionContext = {\n  /**\n   * One of the peers will be designated an initiator.\n   */\n  initiator: boolean;\n  localPeerId: PublicKey;\n  remotePeerId: PublicKey;\n  createStream(tag: string, opts?: CreateChannelOpts): Promise<Duplex>;\n  createPort(tag: string, opts?: CreateChannelOpts): Promise<RpcPort>;\n  close(err?: Error): void;\n};\n\nexport interface TeleportExtension {\n  onOpen(context: ExtensionContext): Promise<void>;\n  onClose(err?: Error): Promise<void>;\n  onAbort(err?: Error): Promise<void>;\n}\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { asyncTimeout, scheduleTaskInterval, TimeoutError as AsyncTimeoutError } from '@dxos/async';\nimport { Context } from '@dxos/context';\nimport { type PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { RpcClosedError } from '@dxos/protocols';\nimport { schema } from '@dxos/protocols/proto';\nimport { type ControlService } from '@dxos/protocols/proto/dxos/mesh/teleport/control';\nimport { createProtoRpcPeer, type ProtoRpcPeer } from '@dxos/rpc';\nimport { Callback } from '@dxos/util';\n\nimport { type ExtensionContext, type TeleportExtension } from './teleport';\n\nconst HEARTBEAT_RTT_WARN_THRESH = 10_000;\nconst DEBUG_PRINT_HEARTBEAT = false; // very noisy\n\ntype ControlRpcBundle = {\n  Control: ControlService;\n};\n\ntype ControlExtensionOpts = {\n  heartbeatInterval: number;\n  heartbeatTimeout: number;\n  onTimeout: (err: any) => void;\n};\n\nexport class ControlExtension implements TeleportExtension {\n  private readonly _ctx = new Context({\n    onError: (err) => {\n      this._extensionContext.close(err);\n    },\n  });\n\n  public readonly onExtensionRegistered = new Callback<(extensionName: string) => void>();\n\n  private _extensionContext!: ExtensionContext;\n  private _rpc!: ProtoRpcPeer<{ Control: ControlService }>;\n\n  constructor(\n    private readonly opts: ControlExtensionOpts,\n    private readonly localPeerId: PublicKey,\n    private readonly remotePeerId: PublicKey,\n  ) {}\n\n  async registerExtension(name: string): Promise<void> {\n    await this._rpc.rpc.Control.registerExtension({ name });\n  }\n\n  async onOpen(extensionContext: ExtensionContext): Promise<void> {\n    this._extensionContext = extensionContext;\n\n    this._rpc = createProtoRpcPeer<ControlRpcBundle, ControlRpcBundle>({\n      requested: {\n        Control: schema.getService('dxos.mesh.teleport.control.ControlService'),\n      },\n      exposed: {\n        Control: schema.getService('dxos.mesh.teleport.control.ControlService'),\n      },\n      handlers: {\n        Control: {\n          registerExtension: async (request) => {\n            this.onExtensionRegistered.call(request.name);\n          },\n          heartbeat: async (request) => {\n            if (DEBUG_PRINT_HEARTBEAT) {\n              log('received heartbeat request', {\n                ts: request.requestTimestamp,\n                localPeerId: this.localPeerId.truncate(),\n                remotePeerId: this.remotePeerId.truncate(),\n              });\n            }\n            return {\n              requestTimestamp: request.requestTimestamp,\n            };\n          },\n        },\n      },\n      port: await extensionContext.createPort('rpc', {\n        contentType: 'application/x-protobuf; messageType=\"dxos.rpc.Message\"',\n      }),\n      timeout: this.opts.heartbeatTimeout,\n    });\n\n    await this._rpc.open();\n\n    scheduleTaskInterval(\n      this._ctx,\n      async () => {\n        const reqTS = new Date();\n        try {\n          const resp = await asyncTimeout(\n            this._rpc.rpc.Control.heartbeat({ requestTimestamp: reqTS }),\n            this.opts.heartbeatTimeout,\n          );\n          const now = Date.now();\n          // TODO(nf): properly instrument\n          if (resp.requestTimestamp instanceof Date) {\n            if (\n              now - resp.requestTimestamp.getTime() >\n              (HEARTBEAT_RTT_WARN_THRESH < this.opts.heartbeatTimeout\n                ? HEARTBEAT_RTT_WARN_THRESH\n                : this.opts.heartbeatTimeout / 2)\n            ) {\n              log.warn(`heartbeat RTT for Teleport > ${HEARTBEAT_RTT_WARN_THRESH / 1000}s`, {\n                rtt: now - resp.requestTimestamp.getTime(),\n                localPeerId: this.localPeerId.truncate(),\n                remotePeerId: this.remotePeerId.truncate(),\n              });\n            } else {\n              if (DEBUG_PRINT_HEARTBEAT) {\n                log('heartbeat RTT', {\n                  rtt: now - resp.requestTimestamp.getTime(),\n                  localPeerId: this.localPeerId.truncate(),\n                  remotePeerId: this.remotePeerId.truncate(),\n                });\n              }\n            }\n          }\n        } catch (err: any) {\n          const now = Date.now();\n          if (err instanceof RpcClosedError) {\n            // TODO: expose 'closed' event in Rpc peer to close context as soon the the peer gets closed\n            log('ignoring RpcClosedError in heartbeat');\n            this._extensionContext.close(err);\n            return;\n          }\n          if (err instanceof AsyncTimeoutError) {\n            log('timeout waiting for heartbeat response', { err, delay: now - reqTS.getTime() });\n            this.opts.onTimeout(err);\n          } else {\n            log.info('other error waiting for heartbeat response', { err, delay: now - reqTS.getTime() });\n            this.opts.onTimeout(err);\n          }\n        }\n      },\n      this.opts.heartbeatInterval,\n    );\n  }\n\n  async onClose(err?: Error): Promise<void> {\n    await this._ctx.dispose();\n    await this._rpc.close();\n  }\n\n  async onAbort(err?: Error | undefined): Promise<void> {\n    await this._ctx.dispose();\n    await this._rpc.abort();\n  }\n}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { Duplex } from 'node:stream';\n\nimport { Event } from '@dxos/async';\nimport { invariant } from '@dxos/invariant';\nimport { log } from '@dxos/log';\n\nimport { type RpcPort } from './rpc-port';\n\nconst FRAME_LENGTH_SIZE = 2;\n\n/**\n * Converts a stream of binary messages into a framed RpcPort.\n * Buffers are written prefixed by their length encoded as a varint.\n */\nexport class Framer {\n  // private readonly _tagBuffer = Buffer.alloc(4)\n  private _messageCb?: (msg: Uint8Array) => void = undefined;\n  private _subscribeCb?: () => void = undefined;\n  private _buffer?: Buffer = undefined; // The rest of the bytes from the previous write call.\n  private _sendCallbacks: (() => void)[] = [];\n\n  private _bytesSent = 0;\n  private _bytesReceived = 0;\n\n  private _writable = true;\n\n  readonly drain = new Event();\n\n  // TODO(egorgripasov): Consider using a Transform stream if it provides better backpressure handling.\n  private readonly _stream = new Duplex({\n    objectMode: false,\n    read: () => {\n      this._processResponseQueue();\n    },\n    write: (chunk, encoding, callback) => {\n      invariant(!this._subscribeCb, 'Internal Framer bug. Concurrent writes detected.');\n\n      this._bytesReceived += chunk.length;\n\n      if (this._buffer && this._buffer.length > 0) {\n        this._buffer = Buffer.concat([this._buffer, chunk]);\n      } else {\n        this._buffer = chunk;\n      }\n\n      if (this._messageCb) {\n        this._popFrames();\n        callback();\n      } else {\n        this._subscribeCb = () => {\n          // Schedule the processing of the chunk after the peer subscribes to the messages.\n          this._popFrames();\n          this._subscribeCb = undefined;\n          callback();\n        };\n      }\n    },\n  });\n\n  public readonly port: RpcPort = {\n    send: (message) => {\n      // log('write', { len: message.length, frame: Buffer.from(message).toString('hex') })\n      return new Promise<void>((resolve) => {\n        const frame = encodeFrame(message);\n        this._bytesSent += frame.length;\n        this._writable = this._stream.push(frame);\n        if (!this._writable) {\n          this._sendCallbacks.push(resolve);\n        } else {\n          resolve();\n        }\n      });\n    },\n    subscribe: (callback) => {\n      invariant(!this._messageCb, 'Rpc port already has a message listener.');\n      this._messageCb = callback;\n      this._subscribeCb?.();\n      return () => {\n        this._messageCb = undefined;\n      };\n    },\n  };\n\n  get stream(): Duplex {\n    return this._stream;\n  }\n\n  get bytesSent() {\n    return this._bytesSent;\n  }\n\n  get bytesReceived() {\n    return this._bytesReceived;\n  }\n\n  get writable() {\n    return this._writable;\n  }\n\n  private _processResponseQueue(): void {\n    const responseQueue = this._sendCallbacks;\n    this._sendCallbacks = [];\n    this._writable = true;\n    this.drain.emit();\n    responseQueue.forEach((cb) => cb());\n  }\n\n  /**\n   * Attempts to pop frames from the buffer and call the message callback.\n   */\n  private _popFrames(): void {\n    let offset = 0;\n    while (offset < this._buffer!.length) {\n      const frame = decodeFrame(this._buffer!, offset);\n\n      if (!frame) {\n        break; // Couldn't read frame but there are still bytes left in the buffer.\n      }\n      offset += frame.bytesConsumed;\n      // TODO(dmaretskyi): Possible bug if the peer unsubscribes while we're reading frames.\n      // log('read', { len: frame.payload.length, frame: Buffer.from(frame.payload).toString('hex') })\n      this._messageCb!(frame.payload);\n    }\n\n    if (offset < this._buffer!.length) {\n      // Save the rest of the bytes for the next write call.\n      this._buffer = this._buffer!.subarray(offset);\n    } else {\n      this._buffer = undefined;\n    }\n  }\n\n  destroy(): void {\n    // TODO(dmaretskyi): Call stream.end() instead?\n    if (this._stream.readableLength > 0) {\n      log('framer destroyed while there are still read bytes in the buffer.');\n    }\n    if (this._stream.writableLength > 0) {\n      log.warn('framer destroyed while there are still write bytes in the buffer.');\n    }\n    this._stream.destroy();\n  }\n}\n\n/**\n * Attempts to read a frame from the input buffer.\n */\nexport const decodeFrame = (buffer: Buffer, offset: number): { payload: Buffer; bytesConsumed: number } | undefined => {\n  if (buffer.length < offset + FRAME_LENGTH_SIZE) {\n    // Not enough bytes to read the frame length.\n    return undefined;\n  }\n\n  const frameLength = buffer.readUInt16BE(offset);\n  const bytesConsumed = FRAME_LENGTH_SIZE + frameLength;\n\n  if (buffer.length < offset + bytesConsumed) {\n    // Not enough bytes to read the frame.\n    return undefined;\n  }\n\n  const payload = buffer.subarray(offset + FRAME_LENGTH_SIZE, offset + bytesConsumed);\n\n  return {\n    payload,\n    bytesConsumed,\n  };\n};\n\nexport const encodeFrame = (payload: Uint8Array): Buffer => {\n  const frame = Buffer.allocUnsafe(FRAME_LENGTH_SIZE + payload.length);\n  frame.writeUInt16BE(payload.length, 0);\n  frame.set(payload, FRAME_LENGTH_SIZE);\n  return frame;\n};\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { Duplex } from 'node:stream';\n\nimport { scheduleTaskInterval, Event, Trigger, asyncTimeout } from '@dxos/async';\nimport { Context } from '@dxos/context';\nimport { failUndefined } from '@dxos/debug';\nimport { invariant } from '@dxos/invariant';\nimport { type PublicKey } from '@dxos/keys';\nimport { log, logInfo } from '@dxos/log';\nimport { TimeoutError } from '@dxos/protocols';\nimport { schema } from '@dxos/protocols/proto';\nimport { type ConnectionInfo } from '@dxos/protocols/proto/dxos/devtools/swarm';\nimport { type Command } from '@dxos/protocols/proto/dxos/mesh/muxer';\n\nimport { Balancer } from './balancer';\nimport { type RpcPort } from './rpc-port';\n\nconst Command = schema.getCodecForType('dxos.mesh.muxer.Command');\n\nconst DEFAULT_SEND_COMMAND_TIMEOUT = 60_000;\nconst DESTROY_COMMAND_SEND_TIMEOUT = 5_000;\n\nexport type CleanupCb = void | (() => void);\n\nexport type CreateChannelOpts = {\n  /**\n   * MIME type of the wire content.\n   *\n   * Examples:\n   *  - application/octet-stream\n   *  - application/x-protobuf; messageType=\"dxos.rpc.Message\"\n   */\n  contentType?: string;\n};\n\nexport type MuxerStats = {\n  timestamp: number;\n  channels: ConnectionInfo.StreamStats[];\n  bytesSent: number;\n  bytesReceived: number;\n  bytesSentRate?: number;\n  bytesReceivedRate?: number;\n  readBufferSize?: number;\n  writeBufferSize?: number;\n};\n\nconst STATS_INTERVAL = 1_000;\nconst MAX_SAFE_FRAME_SIZE = 1_000_000;\nconst SYSTEM_CHANNEL_ID = 0;\nconst GRACEFUL_CLOSE_TIMEOUT = 3_000;\n\ntype Channel = {\n  /**\n   * Our local channel ID.\n   * Incoming Data commands will have this ID.\n   */\n  id: number;\n  tag: string;\n\n  /**\n   * Remote id is set when we receive an OpenChannel command.\n   * The originating Data commands should carry this id.\n   */\n  remoteId: null | number;\n\n  contentType?: string;\n\n  /**\n   * Send buffer.\n   */\n  buffer: Uint8Array[];\n\n  /**\n   * Set when we initialize a NodeJS stream or an RPC port consuming the channel.\n   */\n  push: null | ((data: Uint8Array) => void);\n\n  destroy: null | ((err?: Error) => void);\n\n  stats: {\n    bytesSent: number;\n    bytesReceived: number;\n  };\n};\n\ntype CreateChannelInternalParams = {\n  tag: string;\n  contentType?: string;\n};\n\n/**\n * Channel based multiplexer.\n *\n * Can be used to open a number of channels represented by streams or RPC ports.\n * Performs framing for RPC ports.\n * Will buffer data until the remote peer opens the channel.\n *\n * The API will not advertise channels that as they are opened by the remote peer.\n * A higher level API (could be build on top of this muxer) for channel discovery is required.\n */\nexport class Muxer {\n  private readonly _balancer = new Balancer(SYSTEM_CHANNEL_ID);\n  private readonly _channelsByLocalId = new Map<number, Channel>();\n  private readonly _channelsByTag = new Map<string, Channel>();\n  private readonly _ctx = new Context();\n  private _sessionId?: PublicKey;\n\n  private _nextId = 1;\n\n  private _closing = false;\n  private _destroying = false;\n  private _disposed = false;\n\n  private _lastStats?: MuxerStats = undefined;\n  private readonly _lastChannelStats = new Map<number, Channel['stats']>();\n\n  public afterClosed = new Event<Error | undefined>();\n  public statsUpdated = new Event<MuxerStats>();\n\n  public readonly stream = this._balancer.stream;\n\n  constructor() {\n    // Add a channel for control messages.\n    this._balancer.incomingData.on(async (msg) => {\n      await this._handleCommand(Command.decode(msg));\n    });\n  }\n\n  setSessionId(sessionId: PublicKey): void {\n    this._sessionId = sessionId;\n  }\n\n  @logInfo\n  get sessionIdString(): string {\n    return this._sessionId ? this._sessionId.truncate() : 'none';\n  }\n\n  /**\n   * Creates a duplex Node.js-style stream.\n   * The remote peer is expected to call `createStream` with the same tag.\n   * The stream is immediately readable and writable.\n   * NOTE: The data will be buffered until the stream is opened remotely with the same tag (may cause a memory leak).\n   */\n  async createStream(tag: string, opts: CreateChannelOpts = {}): Promise<Duplex> {\n    const channel = this._getOrCreateStream({\n      tag,\n      contentType: opts.contentType,\n    });\n    invariant(!channel.push, `Channel already open: ${tag}`);\n\n    const stream = new Duplex({\n      write: (data, encoding, callback) => {\n        this._sendData(channel, data)\n          .then(() => callback())\n          .catch(callback);\n        // TODO(dmaretskyi): Should we error if sending data has errored?\n      },\n      read: () => {}, // No-op. We will push data when we receive it.\n    });\n\n    channel.push = (data) => {\n      channel.stats.bytesReceived += data.length;\n      stream.push(data);\n    };\n    channel.destroy = (err) => {\n      // TODO(dmaretskyi): Call stream.end() instead?\n      if (err) {\n        if (stream.listeners('error').length > 0) {\n          stream.destroy(err);\n        } else {\n          stream.destroy();\n        }\n      } else {\n        stream.destroy();\n      }\n    };\n\n    // NOTE: Make sure channel.push is set before sending the command.\n    try {\n      await this._sendCommand(\n        {\n          openChannel: {\n            id: channel.id,\n            tag: channel.tag,\n            contentType: channel.contentType,\n          },\n        },\n        SYSTEM_CHANNEL_ID,\n      );\n    } catch (err: any) {\n      this._destroyChannel(channel, err);\n      throw err;\n    }\n\n    return stream;\n  }\n\n  /**\n   * Creates an RPC port.\n   * The remote peer is expected to call `createPort` with the same tag.\n   * The port is immediately usable.\n   * NOTE: The data will be buffered until the stream is opened remotely with the same tag (may cause a memory leak).\n   */\n  async createPort(tag: string, opts: CreateChannelOpts = {}): Promise<RpcPort> {\n    const channel = this._getOrCreateStream({\n      tag,\n      contentType: opts.contentType,\n    });\n    invariant(!channel.push, `Channel already open: ${tag}`);\n\n    // We need to buffer incoming data until the port is subscribed to.\n    let inboundBuffer: Uint8Array[] = [];\n    let callback: ((data: Uint8Array) => void) | undefined;\n\n    channel.push = (data) => {\n      channel.stats.bytesReceived += data.length;\n      if (callback) {\n        callback(data);\n      } else {\n        inboundBuffer.push(data);\n      }\n    };\n\n    const port: RpcPort = {\n      send: async (data: Uint8Array, timeout?: number) => {\n        await this._sendData(channel, data, timeout);\n        // TODO(dmaretskyi): Debugging.\n        // appendFileSync('log.json', JSON.stringify(schema.getCodecForType('dxos.rpc.RpcMessage').decode(data), null, 2) + '\\n')\n      },\n      subscribe: (cb: (data: Uint8Array) => void) => {\n        invariant(!callback, 'Only one subscriber is allowed');\n        callback = cb;\n        for (const data of inboundBuffer) {\n          cb(data);\n        }\n        inboundBuffer = [];\n      },\n    };\n\n    // NOTE: Make sure channel.push is set before sending the command.\n    try {\n      await this._sendCommand(\n        {\n          openChannel: {\n            id: channel.id,\n            tag: channel.tag,\n            contentType: channel.contentType,\n          },\n        },\n        SYSTEM_CHANNEL_ID,\n      );\n    } catch (err: any) {\n      this._destroyChannel(channel, err);\n      throw err;\n    }\n\n    return port;\n  }\n\n  // initiate graceful close\n\n  async close(err?: Error): Promise<void> {\n    if (this._destroying) {\n      log('already destroying, ignoring graceful close request');\n      return;\n    }\n    if (this._closing) {\n      log('already closing, ignoring graceful close request');\n      return;\n    }\n\n    this._closing = true;\n\n    await this._sendCommand(\n      {\n        close: {\n          error: err?.message,\n        },\n      },\n      SYSTEM_CHANNEL_ID,\n      DESTROY_COMMAND_SEND_TIMEOUT,\n    ).catch(async (err: any) => {\n      log('error sending close command', { err });\n\n      await this._dispose(err);\n    });\n\n    // don't return until close is complete or timeout\n    await asyncTimeout(this._dispose(err), GRACEFUL_CLOSE_TIMEOUT, new TimeoutError('gracefully closing muxer'));\n  }\n\n  // force close without confirmation\n\n  async destroy(err?: Error): Promise<void> {\n    if (this._destroying) {\n      log('already destroying, ignoring destroy request');\n      return;\n    }\n    this._destroying = true;\n    void this._ctx.dispose();\n    if (this._closing) {\n      log('destroy cancelling graceful close');\n      this._closing = false;\n    } else {\n      // as a courtesy to the peer, send destroy command but ignore errors sending\n\n      await this._sendCommand(\n        {\n          close: {\n            error: err?.message,\n          },\n        },\n        SYSTEM_CHANNEL_ID,\n      ).catch(async (err: any) => {\n        log('error sending courtesy close command', { err });\n      });\n    }\n\n    this._dispose(err).catch((err) => {\n      log('error disposing after destroy', { err });\n    });\n  }\n\n  // complete the termination, graceful or otherwise\n\n  async _dispose(err?: Error): Promise<void> {\n    if (this._disposed) {\n      log('already destroyed, ignoring dispose request');\n      return;\n    }\n\n    void this._ctx.dispose();\n\n    await this._balancer.destroy();\n\n    for (const channel of this._channelsByTag.values()) {\n      channel.destroy?.(err);\n    }\n    this._disposed = true;\n    await this._emitStats();\n\n    this.afterClosed.emit(err);\n\n    // Make it easy for GC.\n    this._channelsByLocalId.clear();\n    this._channelsByTag.clear();\n  }\n\n  private async _handleCommand(cmd: Command): Promise<void> {\n    if (this._disposed) {\n      log.warn('Received command after disposed', { cmd });\n      return;\n    }\n\n    if (cmd.close) {\n      if (!this._closing) {\n        log('received peer close, initiating my own graceful close');\n        await this.close(new Error('received peer close'));\n      } else {\n        log('received close from peer, already closing');\n      }\n\n      return;\n    }\n\n    if (cmd.openChannel) {\n      const channel = this._getOrCreateStream({\n        tag: cmd.openChannel.tag,\n        contentType: cmd.openChannel.contentType,\n      });\n      channel.remoteId = cmd.openChannel.id;\n\n      // Flush any buffered data.\n      for (const data of channel.buffer) {\n        await this._sendCommand(\n          {\n            data: {\n              channelId: channel.remoteId!,\n              data,\n            },\n          },\n          channel.id,\n        );\n      }\n      channel.buffer = [];\n    } else if (cmd.data) {\n      const stream = this._channelsByLocalId.get(cmd.data.channelId) ?? failUndefined();\n      if (!stream.push) {\n        log.warn('Received data for channel before it was opened', { tag: stream.tag });\n        return;\n      }\n      stream.push(cmd.data.data);\n    }\n  }\n\n  private async _sendCommand(cmd: Command, channelId = -1, timeout = DEFAULT_SEND_COMMAND_TIMEOUT): Promise<void> {\n    if (this._disposed) {\n      // log.info('ignoring sendCommand after disposed', { cmd });\n      return;\n    }\n    try {\n      const trigger = new Trigger<void>();\n      this._balancer.pushData(Command.encode(cmd), trigger, channelId);\n      await trigger.wait({ timeout });\n    } catch (err: any) {\n      await this.destroy(err);\n    }\n  }\n\n  private _getOrCreateStream(params: CreateChannelInternalParams): Channel {\n    if (this._channelsByTag.size === 0) {\n      scheduleTaskInterval(this._ctx, async () => this._emitStats(), STATS_INTERVAL);\n    }\n    let channel = this._channelsByTag.get(params.tag);\n    if (!channel) {\n      channel = {\n        id: this._nextId++,\n        remoteId: null,\n        tag: params.tag,\n        contentType: params.contentType,\n        buffer: [],\n        push: null,\n        destroy: null,\n        stats: {\n          bytesSent: 0,\n          bytesReceived: 0,\n        },\n      };\n      this._channelsByTag.set(channel.tag, channel);\n      this._channelsByLocalId.set(channel.id, channel);\n      this._balancer.addChannel(channel.id);\n    }\n\n    return channel;\n  }\n\n  private async _sendData(channel: Channel, data: Uint8Array, timeout?: number): Promise<void> {\n    if (data.length > MAX_SAFE_FRAME_SIZE) {\n      log.warn('frame size exceeds maximum safe value', { size: data.length, threshold: MAX_SAFE_FRAME_SIZE });\n    }\n\n    channel.stats.bytesSent += data.length;\n    if (channel.remoteId === null) {\n      // Remote side has not opened the channel yet.\n      channel.buffer.push(data);\n      return;\n    }\n    await this._sendCommand(\n      {\n        data: {\n          channelId: channel.remoteId,\n          data,\n        },\n      },\n      channel.id,\n      timeout,\n    );\n  }\n\n  private _destroyChannel(channel: Channel, err?: Error): void {\n    if (err) {\n      log.warn('destroying channel with error', { err });\n    }\n    if (channel.destroy) {\n      channel.destroy(err);\n    }\n\n    this._channelsByLocalId.delete(channel.id);\n    this._channelsByTag.delete(channel.tag);\n  }\n\n  private async _emitStats(): Promise<void> {\n    if (this._disposed || this._destroying) {\n      if (!this._lastStats) {\n        return;\n      }\n\n      // zero out counting stats to not skew metrics.\n      const lastStats = this._lastStats;\n      this._lastStats = undefined;\n\n      lastStats.readBufferSize = 0;\n      lastStats.writeBufferSize = 0;\n      for (const c of lastStats.channels) {\n        c.writeBufferSize = 0;\n      }\n      this.statsUpdated.emit(lastStats);\n\n      this._lastChannelStats.clear();\n      return;\n    }\n\n    const bytesSent = this._balancer.bytesSent;\n    const bytesReceived = this._balancer.bytesReceived;\n\n    const now = Date.now();\n    const interval = this._lastStats ? (now - this._lastStats.timestamp) / 1_000 : 0;\n    const calculateThroughput = (current: Channel['stats'], last: Channel['stats'] | undefined) =>\n      last\n        ? {\n            bytesSentRate: interval ? (current.bytesSent - last.bytesSent) / interval : undefined,\n            bytesReceivedRate: interval ? (current.bytesReceived - last.bytesReceived) / interval : undefined,\n          }\n        : {};\n\n    this._lastStats = {\n      timestamp: now,\n      channels: Array.from(this._channelsByTag.values()).map((channel) => {\n        const stats: ConnectionInfo.StreamStats = {\n          id: channel.id,\n          tag: channel.tag,\n          contentType: channel.contentType,\n          writeBufferSize: channel.buffer.length,\n          bytesSent: channel.stats.bytesSent,\n          bytesReceived: channel.stats.bytesReceived,\n          ...calculateThroughput(channel.stats, this._lastChannelStats.get(channel.id)),\n        };\n\n        this._lastChannelStats.set(channel.id, stats);\n        return stats;\n      }),\n      bytesSent,\n      bytesReceived,\n      ...calculateThroughput({ bytesSent, bytesReceived }, this._lastStats),\n      readBufferSize: this._balancer.stream.readableLength,\n      writeBufferSize: this._balancer.stream.writableLength,\n    };\n\n    this.statsUpdated.emit(this._lastStats);\n  }\n}\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport varint from 'varint';\n\nimport { type Trigger, Event } from '@dxos/async';\nimport { invariant } from '@dxos/invariant';\nimport { log } from '@dxos/log';\n\nimport { Framer } from './framer';\n\nconst MAX_CHUNK_SIZE = 8192;\n\ntype Chunk = {\n  chunk: Uint8Array;\n  channelId: number;\n  dataLength?: number;\n};\n\ntype ChunkEnvelope = {\n  msg: Buffer;\n  trigger?: Trigger;\n};\n\ntype ChannelBuffer = {\n  buffer: Buffer;\n  msgLength: number;\n};\n\n/**\n * Load balancer for handling asynchronous calls from multiple channels.\n *\n * Manages a queue of calls from different channels and ensures that the calls\n * are processed in a balanced manner in a round-robin fashion.\n */\nexport class Balancer {\n  private _lastCallerIndex = 0;\n  private _channels: number[] = [];\n\n  private readonly _framer = new Framer();\n  // TODO(egorgripasov): Will cause a memory leak if channels do not appreciate the backpressure.\n  private readonly _sendBuffers: Map<number, ChunkEnvelope[]> = new Map();\n  private readonly _receiveBuffers = new Map<number, ChannelBuffer>();\n\n  private _sending = false;\n  public incomingData = new Event<Uint8Array>();\n  public readonly stream = this._framer.stream;\n\n  constructor(private readonly _sysChannelId: number) {\n    this._channels.push(_sysChannelId);\n\n    // Handle incoming messages.\n    this._framer.port.subscribe(this._processIncomingMessage.bind(this));\n  }\n\n  get bytesSent() {\n    return this._framer.bytesSent;\n  }\n\n  get bytesReceived() {\n    return this._framer.bytesReceived;\n  }\n\n  get buffersCount() {\n    return this._sendBuffers.size;\n  }\n\n  addChannel(channel: number): void {\n    this._channels.push(channel);\n  }\n\n  pushData(data: Uint8Array, trigger: Trigger, channelId: number): void {\n    this._enqueueChunk(data, trigger, channelId);\n    this._sendChunks().catch((err) => log.catch(err));\n  }\n\n  destroy(): void {\n    if (this._sendBuffers.size !== 0) {\n      log.info('destroying balancer with pending calls');\n    }\n    this._sendBuffers.clear();\n    this._framer.destroy();\n  }\n\n  private _processIncomingMessage(msg: Uint8Array): void {\n    const { channelId, dataLength, chunk } = decodeChunk(msg, (channelId) => !this._receiveBuffers.has(channelId));\n    if (!this._receiveBuffers.has(channelId)) {\n      if (chunk.length < dataLength!) {\n        this._receiveBuffers.set(channelId, {\n          buffer: Buffer.from(chunk),\n          msgLength: dataLength!,\n        });\n      } else {\n        this.incomingData.emit(chunk);\n      }\n    } else {\n      const channelBuffer = this._receiveBuffers.get(channelId)!;\n      channelBuffer.buffer = Buffer.concat([channelBuffer.buffer, chunk]);\n      if (channelBuffer.buffer.length < channelBuffer.msgLength) {\n        return;\n      }\n      const msg = channelBuffer.buffer;\n      this._receiveBuffers.delete(channelId);\n      this.incomingData.emit(msg);\n    }\n  }\n\n  private _getNextCallerId(): number {\n    if (this._sendBuffers.has(this._sysChannelId)) {\n      return this._sysChannelId;\n    }\n\n    const index = this._lastCallerIndex;\n    this._lastCallerIndex = (this._lastCallerIndex + 1) % this._channels.length;\n\n    return this._channels[index];\n  }\n\n  private _enqueueChunk(data: Uint8Array, trigger: Trigger, channelId: number): void {\n    if (!this._channels.includes(channelId)) {\n      throw new Error(`Unknown channel ${channelId}`);\n    }\n\n    if (!this._sendBuffers.has(channelId)) {\n      this._sendBuffers.set(channelId, []);\n    }\n\n    const sendBuffer = this._sendBuffers.get(channelId)!;\n\n    const chunks = [];\n    for (let idx = 0; idx < data.length; idx += MAX_CHUNK_SIZE) {\n      chunks.push(data.subarray(idx, idx + MAX_CHUNK_SIZE));\n    }\n\n    chunks.forEach((chunk, index) => {\n      const msg = encodeChunk({\n        chunk,\n        channelId,\n        dataLength: index === 0 ? data.length : undefined,\n      });\n      sendBuffer.push({ msg, trigger: index === chunks.length - 1 ? trigger : undefined });\n    });\n  }\n\n  // get the next chunk or null if there are no chunks remaining\n\n  private _getNextChunk(): ChunkEnvelope | null {\n    let chunk;\n    while (this._sendBuffers.size > 0) {\n      const channelId = this._getNextCallerId();\n      const sendBuffer = this._sendBuffers.get(channelId);\n      if (!sendBuffer) {\n        continue;\n      }\n\n      chunk = sendBuffer.shift();\n      if (!chunk) {\n        continue;\n      }\n      if (sendBuffer.length === 0) {\n        this._sendBuffers.delete(channelId);\n      }\n      return chunk;\n    }\n    return null;\n  }\n\n  private async _sendChunks(): Promise<void> {\n    if (this._sending) {\n      return;\n    }\n    this._sending = true;\n    let chunk: ChunkEnvelope | null;\n    chunk = this._getNextChunk();\n    while (chunk) {\n      // TODO(nf): determine whether this is needed since we await the chunk send\n      if (!this._framer.writable) {\n        log('PAUSE for drain');\n        await this._framer.drain.waitForCount(1);\n        log('RESUME for drain');\n      }\n      try {\n        await this._framer.port.send(chunk.msg);\n        chunk.trigger?.wake();\n      } catch (err: any) {\n        log('Error sending chunk', { err });\n        chunk.trigger?.throw(err);\n      }\n      chunk = this._getNextChunk();\n    }\n    invariant(this._sendBuffers.size === 0, 'sendBuffers not empty');\n    this._sending = false;\n  }\n}\n\nexport const encodeChunk = ({ channelId, dataLength, chunk }: Chunk): Buffer => {\n  const channelTagLength = varint.encodingLength(channelId);\n  const dataLengthLength = dataLength ? varint.encodingLength(dataLength) : 0;\n  const message = Buffer.allocUnsafe(channelTagLength + dataLengthLength + chunk.length);\n  varint.encode(channelId, message);\n  if (dataLength) {\n    varint.encode(dataLength, message, channelTagLength);\n  }\n  message.set(chunk, channelTagLength + dataLengthLength);\n  return message;\n};\n\nexport const decodeChunk = (data: Uint8Array, withLength: (channelId: number) => boolean): Chunk => {\n  const channelId = varint.decode(data);\n  let dataLength: number | undefined;\n  let offset = varint.decode.bytes;\n\n  if (withLength(channelId)) {\n    dataLength = varint.decode(data, offset);\n    offset += varint.decode.bytes;\n  }\n\n  const chunk = data.subarray(offset);\n\n  return { channelId, dataLength, chunk };\n};\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { asyncTimeout, Trigger } from '@dxos/async';\nimport { invariant } from '@dxos/invariant';\nimport { log } from '@dxos/log';\nimport { schema } from '@dxos/protocols/proto';\nimport { type TestService } from '@dxos/protocols/proto/example/testing/rpc';\nimport { createProtoRpcPeer, type ProtoRpcPeer } from '@dxos/rpc';\n\nimport { type ExtensionContext, type TeleportExtension } from '../teleport';\n\ninterface TestExtensionCallbacks {\n  onOpen?: () => Promise<void>;\n  onClose?: () => Promise<void>;\n  onAbort?: () => Promise<void>;\n}\n\nexport class TestExtension implements TeleportExtension {\n  public readonly open = new Trigger();\n  public readonly closed = new Trigger();\n  public readonly aborted = new Trigger();\n  public extensionContext: ExtensionContext | undefined;\n  private _rpc!: ProtoRpcPeer<{ TestService: TestService }>;\n\n  constructor(public readonly callbacks: TestExtensionCallbacks = {}) {}\n\n  get remotePeerId() {\n    return this.extensionContext?.remotePeerId;\n  }\n\n  async onOpen(context: ExtensionContext): Promise<void> {\n    log('onOpen', { localPeerId: context.localPeerId, remotePeerId: context.remotePeerId });\n    this.extensionContext = context;\n    this._rpc = createProtoRpcPeer<{ TestService: TestService }, { TestService: TestService }>({\n      port: await context.createPort('rpc', {\n        contentType: 'application/x-protobuf; messageType=\"dxos.rpc.Message\"',\n      }),\n      requested: {\n        TestService: schema.getService('example.testing.rpc.TestService'),\n      },\n      exposed: {\n        TestService: schema.getService('example.testing.rpc.TestService'),\n      },\n      handlers: {\n        TestService: {\n          voidCall: async (request) => {\n            // Ok.\n          },\n          testCall: async (request) => {\n            return {\n              data: request.data,\n            };\n          },\n        },\n      },\n      timeout: 2000,\n    });\n\n    await this._rpc.open();\n    await this.callbacks.onOpen?.();\n\n    this.open.wake();\n  }\n\n  async onClose(err?: Error): Promise<void> {\n    log('onClose', { err });\n    await this.callbacks.onClose?.();\n    this.closed.wake();\n    await this._rpc?.close();\n  }\n\n  async onAbort(err?: Error): Promise<void> {\n    log('onAbort', { err });\n    await this.callbacks.onAbort?.();\n    this.aborted.wake();\n    await this._rpc?.abort();\n  }\n\n  async test(message = 'test'): Promise<void> {\n    await this.open.wait({ timeout: 2000 });\n    const res = await asyncTimeout(this._rpc.rpc.TestService.testCall({ data: message }), 1500);\n    invariant(res.data === message);\n  }\n\n  /**\n   * Force-close the connection.\n   */\n  async closeConnection(err?: Error): Promise<void> {\n    this.extensionContext?.close(err);\n  }\n}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { randomBytes } from 'node:crypto';\nimport { type Duplex } from 'node:stream';\n\nimport { Trigger } from '@dxos/async';\nimport { invariant } from '@dxos/invariant';\nimport { log } from '@dxos/log';\nimport { schema } from '@dxos/protocols/proto';\nimport { type TestServiceWithStreams } from '@dxos/protocols/proto/example/testing/rpc';\nimport { createProtoRpcPeer, type ProtoRpcPeer } from '@dxos/rpc';\n\nimport { type ExtensionContext, type TeleportExtension } from '../teleport';\n\ninterface TestExtensionWithStreamsCallbacks {\n  onOpen?: () => Promise<void>;\n  onClose?: () => Promise<void>;\n  onAbort?: () => Promise<void>;\n}\n\nexport class TestExtensionWithStreams implements TeleportExtension {\n  public readonly open = new Trigger();\n  public readonly closed = new Trigger();\n  public readonly aborted = new Trigger();\n  private readonly _streams = new Map<string, TestStream>();\n\n  public extensionContext: ExtensionContext | undefined;\n  private _rpc!: ProtoRpcPeer<{ TestServiceWithStreams: TestServiceWithStreams }>;\n\n  constructor(public readonly callbacks: TestExtensionWithStreamsCallbacks = {}) {}\n\n  get remotePeerId() {\n    return this.extensionContext?.remotePeerId;\n  }\n\n  private async _openStream(streamTag: string, interval = 5, chunkSize = 2048): Promise<void> {\n    invariant(!this._streams.has(streamTag), `Stream already exists: ${streamTag}`);\n\n    const networkStream = await this.extensionContext!.createStream(streamTag, {\n      contentType: 'application/x-test-stream',\n    });\n\n    const streamEntry: TestStream = {\n      networkStream,\n      bytesSent: 0,\n      bytesReceived: 0,\n      sendErrors: 0,\n      receiveErrors: 0,\n      startTimestamp: Date.now(),\n    };\n\n    const pushChunk = () => {\n      streamEntry.timer = setTimeout(() => {\n        const chunk = randomBytes(chunkSize);\n\n        if (\n          !networkStream.write(chunk, 'binary', (err) => {\n            if (!err) {\n              streamEntry.bytesSent += chunk.length;\n            } else {\n              streamEntry.sendErrors += 1;\n            }\n          })\n        ) {\n          networkStream.once('drain', pushChunk);\n        } else {\n          process.nextTick(pushChunk);\n        }\n      }, interval);\n    };\n\n    pushChunk();\n\n    this._streams.set(streamTag, streamEntry);\n\n    networkStream.on('data', (data) => {\n      streamEntry.bytesReceived += data.length;\n    });\n\n    networkStream.on('error', (err) => {\n      streamEntry.receiveErrors += 1;\n    });\n\n    networkStream.on('close', () => {\n      networkStream.removeAllListeners();\n    });\n\n    streamEntry.reportingTimer = setInterval(() => {\n      const { bytesSent, bytesReceived, sendErrors, receiveErrors } = streamEntry;\n      // log.info('stream stats', { streamTag, bytesSent, bytesReceived, sendErrors, receiveErrors });\n      log.trace('dxos.test.stream-stats', {\n        streamTag,\n        bytesSent,\n        bytesReceived,\n        sendErrors,\n        receiveErrors,\n        from: this.extensionContext?.localPeerId,\n        to: this.extensionContext?.remotePeerId,\n      });\n    }, 100);\n  }\n\n  private _closeStream(streamTag: string): Stats {\n    invariant(this._streams.has(streamTag), `Stream does not exist: ${streamTag}`);\n\n    const stream = this._streams.get(streamTag)!;\n\n    clearTimeout(stream.timer);\n    clearTimeout(stream.reportingTimer);\n\n    const { bytesSent, bytesReceived, sendErrors, receiveErrors, startTimestamp } = stream;\n\n    stream.networkStream.destroy();\n    this._streams.delete(streamTag);\n\n    return {\n      bytesSent,\n      bytesReceived,\n      sendErrors,\n      receiveErrors,\n      runningTime: Date.now() - (startTimestamp ?? 0),\n    };\n  }\n\n  async onOpen(context: ExtensionContext): Promise<void> {\n    log('onOpen', { localPeerId: context.localPeerId, remotePeerId: context.remotePeerId });\n    this.extensionContext = context;\n    this._rpc = createProtoRpcPeer<\n      { TestServiceWithStreams: TestServiceWithStreams },\n      { TestServiceWithStreams: TestServiceWithStreams }\n    >({\n      port: await context.createPort('rpc', {\n        contentType: 'application/x-protobuf; messageType=\"dxos.rpc.Message\"',\n      }),\n      requested: {\n        TestServiceWithStreams: schema.getService('example.testing.rpc.TestServiceWithStreams'),\n      },\n      exposed: {\n        TestServiceWithStreams: schema.getService('example.testing.rpc.TestServiceWithStreams'),\n      },\n      handlers: {\n        TestServiceWithStreams: {\n          requestTestStream: async (request) => {\n            const { data: streamTag, streamLoadInterval, streamLoadChunkSize } = request;\n\n            await this._openStream(streamTag, streamLoadInterval, streamLoadChunkSize);\n\n            return {\n              data: streamTag,\n            };\n          },\n          closeTestStream: async (request) => {\n            const streamTag = request.data;\n            const { bytesSent, bytesReceived, sendErrors, receiveErrors, runningTime } = this._closeStream(streamTag);\n\n            return {\n              data: streamTag,\n              bytesSent,\n              bytesReceived,\n              sendErrors,\n              receiveErrors,\n              runningTime,\n            };\n          },\n        },\n      },\n      timeout: 2000,\n    });\n\n    await this._rpc.open();\n    await this.callbacks.onOpen?.();\n\n    this.open.wake();\n  }\n\n  async onClose(err?: Error): Promise<void> {\n    log('onClose', { err });\n    await this.callbacks.onClose?.();\n    this.closed.wake();\n    for (const [streamTag, stream] of Object.entries(this._streams)) {\n      log('closing stream', { streamTag });\n      clearTimeout(stream.interval);\n      stream.networkStream.destroy();\n    }\n    await this._rpc?.close();\n  }\n\n  async onAbort(err?: Error): Promise<void> {\n    log('onAbort', { err });\n    await this.callbacks.onAbort?.();\n    this.aborted.wake();\n    await this._rpc?.abort();\n  }\n\n  async addNewStream(streamLoadInterval: number, streamLoadChunkSize: number, streamTag?: string): Promise<string> {\n    await this.open.wait({ timeout: 1500 });\n    if (!streamTag) {\n      streamTag = `stream-${randomBytes(4).toString('hex')}`;\n    }\n    const { data } = await this._rpc.rpc.TestServiceWithStreams.requestTestStream({\n      data: streamTag,\n      streamLoadInterval,\n      streamLoadChunkSize,\n    });\n    invariant(data === streamTag);\n\n    await this._openStream(streamTag, streamLoadInterval, streamLoadChunkSize);\n    return streamTag;\n  }\n\n  async closeStream(streamTag: string): Promise<TestStreamStats> {\n    await this.open.wait({ timeout: 1500 });\n    const { data, bytesSent, bytesReceived, sendErrors, receiveErrors, runningTime } =\n      await this._rpc.rpc.TestServiceWithStreams.closeTestStream({\n        data: streamTag,\n      });\n\n    invariant(data === streamTag);\n\n    const local = this._closeStream(streamTag);\n\n    return {\n      streamTag,\n      stats: {\n        local,\n        remote: {\n          bytesSent,\n          bytesReceived,\n          sendErrors,\n          receiveErrors,\n          runningTime,\n        },\n      },\n    };\n  }\n\n  /**\n   * Force-close the connection.\n   */\n  async closeConnection(err?: Error): Promise<void> {\n    this.extensionContext?.close(err);\n  }\n}\n\ntype Stats = {\n  bytesSent: number;\n  bytesReceived: number;\n  sendErrors: number;\n  receiveErrors: number;\n  runningTime: number;\n};\n\nexport type TestStreamStats = {\n  streamTag: string;\n  stats: {\n    local: Stats;\n    remote: Stats;\n  };\n};\n\ntype TestStream = {\n  networkStream: Duplex;\n  bytesSent: number;\n  bytesReceived: number;\n  sendErrors: number;\n  receiveErrors: number;\n  timer?: NodeJS.Timeout;\n  startTimestamp?: number;\n  reportingTimer?: NodeJS.Timeout;\n};\n"],
  "mappings": "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",
  "names": ["import_async", "import_invariant", "import_keys", "import_log", "import_context", "import_protocols", "import_node_stream", "import_debug", "import_proto", "import_rpc", "exports", "module", "HEARTBEAT_RTT_WARN_THRESH", "DEBUG_PRINT_HEARTBEAT", "ControlExtension", "opts", "localPeerId", "remotePeerId", "_ctx", "Context", "onError", "err", "_extensionContext", "close", "onExtensionRegistered", "Callback", "registerExtension", "name", "_rpc", "rpc", "Control", "onOpen", "extensionContext", "createProtoRpcPeer", "requested", "schema", "getService", "exposed", "handlers", "request", "call", "heartbeat", "log", "ts", "requestTimestamp", "truncate", "port", "createPort", "contentType", "timeout", "heartbeatTimeout", "open", "scheduleTaskInterval", "reqTS", "Date", "resp", "asyncTimeout", "now", "getTime", "warn", "rtt", "RpcClosedError", "AsyncTimeoutError", "delay", "onTimeout", "info", "heartbeatInterval", "onClose", "dispose", "onAbort", "abort", "FRAME_LENGTH_SIZE", "Framer", "undefined", "_subscribeCb", "_buffer", "_sendCallbacks", "_bytesSent", "_bytesReceived", "_writable", "drain", "Event", "Duplex", "objectMode", "read", "_processResponseQueue", "write", "chunk", "encoding", "callback", "invariant", "length", "Buffer", "concat", "_messageCb", "_popFrames", "send", "message", "Promise", "resolve", "frame", "encodeFrame", "_stream", "push", "subscribe", "stream", "bytesSent", "bytesReceived", "writable", "responseQueue", "emit", "forEach", "cb", "offset", "decodeFrame", "bytesConsumed", "payload", "subarray", "destroy", "readableLength", "writableLength", "buffer", "frameLength", "readUInt16BE", "allocUnsafe", "writeUInt16BE", "set", "MAX_CHUNK_SIZE", "Balancer", "_sysChannelId", "_lastCallerIndex", "_channels", "_framer", "_sendBuffers", "Map", "_receiveBuffers", "_sending", "incomingData", "_processIncomingMessage", "bind", "buffersCount", "size", "addChannel", "channel", "pushData", "data", "trigger", "channelId", "_enqueueChunk", "_sendChunks", "catch", "clear", "msg", "dataLength", "decodeChunk", "has", "from", "msgLength", "channelBuffer", "get", "delete", "_getNextCallerId", "index", "includes", "Error", "sendBuffer", "chunks", "idx", "encodeChunk", "_getNextChunk", "shift", "waitForCount", "wake", "throw", "channelTagLength", "varint", "encodingLength", "dataLengthLength", "encode", "withLength", "decode", "bytes", "Command", "getCodecForType", "DEFAULT_SEND_COMMAND_TIMEOUT", "DESTROY_COMMAND_SEND_TIMEOUT", "STATS_INTERVAL", "MAX_SAFE_FRAME_SIZE", "SYSTEM_CHANNEL_ID", "GRACEFUL_CLOSE_TIMEOUT", "Muxer", "_balancer", "_channelsByLocalId", "_channelsByTag", "_nextId", "_closing", "_destroying", "_disposed", "_lastStats", "_lastChannelStats", "afterClosed", "statsUpdated", "on", "_handleCommand", "setSessionId", "sessionId", "_sessionId", "sessionIdString", "createStream", "tag", "_getOrCreateStream", "_sendData", "then", "stats", "listeners", "_sendCommand", "openChannel", "id", "_destroyChannel", "inboundBuffer", "error", "_dispose", "TimeoutError", "values", "_emitStats", "cmd", "remoteId", "failUndefined", "Trigger", "wait", "params", "threshold", "lastStats", "readBufferSize", "writeBufferSize", "c", "channels", "interval", "timestamp", "calculateThroughput", "current", "last", "bytesSentRate", "bytesReceivedRate", "Array", "map", "CONTROL_HEARTBEAT_INTERVAL", "CONTROL_HEARTBEAT_TIMEOUT", "Teleport", "initiator", "rest", "_muxer", "_extensions", "_remoteExtensions", "Set", "_open", "_aborting", "PublicKey", "isPublicKey", "_control", "controlHeartbeatInterval", "controlHeartbeatTimeout", "add", "_openExtension", "trace", "isOpen", "random", "_setExtension", "disposed", "extension", "extensionsCount", "addExtension", "scheduleTask", "extensionName", "context", "channelName", "runInContextAsync", "TestBuilder", "_peers", "createPeer", "peer", "factory", "createPeers", "all", "agent", "connect", "peer1", "peer2", "connection1", "createConnection", "peerId", "connection2", "pipeStreams", "teleport", "openConnection", "disconnect", "connections", "find", "connection", "equals", "closeConnection", "TestPeer", "TestConnection", "stream1", "stream2", "pipeline", "code", "whenOpen", "waitForCondition", "condition", "TestExtension", "callbacks", "closed", "aborted", "TestService", "voidCall", "testCall", "test", "res", "TestExtensionWithStreams", "_streams", "_openStream", "streamTag", "chunkSize", "networkStream", "streamEntry", "sendErrors", "receiveErrors", "startTimestamp", "pushChunk", "timer", "setTimeout", "randomBytes", "once", "process", "nextTick", "removeAllListeners", "reportingTimer", "setInterval", "to", "_closeStream", "clearTimeout", "runningTime", "TestServiceWithStreams", "requestTestStream", "streamLoadInterval", "streamLoadChunkSize", "closeTestStream", "Object", "entries", "addNewStream", "toString", "closeStream", "local", "remote"]
}
