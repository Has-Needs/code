{
  "version": 3,
  "sources": ["../../../src/blob-sync-extension.ts", "../../../src/blob-sync.ts", "../../../src/blob-store.ts"],
  "sourcesContent": ["//\n\n//\n// Copyright 2023 DXOS.org\n//\n\nimport { DeferredTask, sleep, synchronized } from '@dxos/async';\nimport { Context } from '@dxos/context';\nimport { invariant } from '@dxos/invariant';\nimport { log } from '@dxos/log';\nimport { RpcClosedError } from '@dxos/protocols';\nimport { schema } from '@dxos/protocols/proto';\nimport { type BlobChunk, type BlobSyncService, type WantList } from '@dxos/protocols/proto/dxos/mesh/teleport/blobsync';\nimport { type ExtensionContext, RpcExtension } from '@dxos/teleport';\nimport { BitField } from '@dxos/util';\n\nimport { type BlobStore } from './blob-store';\n\nexport type BlobSyncExtensionParams = {\n  blobStore: BlobStore;\n  onOpen: () => Promise<void>;\n  onClose: () => Promise<void>;\n  onAbort: () => Promise<void>;\n  onPush: (data: BlobChunk) => Promise<void>;\n};\n\nconst MIN_WANT_LIST_UPDATE_INTERVAL = process.env.NODE_ENV === 'test' ? 5 : 500;\n\nconst MAX_CONCURRENT_UPLOADS = 20;\n\n/**\n * Manages replication between a set of feeds for a single teleport session.\n */\nexport class BlobSyncExtension extends RpcExtension<ServiceBundle, ServiceBundle> {\n  private readonly _ctx = new Context({ onError: (err) => log.catch(err) });\n\n  private _lastWantListUpdate = 0;\n  private _localWantList: WantList = { blobs: [] };\n\n  private readonly _updateWantList = new DeferredTask(this._ctx, async () => {\n    // Throttle want list updates.\n    if (this._lastWantListUpdate + MIN_WANT_LIST_UPDATE_INTERVAL > Date.now()) {\n      await sleep(this._lastWantListUpdate + MIN_WANT_LIST_UPDATE_INTERVAL - Date.now());\n      if (this._ctx.disposed) {\n        return;\n      }\n    }\n\n    log('want', { list: this._localWantList });\n    await this.rpc.BlobSyncService.want(this._localWantList);\n    this._lastWantListUpdate = Date.now();\n  });\n\n  private _currentUploads = 0;\n\n  private readonly _upload = new DeferredTask(this._ctx, async () => {\n    if (this._currentUploads >= MAX_CONCURRENT_UPLOADS) {\n      return;\n    }\n    const blobChunks = await this._pickBlobChunks(MAX_CONCURRENT_UPLOADS - this._currentUploads);\n    if (!blobChunks) {\n      return;\n    }\n    for (const blobChunk of blobChunks) {\n      if (this._ctx.disposed) {\n        break;\n      }\n\n      this._currentUploads++;\n\n      this.push(blobChunk)\n        .catch((err) => {\n          if (err instanceof RpcClosedError) {\n            return;\n          }\n          log.warn('push failed', { err });\n        })\n        .finally(() => {\n          this._currentUploads--;\n          this.reconcileUploads();\n        });\n    }\n  });\n\n  /**\n   * Set of id's remote peer wants.\n   */\n  public remoteWantList: WantList = { blobs: [] };\n\n  constructor(\n    private readonly _params: BlobSyncExtensionParams, // to not conflict with the base class\n  ) {\n    super({\n      exposed: {\n        BlobSyncService: schema.getService('dxos.mesh.teleport.blobsync.BlobSyncService'),\n      },\n      requested: {\n        BlobSyncService: schema.getService('dxos.mesh.teleport.blobsync.BlobSyncService'),\n      },\n      timeout: 20_000,\n      encodingOptions: {\n        preserveAny: true,\n      },\n    });\n  }\n\n  override async onOpen(context: ExtensionContext): Promise<void> {\n    log('open');\n    await super.onOpen(context);\n    await this._params.onOpen();\n  }\n\n  override async onClose(err?: Error | undefined): Promise<void> {\n    log('close');\n    await this._ctx.dispose();\n    await this._params.onClose();\n    await super.onClose(err);\n  }\n\n  override async onAbort(err?: Error | undefined): Promise<void> {\n    log('abort');\n    await this._ctx.dispose();\n    await this._params.onAbort();\n    await super.onAbort(err);\n  }\n\n  protected async getHandlers(): Promise<ServiceBundle> {\n    return {\n      BlobSyncService: {\n        want: async (wantList) => {\n          log('remote want', { remoteWantList: wantList });\n          this.remoteWantList = wantList;\n          this.reconcileUploads();\n        },\n        push: async (data) => {\n          log('received', { data });\n          await this._params.onPush(data);\n        },\n      },\n    };\n  }\n\n  @synchronized\n  async push(data: BlobChunk): Promise<void> {\n    if (this._ctx.disposed) {\n      return;\n    }\n    log('push', { data });\n    await this.rpc.BlobSyncService.push(data);\n  }\n\n  updateWantList(wantList: WantList): void {\n    if (this._ctx.disposed) {\n      return;\n    }\n    this._localWantList = wantList;\n    this._updateWantList.schedule();\n  }\n\n  reconcileUploads(): void {\n    if (this._ctx.disposed) {\n      return;\n    }\n    this._upload.schedule();\n  }\n\n  private async _pickBlobChunks(amount = 1): Promise<BlobChunk[] | void> {\n    if (this._ctx.disposed) {\n      return;\n    }\n\n    if (!this.remoteWantList.blobs || this.remoteWantList.blobs?.length === 0) {\n      return;\n    }\n\n    const shuffled = [...this.remoteWantList.blobs].sort(() => Math.random() - 0.5);\n\n    const chunks: BlobChunk[] = [];\n\n    for (const header of shuffled) {\n      const meta = await this._params.blobStore.getMeta(header.id);\n\n      if (!meta) {\n        // Skip this header\n        continue;\n      }\n      invariant(meta.bitfield);\n      invariant(meta.chunkSize);\n      invariant(meta.length);\n\n      if (header.chunkSize && header.chunkSize !== meta.chunkSize) {\n        log.warn('Invalid chunk size', { header, meta });\n        continue;\n      }\n\n      const requestBitfield = header.bitfield ?? BitField.ones(meta.length / meta.chunkSize);\n\n      const presentData = BitField.and(requestBitfield, meta.bitfield);\n      const chunkIndices = BitField.findIndexes(presentData).sort(() => Math.random() - 0.5);\n\n      for (const idx of chunkIndices) {\n        const chunkData = await this._params.blobStore.get(header.id, {\n          offset: idx * meta.chunkSize,\n          length: Math.min(meta.chunkSize, meta.length - idx * meta.chunkSize),\n        });\n        chunks.push({\n          id: header.id,\n          totalLength: meta.length,\n          chunkSize: meta.chunkSize,\n          chunkOffset: idx * meta.chunkSize,\n          payload: chunkData,\n        });\n\n        if (chunks.length >= amount) {\n          return chunks;\n        }\n      }\n    }\n\n    return chunks;\n  }\n}\n\ntype ServiceBundle = {\n  BlobSyncService: BlobSyncService;\n};\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { trackLeaks, Trigger, Mutex } from '@dxos/async';\nimport { cancelWithContext, Context } from '@dxos/context';\nimport { invariant } from '@dxos/invariant';\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { BlobMeta } from '@dxos/protocols/proto/dxos/echo/blob';\nimport { type WantList } from '@dxos/protocols/proto/dxos/mesh/teleport/blobsync';\nimport { BitField, ComplexMap } from '@dxos/util';\n\nimport { type BlobStore } from './blob-store';\nimport { BlobSyncExtension } from './blob-sync-extension';\n\nexport type BlobSyncParams = {\n  blobStore: BlobStore;\n};\n\ntype DownloadRequest = {\n  trigger: Trigger<void>;\n  counter: number;\n  want: WantList.Entry;\n};\n\n// TODO(dmaretskyi): Rename to blob-sync.\n@trackLeaks('open', 'close')\nexport class BlobSync {\n  private readonly _ctx = new Context();\n  private readonly _mutex = new Mutex();\n\n  private readonly _downloadRequests = new ComplexMap<Uint8Array, DownloadRequest>((key) =>\n    PublicKey.from(key).toHex(),\n  );\n\n  private readonly _extensions = new Set<BlobSyncExtension>();\n\n  constructor(private readonly _params: BlobSyncParams) {}\n\n  async open(): Promise<void> {}\n\n  async close(): Promise<void> {\n    await this._ctx.dispose();\n  }\n\n  /**\n   * Resolves when the object with the given id is fully downloaded in the blob store.\n   *\n   * @param id hex-encoded id of the object to download.\n   */\n  async download(ctx: Context, id: Uint8Array): Promise<void> {\n    log('download', { id });\n    const request = await this._mutex.executeSynchronized(async () => {\n      const existingRequest = this._downloadRequests.get(id);\n\n      if (existingRequest) {\n        existingRequest.counter++;\n        return existingRequest;\n      }\n\n      const meta = await this._params.blobStore.getMeta(id);\n      const request: DownloadRequest = {\n        trigger: new Trigger(),\n        counter: 1,\n        want: {\n          id,\n          chunkSize: meta?.chunkSize,\n          bitfield: meta?.bitfield && Uint8Array.from(BitField.invert(meta.bitfield)),\n        },\n      };\n\n      // Check if the object is already fully downloaded.\n      if (meta?.state === BlobMeta.State.FULLY_PRESENT) {\n        request.trigger.wake();\n      } else {\n        this._downloadRequests.set(id, request);\n        this._updateExtensionsWantList();\n      }\n\n      return request;\n    });\n\n    ctx?.onDispose(() =>\n      this._mutex.executeSynchronized(async () => {\n        // Remove request if context is disposed and nobody else requests it.\n        const request = this._downloadRequests.get(id);\n        if (!request) {\n          return;\n        }\n        if (--request.counter === 0) {\n          this._downloadRequests.delete(id);\n        }\n        this._updateExtensionsWantList();\n      }),\n    );\n\n    return ctx ? cancelWithContext(ctx, request.trigger.wait()) : request.trigger.wait();\n  }\n\n  createExtension(): BlobSyncExtension {\n    const extension = new BlobSyncExtension({\n      blobStore: this._params.blobStore,\n      onOpen: async () => {\n        log('extension opened');\n        this._extensions.add(extension);\n        extension.updateWantList(this._getWantList());\n      },\n      onClose: async () => {\n        log('extension closed');\n        this._extensions.delete(extension);\n      },\n      onAbort: async () => {\n        log('extension aborted');\n        this._extensions.delete(extension);\n      },\n      onPush: async (blobChunk) => {\n        if (!this._downloadRequests.has(blobChunk.id)) {\n          return;\n        }\n        log('received', { blobChunk });\n        const meta = await this._params.blobStore.setChunk(blobChunk);\n        if (meta.state === BlobMeta.State.FULLY_PRESENT) {\n          this._downloadRequests.get(blobChunk.id)?.trigger.wake();\n          this._downloadRequests.delete(blobChunk.id);\n        } else {\n          invariant(meta.bitfield);\n          this._downloadRequests.get(blobChunk.id)!.want.bitfield = BitField.invert(meta.bitfield);\n        }\n\n        this._updateExtensionsWantList();\n        this._reconcileUploads();\n      },\n    });\n    return extension;\n  }\n\n  /**\n   * Notify extensions that a blob with the given id was added to the blob store.\n   */\n  async notifyBlobAdded(_id: Uint8Array): Promise<void> {\n    this._reconcileUploads();\n  }\n\n  private _getWantList(): WantList {\n    return {\n      blobs: Array.from(this._downloadRequests.values()).map((request) => request.want),\n    };\n  }\n\n  private _reconcileUploads(): void {\n    for (const extension of this._extensions) {\n      extension.reconcileUploads();\n    }\n  }\n\n  private _updateExtensionsWantList(): void {\n    for (const extension of this._extensions) {\n      extension.updateWantList(this._getWantList());\n    }\n  }\n}\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport path from 'node:path';\n\nimport { synchronized } from '@dxos/async';\nimport { subtleCrypto } from '@dxos/crypto';\nimport { invariant } from '@dxos/invariant';\nimport { PublicKey } from '@dxos/keys';\nimport { schema } from '@dxos/protocols/proto';\nimport { BlobMeta } from '@dxos/protocols/proto/dxos/echo/blob';\nimport { type BlobChunk } from '@dxos/protocols/proto/dxos/mesh/teleport/blobsync';\nimport { type Directory } from '@dxos/random-access-storage';\nimport { BitField, arrayToBuffer } from '@dxos/util';\n\nexport type GetOptions = {\n  offset?: number;\n  length?: number;\n};\n\nexport const DEFAULT_CHUNK_SIZE = 4096;\n\nconst BlobMetaCodec = schema.getCodecForType('dxos.echo.blob.BlobMeta');\n\nexport class BlobStore {\n  constructor(private readonly _directory: Directory) {}\n\n  @synchronized\n  async getMeta(id: Uint8Array): Promise<BlobMeta | undefined> {\n    return this._getMeta(id);\n  }\n\n  /**\n   * @throws If range is not available.\n   */\n  @synchronized\n  async get(id: Uint8Array, options: GetOptions = {}): Promise<Uint8Array> {\n    const metadata = await this._getMeta(id);\n\n    if (!metadata) {\n      throw new Error('Blob not available');\n    }\n\n    const { offset = 0, length = metadata.length } = options;\n\n    if (offset + length > metadata.length) {\n      throw new Error('Invalid range');\n    }\n\n    if (metadata.state === BlobMeta.State.FULLY_PRESENT) {\n      const file = this._getDataFile(id);\n      return file.read(offset, length);\n    } else if (options.offset === undefined && options.length === undefined) {\n      throw new Error('Blob not available');\n    }\n\n    const beginChunk = Math.floor(offset / metadata.chunkSize);\n    const endChunk = Math.ceil((offset + length) / metadata.chunkSize);\n\n    invariant(metadata.bitfield, 'Bitfield not present');\n    invariant(metadata.bitfield.length * 8 >= endChunk, 'Invalid bitfield length');\n\n    const present = BitField.count(metadata.bitfield, beginChunk, endChunk) === endChunk - beginChunk;\n\n    if (!present) {\n      throw new Error('Blob not available');\n    }\n\n    const file = this._getDataFile(id);\n    return file.read(offset, length);\n  }\n\n  @synchronized\n  async list(): Promise<BlobMeta[]> {\n    /*\n    Weird path formatting:\n\n    \"e9b9aa7a21c2c55a9eca333cd59975633157562ca0a0f4f243d4778f192c291e_meta\"\n    \"e9b9aa7a21c2c55a9eca333cd59975633157562ca0a0f4f243d4778f192c291e_data\"\n    \"5001de5a47191357c075aeee6451c4cc323f3a8ada24dd1191e83403608a38d5_meta\n     */\n    const files = new Set((await this._directory.list()).map((f) => f.split('_')[0]));\n\n    const res: BlobMeta[] = [];\n\n    for (const file of files) {\n      const id = PublicKey.from(file).asUint8Array();\n      const meta = await this._getMeta(id);\n      if (meta) {\n        res.push(meta);\n      }\n    }\n\n    return res;\n  }\n\n  @synchronized\n  async set(data: Uint8Array): Promise<BlobMeta> {\n    const id = new Uint8Array(await subtleCrypto.digest('SHA-256', data));\n    const bitfield = BitField.ones(data.length / DEFAULT_CHUNK_SIZE);\n\n    const meta: BlobMeta = {\n      id,\n      state: BlobMeta.State.FULLY_PRESENT,\n      length: data.length,\n      chunkSize: DEFAULT_CHUNK_SIZE,\n      bitfield,\n      created: new Date(),\n      updated: new Date(),\n    };\n\n    await this._getDataFile(id).write(0, arrayToBuffer(data));\n    await this._writeMeta(id, meta);\n    return meta;\n  }\n\n  // TODO(dmaretskyi): Optimize locking.\n  @synchronized\n  async setChunk(chunk: BlobChunk): Promise<BlobMeta> {\n    // Init metadata.\n    let meta = await this._getMeta(chunk.id);\n    if (!meta) {\n      invariant(chunk.totalLength, 'totalLength is not present');\n      meta = {\n        id: chunk.id,\n        state: BlobMeta.State.PARTIALLY_PRESENT,\n        length: chunk.totalLength,\n        chunkSize: chunk.chunkSize ?? DEFAULT_CHUNK_SIZE,\n        created: new Date(),\n      };\n      meta.bitfield = BitField.zeros(meta.length / meta.chunkSize);\n    }\n\n    if (chunk.chunkSize && chunk.chunkSize !== meta.chunkSize) {\n      throw new Error('Invalid chunk size');\n    }\n\n    invariant(meta.bitfield, 'Bitfield not present');\n    invariant(chunk.chunkOffset !== undefined, 'chunkOffset is not present');\n\n    // Write chunk.\n    await this._getDataFile(chunk.id).write(chunk.chunkOffset, arrayToBuffer(chunk.payload));\n\n    // Update bitfield.\n    BitField.set(meta.bitfield, Math.floor(chunk.chunkOffset / meta.chunkSize), true);\n\n    // Update metadata.\n    if (BitField.count(meta.bitfield, 0, meta.length) * meta.chunkSize >= meta.length) {\n      meta.state = BlobMeta.State.FULLY_PRESENT;\n    }\n    meta.updated = new Date();\n\n    await this._writeMeta(chunk.id, meta);\n\n    return meta;\n  }\n\n  private async _writeMeta(id: Uint8Array, meta: BlobMeta): Promise<void> {\n    const encoded = arrayToBuffer(BlobMetaCodec.encode(meta));\n    const data = Buffer.alloc(encoded.length + 4);\n    data.writeUInt32LE(encoded.length, 0);\n    encoded.copy(data, 4);\n\n    // Write metadata.\n    await this._getMetaFile(id).write(0, data);\n  }\n\n  private async _getMeta(id: Uint8Array): Promise<BlobMeta | undefined> {\n    const file = this._getMetaFile(id);\n    const size = (await file.stat()).size;\n    if (size === 0) {\n      return;\n    }\n    const data = await file.read(0, size);\n    const protoSize = data.readUInt32LE(0);\n    return BlobMetaCodec.decode(data.subarray(4, protoSize + 4));\n  }\n\n  private _getMetaFile(id: Uint8Array) {\n    return this._directory.getOrCreateFile(path.join(arrayToBuffer(id).toString('hex'), 'meta'));\n  }\n\n  private _getDataFile(id: Uint8Array) {\n    return this._directory.getOrCreateFile(path.join(arrayToBuffer(id).toString('hex'), 'data'));\n  }\n}\n"],
  "mappings": "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",
  "names": ["DeferredTask", "sleep", "synchronized", "Context", "invariant", "log", "RpcClosedError", "schema", "RpcExtension", "BitField", "MIN_WANT_LIST_UPDATE_INTERVAL", "process", "MAX_CONCURRENT_UPLOADS", "BlobSyncExtension", "_params", "exposed", "BlobSyncService", "getService", "requested", "timeout", "encodingOptions", "preserveAny", "_ctx", "onError", "err", "catch", "_lastWantListUpdate", "_localWantList", "blobs", "_updateWantList", "Date", "now", "disposed", "list", "rpc", "want", "_currentUploads", "_upload", "blobChunks", "_pickBlobChunks", "blobChunk", "push", "warn", "finally", "reconcileUploads", "remoteWantList", "onOpen", "context", "onClose", "dispose", "onAbort", "getHandlers", "wantList", "data", "onPush", "updateWantList", "schedule", "amount", "length", "shuffled", "sort", "Math", "random", "chunks", "header", "meta", "blobStore", "getMeta", "id", "bitfield", "chunkSize", "requestBitfield", "ones", "presentData", "and", "chunkIndices", "findIndexes", "idx", "chunkData", "get", "offset", "min", "totalLength", "chunkOffset", "payload", "trackLeaks", "Trigger", "Mutex", "cancelWithContext", "Context", "invariant", "PublicKey", "log", "BlobMeta", "BitField", "ComplexMap", "BlobSync", "_params", "_ctx", "Context", "_mutex", "Mutex", "_downloadRequests", "ComplexMap", "key", "PublicKey", "from", "toHex", "_extensions", "Set", "open", "close", "dispose", "download", "ctx", "id", "log", "request", "executeSynchronized", "existingRequest", "get", "counter", "meta", "blobStore", "getMeta", "trigger", "Trigger", "want", "chunkSize", "bitfield", "Uint8Array", "BitField", "invert", "state", "BlobMeta", "State", "FULLY_PRESENT", "wake", "set", "_updateExtensionsWantList", "onDispose", "delete", "cancelWithContext", "wait", "createExtension", "extension", "BlobSyncExtension", "onOpen", "add", "updateWantList", "_getWantList", "onClose", "onAbort", "onPush", "blobChunk", "has", "setChunk", "invariant", "_reconcileUploads", "notifyBlobAdded", "_id", "blobs", "Array", "values", "map", "reconcileUploads", "path", "synchronized", "subtleCrypto", "invariant", "PublicKey", "schema", "BlobMeta", "BitField", "arrayToBuffer", "DEFAULT_CHUNK_SIZE", "BlobMetaCodec", "getCodecForType", "BlobStore", "_directory", "getMeta", "id", "_getMeta", "get", "options", "metadata", "Error", "offset", "length", "state", "State", "FULLY_PRESENT", "file", "_getDataFile", "read", "undefined", "beginChunk", "Math", "floor", "chunkSize", "endChunk", "ceil", "bitfield", "present", "count", "list", "files", "Set", "map", "f", "split", "res", "from", "asUint8Array", "meta", "push", "set", "data", "Uint8Array", "digest", "ones", "created", "Date", "updated", "write", "_writeMeta", "setChunk", "chunk", "totalLength", "PARTIALLY_PRESENT", "zeros", "chunkOffset", "payload", "encoded", "encode", "Buffer", "alloc", "writeUInt32LE", "copy", "_getMetaFile", "size", "stat", "protoSize", "readUInt32LE", "decode", "subarray", "getOrCreateFile", "join", "toString"]
}
