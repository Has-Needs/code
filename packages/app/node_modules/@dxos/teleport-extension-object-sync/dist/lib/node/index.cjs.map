{
  "version": 3,
  "sources": ["../../../src/blob-sync-extension.ts", "../../../src/blob-sync.ts", "../../../src/blob-store.ts"],
  "sourcesContent": ["//\n\n//\n// Copyright 2023 DXOS.org\n//\n\nimport { DeferredTask, sleep, synchronized } from '@dxos/async';\nimport { Context } from '@dxos/context';\nimport { invariant } from '@dxos/invariant';\nimport { log } from '@dxos/log';\nimport { RpcClosedError } from '@dxos/protocols';\nimport { schema } from '@dxos/protocols/proto';\nimport { type BlobChunk, type BlobSyncService, type WantList } from '@dxos/protocols/proto/dxos/mesh/teleport/blobsync';\nimport { type ExtensionContext, RpcExtension } from '@dxos/teleport';\nimport { BitField } from '@dxos/util';\n\nimport { type BlobStore } from './blob-store';\n\nexport type BlobSyncExtensionParams = {\n  blobStore: BlobStore;\n  onOpen: () => Promise<void>;\n  onClose: () => Promise<void>;\n  onAbort: () => Promise<void>;\n  onPush: (data: BlobChunk) => Promise<void>;\n};\n\nconst MIN_WANT_LIST_UPDATE_INTERVAL = process.env.NODE_ENV === 'test' ? 5 : 500;\n\nconst MAX_CONCURRENT_UPLOADS = 20;\n\n/**\n * Manages replication between a set of feeds for a single teleport session.\n */\nexport class BlobSyncExtension extends RpcExtension<ServiceBundle, ServiceBundle> {\n  private readonly _ctx = new Context({ onError: (err) => log.catch(err) });\n\n  private _lastWantListUpdate = 0;\n  private _localWantList: WantList = { blobs: [] };\n\n  private readonly _updateWantList = new DeferredTask(this._ctx, async () => {\n    // Throttle want list updates.\n    if (this._lastWantListUpdate + MIN_WANT_LIST_UPDATE_INTERVAL > Date.now()) {\n      await sleep(this._lastWantListUpdate + MIN_WANT_LIST_UPDATE_INTERVAL - Date.now());\n      if (this._ctx.disposed) {\n        return;\n      }\n    }\n\n    log('want', { list: this._localWantList });\n    await this.rpc.BlobSyncService.want(this._localWantList);\n    this._lastWantListUpdate = Date.now();\n  });\n\n  private _currentUploads = 0;\n\n  private readonly _upload = new DeferredTask(this._ctx, async () => {\n    if (this._currentUploads >= MAX_CONCURRENT_UPLOADS) {\n      return;\n    }\n    const blobChunks = await this._pickBlobChunks(MAX_CONCURRENT_UPLOADS - this._currentUploads);\n    if (!blobChunks) {\n      return;\n    }\n    for (const blobChunk of blobChunks) {\n      if (this._ctx.disposed) {\n        break;\n      }\n\n      this._currentUploads++;\n\n      this.push(blobChunk)\n        .catch((err) => {\n          if (err instanceof RpcClosedError) {\n            return;\n          }\n          log.warn('push failed', { err });\n        })\n        .finally(() => {\n          this._currentUploads--;\n          this.reconcileUploads();\n        });\n    }\n  });\n\n  /**\n   * Set of id's remote peer wants.\n   */\n  public remoteWantList: WantList = { blobs: [] };\n\n  constructor(\n    private readonly _params: BlobSyncExtensionParams, // to not conflict with the base class\n  ) {\n    super({\n      exposed: {\n        BlobSyncService: schema.getService('dxos.mesh.teleport.blobsync.BlobSyncService'),\n      },\n      requested: {\n        BlobSyncService: schema.getService('dxos.mesh.teleport.blobsync.BlobSyncService'),\n      },\n      timeout: 20_000,\n      encodingOptions: {\n        preserveAny: true,\n      },\n    });\n  }\n\n  override async onOpen(context: ExtensionContext): Promise<void> {\n    log('open');\n    await super.onOpen(context);\n    await this._params.onOpen();\n  }\n\n  override async onClose(err?: Error | undefined): Promise<void> {\n    log('close');\n    await this._ctx.dispose();\n    await this._params.onClose();\n    await super.onClose(err);\n  }\n\n  override async onAbort(err?: Error | undefined): Promise<void> {\n    log('abort');\n    await this._ctx.dispose();\n    await this._params.onAbort();\n    await super.onAbort(err);\n  }\n\n  protected async getHandlers(): Promise<ServiceBundle> {\n    return {\n      BlobSyncService: {\n        want: async (wantList) => {\n          log('remote want', { remoteWantList: wantList });\n          this.remoteWantList = wantList;\n          this.reconcileUploads();\n        },\n        push: async (data) => {\n          log('received', { data });\n          await this._params.onPush(data);\n        },\n      },\n    };\n  }\n\n  @synchronized\n  async push(data: BlobChunk): Promise<void> {\n    if (this._ctx.disposed) {\n      return;\n    }\n    log('push', { data });\n    await this.rpc.BlobSyncService.push(data);\n  }\n\n  updateWantList(wantList: WantList): void {\n    if (this._ctx.disposed) {\n      return;\n    }\n    this._localWantList = wantList;\n    this._updateWantList.schedule();\n  }\n\n  reconcileUploads(): void {\n    if (this._ctx.disposed) {\n      return;\n    }\n    this._upload.schedule();\n  }\n\n  private async _pickBlobChunks(amount = 1): Promise<BlobChunk[] | void> {\n    if (this._ctx.disposed) {\n      return;\n    }\n\n    if (!this.remoteWantList.blobs || this.remoteWantList.blobs?.length === 0) {\n      return;\n    }\n\n    const shuffled = [...this.remoteWantList.blobs].sort(() => Math.random() - 0.5);\n\n    const chunks: BlobChunk[] = [];\n\n    for (const header of shuffled) {\n      const meta = await this._params.blobStore.getMeta(header.id);\n\n      if (!meta) {\n        // Skip this header\n        continue;\n      }\n      invariant(meta.bitfield);\n      invariant(meta.chunkSize);\n      invariant(meta.length);\n\n      if (header.chunkSize && header.chunkSize !== meta.chunkSize) {\n        log.warn('Invalid chunk size', { header, meta });\n        continue;\n      }\n\n      const requestBitfield = header.bitfield ?? BitField.ones(meta.length / meta.chunkSize);\n\n      const presentData = BitField.and(requestBitfield, meta.bitfield);\n      const chunkIndices = BitField.findIndexes(presentData).sort(() => Math.random() - 0.5);\n\n      for (const idx of chunkIndices) {\n        const chunkData = await this._params.blobStore.get(header.id, {\n          offset: idx * meta.chunkSize,\n          length: Math.min(meta.chunkSize, meta.length - idx * meta.chunkSize),\n        });\n        chunks.push({\n          id: header.id,\n          totalLength: meta.length,\n          chunkSize: meta.chunkSize,\n          chunkOffset: idx * meta.chunkSize,\n          payload: chunkData,\n        });\n\n        if (chunks.length >= amount) {\n          return chunks;\n        }\n      }\n    }\n\n    return chunks;\n  }\n}\n\ntype ServiceBundle = {\n  BlobSyncService: BlobSyncService;\n};\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { trackLeaks, Trigger, Mutex } from '@dxos/async';\nimport { cancelWithContext, Context } from '@dxos/context';\nimport { invariant } from '@dxos/invariant';\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { BlobMeta } from '@dxos/protocols/proto/dxos/echo/blob';\nimport { type WantList } from '@dxos/protocols/proto/dxos/mesh/teleport/blobsync';\nimport { BitField, ComplexMap } from '@dxos/util';\n\nimport { type BlobStore } from './blob-store';\nimport { BlobSyncExtension } from './blob-sync-extension';\n\nexport type BlobSyncParams = {\n  blobStore: BlobStore;\n};\n\ntype DownloadRequest = {\n  trigger: Trigger<void>;\n  counter: number;\n  want: WantList.Entry;\n};\n\n// TODO(dmaretskyi): Rename to blob-sync.\n@trackLeaks('open', 'close')\nexport class BlobSync {\n  private readonly _ctx = new Context();\n  private readonly _mutex = new Mutex();\n\n  private readonly _downloadRequests = new ComplexMap<Uint8Array, DownloadRequest>((key) =>\n    PublicKey.from(key).toHex(),\n  );\n\n  private readonly _extensions = new Set<BlobSyncExtension>();\n\n  constructor(private readonly _params: BlobSyncParams) {}\n\n  async open(): Promise<void> {}\n\n  async close(): Promise<void> {\n    await this._ctx.dispose();\n  }\n\n  /**\n   * Resolves when the object with the given id is fully downloaded in the blob store.\n   *\n   * @param id hex-encoded id of the object to download.\n   */\n  async download(ctx: Context, id: Uint8Array): Promise<void> {\n    log('download', { id });\n    const request = await this._mutex.executeSynchronized(async () => {\n      const existingRequest = this._downloadRequests.get(id);\n\n      if (existingRequest) {\n        existingRequest.counter++;\n        return existingRequest;\n      }\n\n      const meta = await this._params.blobStore.getMeta(id);\n      const request: DownloadRequest = {\n        trigger: new Trigger(),\n        counter: 1,\n        want: {\n          id,\n          chunkSize: meta?.chunkSize,\n          bitfield: meta?.bitfield && Uint8Array.from(BitField.invert(meta.bitfield)),\n        },\n      };\n\n      // Check if the object is already fully downloaded.\n      if (meta?.state === BlobMeta.State.FULLY_PRESENT) {\n        request.trigger.wake();\n      } else {\n        this._downloadRequests.set(id, request);\n        this._updateExtensionsWantList();\n      }\n\n      return request;\n    });\n\n    ctx?.onDispose(() =>\n      this._mutex.executeSynchronized(async () => {\n        // Remove request if context is disposed and nobody else requests it.\n        const request = this._downloadRequests.get(id);\n        if (!request) {\n          return;\n        }\n        if (--request.counter === 0) {\n          this._downloadRequests.delete(id);\n        }\n        this._updateExtensionsWantList();\n      }),\n    );\n\n    return ctx ? cancelWithContext(ctx, request.trigger.wait()) : request.trigger.wait();\n  }\n\n  createExtension(): BlobSyncExtension {\n    const extension = new BlobSyncExtension({\n      blobStore: this._params.blobStore,\n      onOpen: async () => {\n        log('extension opened');\n        this._extensions.add(extension);\n        extension.updateWantList(this._getWantList());\n      },\n      onClose: async () => {\n        log('extension closed');\n        this._extensions.delete(extension);\n      },\n      onAbort: async () => {\n        log('extension aborted');\n        this._extensions.delete(extension);\n      },\n      onPush: async (blobChunk) => {\n        if (!this._downloadRequests.has(blobChunk.id)) {\n          return;\n        }\n        log('received', { blobChunk });\n        const meta = await this._params.blobStore.setChunk(blobChunk);\n        if (meta.state === BlobMeta.State.FULLY_PRESENT) {\n          this._downloadRequests.get(blobChunk.id)?.trigger.wake();\n          this._downloadRequests.delete(blobChunk.id);\n        } else {\n          invariant(meta.bitfield);\n          this._downloadRequests.get(blobChunk.id)!.want.bitfield = BitField.invert(meta.bitfield);\n        }\n\n        this._updateExtensionsWantList();\n        this._reconcileUploads();\n      },\n    });\n    return extension;\n  }\n\n  /**\n   * Notify extensions that a blob with the given id was added to the blob store.\n   */\n  async notifyBlobAdded(_id: Uint8Array): Promise<void> {\n    this._reconcileUploads();\n  }\n\n  private _getWantList(): WantList {\n    return {\n      blobs: Array.from(this._downloadRequests.values()).map((request) => request.want),\n    };\n  }\n\n  private _reconcileUploads(): void {\n    for (const extension of this._extensions) {\n      extension.reconcileUploads();\n    }\n  }\n\n  private _updateExtensionsWantList(): void {\n    for (const extension of this._extensions) {\n      extension.updateWantList(this._getWantList());\n    }\n  }\n}\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport path from 'node:path';\n\nimport { synchronized } from '@dxos/async';\nimport { subtleCrypto } from '@dxos/crypto';\nimport { invariant } from '@dxos/invariant';\nimport { PublicKey } from '@dxos/keys';\nimport { schema } from '@dxos/protocols/proto';\nimport { BlobMeta } from '@dxos/protocols/proto/dxos/echo/blob';\nimport { type BlobChunk } from '@dxos/protocols/proto/dxos/mesh/teleport/blobsync';\nimport { type Directory } from '@dxos/random-access-storage';\nimport { BitField, arrayToBuffer } from '@dxos/util';\n\nexport type GetOptions = {\n  offset?: number;\n  length?: number;\n};\n\nexport const DEFAULT_CHUNK_SIZE = 4096;\n\nconst BlobMetaCodec = schema.getCodecForType('dxos.echo.blob.BlobMeta');\n\nexport class BlobStore {\n  constructor(private readonly _directory: Directory) {}\n\n  @synchronized\n  async getMeta(id: Uint8Array): Promise<BlobMeta | undefined> {\n    return this._getMeta(id);\n  }\n\n  /**\n   * @throws If range is not available.\n   */\n  @synchronized\n  async get(id: Uint8Array, options: GetOptions = {}): Promise<Uint8Array> {\n    const metadata = await this._getMeta(id);\n\n    if (!metadata) {\n      throw new Error('Blob not available');\n    }\n\n    const { offset = 0, length = metadata.length } = options;\n\n    if (offset + length > metadata.length) {\n      throw new Error('Invalid range');\n    }\n\n    if (metadata.state === BlobMeta.State.FULLY_PRESENT) {\n      const file = this._getDataFile(id);\n      return file.read(offset, length);\n    } else if (options.offset === undefined && options.length === undefined) {\n      throw new Error('Blob not available');\n    }\n\n    const beginChunk = Math.floor(offset / metadata.chunkSize);\n    const endChunk = Math.ceil((offset + length) / metadata.chunkSize);\n\n    invariant(metadata.bitfield, 'Bitfield not present');\n    invariant(metadata.bitfield.length * 8 >= endChunk, 'Invalid bitfield length');\n\n    const present = BitField.count(metadata.bitfield, beginChunk, endChunk) === endChunk - beginChunk;\n\n    if (!present) {\n      throw new Error('Blob not available');\n    }\n\n    const file = this._getDataFile(id);\n    return file.read(offset, length);\n  }\n\n  @synchronized\n  async list(): Promise<BlobMeta[]> {\n    /*\n    Weird path formatting:\n\n    \"e9b9aa7a21c2c55a9eca333cd59975633157562ca0a0f4f243d4778f192c291e_meta\"\n    \"e9b9aa7a21c2c55a9eca333cd59975633157562ca0a0f4f243d4778f192c291e_data\"\n    \"5001de5a47191357c075aeee6451c4cc323f3a8ada24dd1191e83403608a38d5_meta\n     */\n    const files = new Set((await this._directory.list()).map((f) => f.split('_')[0]));\n\n    const res: BlobMeta[] = [];\n\n    for (const file of files) {\n      const id = PublicKey.from(file).asUint8Array();\n      const meta = await this._getMeta(id);\n      if (meta) {\n        res.push(meta);\n      }\n    }\n\n    return res;\n  }\n\n  @synchronized\n  async set(data: Uint8Array): Promise<BlobMeta> {\n    const id = new Uint8Array(await subtleCrypto.digest('SHA-256', data));\n    const bitfield = BitField.ones(data.length / DEFAULT_CHUNK_SIZE);\n\n    const meta: BlobMeta = {\n      id,\n      state: BlobMeta.State.FULLY_PRESENT,\n      length: data.length,\n      chunkSize: DEFAULT_CHUNK_SIZE,\n      bitfield,\n      created: new Date(),\n      updated: new Date(),\n    };\n\n    await this._getDataFile(id).write(0, arrayToBuffer(data));\n    await this._writeMeta(id, meta);\n    return meta;\n  }\n\n  // TODO(dmaretskyi): Optimize locking.\n  @synchronized\n  async setChunk(chunk: BlobChunk): Promise<BlobMeta> {\n    // Init metadata.\n    let meta = await this._getMeta(chunk.id);\n    if (!meta) {\n      invariant(chunk.totalLength, 'totalLength is not present');\n      meta = {\n        id: chunk.id,\n        state: BlobMeta.State.PARTIALLY_PRESENT,\n        length: chunk.totalLength,\n        chunkSize: chunk.chunkSize ?? DEFAULT_CHUNK_SIZE,\n        created: new Date(),\n      };\n      meta.bitfield = BitField.zeros(meta.length / meta.chunkSize);\n    }\n\n    if (chunk.chunkSize && chunk.chunkSize !== meta.chunkSize) {\n      throw new Error('Invalid chunk size');\n    }\n\n    invariant(meta.bitfield, 'Bitfield not present');\n    invariant(chunk.chunkOffset !== undefined, 'chunkOffset is not present');\n\n    // Write chunk.\n    await this._getDataFile(chunk.id).write(chunk.chunkOffset, arrayToBuffer(chunk.payload));\n\n    // Update bitfield.\n    BitField.set(meta.bitfield, Math.floor(chunk.chunkOffset / meta.chunkSize), true);\n\n    // Update metadata.\n    if (BitField.count(meta.bitfield, 0, meta.length) * meta.chunkSize >= meta.length) {\n      meta.state = BlobMeta.State.FULLY_PRESENT;\n    }\n    meta.updated = new Date();\n\n    await this._writeMeta(chunk.id, meta);\n\n    return meta;\n  }\n\n  private async _writeMeta(id: Uint8Array, meta: BlobMeta): Promise<void> {\n    const encoded = arrayToBuffer(BlobMetaCodec.encode(meta));\n    const data = Buffer.alloc(encoded.length + 4);\n    data.writeUInt32LE(encoded.length, 0);\n    encoded.copy(data, 4);\n\n    // Write metadata.\n    await this._getMetaFile(id).write(0, data);\n  }\n\n  private async _getMeta(id: Uint8Array): Promise<BlobMeta | undefined> {\n    const file = this._getMetaFile(id);\n    const size = (await file.stat()).size;\n    if (size === 0) {\n      return;\n    }\n    const data = await file.read(0, size);\n    const protoSize = data.readUInt32LE(0);\n    return BlobMetaCodec.decode(data.subarray(4, protoSize + 4));\n  }\n\n  private _getMetaFile(id: Uint8Array) {\n    return this._directory.getOrCreateFile(path.join(arrayToBuffer(id).toString('hex'), 'meta'));\n  }\n\n  private _getDataFile(id: Uint8Array) {\n    return this._directory.getOrCreateFile(path.join(arrayToBuffer(id).toString('hex'), 'data'));\n  }\n}\n"],
  "mappings": "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",
  "names": ["import_async", "import_context", "import_invariant", "import_log", "import_util", "import_keys", "import_proto", "import_blob", "MIN_WANT_LIST_UPDATE_INTERVAL", "process", "env", "NODE_ENV", "MAX_CONCURRENT_UPLOADS", "BlobSyncExtension", "RpcExtension", "_params", "exposed", "BlobSyncService", "schema", "getService", "requested", "timeout", "encodingOptions", "preserveAny", "_ctx", "Context", "onError", "err", "log", "catch", "_lastWantListUpdate", "_localWantList", "blobs", "_updateWantList", "DeferredTask", "Date", "now", "sleep", "disposed", "list", "rpc", "want", "_currentUploads", "_upload", "blobChunks", "_pickBlobChunks", "blobChunk", "push", "RpcClosedError", "warn", "finally", "reconcileUploads", "remoteWantList", "onOpen", "context", "onClose", "dispose", "onAbort", "getHandlers", "wantList", "data", "onPush", "updateWantList", "schedule", "amount", "length", "shuffled", "sort", "Math", "random", "chunks", "header", "meta", "blobStore", "getMeta", "id", "invariant", "bitfield", "chunkSize", "requestBitfield", "BitField", "ones", "presentData", "and", "chunkIndices", "findIndexes", "idx", "chunkData", "get", "offset", "min", "totalLength", "chunkOffset", "payload", "BlobSync", "_mutex", "Mutex", "_downloadRequests", "ComplexMap", "key", "PublicKey", "from", "toHex", "_extensions", "Set", "open", "close", "download", "ctx", "request", "executeSynchronized", "existingRequest", "counter", "trigger", "Trigger", "Uint8Array", "invert", "state", "BlobMeta", "State", "FULLY_PRESENT", "wake", "set", "_updateExtensionsWantList", "onDispose", "delete", "cancelWithContext", "wait", "createExtension", "extension", "add", "_getWantList", "has", "setChunk", "_reconcileUploads", "notifyBlobAdded", "_id", "Array", "values", "map", "DEFAULT_CHUNK_SIZE", "BlobMetaCodec", "getCodecForType", "BlobStore", "_directory", "_getMeta", "options", "metadata", "Error", "file", "_getDataFile", "read", "undefined", "beginChunk", "floor", "endChunk", "ceil", "present", "count", "files", "f", "split", "res", "asUint8Array", "subtleCrypto", "digest", "created", "updated", "write", "arrayToBuffer", "_writeMeta", "chunk", "PARTIALLY_PRESENT", "zeros", "encoded", "encode", "Buffer", "alloc", "writeUInt32LE", "copy", "_getMetaFile", "size", "stat", "protoSize", "readUInt32LE", "decode", "subarray", "getOrCreateFile", "path", "join", "toString"]
}
