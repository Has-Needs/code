import { createRequire } from 'node:module';const require = createRequire(import.meta.url);

// packages/sdk/config/src/plugin/definitions.ts
import yaml from "js-yaml";
import { execSync } from "node:child_process";
import { readFileSync } from "node:fs";
import { resolve } from "node:path";
import pkgUp from "pkg-up";
import { log } from "@dxos/log";
import { setDeep as setDeep2 } from "@dxos/util";

// packages/sdk/config/src/config.ts
import { boolean } from "boolean";
import defaultsDeep from "lodash.defaultsdeep";
import isMatch from "lodash.ismatch";
import { InvalidConfigError } from "@dxos/protocols";
import { schema } from "@dxos/protocols/proto";
import { trace } from "@dxos/tracing";
import { getDeep, setDeep } from "@dxos/util";
function _ts_decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var configRootType = schema.getCodecForType("dxos.config.Config");
var mapFromKeyValues = (spec, values) => {
  const config = {};
  for (const [key, { path, type }] of Object.entries(spec)) {
    let value = values[key];
    if (value !== void 0) {
      if (type) {
        switch (type) {
          case "boolean": {
            value = boolean(value);
            break;
          }
          case "number": {
            value = Number(value);
            break;
          }
          case "string": {
            break;
          }
          case "json": {
            value = value ? JSON.parse(value) : null;
            break;
          }
          default: {
            throw new Error(`Invalid type: ${type}`);
          }
        }
      }
      setDeep(config, path.split("."), value);
    }
  }
  return config;
};
var validateConfig = (config) => {
  if (!("version" in config)) {
    throw new InvalidConfigError("Version not specified");
  }
  if (config?.version !== 1) {
    throw new InvalidConfigError(`Invalid config version: ${config.version}`);
  }
  const error = configRootType.protoType.verify(config);
  if (error) {
    throw new InvalidConfigError(error);
  }
  return config;
};
var ConfigResource = Symbol.for("dxos.resource.Config");
var Config = class {
  /**
  * Creates an immutable instance.
  * @constructor
  */
  constructor(config = {}, ...objects) {
    this._config = validateConfig(defaultsDeep(config, ...objects, {
      version: 1
    }));
  }
  /**
  * Returns an immutable config JSON object.
  */
  get values() {
    return this._config;
  }
  /**
  * Returns the given config property.
  *
  * @param key A key in the config object. Can be a nested property with keys separated by dots: 'services.signal.server'.
  * @param defaultValue Default value to return if option is not present in the config.
  * @returns The config value or undefined if the option is not present.
  */
  get(key, defaultValue) {
    return getDeep(this._config, key.split(".")) ?? defaultValue;
  }
  /**
  * Get unique key.
  */
  find(path, test) {
    const values = getDeep(this._config, path.split("."));
    if (!Array.isArray(values)) {
      return;
    }
    return values.find((value) => isMatch(value, test));
  }
  /**
  * Returns the given config property or throw if it doesn't exist.
  *
  * @param key A key in the config object. Can be a nested property with keys separated by dots: 'services.signal.server'.
  */
  getOrThrow(key) {
    const value = getDeep(this._config, key.split("."));
    if (!value) {
      throw new Error(`Config option not present: ${key}`);
    }
    return value;
  }
};
Config = _ts_decorate([
  trace.resource({
    annotation: ConfigResource
  })
], Config);

// packages/sdk/config/src/plugin/definitions.ts
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/sdk/config/src/plugin/definitions.ts";
var CWD = process.cwd();
var definitions = ({ configPath, envPath, devPath, mode = process.env.NODE_ENV, publicUrl = "", env }) => {
  const KEYS_TO_FILE = {
    __CONFIG_DEFAULTS__: configPath?.length ? configPath : resolve(CWD, "dx.yml"),
    __CONFIG_ENVS__: envPath?.length ? envPath : resolve(CWD, "dx-env.yml")
  };
  if (mode !== "production") {
    KEYS_TO_FILE.__CONFIG_LOCAL__ = devPath ?? resolve(CWD, "dx-local.yml");
  }
  return Object.entries(KEYS_TO_FILE).reduce((prev, [key, value]) => {
    let content = {};
    try {
      content = yaml.load(readFileSync(value, "utf-8"));
      if (key === "__CONFIG_ENVS__") {
        content = mapFromKeyValues(content, process.env);
      }
      if (key === "__CONFIG_DEFAULTS__") {
        Object.entries(process.env).forEach(([key2, value2]) => {
          if (key2.startsWith("DX_") || env?.includes(key2)) {
            setDeep2(content, [
              "runtime",
              "app",
              "env",
              key2
            ], value2);
          }
        });
        try {
          const timestamp = (/* @__PURE__ */ new Date()).toISOString();
          const commitHash = process.env.DX_COMMIT_HASH ?? execSync("git rev-parse --short HEAD", {
            encoding: "utf-8"
          }).replace("\n", "");
          const packagePath = pkgUp.sync();
          const packageJson = packagePath && JSON.parse(readFileSync(packagePath, "utf-8"));
          setDeep2(content, [
            "runtime",
            "app",
            "build",
            "timestamp"
          ], timestamp);
          setDeep2(content, [
            "runtime",
            "app",
            "build",
            "commitHash"
          ], commitHash);
          setDeep2(content, [
            "runtime",
            "app",
            "build",
            "version"
          ], packageJson?.version);
        } catch {
        }
      }
    } catch (err) {
      if (err.message.includes("YAMLException")) {
        log.error(`Failed to parse file ${value}:`, err, {
          F: __dxlog_file,
          L: 71,
          S: void 0,
          C: (f, a) => f(...a)
        });
      } else {
        log(`Failed to load file ${value}:`, err, {
          F: __dxlog_file,
          L: 73,
          S: void 0,
          C: (f, a) => f(...a)
        });
      }
      if (key === "__CONFIG_DEFAULTS__") {
        throw new Error(`Failed to load default config file from ${value}`);
      }
    }
    return {
      ...prev,
      [key]: content
    };
  }, {
    __DXOS_CONFIG__: {
      dynamic: mode === "production",
      publicUrl
    },
    __CONFIG_DEFAULTS__: {},
    __CONFIG_ENVS__: {},
    __CONFIG_LOCAL__: {}
  });
};

export {
  definitions
};
//# sourceMappingURL=chunk-PAFU3TJI.mjs.map
