import { Event, type CleanupFn } from '@dxos/async';
import { type QueryAST } from '@dxos/echo-protocol';
import { type AnyEchoObject } from '@dxos/echo-schema';
import { type PublicKey, type SpaceId } from '@dxos/keys';
import { type Query } from './api';
export type Sort<T extends AnyEchoObject> = (a: T, b: T) => -1 | 0 | 1;
export type QueryResultEntry<T extends AnyEchoObject = AnyEchoObject> = {
    id: string;
    spaceId: SpaceId;
    /** @deprecated Use spaceId */
    spaceKey: PublicKey;
    /**
     * May not be present for remote results.
     */
    object?: T;
    match?: {
        /**
         * Higher means better match.
         */
        rank: number;
    };
    /**
     * Query resolution metadata.
     */
    resolution?: {
        source: 'remote' | 'local' | 'index';
        /**
         * Query resolution time in milliseconds.
         */
        time: number;
    };
};
export type OneShotQueryResult<T extends AnyEchoObject = AnyEchoObject> = {
    results: QueryResultEntry<T>[];
    objects: T[];
};
export interface QueryContext<T extends AnyEchoObject = AnyEchoObject> {
    getResults(): QueryResultEntry<T>[];
    changed: Event<void>;
    /**
     * One-shot query.
     */
    run(query: QueryAST.Query, opts?: QueryRunOptions): Promise<QueryResultEntry<T>[]>;
    /**
     * Set the filter and trigger continuous updates.
     */
    update(query: QueryAST.Query): void;
    /**
     * Start creating query sources and firing events.
     *
     * `start` and `stop` are re-entrant.
     */
    start(): void;
    /**
     * Clear any resources associated with the query.
     *
     * `start` and `stop` are re-entrant.
     */
    stop(): void;
}
export type QuerySubscriptionOptions = {
    /**
     * Fire the callback immediately.
     */
    fire?: boolean;
};
export type QueryRunOptions = {
    timeout?: number;
};
/**
 * Predicate based query.
 */
export declare class QueryResult<T extends AnyEchoObject = AnyEchoObject> {
    private readonly _queryContext;
    private readonly _query;
    private readonly _signal;
    private readonly _event;
    private readonly _diagnostic;
    private _isActive;
    private _resultCache?;
    private _objectCache?;
    private _subscribers;
    constructor(_queryContext: QueryContext<T>, query: Query<T>);
    get query(): Query<T>;
    get results(): QueryResultEntry<T>[];
    get objects(): T[];
    /**
     * Execute the query once and return the results.
     * Does not subscribe to updates.
     */
    run(timeout?: {
        timeout?: number;
    }): Promise<OneShotQueryResult<T>>;
    first(opts?: {
        timeout?: number;
    }): Promise<T>;
    /**
     * Runs the query synchronously and returns all results.
     * WARNING: This method will only return the data already cached and may return incomplete results.
     * Use `this.run()` for a complete list of results stored on-disk.
     */
    runSync(): QueryResultEntry<T>[];
    /**
     * Subscribe to query results.
     * Updates only when the identity or the order of the objects changes.
     * Does not update when the object properties change.
     */
    subscribe(callback?: (query: QueryResult<T>) => void, opts?: QuerySubscriptionOptions): CleanupFn;
    private _ensureCachePresent;
    /**
     * @returns true if the result cache was updated.
     */
    private _recomputeResult;
    private _uniqueObjects;
    private _handleQueryLifecycle;
    private _start;
    private _stop;
    private _checkQueryIsRunning;
}
//# sourceMappingURL=query-result.d.ts.map