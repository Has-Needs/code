{
  "version": 3,
  "sources": ["../../../src/guarded-scope.ts", "../../../src/query/query-result.ts", "../../../src/query/api.ts", "../../../src/query/util.ts", "../../../src/query/graph-query-context.ts", "../../../src/core-db/types.ts", "../../../src/core-db/object-core.ts", "../../../src/core-db/doc-semaphore.ts", "../../../src/automerge/doc-handle-proxy.ts", "../../../src/automerge/repo-proxy.ts", "../../../src/core-db/core-database.ts", "../../../src/core-db/automerge-doc-loader.ts", "../../../src/core-db/core-database-query-context.ts", "../../../src/core-db/util.ts", "../../../src/echo-handler/echo-handler.ts", "../../../src/echo-handler/devtools-formatter.ts", "../../../src/echo-handler/echo-array.ts", "../../../src/echo-handler/echo-proxy-target.ts", "../../../src/echo-handler/clone.ts", "../../../src/echo-handler/edit-history.ts", "../../../src/echo-handler/relations.ts", "../../../src/echo-handler/util.ts", "../../../src/echo-handler/doc-accessor.ts", "../../../src/echo-handler/version.ts", "../../../src/echo-handler/subscription.ts", "../../../src/hypergraph.ts", "../../../src/proxy-db/echo-schema-registry.ts", "../../../src/proxy-db/schema-registry-prepared-query.ts", "../../../src/proxy-db/database.ts", "../../../src/proxy-db/load-object.ts", "../../../src/proxy-db/object-migration.ts", "../../../src/queue/memory-queue.ts", "../../../src/queue/queue.ts", "../../../src/queue/queue-factory.ts", "../../../src/queue/queue-service.ts", "../../../src/queue/types.ts", "../../../src/client/echo-client.ts", "../../../src/client/index-query-source-provider.ts"],
  "sourcesContent": ["//\n// Copyright 2024 DXOS.org\n//\n\nimport { registerSignalsRuntime, type GenericSignal } from '@dxos/echo-signals/runtime';\n\n//\n// This module is used to guard against ECHO subscribing to signals within it's internals.\n//\n\nlet areSignalsProhibited = false;\n\nlet inUntrackedScope = false;\n\nclass GuardSignal implements GenericSignal {\n  constructor(public readonly debugInfo: unknown) {}\n\n  notifyRead(): void {\n    // Separate if statements so it's possible to place a debugger breakpoint on `!inUntrackedScope` condition.\n    if (inUntrackedScope) {\n      return;\n    }\n\n    if (areSignalsProhibited) {\n      throw new Error('Signal read is prohibited in this scope');\n    }\n  }\n\n  notifyWrite(): void {\n    // Separate if statements so it's possible to place a debugger breakpoint on `!inUntrackedScope` condition.\n    if (inUntrackedScope) {\n      return;\n    }\n\n    if (areSignalsProhibited) {\n      throw new Error('Signal write is prohibited in this scope');\n    }\n  }\n}\n\nregisterSignalsRuntime({\n  createSignal: (debugInfo) => new GuardSignal(debugInfo),\n  batch: (cb) => {\n    cb();\n  },\n  untracked: (cb) => {\n    const prev = inUntrackedScope;\n    try {\n      inUntrackedScope = true;\n      return cb();\n    } finally {\n      inUntrackedScope = prev;\n    }\n  },\n});\n\n/**\n * Prohibit signal actions within the given scope.\n */\nexport const prohibitSignalActions = <T>(cb: () => T) => {\n  try {\n    areSignalsProhibited = true;\n    return cb();\n  } finally {\n    areSignalsProhibited = false;\n  }\n};\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { Event, type CleanupFn } from '@dxos/async';\nimport { StackTrace } from '@dxos/debug';\nimport { type QueryAST } from '@dxos/echo-protocol';\nimport { type AnyEchoObject } from '@dxos/echo-schema';\nimport { compositeRuntime } from '@dxos/echo-signals/runtime';\nimport { invariant } from '@dxos/invariant';\nimport { type PublicKey, type SpaceId } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { trace } from '@dxos/tracing';\nimport { isNonNullable } from '@dxos/util';\n\nimport { type Query } from './api';\nimport { prohibitSignalActions } from '../guarded-scope';\n\n// TODO(burdon): Multi-sort option.\nexport type Sort<T extends AnyEchoObject> = (a: T, b: T) => -1 | 0 | 1;\n\nexport type QueryResultEntry<T extends AnyEchoObject = AnyEchoObject> = {\n  id: string;\n\n  spaceId: SpaceId;\n\n  /** @deprecated Use spaceId */\n  spaceKey: PublicKey;\n\n  /**\n   * May not be present for remote results.\n   */\n  object?: T;\n\n  match?: {\n    // TODO(dmaretskyi): text positional info.\n\n    /**\n     * Higher means better match.\n     */\n    rank: number;\n  };\n\n  /**\n   * Query resolution metadata.\n   */\n  // TODO(dmaretskyi): Rename to meta?\n  resolution?: {\n    // TODO(dmaretskyi): Make this more generic.\n    source: 'remote' | 'local' | 'index';\n\n    /**\n     * Query resolution time in milliseconds.\n     */\n    time: number;\n  };\n};\n\nexport type OneShotQueryResult<T extends AnyEchoObject = AnyEchoObject> = {\n  results: QueryResultEntry<T>[];\n  objects: T[];\n};\n\nexport interface QueryContext<T extends AnyEchoObject = AnyEchoObject> {\n  getResults(): QueryResultEntry<T>[];\n\n  // TODO(dmaretskyi): Update info?\n  changed: Event<void>;\n\n  /**\n   * One-shot query.\n   */\n  run(query: QueryAST.Query, opts?: QueryRunOptions): Promise<QueryResultEntry<T>[]>;\n\n  /**\n   * Set the filter and trigger continuous updates.\n   */\n  update(query: QueryAST.Query): void;\n\n  /**\n   * Start creating query sources and firing events.\n   *\n   * `start` and `stop` are re-entrant.\n   */\n  // TODO(dmaretskyi): Make async.\n  start(): void;\n\n  /**\n   * Clear any resources associated with the query.\n   *\n   * `start` and `stop` are re-entrant.\n   */\n  // TODO(dmaretskyi): Make async.\n  stop(): void;\n}\n\nexport type QuerySubscriptionOptions = {\n  /**\n   * Fire the callback immediately.\n   */\n  fire?: boolean;\n};\n\nexport type QueryRunOptions = {\n  timeout?: number;\n};\n\n/**\n * Predicate based query.\n */\nexport class QueryResult<T extends AnyEchoObject = AnyEchoObject> {\n  private readonly _query: Query<T>;\n  private readonly _signal = compositeRuntime.createSignal();\n  private readonly _event = new Event<QueryResult<T>>();\n  private readonly _diagnostic: QueryDiagnostic;\n\n  private _isActive = false;\n  private _resultCache?: QueryResultEntry<T>[] = undefined;\n  private _objectCache?: T[] = undefined;\n  private _subscribers: number = 0;\n\n  constructor(\n    private readonly _queryContext: QueryContext<T>,\n    query: Query<T>,\n  ) {\n    this._query = query;\n\n    this._queryContext.changed.on(() => {\n      if (this._recomputeResult()) {\n        // Clear `prohibitSignalActions` to allow the signal to be emitted.\n        compositeRuntime.untracked(() => {\n          this._event.emit(this);\n          this._signal.notifyWrite();\n        });\n      }\n    });\n    this._queryContext.update(query.ast);\n\n    this._diagnostic = {\n      isActive: this._isActive,\n      filter: JSON.stringify(this._query),\n      creationStack: new StackTrace(),\n    };\n    QUERIES.add(this._diagnostic);\n\n    log('construct', { filter: this._query.ast });\n  }\n\n  get query(): Query<T> {\n    return this._query;\n  }\n\n  get results(): QueryResultEntry<T>[] {\n    this._checkQueryIsRunning();\n    this._signal.notifyRead();\n    this._ensureCachePresent();\n    return this._resultCache!;\n  }\n\n  get objects(): T[] {\n    this._checkQueryIsRunning();\n    this._signal.notifyRead();\n    this._ensureCachePresent();\n    return this._objectCache!;\n  }\n\n  /**\n   * Execute the query once and return the results.\n   * Does not subscribe to updates.\n   */\n  async run(timeout: { timeout?: number } = { timeout: 30_000 }): Promise<OneShotQueryResult<T>> {\n    const filteredResults = await this._queryContext.run(this._query.ast, { timeout: timeout.timeout });\n\n    return {\n      results: filteredResults,\n      objects: this._uniqueObjects(filteredResults),\n    };\n  }\n\n  async first(opts?: { timeout?: number }): Promise<T> {\n    const { objects } = await this.run(opts);\n    if (objects.length === 0) {\n      throw new Error('No objects found');\n    }\n\n    return objects[0];\n  }\n\n  /**\n   * Runs the query synchronously and returns all results.\n   * WARNING: This method will only return the data already cached and may return incomplete results.\n   * Use `this.run()` for a complete list of results stored on-disk.\n   */\n  runSync(): QueryResultEntry<T>[] {\n    this._ensureCachePresent();\n    return this._resultCache!;\n  }\n\n  /**\n   * Subscribe to query results.\n   * Updates only when the identity or the order of the objects changes.\n   * Does not update when the object properties change.\n   */\n  // TODO(burdon): Change to SubscriptionHandle (make uniform).\n  subscribe(callback?: (query: QueryResult<T>) => void, opts?: QuerySubscriptionOptions): CleanupFn {\n    invariant(!(!callback && opts?.fire), 'Cannot fire without a callback.');\n\n    log('subscribe', { filter: this._query.ast, active: this._isActive });\n    this._subscribers++;\n    const unsubscribeFromEvent = callback ? this._event.on(callback) : undefined;\n    this._handleQueryLifecycle();\n\n    const unsubscribe = () => {\n      log('unsubscribe', { filter: this._query.ast, active: this._isActive });\n      this._subscribers--;\n      unsubscribeFromEvent?.();\n      this._handleQueryLifecycle();\n    };\n\n    if (callback && opts?.fire) {\n      try {\n        callback(this);\n      } catch (err) {\n        unsubscribe();\n        throw err;\n      }\n    }\n\n    return unsubscribe;\n  }\n\n  private _ensureCachePresent(): void {\n    if (!this._resultCache) {\n      prohibitSignalActions(() => {\n        // TODO(dmaretskyi): Clean up getters in the internal signals so they don't use the Proxy API and don't hit the signals.\n        compositeRuntime.untracked(() => {\n          this._recomputeResult();\n        });\n      });\n    }\n  }\n\n  /**\n   * @returns true if the result cache was updated.\n   */\n  private _recomputeResult(): boolean {\n    // TODO(dmaretskyi): Make results unique too.\n    const results = this._queryContext.getResults();\n    const objects = this._uniqueObjects(results);\n\n    const changed =\n      !this._objectCache ||\n      this._objectCache.length !== objects.length ||\n      this._objectCache.some((obj, index) => obj.id !== objects[index].id);\n\n    log('recomputeResult', {\n      old: this._objectCache?.map((obj) => obj.id),\n      new: objects.map((obj) => obj.id),\n      changed,\n    });\n\n    this._resultCache = results;\n    this._objectCache = objects;\n    return changed;\n  }\n\n  private _uniqueObjects(results: QueryResultEntry<T>[]): T[] {\n    const seen = new Set<unknown>();\n    return results\n      .map((result) => result.object)\n      .filter(isNonNullable)\n      .filter((object: any) => {\n        // Assuming objects have `id` property we can use to dedup.\n        if (object.id == null) {\n          return true;\n        }\n\n        if (seen.has(object.id)) {\n          return false;\n        }\n        seen.add(object.id);\n        return true;\n      });\n  }\n\n  private _handleQueryLifecycle(): void {\n    if (this._subscribers === 0 && this._isActive) {\n      log('stop query', { filter: this._query.ast });\n      this._stop();\n    } else if (this._subscribers > 0 && !this._isActive) {\n      log('start query', { filter: this._query.ast });\n      this._start();\n    }\n  }\n\n  private _start(): void {\n    this._isActive = true;\n    this._queryContext.start();\n    this._diagnostic.isActive = true;\n  }\n\n  private _stop(): void {\n    this._queryContext.stop();\n    this._isActive = false;\n    this._diagnostic.isActive = false;\n  }\n\n  private _checkQueryIsRunning(): void {\n    if (!this._isActive) {\n      throw new Error(\n        'Query must have at least 1 subscriber for `.objects` and `.results` to be used. Use query.run() for single-use result retrieval.',\n      );\n    }\n  }\n}\n\n// NOTE: Make sure this doesn't keep references to the queries so that they can be garbage collected.\ntype QueryDiagnostic = {\n  isActive: boolean;\n  filter: string;\n  creationStack: StackTrace;\n};\n\nconst QUERIES = new Set<QueryDiagnostic>();\n\ntrace.diagnostic({\n  id: 'client-queries',\n  name: 'Queries (Client)',\n  fetch: () => {\n    return Array.from(QUERIES).map((query) => {\n      return {\n        isActive: query.isActive,\n        filter: query.filter,\n        creationStack: query.creationStack.getStack(),\n      };\n    });\n  },\n});\n", "//\n// Copyright 2025 DXOS.org\n//\nimport { Filter, Query } from '@dxos/echo';\nimport { type PublicKey, type SpaceId } from '@dxos/keys';\nimport { type Live } from '@dxos/live-object';\nimport { log } from '@dxos/log';\nimport { QueryOptions as QueryOptionsProto } from '@dxos/protocols/proto/dxos/echo/filter';\n\nimport { type QueryResult } from './query-result';\n\nexport { Filter, Query };\n\n/**\n * `query` API function declaration.\n */\nexport interface QueryFn {\n  // TODO(dmaretskyi): Remove query options.\n  <Q extends Query.Any>(query: Q, options?: QueryOptions | undefined): QueryResult<Live<Query.Type<Q>>>;\n  <F extends Filter.Any>(filter: F, options?: QueryOptions | undefined): QueryResult<Live<Filter.Type<F>>>;\n}\n\n/**\n * Defines the result format of the query.\n */\nexport enum ResultFormat {\n  /**\n   * Plain javascript objects.\n   * No live updates.\n   */\n  Plain = 'plain',\n\n  /**\n   * Live objects that update automatically with mutations in the database.\n   * Support signal notifications.\n   */\n  Live = 'live',\n\n  /**\n   * Direct access to the automerge document.\n   */\n  AutomergeDocAccessor = 'automergeDocAccessor',\n}\n\n/**\n * @deprecated Use `Query.options` instead.\n */\nexport type QueryOptions = {\n  /**\n   * Query only in specific spaces.\n   */\n  // TODO(dmaretskyi): Change this to SpaceId.\n  spaceIds?: string[];\n  /**\n   * Controls how deleted items are filtered.\n   *\n   * Options:\n   *   - proto3_optional = true\n   */\n  deleted?: QueryOptionsProto.ShowDeletedOption;\n\n  /**\n   * Query only local spaces, or remote on agent.\n   * @default `QueryOptions.DataLocation.LOCAL`\n   *\n   * Options:\n   *   - proto3_optional = true\n   */\n  dataLocation?: QueryOptionsProto.DataLocation;\n\n  /**\n   * Specify which references are to inline in the result.\n   */\n  include?: QueryJoinSpec;\n\n  /**\n   * Return only the first `limit` results.\n   */\n  limit?: number;\n\n  /**\n   * @deprecated Stick to live format.\n   */\n  format?: ResultFormat;\n\n  /**\n   * @deprecated Use `spaceIds` instead.\n   */\n  spaces?: PublicKey[];\n};\n\nexport interface QueryJoinSpec extends Record<string, true | QueryJoinSpec> {}\n\nexport const optionsToProto = (options: QueryOptions): QueryOptionsProto => {\n  return {\n    spaceIds: options.spaceIds,\n    deleted: options.deleted,\n    dataLocation: options.dataLocation,\n    include: options.include,\n    limit: options.limit,\n    spaces: options.spaces,\n  };\n};\n\ntype NormalizeQueryOptions = {\n  defaultSpaceId?: SpaceId;\n};\n\nexport const normalizeQuery = (\n  query_: unknown | undefined,\n  userOptions: QueryOptions | undefined,\n  opts?: NormalizeQueryOptions,\n) => {\n  let query: Query.Any;\n\n  if (Query.is(query_)) {\n    query = query_;\n  } else if (Filter.is(query_)) {\n    query = Query.select(query_);\n  } else if (query_ === undefined) {\n    query = Query.select(Filter.everything());\n  } else if (typeof query_ === 'object' && query_ !== null) {\n    query = Query.select(Filter._props(query_));\n  } else if (typeof query_ === 'function') {\n    throw new TypeError('Functions are not supported as queries');\n  } else {\n    log.error('Invalid query', { query: query_ });\n    throw new TypeError('Invalid query');\n  }\n\n  if (userOptions) {\n    query = query.options({\n      spaceIds: userOptions.spaceIds ?? (opts?.defaultSpaceId ? [opts.defaultSpaceId] : undefined),\n      deleted:\n        userOptions?.deleted === undefined\n          ? undefined\n          : userOptions?.deleted === QueryOptionsProto.ShowDeletedOption.SHOW_DELETED\n            ? 'include'\n            : userOptions?.deleted === QueryOptionsProto.ShowDeletedOption.HIDE_DELETED\n              ? 'exclude'\n              : 'only',\n    });\n  }\n\n  return query;\n};\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { QueryAST } from '@dxos/echo-protocol';\nimport { SpaceId } from '@dxos/keys';\n\n/**\n * Lists spaces this query will select from.\n */\nexport const getTargetSpacesForQuery = (query: QueryAST.Query): SpaceId[] => {\n  const spaces = new Set<SpaceId>();\n\n  const visitor = (node: QueryAST.Query) => {\n    if (node.type === 'options') {\n      if (node.options.spaceIds) {\n        for (const spaceId of node.options.spaceIds) {\n          spaces.add(SpaceId.make(spaceId));\n        }\n      }\n    }\n    QueryAST.visit(node, visitor);\n  };\n  visitor(query);\n  return [...spaces];\n};\n\n/**\n * Extracts the filter and options from a query.\n * Supports Select(...) and Options(Select(...)) queries.\n */\nexport const isSimpleSelectionQuery = (\n  query: QueryAST.Query,\n): { filter: QueryAST.Filter; options?: QueryAST.QueryOptions } | null => {\n  switch (query.type) {\n    case 'options': {\n      const maybeFilter = isSimpleSelectionQuery(query.query);\n      if (!maybeFilter) {\n        return null;\n      }\n      return { filter: maybeFilter.filter, options: query.options };\n    }\n    case 'select': {\n      return { filter: query.filter, options: undefined };\n    }\n    default: {\n      return null;\n    }\n  }\n};\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { isNotUndefined } from 'effect/Predicate';\n\nimport { asyncTimeout, Event } from '@dxos/async';\nimport { Context } from '@dxos/context';\nimport { filterMatchObject } from '@dxos/echo-pipeline/filter';\nimport { type QueryAST } from '@dxos/echo-protocol';\nimport { type ObjectId } from '@dxos/echo-schema';\nimport { log } from '@dxos/log';\n\nimport type { QueryContext, QueryResultEntry, QueryRunOptions } from './query-result';\nimport { getTargetSpacesForQuery, isSimpleSelectionQuery } from './util';\nimport { type ItemsUpdatedEvent, type ObjectCore } from '../core-db';\nimport { type AnyLiveObject } from '../echo-handler';\nimport { prohibitSignalActions } from '../guarded-scope';\nimport { type EchoDatabaseImpl } from '../proxy-db';\n\nexport type GraphQueryContextParams = {\n  // TODO(dmaretskyi): Make async.\n  onStart: () => void;\n\n  onStop: () => void;\n};\n\n/**\n * Query data source.\n * Implemented by a space or a remote agent.\n * Each query has a separate instance.\n */\nexport interface QuerySource {\n  // TODO(dmaretskyi): Update info?\n  changed: Event<void>;\n\n  // TODO(dmaretskyi): Make async.\n  open(): void;\n\n  // TODO(dmaretskyi): Make async.\n  close(): void;\n\n  /**\n   * Synchronous query.\n   */\n  getResults(): QueryResultEntry[];\n\n  /**\n   * One-shot query.\n   */\n  run(query: QueryAST.Query): Promise<QueryResultEntry[]>;\n\n  /**\n   * Set the filter and trigger continuous updates.\n   */\n  update(query: QueryAST.Query): void;\n}\n\n/**\n * Aggregates multiple query sources.\n */\nexport class GraphQueryContext implements QueryContext {\n  private readonly _sources = new Set<QuerySource>();\n\n  private _query?: QueryAST.Query = undefined;\n\n  private _ctx?: Context = undefined;\n\n  public changed = new Event<void>();\n\n  constructor(private readonly _params: GraphQueryContextParams) {}\n\n  get sources(): ReadonlySet<QuerySource> {\n    return this._sources;\n  }\n\n  start() {\n    this._ctx = new Context();\n    this._params.onStart();\n    for (const source of this._sources) {\n      if (this._query) {\n        source.update(this._query);\n      }\n\n      // Subscribing after `update` means that we will intentionally skip any `changed` events generated by update.\n      source.changed.on(this._ctx, () => {\n        this.changed.emit();\n      });\n    }\n  }\n\n  stop() {\n    void this._ctx?.dispose();\n    for (const source of this.sources) {\n      source.close();\n    }\n    this._params.onStop();\n  }\n\n  getResults(): QueryResultEntry[] {\n    if (!this._query) {\n      return [];\n    }\n    return Array.from(this._sources).flatMap((source) => source.getResults());\n  }\n\n  async run(query: QueryAST.Query, { timeout = 30_000 }: QueryRunOptions = {}): Promise<QueryResultEntry[]> {\n    const runTasks = [...this._sources.values()].map(async (s) => {\n      try {\n        log('run query', { resolver: Object.getPrototypeOf(s).constructor.name });\n        const results = await asyncTimeout<QueryResultEntry[]>(s.run(query), timeout);\n        log('run query results', { resolver: Object.getPrototypeOf(s).constructor.name, count: results.length });\n        return results;\n      } catch (err) {\n        log('run query error', { resolver: Object.getPrototypeOf(s).constructor.name, error: err });\n        throw err;\n      }\n    });\n    if (runTasks.length === 0) {\n      return [];\n    }\n    const mergedResults = (await Promise.all(runTasks)).flatMap((r) => r ?? []);\n    return mergedResults;\n  }\n\n  update(query: QueryAST.Query): void {\n    this._query = query;\n    for (const source of this._sources) {\n      source.update(query);\n    }\n  }\n\n  addQuerySource(querySource: QuerySource) {\n    this._sources.add(querySource);\n    if (this._ctx != null) {\n      querySource.changed.on(this._ctx, () => {\n        this.changed.emit();\n      });\n    }\n    if (this._query) {\n      querySource.update(this._query);\n    }\n  }\n}\n\n/**\n * Queries objects from the local working set.\n */\nexport class SpaceQuerySource implements QuerySource {\n  public readonly changed = new Event<void>();\n\n  private _ctx: Context = new Context();\n  private _query: QueryAST.Query | undefined = undefined;\n  private _results?: QueryResultEntry<AnyLiveObject<any>>[] = undefined;\n\n  constructor(private readonly _database: EchoDatabaseImpl) {}\n\n  get spaceId() {\n    return this._database.spaceId;\n  }\n\n  get spaceKey() {\n    return this._database.spaceKey;\n  }\n\n  open(): void {}\n\n  close() {\n    this._results = undefined;\n    void this._ctx.dispose().catch(() => {});\n  }\n\n  private _onUpdate = (updateEvent: ItemsUpdatedEvent) => {\n    if (!this._query) {\n      return;\n    }\n\n    prohibitSignalActions(() => {\n      // TODO(dmaretskyi): Could be optimized to recompute changed only to the relevant space.\n      const changed = updateEvent.itemsUpdated.some(({ id: objectId }) => {\n        const core = this._database.coreDatabase.getObjectCoreById(objectId, { load: false });\n\n        const trivial = isSimpleSelectionQuery(this._query!);\n        if (!trivial) {\n          return false;\n        }\n\n        const { filter, options } = trivial;\n\n        return (\n          !this._results ||\n          this._results.find((result) => result.id === objectId) ||\n          (core && this._filterCore(core, filter, options))\n        );\n      });\n\n      if (changed) {\n        this._results = undefined;\n        this.changed.emit();\n      }\n    });\n  };\n\n  async run(query: QueryAST.Query): Promise<QueryResultEntry<AnyLiveObject<any>>[]> {\n    if (!this._isValidSourceForQuery(query)) {\n      return [];\n    }\n\n    const simple = isSimpleSelectionQuery(query);\n    if (!simple) {\n      return [];\n    }\n\n    const { filter, options } = simple;\n    const results: QueryResultEntry<AnyLiveObject<any>>[] = [];\n    if (isObjectIdFilter(filter)) {\n      results.push(\n        ...(await this._database._coreDatabase.batchLoadObjectCores((filter as QueryAST.FilterObject).id as ObjectId[]))\n          .filter(isNotUndefined)\n          .filter((core) => this._filterCore(core, filter, options))\n          .map((core) => this._mapCoreToResult(core)),\n      );\n    }\n\n    prohibitSignalActions(() => {\n      results.push(...this._queryWorkingSet(filter, options));\n    });\n\n    // Dedup\n    const map = new Map<string, QueryResultEntry<AnyLiveObject<any>>>();\n    for (const result of results) {\n      map.set(result.id, result);\n    }\n\n    return [...map.values()];\n  }\n\n  getResults(): QueryResultEntry<AnyLiveObject<any>>[] {\n    if (!this._query) {\n      return [];\n    }\n\n    const trivial = isSimpleSelectionQuery(this._query);\n    if (!trivial) {\n      return [];\n    }\n\n    const { filter, options } = trivial;\n\n    if (!this._results) {\n      prohibitSignalActions(() => {\n        this._results = this._queryWorkingSet(filter, options);\n      });\n    }\n\n    return this._results!;\n  }\n\n  update(query: QueryAST.Query): void {\n    if (!this._isValidSourceForQuery(query)) {\n      this._query = undefined;\n      return;\n    }\n\n    void this._ctx.dispose().catch(() => {});\n    this._ctx = new Context();\n    this._query = query;\n\n    this._database.coreDatabase._updateEvent.on(this._ctx, this._onUpdate);\n\n    this._results = undefined;\n    this.changed.emit();\n  }\n\n  /**\n   * Queries from already loaded objects.\n   */\n  private _queryWorkingSet(\n    filter: QueryAST.Filter,\n    options: QueryAST.QueryOptions | undefined,\n  ): QueryResultEntry<AnyLiveObject<any>>[] {\n    const filteredCores = isObjectIdFilter(filter)\n      ? (filter as QueryAST.FilterObject)\n          .id!.map((id) => this._database.coreDatabase.getObjectCoreById(id, { load: true }))\n          .filter(isNotUndefined)\n          .filter((core) => this._filterCore(core, filter, options))\n      : this._database.coreDatabase.allObjectCores().filter((core) => this._filterCore(core, filter, options));\n\n    return filteredCores.map((core) => this._mapCoreToResult(core));\n  }\n\n  private _isValidSourceForQuery(query: QueryAST.Query): boolean {\n    const targetSpaces = getTargetSpacesForQuery(query);\n    // Disabled by spaces filter.\n    if (targetSpaces.length > 0 && !targetSpaces.includes(this.spaceId)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  private _mapCoreToResult(core: ObjectCore): QueryResultEntry<AnyLiveObject<any>> {\n    return {\n      id: core.id,\n      spaceId: this.spaceId,\n      spaceKey: this.spaceKey,\n      object: this._database.getObjectById(core.id, { deleted: true }),\n      resolution: {\n        source: 'local',\n        time: 0,\n      },\n    };\n  }\n\n  private _filterCore(core: ObjectCore, filter: QueryAST.Filter, options: QueryAST.QueryOptions | undefined): boolean {\n    return (\n      filterCoreByDeletedFlag(core, options) &&\n      filterMatchObject(filter, {\n        id: core.id,\n        doc: core.getObjectStructure(),\n        spaceId: this.spaceId,\n      })\n    );\n  }\n}\n\nconst isObjectIdFilter = (filter: QueryAST.Filter) => {\n  return filter.type === 'object' && filter.id !== undefined && filter.id.length > 0;\n};\n\nconst filterCoreByDeletedFlag = (core: ObjectCore, options: QueryAST.QueryOptions | undefined): boolean => {\n  switch (options?.deleted) {\n    case undefined:\n    case 'exclude':\n      return !core.isDeleted();\n    case 'include':\n      return true;\n    case 'only':\n      return core.isDeleted();\n  }\n};\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport type { ChangeFn, ChangeOptions, Doc, Heads } from '@automerge/automerge';\n\nimport { type Reference } from '@dxos/echo-protocol';\nimport { get } from '@dxos/util';\n\nexport type DecodedAutomergePrimaryValue =\n  | undefined\n  | string\n  | number\n  | boolean\n  | DecodedAutomergePrimaryValue[]\n  | { [key: string]: DecodedAutomergePrimaryValue }\n  | Reference;\n\n//\n// Automerge types.\n// TODO(burdon): Factor out to new low-level type package: @dxos/types?\n//\n\nexport type KeyPath = readonly (string | number)[];\n\nexport interface IDocHandle<T = any> {\n  doc(): Doc<T> | undefined;\n  change(callback: ChangeFn<T>, options?: ChangeOptions<T>): void;\n  changeAt(heads: Heads, callback: ChangeFn<T>, options?: ChangeOptions<T>): Heads | undefined;\n  addListener(event: 'change', listener: () => void): void;\n  removeListener(event: 'change', listener: () => void): void;\n}\n\n// TODO(burdon): Rename ValueAccessor?\nexport interface DocAccessor<T = any> {\n  get handle(): IDocHandle<T>;\n  get path(): KeyPath;\n}\n\n// TODO(burdon): Extract function.\nexport const DocAccessor = {\n  getValue: <T>(accessor: DocAccessor): T => get(accessor.handle.doc(), accessor.path) as T,\n};\n\nexport const isValidKeyPath = (value: unknown): value is KeyPath =>\n  Array.isArray(value) && value.every((v) => typeof v === 'string' || typeof v === 'number');\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { type ChangeFn, type ChangeOptions, type Doc, type Heads, next as A } from '@automerge/automerge';\nimport { type DocHandleChangePayload } from '@automerge/automerge-repo';\nimport type { InspectOptionsStylized, inspect } from 'util';\n\nimport { Event } from '@dxos/async';\nimport { inspectCustom } from '@dxos/debug';\nimport {\n  decodeReference,\n  encodeReference,\n  isEncodedReference,\n  type ObjectStructure,\n  Reference,\n  type DatabaseDirectory,\n  DATA_NAMESPACE,\n} from '@dxos/echo-protocol';\nimport { ObjectId, EntityKind, type CommonObjectData, type ObjectMeta } from '@dxos/echo-schema';\nimport { invariant } from '@dxos/invariant';\nimport { DXN } from '@dxos/keys';\nimport { isLiveObject } from '@dxos/live-object';\nimport { log } from '@dxos/log';\nimport { setDeep, defer, getDeep, throwUnhandledError, deepMapValues } from '@dxos/util';\n\nimport { type CoreDatabase } from './core-database';\nimport { docChangeSemaphore } from './doc-semaphore';\nimport { isValidKeyPath, type DocAccessor, type DecodedAutomergePrimaryValue, type KeyPath } from './types';\nimport { type DocHandleProxy } from '../automerge';\n\n// Strings longer than this will have collaborative editing disabled for performance reasons.\n// TODO(dmaretskyi): Remove in favour of explicitly specifying this in the API/Schema.\nconst STRING_CRDT_LIMIT = 300_000;\n\nexport const META_NAMESPACE = 'meta';\nconst SYSTEM_NAMESPACE = 'system';\n\nexport type ObjectCoreOptions = {\n  type?: Reference;\n  meta?: ObjectMeta;\n  immutable?: boolean;\n};\n\n/**\n *\n */\n// TODO(burdon): Comment.\nexport class ObjectCore {\n  // TODO(dmaretskyi): Start making some of those fields private.\n  // TODO(dmaretskyi): Create a discriminated union for the bound/not bound states.\n\n  /**\n   * Id of the ECHO object.\n   */\n  public id = ObjectId.random();\n\n  /**\n   * Set if when the object is bound to a database.\n   */\n  public database?: CoreDatabase | undefined;\n\n  /**\n   * Set if when the object is not bound to a database.\n   */\n  public doc?: Doc<ObjectStructure> | undefined;\n\n  /**\n   * Set if when the object is bound to a database.\n   */\n  public docHandle?: DocHandleProxy<DatabaseDirectory> = undefined;\n\n  /**\n   * Key path at where we are mounted in the `doc` or `docHandle`.\n   * The value at path must be of type `ObjectStructure`.\n   */\n  public mountPath: KeyPath = [];\n\n  /**\n   * Handles link resolution as well as manual changes.\n   */\n  public readonly updates = new Event();\n\n  toString(): string {\n    return `ObjectCore { id: ${this.id} }`;\n  }\n\n  [inspectCustom](depth: number, options: InspectOptionsStylized, inspectFn: typeof inspect): string {\n    return `ObjectCore ${inspectFn({ id: this.id }, options)}`;\n  }\n\n  /**\n   * Create local doc with initial state from this object.\n   */\n  initNewObject(initialProps?: unknown, opts?: ObjectCoreOptions): void {\n    invariant(!this.docHandle && !this.doc);\n\n    initialProps ??= {};\n\n    this.doc = A.from<ObjectStructure>({\n      data: this.encode(initialProps as any),\n      meta: this.encode({\n        keys: [],\n        ...opts?.meta,\n      }),\n      system: {},\n    });\n  }\n\n  bind(options: BindOptions): void {\n    invariant(options.docHandle.isReady());\n    this.database = options.db;\n    this.docHandle = options.docHandle;\n    this.mountPath = options.path;\n\n    const doc = this.doc;\n    this.doc = undefined;\n\n    if (options.assignFromLocalState) {\n      invariant(doc, 'assignFromLocalState');\n\n      // Prevent recursive change calls.\n      using _ = defer(docChangeSemaphore(this.docHandle ?? this));\n\n      this.docHandle.change((newDoc: DatabaseDirectory) => {\n        setDeep(newDoc, this.mountPath, doc);\n      });\n    }\n\n    this.notifyUpdate();\n  }\n\n  getDoc(): Doc<unknown> {\n    if (this.doc) {\n      return this.doc;\n    }\n\n    if (this.docHandle) {\n      return this.docHandle.doc();\n    }\n\n    throw new Error('Invalid ObjectCore state');\n  }\n\n  getObjectStructure(): ObjectStructure {\n    return getDeep(this.getDoc(), this.mountPath) as ObjectStructure;\n  }\n\n  /**\n   * Do not take into account mountPath.\n   */\n  change(changeFn: ChangeFn<any>, options?: A.ChangeOptions<any>): void {\n    // Prevent recursive change calls.\n    using _ = defer(docChangeSemaphore(this.docHandle ?? this));\n\n    if (this.doc) {\n      if (options) {\n        this.doc = A.change(this.doc!, options, changeFn);\n      } else {\n        this.doc = A.change(this.doc!, changeFn);\n      }\n\n      // No change event is emitted here since we are not using the doc handle. Notify listeners manually.\n      this.notifyUpdate();\n    } else {\n      invariant(this.docHandle);\n      this.docHandle.change(changeFn, options);\n      // Note: We don't need to notify listeners here, since `change` event is already processed by DB.\n    }\n  }\n\n  /**\n   * Do not take into account mountPath.\n   */\n  changeAt(heads: Heads, callback: ChangeFn<any>, options?: ChangeOptions<any>): Heads | undefined {\n    // Prevent recursive change calls.\n    using _ = defer(docChangeSemaphore(this.docHandle ?? this));\n\n    let result: Heads | undefined;\n    if (this.doc) {\n      if (options) {\n        const { newDoc, newHeads } = A.changeAt(this.doc!, heads, options, callback);\n        this.doc = newDoc;\n        result = newHeads ?? undefined;\n      } else {\n        const { newDoc, newHeads } = A.changeAt(this.doc!, heads, callback);\n        this.doc = newDoc;\n        result = newHeads ?? undefined;\n      }\n\n      // No change event is emitted here since we are not using the doc handle. Notify listeners manually.\n      this.notifyUpdate();\n    } else {\n      invariant(this.docHandle);\n      result = this.docHandle.changeAt(heads, callback, options);\n      // Note: We don't need to notify listeners here, since `change` event is already processed by DB.\n    }\n\n    return result;\n  }\n\n  getDocAccessor(path: KeyPath = []): DocAccessor {\n    invariant(isValidKeyPath(path));\n    const self = this;\n    return {\n      handle: {\n        doc: () => this.getDoc(),\n        change: (callback, options) => {\n          this.change(callback, options);\n        },\n        changeAt: (heads, callback, options) => {\n          return this.changeAt(heads, callback, options);\n        },\n        addListener: (event, listener) => {\n          if (event === 'change') {\n            // TODO(dmaretskyi): We probably don't need to subscribe to docHandle here separately.\n            this.docHandle?.on('change', listener);\n            this.updates.on(listener);\n          }\n        },\n        removeListener: (event, listener) => {\n          if (event === 'change') {\n            // TODO(dmaretskyi): We probably don't need to subscribe to docHandle here separately.\n            this.docHandle?.off('change', listener);\n            this.updates.off(listener);\n          }\n        },\n      },\n      get path() {\n        return [...self.mountPath, 'data', ...path];\n      },\n    };\n  }\n\n  /**\n   * Fire a synchronous update notification via signal and event subscriptions.\n   * Called after local changes and link resolution.\n   * This function can be used unbound.\n   */\n  public readonly notifyUpdate = () => {\n    try {\n      this.updates.emit();\n    } catch (err: any) {\n      // Print the error message synchronously for easier debugging.\n      // The stack trace and details will be printed asynchronously.\n      log.catch(err);\n\n      // Reports all errors that happen during even propagation as unhandled.\n      // This is important since we don't want to silently swallow errors.\n      // Unfortunately, this will only report errors in the next microtask after the current stack has already unwound.\n      // TODO(dmaretskyi): Take some inspiration from facebook/react/packages/shared/invokeGuardedCallbackImpl.js\n      throwUnhandledError(err);\n    }\n  };\n\n  /**\n   * Encode a value to be stored in the Automerge document.\n   */\n  encode(value: DecodedAutomergePrimaryValue) {\n    if (isLiveObject(value) as boolean) {\n      throw new TypeError('Linking is not allowed');\n    }\n\n    if (value instanceof A.RawString) {\n      return value;\n    }\n    if (value === undefined) {\n      return null;\n    }\n\n    if (value instanceof Reference) {\n      // TODO(mykola): Delete this once we clean up Reference 'protobuf' protocols types.\n      return encodeReference(value);\n    }\n    if (Array.isArray(value)) {\n      const values: any = value.map((val) => this.encode(val));\n      return values;\n    }\n    if (typeof value === 'object' && value !== null) {\n      const entries = Object.entries(value).filter(([_, value]) => value !== undefined);\n      return Object.fromEntries(entries.map(([key, value]): [string, any] => [key, this.encode(value)]));\n    }\n\n    if (typeof value === 'string' && value.length > STRING_CRDT_LIMIT) {\n      return new A.RawString(value);\n    }\n\n    return value;\n  }\n\n  /**\n   * Decode a value from the Automerge document.\n   */\n  decode(value: any): DecodedAutomergePrimaryValue {\n    if (value === null) {\n      return value;\n    }\n    if (Array.isArray(value)) {\n      return value.map((val) => this.decode(val));\n    }\n    if (value instanceof A.RawString) {\n      return value.toString();\n    }\n    // For some reason references without `@type` are being stored in the document.\n    if (isEncodedReference(value) || maybeReference(value)) {\n      return decodeReference(value);\n    }\n    if (typeof value === 'object') {\n      return Object.fromEntries(Object.entries(value).map(([key, value]): [string, any] => [key, this.decode(value)]));\n    }\n\n    return value;\n  }\n\n  arrayPush(path: KeyPath, items: DecodedAutomergePrimaryValue[]): number {\n    const itemsEncoded = items.map((item) => this.encode(item));\n\n    let newLength: number = -1;\n    this.change((doc) => {\n      const fullPath = [...this.mountPath, ...path];\n      const array = getDeep(doc, fullPath);\n      invariant(Array.isArray(array));\n      newLength = array.push(...itemsEncoded);\n    });\n    invariant(newLength !== -1);\n    return newLength;\n  }\n\n  private _getRaw(path: KeyPath): Doc<ObjectStructure> | Doc<DatabaseDirectory> {\n    const fullPath = [...this.mountPath, ...path];\n\n    let value = this.getDoc();\n    for (const key of fullPath) {\n      value = (value as any)?.[key];\n    }\n\n    return value;\n  }\n\n  private _setRaw(path: KeyPath, value: any): void {\n    const fullPath = [...this.mountPath, ...path];\n\n    this.change((doc) => {\n      setDeep(doc, fullPath, value);\n    });\n  }\n\n  // TODO(dmaretskyi): Rename to `get`.\n  getDecoded(path: KeyPath): DecodedAutomergePrimaryValue {\n    return this.decode(this._getRaw(path)) as DecodedAutomergePrimaryValue;\n  }\n\n  // TODO(dmaretskyi): Rename to `set`.\n  setDecoded(path: KeyPath, value: DecodedAutomergePrimaryValue): void {\n    this._setRaw(path, this.encode(value));\n  }\n\n  /**\n   * Deletes key at path.\n   */\n  delete(path: KeyPath): void {\n    const fullPath = [...this.mountPath, ...path];\n\n    this.change((doc) => {\n      const value: any = getDeep(doc, fullPath.slice(0, fullPath.length - 1));\n      delete value[fullPath[fullPath.length - 1]];\n    });\n  }\n\n  getKind(): EntityKind {\n    return (this._getRaw([SYSTEM_NAMESPACE, 'kind']) as any) ?? EntityKind.Object;\n  }\n\n  // TODO(dmaretskyi): Just set statically during construction.\n  setKind(kind: EntityKind): void {\n    this._setRaw([SYSTEM_NAMESPACE, 'kind'], kind);\n  }\n\n  getSource(): Reference | undefined {\n    const res = this.getDecoded([SYSTEM_NAMESPACE, 'source']);\n    invariant(res === undefined || res instanceof Reference);\n    return res;\n  }\n\n  // TODO(dmaretskyi): Just set statically during construction.\n  setSource(ref: Reference): void {\n    this.setDecoded([SYSTEM_NAMESPACE, 'source'], ref);\n  }\n\n  getTarget(): Reference | undefined {\n    const res = this.getDecoded([SYSTEM_NAMESPACE, 'target']);\n    invariant(res === undefined || res instanceof Reference);\n    return res;\n  }\n\n  // TODO(dmaretskyi): Just set statically during construction.\n  setTarget(ref: Reference): void {\n    this.setDecoded([SYSTEM_NAMESPACE, 'target'], ref);\n  }\n\n  getType(): Reference | undefined {\n    const value = this.decode(this._getRaw([SYSTEM_NAMESPACE, 'type']));\n    if (!value) {\n      return undefined;\n    }\n\n    invariant(value instanceof Reference);\n    return value;\n  }\n\n  setType(reference: Reference): void {\n    this._setRaw([SYSTEM_NAMESPACE, 'type'], this.encode(reference));\n  }\n\n  getMeta(): ObjectMeta {\n    return this.getDecoded([META_NAMESPACE]) as ObjectMeta;\n  }\n\n  setMeta(meta: ObjectMeta): void {\n    this._setRaw([META_NAMESPACE], this.encode(meta));\n  }\n\n  isDeleted(): boolean {\n    const value = this._getRaw([SYSTEM_NAMESPACE, 'deleted']);\n    return typeof value === 'boolean' ? value : false;\n  }\n\n  setDeleted(value: boolean): void {\n    this._setRaw([SYSTEM_NAMESPACE, 'deleted'], value);\n  }\n\n  /**\n   * @deprecated\n   */\n  toPlainObject(): CommonObjectData & Record<string, any> {\n    let data = this.getDecoded([DATA_NAMESPACE]);\n    if (typeof data !== 'object') {\n      log.error('Corrupted object data property', { type: typeof data });\n      data = {};\n    }\n\n    const dataMapped = deepMapValues(data, (value, recurse) => {\n      if (value instanceof Reference) {\n        return { '/': value.toDXN().toString() };\n      }\n      return recurse(value);\n    });\n\n    return {\n      id: this.id,\n      __typename: this.getType()?.toDXN().toString() ?? null,\n      __meta: this.getDecoded([META_NAMESPACE]) as ObjectMeta,\n      ...dataMapped,\n    };\n  }\n\n  /**\n   * DXNs of objects that this object strongly depends on.\n   * Strong references are loaded together with the source object.\n   * Currently this is the schema reference and the source and target for relations\n   */\n  getStrongDependencies(): DXN[] {\n    const res: DXN[] = [];\n\n    const type = this.getType()?.toDXN();\n    if (type && type.kind === DXN.kind.ECHO) {\n      res.push(type);\n    }\n\n    if (this.getKind() === EntityKind.Relation) {\n      const source = this.getSource()?.toDXN();\n      if (source) {\n        res.push(source);\n      }\n      const target = this.getTarget()?.toDXN();\n      if (target) {\n        res.push(target);\n      }\n    }\n\n    return res;\n  }\n}\n\nexport type BindOptions = {\n  db: CoreDatabase;\n  docHandle: DocHandleProxy<DatabaseDirectory>;\n  path: KeyPath;\n\n  /**\n   * Assign the state from the local doc into the shared structure for the database.\n   */\n  assignFromLocalState?: boolean;\n};\n\nexport const objectIsUpdated = (objId: string, event: DocHandleChangePayload<DatabaseDirectory>) => {\n  if (event.patches.some((patch) => patch.path[0] === 'objects' && patch.path[1] === objId)) {\n    return true;\n  }\n  return false;\n};\n\n// TODO(burdon): Move to echo-protocol.\nconst maybeReference = (value: unknown) =>\n  typeof value === 'object' &&\n  value !== null &&\n  Object.keys(value).length === 3 &&\n  'objectId' in value && // TODO(burdon): 'objectId'\n  'protocol' in value &&\n  'host' in value;\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { failedInvariant } from '@dxos/invariant';\nimport { log } from '@dxos/log';\nimport { getDebugName } from '@dxos/util';\n\n// Not very pretty code, but easy to write without introducing a new wrapper around AM docs.\n\nconst beingChanged = new WeakSet<any>();\n\nexport const docChangeSemaphore = (handle: any) => {\n  log('begin change', { handled: getDebugName(handle) });\n  if (beingChanged.has(handle)) {\n    failedInvariant('Recursive call to doc.change');\n  }\n\n  beingChanged.add(handle);\n\n  return () => {\n    log('end change', { handled: getDebugName(handle) });\n    beingChanged.delete(handle);\n  };\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { next as A, type Doc } from '@automerge/automerge';\nimport { stringifyAutomergeUrl, type DocHandleOptions, type DocumentId } from '@automerge/automerge-repo';\nimport { EventEmitter } from 'eventemitter3';\n\nimport { Trigger, TriggerState } from '@dxos/async';\nimport { invariant } from '@dxos/invariant';\n\nimport { type IDocHandle } from '../core-db';\n\nexport type ChangeEvent<T> = {\n  handle: DocHandleProxy<T>;\n  doc: A.Doc<T>;\n  patches: A.Patch[];\n  patchInfo: { before: A.Doc<T>; after: A.Doc<T>; source: 'change' };\n};\n\nexport type ClientDocHandleEvents<T> = {\n  change: ChangeEvent<T>;\n  delete: { handle: DocHandleProxy<T> };\n};\n\n/**\n * A client-side `IDocHandle` implementation.\n * Syncs with a Automerge Repo in shared worker.\n * Inspired by Automerge's `DocHandle`.\n */\nexport class DocHandleProxy<T> extends EventEmitter<ClientDocHandleEvents<T>> implements IDocHandle<T> {\n  private readonly _ready = new Trigger();\n  private _doc?: A.Doc<T> = undefined;\n\n  private _lastSentHeads: A.Heads = [];\n  /**\n   * Heads that are currently being synced.\n   * If sync is successful, they will be moved to `_lastSentHeads`.\n   */\n  private _currentlySendingHeads: A.Heads = [];\n\n  constructor(\n    private readonly _documentId: DocumentId,\n    options: DocHandleOptions<T> = {},\n    private readonly _callbacks?: {\n      onDelete: () => void;\n    },\n  ) {\n    super();\n    if (options.isNew) {\n      // T should really be constrained to extend `Record<string, unknown>` (an automerge doc can't be\n      // e.g. a primitive, an array, etc. - it must be an object). But adding that constraint creates\n      // a bunch of other problems elsewhere so for now we'll just cast it here to make Automerge happy.\n      this._doc = A.from(options.initialValue as Record<string, unknown>) as T;\n      this._doc = A.emptyChange<T>(this._doc);\n      this._ready.wake();\n    } else {\n      this._doc = A.init<T>();\n    }\n  }\n\n  get url() {\n    return stringifyAutomergeUrl(this._documentId);\n  }\n\n  get documentId(): DocumentId {\n    return this._documentId;\n  }\n\n  get state() {\n    return this._ready.state === TriggerState.RESOLVED ? 'ready' : 'pending';\n  }\n\n  doc(): A.Doc<T> {\n    if (!this._doc) {\n      throw new Error('DocHandleProxy.doc called on deleted doc');\n    }\n    return this._doc;\n  }\n\n  async whenReady(): Promise<void> {\n    await this._ready.wait();\n  }\n\n  isReady(): boolean {\n    return this._ready.state === TriggerState.RESOLVED;\n  }\n\n  change(fn: (doc: A.Doc<T>) => void, opts?: A.ChangeOptions<any>): void {\n    invariant(this._doc, 'DocHandleProxy.change called on deleted doc');\n    const before = this._doc;\n    const headsBefore = A.getHeads(this._doc);\n    this._doc = opts ? A.change(this._doc, opts, fn) : A.change(this._doc, fn);\n    this.emit('change', {\n      handle: this,\n      doc: this._doc,\n      patches: A.diff(this._doc, headsBefore, A.getHeads(this._doc)),\n      patchInfo: { before, after: this._doc, source: 'change' },\n    });\n  }\n\n  changeAt(heads: A.Heads, fn: (doc: A.Doc<T>) => void, opts?: A.ChangeOptions<any>): A.Heads | undefined {\n    invariant(this._doc, 'DocHandleProxy.changeAt called on deleted doc');\n    const before = this._doc;\n    const headsBefore = A.getHeads(this._doc);\n    const { newDoc, newHeads } = opts ? A.changeAt(this._doc, heads, opts, fn) : A.changeAt(this._doc, heads, fn);\n\n    this._doc = newDoc;\n    this.emit('change', {\n      handle: this,\n      doc: this._doc,\n      patches: newHeads ? A.diff(this._doc, headsBefore, newHeads) : [],\n      patchInfo: { before, after: this._doc, source: 'change' },\n    });\n    return newHeads ?? undefined;\n  }\n\n  update(updateCallback: (doc: A.Doc<T>) => A.Doc<T>): void {\n    invariant(this._doc, 'DocHandleProxy.update called on deleted doc');\n    const before = this._doc;\n    const headsBefore = A.getHeads(this._doc);\n    const newDoc = updateCallback(this._doc);\n    invariant(newDoc, 'DocHandleProxy.update returned undefined doc');\n    this._doc = newDoc;\n    this.emit('change', {\n      handle: this,\n      doc: this._doc,\n      patches: A.diff(this._doc, headsBefore, A.getHeads(this._doc)),\n      patchInfo: { before, after: this._doc, source: 'change' },\n    });\n  }\n\n  delete(): void {\n    this._callbacks?.onDelete();\n    this.emit('delete', { handle: this });\n    this._doc = undefined;\n  }\n\n  /**\n   * Get pending changes since last write.\n   * @internal\n   */\n  _getPendingChanges(): Uint8Array | undefined {\n    invariant(this._doc, 'Doc is deleted, cannot get last write mutation');\n    if (A.equals(A.getHeads(this._doc), this._lastSentHeads)) {\n      return;\n    }\n\n    const mutation = A.saveSince(this._doc, this._lastSentHeads);\n    if (mutation.length === 0) {\n      return;\n    }\n    this._currentlySendingHeads = A.getHeads(this._doc);\n    return mutation;\n  }\n\n  /**\n   * Confirm that the last write was successful.\n   * @internal\n   */\n  _confirmSync(): void {\n    this._lastSentHeads = this._currentlySendingHeads;\n  }\n\n  /**\n   * Update the doc with a foreign mutation from worker.\n   * @internal\n   */\n  _integrateHostUpdate(mutation: Uint8Array): void {\n    invariant(this._doc, 'Doc is deleted, cannot write mutation');\n    const before = this._doc;\n    const headsBefore = A.getHeads(this._doc);\n    this._doc = A.loadIncremental(this._doc, mutation);\n\n    if (A.equals(headsBefore, this._lastSentHeads)) {\n      this._lastSentHeads = A.getHeads(this._doc);\n    }\n\n    this._ready.wake();\n\n    this.emit('change', {\n      handle: this,\n      doc: this._doc,\n      patches: A.diff(this._doc, headsBefore, A.getHeads(this._doc)),\n      patchInfo: { before, after: this._doc, source: 'change' },\n    });\n  }\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { next as A } from '@automerge/automerge';\nimport {\n  type AnyDocumentId,\n  type DocumentId,\n  generateAutomergeUrl,\n  interpretAsDocumentId,\n  parseAutomergeUrl,\n} from '@automerge/automerge-repo';\n\nimport { Event, UpdateScheduler } from '@dxos/async';\nimport { type Stream } from '@dxos/codec-protobuf/stream';\nimport { LifecycleState, Resource } from '@dxos/context';\nimport { invariant } from '@dxos/invariant';\nimport { PublicKey, type SpaceId } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport {\n  type BatchedDocumentUpdates,\n  type DataService,\n  type DocumentUpdate,\n} from '@dxos/protocols/proto/dxos/echo/service';\nimport { trace } from '@dxos/tracing';\n\nimport { DocHandleProxy } from './doc-handle-proxy';\n\nconst MAX_UPDATE_FREQ = 10; // [updates/sec]\nconst RPC_TIMEOUT = 30_000;\n\n/**\n * A proxy (thin client) to the Automerge Repo.\n * Inspired by Automerge's `Repo`.\n */\n@trace.resource()\nexport class RepoProxy extends Resource {\n  // TODO(mykola): Change to Map<string, DocHandleProxy<unknown>>.\n  private _handles: Record<string, DocHandleProxy<any>> = {};\n  private readonly _subscriptionId = PublicKey.random().toHex();\n  /**\n   * Subscription id which is used inside the DataService to identify the Client.\n   */\n  private _subscription?: Stream<BatchedDocumentUpdates> = undefined;\n\n  /**\n   * Document ids pending for init mutation.\n   */\n  private readonly _pendingCreateIds = new Set<DocumentId>();\n\n  /**\n   * Document ids that should be subscribed to.\n   */\n  private readonly _pendingAddIds = new Set<DocumentId>();\n\n  /**\n   * Document ids that should be unsubscribed from.\n   */\n  private readonly _pendingRemoveIds = new Set<DocumentId>();\n\n  /**\n   * Document ids that have pending updates.\n   */\n  private readonly _pendingUpdateIds = new Set<DocumentId>();\n\n  private _sendUpdatesJob?: UpdateScheduler = undefined;\n\n  readonly saveStateChanged = new Event<SaveStateChangedEvent>();\n\n  constructor(\n    private readonly _dataService: DataService,\n    private readonly _spaceId: SpaceId,\n  ) {\n    super();\n  }\n\n  get handles(): Record<string, DocHandleProxy<any>> {\n    return this._handles;\n  }\n\n  find<T>(id: AnyDocumentId): DocHandleProxy<T> {\n    if (typeof id !== 'string') {\n      throw new TypeError(`Invalid documentId ${id}`);\n    }\n\n    const documentId = interpretAsDocumentId(id);\n    return this._getHandle<T>({\n      documentId,\n      isNew: false,\n    });\n  }\n\n  import<T>(dump: Uint8Array): DocHandleProxy<T> {\n    const handle = this.create<T>();\n    handle.update(() => A.load(dump));\n    return handle;\n  }\n\n  create<T>(initialValue?: T): DocHandleProxy<T> {\n    // Generate a new UUID and store it in the buffer.\n    const { documentId } = parseAutomergeUrl(generateAutomergeUrl());\n    return this._getHandle<T>({\n      documentId,\n      isNew: true,\n      initialValue,\n    });\n  }\n\n  async flush(): Promise<void> {\n    await this._sendUpdatesJob?.runBlocking();\n  }\n\n  protected override async _open(): Promise<void> {\n    // TODO(dmaretskyi): Set proper space id.\n    this._subscription = this._dataService.subscribe({\n      subscriptionId: this._subscriptionId,\n      spaceId: this._spaceId,\n    });\n    this._sendUpdatesJob = new UpdateScheduler(this._ctx, async () => this._sendUpdates(), {\n      maxFrequency: MAX_UPDATE_FREQ,\n    });\n    this._subscription.subscribe((updates) => this._receiveUpdate(updates));\n  }\n\n  protected override async _close(): Promise<void> {\n    await this._sendUpdatesJob?.join();\n    this._sendUpdatesJob = undefined;\n    for (const handle of Object.values(this._handles)) {\n      handle.off('change');\n    }\n\n    this._handles = {};\n    await this._subscription?.close();\n    this._subscription = undefined;\n  }\n\n  /** Returns an existing handle if we have it; creates one otherwise. */\n  private _getHandle<T>({\n    documentId,\n    isNew,\n    initialValue,\n  }: {\n    /** The documentId of the handle to look up or create. */\n    documentId: DocumentId;\n    /** If we know we're creating a new document, specify this so we can have access to it immediately. */\n    isNew: boolean;\n    initialValue?: T;\n  }): DocHandleProxy<T> {\n    // If we have the handle cached, return it\n    if (this._handles[documentId]) {\n      return this._handles[documentId];\n    }\n    // If not, create a new handle, cache it, and return it.\n    if (!documentId) {\n      throw new Error(`Invalid documentId ${documentId}`);\n    }\n\n    return this._createHandle<T>({ documentId, isNew, initialValue });\n  }\n\n  private _createHandle<T>({\n    documentId,\n    isNew,\n    initialValue,\n  }: {\n    documentId: DocumentId;\n    isNew: boolean;\n    initialValue?: T;\n  }): DocHandleProxy<T> {\n    invariant(this._lifecycleState === LifecycleState.OPEN);\n\n    // TODO(burdon): Called even if not mutations.\n    const onChange = () => {\n      log('onChange', { documentId });\n      this._pendingUpdateIds.add(documentId);\n      this._sendUpdatesJob?.trigger();\n      this._emitSaveStateEvent();\n    };\n\n    const onDelete = () => {\n      log('onDelete', { documentId });\n      handle.off('change', onChange);\n      this._pendingRemoveIds.add(documentId);\n      this._sendUpdatesJob?.trigger();\n      delete this._handles[documentId];\n    };\n\n    const handle = new DocHandleProxy<T>(documentId, { isNew, initialValue }, { onDelete });\n    handle.on('change', onChange);\n    this._handles[documentId] = handle;\n\n    if (isNew) {\n      this._pendingCreateIds.add(documentId);\n    } else {\n      this._pendingAddIds.add(documentId);\n    }\n    this._sendUpdatesJob!.trigger();\n\n    return handle;\n  }\n\n  private _receiveUpdate({ updates }: BatchedDocumentUpdates): void {\n    if (!updates) {\n      return;\n    }\n\n    for (const update of updates) {\n      const { documentId, mutation } = update;\n      const handle = this._handles[documentId];\n      if (!handle) {\n        log.warn('Received update for unknown document', { documentId });\n        continue;\n      }\n\n      handle._integrateHostUpdate(mutation);\n    }\n  }\n\n  private async _sendUpdates(): Promise<void> {\n    // Save current state of pending updates to avoid race conditions.\n    const createIds = Array.from(this._pendingCreateIds);\n    const addIds = Array.from(this._pendingAddIds);\n    const removeIds = Array.from(this._pendingRemoveIds);\n    const updateIds = Array.from(this._pendingUpdateIds);\n\n    this._pendingCreateIds.clear();\n    this._pendingAddIds.clear();\n    this._pendingRemoveIds.clear();\n    this._pendingUpdateIds.clear();\n\n    try {\n      await this._dataService.updateSubscription(\n        { subscriptionId: this._subscriptionId, addIds, removeIds },\n        { timeout: RPC_TIMEOUT },\n      );\n      const updates: DocumentUpdate[] = [];\n      const addMutations = (documentIds: DocumentId[], isNew?: boolean) => {\n        for (const documentId of documentIds) {\n          const handle = this._handles[documentId];\n          invariant(handle, `No handle found for documentId ${documentId}`);\n          const mutation = handle._getPendingChanges();\n          if (mutation) {\n            updates.push({ documentId, mutation, isNew });\n          }\n        }\n      };\n\n      addMutations(createIds, true);\n      addMutations(updateIds);\n      if (updates.length > 0) {\n        await this._dataService.update({ subscriptionId: this._subscriptionId, updates }, { timeout: RPC_TIMEOUT });\n        for (const { documentId } of updates) {\n          this._handles[documentId]._confirmSync();\n        }\n      }\n      this._emitSaveStateEvent();\n    } catch (err) {\n      // Restore the state of pending updates if the RPC call failed.\n      createIds.forEach((id) => this._pendingCreateIds.add(id));\n      addIds.forEach((id) => this._pendingAddIds.add(id));\n      removeIds.forEach((id) => this._pendingRemoveIds.add(id));\n      updateIds.forEach((id) => this._pendingUpdateIds.add(id));\n\n      this._ctx.raise(err as Error);\n    }\n  }\n\n  private _emitSaveStateEvent(): void {\n    const unsavedDocuments = [...this._pendingCreateIds, ...this._pendingUpdateIds];\n    this.saveStateChanged.emit({ unsavedDocuments });\n  }\n}\n\nexport type SaveStateChangedEvent = {\n  unsavedDocuments: DocumentId[];\n};\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { getHeads } from '@automerge/automerge';\nimport { interpretAsDocumentId, type AutomergeUrl, type DocumentId } from '@automerge/automerge-repo';\n\nimport {\n  asyncTimeout,\n  Event,\n  runInContextAsync,\n  synchronized,\n  TimeoutError,\n  Trigger,\n  UpdateScheduler,\n  type ReadOnlyEvent,\n  type CleanupFn,\n} from '@dxos/async';\nimport { Stream } from '@dxos/codec-protobuf/stream';\nimport { Context, ContextDisposedError } from '@dxos/context';\nimport { raise } from '@dxos/debug';\nimport { type Filter } from '@dxos/echo';\nimport {\n  encodeReference,\n  isEncodedReference,\n  Reference,\n  type ObjectStructure,\n  type DatabaseDirectory,\n  type SpaceState,\n  DATA_NAMESPACE,\n} from '@dxos/echo-protocol';\nimport { type ObjectId, Ref, type AnyObjectData } from '@dxos/echo-schema';\nimport { compositeRuntime } from '@dxos/echo-signals/runtime';\nimport { invariant } from '@dxos/invariant';\nimport { DXN, LOCAL_SPACE_TAG, type PublicKey, type SpaceId } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport type { QueryOptions } from '@dxos/protocols/proto/dxos/echo/filter';\nimport type { QueryService } from '@dxos/protocols/proto/dxos/echo/query';\nimport type { DataService, SpaceSyncState } from '@dxos/protocols/proto/dxos/echo/service';\nimport { trace } from '@dxos/tracing';\nimport { chunkArray, deepMapValues, defaultMap, setDeep } from '@dxos/util';\n\nimport {\n  AutomergeDocumentLoaderImpl,\n  type AutomergeDocumentLoader,\n  type DocumentChanges,\n  type ObjectDocumentLoaded,\n} from './automerge-doc-loader';\nimport { CoreDatabaseQueryContext } from './core-database-query-context';\nimport { type InsertBatch, type InsertData, type UpdateOperation } from './crud-api';\nimport { ObjectCore } from './object-core';\nimport { getInlineAndLinkChanges } from './util';\nimport { RepoProxy, type ChangeEvent, type DocHandleProxy, type SaveStateChangedEvent } from '../automerge';\nimport { type Hypergraph } from '../hypergraph';\nimport { normalizeQuery, QueryResult, type QueryFn } from '../query';\n\nexport type InitRootProxyFn = (core: ObjectCore) => void;\n\nexport type CoreDatabaseParams = {\n  graph: Hypergraph;\n  dataService: DataService;\n  queryService: QueryService;\n  spaceId: SpaceId;\n  spaceKey: PublicKey;\n};\n\n/**\n * Maximum number of remote update notifications per second.\n */\nconst THROTTLED_UPDATE_FREQUENCY = 10;\n\nexport type ObjectPlacement = 'root-doc' | 'linked-doc';\n\nexport type AddCoreOptions = {\n  /**\n   * Where to place the object in the Automerge document tree.\n   * Root document is always loaded with the space.\n   * Linked documents are loaded lazily.\n   * Placing large number of objects in the root document may slow down the initial load.\n   *\n   * @default 'linked-doc'\n   */\n  placeIn?: ObjectPlacement;\n};\n\nconst TRACE_LOADING = false;\n\n/**\n *\n */\n// TODO(burdon): Document.\n@trace.resource()\nexport class CoreDatabase {\n  private readonly _hypergraph: Hypergraph;\n  private readonly _dataService: DataService;\n  private readonly _queryService: QueryService;\n  private readonly _repoProxy: RepoProxy;\n  private readonly _spaceId: SpaceId;\n  private readonly _spaceKey: PublicKey;\n  private readonly _objects = new Map<string, ObjectCore>();\n\n  /**\n   * DXN string -> ObjectId.\n   * Stores the targets of strong dependencies to the objects that depend on them.\n   * When we load an object that doesn't have it's strong deps resolved, we wait for the deps to be loaded first.\n   */\n  private readonly _strongDepsIndex = new Map<string, ObjectId[]>();\n\n  readonly _updateEvent = new Event<ItemsUpdatedEvent>();\n\n  private _state = CoreDatabaseState.CLOSED;\n\n  private _ctx = new Context();\n\n  // TODO(dmaretskyi): Refactor this.\n  public readonly opened = new Trigger();\n\n  /**\n   * @internal\n   */\n  readonly _automergeDocLoader: AutomergeDocumentLoader;\n\n  readonly rootChanged = new Event<void>();\n\n  readonly saveStateChanged: ReadOnlyEvent<SaveStateChangedEvent>;\n\n  constructor({ graph, dataService, queryService, spaceId, spaceKey }: CoreDatabaseParams) {\n    this._hypergraph = graph;\n    this._dataService = dataService;\n    this._queryService = queryService;\n    this._spaceId = spaceId;\n    this._spaceKey = spaceKey;\n    this._repoProxy = new RepoProxy(this._dataService, this._spaceId);\n    this.saveStateChanged = this._repoProxy.saveStateChanged;\n    this._automergeDocLoader = new AutomergeDocumentLoaderImpl(this._repoProxy, spaceId, spaceKey);\n  }\n\n  toJSON() {\n    return {\n      id: this._spaceId,\n      objects: this._objects.size,\n    };\n  }\n\n  get graph(): Hypergraph {\n    return this._hypergraph;\n  }\n\n  get spaceId(): SpaceId {\n    return this._spaceId;\n  }\n\n  /**\n   * @deprecated\n   */\n  get spaceKey(): PublicKey {\n    return this._spaceKey;\n  }\n\n  // TODO(dmaretskyi): Stop exposing repo.\n  // Currently needed for migration-builder and unit-tests.\n  get _repo(): RepoProxy {\n    return this._repoProxy;\n  }\n\n  @synchronized\n  async open(spaceState: SpaceState): Promise<void> {\n    const start = performance.now();\n    if (this._state !== CoreDatabaseState.CLOSED) {\n      log.info('Already open');\n      return;\n    }\n    this._state = CoreDatabaseState.OPENING;\n\n    await this._repoProxy.open();\n    this._ctx.onDispose(this._unsubscribeFromHandles.bind(this));\n    this._automergeDocLoader.onObjectDocumentLoaded.on(this._ctx, this._onObjectDocumentLoaded.bind(this));\n\n    try {\n      await this._automergeDocLoader.loadSpaceRootDocHandle(this._ctx, spaceState);\n      const spaceRootDocHandle = this._automergeDocLoader.getSpaceRootDocHandle();\n      const spaceRootDoc: DatabaseDirectory = spaceRootDocHandle.doc();\n      invariant(spaceRootDoc);\n      const objectIds = Object.keys(spaceRootDoc.objects ?? {});\n      this._createInlineObjects(spaceRootDocHandle, objectIds);\n      spaceRootDocHandle.on('change', this._onDocumentUpdate);\n    } catch (err) {\n      if (err instanceof ContextDisposedError) {\n        return;\n      }\n      log.catch(err);\n      throw err;\n    }\n\n    const elapsed = performance.now() - start;\n    if (elapsed > 1_000) {\n      log.warn('slow AM open', { docId: spaceState.rootUrl, duration: elapsed });\n    }\n\n    this._state = CoreDatabaseState.OPEN;\n    this.opened.wake();\n  }\n\n  // TODO(dmaretskyi): Cant close while opening.\n  @synchronized\n  async close(): Promise<void> {\n    if (this._state === CoreDatabaseState.CLOSED) {\n      return;\n    }\n    this._state = CoreDatabaseState.CLOSED;\n\n    this.opened.throw(new ContextDisposedError());\n    this.opened.reset();\n\n    await this._ctx.dispose();\n    this._ctx = new Context();\n\n    await this._repoProxy.close();\n  }\n\n  /**\n   * Update DB in response to space state change.\n   * Can be used to change the root AM document.\n   */\n  // TODO(dmaretskyi): should it be synchronized and/or cancelable?\n  @synchronized\n  async updateSpaceState(spaceState: SpaceState): Promise<void> {\n    invariant(this._ctx, 'Must be open');\n    if (spaceState.rootUrl === this._automergeDocLoader.getSpaceRootDocHandle().url) {\n      return;\n    }\n    this._unsubscribeFromHandles();\n    const objectIdsToLoad = this._automergeDocLoader.clearHandleReferences();\n\n    try {\n      await this._automergeDocLoader.loadSpaceRootDocHandle(this._ctx, spaceState);\n      const spaceRootDocHandle = this._automergeDocLoader.getSpaceRootDocHandle();\n      await this._handleSpaceRootDocumentChange(spaceRootDocHandle, objectIdsToLoad);\n      spaceRootDocHandle.on('change', this._onDocumentUpdate);\n    } catch (err) {\n      if (err instanceof ContextDisposedError) {\n        return;\n      }\n      log.catch(err);\n      throw err;\n    }\n  }\n\n  /**\n   * Returns ids for loaded and not loaded objects.\n   */\n  getAllObjectIds(): string[] {\n    if (this._state !== CoreDatabaseState.OPEN) {\n      return [];\n    }\n\n    const hasLoadedHandles = this._automergeDocLoader.getAllHandles().length > 0;\n    if (!hasLoadedHandles) {\n      return [];\n    }\n    const rootDoc = this._automergeDocLoader.getSpaceRootDocHandle().doc();\n    if (!rootDoc) {\n      return [];\n    }\n\n    return [...new Set([...Object.keys(rootDoc.objects ?? {}), ...Object.keys(rootDoc.links ?? {})])];\n  }\n\n  getNumberOfInlineObjects(): number {\n    return Object.keys(this._automergeDocLoader.getSpaceRootDocHandle().doc()?.objects ?? {}).length;\n  }\n\n  getNumberOfLinkedObjects(): number {\n    return Object.keys(this._automergeDocLoader.getSpaceRootDocHandle().doc()?.links ?? {}).length;\n  }\n\n  getTotalNumberOfObjects(): number {\n    return this.getNumberOfInlineObjects() + this.getNumberOfLinkedObjects();\n  }\n\n  /**\n   * @deprecated\n   * Return only loaded objects.\n   */\n  allObjectCores(): ObjectCore[] {\n    return Array.from(this._objects.values());\n  }\n\n  getObjectCoreById(id: string, { load = true }: GetObjectCoreByIdOptions = {}): ObjectCore | undefined {\n    if (!this._automergeDocLoader.hasRootHandle) {\n      throw new Error('Database is not ready.');\n    }\n\n    const objCore = this._objects.get(id);\n    if (load && !objCore) {\n      this._automergeDocLoader.loadObjectDocument(id);\n      return undefined;\n    }\n\n    invariant(objCore instanceof ObjectCore);\n    return objCore;\n  }\n\n  // TODO(Mykola): Reconcile with `getObjectById`.\n  async loadObjectCoreById(\n    objectId: string,\n    { timeout, returnWithUnsatisfiedDeps }: LoadObjectOptions = {},\n  ): Promise<ObjectCore | undefined> {\n    const core = this.getObjectCoreById(objectId);\n    if (core && (returnWithUnsatisfiedDeps || this._areDepsSatisfied(core))) {\n      return core;\n    }\n    const isReady = () => {\n      const core = this.getObjectCoreById(objectId);\n      return core ? returnWithUnsatisfiedDeps || this._areDepsSatisfied(core) : false;\n    };\n    const waitForUpdate = this._updateEvent\n      .waitFor((event) => event.itemsUpdated.some(({ id }) => id === objectId) && isReady())\n      .then(() => this.getObjectCoreById(objectId));\n    this._automergeDocLoader.loadObjectDocument(objectId);\n\n    return timeout ? asyncTimeout(waitForUpdate, timeout) : waitForUpdate;\n  }\n\n  async batchLoadObjectCores(\n    objectIds: string[],\n    {\n      inactivityTimeout = 30_000,\n      returnDeleted = false,\n      returnWithUnsatisfiedDeps = false,\n      failOnTimeout = false,\n    }: {\n      inactivityTimeout?: number;\n      returnDeleted?: boolean;\n      returnWithUnsatisfiedDeps?: boolean;\n      failOnTimeout?: boolean;\n    } = {},\n  ): Promise<(ObjectCore | undefined)[]> {\n    if (!this._automergeDocLoader.hasRootHandle) {\n      throw new Error('Database is not ready.');\n    }\n\n    const result: (ObjectCore | undefined)[] = new Array(objectIds.length);\n    const objectsToLoad: Array<{ id: string; resultIndex: number }> = [];\n    for (let i = 0; i < objectIds.length; i++) {\n      const objectId = objectIds[i];\n\n      if (!this._automergeDocLoader.objectPresent(objectId)) {\n        result[i] = undefined;\n        continue;\n      }\n\n      const core = this.getObjectCoreById(objectId, { load: true });\n      if (!returnDeleted && this._objects.get(objectId)?.isDeleted()) {\n        result[i] = undefined;\n      } else if (!returnWithUnsatisfiedDeps && core && !this._areDepsSatisfied(core)) {\n        result[i] = undefined;\n      } else if (core != null) {\n        result[i] = core;\n      } else {\n        objectsToLoad.push({ id: objectId, resultIndex: i });\n      }\n    }\n    if (objectsToLoad.length === 0) {\n      return result;\n    }\n    const idsToLoad = objectsToLoad.map((v) => v.id);\n    this._automergeDocLoader.loadObjectDocument(idsToLoad);\n\n    const startTime = TRACE_LOADING ? performance.now() : 0;\n    const diagnostics: string[] = [];\n    try {\n      return await new Promise((resolve, reject) => {\n        let unsubscribe: CleanupFn | null = null;\n        let inactivityTimeoutTimer: any | undefined;\n        const scheduleInactivityTimeout = () => {\n          inactivityTimeoutTimer = setTimeout(() => {\n            unsubscribe?.();\n            if (failOnTimeout) {\n              diagnostics.push('inactivity-rejected');\n              reject(new TimeoutError(inactivityTimeout));\n            } else {\n              diagnostics.push('inactivity-resolved');\n              resolve(result);\n            }\n          }, inactivityTimeout);\n        };\n        unsubscribe = this._updateEvent.on(({ itemsUpdated }) => {\n          const updatedIds = itemsUpdated.map((v) => v.id);\n          for (let i = objectsToLoad.length - 1; i >= 0; i--) {\n            const objectToLoad = objectsToLoad[i];\n            if (updatedIds.includes(objectToLoad.id)) {\n              clearTimeout(inactivityTimeoutTimer);\n\n              const isDeleted = this._objects.get(objectToLoad.id)?.isDeleted();\n              const depsUnsatisfied =\n                this._objects.get(objectToLoad.id) && !this._areDepsSatisfied(this._objects.get(objectToLoad.id)!);\n\n              if (!returnDeleted && isDeleted) {\n                diagnostics.push('object-deleted');\n                result[objectToLoad.resultIndex] = undefined;\n              } else if (!returnWithUnsatisfiedDeps && depsUnsatisfied) {\n                diagnostics.push('deps-unsatisfied');\n                result[objectToLoad.resultIndex] = undefined;\n              } else {\n                result[objectToLoad.resultIndex] = this.getObjectCoreById(objectToLoad.id)!;\n              }\n\n              objectsToLoad.splice(i, 1);\n              scheduleInactivityTimeout();\n            }\n          }\n          if (objectsToLoad.length === 0) {\n            clearTimeout(inactivityTimeoutTimer);\n            unsubscribe?.();\n            resolve(result);\n          }\n        });\n        scheduleInactivityTimeout();\n      });\n    } finally {\n      if (TRACE_LOADING) {\n        log.info('loading objects', { objectIds, elapsed: performance.now() - startTime, diagnostics });\n      }\n    }\n  }\n\n  // Odd way to define methods types from a typedef.\n  declare query: QueryFn;\n  static {\n    this.prototype.query = this.prototype._query;\n  }\n\n  private _query(filter?: unknown, options?: QueryOptions) {\n    return new QueryResult(\n      this._createQueryContext(),\n      normalizeQuery(filter, options, { defaultSpaceId: this.spaceId }),\n    );\n  }\n\n  /**\n   * @internal\n   */\n  _createQueryContext(): CoreDatabaseQueryContext {\n    return new CoreDatabaseQueryContext(this, this._queryService);\n  }\n\n  /**\n   * Update objects.\n   */\n  async update(filter: Filter.Any, operation: UpdateOperation): Promise<void> {\n    const ast = filter.ast;\n    if (ast.type !== 'object' || ast.id?.length !== 1) {\n      throw new Error('Only object id filters with one id are currently supported');\n    }\n    const id = ast.id[0];\n\n    const core = this.getObjectCoreById(id);\n    if (!core) {\n      throw new Error(`Object not found: ${id}`);\n    }\n\n    // TODO(dmaretskyi): Nested assignments.\n    core.change((doc) => {\n      for (const key in operation) {\n        if (key === 'id') {\n          continue;\n        }\n        setDeep(doc, [...core.mountPath, DATA_NAMESPACE, key], operation[key]);\n      }\n    });\n\n    await this.flush();\n  }\n\n  // TODO(dmaretskyi): Support meta.\n  async insert(data: InsertData): Promise<AnyObjectData>;\n  async insert(data: InsertBatch): Promise<AnyObjectData[]>;\n  async insert(data: InsertData | InsertBatch) {\n    const isBatch = Array.isArray(data);\n    const dataArray = isBatch ? data : [data];\n\n    const cores = dataArray.map((item) => {\n      const core = createCoreFromInsertData(item);\n      this.addCore(core);\n      return core;\n    });\n\n    await this.flush();\n\n    return isBatch ? cores.map((core) => core.toPlainObject()) : cores[0].toPlainObject();\n  }\n\n  addCore(core: ObjectCore, opts?: AddCoreOptions): void {\n    if (core.database) {\n      // Already in the database.\n      if (core.database !== this) {\n        throw new Error('Object already belongs to another database');\n      }\n\n      if (core.isDeleted()) {\n        core.setDeleted(false);\n      }\n\n      return;\n    }\n\n    invariant(!this._objects.has(core.id));\n    this._objects.set(core.id, core);\n\n    let spaceDocHandle: DocHandleProxy<DatabaseDirectory>;\n    const placement = opts?.placeIn ?? 'linked-doc';\n    switch (placement) {\n      case 'linked-doc': {\n        spaceDocHandle = this._automergeDocLoader.createDocumentForObject(core.id);\n        spaceDocHandle.on('change', this._onDocumentUpdate);\n        break;\n      }\n      // TODO(dmaretskyi): In the future we should forbid object placement in the root doc.\n      case 'root-doc': {\n        spaceDocHandle = this._automergeDocLoader.getSpaceRootDocHandle();\n        this._automergeDocLoader.onObjectBoundToDocument(spaceDocHandle, core.id);\n        break;\n      }\n      default:\n        throw new TypeError(`Unknown object placement: ${placement}`);\n    }\n\n    core.bind({\n      db: this,\n      docHandle: spaceDocHandle,\n      path: ['objects', core.id],\n      assignFromLocalState: true,\n    });\n  }\n\n  removeCore(core: ObjectCore): void {\n    invariant(this._objects.has(core.id));\n    core.setDeleted(true);\n  }\n\n  /**\n   * Removes an object link from the space root document.\n   */\n  unlinkObjects(objectIds: string[]): void {\n    const root = this._automergeDocLoader.getSpaceRootDocHandle();\n    for (const objectId of objectIds) {\n      if (!root.doc().links?.[objectId]) {\n        throw new Error(`Link not found: ${objectId}`);\n      }\n    }\n    root.change((doc) => {\n      for (const objectId of objectIds) {\n        delete doc.links![objectId];\n      }\n    });\n  }\n\n  /**\n   * Removes all objects that are marked as deleted.\n   */\n  async unlinkDeletedObjects({ batchSize = 10 }: { batchSize?: number } = {}): Promise<void> {\n    const idChunks = chunkArray(this.getAllObjectIds(), batchSize);\n    for (const ids of idChunks) {\n      const objects = await this.batchLoadObjectCores(ids, { returnDeleted: true });\n      const toUnlink = objects.filter((o) => o?.isDeleted()).map((o) => o!.id);\n      this.unlinkObjects(toUnlink);\n    }\n  }\n\n  /**\n   * Resets the object to the new state.\n   * Intended way to change the type of the object (for schema migrations).\n   * Any concurrent changes made by other peers will be overwritten.\n   */\n  async atomicReplaceObject(id: ObjectId, params: AtomicReplaceObjectParams): Promise<void> {\n    const { data, type } = params;\n\n    const core = await this.loadObjectCoreById(id);\n    invariant(core);\n\n    const mappedData = deepMapValues(data, (value, recurse) => {\n      if (Ref.isRef(value)) {\n        return { '/': value.dxn.toString() };\n      }\n      return recurse(value);\n    });\n    delete mappedData.id;\n    invariant(mappedData['@type'] === undefined);\n    invariant(mappedData['@meta'] === undefined);\n\n    const existingStruct: ObjectStructure = core.getDecoded([]) as any;\n    const newStruct: ObjectStructure = {\n      ...existingStruct,\n      data: mappedData,\n    };\n\n    if (type !== undefined) {\n      newStruct.system!.type = encodeReference(Reference.fromDXN(type));\n    }\n\n    core.setDecoded([], newStruct);\n  }\n\n  async flush({ disk = true, indexes = false, updates = false }: FlushOptions = {}): Promise<void> {\n    log('flush', { disk, indexes, updates });\n    if (disk) {\n      await this._repoProxy.flush();\n      await this._dataService.flush(\n        { documentIds: this._automergeDocLoader.getAllHandles().map((handle) => handle.documentId) },\n        { timeout: RPC_TIMEOUT },\n      );\n    }\n\n    if (indexes) {\n      await this._dataService.updateIndexes(undefined, { timeout: 0 });\n    }\n\n    if (updates) {\n      await this._updateScheduler.runBlocking();\n    }\n  }\n\n  /**\n   * Returns document heads for all documents in the space.\n   */\n  async getDocumentHeads(): Promise<SpaceDocumentHeads> {\n    const root = this._automergeDocLoader.getSpaceRootDocHandle();\n    const doc = root.doc();\n    if (!doc) {\n      return { heads: {} };\n    }\n\n    const headsStates = await this._dataService.getDocumentHeads(\n      {\n        documentIds: Object.values(doc.links ?? {}).map((link) =>\n          interpretAsDocumentId(link.toString() as AutomergeUrl),\n        ),\n      },\n      { timeout: RPC_TIMEOUT },\n    );\n\n    const heads: Record<string, string[]> = {};\n    for (const state of headsStates.heads.entries ?? []) {\n      heads[state.documentId] = state.heads ?? [];\n    }\n\n    heads[root.documentId] = getHeads(doc);\n\n    return { heads };\n  }\n\n  /**\n   * Ensures that document heads have been replicated on the ECHO host.\n   * Waits for the changes to be flushed to disk.\n   * Does not ensure that this data has been propagated to the client.\n   *\n   * Note:\n   *   For queries to return up-to-date results, the client must call `this.updateIndexes()`.\n   *   This is also why flushing to disk is important.\n   */\n  // TODO(dmaretskyi): Find a way to ensure client propagation.\n  async waitUntilHeadsReplicated(heads: SpaceDocumentHeads): Promise<void> {\n    await this._dataService.waitUntilHeadsReplicated(\n      {\n        heads: {\n          entries: Object.entries(heads.heads).map(([documentId, heads]) => ({ documentId, heads })),\n        },\n      },\n      { timeout: 0 },\n    );\n  }\n\n  /**\n   * Returns document heads for all documents in the space.\n   */\n  async reIndexHeads(): Promise<void> {\n    const root = this._automergeDocLoader.getSpaceRootDocHandle();\n    const doc = root.doc();\n    invariant(doc);\n\n    await this._dataService.reIndexHeads(\n      {\n        documentIds: [\n          root.documentId,\n          ...Object.values(doc.links ?? {}).map((link) => interpretAsDocumentId(link as AutomergeUrl)),\n        ],\n      },\n      { timeout: 0 },\n    );\n  }\n\n  /**\n   * @deprecated Use `flush({ indexes: true })`.\n   */\n  async updateIndexes(): Promise<void> {\n    await this._dataService.updateIndexes(undefined, { timeout: 0 });\n  }\n\n  async getSyncState(): Promise<SpaceSyncState> {\n    const value = await Stream.first(\n      this._dataService.subscribeSpaceSyncState({ spaceId: this.spaceId }, { timeout: RPC_TIMEOUT }),\n    );\n    return value ?? raise(new Error('Failed to get sync state'));\n  }\n\n  subscribeToSyncState(ctx: Context, callback: (state: SpaceSyncState) => void): CleanupFn {\n    const stream = this._dataService.subscribeSpaceSyncState({ spaceId: this.spaceId }, { timeout: RPC_TIMEOUT });\n    stream.subscribe(\n      (data) => {\n        void runInContextAsync(ctx, () => callback(data));\n      },\n      (err) => {\n        if (err) {\n          ctx.raise(err);\n        }\n      },\n    );\n    ctx.onDispose(() => stream.close());\n    return () => stream.close();\n  }\n\n  getLoadedDocumentHandles(): DocHandleProxy<any>[] {\n    return Object.values(this._repoProxy.handles);\n  }\n\n  private async _handleSpaceRootDocumentChange(\n    spaceRootDocHandle: DocHandleProxy<DatabaseDirectory>,\n    objectsToLoad: string[],\n  ): Promise<void> {\n    const spaceRootDoc: DatabaseDirectory = spaceRootDocHandle.doc();\n    const inlinedObjectIds = new Set(Object.keys(spaceRootDoc.objects ?? {}));\n    const linkedObjectIds = new Map(Object.entries(spaceRootDoc.links ?? {}).map(([k, v]) => [k, v.toString()]));\n\n    const objectsToRebind = new Map<string, { handle: DocHandleProxy<DatabaseDirectory>; objectIds: string[] }>();\n    objectsToRebind.set(spaceRootDocHandle.url, { handle: spaceRootDocHandle, objectIds: [] });\n\n    const objectsToRemove: string[] = [];\n    const objectsToCreate = [...inlinedObjectIds.values()].filter((oid) => !this._objects.has(oid));\n\n    for (const object of this._objects.values()) {\n      if (inlinedObjectIds.has(object.id)) {\n        if (spaceRootDocHandle.url === object.docHandle?.url) {\n          continue;\n        }\n        objectsToRebind.get(spaceRootDocHandle.url)!.objectIds.push(object.id);\n      } else if (linkedObjectIds.has(object.id)) {\n        const newObjectDocUrl = linkedObjectIds.get(object.id)!;\n        if (newObjectDocUrl === object.docHandle?.url) {\n          continue;\n        }\n        const existing = objectsToRebind.get(newObjectDocUrl.toString());\n        if (existing != null) {\n          existing.objectIds.push(object.id);\n          continue;\n        }\n        const newDocHandle = this._repoProxy.find(newObjectDocUrl as DocumentId);\n        await newDocHandle.whenReady();\n        newDocHandle.doc();\n        objectsToRebind.set(newObjectDocUrl.toString(), { handle: newDocHandle, objectIds: [object.id] });\n      } else {\n        objectsToRemove.push(object.id);\n      }\n    }\n\n    objectsToRemove.forEach((oid) => this._objects.delete(oid));\n    this._createInlineObjects(spaceRootDocHandle, objectsToCreate);\n    for (const { handle, objectIds } of objectsToRebind.values()) {\n      this._rebindObjects(handle, objectIds);\n    }\n    for (const objectId of objectsToLoad) {\n      if (!this._objects.has(objectId)) {\n        this._automergeDocLoader.loadObjectDocument(objectId);\n      }\n    }\n    this._automergeDocLoader.onObjectLinksUpdated(spaceRootDoc.links);\n    this.rootChanged.emit();\n  }\n\n  private _emitObjectUpdateEvent(itemsUpdated: string[]): void {\n    if (itemsUpdated.length === 0) {\n      return;\n    }\n\n    compositeRuntime.batch(() => {\n      for (const id of itemsUpdated) {\n        const objCore = this._objects.get(id);\n        if (objCore) {\n          objCore.notifyUpdate();\n        }\n      }\n    });\n  }\n\n  /**\n   * Keep as field to have a reference to pass for unsubscribing from handle changes.\n   */\n  private readonly _onDocumentUpdate = (event: ChangeEvent<DatabaseDirectory>) => {\n    const documentChanges = this._processDocumentUpdate(event);\n    this._rebindObjects(event.handle, documentChanges.objectsToRebind);\n    this._automergeDocLoader.onObjectLinksUpdated(documentChanges.linkedDocuments);\n    this._createInlineObjects(event.handle, documentChanges.createdObjectIds);\n    this._emitObjectUpdateEvent(documentChanges.updatedObjectIds);\n    this._scheduleThrottledDbUpdate(documentChanges.updatedObjectIds);\n  };\n\n  private _processDocumentUpdate(event: ChangeEvent<DatabaseDirectory>): DocumentChanges {\n    const { inlineChangedObjects, linkedDocuments } = getInlineAndLinkChanges(event);\n    const createdObjectIds: string[] = [];\n    const objectsToRebind: string[] = [];\n    for (const updatedObject of inlineChangedObjects) {\n      const objectCore = this._objects.get(updatedObject);\n      if (!objectCore) {\n        createdObjectIds.push(updatedObject);\n      } else if (objectCore?.docHandle && objectCore.docHandle.url !== event.handle.url) {\n        log.verbose('object bound to incorrect document, going to rebind', {\n          updatedObject,\n          documentUrl: objectCore.docHandle.url,\n          actualUrl: event.handle.url,\n        });\n        objectsToRebind.push(updatedObject);\n      }\n    }\n\n    return {\n      updatedObjectIds: inlineChangedObjects,\n      objectsToRebind,\n      createdObjectIds,\n      linkedDocuments,\n    };\n  }\n\n  private _unsubscribeFromHandles(): void {\n    for (const docHandle of Object.values(this._repoProxy.handles)) {\n      docHandle.off('change', this._onDocumentUpdate);\n    }\n  }\n\n  private _onObjectDocumentLoaded({ handle, objectId }: ObjectDocumentLoaded): void {\n    handle.on('change', this._onDocumentUpdate);\n    const core = this._createObjectInDocument(handle, objectId);\n    if (this._areDepsSatisfied(core)) {\n      this._scheduleThrottledUpdate([objectId]);\n    } else {\n      for (const dep of core.getStrongDependencies()) {\n        if (dep.isLocalObjectId()) {\n          const id = dep.parts[1];\n          this._automergeDocLoader.loadObjectDocument(id);\n        }\n      }\n    }\n    for (const dep of this._strongDepsIndex.get(objectId) ?? []) {\n      const core = this._objects.get(dep);\n      if (core && this._areDepsSatisfied(core)) {\n        this._scheduleThrottledUpdate([core.id]);\n      }\n    }\n  }\n\n  /**\n   * Loads all objects on open and handles objects that are being created not by this client.\n   */\n  private _createInlineObjects(docHandle: DocHandleProxy<DatabaseDirectory>, objectIds: string[]): void {\n    for (const id of objectIds) {\n      invariant(!this._objects.has(id));\n      this._createObjectInDocument(docHandle, id);\n    }\n  }\n\n  private _createObjectInDocument(docHandle: DocHandleProxy<DatabaseDirectory>, objectId: string): ObjectCore {\n    invariant(!this._objects.get(objectId));\n    const core = new ObjectCore();\n    core.id = objectId;\n    this._objects.set(core.id, core);\n    this._automergeDocLoader.onObjectBoundToDocument(docHandle, objectId);\n    core.bind({\n      db: this,\n      docHandle,\n      path: ['objects', core.id],\n      assignFromLocalState: false,\n    });\n\n    const deps = core.getStrongDependencies();\n    for (const dxn of deps) {\n      if (!dxn.isLocalObjectId()) {\n        continue;\n      }\n      const depObjectId = dxn.parts[1];\n      if (this._objects.has(depObjectId)) {\n        continue;\n      }\n\n      defaultMap(this._strongDepsIndex, depObjectId, []).push(core.id);\n    }\n\n    return core;\n  }\n\n  private _areDepsSatisfied(core: ObjectCore, seen?: Set<ObjectId>): boolean {\n    seen ??= new Set<ObjectId>();\n    const deps = core.getStrongDependencies();\n\n    seen.add(core.id);\n    return deps.every((dep) => {\n      if (!dep.isLocalObjectId()) {\n        return true;\n      }\n      const depObjectId = dep.parts[1];\n      const depCore = this._objects.get(depObjectId);\n      if (!depCore) {\n        return false;\n      }\n      if (seen.has(depCore.id)) {\n        return true;\n      }\n      return this._areDepsSatisfied(depCore, seen);\n    });\n  }\n\n  private _rebindObjects(docHandle: DocHandleProxy<DatabaseDirectory>, objectIds: string[]): void {\n    for (const objectId of objectIds) {\n      const objectCore = this._objects.get(objectId);\n      invariant(objectCore);\n      objectCore.bind({\n        db: this,\n        docHandle,\n        path: objectCore.mountPath,\n        assignFromLocalState: false,\n      });\n      this._automergeDocLoader.onObjectBoundToDocument(docHandle, objectId);\n    }\n  }\n\n  /**\n   * Throttled db query updates. Signal updates were already emitted for these objects to immediately\n   * update the UI. This happens for locally changed objects (_onDocumentUpdate).\n   */\n  private _objectsForNextDbUpdate = new Set<string>();\n  /**\n   * Objects for which we throttled a db update event and a signal update event.\n   * This happens for objects which were loaded for the first time (_onObjectDocumentLoaded).\n   */\n  private _objectsForNextUpdate = new Set<string>();\n  private readonly _updateScheduler = new UpdateScheduler(this._ctx, async () => this._emitDbUpdateEvents(), {\n    maxFrequency: THROTTLED_UPDATE_FREQUENCY,\n  });\n\n  @trace.span({ showInBrowserTimeline: true })\n  private _emitDbUpdateEvents(): void {\n    const fullUpdateIds = [...this._objectsForNextUpdate];\n    const allDbUpdates = new Set([...this._objectsForNextUpdate, ...this._objectsForNextDbUpdate]);\n    this._objectsForNextUpdate.clear();\n    this._objectsForNextDbUpdate.clear();\n\n    compositeRuntime.batch(() => {\n      if (allDbUpdates.size > 0) {\n        this._updateEvent.emit({\n          spaceId: this.spaceId,\n          itemsUpdated: [...allDbUpdates].map((id) => ({ id })),\n        });\n      }\n      this._emitObjectUpdateEvent(fullUpdateIds);\n    });\n  }\n\n  // TODO(dmaretskyi): Pass all remote updates through this.\n  // Scheduled db and signal update events.\n  private _scheduleThrottledUpdate(objectId: string[]): void {\n    for (const id of objectId) {\n      this._objectsForNextUpdate.add(id);\n    }\n    if (DISABLE_THROTTLING) {\n      this._updateScheduler.forceTrigger();\n    } else {\n      this._updateScheduler.trigger();\n    }\n  }\n\n  // Scheduled db update event only.\n  private _scheduleThrottledDbUpdate(objectId: string[]): void {\n    for (const id of objectId) {\n      this._objectsForNextDbUpdate.add(id);\n    }\n    if (DISABLE_THROTTLING) {\n      this._updateScheduler.forceTrigger();\n    } else {\n      this._updateScheduler.trigger();\n    }\n  }\n}\n\nexport interface ItemsUpdatedEvent {\n  spaceId: SpaceId;\n  itemsUpdated: Array<{ id: string }>;\n}\n\nexport type LoadObjectOptions = {\n  timeout?: number;\n  /**\n   * Will not eagerly preload strong deps.\n   */\n  returnWithUnsatisfiedDeps?: boolean;\n};\n\nenum CoreDatabaseState {\n  CLOSED,\n  OPENING,\n  OPEN,\n}\n\nexport type SpaceDocumentHeads = {\n  /**\n   * DocumentId => Heads.\n   */\n  heads: Record<string, string[]>;\n};\n\nexport type GetObjectCoreByIdOptions = {\n  /**\n   * Request the object to be loaded if it is not already loaded.\n   * @default true\n   */\n  load?: boolean;\n};\n\nexport type AtomicReplaceObjectParams = {\n  /**\n   * Update data.\n   * NOTE: This is not merged with the existing data.\n   */\n  data: any;\n\n  /**\n   * Update object type.\n   */\n  type?: DXN;\n};\n\nexport type FlushOptions = {\n  /**\n   * Write any pending changes to disk.\n   * @default true\n   */\n  disk?: boolean;\n\n  /**\n   * Wait for pending index updates.\n   * @default false\n   */\n  indexes?: boolean;\n\n  /**\n   * Flush pending updates to objects and queries.\n   * @default false\n   */\n  updates?: boolean;\n};\n\nconst RPC_TIMEOUT = 20_000;\n\nconst DISABLE_THROTTLING = true;\n\nconst sanitizeTypename = (typename: string): DXN => {\n  if (typename.startsWith('dxn:')) {\n    return DXN.parse(typename);\n  } else {\n    if (typename.includes(':')) {\n      throw new Error(`Invalid typename: ${typename}`);\n    }\n    return new DXN(DXN.kind.TYPE, [typename]);\n  }\n};\n\nconst createCoreFromInsertData = (data: InsertData): ObjectCore => {\n  if ('id' in data) {\n    throw new Error('Cannot insert object with id');\n  }\n\n  const { __typename, ...rest } = data;\n  let type: DXN | undefined;\n  if (__typename) {\n    type = sanitizeTypename(__typename);\n  }\n\n  const fieldsMapped = deepMapValues(rest, (value, recurse) => {\n    if (isEncodedReference(value)) {\n      if (value['/'].startsWith('dxn:')) {\n        return value;\n      } else {\n        return { '/': new DXN(DXN.kind.ECHO, [LOCAL_SPACE_TAG, value['/']]).toString() };\n      }\n    } else {\n      return recurse(value);\n    }\n  });\n\n  const core = new ObjectCore();\n  core.initNewObject(fieldsMapped);\n  if (type) {\n    core.setType(Reference.fromDXN(type));\n  }\n  return core;\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { next as A } from '@automerge/automerge';\nimport { type AutomergeUrl, type DocumentId, interpretAsDocumentId } from '@automerge/automerge-repo';\n\nimport { Event } from '@dxos/async';\nimport { cancelWithContext, type Context } from '@dxos/context';\nimport { warnAfterTimeout } from '@dxos/debug';\nimport { type SpaceState, DatabaseDirectory, SpaceDocVersion } from '@dxos/echo-protocol';\nimport { assertState, invariant } from '@dxos/invariant';\nimport { type ObjectId, type PublicKey, type SpaceId } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { trace } from '@dxos/tracing';\nimport { ComplexSet } from '@dxos/util';\n\nimport { type RepoProxy, type DocHandleProxy } from '../automerge';\n\ntype SpaceDocumentLinks = DatabaseDirectory['links'];\n\nexport interface AutomergeDocumentLoader {\n  onObjectDocumentLoaded: Event<ObjectDocumentLoaded>;\n\n  get hasRootHandle(): boolean;\n\n  getAllHandles(): DocHandleProxy<DatabaseDirectory>[];\n  /**\n   * @returns Handles linked from the space root handle.\n   */\n  getLinkedDocHandles(): DocHandleProxy<DatabaseDirectory>[];\n\n  objectPresent(id: ObjectId): boolean;\n  loadSpaceRootDocHandle(ctx: Context, spaceState: SpaceState): Promise<void>;\n  loadObjectDocument(objectId: string | string[]): void;\n  getObjectDocumentId(objectId: string): string | undefined;\n  getSpaceRootDocHandle(): DocHandleProxy<DatabaseDirectory>;\n  createDocumentForObject(objectId: string): DocHandleProxy<DatabaseDirectory>;\n  onObjectLinksUpdated(links: SpaceDocumentLinks): void;\n  onObjectBoundToDocument(handle: DocHandleProxy<DatabaseDirectory>, objectId: string): void;\n\n  /**\n   * @returns objectIds for which we had document handles or were loading one.\n   */\n  clearHandleReferences(): string[];\n}\n\n/**\n * Manages object <-> docHandle binding and automerge document loading.\n */\n@trace.resource()\nexport class AutomergeDocumentLoaderImpl implements AutomergeDocumentLoader {\n  private _spaceRootDocHandle: DocHandleProxy<DatabaseDirectory> | null = null;\n  /**\n   * An object id pointer to a handle of the document where the object is stored inline.\n   */\n  private readonly _objectDocumentHandles = new Map<string, DocHandleProxy<DatabaseDirectory>>();\n  /**\n   * If object was requested via loadObjectDocument but root document links weren't updated yet\n   * loading will be triggered in onObjectLinksUpdated callback.\n   */\n  private readonly _objectsPendingDocumentLoad = new Set<string>();\n\n  /**\n   * Keeps track of objects that are currently being loaded.\n   * Prevents multiple concurrent loads of the same document.\n   * This can happen on SpaceRootHandle switch because we don't cancel the previous load.\n   */\n  private readonly _currentlyLoadingObjects = new ComplexSet<{ url: AutomergeUrl; objectId: string }>(\n    ({ url, objectId }) => `${url}:${objectId}`,\n  );\n\n  public readonly onObjectDocumentLoaded = new Event<ObjectDocumentLoaded>();\n\n  constructor(\n    private readonly _repo: RepoProxy,\n    private readonly _spaceId: SpaceId,\n    /** Legacy Id */\n    private readonly _spaceKey: PublicKey,\n  ) {}\n\n  get hasRootHandle(): boolean {\n    return this._spaceRootDocHandle != null;\n  }\n\n  getAllHandles(): DocHandleProxy<DatabaseDirectory>[] {\n    return this._spaceRootDocHandle != null\n      ? [this._spaceRootDocHandle, ...new Set(this._objectDocumentHandles.values())]\n      : [];\n  }\n\n  getLinkedDocHandles(): DocHandleProxy<DatabaseDirectory>[] {\n    return [...new Set(this._objectDocumentHandles.values())];\n  }\n\n  @trace.span({ showInBrowserTimeline: true })\n  public async loadSpaceRootDocHandle(ctx: Context, spaceState: SpaceState): Promise<void> {\n    if (this._spaceRootDocHandle != null) {\n      return;\n    }\n    if (!spaceState.rootUrl) {\n      throw new Error('Database opened with no rootUrl');\n    }\n\n    const existingDocHandle = await this._initDocHandle(ctx, spaceState.rootUrl);\n    const doc = existingDocHandle.doc();\n    invariant(doc);\n    invariant(doc.version === SpaceDocVersion.CURRENT);\n    if (doc.access == null) {\n      this._initDocAccess(existingDocHandle);\n    }\n    this._spaceRootDocHandle = existingDocHandle;\n  }\n\n  objectPresent(id: ObjectId): boolean {\n    assertState(this._spaceRootDocHandle, 'Database was not initialized with root object.');\n    return (\n      DatabaseDirectory.getInlineObject(this._spaceRootDocHandle.doc(), id) != null ||\n      DatabaseDirectory.getLink(this._spaceRootDocHandle.doc(), id) != null\n    );\n  }\n\n  public loadObjectDocument(objectIdOrMany: string | string[]): void {\n    const objectIds = Array.isArray(objectIdOrMany) ? objectIdOrMany : [objectIdOrMany];\n    let hasUrlsToLoad = false;\n    const urlsToLoad: DatabaseDirectory['links'] = {};\n    for (const objectId of objectIds) {\n      invariant(this._spaceRootDocHandle, 'Database was not initialized with root object.');\n      if (this._objectDocumentHandles.has(objectId) || this._objectsPendingDocumentLoad.has(objectId)) {\n        continue;\n      }\n      const documentUrl = this._getLinkedDocumentUrl(objectId);\n      if (documentUrl == null) {\n        this._objectsPendingDocumentLoad.add(objectId);\n        log('loading delayed until object links are initialized', { objectId });\n      } else {\n        urlsToLoad[objectId] = documentUrl;\n        hasUrlsToLoad = true;\n      }\n    }\n    if (hasUrlsToLoad) {\n      this._loadLinkedObjects(urlsToLoad);\n    }\n  }\n\n  public getObjectDocumentId(objectId: string): string | undefined {\n    invariant(this._spaceRootDocHandle, 'Database was not initialized with root object.');\n    const spaceRootDoc = this._spaceRootDocHandle.doc();\n    invariant(spaceRootDoc);\n    if (spaceRootDoc.objects?.[objectId]) {\n      return this._spaceRootDocHandle.documentId;\n    }\n    const documentUrl = this._getLinkedDocumentUrl(objectId);\n    return documentUrl && interpretAsDocumentId(documentUrl.toString() as AutomergeUrl);\n  }\n\n  public onObjectLinksUpdated(links: SpaceDocumentLinks): void {\n    if (!links) {\n      return;\n    }\n    const linksAwaitingLoad = Object.entries(links).filter(([objectId]) =>\n      this._objectsPendingDocumentLoad.has(objectId),\n    );\n    this._loadLinkedObjects(Object.fromEntries(linksAwaitingLoad));\n    linksAwaitingLoad.forEach(([objectId]) => this._objectsPendingDocumentLoad.delete(objectId));\n  }\n\n  public getSpaceRootDocHandle(): DocHandleProxy<DatabaseDirectory> {\n    invariant(this._spaceRootDocHandle, 'Database was not initialized with root object.');\n    return this._spaceRootDocHandle;\n  }\n\n  public createDocumentForObject(objectId: string): DocHandleProxy<DatabaseDirectory> {\n    invariant(this._spaceRootDocHandle, 'Database was not initialized with root object.');\n    const spaceDocHandle = this._repo.create<DatabaseDirectory>({\n      version: SpaceDocVersion.CURRENT,\n      access: { spaceKey: this._spaceKey.toHex() },\n    });\n    this.onObjectBoundToDocument(spaceDocHandle, objectId);\n    this._spaceRootDocHandle.change((newDoc: DatabaseDirectory) => {\n      newDoc.links ??= {};\n      newDoc.links[objectId] = new A.RawString(spaceDocHandle.url);\n    });\n    return spaceDocHandle;\n  }\n\n  public onObjectBoundToDocument(handle: DocHandleProxy<DatabaseDirectory>, objectId: string): void {\n    this._objectDocumentHandles.set(objectId, handle);\n  }\n\n  public clearHandleReferences(): string[] {\n    const objectsWithHandles = [...this._objectDocumentHandles.keys()];\n    this._objectDocumentHandles.clear();\n    this._spaceRootDocHandle = null;\n    return objectsWithHandles;\n  }\n\n  private _getLinkedDocumentUrl(objectId: string): AutomergeUrl | undefined {\n    const spaceRootDoc = this._spaceRootDocHandle?.doc();\n    invariant(spaceRootDoc);\n    return (spaceRootDoc.links ?? {})[objectId]?.toString() as AutomergeUrl;\n  }\n\n  private _loadLinkedObjects(links: SpaceDocumentLinks): void {\n    if (!links) {\n      return;\n    }\n    for (const [objectId, automergeUrlData] of Object.entries(links)) {\n      const automergeUrl = automergeUrlData.toString();\n      const logMeta = { objectId, automergeUrl };\n      const objectDocumentHandle = this._objectDocumentHandles.get(objectId);\n      if (objectDocumentHandle != null && objectDocumentHandle.url !== automergeUrl) {\n        log.warn('object already inlined in a different document, ignoring the link', {\n          ...logMeta,\n          actualDocumentUrl: objectDocumentHandle.url,\n        });\n        continue;\n      }\n      if (objectDocumentHandle?.url === automergeUrl) {\n        log.warn('object document was already loaded', logMeta);\n        continue;\n      }\n      const handle = this._repo.find<DatabaseDirectory>(automergeUrl as DocumentId);\n      log.debug('document loading triggered', logMeta);\n      this._objectDocumentHandles.set(objectId, handle);\n      void this._loadHandleForObject(handle, objectId);\n    }\n  }\n\n  private async _initDocHandle(ctx: Context, url: string): Promise<DocHandleProxy<DatabaseDirectory>> {\n    const docHandle = this._repo.find<DatabaseDirectory>(url as DocumentId);\n    await warnAfterTimeout(5_000, 'Automerge root doc load timeout (CoreDatabase)', async () => {\n      await cancelWithContext(ctx, docHandle.whenReady()); // TODO(dmaretskyi): Temporary 5s timeout for debugging.\n    });\n\n    return docHandle;\n  }\n\n  private _initDocAccess(handle: DocHandleProxy<DatabaseDirectory>): void {\n    handle.change((newDoc: DatabaseDirectory) => {\n      newDoc.access ??= { spaceKey: this._spaceKey.toHex() };\n      newDoc.access.spaceKey = this._spaceKey.toHex();\n    });\n  }\n\n  private async _loadHandleForObject(handle: DocHandleProxy<DatabaseDirectory>, objectId: string): Promise<void> {\n    try {\n      if (this._currentlyLoadingObjects.has({ url: handle.url, objectId })) {\n        log.warn('document is already loading', { objectId });\n        return;\n      }\n      this._currentlyLoadingObjects.add({ url: handle.url, objectId });\n      await handle.whenReady();\n      this._currentlyLoadingObjects.delete({ url: handle.url, objectId });\n\n      const logMeta = { objectId, docUrl: handle.url };\n      if (this.onObjectDocumentLoaded.listenerCount() === 0) {\n        log.info('document loaded after all listeners were removed', logMeta);\n        return;\n      }\n      const objectDocHandle = this._objectDocumentHandles.get(objectId);\n      if (objectDocHandle?.url !== handle.url) {\n        log.warn('object was rebound while a document was loading, discarding handle', logMeta);\n        return;\n      }\n      this.onObjectDocumentLoaded.emit({ handle, objectId });\n    } catch (err) {\n      this._currentlyLoadingObjects.delete({ url: handle.url, objectId });\n      const shouldRetryLoading = this.onObjectDocumentLoaded.listenerCount() > 0;\n      log.warn('failed to load a document', {\n        objectId,\n        automergeUrl: handle.url,\n        retryLoading: shouldRetryLoading,\n        err,\n      });\n      if (shouldRetryLoading) {\n        await this._loadHandleForObject(handle, objectId);\n      }\n    }\n  }\n}\n\nexport interface ObjectDocumentLoaded {\n  handle: DocHandleProxy<DatabaseDirectory>;\n  objectId: string;\n}\n\nexport interface DocumentChanges {\n  createdObjectIds: string[];\n  updatedObjectIds: string[];\n  objectsToRebind: string[];\n  linkedDocuments: {\n    [echoId: string]: AutomergeUrl;\n  };\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { next as A } from '@automerge/automerge';\n\nimport { Event } from '@dxos/async';\nimport { Stream } from '@dxos/codec-protobuf/stream';\nimport { Context } from '@dxos/context';\nimport { filterMatchObject } from '@dxos/echo-pipeline/filter';\nimport { isEncodedReference, type DatabaseDirectory, type QueryAST } from '@dxos/echo-protocol';\nimport { type AnyEchoObject, type AnyObjectData } from '@dxos/echo-schema';\nimport { invariant } from '@dxos/invariant';\nimport { DXN, PublicKey, SpaceId } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport {\n  QueryReactivity,\n  type QueryService,\n  type QueryResult as RemoteQueryResult,\n} from '@dxos/protocols/proto/dxos/echo/query';\nimport { isNonNullable } from '@dxos/util';\n\nimport type { CoreDatabase } from './core-database';\nimport type { ObjectCore } from './object-core';\nimport { isSimpleSelectionQuery, type QueryContext, type QueryJoinSpec, type QueryResultEntry } from '../query';\n\nconst QUERY_SERVICE_TIMEOUT = 20_000;\n\n/**\n * Services plain data queries from the CoreDatabase class\n */\n// TODO(dmaretskyi): Restructure client-side query sub-systems: working-set query, host query (via service), remote agent/edge query\nexport class CoreDatabaseQueryContext implements QueryContext {\n  private _lastResult: QueryResultEntry<any>[] = [];\n\n  readonly changed = new Event();\n\n  constructor(\n    private readonly _coreDatabase: CoreDatabase,\n    private readonly _queryService: QueryService,\n  ) {}\n\n  // TODO(dmaretskyi): Make async.\n  start(): void {}\n\n  // TODO(dmaretskyi): Make async.\n  stop(): void {}\n\n  getResults(): QueryResultEntry<any>[] {\n    return this._lastResult;\n  }\n\n  async run(query: QueryAST.Query): Promise<QueryResultEntry<any>[]> {\n    const queryId = nextQueryId++;\n    // Disposed when this method exists.\n    await using ctx = new Context();\n\n    const start = Date.now();\n\n    // Special case for object id filter.\n    const trivial = isSimpleSelectionQuery(query);\n    if (!trivial) {\n      return [];\n    }\n    const { filter, options: _options } = trivial;\n\n    if (filter.type === 'object' && filter.id?.length === 1) {\n      const core = await this._coreDatabase.loadObjectCoreById(filter.id[0]);\n\n      if (!core || ctx.disposed) {\n        return [];\n      }\n\n      return (await Promise.all([this._filterMapCore(filter, core, start, undefined)])).filter(isNonNullable);\n    }\n\n    // TODO(dmaretskyi): Ensure the space id is set on filter.\n    const response = await Stream.first(\n      this._queryService.execQuery(\n        { query: JSON.stringify(query), reactivity: QueryReactivity.ONE_SHOT },\n        { timeout: QUERY_SERVICE_TIMEOUT },\n      ),\n    );\n\n    if (!response) {\n      throw new Error('Query terminated without a response.');\n    }\n\n    log('raw results', {\n      queryId,\n      length: response.results?.length ?? 0,\n    });\n\n    const processedResults = await Promise.all(\n      (response.results ?? []).map((result) => this._filterMapResult(ctx, filter, start, result)),\n    );\n    const results = processedResults.filter(isNonNullable);\n\n    // TODO(dmaretskyi): Merge in results from local working set.\n\n    log('processed results', {\n      queryId,\n      fetchedFromIndex: response.results?.length ?? 0,\n      loaded: results.length,\n    });\n\n    // TODO(dmaretskyi): Limit.\n    // if (typeof filter.options.limit === 'number') {\n    //   results = results.slice(0, filter.options.limit);\n    // }\n\n    return results;\n  }\n\n  update(query: QueryAST.Query): void {}\n\n  private async _filterMapResult(\n    ctx: Context,\n    filter: QueryAST.Filter,\n    queryStartTimestamp: number,\n    result: RemoteQueryResult,\n  ): Promise<QueryResultEntry | null> {\n    if (!SpaceId.isValid(result.spaceId)) {\n      log.warn('dropping result with invalid space id', { id: result.id, spaceId: result.spaceId });\n      return null;\n    }\n\n    /**\n     * Ignore data in the query result and fetch documents through DataService & RepoProxy.\n     */\n    const FORCE_DATA_SERVICE_FETCH = true;\n\n    if (!FORCE_DATA_SERVICE_FETCH && result.documentJson) {\n      // Return JSON snapshot.\n      return {\n        id: result.id,\n        spaceId: result.spaceId as SpaceId,\n        spaceKey: PublicKey.ZERO,\n        object: JSON.parse(result.documentJson),\n        match: { rank: result.rank },\n        resolution: { source: 'remote', time: Date.now() - queryStartTimestamp },\n      } satisfies QueryResultEntry;\n    } else if (!FORCE_DATA_SERVICE_FETCH && result.documentAutomerge) {\n      // Return snapshot from automerge CRDT.\n      const doc = A.load(result.documentAutomerge) as DatabaseDirectory;\n\n      const object = doc.objects?.[result.id];\n      if (!object) {\n        return null;\n      }\n\n      return {\n        id: result.id,\n        spaceId: result.spaceId as SpaceId,\n        spaceKey: PublicKey.ZERO,\n        object: object as unknown as AnyEchoObject, // TODO(burdon): ???\n        match: { rank: result.rank },\n        resolution: { source: 'remote', time: Date.now() - queryStartTimestamp },\n      } satisfies QueryResultEntry;\n    } else {\n      // Return CRDT from data service.\n      const objectDocId = this._coreDatabase._automergeDocLoader.getObjectDocumentId(result.id);\n      if (objectDocId !== result.documentId) {\n        log(\"documentIds don't match\", {\n          objectId: result.id,\n          expected: result.documentId,\n          actual: objectDocId ?? null,\n        });\n        return null;\n      }\n\n      const core = await this._coreDatabase.loadObjectCoreById(result.id);\n      if (!core || ctx.disposed) {\n        return null;\n      }\n\n      return this._filterMapCore(filter, core, queryStartTimestamp, result);\n    }\n  }\n\n  private async _filterMapCore(\n    filter: QueryAST.Filter,\n    core: ObjectCore,\n    queryStartTimestamp: number,\n    result: RemoteQueryResult | undefined,\n  ): Promise<QueryResultEntry | null> {\n    if (\n      !filterMatchObject(filter, {\n        doc: core.getObjectStructure(),\n        id: core.id,\n        spaceId: core.database!.spaceId,\n      })\n    ) {\n      return null;\n    }\n\n    // TODO(dmaretskyi): Joins.\n    // if (filter.options.include) {\n    //   validateJoinSpec(filter.options.include);\n    // }\n\n    // const data = await this._recursivelyJoinFields(core.toPlainObject(), filter.options.include);\n\n    return {\n      id: core.id,\n      spaceId: core.database!.spaceId,\n      spaceKey: core.database!.spaceKey,\n      object: core.toPlainObject(),\n      match: result && { rank: result.rank },\n      resolution: { source: 'remote', time: Date.now() - queryStartTimestamp },\n    } satisfies QueryResultEntry;\n  }\n\n  private async _recursivelyJoinFields(\n    data: AnyObjectData,\n    joinSpec: QueryJoinSpec | undefined,\n  ): Promise<AnyObjectData> {\n    if (!joinSpec) {\n      return data;\n    }\n\n    const newData = { ...data };\n    for (const [key, spec] of Object.entries(joinSpec)) {\n      if (spec === true || (typeof spec === 'object' && spec !== null)) {\n        if (isEncodedReference(newData[key])) {\n          const dxn = DXN.parse(newData[key]['/']);\n          invariant(dxn.isLocalObjectId());\n          const core = await this._coreDatabase.loadObjectCoreById(dxn.parts[1]);\n          newData[key] = core\n            ? await this._recursivelyJoinFields(core.toPlainObject(), spec !== true ? spec : undefined)\n            : null;\n        } else {\n          throw new Error(`Invalid join spec: ${spec}`);\n        }\n      }\n    }\n    return newData;\n  }\n}\n\n/**\n * Used for logging.\n */\nlet nextQueryId = 1;\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { type Patch, next as A } from '@automerge/automerge';\nimport { isValidAutomergeUrl } from '@automerge/automerge-repo';\n\nimport { type DatabaseDirectory } from '@dxos/echo-protocol';\n\nimport { type DocumentChanges } from './automerge-doc-loader';\nimport { type ChangeEvent } from '../automerge';\n\nexport const getInlineAndLinkChanges = (event: ChangeEvent<DatabaseDirectory>) => {\n  const inlineChangedObjectIds = new Set<string>();\n  const linkedDocuments: DocumentChanges['linkedDocuments'] = {};\n  for (const { path, value } of event.patches as (Patch & { value: any })[]) {\n    if (path.length < 2) {\n      continue;\n    }\n    switch (path[0]) {\n      case 'objects':\n        if (path.length >= 2) {\n          inlineChangedObjectIds.add(path[1] as string);\n        }\n        break;\n      case 'links':\n        if (path.length >= 2 && (typeof value === 'string' || value instanceof A.RawString)) {\n          const valueStr = value.toString();\n          if (isValidAutomergeUrl(valueStr)) {\n            linkedDocuments[path[1]] = valueStr;\n          }\n        }\n        break;\n    }\n  }\n  return {\n    inlineChangedObjects: [...inlineChangedObjectIds],\n    linkedDocuments,\n  };\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport type * as A from '@automerge/automerge';\nimport { Schema } from 'effect';\nimport { type InspectOptionsStylized } from 'node:util';\n\nimport { devtoolsFormatter, type DevtoolsFormatter, inspectCustom } from '@dxos/debug';\nimport { DATA_NAMESPACE, encodeReference, type ObjectStructure, PROPERTY_ID, Reference } from '@dxos/echo-protocol';\nimport {\n  ATTR_META,\n  ATTR_TYPE,\n  type BaseObject,\n  defineHiddenProperty,\n  DeletedId,\n  EchoSchema,\n  EntityKind,\n  EntityKindId,\n  getRefSavedTarget,\n  getTypeAnnotation,\n  isInstanceOf,\n  MetaId,\n  type ObjectMeta,\n  ObjectMetaSchema,\n  Ref,\n  RefImpl,\n  RelationSourceId,\n  RelationTargetId,\n  SchemaId,\n  SchemaMetaSymbol,\n  SchemaValidator,\n  setRefResolver,\n  StoredSchema,\n  TypeId,\n  type BaseEchoObject,\n  getEntityKind,\n  getSchema,\n  requireTypeReference,\n  RelationTargetDXNId,\n  RelationSourceDXNId,\n  assertObjectModelShape,\n} from '@dxos/echo-schema';\nimport { invariant, assertArgument } from '@dxos/invariant';\nimport { DXN } from '@dxos/keys';\nimport {\n  createProxy,\n  getProxyHandler,\n  getProxyTarget,\n  isLiveObject,\n  type Live,\n  type ReactiveHandler,\n  symbolIsProxy,\n} from '@dxos/live-object';\nimport { getMeta, getProxySlot } from '@dxos/live-object';\nimport { log } from '@dxos/log';\nimport { deepMapValues, defaultMap, getDeep, setDeep } from '@dxos/util';\n\nimport { getBody, getHeader } from './devtools-formatter';\nimport { EchoArray } from './echo-array';\nimport { ObjectInternals } from './echo-proxy-target';\nimport {\n  type ProxyTarget,\n  symbolHandler,\n  symbolInternals,\n  symbolNamespace,\n  symbolPath,\n  TargetKey,\n} from './echo-proxy-target';\nimport { type DecodedAutomergePrimaryValue, type KeyPath, META_NAMESPACE, ObjectCore } from '../core-db';\nimport { type EchoDatabase } from '../proxy-db';\n\n/**\n * Shared for all targets within one ECHO object.\n * @internal\n */\nexport class EchoReactiveHandler implements ReactiveHandler<ProxyTarget> {\n  public static readonly instance = new EchoReactiveHandler();\n\n  _proxyMap = new WeakMap<object, any>();\n\n  init(target: ProxyTarget): void {\n    invariant(target[symbolInternals]);\n    invariant(!(target as any)[symbolIsProxy]);\n    invariant(Array.isArray(target[symbolPath]));\n\n    // Clear extra keys from objects\n    if (!Array.isArray(target)) {\n      for (const key in target) {\n        if (typeof key !== 'symbol') {\n          delete (target as any)[key];\n        }\n      }\n    }\n\n    defineHiddenProperty(target, symbolHandler, this);\n\n    // Maybe have been set by `create`.\n    Object.defineProperty(target, inspectCustom, {\n      enumerable: false,\n      configurable: true,\n      value: this._inspect.bind(target),\n    });\n  }\n\n  ownKeys(target: ProxyTarget): ArrayLike<string | symbol> {\n    target[symbolInternals].signal.notifyRead();\n\n    const { value } = this._getDecodedValueAtPath(target);\n    const keys = typeof value === 'object' ? Reflect.ownKeys(value) : [];\n    if (isRootDataObject(target)) {\n      keys.push(PROPERTY_ID);\n    }\n    return keys;\n  }\n\n  getOwnPropertyDescriptor(target: ProxyTarget, p: string | symbol): PropertyDescriptor | undefined {\n    const { value } = this._getDecodedValueAtPath(target);\n    if (isRootDataObject(target) && p === PROPERTY_ID) {\n      return { enumerable: true, configurable: true, writable: false };\n    }\n    return typeof value === 'object' ? Reflect.getOwnPropertyDescriptor(value, p) : undefined;\n  }\n\n  defineProperty(target: ProxyTarget, property: string | symbol, attributes: PropertyDescriptor): boolean {\n    return this.set(target, property, attributes.value, target);\n  }\n\n  has(target: ProxyTarget, p: string | symbol): boolean {\n    if (target instanceof EchoArray) {\n      return this._arrayHas(target, p);\n    }\n\n    const { value } = this._getDecodedValueAtPath(target);\n    return typeof value === 'object' ? Reflect.has(value, p) : false;\n  }\n\n  get(target: ProxyTarget, prop: string | symbol, receiver: any): any {\n    invariant(Array.isArray(target[symbolPath]));\n\n    // Non reactive properties on root and nested records.\n    switch (prop) {\n      case symbolInternals:\n        return target[symbolInternals];\n      case SchemaId:\n        return this.getSchema(target);\n    }\n\n    // Non-reactive root properties.\n    if (isRootDataObject(target)) {\n      switch (prop) {\n        case 'id': {\n          return target[symbolInternals].core.id;\n        }\n        case EntityKindId: {\n          return target[symbolInternals].core.getKind();\n        }\n        case RelationSourceDXNId: {\n          return target[symbolInternals].core.getSource()?.toDXN();\n        }\n        case RelationTargetDXNId: {\n          return target[symbolInternals].core.getTarget()?.toDXN();\n        }\n        case RelationSourceId: {\n          return this._getRelationSource(target);\n        }\n        case RelationTargetId: {\n          return this._getRelationTarget(target);\n        }\n        case TypeId:\n          return this.getTypeReference(target)?.toDXN();\n        case MetaId:\n          return this.getMeta(target);\n        case DeletedId:\n          return this.isDeleted(target);\n      }\n    } else {\n      switch (prop) {\n        case EntityKindId:\n        case RelationSourceDXNId:\n        case RelationTargetDXNId:\n        case RelationSourceId:\n        case RelationTargetId:\n        case TypeId:\n        case MetaId:\n        case DeletedId:\n          return undefined;\n      }\n    }\n\n    target[symbolInternals].signal.notifyRead();\n\n    // Reactive properties on root and nested records.\n    switch (prop) {\n      case devtoolsFormatter:\n        return this._getDevtoolsFormatter(target);\n    }\n\n    // Reactive root properties.\n    if (isRootDataObject(target)) {\n      switch (prop) {\n        case 'toJSON':\n          return () => this._toJSON(target);\n        case PROPERTY_ID:\n          return target[symbolInternals].core.id;\n      }\n    }\n\n    if (typeof prop === 'symbol') {\n      return Reflect.get(target, prop);\n    }\n\n    if (target instanceof EchoArray) {\n      return this._arrayGet(target, prop);\n    }\n\n    const decodedValueAtPath = this._getDecodedValueAtPath(target, prop);\n    return this._wrapInProxyIfRequired(target, decodedValueAtPath);\n  }\n\n  // TODO(burdon): arg `receiver` not used.\n  set(target: ProxyTarget, prop: string | symbol, value: any, receiver: any): boolean {\n    invariant(Array.isArray(target[symbolPath]));\n    invariant(typeof prop === 'string');\n    if (target instanceof EchoArray && prop === 'length') {\n      this._arraySetLength(target, target[symbolPath], value);\n      return true;\n    }\n\n    const fullPath = [getNamespace(target), ...target[symbolPath], prop];\n    const validatedValue = this._validateValue(target, [...target[symbolPath], prop], value);\n    if (validatedValue === undefined) {\n      target[symbolInternals].core.delete(fullPath);\n    } else {\n      const withLinks = this._handleLinksAssignment(target, validatedValue);\n      target[symbolInternals].core.setDecoded(fullPath, withLinks);\n    }\n\n    return true;\n  }\n\n  /**\n   * @returns The typename without version for static schema or object id for dynamic schema.\n   */\n  private _getTypename(target: ProxyTarget): string | undefined {\n    const schema = this.getSchema(target);\n    // Special handling for EchoSchema. objectId is StoredSchema objectId, not a typename.\n    if (schema && typeof schema === 'object' && SchemaMetaSymbol in schema) {\n      return (schema as any)[SchemaMetaSymbol].typename;\n    }\n    return this.getTypeReference(target)?.objectId;\n  }\n\n  private _getRelationSource(target: ProxyTarget): any {\n    const sourceRef = target[symbolInternals].core.getSource();\n    invariant(sourceRef);\n    const database = target[symbolInternals].database;\n    if (database) {\n      // TODO(dmaretskyi): Put refs into proxy cache.\n      return database.graph\n        .createRefResolver({\n          context: {\n            space: database.spaceId,\n          },\n        })\n        .resolveSync(sourceRef.toDXN(), false);\n    } else {\n      invariant(target[symbolInternals].linkCache);\n      return target[symbolInternals].linkCache.get(sourceRef.objectId);\n    }\n  }\n\n  private _getRelationTarget(target: ProxyTarget): any {\n    const targetRef = target[symbolInternals].core.getTarget();\n    invariant(targetRef);\n    const database = target[symbolInternals].database;\n    if (database) {\n      return database.graph\n        .createRefResolver({\n          context: {\n            space: database.spaceId,\n          },\n        })\n        .resolveSync(targetRef.toDXN(), false);\n    } else {\n      invariant(target[symbolInternals].linkCache);\n      return target[symbolInternals].linkCache.get(targetRef.objectId);\n    }\n  }\n\n  /**\n   * Takes a decoded value from the document, and wraps it in a proxy if required.\n   * We use it to wrap records and arrays to provide deep mutability.\n   * Wrapped targets are cached in the `targetsMap` to ensure that the same proxy is returned for the same path.\n   */\n  private _wrapInProxyIfRequired(target: ProxyTarget, decodedValueAtPath: DecodedValueAtPath) {\n    const { value: decoded, dataPath, namespace } = decodedValueAtPath;\n    if (decoded == null) {\n      return decoded;\n    }\n    if (decoded[symbolIsProxy]) {\n      return this._handleStoredSchema(target, decoded);\n    }\n    if (decoded instanceof Reference) {\n      return this.lookupRef(target, decoded);\n    }\n    if (Array.isArray(decoded)) {\n      const targetKey = TargetKey.new(dataPath, namespace, 'array');\n      const newTarget = defaultMap(target[symbolInternals].targetsMap, targetKey, (): ProxyTarget => {\n        const array = new EchoArray();\n        array[symbolInternals] = target[symbolInternals];\n        array[symbolPath] = dataPath;\n        array[symbolNamespace] = namespace;\n        array[symbolHandler] = this;\n        return array;\n      });\n\n      return createProxy(newTarget, this);\n    }\n    if (typeof decoded === 'object') {\n      const targetKey = TargetKey.new(dataPath, namespace, 'record');\n      // TODO(dmaretskyi): Materialize properties for easier debugging.\n      const newTarget = defaultMap(\n        target[symbolInternals].targetsMap,\n        targetKey,\n        (): ProxyTarget => ({\n          [symbolInternals]: target[symbolInternals],\n          [symbolPath]: dataPath,\n          [symbolNamespace]: namespace,\n        }),\n      );\n\n      return createProxy(newTarget, this);\n    }\n\n    return decoded;\n  }\n\n  private _handleStoredSchema(target: ProxyTarget, object: any): any {\n    // Object instanceof StoredEchoSchema requires database to lookup schema.\n    const database = target[symbolInternals].database;\n    // TODO(dmaretskyi): isInstanceOf(StoredSchema, object)\n    if (database && isInstanceOf(StoredSchema, object)) {\n      return database.schemaRegistry._registerSchema(object);\n    }\n\n    return object;\n  }\n\n  private _getDecodedValueAtPath(target: ProxyTarget, prop?: string): DecodedValueAtPath {\n    const dataPath = [...target[symbolPath]];\n    if (prop != null) {\n      dataPath.push(prop);\n    }\n    const fullPath = [getNamespace(target), ...dataPath];\n    const value: any = target[symbolInternals].core.getDecoded(fullPath);\n    // if (value instanceof Reference) {\n    //   value = this.lookupRef(target, value);\n    // }\n\n    return { namespace: getNamespace(target), value, dataPath };\n  }\n\n  private _arrayGet(target: ProxyTarget, prop: string) {\n    invariant(target instanceof EchoArray);\n    if (prop === 'constructor') {\n      return Array.prototype.constructor;\n    }\n    if (prop !== 'length' && isNaN(parseInt(prop))) {\n      return Reflect.get(target, prop);\n    }\n\n    const decodedValueAtPath = this._getDecodedValueAtPath(target, prop);\n    return this._wrapInProxyIfRequired(target, decodedValueAtPath);\n  }\n\n  private _arrayHas(target: ProxyTarget, prop: string | symbol): boolean {\n    invariant(target instanceof EchoArray);\n    if (typeof prop === 'string') {\n      const parsedIndex = parseInt(prop);\n      const { value: length } = this._getDecodedValueAtPath(target, 'length');\n      invariant(typeof length === 'number');\n      if (!isNaN(parsedIndex)) {\n        return parsedIndex < length;\n      }\n    }\n\n    return Reflect.has(target, prop);\n  }\n\n  private _validateValue(target: ProxyTarget, path: KeyPath, value: any): any {\n    invariant(path.length > 0);\n    throwIfCustomClass(path[path.length - 1], value);\n    const rootObjectSchema = this.getSchema(target);\n    if (rootObjectSchema == null) {\n      const typeReference = target[symbolInternals].core.getType();\n      if (typeReference) {\n        // The object has schema, but we can't access it to validate the value being set.\n        throw new Error(`Schema not found in schema registry: ${typeReference.toDXN().toString()}`);\n      }\n\n      return value;\n    }\n\n    // DynamicEchoSchema is a utility-wrapper around the object we actually store in automerge, unwrap it\n    const unwrappedValue = value instanceof EchoSchema ? value.storedSchema : value;\n    const propertySchema = SchemaValidator.getPropertySchema(rootObjectSchema, path, (path) => {\n      return target[symbolInternals].core.getDecoded([getNamespace(target), ...path]);\n    });\n    if (propertySchema == null) {\n      return unwrappedValue;\n    }\n\n    const _ = Schema.asserts(propertySchema)(unwrappedValue);\n    return unwrappedValue;\n  }\n\n  private _handleLinksAssignment(target: ProxyTarget, value: any): any {\n    return deepMapValues(value, (value, recurse) => {\n      if (isEchoObjectField(value)) {\n        // The value is a value-object field of another echo-object. We don't want to create a reference\n        // to it or have shared mutability, we need to copy by value.\n        return recurse({ ...value });\n      } else if (isLiveObject(value)) {\n        throw new Error('Object references must be wrapped with `Ref.make`');\n      } else if (Ref.isRef(value)) {\n        const savedTarget = getRefSavedTarget(value);\n        if (savedTarget) {\n          return this.createRef(target, savedTarget);\n        } else {\n          return Reference.fromDXN(value.dxn);\n        }\n      } else {\n        return recurse(value);\n      }\n    });\n  }\n\n  getSchema(target: ProxyTarget): Schema.Schema.AnyNoContext | undefined {\n    if (target[symbolNamespace] === META_NAMESPACE) {\n      // TODO(dmaretskyi): Breaks tests.\n      // if (target[symbolPath].length !== 0) {\n      //   // TODO(dmaretskyi): pluck from ObjectMetaSchema.\n      //   return undefined;\n      // }\n      return ObjectMetaSchema;\n    }\n\n    // TODO(y): Make reactive.\n    // TODO(burdon): May not be attached to database yet.\n    if (!target[symbolInternals].database) {\n      // For objects created by `createObject` outside of the database.\n      if (target[symbolInternals].rootSchema != null) {\n        return target[symbolInternals].rootSchema;\n      }\n\n      return undefined;\n    }\n\n    const typeReference = target[symbolInternals].core.getType();\n    if (typeReference == null) {\n      return undefined;\n    }\n\n    const staticSchema = target[symbolInternals].database.graph.schemaRegistry.getSchemaByDXN(typeReference.toDXN());\n    if (staticSchema != null) {\n      return staticSchema;\n    }\n\n    // TODO(dmaretskyi): Check using dxn\n    if (typeReference.protocol === 'protobuf') {\n      return undefined;\n    }\n\n    return target[symbolInternals].database.schemaRegistry.query({ id: typeReference.toDXN().toString() }).runSync()[0];\n  }\n\n  getTypeReference(target: ProxyTarget): Reference | undefined {\n    return target[symbolNamespace] === DATA_NAMESPACE ? target[symbolInternals].core.getType() : undefined;\n  }\n\n  isDeleted(target: any): boolean {\n    return target[symbolInternals].core.isDeleted();\n  }\n\n  deleteProperty(target: ProxyTarget, property: string | symbol): boolean {\n    if (target instanceof EchoArray) {\n      // Note: Automerge support delete array[index] but its behavior is not consistent with JS arrays.\n      //       It works as splice but JS arrays substitute `undefined` for deleted elements.\n      //       `Undefined` values are not supported in Automerge, so we can't override this behavior.\n      log.warn('Deleting properties from EchoArray is not supported. Use `EchoArray.splice` instead.');\n      return false;\n    } else if (isRootDataObject(target) && property === PROPERTY_ID) {\n      return false;\n    } else if (typeof property === 'symbol') {\n      return false;\n    } else if (target instanceof EchoArray && isNaN(parseInt(property))) {\n      return false;\n    } else if (typeof property === 'string') {\n      const fullPath = [getNamespace(target), ...target[symbolPath], property];\n      target[symbolInternals].core.delete(fullPath);\n      return true;\n    }\n    return false;\n  }\n\n  arrayPush(target: Live<ProxyTarget>, path: KeyPath, ...items: any[]): number {\n    const validatedItems = this._validateForArray(target, path, items, target.length);\n\n    const encodedItems = this._encodeForArray(target, validatedItems);\n    return target[symbolInternals].core.arrayPush([getNamespace(target), ...path], encodedItems);\n  }\n\n  arrayPop(target: Live<ProxyTarget>, path: KeyPath): any {\n    const fullPath = this._getPropertyMountPath(target, path);\n\n    let returnValue: any | undefined;\n    target[symbolInternals].core.change((doc) => {\n      const array = getDeep(doc, fullPath);\n      invariant(Array.isArray(array));\n      returnValue = array.pop();\n    });\n\n    return returnValue;\n  }\n\n  arrayShift(target: Live<ProxyTarget>, path: KeyPath): any {\n    const fullPath = this._getPropertyMountPath(target, path);\n\n    let returnValue: any | undefined;\n    target[symbolInternals].core.change((doc) => {\n      const array = getDeep(doc, fullPath);\n      invariant(Array.isArray(array));\n      returnValue = array.shift();\n    });\n\n    return returnValue;\n  }\n\n  arrayUnshift(target: Live<ProxyTarget>, path: KeyPath, ...items: any[]): number {\n    const validatedItems = this._validateForArray(target, path, items, 0);\n\n    const fullPath = this._getPropertyMountPath(target, path);\n    const encodedItems = this._encodeForArray(target, validatedItems);\n\n    let newLength: number = -1;\n    target[symbolInternals].core.change((doc) => {\n      const array = getDeep(doc, fullPath);\n      invariant(Array.isArray(array));\n      newLength = array.unshift(...encodedItems);\n    });\n    invariant(newLength !== -1);\n\n    return newLength;\n  }\n\n  arraySplice(target: Live<ProxyTarget>, path: KeyPath, start: number, deleteCount?: number, ...items: any[]): any[] {\n    const validatedItems = this._validateForArray(target, path, items, start);\n\n    const fullPath = this._getPropertyMountPath(target, path);\n    const encodedItems = this._encodeForArray(target, validatedItems);\n\n    let deletedElements: any[] | undefined;\n    target[symbolInternals].core.change((doc) => {\n      const array = getDeep(doc, fullPath);\n      invariant(Array.isArray(array));\n      if (deleteCount != null) {\n        deletedElements = array.splice(start, deleteCount, ...encodedItems);\n      } else {\n        deletedElements = array.splice(start);\n      }\n    });\n\n    invariant(deletedElements);\n    return deletedElements;\n  }\n\n  arraySort(target: Live<ProxyTarget>, path: KeyPath, compareFn?: (v1: any, v2: any) => number): any[] {\n    const fullPath = this._getPropertyMountPath(target, path);\n\n    target[symbolInternals].core.change((doc) => {\n      const array = getDeep(doc, fullPath);\n      invariant(Array.isArray(array));\n      const sortedArray = [...array].sort(compareFn);\n      setDeep(doc, fullPath, sortedArray);\n    });\n\n    return target as EchoArray<any>;\n  }\n\n  arrayReverse(target: Live<ProxyTarget>, path: KeyPath): any[] {\n    const fullPath = this._getPropertyMountPath(target, path);\n\n    target[symbolInternals].core.change((doc) => {\n      const array = getDeep(doc, fullPath);\n      invariant(Array.isArray(array));\n      const reversedArray = [...array].reverse();\n      setDeep(doc, fullPath, reversedArray);\n    });\n\n    return target as EchoArray<any>;\n  }\n\n  getMeta(target: ProxyTarget): ObjectMeta {\n    // TODO(dmaretskyi): Reuse meta target.\n    const metaTarget: ProxyTarget = {\n      [symbolInternals]: target[symbolInternals],\n      [symbolPath]: [],\n      [symbolNamespace]: META_NAMESPACE,\n    };\n\n    return createProxy(metaTarget, this) as any;\n  }\n\n  setDatabase(target: ProxyTarget, database: EchoDatabase): void {\n    target[symbolInternals].database = database;\n  }\n\n  /**\n   * Store referenced object.\n   * Used when `set` and other mutating methods are called with a proxy.\n   * @param target - self\n   * @param proxy - the proxy that was passed to the method\n   */\n  createRef(target: ProxyTarget, proxy: any): Reference {\n    let otherEchoObj = proxy instanceof EchoSchema ? proxy.storedSchema : proxy;\n    otherEchoObj = !isEchoObject(otherEchoObj) ? createObject(otherEchoObj) : otherEchoObj;\n    const otherObjId = otherEchoObj.id;\n    invariant(typeof otherObjId === 'string' && otherObjId.length > 0);\n\n    // Note: Save proxy in `.linkCache` if the object is not yet saved in the database.\n    const database = target[symbolInternals].database;\n    if (!database) {\n      invariant(target[symbolInternals].linkCache);\n\n      // Can be caused not using `object(Expando, { ... })` constructor.\n      // TODO(dmaretskyi): Add better validation.\n      invariant(otherObjId != null);\n      target[symbolInternals].linkCache.set(otherObjId, otherEchoObj as AnyLiveObject<any>);\n      return Reference.localObjectReference(otherObjId);\n    }\n\n    // TODO(burdon): Remote?\n    const foreignDatabase = (getProxyTarget(otherEchoObj) as ProxyTarget)[symbolInternals].database;\n    if (!foreignDatabase) {\n      database.add(otherEchoObj);\n      // TODO(dmaretskyi): Is this right.\n      return Reference.localObjectReference(otherObjId);\n    }\n\n    // Note: If the object is in a different database, return a reference to a foreign database.\n    if (foreignDatabase !== database) {\n      return Reference.fromDXN(new DXN(DXN.kind.ECHO, [foreignDatabase.spaceId, otherObjId]));\n    }\n\n    return Reference.localObjectReference(otherObjId);\n  }\n\n  /**\n   * Lookup referenced object.\n   */\n  lookupRef(target: ProxyTarget, ref: Reference): Ref<any> | undefined {\n    const database = target[symbolInternals].database;\n    if (database) {\n      // TODO(dmaretskyi): Put refs into proxy cache.\n      const refImpl = new RefImpl(ref.toDXN());\n      setRefResolver(\n        refImpl,\n        database.graph.createRefResolver({\n          context: {\n            space: database.spaceId,\n          },\n          middleware: (obj) => this._handleStoredSchema(target, obj),\n        }),\n      );\n      return refImpl;\n    } else {\n      invariant(target[symbolInternals].linkCache);\n      return new RefImpl(\n        ref.toDXN(),\n        this._handleStoredSchema(target, target[symbolInternals].linkCache.get(ref.objectId)),\n      );\n    }\n  }\n\n  /**\n   *\n   */\n  saveRefs(target: ProxyTarget): void {\n    if (!target[symbolInternals].linkCache) {\n      return;\n    }\n\n    if (target[symbolInternals].linkCache) {\n      for (const obj of target[symbolInternals].linkCache.values()) {\n        this.createRef(target, obj);\n      }\n\n      target[symbolInternals].linkCache = undefined;\n    }\n  }\n\n  private _arraySetLength(target: ProxyTarget, path: KeyPath, newLength: number): void {\n    if (newLength < 0) {\n      throw new RangeError('Invalid array length');\n    }\n    const fullPath = this._getPropertyMountPath(target, path);\n\n    target[symbolInternals].core.change((doc) => {\n      const array = getDeep(doc, fullPath);\n      invariant(Array.isArray(array));\n      const trimmedArray = [...array];\n      trimmedArray.length = newLength;\n      setDeep(doc, fullPath, trimmedArray);\n    });\n  }\n\n  private _validateForArray(target: ProxyTarget, path: KeyPath, items: any[], start: number) {\n    return items.map((item, index) => {\n      return this._validateValue(target, [...path, String(start + index)], item);\n    });\n  }\n\n  // TODO(dmaretskyi): Change to not rely on object-core doing linking.\n  private _encodeForArray(target: ProxyTarget, items: any[] | undefined): any[] {\n    const linksEncoded = this._handleLinksAssignment(target, items);\n    return target[symbolInternals].core.encode(linksEncoded);\n  }\n\n  private _getPropertyMountPath(target: ProxyTarget, path: KeyPath): KeyPath {\n    return [...target[symbolInternals].core.mountPath, getNamespace(target), ...path];\n  }\n\n  // Will be bound to the proxy target.\n  _inspect = function (\n    this: ProxyTarget,\n    _: number,\n    options: InspectOptionsStylized,\n    inspectFn: (value: any, options?: InspectOptionsStylized) => string,\n  ) {\n    const handler = this[symbolHandler] as EchoReactiveHandler;\n    const typename = handler._getTypename(this);\n    const isRelation = this[symbolInternals].core.getKind() === EntityKind.Relation;\n\n    const isTyped = !!this[symbolInternals].core.getType();\n    const reified = handler._getReified(this);\n    reified.id = this[symbolInternals].core.id;\n    return `${isTyped ? 'Typed' : ''}Echo${isRelation ? 'Relation' : 'Object'}${typename ? `(${typename})` : ''} ${inspectFn(\n      reified,\n      {\n        ...options,\n        compact: true,\n        showHidden: false,\n        customInspect: false,\n      },\n    )}`;\n  };\n\n  // TODO(dmaretskyi): Re-use existing json serializer\n  private _toJSON(target: ProxyTarget): any {\n    target[symbolInternals].signal.notifyRead();\n    const typeRef = target[symbolInternals].core.getType();\n    const reified = this._getReified(target);\n    return {\n      [ATTR_TYPE]: typeRef ? encodeReference(typeRef) : undefined,\n      ...(target[symbolInternals].core.isDeleted() ? { '@deleted': true } : {}),\n      [ATTR_META]: { ...this.getMeta(target) },\n\n      // TODO(dmaretskyi): Change to just `id`.\n      '@id': target[symbolInternals].core.id,\n\n      ...deepMapValues(reified, (value, recurse) => {\n        if (value instanceof Reference) {\n          return encodeReference(value);\n        }\n        return recurse(value);\n      }),\n    };\n  }\n\n  private _getReified(target: ProxyTarget): any {\n    const dataPath = [...target[symbolPath]];\n    const fullPath = [getNamespace(target), ...dataPath];\n    return target[symbolInternals].core.getDecoded(fullPath);\n  }\n\n  private _getDevtoolsFormatter(target: ProxyTarget): DevtoolsFormatter {\n    const schema = this.getSchema(target);\n    const typename = schema ? getTypeAnnotation(schema)?.typename : undefined;\n\n    return {\n      header: (config?: any) => getHeader(typename ?? 'EchoObject', target[symbolInternals].core.id, config),\n      hasBody: () => true,\n      body: () => {\n        let data = deepMapValues(this._getReified(target), (value, recurse) => {\n          if (value instanceof Reference) {\n            return this.lookupRef(target, value);\n          }\n\n          return recurse(value);\n        });\n        if (isRootDataObject(target)) {\n          // TODO(dmaretskyi): Extract & reuse.\n          const metaTarget: ProxyTarget = {\n            [symbolInternals]: target[symbolInternals],\n            [symbolPath]: [],\n            [symbolNamespace]: META_NAMESPACE,\n          };\n          const metaReified = this._getReified(metaTarget);\n\n          data = {\n            id: target[symbolInternals].core.id,\n            '@type': this.getTypeReference(target)?.objectId,\n            '@meta': metaReified,\n            ...data,\n            '[[Schema]]': this.getSchema(target),\n            '[[Core]]': target[symbolInternals].core,\n          };\n        }\n\n        return getBody(data);\n      },\n    };\n  }\n}\n\nexport const throwIfCustomClass = (prop: KeyPath[number], value: any) => {\n  if (value == null || Array.isArray(value) || value instanceof EchoSchema || Ref.isRef(value)) {\n    return;\n  }\n\n  const proto = Object.getPrototypeOf(value);\n  if (typeof value === 'object' && proto !== Object.prototype) {\n    throw new Error(`class instances are not supported: setting ${proto} on ${String(prop)}`);\n  }\n};\n\n// TODO(burdon): Move ProxyTarget def to echo-schema and make AnyLiveObject inherit?\nexport const getObjectCore = <T extends BaseObject>(obj: Live<T>): ObjectCore => {\n  if (!(obj as any as ProxyTarget)[symbolInternals]) {\n    throw new Error('object is not an EchoObject');\n  }\n\n  const { core } = (obj as any as ProxyTarget)[symbolInternals];\n  return core;\n};\n\n/**\n * @returns Automerge document (or a part of it) that backs the object.\n * Mostly used for debugging.\n */\nexport const getObjectDocument = (obj: AnyLiveObject<any>): A.Doc<ObjectStructure> => {\n  const core = getObjectCore(obj);\n  return getDeep(core.getDoc(), core.mountPath)!;\n};\n\nexport const isRootDataObject = (target: ProxyTarget) => {\n  const path = target[symbolPath];\n  if (!Array.isArray(path) || path.length > 0) {\n    return false;\n  }\n\n  return getNamespace(target) === DATA_NAMESPACE;\n};\n\n/**\n * @returns True if `value` is part of another EchoObject but not the root data object.\n */\nconst isEchoObjectField = (value: any) => {\n  return (\n    isLiveObject(value) &&\n    getProxyHandler(value) instanceof EchoReactiveHandler &&\n    !isRootDataObject(getProxyTarget(value))\n  );\n};\n\nconst getNamespace = (target: ProxyTarget): string => target[symbolNamespace];\n\ninterface DecodedValueAtPath {\n  value: any;\n  namespace: string;\n  dataPath: KeyPath;\n}\n\n/** @deprecated Use {@link @dxos/echo#AnyLiveObject} instead. */\n// TODO(burdon): Any shouldn't be generic (use namespace).\nexport type AnyLiveObject<T extends BaseObject = any> = Live<T> & BaseEchoObject;\n\n/**\n * @returns True if `value` is a reactive object with an EchoHandler backend.\n */\n// TODO(dmaretskyi): Reconcile with `isTypedObjectProxy`.\nexport const isEchoObject = (value: any): value is AnyLiveObject<any> => {\n  if (!isLiveObject(value)) {\n    return false;\n  }\n\n  const handler = getProxyHandler(value);\n  if (!(handler instanceof EchoReactiveHandler)) {\n    return false;\n  }\n\n  return isRootDataObject(getProxyTarget(value));\n};\n\n/**\n * Used to determine if the value should be placed at the root of a separate ECHO object.\n *\n * @returns True if `value` is a reactive object with an EchoHandler backend or a schema that has an `Object` annotation.\n */\n// TODO(dmaretskyi): Reconcile with `isEchoObject`.\nexport const isTypedObjectProxy = (value: any): value is Live<any> => {\n  if (isEchoObject(value)) {\n    return true;\n  }\n\n  const schema = getSchema(value);\n  if (schema != null) {\n    return !!getTypeAnnotation(schema);\n  }\n\n  return false;\n};\n\n/**\n * Creates a reactive ECHO object backed by a CRDT.\n * @internal\n */\n// TODO(burdon): Document lifecycle.\nexport const createObject = <T extends BaseObject>(obj: T): AnyLiveObject<T> => {\n  assertArgument(!isEchoObject(obj), 'Object is already an ECHO object');\n  const schema = getSchema(obj);\n  if (schema != null) {\n    validateSchema(schema);\n  }\n  validateInitialProps(obj);\n\n  const core = new ObjectCore();\n  if (isLiveObject(obj)) {\n    // Already an echo-schema reactive object.\n    const meta = getProxyTarget<ObjectMeta>(getMeta(obj));\n\n    // TODO(burdon): Requires comment.\n    const slot = getProxySlot(obj);\n    slot.setHandler(EchoReactiveHandler.instance);\n\n    const target = slot.target as ProxyTarget;\n    target[symbolInternals] = new ObjectInternals(core);\n    target[symbolInternals].rootSchema = schema;\n    target[symbolPath] = [];\n    target[symbolNamespace] = DATA_NAMESPACE;\n    slot.handler._proxyMap.set(target, obj);\n\n    target[symbolInternals].subscriptions.push(core.updates.on(() => target[symbolInternals].signal.notifyWrite()));\n\n    // NOTE: This call is recursively linking all nested objects\n    //  which can cause recursive loops of `createObject` if `EchoReactiveHandler` is not set prior to this call.\n    //  Do not change order.\n    initCore(core, target);\n    slot.handler.init(target);\n\n    setSchemaPropertiesOnObjectCore(target[symbolInternals], schema);\n    setRelationSourceAndTarget(target, core, schema);\n\n    if (meta && meta.keys.length > 0) {\n      target[symbolInternals].core.setMeta(meta);\n    }\n\n    return obj as any;\n  } else {\n    const target: ProxyTarget = {\n      [symbolInternals]: new ObjectInternals(core),\n      [symbolPath]: [],\n      [symbolNamespace]: DATA_NAMESPACE,\n      ...(obj as any),\n    };\n    target[symbolInternals].rootSchema = schema;\n\n    target[symbolInternals].subscriptions.push(core.updates.on(() => target[symbolInternals].signal.notifyWrite()));\n\n    initCore(core, target);\n    const proxy = createProxy<ProxyTarget>(target, EchoReactiveHandler.instance) as any;\n    setSchemaPropertiesOnObjectCore(target[symbolInternals], schema);\n    setRelationSourceAndTarget(target, core, schema);\n\n    return proxy;\n  }\n};\n\n/**\n * @internal\n */\n// TODO(burdon): Call and remove subscriptions.\nexport const destroyObject = <T extends BaseObject>(proxy: AnyLiveObject<T>) => {\n  invariant(isEchoObject(proxy));\n  const target: ProxyTarget = getProxyTarget(proxy);\n  const internals: ObjectInternals = target[symbolInternals];\n  for (const unsubscribe of internals.subscriptions) {\n    unsubscribe();\n  }\n};\n\nconst initCore = (core: ObjectCore, target: ProxyTarget) => {\n  // Handle ID pre-generated by `create`.\n  if (PROPERTY_ID in target) {\n    target[symbolInternals].core.id = target[PROPERTY_ID];\n    delete target[PROPERTY_ID];\n  }\n\n  core.initNewObject(linkAllNestedProperties(target));\n};\n\n/**\n * @internal\n */\nexport const initEchoReactiveObjectRootProxy = (core: ObjectCore, database?: EchoDatabase): AnyLiveObject<any> => {\n  const target: ProxyTarget = {\n    [symbolInternals]: new ObjectInternals(core, database),\n    [symbolPath]: [],\n    [symbolNamespace]: DATA_NAMESPACE,\n  };\n\n  // TODO(dmaretskyi): Does this need to be disposed?\n  core.updates.on(() => target[symbolInternals].signal.notifyWrite());\n\n  const obj = createProxy<ProxyTarget>(target, EchoReactiveHandler.instance) as any;\n  assertObjectModelShape(obj);\n  return obj;\n};\n\nconst validateSchema = (schema: Schema.Schema.AnyNoContext) => {\n  requireTypeReference(schema);\n  const entityKind = getEntityKind(schema);\n  invariant(entityKind === 'object' || entityKind === 'relation');\n  SchemaValidator.validateSchema(schema);\n};\n\nconst setSchemaPropertiesOnObjectCore = (\n  internals: ObjectInternals,\n  schema: Schema.Schema.AnyNoContext | undefined,\n) => {\n  if (schema != null) {\n    internals.core.setType(requireTypeReference(schema));\n\n    const kind = getEntityKind(schema);\n    invariant(kind);\n    internals.core.setKind(kind);\n  }\n};\n\nconst setRelationSourceAndTarget = (\n  target: ProxyTarget,\n  core: ObjectCore,\n  schema: Schema.Schema.AnyNoContext | undefined,\n) => {\n  const kind = schema && getEntityKind(schema);\n  if (kind === EntityKind.Relation) {\n    // `getSource` and `getTarget` don't work here since they assert entity kind.\n    const sourceRef = (target as any)[RelationSourceId];\n    const targetRef = (target as any)[RelationTargetId];\n    if (!sourceRef || !targetRef) {\n      throw new TypeError('Relation source and target must be specified');\n    }\n    if (!isLiveObject(sourceRef)) {\n      throw new TypeError('source must be an ECHO object');\n    }\n    if (!isLiveObject(targetRef)) {\n      throw new TypeError('target must be an ECHO object');\n    }\n\n    core.setSource(EchoReactiveHandler.instance.createRef(target, sourceRef));\n    core.setTarget(EchoReactiveHandler.instance.createRef(target, targetRef));\n  }\n};\n\nconst validateInitialProps = (target: any, seen: Set<object> = new Set()) => {\n  if (seen.has(target)) {\n    return;\n  }\n\n  seen.add(target);\n  for (const key in target) {\n    const value = target[key];\n    if (value === undefined) {\n      delete target[key];\n    } else if (typeof value === 'object') {\n      if (Ref.isRef(value)) {\n        // Pass refs as is.\n      } else if (value instanceof EchoSchema || isTypedObjectProxy(value)) {\n        throw new Error('Object references must be wrapped with `Ref.make`');\n      } else {\n        throwIfCustomClass(key, value);\n        validateInitialProps(target[key], seen);\n      }\n    }\n  }\n};\n\nconst linkAllNestedProperties = (target: ProxyTarget): DecodedAutomergePrimaryValue => {\n  return deepMapValues(target, (value, recurse) => {\n    if (Ref.isRef(value)) {\n      return refToEchoReference(target, value);\n    }\n\n    return recurse(value);\n  });\n};\n\nconst refToEchoReference = (target: ProxyTarget, ref: Ref<any>): Reference => {\n  const savedTarget = getRefSavedTarget(ref);\n  if (savedTarget) {\n    return EchoReactiveHandler.instance.createRef(target, savedTarget);\n  } else {\n    return Reference.fromDXN(ref.dxn);\n  }\n};\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { type JsonML } from '@dxos/debug';\n\nconst idStyle = { style: 'color: #777' };\nconst listStyle = {\n  style: 'list-style-type: none; padding: 0; margin: 0 0 0 12px; font-style: normal; position: relative',\n};\nconst liStyle = { style: 'min-height: 16px;' };\nconst nestedObjectContainerStyle = { style: 'margin: -2px 0 0; display: inline-flex' };\nconst keyStyle = { style: 'color: #881391' };\nconst defaultValueKeyStyle = { style: 'color: #777' };\nconst alteredValueKeyStyle = { style: 'color: #881391; font-weight: bolder' };\nconst nullStyle = { style: 'color: #777' };\n\nconst defaultKeys = ['id', '@type', '@meta'];\n\nexport const getHeader = (tag: string, id: string, config?: any): JsonML => {\n  return [\n    'span',\n    {\n      style: (config?.nested ? 'padding: 2px 0 0;' : '') + '\\n height: 18px;',\n    },\n    `${tag}`,\n    ['span', idStyle, `#${id}`],\n  ];\n};\n\nconst formatValue = (object: any, config?: any): JsonML => {\n  if (typeof object === 'undefined') {\n    return ['span', nullStyle, 'undefined'];\n  } else if (object === 'null') {\n    return ['span', nullStyle, 'null'];\n  } else {\n    return ['span', nestedObjectContainerStyle, ['object', { object, config }]];\n  }\n};\n\nexport const getBody = (objData: any): JsonML => {\n  return [\n    'ol',\n    listStyle,\n    ...Object.keys(objData).map(\n      (key): JsonML => [\n        'li',\n        liStyle,\n        [\n          'span',\n          defaultKeys.includes(key) ? keyStyle : key.startsWith('[[') ? defaultValueKeyStyle : alteredValueKeyStyle,\n          key,\n        ],\n        ['span', {}, ': '],\n        formatValue(objData[key], { nested: true }),\n      ],\n    ),\n  ];\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { compositeRuntime } from '@dxos/echo-signals/runtime';\n\nimport { type EchoReactiveHandler } from './echo-handler';\nimport { type ObjectInternals, symbolHandler, symbolInternals, symbolNamespace, symbolPath } from './echo-proxy-target';\nimport type { KeyPath } from '../core-db';\n\nexport class EchoArray<T> extends Array<T> {\n  static override get [Symbol.species]() {\n    return Array;\n  }\n\n  // Will be initialize when the proxy is created.\n  [symbolInternals]: ObjectInternals = null as any;\n  [symbolPath]: KeyPath = null as any;\n  [symbolNamespace]: string = null as any;\n  [symbolHandler]: EchoReactiveHandler = null as any;\n\n  static {\n    /**\n     * These methods will trigger proxy traps like `set` and `defineProperty` and emit signal notifications.\n     * We wrap them in a batch to avoid unnecessary signal notifications.\n     */\n    const BATCHED_METHODS = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'] as const;\n\n    for (const method of BATCHED_METHODS) {\n      const handlerMethodName = `array${method.slice(0, 1).toUpperCase()}${method.slice(1)}`;\n\n      const fn = function (this: EchoArray<any>, ...args: any[]) {\n        let result!: any;\n        compositeRuntime.batch(() => {\n          const handler = this[symbolHandler];\n          result = ((handler as any)[handlerMethodName] as Function).apply(handler, [this, this[symbolPath], ...args]);\n        });\n        return result;\n      };\n      Object.defineProperty(fn, 'name', { value: method });\n      Object.defineProperty(this.prototype, method, {\n        enumerable: false,\n        value: fn,\n      });\n    }\n  }\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { type Brand, type Schema } from 'effect';\n\nimport type { CleanupFn } from '@dxos/async';\nimport { inspectCustom } from '@dxos/debug';\nimport type { SchemaId } from '@dxos/echo-schema';\nimport { compositeRuntime, type GenericSignal } from '@dxos/echo-signals/runtime';\nimport { ComplexMap } from '@dxos/util';\n\nimport { type EchoArray } from './echo-array';\nimport { type AnyLiveObject, type EchoReactiveHandler } from './echo-handler';\nimport type { ObjectCore, KeyPath } from '../core-db';\nimport { type EchoDatabase } from '../proxy-db';\n\nexport const symbolPath = Symbol('path');\nexport const symbolNamespace = Symbol('namespace');\nexport const symbolHandler = Symbol('handler');\nexport const symbolInternals = Symbol('internals');\n\n/**\n * For tracking proxy targets in the `targetsMap`.\n */\ntype TargetKey = {\n  path: KeyPath;\n  namespace: string;\n  type: 'record' | 'array';\n} & Brand.Brand<'TargetKey'>;\n\nexport const TargetKey = {\n  /**\n   * Constructor function forces the order of the fields.\n   */\n  new: (path: KeyPath, namespace: string, type: 'record' | 'array'): TargetKey =>\n    ({\n      path,\n      namespace,\n      type,\n    }) as TargetKey,\n  hash: (key: TargetKey): string => JSON.stringify(key),\n};\n\n/**\n * Internal state for the proxy ECHO object.\n * Shared for the entire ECHO object in the database (maybe be composed of multiple proxies for each subrecord).\n */\nexport class ObjectInternals {\n  /**\n   * Backing ECHO object core.\n   */\n  core: ObjectCore;\n\n  /**\n   * Database.\n   * Is set on object adding to database.\n   */\n  database: EchoDatabase | undefined;\n\n  /**\n   * Signal for reactive updates to the object.\n   */\n  signal: GenericSignal = compositeRuntime.createSignal();\n\n  /**\n   * Caching targets based on key path.\n   * Only used for records and arrays.\n   */\n  targetsMap = new ComplexMap<TargetKey, ProxyTarget>((key) => JSON.stringify(key));\n\n  /**\n   * Until object is persisted in the database, the linked object references are stored in this cache.\n   * Set only when the object is not bound to a database.\n   */\n  linkCache: Map<string, AnyLiveObject<any>> | undefined = new Map<string, AnyLiveObject<any>>();\n\n  subscriptions: CleanupFn[] = [];\n\n  /**\n   * Schema of the root object.\n   * Only used if this is not bound to a database.\n   */\n  rootSchema?: Schema.Schema.AnyNoContext = undefined;\n\n  constructor(core: ObjectCore, database?: EchoDatabase) {\n    this.core = core;\n    this.database = database;\n  }\n\n  [inspectCustom] = () => `ObjectInternals(${this.core.id}${this.database ? ' bound' : ''})`;\n}\n\n/**\n * Generic proxy target type for ECHO proxy objects.\n * Targets can either be objects or arrays (instances of `EchoArrayTwoPointO`).\n * @internal\n */\nexport type ProxyTarget = {\n  [symbolInternals]: ObjectInternals;\n\n  /**\n   * `data` or `meta` namespace.\n   */\n  [symbolNamespace]: string;\n\n  /**\n   * Path within the namespace.\n   *\n   * Root objects have an empty path: `[]`.\n   */\n  [symbolPath]: KeyPath;\n\n  /**\n   * Reference to the handler.\n   * @deprecated\n   */\n  // TODO(dmaretskyi): Can be removed.\n  [symbolHandler]?: EchoReactiveHandler;\n\n  /**\n   * Used for objects created by `createObject`.\n   */\n  [SchemaId]?: Schema.Schema.AnyNoContext;\n} & ({ [key: keyof any]: any } | EchoArray<any>);\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { type BaseObject, ObjectId } from '@dxos/echo-schema';\nimport { invariant, assertArgument } from '@dxos/invariant';\n\nimport { type AnyLiveObject, initEchoReactiveObjectRootProxy, isEchoObject } from './echo-handler';\nimport { getObjectCore } from './echo-handler';\nimport { symbolInternals } from './echo-proxy-target';\nimport { ObjectCore } from '../core-db';\n\nexport type CloneOptions = {\n  /**\n   * @default true\n   */\n  retainId?: boolean;\n\n  /**\n   * Additional list of objects to clone preserving references.\n   */\n  additional?: (AnyLiveObject<any> | undefined)[];\n};\n\nconst requireAutomergeCore = (obj: AnyLiveObject<any>) => {\n  const core = getObjectCore(obj);\n  invariant(core, 'object is not an EchoObject');\n  return core;\n};\n\n/**\n * Returns new unbound clone of the object.\n * @deprecated\n */\nexport const clone = <T extends BaseObject>(\n  obj: AnyLiveObject<T>,\n  { retainId = true, additional = [] }: CloneOptions = {},\n): T => {\n  assertArgument(isEchoObject(obj), 'expect obj to be an EchoObject');\n  assertArgument(retainId === true || additional.length === 0, 'retainId must be true when additional is not empty');\n\n  const clone = cloneInner(obj, retainId ? obj.id : ObjectId.random());\n  const clones: AnyLiveObject<any>[] = [clone];\n  for (const innerObj of additional) {\n    if (innerObj) {\n      clones.push(cloneInner(innerObj, retainId ? innerObj.id : ObjectId.random()));\n    }\n  }\n\n  // Update links.\n  // Ensures references work before the object is bound.\n  for (const clone of clones) {\n    if (!isEchoObject(clone)) {\n      continue;\n    }\n\n    for (const ref of clones) {\n      if (ref === clone) {\n        continue;\n      }\n\n      clone[symbolInternals as any].linkCache!.set(ref.id, ref);\n    }\n  }\n\n  return clone;\n};\n\nconst cloneInner = <T extends BaseObject>(obj: AnyLiveObject<T>, id: string): AnyLiveObject<T> => {\n  const core = requireAutomergeCore(obj);\n  const coreClone = new ObjectCore();\n  coreClone.initNewObject();\n  coreClone.id = id;\n  const proxy = initEchoReactiveObjectRootProxy(coreClone);\n  const automergeSnapshot = getObjectDoc(core);\n  coreClone.change((doc: any) => {\n    for (const key of Object.keys(automergeSnapshot)) {\n      doc[key] = automergeSnapshot[key];\n    }\n  });\n  return proxy as any;\n};\n\nconst getObjectDoc = (core: ObjectCore): any => {\n  let value = core.doc ?? core.docHandle!.doc();\n  for (const key of core.mountPath) {\n    value = (value as any)?.[key];\n  }\n  return value;\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { next as am, type Doc, type Heads, type State } from '@automerge/automerge';\n\nimport { ATTR_META, ATTR_TYPE, type BaseObject } from '@dxos/echo-schema';\nimport { assertArgument } from '@dxos/invariant';\n\nimport { isEchoObject, type AnyLiveObject } from './echo-handler';\nimport { getObjectCore } from './echo-handler';\nimport { ObjectCore } from '../core-db';\n\n/**\n * Returns the edit history of an ECHO object.\n * NOTE: This is the history of the automerge document containing the echo object.\n */\nexport const getEditHistory = (object: AnyLiveObject<any>): State<any>[] => {\n  assertArgument(isEchoObject(object), 'expected ECHO object stored in the database');\n\n  const objectCore = getObjectCore(object);\n  const doc = objectCore.getDoc();\n  const changes = am.getHistory(doc as Doc<any>);\n  return changes;\n};\n\n/**\n * @returns Snapshot of the object at the given version in the JSON format.\n */\n// TODO(dmaretskyi): Returning T is actually wrong since the object is actually in JSON format -- we should unify data formats.\nexport const checkoutVersion = <T extends BaseObject>(object: AnyLiveObject<T>, version: Heads): T => {\n  assertArgument(isEchoObject(object), 'expected ECHO object stored in the database');\n  assertArgument(Array.isArray(version), 'expected automerge heads array');\n\n  const objectCore = getObjectCore(object);\n  const doc = objectCore.getDoc();\n  const snapshot = am.view(doc as Doc<any>, version);\n\n  // TODO(dmaretskyi): Refactor so this doesn't have to create another core.\n  const versionCore = new ObjectCore();\n  versionCore.id = objectCore.id;\n  versionCore.doc = snapshot;\n  versionCore.mountPath = objectCore.mountPath;\n\n  // TODO(dmaretskyi): Fix this nonsense.\n  const { id, __typename, __meta, ...data } = versionCore.toPlainObject();\n  return {\n    id,\n    [ATTR_TYPE]: __typename,\n    [ATTR_META]: __meta,\n    ...data,\n  } as any;\n};\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport {\n  type BaseEchoObject,\n  EntityKind,\n  EntityKindId,\n  RelationSourceId,\n  RelationTargetId,\n  type BaseObject,\n  type RelationSourceTargetRefs,\n} from '@dxos/echo-schema';\nimport { invariant } from '@dxos/invariant';\nimport { type Live } from '@dxos/live-object';\n\nimport type { AnyLiveObject } from './echo-handler';\n\n/**\n * @deprecated Use {@link @dxos/echo#Relation.Any} instead.\n */\nexport type AnyLiveRelation<T extends BaseObject> = Live<T> & BaseEchoObject & RelationSourceTargetRefs;\n\n/**\n * @deprecated Use {@link @dxos/echo#Relation.isRelation} instead.\n */\nexport const isRelation = <T extends BaseObject>(object: AnyLiveObject<T>): object is AnyLiveRelation<T> => {\n  const kind = (object as any)[EntityKindId];\n  if (kind === undefined) {\n    throw new TypeError('Provided value is not a valid ECHO object or relation');\n  }\n  return kind === EntityKind.Relation;\n};\n\n/**\n * @deprecated Use {@link @dxos/echo#Relation.getSource} instead.\n * @returns Source ref from a relation.\n * @throws If the object is not a relation.\n */\nexport const getSource = (relation: AnyLiveObject<any>): AnyLiveObject<any> => {\n  invariant(isRelation(relation));\n  const obj = relation[RelationSourceId];\n  invariant(obj !== undefined);\n  return obj;\n};\n\n/**\n * @deprecated Use {@link @dxos/echo#Relation.getTarget} instead.\n * @returns Target ref from a relation.\n * @throws If the object is not a relation.\n */\nexport const getTarget = (relation: AnyLiveObject<any>): AnyLiveObject<any> => {\n  invariant(isRelation(relation));\n  const obj = relation[RelationTargetId];\n  invariant(obj !== undefined);\n  return obj;\n};\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { Reference } from '@dxos/echo-protocol';\nimport { type BaseObject, type ForeignKey } from '@dxos/echo-schema';\nimport { invariant } from '@dxos/invariant';\nimport { getMeta, getProxyTarget, type Live } from '@dxos/live-object';\n\nimport { isEchoObject, type AnyLiveObject } from './echo-handler';\nimport { symbolInternals, type ProxyTarget } from './echo-proxy-target';\nimport { type EchoDatabase } from '../proxy-db';\n\nexport const getDatabaseFromObject = (obj: Live<any>): EchoDatabase | undefined => {\n  if (!isEchoObject(obj)) {\n    return undefined;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-var-requires\n  const target = getProxyTarget(obj) as ProxyTarget;\n  return target[symbolInternals].database;\n};\n\n/**\n * @deprecated\n */\nexport const getReferenceWithSpaceKey = (obj: AnyLiveObject<any>): Reference | undefined => {\n  invariant(obj);\n  const db = getDatabaseFromObject(obj);\n  return db && Reference.fromObjectIdAndSpaceKey(obj.id, db.spaceKey);\n};\n\n// TODO(burdon): Factor out.\n// TODO(burdon): Impl query by meta.\nexport const findObjectWithForeignKey = <T extends BaseObject>(objects: AnyLiveObject<T>[], foreignKey: ForeignKey) => {\n  return objects.find((result) => {\n    return getMeta(result).keys.find(({ source, id }) => source === foreignKey.source && id === foreignKey.id);\n  });\n};\n\nexport const matchKeys = (a: ForeignKey[], b: ForeignKey[]): boolean => {\n  return a.some((keyA) => b.some((keyB) => keyA.source === keyB.source && keyA.id === keyB.id));\n};\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport type { BaseObject } from '@dxos/echo-schema';\nimport { assertArgument } from '@dxos/invariant';\nimport { isLiveObject, type Live } from '@dxos/live-object';\n\nimport { getObjectCore } from './echo-handler';\nimport { symbolPath, type ProxyTarget } from './echo-proxy-target';\nimport { isValidKeyPath, type DocAccessor, type KeyPath } from '../core-db/types';\n\n//   TODO(burdon): Move to @dxos/live-object?\nexport const createDocAccessor = <T extends BaseObject>(obj: Live<T>, path: KeyPath | keyof T): DocAccessor<T> => {\n  if (!Array.isArray(path)) {\n    path = [path as any];\n  }\n\n  assertArgument(isLiveObject(obj), 'expect obj to be a LiveObject');\n  assertArgument(path === undefined || isValidKeyPath(path), 'expect path to be a valid key path');\n\n  const core = getObjectCore(obj);\n  const basePath = (obj as any as ProxyTarget)[symbolPath];\n  const fullPath = basePath ? [...basePath, ...path] : path;\n  return core.getDocAccessor(fullPath);\n};\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { next as Automerge } from '@automerge/automerge';\n\nimport type { Live } from '@dxos/live-object';\n\nimport { createDocAccessor } from './doc-accessor';\n\nexport type ObjectVersion = {\n  heads: string[];\n};\n\nexport const ObjectVersion = Object.freeze({\n  equals: (a: ObjectVersion, b: ObjectVersion) => {\n    return JSON.stringify(a) === JSON.stringify(b);\n  },\n});\n\n/**\n * @returns The current version of the object in the database.\n * @throws If the object is not in the database.\n */\nexport const getVersion = (obj: Live<any>): ObjectVersion => {\n  const docAccessor = createDocAccessor(obj, []);\n  const doc = docAccessor.handle.doc();\n  if (!doc) {\n    return { heads: [] };\n  }\n  return { heads: Automerge.getHeads(doc) };\n};\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { type CleanupFn } from '@dxos/async';\n\nimport { getObjectCore, isEchoObject } from './echo-handler';\n\nexport type Selection = any[];\n\n// TODO(dmaretskyi): Convert to class.\nexport interface SubscriptionHandle {\n  update: (selection: Selection) => SubscriptionHandle;\n  subscribed: boolean;\n  unsubscribe: () => void;\n  selected: Set<any>;\n}\n\nexport type UpdateInfo = {\n  // TODO(dmaretskyi): Include metadata about the update.\n  updated: any[];\n  added: any[];\n  removed: any[];\n};\n\n/**\n * Subscribe to database updates.\n * Calls the callback when any object from the selection changes.\n * Calls the callback when the selection changes.\n * Always calls the callback on the first `selection.update` call.\n */\n// TODO(burdon): Add filter?\n// TODO(burdon): Immediately trigger callback.\n// TODO(wittjosiah): Could signals effect be used instead?\nexport const createSubscription = (onUpdate: (info: UpdateInfo) => void): SubscriptionHandle => {\n  let subscribed = true;\n  let firstUpdate = true;\n  const subscriptions = new Map<any, CleanupFn>();\n\n  const handle = {\n    update: (selection: Selection) => {\n      const newSelected = new Set(selection.filter(isEchoObject));\n      const removed = [...handle.selected].filter((item) => !newSelected.has(item));\n      const added = [...newSelected].filter((item) => !handle.selected.has(item));\n      handle.selected = newSelected;\n      if (removed.length > 0 || added.length > 0 || firstUpdate) {\n        firstUpdate = false;\n\n        removed.forEach((obj) => {\n          subscriptions.get(obj)?.();\n          subscriptions.delete(obj);\n        });\n\n        added.forEach((obj) => {\n          subscriptions.set(\n            obj,\n            getObjectCore(obj).updates.on(() => {\n              onUpdate({\n                added: [],\n                removed: [],\n                updated: [obj],\n              });\n            }),\n          );\n        });\n\n        onUpdate({\n          added,\n          removed,\n          updated: [],\n        });\n      }\n\n      return handle;\n    },\n    subscribed,\n    selected: new Set<any>(),\n    unsubscribe: () => {\n      Array.from(subscriptions.values()).forEach((unsubscribe) => unsubscribe());\n      subscriptions.clear();\n      subscribed = false;\n    },\n  };\n\n  return handle;\n};\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { Event } from '@dxos/async';\nimport { Context } from '@dxos/context';\nimport { raise, StackTrace } from '@dxos/debug';\nimport type { Ref } from '@dxos/echo';\nimport { Query, Filter } from '@dxos/echo';\nimport {\n  ImmutableSchema,\n  RuntimeSchemaRegistry,\n  type AnyEchoObject,\n  type BaseObject,\n  type BaseSchema,\n  type ObjectId,\n} from '@dxos/echo-schema';\nimport { compositeRuntime } from '@dxos/echo-signals/runtime';\nimport { failedInvariant, invariant } from '@dxos/invariant';\nimport { DXN, type QueueSubspaceTag, type SpaceId } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { trace } from '@dxos/tracing';\nimport { entry } from '@dxos/util';\n\nimport { type ItemsUpdatedEvent } from './core-db';\nimport { type AnyLiveObject } from './echo-handler';\nimport { type EchoDatabase, type EchoDatabaseImpl } from './proxy-db';\nimport {\n  GraphQueryContext,\n  normalizeQuery,\n  QueryResult,\n  ResultFormat,\n  SpaceQuerySource,\n  type QueryContext,\n  type QueryFn,\n  type QueryOptions,\n  type QuerySource,\n} from './query';\nimport type { Queue, QueueFactory } from './queue';\n\nconst TRACE_REF_RESOLUTION = false;\n\n/**\n * Resolution context.\n * Affects how non-absolute DXNs are resolved.\n */\nexport interface RefResolutionContext {\n  /**\n   * Space that the resolution is happening from.\n   */\n  space?: SpaceId;\n\n  /**\n   * Queue that the resolution is happening from.\n   * This queue will be searched first, and then the space it belongs to.\n   */\n  queue?: DXN;\n}\n\nexport interface RefResolverOptions {\n  /**\n   * Resolution context.\n   * Affects how non-absolute DXNs are resolved.\n   */\n  context?: RefResolutionContext;\n\n  /**\n   * Middleware to change the resolved object before returning it.\n   * @deprecated On track to be removed.\n   */\n  middleware?: (obj: BaseObject) => BaseObject;\n}\n\n/**\n * Manages cross-space database interactions.\n */\nexport class Hypergraph {\n  private readonly _databases = new Map<SpaceId, EchoDatabaseImpl>();\n  private readonly _queueFactories = new Map<SpaceId, QueueFactory>();\n\n  // TODO(burdon): Comment/rename?\n  private readonly _owningObjects = new Map<SpaceId, unknown>();\n  private readonly _schemaRegistry = new RuntimeSchemaRegistry();\n  private readonly _updateEvent = new Event<ItemsUpdatedEvent>();\n  private readonly _resolveEvents = new Map<SpaceId, Map<string, Event<AnyLiveObject<any>>>>();\n  private readonly _queryContexts = new Set<GraphQueryContext>();\n  private readonly _querySourceProviders: QuerySourceProvider[] = [];\n\n  get schemaRegistry(): RuntimeSchemaRegistry {\n    return this._schemaRegistry;\n  }\n\n  /**\n   * @deprecated\n   */\n  // TODO(burdon): Use DXN.\n  // TODO(burdon): Ensure static and dynamic schema do not have overlapping type names.\n  async getSchemaByTypename(typename: string, db: EchoDatabase): Promise<BaseSchema | undefined> {\n    const schema = this.schemaRegistry.getSchema(typename);\n    if (schema) {\n      return new ImmutableSchema(schema);\n    }\n\n    return await db.schemaRegistry.query({ typename }).firstOrUndefined();\n  }\n\n  /**\n   * Register a database.\n   * @param spaceId Space id.\n   * @param spaceKey Space key.\n   * @param database Database backend.\n   * @param owningObject Database owner, usually a space.\n   */\n  // TODO(burdon): When is the owner not a space?\n  _registerDatabase(\n    spaceId: SpaceId,\n    /** @deprecated Use spaceId */\n    database: EchoDatabaseImpl,\n    owningObject?: unknown,\n  ): void {\n    this._databases.set(spaceId, database);\n    this._owningObjects.set(spaceId, owningObject);\n    database.coreDatabase._updateEvent.on(this._onUpdate.bind(this));\n\n    const map = this._resolveEvents.get(spaceId);\n    if (map) {\n      for (const [id, event] of map) {\n        const obj = database.getObjectById(id);\n        if (obj) {\n          log('resolve', { spaceId, objectId: id });\n          event.emit(obj);\n          map.delete(id);\n        }\n      }\n    }\n\n    for (const context of this._queryContexts.values()) {\n      context.addQuerySource(new SpaceQuerySource(database));\n    }\n  }\n\n  /**\n   * @internal\n   */\n  _unregisterDatabase(spaceId: SpaceId): void {\n    // TODO(dmaretskyi): Remove db from query contexts.\n    this._databases.delete(spaceId);\n  }\n\n  /**\n   * @internal\n   */\n  _registerQueueFactory(spaceId: SpaceId, factory: QueueFactory): void {\n    this._queueFactories.set(spaceId, factory);\n  }\n\n  /**\n   * @internal\n   */\n  _unregisterQueueFactory(spaceId: SpaceId): void {\n    this._queueFactories.delete(spaceId);\n  }\n\n  _getOwningObject(spaceId: SpaceId): unknown | undefined {\n    return this._owningObjects.get(spaceId);\n  }\n\n  // Odd way to define methods types from a typedef.\n  declare query: QueryFn;\n  static {\n    this.prototype.query = this.prototype._query;\n  }\n\n  private _query(query: Query.Any | Filter.Any, options?: QueryOptions) {\n    query = Filter.is(query) ? Query.select(query) : query;\n    // TODO(dmaretskyi): Consider plain format by default.\n    const resultFormat = options?.format ?? ResultFormat.Live;\n\n    if (typeof resultFormat !== 'string') {\n      throw new TypeError('Invalid result format');\n    }\n\n    switch (resultFormat) {\n      // TODO(dmaretskyi): Remove.\n      case ResultFormat.Plain: {\n        const spaceIds = options?.spaceIds;\n        invariant(spaceIds && spaceIds.length === 1, 'Plain format requires a single space.');\n        return new QueryResult(\n          this._createPlainObjectQueryContext(spaceIds[0] as SpaceId),\n          normalizeQuery(query, options),\n        );\n      }\n      case ResultFormat.Live: {\n        return new QueryResult(this._createLiveObjectQueryContext(), normalizeQuery(query, options));\n      }\n      // TODO(dmaretskyi): Remove.\n      case ResultFormat.AutomergeDocAccessor: {\n        throw new Error('Not implemented: ResultFormat.AutomergeDocAccessor');\n      }\n      default: {\n        throw new TypeError(`Invalid result format: ${resultFormat}`);\n      }\n    }\n  }\n\n  /**\n   * @param hostDb Host database for reference resolution.\n   * @param middleware Called with the loaded object. The caller may change the object.\n   * @returns Result of `onLoad`.\n   */\n  // TODO(dmaretskyi): Restructure API: Remove middleware, move `hostDb` into context option. Make accessible on Database objects.\n  createRefResolver({ context = {}, middleware = (obj) => obj }: RefResolverOptions): Ref.Resolver {\n    // TODO(dmaretskyi): Rewrite resolution algorithm with tracks for absolute and relative DXNs.\n\n    return {\n      // TODO(dmaretskyi): Respect `load` flag.\n      resolveSync: (dxn, load, onLoad) => {\n        // TODO(dmaretskyi): Add queue objects.\n        if (dxn.kind === DXN.kind.QUEUE && dxn.asQueueDXN()?.objectId === undefined) {\n          const { spaceId, subspaceTag, queueId } = dxn.asQueueDXN()!;\n          return this._resolveQueueSync(spaceId, subspaceTag as QueueSubspaceTag, queueId);\n        }\n\n        if (dxn.kind !== DXN.kind.ECHO) {\n          return undefined; // Unsupported DXN kind.\n        }\n\n        const res = this._resolveSync(dxn, context, onLoad);\n\n        if (res) {\n          return middleware(res);\n        } else {\n          return undefined;\n        }\n      },\n      resolve: async (dxn) => {\n        const obj = await this._resolveAsync(dxn, context);\n        if (obj) {\n          return middleware(obj);\n        } else {\n          return undefined;\n        }\n      },\n\n      resolveSchema: async (dxn) => {\n        const beginTime = TRACE_REF_RESOLUTION ? performance.now() : 0;\n        let status: string = '';\n        try {\n          switch (dxn.kind) {\n            case DXN.kind.TYPE: {\n              const schema = this.schemaRegistry.getSchemaByDXN(dxn);\n              status = schema != null ? 'resolved' : 'missing';\n              return schema;\n            }\n            case DXN.kind.ECHO: {\n              status = 'error';\n              throw new Error('Not implemented: Resolving schema stored in the database');\n            }\n            default: {\n              status = 'unknown dxn';\n              return undefined;\n            }\n          }\n        } finally {\n          if (TRACE_REF_RESOLUTION) {\n            log.info('resolveSchema', { dxn: dxn.toString(), status, time: performance.now() - beginTime });\n          }\n        }\n      },\n    } satisfies Ref.Resolver;\n  }\n\n  /**\n   * @param db\n   * @param ref\n   * @param onResolve will be weakly referenced.\n   */\n  private _resolveSync(\n    dxn: DXN,\n    context: RefResolutionContext,\n    onResolve?: (obj: AnyLiveObject<any>) => void,\n  ): AnyLiveObject<any> | undefined {\n    if (!dxn.asEchoDXN()) {\n      throw new Error('Unsupported DXN kind');\n    }\n    const dxnData = dxn.asEchoDXN()!;\n    const spaceId = dxnData.spaceId ?? context.space;\n    const objectId = dxnData.echoId;\n\n    if (spaceId === undefined) {\n      throw new Error('Unable to determine space to resolve the reference from');\n    }\n\n    const db = this._databases.get(spaceId);\n    if (db) {\n      // Resolve remote reference.\n      const obj = db.getObjectById(objectId);\n      if (obj) {\n        return obj;\n      }\n    }\n\n    // TODO(dmaretskyi): Consider throwing if space not found.\n\n    if (!OBJECT_DIAGNOSTICS.has(objectId)) {\n      OBJECT_DIAGNOSTICS.set(objectId, {\n        objectId,\n        spaceId,\n        loadReason: 'reference access',\n        loadedStack: new StackTrace(),\n      });\n    }\n\n    log('trap', { spaceId, objectId });\n    if (onResolve) {\n      entry(this._resolveEvents, spaceId)\n        .orInsert(new Map())\n        .deep(objectId)\n        .orInsert(new Event())\n        .value.on(new Context(), onResolve);\n    }\n  }\n\n  private async _resolveAsync(dxn: DXN, context: RefResolutionContext): Promise<AnyEchoObject | Queue | undefined> {\n    const beginTime = TRACE_REF_RESOLUTION ? performance.now() : 0;\n    let status: string = '';\n    try {\n      switch (dxn.kind) {\n        case DXN.kind.ECHO: {\n          if (!dxn.isLocalObjectId()) {\n            status = 'error';\n            throw new Error('Cross-space references are not supported');\n          }\n          const { echoId } = dxn.asEchoDXN() ?? failedInvariant();\n\n          if (context.queue) {\n            const { subspaceTag, spaceId, queueId } = context.queue.asQueueDXN() ?? failedInvariant();\n            const obj = await this._resolveQueueObjectAsync(spaceId, subspaceTag as QueueSubspaceTag, queueId, echoId);\n            if (obj) {\n              status = 'resolved';\n              return obj;\n            }\n          }\n\n          if (!context.space) {\n            status = 'error';\n            throw new Error('Resolving context-free references is not supported');\n          }\n\n          const obj = await this._resolveDatabaseObjectAsync(context.space, echoId);\n          if (obj) {\n            status = 'resolved';\n            return obj;\n          }\n\n          status = 'missing';\n          return undefined;\n        }\n        case DXN.kind.QUEUE: {\n          const { subspaceTag, spaceId, queueId, objectId } = dxn.asQueueDXN() ?? failedInvariant();\n          if (!objectId) {\n            status = 'error';\n            return this._resolveQueueSync(spaceId, subspaceTag as QueueSubspaceTag, queueId);\n          }\n\n          const obj = await this._resolveQueueObjectAsync(spaceId, subspaceTag as QueueSubspaceTag, queueId, objectId);\n          if (obj) {\n            status = 'resolved';\n            return obj;\n          }\n\n          status = 'missing queue';\n          return undefined;\n        }\n        default: {\n          status = 'error';\n          throw new Error(`Unsupported DXN kind: ${dxn.kind}`);\n        }\n      }\n    } finally {\n      if (TRACE_REF_RESOLUTION) {\n        log.info('resolve', { dxn: dxn.toString(), status, time: performance.now() - beginTime });\n      }\n    }\n  }\n\n  private async _resolveDatabaseObjectAsync(spaceId: SpaceId, objectId: ObjectId): Promise<AnyEchoObject | undefined> {\n    const db = this._databases.get(spaceId);\n    if (!db) {\n      return undefined;\n    }\n    const {\n      objects: [obj],\n    } = await db.query(Filter.ids(objectId)).run();\n    return obj;\n  }\n\n  private _resolveQueueSync(spaceId: SpaceId, subspaceTag: QueueSubspaceTag, queueId: ObjectId): Queue | undefined {\n    const queueFactory = this._queueFactories.get(spaceId);\n    if (!queueFactory) {\n      return undefined;\n    }\n    return queueFactory.get(DXN.fromQueue(subspaceTag, spaceId, queueId));\n  }\n\n  private async _resolveQueueObjectAsync(\n    spaceId: SpaceId,\n    subspaceTag: QueueSubspaceTag,\n    queueId: ObjectId,\n    objectId: ObjectId,\n  ): Promise<AnyEchoObject | undefined> {\n    const queueFactory = this._queueFactories.get(spaceId);\n    if (!queueFactory) {\n      return undefined;\n    }\n    const queue = queueFactory.get(DXN.fromQueue(subspaceTag, spaceId, queueId));\n    if (!queue) {\n      return undefined;\n    }\n    const [obj] = await queue.getObjectsById([objectId]);\n    return obj ?? undefined;\n  }\n\n  registerQuerySourceProvider(provider: QuerySourceProvider): void {\n    this._querySourceProviders.push(provider);\n    for (const context of this._queryContexts.values()) {\n      context.addQuerySource(provider.create());\n    }\n  }\n\n  /**\n   * Does not remove the provider from active query contexts.\n   */\n  unregisterQuerySourceProvider(provider: QuerySourceProvider): void {\n    const index = this._querySourceProviders.indexOf(provider);\n    if (index !== -1) {\n      this._querySourceProviders.splice(index, 1);\n    }\n  }\n\n  private _onUpdate(updateEvent: ItemsUpdatedEvent): void {\n    const listenerMap = this._resolveEvents.get(updateEvent.spaceId);\n    if (listenerMap) {\n      compositeRuntime.batch(() => {\n        // TODO(dmaretskyi): We only care about created items.\n        for (const item of updateEvent.itemsUpdated) {\n          const listeners = listenerMap.get(item.id);\n          if (!listeners) {\n            continue;\n          }\n          const db = this._databases.get(updateEvent.spaceId);\n          if (!db) {\n            continue;\n          }\n          const obj = db.getObjectById(item.id);\n          if (!obj) {\n            continue;\n          }\n          log('resolve', { spaceId: updateEvent.spaceId, objectId: obj.id });\n          listeners.emit(obj);\n          listenerMap.delete(item.id);\n        }\n      });\n    }\n    this._updateEvent.emit(updateEvent);\n  }\n\n  private _createLiveObjectQueryContext(): QueryContext {\n    const context = new GraphQueryContext({\n      onStart: () => {\n        this._queryContexts.add(context);\n      },\n      onStop: () => {\n        this._queryContexts.delete(context);\n      },\n    });\n    for (const database of this._databases.values()) {\n      context.addQuerySource(new SpaceQuerySource(database));\n    }\n    for (const provider of this._querySourceProviders) {\n      context.addQuerySource(provider.create());\n    }\n\n    return context;\n  }\n\n  private _createPlainObjectQueryContext(spaceId: SpaceId): QueryContext {\n    const space = this._databases.get(spaceId) ?? raise(new Error(`Space not found: ${spaceId}`));\n    return space._coreDatabase._createQueryContext();\n  }\n}\n\nexport interface QuerySourceProvider {\n  create(): QuerySource;\n}\n\ntype ObjectDiagnostic = {\n  objectId: string;\n  spaceId: string;\n  loadReason: string;\n  loadedStack?: StackTrace;\n  query?: string;\n};\n\nexport const OBJECT_DIAGNOSTICS = new Map<string, ObjectDiagnostic>();\n\ntrace.diagnostic({\n  id: 'referenced-objects',\n  name: 'Referenced Objects (Client)',\n  fetch: () => {\n    return Array.from(OBJECT_DIAGNOSTICS.values()).map((object) => {\n      return {\n        objectId: object.objectId,\n        spaceId: object.spaceId,\n        loadReason: object.loadReason,\n        creationStack: object.loadedStack?.getStack(),\n        query: object.query,\n      };\n    });\n  },\n});\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { Schema } from 'effect';\n\nimport { Event, type CleanupFn } from '@dxos/async';\nimport { Resource, type Context } from '@dxos/context';\nimport {\n  TypeIdentifierAnnotationId,\n  EchoSchema,\n  getTypeIdentifierAnnotation,\n  getTypeAnnotation,\n  TypeAnnotationId,\n  StoredSchema,\n  toJsonSchema,\n  type ObjectId,\n  create,\n  createJsonSchema,\n} from '@dxos/echo-schema';\nimport { invariant } from '@dxos/invariant';\nimport { DXN } from '@dxos/keys';\nimport { log } from '@dxos/log';\n\nimport { type EchoDatabase } from './database';\nimport type {\n  RegisterSchemaInput,\n  SchemaRegistry,\n  SchemaRegistryPreparedQuery,\n  SchemaRegistryQuery,\n  SchemaSubscriptionCallback,\n} from './schema-registry-api';\nimport { SchemaRegistryPreparedQueryImpl } from './schema-registry-prepared-query';\nimport { getObjectCore } from '../echo-handler';\nimport { Filter } from '../query';\n\nexport type EchoSchemaRegistryOptions = {\n  /**\n   * Run a reactive query for dynamic schemas.\n   * @default true\n   */\n  reactiveQuery?: boolean;\n\n  /**\n   * Preload all schema during open.\n   * @default true\n   */\n  preloadSchemaOnOpen?: boolean;\n};\n\n/**\n * Per-space set of mutable schemas.\n */\n// TODO(burdon): Reconcile with RuntimeSchemaRegistry.\nexport class EchoSchemaRegistry extends Resource implements SchemaRegistry {\n  private readonly _reactiveQuery: boolean;\n  private readonly _preloadSchemaOnOpen: boolean;\n\n  private readonly _schemaById: Map<string, EchoSchema> = new Map();\n  private readonly _schemaByType: Map<string, EchoSchema> = new Map();\n  private readonly _unsubscribeById: Map<string, CleanupFn> = new Map();\n  private readonly _schemaSubscriptionCallbacks: SchemaSubscriptionCallback[] = [];\n\n  constructor(\n    private readonly _db: EchoDatabase,\n    { reactiveQuery = true, preloadSchemaOnOpen = true }: EchoSchemaRegistryOptions = {},\n  ) {\n    super();\n    this._reactiveQuery = reactiveQuery;\n    this._preloadSchemaOnOpen = preloadSchemaOnOpen;\n  }\n\n  protected override async _open(ctx: Context): Promise<void> {\n    // Preloading schema is required for ECHO to operate.\n    // TODO(dmaretskyi): Does this change with strong object deps.\n    if (this._preloadSchemaOnOpen) {\n      const { objects } = await this._db.query(Filter.type(StoredSchema)).run();\n\n      objects.forEach((object) => this._registerSchema(object));\n    }\n\n    if (this._reactiveQuery) {\n      const unsubscribe = this._db.query(Filter.type(StoredSchema)).subscribe(({ objects }) => {\n        const currentObjectIds = new Set(objects.map((o) => o.id));\n        const newObjects = objects.filter((object) => !this._schemaById.has(object.id));\n        const removedObjects = [...this._schemaById.keys()].filter((oid) => !currentObjectIds.has(oid));\n        newObjects.forEach((obj) => this._register(obj));\n        removedObjects.forEach((idoid) => this._unregister(idoid));\n        if (newObjects.length > 0 || removedObjects.length > 0) {\n          this._notifySchemaListChanged();\n        }\n      });\n      this._ctx.onDispose(unsubscribe);\n    }\n  }\n\n  protected override async _close(ctx: Context): Promise<void> {\n    // Nothing to do.\n  }\n\n  query(query: SchemaRegistryQuery = {}): SchemaRegistryPreparedQuery<EchoSchema> {\n    const self = this;\n\n    const filterOrderResults = (schemas: EchoSchema[]) => {\n      log('Filtering schemas', { schemas, query });\n      return (\n        schemas\n          .filter((schema) => validateStoredSchemaIntegrity(schema.storedSchema))\n          .filter((object) => {\n            const idFilter = coerceArray(query.id);\n            if (idFilter.length > 0) {\n              if (object.jsonSchema.$id && !idFilter.includes(object.jsonSchema.$id)) {\n                return false;\n              }\n            }\n\n            const backingObjectIdFilter = coerceArray(query.backingObjectId);\n            if (backingObjectIdFilter.length > 0) {\n              if (!backingObjectIdFilter.includes(object.id)) {\n                return false;\n              }\n            }\n\n            const typenameFilter = coerceArray(query.typename);\n            if (typenameFilter.length > 0) {\n              if (!typenameFilter.includes(object.typename)) {\n                return false;\n              }\n            }\n\n            if (query.version) {\n              if (!query.version.match(/^[0-9.]+$/)) {\n                throw new Error('Semver version ranges not supported.');\n              }\n\n              if (object.version !== query.version) {\n                return false;\n              }\n            }\n\n            return true;\n          })\n          // TODO(dmaretskyi): Come up with a better stable sorting method (e.g. [typename, version, id]).\n          .sort((a, b) => a.id.localeCompare(b.id))\n      );\n    };\n\n    const changes = new Event();\n    let unsubscribe: CleanupFn | undefined;\n    return new SchemaRegistryPreparedQueryImpl({\n      changes,\n      getResultsSync() {\n        const objects = self._db\n          .query(Filter.type(StoredSchema))\n          .runSync()\n          .map((result) => result.object)\n          .filter((object) => object != null);\n\n        const results = filterOrderResults(\n          objects.map((stored) => {\n            return self._register(stored);\n          }),\n        );\n        return results;\n      },\n      async getResults() {\n        const { objects } = await self._db.query(Filter.type(StoredSchema)).run();\n\n        return filterOrderResults(\n          objects.map((stored) => {\n            return self._register(stored);\n          }),\n        );\n      },\n      async start() {\n        if (unsubscribe) {\n          return;\n        }\n        unsubscribe = self._subscribe(() => {\n          changes.emit();\n        });\n      },\n      async stop() {\n        unsubscribe?.();\n        unsubscribe = undefined;\n      },\n    });\n  }\n\n  // TODO(burdon): Tighten type signature to TypedObject?\n  async register(inputs: RegisterSchemaInput[]): Promise<EchoSchema[]> {\n    const results: EchoSchema[] = [];\n\n    // TODO(dmaretskyi): Check for conflicts with the schema in the DB.\n    for (const input of inputs) {\n      if (!Schema.isSchema(input)) {\n        throw new TypeError('Invalid schema');\n      }\n      results.push(this._addSchema(input));\n    }\n    return results;\n  }\n\n  public hasSchema(schema: Schema.Schema.AnyNoContext): boolean {\n    const schemaId = schema instanceof EchoSchema ? schema.id : getObjectIdFromSchema(schema);\n    return schemaId != null && this.getSchemaById(schemaId) != null;\n  }\n\n  /**\n   * @deprecated Use `query` instead.\n   */\n  public getSchema(typename: string): EchoSchema | undefined {\n    return this.query({ typename }).runSync()[0];\n  }\n\n  /**\n   * @deprecated Use `query` instead.\n   */\n  public getSchemaById(id: string): EchoSchema | undefined {\n    const existing = this._schemaById.get(id);\n    if (existing != null) {\n      return existing;\n    }\n\n    const typeObject = this._db.getObjectById(id);\n    if (typeObject == null) {\n      return undefined;\n    }\n\n    if (!Schema.is(StoredSchema)(typeObject)) {\n      log.warn('type object is not a stored schema', { id: typeObject?.id });\n      return undefined;\n    }\n\n    return this._register(typeObject);\n  }\n\n  /**\n   * @internal\n   *\n   * Registers a StoredSchema object if necessary and returns a EchoSchema object.\n   */\n  _registerSchema(schema: StoredSchema): EchoSchema {\n    const existing = this._schemaById.get(schema.id);\n    if (existing != null) {\n      return existing;\n    }\n\n    const registered = this._register(schema);\n    this._notifySchemaListChanged();\n    return registered;\n  }\n\n  private _register(schema: StoredSchema): EchoSchema {\n    const existing = this._schemaById.get(schema.id);\n    if (existing != null) {\n      return existing;\n    }\n\n    let previousTypename: string | undefined;\n    const echoSchema = new EchoSchema(schema);\n    const subscription = getObjectCore(schema).updates.on(() => {\n      echoSchema._invalidate();\n    });\n\n    if (previousTypename !== undefined && schema.typename !== previousTypename) {\n      if (this._schemaByType.get(previousTypename) === echoSchema) {\n        this._schemaByType.delete(previousTypename);\n      }\n      previousTypename = schema.typename;\n      this._schemaByType.set(schema.typename, echoSchema);\n      this._notifySchemaListChanged();\n    }\n\n    this._schemaById.set(schema.id, echoSchema);\n    this._schemaByType.set(schema.typename, echoSchema);\n    this._unsubscribeById.set(schema.id, subscription);\n    return echoSchema;\n  }\n\n  // TODO(dmaretskyi): Figure out how to migrate the usages to the async `register` method.\n  private _addSchema(schema: Schema.Schema.AnyNoContext): EchoSchema {\n    if (schema instanceof EchoSchema) {\n      schema = schema.snapshot.annotations({\n        [TypeIdentifierAnnotationId]: undefined,\n      });\n    }\n\n    const meta = getTypeAnnotation(schema);\n    invariant(meta, 'use Schema.Struct({}).pipe(Type.Obj()) or class syntax to create a valid schema');\n    const schemaToStore = create(StoredSchema, { ...meta, jsonSchema: createJsonSchema() });\n    schemaToStore.jsonSchema = toJsonSchema(\n      schema.annotations({\n        [TypeAnnotationId]: meta,\n        [TypeIdentifierAnnotationId]: `dxn:echo:@:${schemaToStore.id}`,\n      }),\n    );\n\n    const storedSchema = this._db.add(schemaToStore);\n    const result = this._register(storedSchema);\n\n    this._notifySchemaListChanged();\n    result._rebuild();\n    return result;\n  }\n\n  private _unregister(id: string): void {\n    const schema = this._schemaById.get(id);\n    if (schema != null) {\n      this._schemaById.delete(id);\n      this._schemaByType.delete(schema.typename);\n      this._unsubscribeById.get(schema.id)?.();\n      this._unsubscribeById.delete(schema.id);\n    }\n  }\n\n  private _subscribe(callback: SchemaSubscriptionCallback): CleanupFn {\n    callback([...this._schemaById.values()]);\n    this._schemaSubscriptionCallbacks.push(callback);\n    return () => {\n      const index = this._schemaSubscriptionCallbacks.indexOf(callback);\n      if (index >= 0) {\n        this._schemaSubscriptionCallbacks.splice(index, 1);\n      }\n    };\n  }\n\n  private _notifySchemaListChanged(): void {\n    const list = [...this._schemaById.values()];\n    this._schemaSubscriptionCallbacks.forEach((s) => s(list));\n  }\n}\n\nconst coerceArray = <T>(arr: T | T[] | undefined): T[] => {\n  if (arr === undefined) {\n    return [];\n  }\n  return Array.isArray(arr) ? arr : [arr];\n};\n\nconst validateStoredSchemaIntegrity = (schema: StoredSchema) => {\n  if (!schema.jsonSchema.$id && !schema.jsonSchema.$id?.startsWith('dxn:')) {\n    log.warn('Schema is missing $id or has invalid $id', { schema });\n    return false;\n  }\n\n  if (schema.jsonSchema.type !== 'object') {\n    log.warn('Schema is not of object type', { schema });\n    return false;\n  }\n\n  return true;\n};\n\nconst getObjectIdFromSchema = (schema: Schema.Schema.AnyNoContext): ObjectId | undefined => {\n  const echoIdentifier = getTypeIdentifierAnnotation(schema);\n  if (!echoIdentifier) {\n    return undefined;\n  }\n\n  const dxn = DXN.parse(echoIdentifier);\n  invariant(dxn.isLocalObjectId());\n  return dxn.parts[1];\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { Event, Mutex, type CleanupFn } from '@dxos/async';\nimport { log } from '@dxos/log';\n\nimport type { SchemaRegistryPreparedQuery } from './schema-registry-api';\n\nexport interface SchemaRegistryQueryResolver<T> {\n  changes: Event<void>;\n\n  /**\n   * Start reactive query.\n   */\n  start(): Promise<void>;\n\n  /**\n   * Stop reactive query.\n   */\n  stop(): Promise<void>;\n\n  getResults(): Promise<T[]>;\n  getResultsSync(): T[];\n}\n\n/**\n * API for the schema queries.\n */\nexport class SchemaRegistryPreparedQueryImpl<T> implements SchemaRegistryPreparedQuery<T> {\n  private readonly _mutex = new Mutex();\n  private readonly _changes = new Event<this>();\n  private _isReactiveQueryRunning = false;\n  private _subscriberCount = 0;\n  private _isFiring = false;\n\n  constructor(private readonly _resolver: SchemaRegistryQueryResolver<T>) {}\n\n  get results(): T[] {\n    if (!this._isReactiveQueryRunning && !this._isFiring) {\n      throw new Error(\n        'Query must have at least 1 subscriber for `.results` to be used. Use query.run() for single-use result retrieval.',\n      );\n    }\n    return this._resolver.getResultsSync();\n  }\n\n  run(): Promise<T[]> {\n    return this._resolver.getResults();\n  }\n\n  runSync(): T[] {\n    return this._resolver.getResultsSync();\n  }\n\n  async first(): Promise<T> {\n    const results = await this._resolver.getResults();\n    if (results.length === 0) {\n      throw new Error('Query returned 0 entries');\n    }\n\n    return results[0];\n  }\n\n  async firstOrUndefined(): Promise<T | undefined> {\n    const results = await this._resolver.getResults();\n    return results[0];\n  }\n\n  subscribe(cb?: (self: this) => void, opts?: { fire?: boolean }): CleanupFn {\n    if (cb) {\n      this._changes.on(cb);\n    }\n    this._subscriberCount++;\n    this._onSubscriberCountChange();\n\n    if (opts?.fire) {\n      if (!cb) {\n        throw new Error('Cannot fire without a callback');\n      }\n      try {\n        this._isFiring = true;\n        cb(this);\n      } finally {\n        this._isFiring = false;\n      }\n    }\n\n    return () => {\n      if (cb) {\n        this._changes.off(cb);\n      }\n      this._subscriberCount--;\n      this._onSubscriberCountChange();\n    };\n  }\n\n  private _onSubscriberCountChange(): void {\n    if (this._subscriberCount === 0) {\n      this._stop();\n    } else if (this._subscriberCount > 0) {\n      this._start();\n    }\n  }\n\n  private _start(): void {\n    if (this._isReactiveQueryRunning) {\n      return;\n    }\n    queueMicrotask(async () => {\n      using _guard = await this._mutex.acquire();\n      if (this._isReactiveQueryRunning) {\n        return;\n      }\n\n      try {\n        await this._resolver.start();\n        this._isReactiveQueryRunning = true;\n      } catch (err) {\n        log.catch(err);\n      }\n    });\n  }\n\n  private _stop(): void {\n    if (!this._isReactiveQueryRunning) {\n      return;\n    }\n    queueMicrotask(async () => {\n      using _guard = await this._mutex.acquire();\n      if (!this._isReactiveQueryRunning) {\n        return;\n      }\n\n      try {\n        await this._resolver.stop();\n        this._isReactiveQueryRunning = false;\n      } catch (err) {\n        log.catch(err);\n      }\n    });\n  }\n}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { inspect } from 'node:util';\n\nimport { Event, type ReadOnlyEvent, synchronized } from '@dxos/async';\nimport { LifecycleState, Resource } from '@dxos/context';\nimport { inspectObject } from '@dxos/debug';\nimport {\n  assertObjectModelShape,\n  type AnyEchoObject,\n  type AnyObjectData,\n  type BaseObject,\n  type HasId,\n} from '@dxos/echo-schema';\nimport { getSchema } from '@dxos/echo-schema';\nimport { invariant } from '@dxos/invariant';\nimport { DXN, type PublicKey, type SpaceId } from '@dxos/keys';\nimport { type Live, getProxyTarget, getType, isLiveObject } from '@dxos/live-object';\nimport { log } from '@dxos/log';\nimport { type QueryService } from '@dxos/protocols/proto/dxos/echo/query';\nimport { type DataService } from '@dxos/protocols/proto/dxos/echo/service';\nimport { defaultMap } from '@dxos/util';\n\nimport { EchoSchemaRegistry } from './echo-schema-registry';\nimport type { ObjectMigration } from './object-migration';\nimport {\n  CoreDatabase,\n  type FlushOptions,\n  type LoadObjectOptions,\n  type ObjectCore,\n  type ObjectPlacement,\n} from '../core-db';\nimport type { InsertBatch, InsertData, UpdateOperation } from '../core-db/crud-api';\nimport {\n  EchoReactiveHandler,\n  type ProxyTarget,\n  type AnyLiveObject,\n  createObject,\n  getObjectCore,\n  initEchoReactiveObjectRootProxy,\n  isEchoObject,\n} from '../echo-handler';\nimport { type Hypergraph } from '../hypergraph';\nimport { Filter, type QueryFn, type QueryOptions, Query } from '../query';\n\nexport type GetObjectByIdOptions = {\n  deleted?: boolean;\n};\n\nexport type AddOptions = {\n  /**\n   * Where to place the object in the Automerge document tree.\n   * Root document is always loaded with the space.\n   * Linked documents are loaded lazily.\n   * Placing large number of objects in the root document may slow down the initial load.\n   *\n   * @default 'linked-doc'\n   */\n  placeIn?: ObjectPlacement;\n};\n\n/**\n *\n */\nexport interface EchoDatabase {\n  get graph(): Hypergraph;\n  get schemaRegistry(): EchoSchemaRegistry;\n\n  get spaceKey(): PublicKey;\n  get spaceId(): SpaceId;\n\n  toJSON(): object;\n\n  getObjectById<T extends BaseObject = any>(id: string, opts?: GetObjectByIdOptions): AnyLiveObject<T> | undefined;\n\n  /**\n   * Query objects.\n   */\n  query: QueryFn;\n\n  /**\n   * Adds object to the database.\n   */\n  // TODO(dmaretskyi): Lock to Obj.Any | Relation.Any.\n  add<T extends AnyEchoObject>(obj: Live<T>, opts?: AddOptions): Live<T & HasId>;\n\n  /**\n   * Removes object from the database.\n   */\n  // TODO(dmaretskyi): Lock to Obj.Any | Relation.Any.\n  remove<T extends AnyEchoObject>(obj: T): void;\n\n  /**\n   * Wait for all pending changes to be saved to disk.\n   */\n  flush(opts?: FlushOptions): Promise<void>;\n\n  /**\n   * Update objects.\n   * @deprecated Use `add` instead.\n   */\n  // TODO(burdon): Remove.\n  update(filter: Filter.Any, operation: UpdateOperation): Promise<void>;\n\n  /**\n   * Insert new objects.\n   * @deprecated Use `add` instead.\n   */\n  // TODO(burdon): Remove.\n  // TODO(dmaretskyi): Support meta.\n  insert(data: InsertData): Promise<AnyObjectData>;\n  insert(data: InsertBatch): Promise<AnyObjectData[]>;\n\n  /**\n   * Run migrations.\n   */\n  runMigrations(migrations: ObjectMigration[]): Promise<void>;\n\n  /**\n   * @deprecated\n   */\n  readonly pendingBatch: ReadOnlyEvent<unknown>;\n\n  /**\n   * @deprecated\n   */\n  readonly coreDatabase: CoreDatabase;\n}\n\nexport type EchoDatabaseParams = {\n  graph: Hypergraph;\n  dataService: DataService;\n  queryService: QueryService;\n  spaceId: SpaceId;\n\n  /**\n   * Run a reactive query for a set of dynamic schema.\n   * @default true\n   */\n  reactiveSchemaQuery?: boolean;\n\n  preloadSchemaOnOpen?: boolean;\n\n  /** @deprecated Use spaceId */\n  spaceKey: PublicKey;\n};\n\n/**\n * API for the database.\n * Implements EchoDatabase interface.\n */\nexport class EchoDatabaseImpl extends Resource implements EchoDatabase {\n  private readonly _schemaRegistry: EchoSchemaRegistry;\n  /**\n   * @internal\n   */\n  _coreDatabase: CoreDatabase;\n\n  private _rootUrl: string | undefined = undefined;\n\n  /**\n   * Mapping `object core` -> `root proxy` (User facing proxies).\n   * @internal\n   */\n  readonly _rootProxies = new Map<ObjectCore, AnyLiveObject<any>>();\n\n  constructor(params: EchoDatabaseParams) {\n    super();\n\n    this._coreDatabase = new CoreDatabase({\n      graph: params.graph,\n      dataService: params.dataService,\n      queryService: params.queryService,\n      spaceId: params.spaceId,\n      spaceKey: params.spaceKey,\n    });\n\n    this._schemaRegistry = new EchoSchemaRegistry(this, {\n      reactiveQuery: params.reactiveSchemaQuery,\n      preloadSchemaOnOpen: params.preloadSchemaOnOpen,\n    });\n  }\n\n  [inspect.custom]() {\n    return inspectObject(this);\n  }\n\n  toJSON() {\n    return this._coreDatabase.toJSON();\n  }\n\n  get spaceId(): SpaceId {\n    return this._coreDatabase.spaceId;\n  }\n\n  /**\n   * @deprecated Use `spaceId`.\n   */\n  get spaceKey(): PublicKey {\n    return this._coreDatabase.spaceKey;\n  }\n\n  get rootUrl(): string | undefined {\n    return this._rootUrl;\n  }\n\n  get graph(): Hypergraph {\n    return this._coreDatabase.graph;\n  }\n\n  // TODO(burdon): Rename.\n  get schemaRegistry(): EchoSchemaRegistry {\n    return this._schemaRegistry;\n  }\n\n  @synchronized\n  protected override async _open(): Promise<void> {\n    if (this._rootUrl !== undefined) {\n      await this._coreDatabase.open({ rootUrl: this._rootUrl });\n    }\n    await this._schemaRegistry.open();\n  }\n\n  @synchronized\n  protected override async _close(): Promise<void> {\n    await this._schemaRegistry.close();\n    await this._coreDatabase.close();\n  }\n\n  @synchronized\n  async setSpaceRoot(rootUrl: string): Promise<void> {\n    log('setSpaceRoot', { rootUrl });\n    const firstTime = this._rootUrl === undefined;\n    this._rootUrl = rootUrl;\n    if (this._lifecycleState === LifecycleState.OPEN) {\n      if (firstTime) {\n        await this._coreDatabase.open({ rootUrl });\n      } else {\n        await this._coreDatabase.updateSpaceState({ rootUrl });\n      }\n    }\n  }\n\n  getObjectById(id: string, { deleted = false } = {}): AnyLiveObject<any> | undefined {\n    const core = this._coreDatabase.getObjectCoreById(id);\n    if (!core || (core.isDeleted() && !deleted)) {\n      return undefined;\n    }\n\n    const object = defaultMap(this._rootProxies, core, () => initEchoReactiveObjectRootProxy(core, this));\n    invariant(isLiveObject(object));\n    return object;\n  }\n\n  // Odd way to define methods types from a typedef.\n  declare query: QueryFn;\n  static {\n    this.prototype.query = this.prototype._query;\n  }\n\n  private _query(query: Query.Any | Filter.Any, options?: QueryOptions) {\n    query = Filter.is(query) ? Query.select(query) : query;\n    return this._coreDatabase.graph.query(query, {\n      ...options,\n      spaceIds: [this.spaceId],\n    });\n  }\n\n  /**\n   * Update objects.\n   */\n  async update(filter: Filter.Any, operation: UpdateOperation): Promise<void> {\n    await this._coreDatabase.update(filter, operation);\n  }\n\n  // TODO(dmaretskyi): Support meta.\n  async insert(data: InsertData): Promise<AnyObjectData>;\n  async insert(data: InsertBatch): Promise<AnyObjectData[]>;\n  async insert(data: InsertData | InsertBatch): Promise<AnyObjectData | AnyObjectData[]> {\n    return this._coreDatabase.insert(data);\n  }\n\n  /**\n   * Add reactive object.\n   */\n  // TODO(dmaretskyi): Lock to Obj.Any | Relation.Any.\n  add<T extends BaseObject>(obj: T, opts?: AddOptions): Live<T & HasId> {\n    if (!isEchoObject(obj)) {\n      const schema = getSchema(obj);\n      if (schema != null) {\n        if (!this.schemaRegistry.hasSchema(schema) && !this.graph.schemaRegistry.hasSchema(schema)) {\n          throw createSchemaNotRegisteredError(schema);\n        }\n      }\n\n      obj = createObject(obj);\n    }\n    assertObjectModelShape(obj);\n\n    // TODO(burdon): Check if already added to db?\n    invariant(isEchoObject(obj));\n    this._rootProxies.set(getObjectCore(obj), obj);\n\n    const target = getProxyTarget(obj) as ProxyTarget;\n    EchoReactiveHandler.instance.setDatabase(target, this);\n    EchoReactiveHandler.instance.saveRefs(target);\n    this._coreDatabase.addCore(getObjectCore(obj), opts);\n\n    return obj as any;\n  }\n\n  /**\n   * Remove reactive object.\n   */\n  remove<T extends BaseObject>(obj: T): void {\n    invariant(isEchoObject(obj));\n    return this._coreDatabase.removeCore(getObjectCore(obj));\n  }\n\n  async flush(opts?: FlushOptions): Promise<void> {\n    await this._coreDatabase.flush(opts);\n  }\n\n  async runMigrations(migrations: ObjectMigration[]): Promise<void> {\n    for (const migration of migrations) {\n      const { objects } = await this._coreDatabase.graph.query(Query.select(Filter.typeDXN(migration.fromType))).run();\n      log.verbose('migrate', { from: migration.fromType, to: migration.toType, objects: objects.length });\n      for (const object of objects) {\n        const output = await migration.transform(object, { db: this });\n\n        // TODO(dmaretskyi): Output validation.\n        delete (output as any).id;\n\n        await this._coreDatabase.atomicReplaceObject(object.id, {\n          data: output,\n          type: migration.toType,\n        });\n        const postMigrationType = getType(object);\n        invariant(postMigrationType != null && DXN.equals(postMigrationType, migration.toType));\n\n        await migration.onMigration({ before: object, object, db: this });\n      }\n    }\n    await this.flush();\n  }\n\n  /**\n   * @internal\n   */\n  async _loadObjectById<T extends BaseObject>(\n    objectId: string,\n    options: LoadObjectOptions = {},\n  ): Promise<AnyLiveObject<T> | undefined> {\n    const core = await this._coreDatabase.loadObjectCoreById(objectId, options);\n    if (!core || core?.isDeleted()) {\n      return undefined;\n    }\n\n    const obj = defaultMap(this._rootProxies, core, () => initEchoReactiveObjectRootProxy(core, this));\n    invariant(isLiveObject(obj));\n    return obj;\n  }\n\n  //\n  // Deprecated API.\n  //\n\n  /**\n   * @deprecated\n   */\n  readonly pendingBatch = new Event<unknown>();\n\n  /**\n   * @deprecated\n   */\n  get coreDatabase(): CoreDatabase {\n    return this._coreDatabase;\n  }\n}\n\n// TODO(burdon): Create APIError class.\nconst createSchemaNotRegisteredError = (schema?: any) => {\n  const message = 'Schema not registered';\n  if (schema?.typename) {\n    return new Error(`${message} Schema: ${schema.typename}`);\n  }\n\n  return new Error(message);\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { asyncTimeout } from '@dxos/async';\nimport type { BaseEchoObject } from '@dxos/echo-schema';\n\nimport { getObjectCore, type AnyLiveObject } from '../echo-handler';\n\n/**\n * @param obj\n */\n// TODO(burdon): Rename/review SDK.\nexport const loadObject = <T extends BaseEchoObject>(obj: T): T => {\n  return getObjectCore(obj).getDecoded(['data']) as any;\n};\n\n/**\n * EXPERIMENTAL - the API is subject to change.\n * @param objOrArray - an echo object or collection of objects with references to other echo objects.\n * @param valueAccessor - selector for a reference that needs to be loaded.\n *                        if return type is an array the method exits when all entries are non-null.\n *                        otherwise the method exits when valueAccessor is not null.\n * @param timeout - loading timeout, defaults to 5s.\n *\n * @deprecated Use `await Ref.load()` instead.\n */\n// TODO(burdon): Rename/review SDK.\nexport const loadObjectReferences = async <\n  T extends AnyLiveObject<any>,\n  RefType,\n  DerefType = RefType extends Array<infer U> ? Array<NonNullable<U>> : NonNullable<RefType>,\n>(\n  // TODO(burdon): Must be T OR T[] not either.\n  objOrArray: T | T[],\n  valueAccessor: (obj: T) => RefType,\n  { timeout }: { timeout: number } = { timeout: 5_000 },\n): Promise<T extends T[] ? Array<DerefType> : DerefType> => {\n  const objectArray = Array.isArray(objOrArray) ? objOrArray : [objOrArray];\n  const tasks = objectArray.map((obj) => {\n    const core = getObjectCore(obj as any);\n    const value = valueAccessor(obj);\n    if (core.database == null) {\n      return value;\n    }\n\n    const isLoadedPredicate = Array.isArray(value)\n      ? () => (valueAccessor(obj) as any[]).every((v) => v != null)\n      : () => valueAccessor(obj) != null;\n    if (isLoadedPredicate()) {\n      return value;\n    }\n\n    // TODO(burdon): Timeout if trying to load object that isn't there.\n    return asyncTimeout(\n      core.database._updateEvent.waitFor(() => isLoadedPredicate()).then(() => valueAccessor(obj)),\n      timeout,\n    );\n  });\n\n  const result = await Promise.all(tasks);\n  return (Array.isArray(objOrArray) ? result : result[0]) as any;\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { type Schema } from 'effect';\n\nimport type { Type } from '@dxos/echo';\nimport { getSchemaDXN } from '@dxos/echo-schema';\nimport { type DXN } from '@dxos/keys';\n\nimport type { EchoDatabase } from './database';\nimport type { AnyLiveObject } from '../echo-handler';\n\ntype DefineObjectMigrationOptions<From extends Schema.Schema.AnyNoContext, To extends Schema.Schema.AnyNoContext> = {\n  from: From;\n  to: To;\n  /**\n   * Pure function that converts the old object data to the new object data.\n   */\n  // TODO(dmaretskyi): `id` should not be a part of the schema.\n  transform: (\n    from: Schema.Schema.Type<From>,\n    context: ObjectMigrationContext,\n  ) => Promise<Omit<Schema.Schema.Type<To>, 'id' | Type.KindId>>;\n\n  /**\n   * Callback that is called after the object is migrated. Called for every object that is migrated.\n   *\n   * NOTE: Database mutations performed in this callback are not guaranteed to be idempotent.\n   *       If multiple peers run the migration separately, the effects may be applied multiple times.\n   */\n  onMigration: (params: OnMigrateParams<From, To>) => Promise<void>;\n};\n\n// TODO(dmaretskyi): For future extensibility.\ntype ObjectMigrationContext = {};\n\ntype OnMigrateParams<From extends Schema.Schema.AnyNoContext, To extends Schema.Schema.AnyNoContext> = {\n  before: Schema.Schema.Type<From>;\n  object: AnyLiveObject<Schema.Schema.Type<To>>;\n  db: EchoDatabase;\n};\n\nexport type ObjectMigration = {\n  fromType: DXN;\n  toType: DXN;\n  fromSchema: Schema.Schema.AnyNoContext;\n  toSchema: Schema.Schema.AnyNoContext;\n  transform: (from: unknown, context: ObjectMigrationContext) => Promise<unknown>;\n  onMigration: (params: OnMigrateParams<any, any>) => Promise<void>;\n};\n\nexport const defineObjectMigration = <From extends Schema.Schema.AnyNoContext, To extends Schema.Schema.AnyNoContext>(\n  options: DefineObjectMigrationOptions<From, To>,\n): ObjectMigration => {\n  const fromType = getSchemaDXN(options.from);\n  if (!fromType) {\n    throw new Error('Invalid from schema');\n  }\n  const toType = getSchemaDXN(options.to);\n  if (!toType) {\n    throw new Error('Invalid to schema');\n  }\n\n  return {\n    fromType,\n    toType,\n    fromSchema: options.from,\n    toSchema: options.to,\n    transform: options.transform as any,\n    onMigration: options.onMigration as any,\n  };\n};\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { type Obj, type Relation } from '@dxos/echo';\nimport { ObjectId, type BaseEchoObject, type HasId } from '@dxos/echo-schema';\nimport { compositeRuntime } from '@dxos/echo-signals/runtime';\nimport { invariant } from '@dxos/invariant';\nimport { DXN, SpaceId } from '@dxos/keys';\n\nimport { type Queue } from './types';\n\nexport type MemoryQueueOptions<T extends BaseEchoObject = BaseEchoObject> = {\n  spaceId?: SpaceId;\n  queueId?: string;\n  dxn?: DXN;\n  objects?: T[];\n};\n\n/**\n * In-memory queue.\n * @deprecated Use the actual queue with a mock service.\n */\nexport class MemoryQueue<T extends Obj.Any | Relation.Any = Obj.Any | Relation.Any> implements Queue<T> {\n  static make<T extends Obj.Any | Relation.Any = Obj.Any | Relation.Any>({\n    spaceId,\n    queueId,\n    dxn,\n    objects,\n  }: MemoryQueueOptions<T>): MemoryQueue<T> {\n    if (!dxn) {\n      dxn = new DXN(DXN.kind.QUEUE, [spaceId ?? SpaceId.random(), queueId ?? ObjectId.random()]);\n    } else {\n      invariant(spaceId == null && queueId == null);\n    }\n\n    const queue = new MemoryQueue<T>(dxn);\n    if (objects?.length) {\n      void queue.append(objects);\n    }\n\n    return queue;\n  }\n\n  private readonly _signal = compositeRuntime.createSignal();\n\n  private _objects: T[] = [];\n\n  constructor(private readonly _dxn: DXN) {}\n\n  toJSON() {\n    return {\n      dxn: this._dxn.toString(),\n      objects: this._objects.length,\n    };\n  }\n\n  get dxn() {\n    return this._dxn;\n  }\n\n  get isLoading(): boolean {\n    return false;\n  }\n\n  get error(): Error | null {\n    return null;\n  }\n\n  get objects(): T[] {\n    this._signal.notifyRead();\n    return [...this._objects];\n  }\n\n  /**\n   * Insert into queue with optimistic update.\n   */\n  async append(objects: T[]): Promise<void> {\n    this._objects = [...this._objects, ...objects];\n    this._signal.notifyWrite();\n  }\n\n  async queryObjects(): Promise<T[]> {\n    return this._objects;\n  }\n\n  async getObjectsById(ids: ObjectId[]): Promise<(T | null)[]> {\n    return ids.map((id) => this._objects.find((object) => (object as HasId).id === id) ?? null);\n  }\n\n  async delete(ids: ObjectId[]): Promise<void> {\n    // TODO(dmaretskyi): Restrict types.\n    this._objects = this._objects.filter((object) => !ids.includes((object as HasId).id));\n    this._signal.notifyWrite();\n  }\n\n  async refresh(): Promise<void> {\n    // No-op.\n  }\n}\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { Obj, type Ref, type Relation } from '@dxos/echo';\nimport { type AnyEchoObject, type HasId, assertObjectModelShape } from '@dxos/echo-schema';\nimport { compositeRuntime } from '@dxos/echo-signals/runtime';\nimport { failedInvariant } from '@dxos/invariant';\nimport { type DXN, type ObjectId, type SpaceId } from '@dxos/keys';\nimport { log } from '@dxos/log';\n\nimport type { QueueService } from './queue-service';\nimport type { Queue } from './types';\n\nconst TRACE_QUEUE_LOAD = false;\n\n/**\n * Client-side view onto an EDGE queue.\n */\nexport class QueueImpl<T extends Obj.Any | Relation.Any = Obj.Any | Relation.Any> implements Queue<T> {\n  private readonly _signal = compositeRuntime.createSignal();\n\n  private readonly _subspaceTag: string;\n  private readonly _spaceId: SpaceId;\n  private readonly _queueId: string;\n\n  private _objectCache = new Map<ObjectId, T>();\n  private _objects: T[] = [];\n  private _isLoading = true;\n  private _error: Error | null = null;\n  private _refreshId = 0;\n  private _querying = false;\n\n  constructor(\n    private readonly _service: QueueService,\n    private readonly _refResolver: Ref.Resolver,\n    private readonly _dxn: DXN,\n  ) {\n    const { subspaceTag, spaceId, queueId } = this._dxn.asQueueDXN() ?? {};\n    this._subspaceTag = subspaceTag ?? failedInvariant();\n    this._spaceId = spaceId ?? failedInvariant();\n    this._queueId = queueId ?? failedInvariant();\n  }\n\n  toJSON() {\n    return {\n      dxn: this._dxn.toString(),\n      objects: this._objects.length,\n    };\n  }\n\n  // TODO(burdon): Rename to objects.\n  get dxn() {\n    return this._dxn;\n  }\n\n  get isLoading(): boolean {\n    this._signal.notifyRead();\n    return this._isLoading;\n  }\n\n  get error(): Error | null {\n    this._signal.notifyRead();\n    return this._error;\n  }\n\n  get objects(): T[] {\n    this._signal.notifyRead();\n    return this._objects;\n  }\n\n  /**\n   * Insert into queue with optimistic update.\n   */\n  async append(items: T[]): Promise<void> {\n    items.forEach((item) => assertObjectModelShape(item));\n\n    // Optimistic update.\n    this._objects = [...this._objects, ...items];\n    for (const item of items) {\n      this._objectCache.set(item.id, item as T);\n    }\n    this._signal.notifyWrite();\n\n    try {\n      await this._service.insertIntoQueue(\n        this._subspaceTag,\n        this._spaceId,\n        this._queueId,\n        items.map((item) => Obj.toJSON(item)),\n      );\n    } catch (err) {\n      log.catch(err);\n      this._error = err as Error;\n      this._signal.notifyWrite();\n    }\n  }\n\n  async delete(ids: string[]): Promise<void> {\n    // Optimistic update.\n    // TODO(dmaretskyi): Restrict types.\n    this._objects = this._objects.filter((item) => !ids.includes((item as HasId).id));\n    for (const id of ids) {\n      this._objectCache.delete(id);\n    }\n    this._signal.notifyWrite();\n\n    try {\n      await this._service.deleteFromQueue(this._subspaceTag, this._spaceId, this._queueId, ids);\n    } catch (err) {\n      this._error = err as Error;\n      this._signal.notifyWrite();\n    }\n  }\n\n  async queryObjects(): Promise<T[]> {\n    const { objects } = await this._service.queryQueue(this._subspaceTag, this._spaceId, { queueId: this._queueId });\n    const decodedObjects = await Promise.all(\n      objects.map(async (obj) => {\n        const decoded = await Obj.fromJSON(obj, { refResolver: this._refResolver });\n        this._objectCache.set(decoded.id, decoded as T);\n        return decoded;\n      }),\n    );\n    return decodedObjects as T[];\n  }\n\n  async getObjectsById(ids: ObjectId[]): Promise<(T | null)[]> {\n    const missingIds = ids.filter((id) => !this._objectCache.has(id));\n    if (missingIds.length > 0) {\n      if (!this._querying) {\n        try {\n          this._querying = true;\n          await this.queryObjects();\n        } finally {\n          this._querying = false;\n        }\n      }\n    }\n    return ids.map((id) => this._objectCache.get(id) ?? null);\n  }\n\n  /**\n   * Reload state from server.\n   * Overrides optimistic updates.\n   */\n  // TODO(dmaretskyi): Split optimistic into separate state so it doesn't get overridden.\n  async refresh(): Promise<void> {\n    const thisRefreshId = ++this._refreshId;\n    let changed = false;\n    try {\n      TRACE_QUEUE_LOAD &&\n        log.info('queue refresh begin', { currentObjects: this._objects.length, refreshId: thisRefreshId });\n      const { objects } = await this._service.queryQueue(this._subspaceTag, this._spaceId, { queueId: this._queueId });\n      TRACE_QUEUE_LOAD && log.info('items fetched', { refreshId: thisRefreshId, count: objects.length });\n      if (thisRefreshId !== this._refreshId) {\n        return;\n      }\n\n      const decodedObjects = await Promise.all(\n        objects.map((obj) => Obj.fromJSON(obj, { refResolver: this._refResolver })),\n      );\n      if (thisRefreshId !== this._refreshId) {\n        return;\n      }\n\n      for (const obj of decodedObjects) {\n        this._objectCache.set(obj.id, obj as T);\n      }\n\n      changed = objectSetChanged(this._objects, decodedObjects);\n\n      TRACE_QUEUE_LOAD && log.info('queue refresh', { changed, objects: objects.length, refreshId: thisRefreshId });\n      this._objects = decodedObjects as T[];\n    } catch (err) {\n      log.catch(err);\n      this._error = err as Error;\n    } finally {\n      this._isLoading = false;\n      if (changed) {\n        this._signal.notifyWrite();\n      }\n    }\n  }\n}\n\nconst objectSetChanged = (before: AnyEchoObject[], after: AnyEchoObject[]) => {\n  if (before.length !== after.length) {\n    return true;\n  }\n\n  // TODO(dmaretskyi):  We might want to compare the objects data.\n  return before.some((item, index) => item.id !== after[index].id);\n};\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { Resource } from '@dxos/context';\nimport type { Obj, Relation } from '@dxos/echo';\nimport { assertState } from '@dxos/invariant';\nimport { DXN, ObjectId, QueueSubspaceTags, type QueueSubspaceTag, type SpaceId } from '@dxos/keys';\n\nimport { QueueImpl } from './queue';\nimport type { QueueService } from './queue-service';\nimport type { Queue } from './types';\nimport { type Hypergraph } from '../hypergraph';\n\nexport interface QueueAPI {\n  get<T extends Obj.Any | Relation.Any = Obj.Any | Relation.Any>(dxn: DXN): Queue<T>;\n  create<T extends Obj.Any | Relation.Any = Obj.Any | Relation.Any>(options?: {\n    subspaceTag?: QueueSubspaceTag;\n  }): Queue<T>;\n}\n\nexport class QueueFactory extends Resource implements QueueAPI {\n  private readonly _queues = new Map<DXN.String, Queue<Obj.Any | Relation.Any>>();\n  private _service?: QueueService = undefined;\n\n  constructor(\n    private readonly _spaceId: SpaceId,\n    private readonly _graph: Hypergraph,\n  ) {\n    super();\n  }\n\n  setService(service: QueueService): void {\n    this._service = service;\n  }\n\n  get<T extends Obj.Any | Relation.Any = Obj.Any | Relation.Any>(dxn: DXN): Queue<T> {\n    assertState(this._service, 'Service not set');\n\n    const stringDxn = dxn.toString();\n    const queue = this._queues.get(stringDxn);\n    if (queue) {\n      return queue as Queue<T>;\n    }\n\n    const newQueue = new QueueImpl<T>(\n      this._service,\n      this._graph.createRefResolver({ context: { space: this._spaceId, queue: dxn } }),\n      dxn,\n    );\n    this._queues.set(stringDxn, newQueue);\n    return newQueue as Queue<T>;\n  }\n\n  create<T extends Obj.Any | Relation.Any = Obj.Any | Relation.Any>({\n    subspaceTag = QueueSubspaceTags.DATA,\n  }: { subspaceTag?: QueueSubspaceTag } = {}): Queue<T> {\n    const dxn = DXN.fromQueue(subspaceTag, this._spaceId, ObjectId.random());\n    return this.get<T>(dxn);\n  }\n}\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport type { ObjectId } from '@dxos/echo-schema';\nimport type { EdgeHttpClient } from '@dxos/edge-client';\nimport type { SpaceId } from '@dxos/keys';\nimport type { QueryResult, QueueQuery } from '@dxos/protocols';\nimport { ComplexMap } from '@dxos/util';\n\n/**\n * Service for managing queues.\n */\n// TODO(burdon): Base type for all services?\nexport interface QueueService {\n  queryQueue(subspaceTag: string, spaceId: SpaceId, query: QueueQuery): Promise<QueryResult>;\n\n  insertIntoQueue(subspaceTag: string, spaceId: SpaceId, queueId: ObjectId, objects: unknown[]): Promise<void>;\n\n  deleteFromQueue(subspaceTag: string, spaceId: SpaceId, queueId: ObjectId, objectIds: ObjectId[]): Promise<void>;\n}\n\n/**\n * Backed by Edge.\n */\nexport class QueueServiceImpl implements QueueService {\n  constructor(private readonly _client: EdgeHttpClient) {}\n\n  queryQueue(subspaceTag: string, spaceId: SpaceId, query: QueueQuery): Promise<QueryResult> {\n    return this._client.queryQueue(subspaceTag, spaceId, query);\n  }\n\n  insertIntoQueue(subspaceTag: string, spaceId: SpaceId, queueId: ObjectId, objects: unknown[]): Promise<void> {\n    return this._client.insertIntoQueue(subspaceTag, spaceId, queueId, objects);\n  }\n\n  deleteFromQueue(subspaceTag: string, spaceId: SpaceId, queueId: ObjectId, objectIds: ObjectId[]): Promise<void> {\n    return this._client.deleteFromQueue(subspaceTag, spaceId, queueId, objectIds);\n  }\n}\n\n/**\n * Stub implementation for when Edge is not available.\n */\nexport class QueueServiceStub implements QueueService {\n  queryQueue(subspaceTag: string, spaceId: SpaceId, query: QueueQuery): Promise<QueryResult> {\n    throw new Error('Not available.');\n  }\n\n  insertIntoQueue(subspaceTag: string, spaceId: SpaceId, queueId: ObjectId, objects: unknown[]): Promise<void> {\n    throw new Error('Not available.');\n  }\n\n  deleteFromQueue(subspaceTag: string, spaceId: SpaceId, queueId: ObjectId, objectIds: ObjectId[]): Promise<void> {\n    throw new Error('Not available.');\n  }\n}\n\n/**\n * Mock implementation for testing.\n */\nexport class MockQueueService implements QueueService {\n  private _queues = new ComplexMap<[subspaceTag: string, spaceId: SpaceId, queueId: ObjectId], unknown[]>(\n    ([subspaceTag, spaceId, queueId]) => `${subspaceTag}:${spaceId}:${queueId}`,\n  );\n\n  async queryQueue(subspaceTag: string, spaceId: SpaceId, query: QueueQuery): Promise<QueryResult> {\n    const objects = this._queues.get([subspaceTag, spaceId, query.queueId]) ?? [];\n    return {\n      objects,\n      nextCursor: null,\n      prevCursor: null,\n    };\n  }\n\n  async insertIntoQueue(subspaceTag: string, spaceId: SpaceId, queueId: ObjectId, objects: unknown[]): Promise<void> {\n    const key: [string, SpaceId, ObjectId] = [subspaceTag, spaceId, queueId];\n    const existing = this._queues.get(key) ?? [];\n    this._queues.set(key, [...existing, ...objects]);\n  }\n\n  async deleteFromQueue(\n    subspaceTag: string,\n    spaceId: SpaceId,\n    queueId: ObjectId,\n    objectIds: ObjectId[],\n  ): Promise<void> {\n    const key: [string, SpaceId, ObjectId] = [subspaceTag, spaceId, queueId];\n    const existing = this._queues.get(key) ?? [];\n    this._queues.set(\n      key,\n      existing.filter((obj: any) => !objectIds.includes(obj.id)),\n    );\n  }\n}\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { Schema } from 'effect';\n\nimport type { Obj, Relation } from '@dxos/echo';\nimport { EntityKind, TypeAnnotationId, type TypeAnnotation } from '@dxos/echo-schema';\nimport { type DXN, type ObjectId } from '@dxos/keys';\n\n/**\n * Client-side view onto an EDGE queue.\n */\nexport interface Queue<T extends Obj.Any | Relation.Any = Obj.Any | Relation.Any> {\n  readonly dxn: DXN;\n  readonly isLoading: boolean;\n  readonly error: Error | null;\n\n  // TODO(dmaretskyi): Replace with unified query(query) => QueryResult<T> API.\n  readonly objects: T[];\n\n  toJSON(): any;\n\n  /**\n   * Appends objects to the queue.\n   */\n  append(objects: T[]): Promise<void>;\n\n  /**\n   * Deletes objects from the queue.\n   */\n  delete(ids: string[]): Promise<void>;\n\n  /**\n   * Query all objects in the queue.\n   */\n  // TODO(dmaretskyi): Replace with unified query(query) => QueryResult<T> API.\n  queryObjects(): Promise<T[]>;\n\n  /**\n   * Queries objects by id.\n   */\n  // TODO(dmaretskyi): Replace with unified query(query) => QueryResult<T> API.\n  getObjectsById(ids: ObjectId[]): Promise<(T | null)[]>;\n\n  /**\n   * Refreshes the queue from the server.\n   */\n  // TODO(dmaretskyi): Remove.\n  refresh(): Promise<void>;\n}\n\n// TODO(dmaretskyi): Implement.\nconst isQueue = (value: unknown): value is Queue => {\n  return false;\n};\n\nexport const Queue: Schema.Schema<Queue> = Schema.declare(isQueue, {\n  [TypeAnnotationId]: {\n    // TODO(dmaretskyi): Perhaps queue should be its own entity kind.\n    kind: EntityKind.Object,\n    typename: 'dxos.org/type/Queue',\n    version: '0.1.0',\n  } satisfies TypeAnnotation,\n});\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { type Context, LifecycleState, Resource, ContextDisposedError } from '@dxos/context';\nimport { invariant } from '@dxos/invariant';\nimport { type PublicKey, type SpaceId } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { type QueryService } from '@dxos/protocols/proto/dxos/echo/query';\nimport { type DataService } from '@dxos/protocols/proto/dxos/echo/service';\n\nimport { IndexQuerySourceProvider, type LoadObjectParams } from './index-query-source-provider';\nimport { Hypergraph } from '../hypergraph';\nimport { EchoDatabaseImpl } from '../proxy-db';\nimport { QueueFactory, type QueueService } from '../queue';\n\nexport type EchoClientParams = {};\n\nexport type ConnectToServiceParams = {\n  dataService: DataService;\n  queryService: QueryService;\n  queueService?: QueueService;\n};\n\nexport type ConstructDatabaseParams = {\n  spaceId: SpaceId;\n\n  /** @deprecated Use spaceId */\n  spaceKey: PublicKey;\n\n  /**\n   * Run a reactive query for a set of dynamic schema.\n   * @default true\n   */\n  reactiveSchemaQuery?: boolean;\n\n  /**\n   * Preload all schema during open.\n   * @default true\n   */\n  preloadSchemaOnOpen?: boolean;\n\n  /**\n   * Space proxy reference for SDK compatibility.\n   */\n  // TODO(dmaretskyi): Remove.\n  owningObject?: unknown;\n};\n\n/**\n * ECHO client.\n * Manages a set of databases and builds a unified hypergraph.\n * Connects to the ECHO host via an ECHO service.\n */\nexport class EchoClient extends Resource {\n  private readonly _graph: Hypergraph;\n  private readonly _databases = new Map<SpaceId, EchoDatabaseImpl>();\n\n  private _dataService: DataService | undefined = undefined;\n  private _queryService: QueryService | undefined = undefined;\n  private _queuesService: QueueService | undefined = undefined;\n\n  private _indexQuerySourceProvider: IndexQuerySourceProvider | undefined = undefined;\n\n  constructor(_: EchoClientParams = {}) {\n    super();\n    this._graph = new Hypergraph();\n  }\n\n  get graph(): Hypergraph {\n    return this._graph;\n  }\n\n  get openDatabases(): Iterable<EchoDatabaseImpl> {\n    return this._databases.values();\n  }\n\n  /**\n   * Connects to the ECHO service.\n   * Must be called before open.\n   */\n  connectToService({ dataService, queryService, queueService }: ConnectToServiceParams): void {\n    invariant(this._lifecycleState === LifecycleState.CLOSED);\n    this._dataService = dataService;\n    this._queryService = queryService;\n    this._queuesService = queueService;\n  }\n\n  disconnectFromService(): void {\n    invariant(this._lifecycleState === LifecycleState.CLOSED);\n    this._dataService = undefined;\n    this._queryService = undefined;\n  }\n\n  protected override async _open(ctx: Context): Promise<void> {\n    invariant(this._dataService && this._queryService, 'Invalid state: not connected');\n\n    this._indexQuerySourceProvider = new IndexQuerySourceProvider({\n      service: this._queryService,\n      objectLoader: {\n        loadObject: this._loadObjectFromDocument.bind(this),\n      },\n    });\n    this._graph.registerQuerySourceProvider(this._indexQuerySourceProvider);\n  }\n\n  protected override async _close(ctx: Context): Promise<void> {\n    if (this._indexQuerySourceProvider) {\n      this._graph.unregisterQuerySourceProvider(this._indexQuerySourceProvider);\n    }\n    for (const db of this._databases.values()) {\n      this._graph._unregisterDatabase(db.spaceId);\n      await db.close();\n    }\n    this._databases.clear();\n  }\n\n  // TODO(dmaretskyi): Make async?\n  constructDatabase({\n    spaceId,\n    owningObject,\n    reactiveSchemaQuery,\n    preloadSchemaOnOpen,\n    spaceKey,\n  }: ConstructDatabaseParams): EchoDatabaseImpl {\n    invariant(this._lifecycleState === LifecycleState.OPEN);\n    invariant(!this._databases.has(spaceId), 'Database already exists.');\n    const db = new EchoDatabaseImpl({\n      dataService: this._dataService!,\n      queryService: this._queryService!,\n      graph: this._graph,\n      spaceId,\n      reactiveSchemaQuery,\n      preloadSchemaOnOpen,\n      spaceKey,\n    });\n    this._graph._registerDatabase(spaceId, db, owningObject);\n    this._databases.set(spaceId, db);\n    return db;\n  }\n\n  constructQueueFactory(spaceId: SpaceId): QueueFactory {\n    const queueFactory = new QueueFactory(spaceId, this._graph);\n    this._graph._registerQueueFactory(spaceId, queueFactory);\n    if (this._queuesService) {\n      queueFactory.setService(this._queuesService);\n    }\n    return queueFactory;\n  }\n\n  private async _loadObjectFromDocument({ spaceId, objectId, documentId }: LoadObjectParams) {\n    const db = this._databases.get(spaceId);\n    if (!db) {\n      return undefined;\n    }\n\n    // Waiting for the database to open since the query can run before the database is ready.\n    // TODO(dmaretskyi): Refactor this.\n    try {\n      await db.coreDatabase.opened.wait();\n    } catch (err) {\n      if (err instanceof ContextDisposedError) {\n        return undefined;\n      }\n      throw err;\n    }\n\n    const objectDocId = db._coreDatabase._automergeDocLoader.getObjectDocumentId(objectId);\n    if (objectDocId !== documentId) {\n      log(\"documentIds don't match\", { objectId, expected: documentId, actual: objectDocId ?? null });\n      return undefined;\n    }\n\n    return db._loadObjectById(objectId);\n  }\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { Event } from '@dxos/async';\nimport { type Stream } from '@dxos/codec-protobuf/stream';\nimport { Context } from '@dxos/context';\nimport type { QueryAST } from '@dxos/echo-protocol';\nimport { invariant } from '@dxos/invariant';\nimport { SpaceId } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { RpcClosedError } from '@dxos/protocols';\nimport {\n  QueryReactivity,\n  type QueryResponse,\n  type QueryService,\n  type QueryResult as RemoteQueryResult,\n} from '@dxos/protocols/proto/dxos/echo/query';\nimport { isNonNullable } from '@dxos/util';\n\nimport { type AnyLiveObject } from '../echo-handler';\nimport { getObjectCore } from '../echo-handler';\nimport { OBJECT_DIAGNOSTICS, type QuerySourceProvider } from '../hypergraph';\nimport { type QueryResultEntry, type QuerySource } from '../query';\nimport { getTargetSpacesForQuery } from '../query/util';\n\nexport type LoadObjectParams = {\n  spaceId: SpaceId;\n  objectId: string;\n  documentId: string;\n};\n\nexport interface ObjectLoader {\n  loadObject(params: LoadObjectParams): Promise<AnyLiveObject<any> | undefined>;\n}\n\nexport type IndexQueryProviderParams = {\n  service: QueryService;\n  objectLoader: ObjectLoader;\n};\n\nconst QUERY_SERVICE_TIMEOUT = 20_000;\n\nexport class IndexQuerySourceProvider implements QuerySourceProvider {\n  // TODO(burdon): OK for options, but not params. Pass separately and type readonly here.\n  constructor(private readonly _params: IndexQueryProviderParams) {}\n\n  // TODO(burdon): Rename createQuerySource\n  create(): QuerySource {\n    return new IndexQuerySource({ service: this._params.service, objectLoader: this._params.objectLoader });\n  }\n}\n\nexport type IndexQuerySourceParams = {\n  service: QueryService;\n  objectLoader: ObjectLoader;\n};\n\n/**\n * Runs queries against an index.\n */\nexport class IndexQuerySource implements QuerySource {\n  changed = new Event<void>();\n\n  private _query?: QueryAST.Query = undefined;\n  private _results?: QueryResultEntry[] = [];\n  private _stream?: Stream<QueryResponse>;\n\n  constructor(private readonly _params: IndexQuerySourceParams) {}\n\n  open(): void {}\n\n  close(): void {\n    this._results = undefined;\n    this._closeStream();\n  }\n\n  getResults(): QueryResultEntry[] {\n    return this._results ?? [];\n  }\n\n  async run(query: QueryAST.Query): Promise<QueryResultEntry[]> {\n    this._query = query;\n    return new Promise((resolve, reject) => {\n      this._queryIndex(query, QueryReactivity.ONE_SHOT, resolve, reject);\n    });\n  }\n\n  update(query: QueryAST.Query): void {\n    this._query = query;\n\n    this._closeStream();\n    this._results = [];\n    this.changed.emit();\n    this._queryIndex(query, QueryReactivity.REACTIVE, (results) => {\n      this._results = results;\n      this.changed.emit();\n    });\n  }\n\n  private _queryIndex(\n    query: QueryAST.Query,\n    queryType: QueryReactivity,\n    onResult: (results: QueryResultEntry[]) => void,\n    onError?: (error: Error) => void,\n  ): void {\n    const queryId = nextQueryId++;\n\n    log('queryIndex', { queryId });\n    const start = Date.now();\n    let currentCtx: Context;\n\n    const stream = this._params.service.execQuery(\n      { query: JSON.stringify(query), queryId: String(queryId), reactivity: queryType },\n      { timeout: QUERY_SERVICE_TIMEOUT },\n    );\n\n    if (queryType === QueryReactivity.REACTIVE) {\n      if (this._stream) {\n        log.warn('Query stream already open');\n      }\n      this._stream = stream;\n    }\n\n    stream.subscribe(\n      async (response) => {\n        try {\n          const targetSpaces = getTargetSpacesForQuery(query);\n          if (targetSpaces.length > 0) {\n            invariant(\n              response.results?.every((r) => targetSpaces.includes(SpaceId.make(r.spaceId))),\n              'Result spaceId mismatch',\n            );\n          }\n\n          if (queryType === QueryReactivity.ONE_SHOT) {\n            if (currentCtx) {\n              return;\n            }\n            void stream.close().catch(() => {});\n          }\n\n          await currentCtx?.dispose();\n          const ctx = new Context();\n          currentCtx = ctx;\n\n          log('queryIndex raw results', {\n            queryId,\n            length: response.results?.length ?? 0,\n          });\n\n          const processedResults = await Promise.all(\n            (response.results ?? []).map((result) => this._filterMapResult(ctx, start, result)),\n          );\n          const results = processedResults.filter(isNonNullable);\n\n          log('queryIndex processed results', {\n            queryId,\n            fetchedFromIndex: response.results?.length ?? 0,\n            loaded: results.length,\n          });\n\n          if (currentCtx === ctx) {\n            onResult(results);\n          } else {\n            log.warn('results from the previous update are ignored', { queryId });\n          }\n        } catch (err: any) {\n          if (onError) {\n            onError(err);\n          } else {\n            log.catch(err);\n          }\n        }\n      },\n      (err) => {\n        if (err != null) {\n          if (onError) {\n            onError(err);\n          } else if (!(err instanceof RpcClosedError)) {\n            log.catch(err);\n          }\n        }\n      },\n    );\n  }\n\n  private async _filterMapResult(\n    ctx: Context,\n    queryStartTimestamp: number,\n    result: RemoteQueryResult,\n  ): Promise<QueryResultEntry | null> {\n    if (!OBJECT_DIAGNOSTICS.has(result.id)) {\n      OBJECT_DIAGNOSTICS.set(result.id, {\n        objectId: result.id,\n        spaceId: result.spaceId,\n        loadReason: 'query',\n        query: JSON.stringify(this._query ?? null),\n      });\n    }\n\n    invariant(SpaceId.isValid(result.spaceId), 'Invalid spaceId');\n    const object = await this._params.objectLoader.loadObject({\n      spaceId: result.spaceId,\n      objectId: result.id,\n      documentId: result.documentId,\n    });\n    if (!object) {\n      return null;\n    }\n\n    if (ctx.disposed) {\n      return null;\n    }\n\n    const core = getObjectCore(object);\n    const queryResult: QueryResultEntry = {\n      id: object.id,\n      spaceId: core.database!.spaceId,\n      spaceKey: core.database!.spaceKey,\n      object,\n      match: { rank: result.rank },\n      resolution: { source: 'index', time: Date.now() - queryStartTimestamp },\n    };\n    return queryResult;\n  }\n\n  private _closeStream(): void {\n    void this._stream?.close().catch(() => {});\n    this._stream = undefined;\n  }\n}\n\n/**\n * Used for logging.\n */\nlet nextQueryId = 1;\n"],
  "mappings": "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",
  "names": ["registerSignalsRuntime", "areSignalsProhibited", "inUntrackedScope", "GuardSignal", "debugInfo", "notifyRead", "Error", "notifyWrite", "registerSignalsRuntime", "createSignal", "batch", "cb", "untracked", "prev", "prohibitSignalActions", "Event", "StackTrace", "compositeRuntime", "invariant", "log", "trace", "isNonNullable", "QueryResult", "_queryContext", "query", "_signal", "compositeRuntime", "createSignal", "_event", "Event", "_isActive", "_resultCache", "undefined", "_objectCache", "_subscribers", "_query", "changed", "on", "_recomputeResult", "untracked", "emit", "notifyWrite", "update", "ast", "_diagnostic", "isActive", "filter", "JSON", "stringify", "creationStack", "StackTrace", "QUERIES", "add", "log", "results", "_checkQueryIsRunning", "notifyRead", "_ensureCachePresent", "objects", "run", "timeout", "filteredResults", "_uniqueObjects", "first", "opts", "length", "Error", "runSync", "subscribe", "callback", "invariant", "fire", "active", "unsubscribeFromEvent", "_handleQueryLifecycle", "unsubscribe", "err", "prohibitSignalActions", "getResults", "some", "obj", "index", "id", "old", "map", "new", "seen", "Set", "result", "object", "isNonNullable", "has", "_stop", "_start", "start", "stop", "trace", "diagnostic", "name", "fetch", "Array", "from", "getStack", "Filter", "Query", "log", "QueryOptions", "QueryOptionsProto", "ResultFormat", "optionsToProto", "options", "spaceIds", "deleted", "dataLocation", "include", "limit", "spaces", "normalizeQuery", "query_", "userOptions", "opts", "query", "Query", "is", "Filter", "select", "undefined", "everything", "_props", "TypeError", "log", "error", "defaultSpaceId", "QueryOptionsProto", "ShowDeletedOption", "SHOW_DELETED", "HIDE_DELETED", "QueryAST", "SpaceId", "getTargetSpacesForQuery", "query", "spaces", "Set", "visitor", "node", "type", "options", "spaceIds", "spaceId", "add", "SpaceId", "make", "QueryAST", "visit", "isSimpleSelectionQuery", "maybeFilter", "filter", "undefined", "isNotUndefined", "asyncTimeout", "Event", "Context", "filterMatchObject", "log", "GraphQueryContext", "_params", "_sources", "Set", "_query", "undefined", "_ctx", "changed", "Event", "sources", "start", "Context", "onStart", "source", "update", "on", "emit", "stop", "dispose", "close", "onStop", "getResults", "Array", "from", "flatMap", "run", "query", "timeout", "runTasks", "values", "map", "s", "log", "resolver", "Object", "getPrototypeOf", "name", "results", "asyncTimeout", "count", "length", "err", "error", "mergedResults", "Promise", "all", "r", "addQuerySource", "querySource", "add", "SpaceQuerySource", "_database", "_results", "_onUpdate", "updateEvent", "prohibitSignalActions", "itemsUpdated", "some", "id", "objectId", "core", "coreDatabase", "getObjectCoreById", "load", "trivial", "isSimpleSelectionQuery", "filter", "options", "find", "result", "_filterCore", "spaceId", "spaceKey", "open", "catch", "_isValidSourceForQuery", "simple", "isObjectIdFilter", "push", "_coreDatabase", "batchLoadObjectCores", "isNotUndefined", "_mapCoreToResult", "_queryWorkingSet", "Map", "set", "_updateEvent", "filteredCores", "allObjectCores", "targetSpaces", "getTargetSpacesForQuery", "includes", "object", "getObjectById", "deleted", "resolution", "time", "filterCoreByDeletedFlag", "filterMatchObject", "doc", "getObjectStructure", "type", "isDeleted", "get", "DocAccessor", "getValue", "accessor", "get", "handle", "doc", "path", "isValidKeyPath", "value", "Array", "isArray", "every", "v", "next", "A", "Event", "inspectCustom", "decodeReference", "encodeReference", "isEncodedReference", "Reference", "DATA_NAMESPACE", "ObjectId", "EntityKind", "invariant", "DXN", "isLiveObject", "log", "setDeep", "defer", "getDeep", "throwUnhandledError", "deepMapValues", "failedInvariant", "log", "getDebugName", "beingChanged", "WeakSet", "docChangeSemaphore", "handle", "handled", "has", "add", "delete", "STRING_CRDT_LIMIT", "META_NAMESPACE", "SYSTEM_NAMESPACE", "ObjectCore", "id", "ObjectId", "random", "docHandle", "undefined", "mountPath", "updates", "Event", "notifyUpdate", "emit", "err", "log", "catch", "throwUnhandledError", "toString", "inspectCustom", "depth", "options", "inspectFn", "initNewObject", "initialProps", "opts", "invariant", "doc", "A", "from", "data", "encode", "meta", "keys", "system", "bind", "isReady", "database", "db", "path", "assignFromLocalState", "_", "defer", "docChangeSemaphore", "change", "newDoc", "setDeep", "getDoc", "Error", "getObjectStructure", "getDeep", "changeFn", "changeAt", "heads", "callback", "result", "newHeads", "getDocAccessor", "isValidKeyPath", "self", "handle", "addListener", "event", "listener", "on", "removeListener", "off", "value", "isLiveObject", "TypeError", "RawString", "Reference", "encodeReference", "Array", "isArray", "values", "map", "val", "entries", "Object", "filter", "fromEntries", "key", "length", "decode", "isEncodedReference", "maybeReference", "decodeReference", "arrayPush", "items", "itemsEncoded", "item", "newLength", "fullPath", "array", "push", "_getRaw", "_setRaw", "getDecoded", "setDecoded", "delete", "slice", "getKind", "EntityKind", "setKind", "kind", "getSource", "res", "setSource", "ref", "getTarget", "setTarget", "getType", "setType", "reference", "getMeta", "setMeta", "isDeleted", "setDeleted", "toPlainObject", "DATA_NAMESPACE", "error", "type", "dataMapped", "deepMapValues", "recurse", "toDXN", "__typename", "__meta", "getStrongDependencies", "DXN", "ECHO", "Relation", "source", "target", "objectIsUpdated", "objId", "patches", "some", "patch", "next", "A", "stringifyAutomergeUrl", "EventEmitter", "Trigger", "TriggerState", "invariant", "DocHandleProxy", "_documentId", "options", "_callbacks", "_ready", "_doc", "undefined", "_lastSentHeads", "_currentlySendingHeads", "isNew", "from", "initialValue", "emptyChange", "wake", "init", "url", "documentId", "state", "RESOLVED", "doc", "Error", "whenReady", "wait", "isReady", "change", "fn", "opts", "before", "headsBefore", "getHeads", "emit", "handle", "patches", "diff", "patchInfo", "after", "source", "changeAt", "heads", "newDoc", "newHeads", "update", "updateCallback", "delete", "onDelete", "_getPendingChanges", "equals", "mutation", "saveSince", "length", "_confirmSync", "_integrateHostUpdate", "loadIncremental", "next", "A", "generateAutomergeUrl", "interpretAsDocumentId", "parseAutomergeUrl", "Event", "UpdateScheduler", "LifecycleState", "Resource", "invariant", "PublicKey", "log", "trace", "MAX_UPDATE_FREQ", "RPC_TIMEOUT", "RepoProxy", "Resource", "_dataService", "_spaceId", "_handles", "_subscriptionId", "PublicKey", "random", "toHex", "_subscription", "undefined", "_pendingCreateIds", "Set", "_pendingAddIds", "_pendingRemoveIds", "_pendingUpdateIds", "_sendUpdatesJob", "saveStateChanged", "Event", "handles", "find", "id", "TypeError", "documentId", "interpretAsDocumentId", "_getHandle", "isNew", "import", "dump", "handle", "create", "update", "A", "load", "initialValue", "parseAutomergeUrl", "generateAutomergeUrl", "flush", "runBlocking", "_open", "subscribe", "subscriptionId", "spaceId", "UpdateScheduler", "_ctx", "_sendUpdates", "maxFrequency", "updates", "_receiveUpdate", "_close", "join", "Object", "values", "off", "close", "Error", "_createHandle", "invariant", "_lifecycleState", "LifecycleState", "OPEN", "onChange", "log", "add", "trigger", "_emitSaveStateEvent", "onDelete", "DocHandleProxy", "on", "mutation", "warn", "_integrateHostUpdate", "createIds", "Array", "from", "addIds", "removeIds", "updateIds", "clear", "updateSubscription", "timeout", "addMutations", "documentIds", "_getPendingChanges", "push", "length", "_confirmSync", "err", "forEach", "raise", "unsavedDocuments", "emit", "resource", "getHeads", "interpretAsDocumentId", "asyncTimeout", "Event", "runInContextAsync", "synchronized", "TimeoutError", "Trigger", "UpdateScheduler", "Stream", "Context", "ContextDisposedError", "raise", "encodeReference", "isEncodedReference", "Reference", "DATA_NAMESPACE", "Ref", "compositeRuntime", "invariant", "DXN", "LOCAL_SPACE_TAG", "log", "trace", "chunkArray", "deepMapValues", "defaultMap", "setDeep", "next", "A", "interpretAsDocumentId", "Event", "cancelWithContext", "warnAfterTimeout", "DatabaseDirectory", "SpaceDocVersion", "assertState", "invariant", "log", "trace", "ComplexSet", "AutomergeDocumentLoaderImpl", "_repo", "_spaceId", "_spaceKey", "_spaceRootDocHandle", "_objectDocumentHandles", "Map", "_objectsPendingDocumentLoad", "Set", "_currentlyLoadingObjects", "url", "objectId", "onObjectDocumentLoaded", "hasRootHandle", "getAllHandles", "values", "getLinkedDocHandles", "loadSpaceRootDocHandle", "ctx", "spaceState", "rootUrl", "Error", "existingDocHandle", "_initDocHandle", "doc", "version", "CURRENT", "access", "_initDocAccess", "objectPresent", "id", "getInlineObject", "getLink", "loadObjectDocument", "objectIdOrMany", "objectIds", "Array", "isArray", "hasUrlsToLoad", "urlsToLoad", "has", "documentUrl", "_getLinkedDocumentUrl", "add", "_loadLinkedObjects", "getObjectDocumentId", "spaceRootDoc", "objects", "documentId", "toString", "onObjectLinksUpdated", "links", "linksAwaitingLoad", "Object", "entries", "filter", "fromEntries", "forEach", "delete", "getSpaceRootDocHandle", "createDocumentForObject", "spaceDocHandle", "create", "spaceKey", "toHex", "onObjectBoundToDocument", "change", "newDoc", "RawString", "handle", "set", "clearHandleReferences", "objectsWithHandles", "keys", "clear", "automergeUrlData", "automergeUrl", "logMeta", "objectDocumentHandle", "get", "warn", "actualDocumentUrl", "find", "debug", "_loadHandleForObject", "docHandle", "whenReady", "docUrl", "listenerCount", "info", "objectDocHandle", "emit", "err", "shouldRetryLoading", "retryLoading", "span", "showInBrowserTimeline", "resource", "next", "A", "Event", "Stream", "Context", "filterMatchObject", "isEncodedReference", "invariant", "DXN", "PublicKey", "SpaceId", "log", "QueryReactivity", "isNonNullable", "QUERY_SERVICE_TIMEOUT", "CoreDatabaseQueryContext", "_coreDatabase", "_queryService", "_lastResult", "changed", "Event", "start", "stop", "getResults", "run", "query", "queryId", "nextQueryId", "ctx", "Context", "Date", "now", "trivial", "isSimpleSelectionQuery", "filter", "options", "_options", "type", "id", "length", "core", "loadObjectCoreById", "disposed", "Promise", "all", "_filterMapCore", "undefined", "isNonNullable", "response", "Stream", "first", "execQuery", "JSON", "stringify", "reactivity", "QueryReactivity", "ONE_SHOT", "timeout", "Error", "log", "results", "processedResults", "map", "result", "_filterMapResult", "fetchedFromIndex", "loaded", "update", "queryStartTimestamp", "SpaceId", "isValid", "spaceId", "warn", "FORCE_DATA_SERVICE_FETCH", "documentJson", "spaceKey", "PublicKey", "ZERO", "object", "parse", "match", "rank", "resolution", "source", "time", "documentAutomerge", "doc", "A", "load", "objects", "objectDocId", "_automergeDocLoader", "getObjectDocumentId", "documentId", "objectId", "expected", "actual", "filterMatchObject", "getObjectStructure", "database", "toPlainObject", "_recursivelyJoinFields", "data", "joinSpec", "newData", "key", "spec", "Object", "entries", "isEncodedReference", "dxn", "DXN", "invariant", "isLocalObjectId", "parts", "next", "A", "isValidAutomergeUrl", "getInlineAndLinkChanges", "event", "inlineChangedObjectIds", "Set", "linkedDocuments", "path", "value", "patches", "length", "add", "A", "RawString", "valueStr", "toString", "isValidAutomergeUrl", "inlineChangedObjects", "THROTTLED_UPDATE_FREQUENCY", "TRACE_LOADING", "CoreDatabase", "graph", "dataService", "queryService", "spaceId", "spaceKey", "_objects", "Map", "_strongDepsIndex", "_updateEvent", "Event", "_state", "_ctx", "Context", "opened", "Trigger", "rootChanged", "_onDocumentUpdate", "event", "documentChanges", "_processDocumentUpdate", "_rebindObjects", "handle", "objectsToRebind", "_automergeDocLoader", "onObjectLinksUpdated", "linkedDocuments", "_createInlineObjects", "createdObjectIds", "_emitObjectUpdateEvent", "updatedObjectIds", "_scheduleThrottledDbUpdate", "_objectsForNextDbUpdate", "Set", "_objectsForNextUpdate", "_updateScheduler", "UpdateScheduler", "_emitDbUpdateEvents", "maxFrequency", "_hypergraph", "_dataService", "_queryService", "_spaceId", "_spaceKey", "_repoProxy", "RepoProxy", "saveStateChanged", "AutomergeDocumentLoaderImpl", "toJSON", "id", "objects", "size", "_repo", "open", "spaceState", "start", "performance", "now", "log", "info", "onDispose", "_unsubscribeFromHandles", "bind", "onObjectDocumentLoaded", "on", "_onObjectDocumentLoaded", "loadSpaceRootDocHandle", "spaceRootDocHandle", "getSpaceRootDocHandle", "spaceRootDoc", "doc", "invariant", "objectIds", "Object", "keys", "err", "ContextDisposedError", "catch", "elapsed", "warn", "docId", "rootUrl", "duration", "wake", "close", "throw", "reset", "dispose", "updateSpaceState", "url", "objectIdsToLoad", "clearHandleReferences", "_handleSpaceRootDocumentChange", "getAllObjectIds", "hasLoadedHandles", "getAllHandles", "length", "rootDoc", "links", "getNumberOfInlineObjects", "getNumberOfLinkedObjects", "getTotalNumberOfObjects", "allObjectCores", "Array", "from", "values", "getObjectCoreById", "load", "hasRootHandle", "Error", "objCore", "get", "loadObjectDocument", "undefined", "ObjectCore", "loadObjectCoreById", "objectId", "timeout", "returnWithUnsatisfiedDeps", "core", "_areDepsSatisfied", "isReady", "waitForUpdate", "waitFor", "itemsUpdated", "some", "then", "asyncTimeout", "batchLoadObjectCores", "inactivityTimeout", "returnDeleted", "failOnTimeout", "result", "objectsToLoad", "i", "objectPresent", "isDeleted", "push", "resultIndex", "idsToLoad", "map", "v", "startTime", "diagnostics", "Promise", "resolve", "reject", "unsubscribe", "inactivityTimeoutTimer", "scheduleInactivityTimeout", "setTimeout", "TimeoutError", "updatedIds", "objectToLoad", "includes", "clearTimeout", "depsUnsatisfied", "splice", "prototype", "query", "_query", "filter", "options", "QueryResult", "_createQueryContext", "normalizeQuery", "defaultSpaceId", "CoreDatabaseQueryContext", "update", "operation", "ast", "type", "change", "key", "setDeep", "mountPath", "DATA_NAMESPACE", "flush", "insert", "data", "isBatch", "isArray", "dataArray", "cores", "item", "createCoreFromInsertData", "addCore", "toPlainObject", "opts", "database", "setDeleted", "has", "set", "spaceDocHandle", "placement", "placeIn", "createDocumentForObject", "onObjectBoundToDocument", "TypeError", "db", "docHandle", "path", "assignFromLocalState", "removeCore", "unlinkObjects", "root", "unlinkDeletedObjects", "batchSize", "idChunks", "chunkArray", "ids", "toUnlink", "o", "atomicReplaceObject", "params", "mappedData", "deepMapValues", "value", "recurse", "Ref", "isRef", "dxn", "toString", "existingStruct", "getDecoded", "newStruct", "system", "encodeReference", "Reference", "fromDXN", "setDecoded", "disk", "indexes", "updates", "documentIds", "documentId", "RPC_TIMEOUT", "updateIndexes", "runBlocking", "getDocumentHeads", "heads", "headsStates", "link", "interpretAsDocumentId", "state", "entries", "getHeads", "waitUntilHeadsReplicated", "reIndexHeads", "getSyncState", "Stream", "first", "subscribeSpaceSyncState", "raise", "subscribeToSyncState", "ctx", "callback", "stream", "subscribe", "runInContextAsync", "getLoadedDocumentHandles", "handles", "inlinedObjectIds", "linkedObjectIds", "k", "objectsToRemove", "objectsToCreate", "oid", "object", "newObjectDocUrl", "existing", "newDocHandle", "find", "whenReady", "forEach", "delete", "emit", "compositeRuntime", "batch", "notifyUpdate", "inlineChangedObjects", "getInlineAndLinkChanges", "updatedObject", "objectCore", "verbose", "documentUrl", "actualUrl", "off", "_createObjectInDocument", "_scheduleThrottledUpdate", "dep", "getStrongDependencies", "isLocalObjectId", "parts", "deps", "depObjectId", "defaultMap", "seen", "add", "every", "depCore", "fullUpdateIds", "allDbUpdates", "clear", "DISABLE_THROTTLING", "forceTrigger", "trigger", "span", "showInBrowserTimeline", "resource", "RPC_TIMEOUT", "DISABLE_THROTTLING", "sanitizeTypename", "typename", "startsWith", "DXN", "parse", "includes", "Error", "kind", "TYPE", "createCoreFromInsertData", "data", "__typename", "rest", "type", "fieldsMapped", "deepMapValues", "value", "recurse", "isEncodedReference", "ECHO", "LOCAL_SPACE_TAG", "toString", "core", "ObjectCore", "initNewObject", "setType", "Reference", "fromDXN", "Schema", "devtoolsFormatter", "inspectCustom", "DATA_NAMESPACE", "encodeReference", "PROPERTY_ID", "Reference", "ATTR_META", "ATTR_TYPE", "defineHiddenProperty", "DeletedId", "EchoSchema", "EntityKind", "EntityKindId", "getRefSavedTarget", "getTypeAnnotation", "isInstanceOf", "MetaId", "ObjectMetaSchema", "Ref", "RefImpl", "RelationSourceId", "RelationTargetId", "SchemaId", "SchemaMetaSymbol", "SchemaValidator", "setRefResolver", "StoredSchema", "TypeId", "getEntityKind", "getSchema", "requireTypeReference", "RelationTargetDXNId", "RelationSourceDXNId", "assertObjectModelShape", "invariant", "assertArgument", "DXN", "createProxy", "getProxyHandler", "getProxyTarget", "isLiveObject", "symbolIsProxy", "getMeta", "getProxySlot", "log", "deepMapValues", "defaultMap", "getDeep", "setDeep", "idStyle", "style", "listStyle", "liStyle", "nestedObjectContainerStyle", "keyStyle", "defaultValueKeyStyle", "alteredValueKeyStyle", "nullStyle", "defaultKeys", "getHeader", "tag", "id", "config", "nested", "formatValue", "object", "getBody", "objData", "Object", "keys", "map", "key", "includes", "startsWith", "compositeRuntime", "inspectCustom", "compositeRuntime", "ComplexMap", "symbolPath", "Symbol", "symbolNamespace", "symbolHandler", "symbolInternals", "TargetKey", "new", "path", "namespace", "type", "hash", "key", "JSON", "stringify", "inspectCustom", "ObjectInternals", "core", "database", "signal", "compositeRuntime", "createSignal", "targetsMap", "ComplexMap", "linkCache", "Map", "subscriptions", "rootSchema", "undefined", "id", "_a", "EchoArray", "Array", "symbolInternals", "symbolPath", "symbolNamespace", "symbolHandler", "Symbol", "species", "BATCHED_METHODS", "method", "handlerMethodName", "slice", "toUpperCase", "fn", "args", "result", "compositeRuntime", "batch", "handler", "apply", "Object", "defineProperty", "value", "prototype", "enumerable", "EchoReactiveHandler", "_proxyMap", "WeakMap", "_inspect", "_", "options", "inspectFn", "handler", "symbolHandler", "typename", "_getTypename", "isRelation", "symbolInternals", "core", "getKind", "EntityKind", "Relation", "isTyped", "getType", "reified", "_getReified", "id", "compact", "showHidden", "customInspect", "instance", "init", "target", "invariant", "symbolIsProxy", "Array", "isArray", "symbolPath", "key", "defineHiddenProperty", "Object", "defineProperty", "inspectCustom", "enumerable", "configurable", "value", "bind", "ownKeys", "signal", "notifyRead", "_getDecodedValueAtPath", "keys", "Reflect", "isRootDataObject", "push", "PROPERTY_ID", "getOwnPropertyDescriptor", "p", "writable", "undefined", "property", "attributes", "set", "has", "EchoArray", "_arrayHas", "get", "prop", "receiver", "SchemaId", "getSchema", "EntityKindId", "RelationSourceDXNId", "getSource", "toDXN", "RelationTargetDXNId", "getTarget", "RelationSourceId", "_getRelationSource", "RelationTargetId", "_getRelationTarget", "TypeId", "getTypeReference", "MetaId", "getMeta", "DeletedId", "isDeleted", "devtoolsFormatter", "_getDevtoolsFormatter", "_toJSON", "_arrayGet", "decodedValueAtPath", "_wrapInProxyIfRequired", "_arraySetLength", "fullPath", "getNamespace", "validatedValue", "_validateValue", "delete", "withLinks", "_handleLinksAssignment", "setDecoded", "schema", "SchemaMetaSymbol", "objectId", "sourceRef", "database", "graph", "createRefResolver", "context", "space", "spaceId", "resolveSync", "linkCache", "targetRef", "decoded", "dataPath", "namespace", "_handleStoredSchema", "Reference", "lookupRef", "targetKey", "TargetKey", "new", "newTarget", "defaultMap", "targetsMap", "array", "symbolNamespace", "createProxy", "object", "isInstanceOf", "StoredSchema", "schemaRegistry", "_registerSchema", "getDecoded", "prototype", "isNaN", "parseInt", "parsedIndex", "length", "path", "throwIfCustomClass", "rootObjectSchema", "typeReference", "Error", "toString", "unwrappedValue", "EchoSchema", "storedSchema", "propertySchema", "SchemaValidator", "getPropertySchema", "Schema", "asserts", "deepMapValues", "recurse", "isEchoObjectField", "isLiveObject", "Ref", "isRef", "savedTarget", "getRefSavedTarget", "createRef", "fromDXN", "dxn", "META_NAMESPACE", "ObjectMetaSchema", "rootSchema", "staticSchema", "getSchemaByDXN", "protocol", "query", "runSync", "DATA_NAMESPACE", "deleteProperty", "log", "warn", "arrayPush", "items", "validatedItems", "_validateForArray", "encodedItems", "_encodeForArray", "arrayPop", "_getPropertyMountPath", "returnValue", "change", "doc", "getDeep", "pop", "arrayShift", "shift", "arrayUnshift", "newLength", "unshift", "arraySplice", "start", "deleteCount", "deletedElements", "splice", "arraySort", "compareFn", "sortedArray", "sort", "setDeep", "arrayReverse", "reversedArray", "reverse", "metaTarget", "setDatabase", "proxy", "otherEchoObj", "isEchoObject", "createObject", "otherObjId", "localObjectReference", "foreignDatabase", "getProxyTarget", "add", "DXN", "kind", "ECHO", "ref", "refImpl", "RefImpl", "setRefResolver", "middleware", "obj", "saveRefs", "values", "RangeError", "trimmedArray", "map", "item", "index", "String", "linksEncoded", "encode", "mountPath", "typeRef", "ATTR_TYPE", "encodeReference", "ATTR_META", "getTypeAnnotation", "header", "config", "getHeader", "hasBody", "body", "data", "metaReified", "getBody", "proto", "getPrototypeOf", "getObjectCore", "isRootDataObject", "target", "path", "symbolPath", "Array", "isArray", "length", "getNamespace", "DATA_NAMESPACE", "isEchoObjectField", "value", "isLiveObject", "getProxyHandler", "EchoReactiveHandler", "getProxyTarget", "symbolNamespace", "isEchoObject", "handler", "isTypedObjectProxy", "schema", "getSchema", "getTypeAnnotation", "createObject", "obj", "assertArgument", "validateSchema", "validateInitialProps", "core", "ObjectCore", "meta", "getMeta", "slot", "getProxySlot", "setHandler", "instance", "symbolInternals", "ObjectInternals", "rootSchema", "_proxyMap", "set", "subscriptions", "push", "updates", "on", "signal", "notifyWrite", "initCore", "init", "setSchemaPropertiesOnObjectCore", "setRelationSourceAndTarget", "keys", "setMeta", "proxy", "createProxy", "initCore", "core", "target", "PROPERTY_ID", "symbolInternals", "id", "initNewObject", "linkAllNestedProperties", "initEchoReactiveObjectRootProxy", "database", "ObjectInternals", "symbolPath", "symbolNamespace", "DATA_NAMESPACE", "updates", "on", "signal", "notifyWrite", "obj", "createProxy", "EchoReactiveHandler", "instance", "assertObjectModelShape", "validateSchema", "schema", "requireTypeReference", "entityKind", "getEntityKind", "invariant", "SchemaValidator", "setSchemaPropertiesOnObjectCore", "internals", "setType", "kind", "setKind", "setRelationSourceAndTarget", "EntityKind", "Relation", "sourceRef", "RelationSourceId", "targetRef", "RelationTargetId", "TypeError", "isLiveObject", "setSource", "createRef", "setTarget", "validateInitialProps", "seen", "Set", "has", "add", "key", "value", "undefined", "Ref", "isRef", "EchoSchema", "isTypedObjectProxy", "Error", "throwIfCustomClass", "deepMapValues", "recurse", "refToEchoReference", "ref", "savedTarget", "getRefSavedTarget", "Reference", "fromDXN", "dxn", "ObjectId", "invariant", "assertArgument", "requireAutomergeCore", "obj", "core", "getObjectCore", "invariant", "clone", "retainId", "additional", "assertArgument", "isEchoObject", "length", "cloneInner", "id", "ObjectId", "random", "clones", "innerObj", "push", "ref", "symbolInternals", "linkCache", "set", "coreClone", "ObjectCore", "initNewObject", "proxy", "initEchoReactiveObjectRootProxy", "automergeSnapshot", "getObjectDoc", "change", "doc", "key", "Object", "keys", "value", "docHandle", "mountPath", "next", "am", "ATTR_META", "ATTR_TYPE", "assertArgument", "getEditHistory", "object", "assertArgument", "isEchoObject", "objectCore", "getObjectCore", "doc", "getDoc", "changes", "am", "getHistory", "checkoutVersion", "version", "Array", "isArray", "snapshot", "view", "versionCore", "ObjectCore", "id", "mountPath", "__typename", "__meta", "data", "toPlainObject", "ATTR_TYPE", "ATTR_META", "EntityKind", "EntityKindId", "RelationSourceId", "RelationTargetId", "invariant", "isRelation", "object", "kind", "undefined", "TypeError", "Relation", "getSource", "relation", "obj", "getTarget", "Reference", "invariant", "getMeta", "getProxyTarget", "getDatabaseFromObject", "obj", "isEchoObject", "undefined", "target", "getProxyTarget", "symbolInternals", "database", "getReferenceWithSpaceKey", "invariant", "db", "Reference", "fromObjectIdAndSpaceKey", "id", "spaceKey", "findObjectWithForeignKey", "objects", "foreignKey", "find", "result", "getMeta", "keys", "source", "matchKeys", "a", "b", "some", "keyA", "keyB", "assertArgument", "isLiveObject", "createDocAccessor", "obj", "path", "Array", "isArray", "assertArgument", "isLiveObject", "undefined", "isValidKeyPath", "core", "getObjectCore", "basePath", "symbolPath", "fullPath", "getDocAccessor", "next", "Automerge", "ObjectVersion", "Object", "freeze", "equals", "a", "b", "JSON", "stringify", "getVersion", "obj", "docAccessor", "createDocAccessor", "doc", "handle", "heads", "Automerge", "getHeads", "createSubscription", "onUpdate", "subscribed", "firstUpdate", "subscriptions", "Map", "handle", "update", "selection", "newSelected", "Set", "filter", "isEchoObject", "removed", "selected", "item", "has", "added", "length", "forEach", "obj", "get", "delete", "set", "getObjectCore", "updates", "on", "updated", "unsubscribe", "Array", "from", "values", "clear", "Event", "Context", "raise", "StackTrace", "Query", "Filter", "ImmutableSchema", "RuntimeSchemaRegistry", "compositeRuntime", "failedInvariant", "invariant", "DXN", "log", "trace", "entry", "TRACE_REF_RESOLUTION", "Hypergraph", "_databases", "Map", "_queueFactories", "_owningObjects", "_schemaRegistry", "RuntimeSchemaRegistry", "_updateEvent", "Event", "_resolveEvents", "_queryContexts", "Set", "_querySourceProviders", "schemaRegistry", "getSchemaByTypename", "typename", "db", "schema", "getSchema", "ImmutableSchema", "query", "firstOrUndefined", "_registerDatabase", "spaceId", "database", "owningObject", "set", "coreDatabase", "on", "_onUpdate", "bind", "map", "get", "id", "event", "obj", "getObjectById", "log", "objectId", "emit", "delete", "context", "values", "addQuerySource", "SpaceQuerySource", "_unregisterDatabase", "_registerQueueFactory", "factory", "_unregisterQueueFactory", "_getOwningObject", "prototype", "_query", "options", "Filter", "is", "Query", "select", "resultFormat", "format", "ResultFormat", "Live", "TypeError", "Plain", "spaceIds", "invariant", "length", "QueryResult", "_createPlainObjectQueryContext", "normalizeQuery", "_createLiveObjectQueryContext", "AutomergeDocAccessor", "Error", "createRefResolver", "middleware", "resolveSync", "dxn", "load", "onLoad", "kind", "DXN", "QUEUE", "asQueueDXN", "undefined", "subspaceTag", "queueId", "_resolveQueueSync", "ECHO", "res", "_resolveSync", "resolve", "_resolveAsync", "resolveSchema", "beginTime", "performance", "now", "status", "TYPE", "getSchemaByDXN", "info", "toString", "time", "onResolve", "asEchoDXN", "dxnData", "space", "echoId", "OBJECT_DIAGNOSTICS", "has", "loadReason", "loadedStack", "StackTrace", "entry", "orInsert", "deep", "value", "Context", "isLocalObjectId", "failedInvariant", "queue", "_resolveQueueObjectAsync", "_resolveDatabaseObjectAsync", "objects", "ids", "run", "queueFactory", "fromQueue", "getObjectsById", "registerQuerySourceProvider", "provider", "push", "create", "unregisterQuerySourceProvider", "index", "indexOf", "splice", "updateEvent", "listenerMap", "compositeRuntime", "batch", "item", "itemsUpdated", "listeners", "GraphQueryContext", "onStart", "add", "onStop", "raise", "_coreDatabase", "_createQueryContext", "trace", "diagnostic", "name", "fetch", "Array", "from", "object", "creationStack", "getStack", "Schema", "Event", "Resource", "TypeIdentifierAnnotationId", "EchoSchema", "getTypeIdentifierAnnotation", "getTypeAnnotation", "TypeAnnotationId", "StoredSchema", "toJsonSchema", "create", "createJsonSchema", "invariant", "DXN", "log", "Event", "Mutex", "log", "SchemaRegistryPreparedQueryImpl", "_resolver", "_mutex", "_changes", "_isReactiveQueryRunning", "_subscriberCount", "_isFiring", "results", "Error", "getResultsSync", "run", "getResults", "runSync", "first", "length", "firstOrUndefined", "subscribe", "cb", "opts", "on", "_onSubscriberCountChange", "fire", "off", "_stop", "_start", "queueMicrotask", "_guard", "acquire", "start", "err", "catch", "stop", "EchoSchemaRegistry", "Resource", "_db", "reactiveQuery", "preloadSchemaOnOpen", "_schemaById", "Map", "_schemaByType", "_unsubscribeById", "_schemaSubscriptionCallbacks", "_reactiveQuery", "_preloadSchemaOnOpen", "_open", "ctx", "objects", "query", "Filter", "type", "StoredSchema", "run", "forEach", "object", "_registerSchema", "unsubscribe", "subscribe", "currentObjectIds", "Set", "map", "o", "id", "newObjects", "filter", "has", "removedObjects", "keys", "oid", "obj", "_register", "idoid", "_unregister", "length", "_notifySchemaListChanged", "_ctx", "onDispose", "_close", "self", "filterOrderResults", "schemas", "log", "schema", "validateStoredSchemaIntegrity", "storedSchema", "idFilter", "coerceArray", "jsonSchema", "$id", "includes", "backingObjectIdFilter", "backingObjectId", "typenameFilter", "typename", "version", "match", "Error", "sort", "a", "b", "localeCompare", "changes", "Event", "SchemaRegistryPreparedQueryImpl", "getResultsSync", "runSync", "result", "results", "stored", "getResults", "start", "_subscribe", "emit", "stop", "undefined", "register", "inputs", "input", "Schema", "isSchema", "TypeError", "push", "_addSchema", "hasSchema", "schemaId", "EchoSchema", "getObjectIdFromSchema", "getSchemaById", "getSchema", "existing", "get", "typeObject", "getObjectById", "is", "warn", "registered", "previousTypename", "echoSchema", "subscription", "getObjectCore", "updates", "on", "_invalidate", "delete", "set", "snapshot", "annotations", "TypeIdentifierAnnotationId", "meta", "getTypeAnnotation", "invariant", "schemaToStore", "create", "createJsonSchema", "toJsonSchema", "TypeAnnotationId", "add", "_rebuild", "callback", "values", "index", "indexOf", "splice", "list", "s", "arr", "Array", "isArray", "startsWith", "echoIdentifier", "getTypeIdentifierAnnotation", "dxn", "DXN", "parse", "isLocalObjectId", "parts", "inspect", "Event", "synchronized", "LifecycleState", "Resource", "inspectObject", "assertObjectModelShape", "getSchema", "invariant", "DXN", "getProxyTarget", "getType", "isLiveObject", "log", "defaultMap", "EchoDatabaseImpl", "Resource", "params", "_rootUrl", "undefined", "_rootProxies", "Map", "pendingBatch", "Event", "_coreDatabase", "CoreDatabase", "graph", "dataService", "queryService", "spaceId", "spaceKey", "_schemaRegistry", "EchoSchemaRegistry", "reactiveQuery", "reactiveSchemaQuery", "preloadSchemaOnOpen", "inspect", "custom", "inspectObject", "toJSON", "rootUrl", "schemaRegistry", "_open", "open", "_close", "close", "setSpaceRoot", "log", "firstTime", "_lifecycleState", "LifecycleState", "OPEN", "updateSpaceState", "getObjectById", "id", "deleted", "core", "getObjectCoreById", "isDeleted", "object", "defaultMap", "initEchoReactiveObjectRootProxy", "invariant", "isLiveObject", "prototype", "query", "_query", "options", "Filter", "is", "Query", "select", "spaceIds", "update", "filter", "operation", "insert", "data", "add", "obj", "opts", "isEchoObject", "schema", "getSchema", "hasSchema", "createSchemaNotRegisteredError", "createObject", "assertObjectModelShape", "set", "getObjectCore", "target", "getProxyTarget", "EchoReactiveHandler", "instance", "setDatabase", "saveRefs", "addCore", "remove", "removeCore", "flush", "runMigrations", "migrations", "migration", "objects", "typeDXN", "fromType", "run", "verbose", "from", "to", "toType", "length", "output", "transform", "db", "atomicReplaceObject", "type", "postMigrationType", "getType", "DXN", "equals", "onMigration", "before", "_loadObjectById", "objectId", "loadObjectCoreById", "coreDatabase", "message", "typename", "Error", "asyncTimeout", "loadObject", "obj", "getObjectCore", "getDecoded", "loadObjectReferences", "objOrArray", "valueAccessor", "timeout", "objectArray", "Array", "isArray", "tasks", "map", "core", "value", "database", "isLoadedPredicate", "every", "v", "asyncTimeout", "_updateEvent", "waitFor", "then", "result", "Promise", "all", "getSchemaDXN", "defineObjectMigration", "options", "fromType", "getSchemaDXN", "from", "Error", "toType", "to", "fromSchema", "toSchema", "transform", "onMigration", "ObjectId", "compositeRuntime", "invariant", "DXN", "SpaceId", "MemoryQueue", "make", "spaceId", "queueId", "dxn", "objects", "kind", "QUEUE", "random", "queue", "length", "append", "_dxn", "_signal", "createSignal", "_objects", "toJSON", "toString", "isLoading", "error", "notifyRead", "notifyWrite", "queryObjects", "getObjectsById", "ids", "map", "id", "find", "object", "delete", "filter", "includes", "refresh", "Obj", "assertObjectModelShape", "compositeRuntime", "failedInvariant", "log", "TRACE_QUEUE_LOAD", "QueueImpl", "_service", "_refResolver", "_dxn", "_signal", "createSignal", "_objectCache", "Map", "_objects", "_isLoading", "_error", "_refreshId", "_querying", "subspaceTag", "spaceId", "queueId", "asQueueDXN", "_subspaceTag", "_spaceId", "_queueId", "toJSON", "dxn", "toString", "objects", "length", "isLoading", "notifyRead", "error", "append", "items", "forEach", "item", "set", "id", "notifyWrite", "insertIntoQueue", "map", "err", "catch", "delete", "ids", "filter", "includes", "deleteFromQueue", "queryObjects", "queryQueue", "decodedObjects", "Promise", "all", "obj", "decoded", "fromJSON", "refResolver", "getObjectsById", "missingIds", "has", "get", "refresh", "thisRefreshId", "changed", "info", "currentObjects", "refreshId", "count", "objectSetChanged", "before", "after", "some", "index", "Resource", "assertState", "DXN", "ObjectId", "QueueSubspaceTags", "QueueFactory", "Resource", "_spaceId", "_graph", "_queues", "Map", "_service", "undefined", "setService", "service", "get", "dxn", "assertState", "stringDxn", "toString", "queue", "newQueue", "QueueImpl", "createRefResolver", "context", "space", "set", "create", "subspaceTag", "QueueSubspaceTags", "DATA", "DXN", "fromQueue", "ObjectId", "random", "ComplexMap", "QueueServiceImpl", "_client", "queryQueue", "subspaceTag", "spaceId", "query", "insertIntoQueue", "queueId", "objects", "deleteFromQueue", "objectIds", "QueueServiceStub", "Error", "MockQueueService", "_queues", "ComplexMap", "get", "nextCursor", "prevCursor", "key", "existing", "set", "filter", "obj", "includes", "id", "Schema", "EntityKind", "TypeAnnotationId", "isQueue", "value", "Queue", "Schema", "declare", "TypeAnnotationId", "kind", "EntityKind", "Object", "typename", "version", "LifecycleState", "Resource", "ContextDisposedError", "invariant", "log", "Event", "Context", "invariant", "SpaceId", "log", "RpcClosedError", "QueryReactivity", "isNonNullable", "QUERY_SERVICE_TIMEOUT", "IndexQuerySourceProvider", "_params", "create", "IndexQuerySource", "service", "objectLoader", "changed", "Event", "_query", "undefined", "_results", "open", "close", "_closeStream", "getResults", "run", "query", "Promise", "resolve", "reject", "_queryIndex", "QueryReactivity", "ONE_SHOT", "update", "emit", "REACTIVE", "results", "queryType", "onResult", "onError", "queryId", "nextQueryId", "log", "start", "Date", "now", "currentCtx", "stream", "execQuery", "JSON", "stringify", "String", "reactivity", "timeout", "_stream", "warn", "subscribe", "response", "targetSpaces", "getTargetSpacesForQuery", "length", "invariant", "every", "r", "includes", "SpaceId", "make", "spaceId", "catch", "dispose", "ctx", "Context", "processedResults", "all", "map", "result", "_filterMapResult", "filter", "isNonNullable", "fetchedFromIndex", "loaded", "err", "RpcClosedError", "queryStartTimestamp", "OBJECT_DIAGNOSTICS", "has", "id", "set", "objectId", "loadReason", "isValid", "object", "loadObject", "documentId", "disposed", "core", "getObjectCore", "queryResult", "database", "spaceKey", "match", "rank", "resolution", "source", "time", "EchoClient", "Resource", "_", "_databases", "Map", "_dataService", "undefined", "_queryService", "_queuesService", "_indexQuerySourceProvider", "_graph", "Hypergraph", "graph", "openDatabases", "values", "connectToService", "dataService", "queryService", "queueService", "invariant", "_lifecycleState", "LifecycleState", "CLOSED", "disconnectFromService", "_open", "ctx", "IndexQuerySourceProvider", "service", "objectLoader", "loadObject", "_loadObjectFromDocument", "bind", "registerQuerySourceProvider", "_close", "unregisterQuerySourceProvider", "db", "_unregisterDatabase", "spaceId", "close", "clear", "constructDatabase", "owningObject", "reactiveSchemaQuery", "preloadSchemaOnOpen", "spaceKey", "OPEN", "has", "EchoDatabaseImpl", "_registerDatabase", "set", "constructQueueFactory", "queueFactory", "QueueFactory", "_registerQueueFactory", "setService", "objectId", "documentId", "get", "coreDatabase", "opened", "wait", "err", "ContextDisposedError", "objectDocId", "_coreDatabase", "_automergeDocLoader", "getObjectDocumentId", "log", "expected", "actual", "_loadObjectById"]
}
