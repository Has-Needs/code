import { createRequire } from 'node:module';const require = createRequire(import.meta.url);

// packages/core/echo/echo-db/src/guarded-scope.ts
import { registerSignalsRuntime } from "@dxos/echo-signals/runtime";
var areSignalsProhibited = false;
var inUntrackedScope = false;
var GuardSignal = class {
  constructor(debugInfo) {
    this.debugInfo = debugInfo;
  }
  notifyRead() {
    if (inUntrackedScope) {
      return;
    }
    if (areSignalsProhibited) {
      throw new Error("Signal read is prohibited in this scope");
    }
  }
  notifyWrite() {
    if (inUntrackedScope) {
      return;
    }
    if (areSignalsProhibited) {
      throw new Error("Signal write is prohibited in this scope");
    }
  }
};
registerSignalsRuntime({
  createSignal: (debugInfo) => new GuardSignal(debugInfo),
  batch: (cb) => {
    cb();
  },
  untracked: (cb) => {
    const prev = inUntrackedScope;
    try {
      inUntrackedScope = true;
      return cb();
    } finally {
      inUntrackedScope = prev;
    }
  }
});
var prohibitSignalActions = (cb) => {
  try {
    areSignalsProhibited = true;
    return cb();
  } finally {
    areSignalsProhibited = false;
  }
};

// packages/core/echo/echo-db/src/query/query-result.ts
import { Event } from "@dxos/async";
import { StackTrace } from "@dxos/debug";
import { compositeRuntime } from "@dxos/echo-signals/runtime";
import { invariant } from "@dxos/invariant";
import { log } from "@dxos/log";
import { trace } from "@dxos/tracing";
import { isNonNullable } from "@dxos/util";
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/core/echo/echo-db/src/query/query-result.ts";
var QueryResult = class {
  constructor(_queryContext, query) {
    this._queryContext = _queryContext;
    this._signal = compositeRuntime.createSignal();
    this._event = new Event();
    this._isActive = false;
    this._resultCache = void 0;
    this._objectCache = void 0;
    this._subscribers = 0;
    this._query = query;
    this._queryContext.changed.on(() => {
      if (this._recomputeResult()) {
        compositeRuntime.untracked(() => {
          this._event.emit(this);
          this._signal.notifyWrite();
        });
      }
    });
    this._queryContext.update(query.ast);
    this._diagnostic = {
      isActive: this._isActive,
      filter: JSON.stringify(this._query),
      creationStack: new StackTrace()
    };
    QUERIES.add(this._diagnostic);
    log("construct", {
      filter: this._query.ast
    }, {
      F: __dxlog_file,
      L: 146,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  get query() {
    return this._query;
  }
  get results() {
    this._checkQueryIsRunning();
    this._signal.notifyRead();
    this._ensureCachePresent();
    return this._resultCache;
  }
  get objects() {
    this._checkQueryIsRunning();
    this._signal.notifyRead();
    this._ensureCachePresent();
    return this._objectCache;
  }
  /**
  * Execute the query once and return the results.
  * Does not subscribe to updates.
  */
  async run(timeout = {
    timeout: 3e4
  }) {
    const filteredResults = await this._queryContext.run(this._query.ast, {
      timeout: timeout.timeout
    });
    return {
      results: filteredResults,
      objects: this._uniqueObjects(filteredResults)
    };
  }
  async first(opts) {
    const { objects } = await this.run(opts);
    if (objects.length === 0) {
      throw new Error("No objects found");
    }
    return objects[0];
  }
  /**
  * Runs the query synchronously and returns all results.
  * WARNING: This method will only return the data already cached and may return incomplete results.
  * Use `this.run()` for a complete list of results stored on-disk.
  */
  runSync() {
    this._ensureCachePresent();
    return this._resultCache;
  }
  /**
  * Subscribe to query results.
  * Updates only when the identity or the order of the objects changes.
  * Does not update when the object properties change.
  */
  // TODO(burdon): Change to SubscriptionHandle (make uniform).
  subscribe(callback, opts) {
    invariant(!(!callback && opts?.fire), "Cannot fire without a callback.", {
      F: __dxlog_file,
      L: 206,
      S: this,
      A: [
        "!(!callback && opts?.fire)",
        "'Cannot fire without a callback.'"
      ]
    });
    log("subscribe", {
      filter: this._query.ast,
      active: this._isActive
    }, {
      F: __dxlog_file,
      L: 208,
      S: this,
      C: (f, a) => f(...a)
    });
    this._subscribers++;
    const unsubscribeFromEvent = callback ? this._event.on(callback) : void 0;
    this._handleQueryLifecycle();
    const unsubscribe = () => {
      log("unsubscribe", {
        filter: this._query.ast,
        active: this._isActive
      }, {
        F: __dxlog_file,
        L: 214,
        S: this,
        C: (f, a) => f(...a)
      });
      this._subscribers--;
      unsubscribeFromEvent?.();
      this._handleQueryLifecycle();
    };
    if (callback && opts?.fire) {
      try {
        callback(this);
      } catch (err) {
        unsubscribe();
        throw err;
      }
    }
    return unsubscribe;
  }
  _ensureCachePresent() {
    if (!this._resultCache) {
      prohibitSignalActions(() => {
        compositeRuntime.untracked(() => {
          this._recomputeResult();
        });
      });
    }
  }
  /**
  * @returns true if the result cache was updated.
  */
  _recomputeResult() {
    const results = this._queryContext.getResults();
    const objects = this._uniqueObjects(results);
    const changed = !this._objectCache || this._objectCache.length !== objects.length || this._objectCache.some((obj, index) => obj.id !== objects[index].id);
    log("recomputeResult", {
      old: this._objectCache?.map((obj) => obj.id),
      new: objects.map((obj) => obj.id),
      changed
    }, {
      F: __dxlog_file,
      L: 256,
      S: this,
      C: (f, a) => f(...a)
    });
    this._resultCache = results;
    this._objectCache = objects;
    return changed;
  }
  _uniqueObjects(results) {
    const seen = /* @__PURE__ */ new Set();
    return results.map((result) => result.object).filter(isNonNullable).filter((object) => {
      if (object.id == null) {
        return true;
      }
      if (seen.has(object.id)) {
        return false;
      }
      seen.add(object.id);
      return true;
    });
  }
  _handleQueryLifecycle() {
    if (this._subscribers === 0 && this._isActive) {
      log("stop query", {
        filter: this._query.ast
      }, {
        F: __dxlog_file,
        L: 288,
        S: this,
        C: (f, a) => f(...a)
      });
      this._stop();
    } else if (this._subscribers > 0 && !this._isActive) {
      log("start query", {
        filter: this._query.ast
      }, {
        F: __dxlog_file,
        L: 291,
        S: this,
        C: (f, a) => f(...a)
      });
      this._start();
    }
  }
  _start() {
    this._isActive = true;
    this._queryContext.start();
    this._diagnostic.isActive = true;
  }
  _stop() {
    this._queryContext.stop();
    this._isActive = false;
    this._diagnostic.isActive = false;
  }
  _checkQueryIsRunning() {
    if (!this._isActive) {
      throw new Error("Query must have at least 1 subscriber for `.objects` and `.results` to be used. Use query.run() for single-use result retrieval.");
    }
  }
};
var QUERIES = /* @__PURE__ */ new Set();
trace.diagnostic({
  id: "client-queries",
  name: "Queries (Client)",
  fetch: () => {
    return Array.from(QUERIES).map((query) => {
      return {
        isActive: query.isActive,
        filter: query.filter,
        creationStack: query.creationStack.getStack()
      };
    });
  }
});

// packages/core/echo/echo-db/src/query/api.ts
import { Filter, Query } from "@dxos/echo";
import { log as log2 } from "@dxos/log";
import { QueryOptions as QueryOptionsProto } from "@dxos/protocols/proto/dxos/echo/filter";
var __dxlog_file2 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-db/src/query/api.ts";
var ResultFormat = /* @__PURE__ */ function(ResultFormat2) {
  ResultFormat2["Plain"] = "plain";
  ResultFormat2["Live"] = "live";
  ResultFormat2["AutomergeDocAccessor"] = "automergeDocAccessor";
  return ResultFormat2;
}({});
var optionsToProto = (options) => {
  return {
    spaceIds: options.spaceIds,
    deleted: options.deleted,
    dataLocation: options.dataLocation,
    include: options.include,
    limit: options.limit,
    spaces: options.spaces
  };
};
var normalizeQuery = (query_, userOptions, opts) => {
  let query;
  if (Query.is(query_)) {
    query = query_;
  } else if (Filter.is(query_)) {
    query = Query.select(query_);
  } else if (query_ === void 0) {
    query = Query.select(Filter.everything());
  } else if (typeof query_ === "object" && query_ !== null) {
    query = Query.select(Filter._props(query_));
  } else if (typeof query_ === "function") {
    throw new TypeError("Functions are not supported as queries");
  } else {
    log2.error("Invalid query", {
      query: query_
    }, {
      F: __dxlog_file2,
      L: 127,
      S: void 0,
      C: (f, a) => f(...a)
    });
    throw new TypeError("Invalid query");
  }
  if (userOptions) {
    query = query.options({
      spaceIds: userOptions.spaceIds ?? (opts?.defaultSpaceId ? [
        opts.defaultSpaceId
      ] : void 0),
      deleted: userOptions?.deleted === void 0 ? void 0 : userOptions?.deleted === QueryOptionsProto.ShowDeletedOption.SHOW_DELETED ? "include" : userOptions?.deleted === QueryOptionsProto.ShowDeletedOption.HIDE_DELETED ? "exclude" : "only"
    });
  }
  return query;
};

// packages/core/echo/echo-db/src/query/util.ts
import { QueryAST } from "@dxos/echo-protocol";
import { SpaceId } from "@dxos/keys";
var getTargetSpacesForQuery = (query) => {
  const spaces = /* @__PURE__ */ new Set();
  const visitor = (node) => {
    if (node.type === "options") {
      if (node.options.spaceIds) {
        for (const spaceId of node.options.spaceIds) {
          spaces.add(SpaceId.make(spaceId));
        }
      }
    }
    QueryAST.visit(node, visitor);
  };
  visitor(query);
  return [
    ...spaces
  ];
};
var isSimpleSelectionQuery = (query) => {
  switch (query.type) {
    case "options": {
      const maybeFilter = isSimpleSelectionQuery(query.query);
      if (!maybeFilter) {
        return null;
      }
      return {
        filter: maybeFilter.filter,
        options: query.options
      };
    }
    case "select": {
      return {
        filter: query.filter,
        options: void 0
      };
    }
    default: {
      return null;
    }
  }
};

// packages/core/echo/echo-db/src/query/graph-query-context.ts
import { isNotUndefined } from "effect/Predicate";
import { asyncTimeout, Event as Event2 } from "@dxos/async";
import { Context } from "@dxos/context";
import { filterMatchObject } from "@dxos/echo-pipeline/filter";
import { log as log3 } from "@dxos/log";
var __dxlog_file3 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-db/src/query/graph-query-context.ts";
var GraphQueryContext = class {
  constructor(_params) {
    this._params = _params;
    this._sources = /* @__PURE__ */ new Set();
    this._query = void 0;
    this._ctx = void 0;
    this.changed = new Event2();
  }
  get sources() {
    return this._sources;
  }
  start() {
    this._ctx = new Context(void 0, {
      F: __dxlog_file3,
      L: 78
    });
    this._params.onStart();
    for (const source of this._sources) {
      if (this._query) {
        source.update(this._query);
      }
      source.changed.on(this._ctx, () => {
        this.changed.emit();
      });
    }
  }
  stop() {
    void this._ctx?.dispose();
    for (const source of this.sources) {
      source.close();
    }
    this._params.onStop();
  }
  getResults() {
    if (!this._query) {
      return [];
    }
    return Array.from(this._sources).flatMap((source) => source.getResults());
  }
  async run(query, { timeout = 3e4 } = {}) {
    const runTasks = [
      ...this._sources.values()
    ].map(async (s) => {
      try {
        log3("run query", {
          resolver: Object.getPrototypeOf(s).constructor.name
        }, {
          F: __dxlog_file3,
          L: 110,
          S: this,
          C: (f, a) => f(...a)
        });
        const results = await asyncTimeout(s.run(query), timeout);
        log3("run query results", {
          resolver: Object.getPrototypeOf(s).constructor.name,
          count: results.length
        }, {
          F: __dxlog_file3,
          L: 112,
          S: this,
          C: (f, a) => f(...a)
        });
        return results;
      } catch (err) {
        log3("run query error", {
          resolver: Object.getPrototypeOf(s).constructor.name,
          error: err
        }, {
          F: __dxlog_file3,
          L: 115,
          S: this,
          C: (f, a) => f(...a)
        });
        throw err;
      }
    });
    if (runTasks.length === 0) {
      return [];
    }
    const mergedResults = (await Promise.all(runTasks)).flatMap((r) => r ?? []);
    return mergedResults;
  }
  update(query) {
    this._query = query;
    for (const source of this._sources) {
      source.update(query);
    }
  }
  addQuerySource(querySource) {
    this._sources.add(querySource);
    if (this._ctx != null) {
      querySource.changed.on(this._ctx, () => {
        this.changed.emit();
      });
    }
    if (this._query) {
      querySource.update(this._query);
    }
  }
};
var SpaceQuerySource = class {
  constructor(_database) {
    this._database = _database;
    this.changed = new Event2();
    this._ctx = new Context(void 0, {
      F: __dxlog_file3,
      L: 152
    });
    this._query = void 0;
    this._results = void 0;
    this._onUpdate = (updateEvent) => {
      if (!this._query) {
        return;
      }
      prohibitSignalActions(() => {
        const changed = updateEvent.itemsUpdated.some(({ id: objectId }) => {
          const core = this._database.coreDatabase.getObjectCoreById(objectId, {
            load: false
          });
          const trivial = isSimpleSelectionQuery(this._query);
          if (!trivial) {
            return false;
          }
          const { filter, options } = trivial;
          return !this._results || this._results.find((result) => result.id === objectId) || core && this._filterCore(core, filter, options);
        });
        if (changed) {
          this._results = void 0;
          this.changed.emit();
        }
      });
    };
  }
  get spaceId() {
    return this._database.spaceId;
  }
  get spaceKey() {
    return this._database.spaceKey;
  }
  open() {
  }
  close() {
    this._results = void 0;
    void this._ctx.dispose().catch(() => {
    });
  }
  async run(query) {
    if (!this._isValidSourceForQuery(query)) {
      return [];
    }
    const simple = isSimpleSelectionQuery(query);
    if (!simple) {
      return [];
    }
    const { filter, options } = simple;
    const results = [];
    if (isObjectIdFilter(filter)) {
      results.push(...(await this._database._coreDatabase.batchLoadObjectCores(filter.id)).filter(isNotUndefined).filter((core) => this._filterCore(core, filter, options)).map((core) => this._mapCoreToResult(core)));
    }
    prohibitSignalActions(() => {
      results.push(...this._queryWorkingSet(filter, options));
    });
    const map = /* @__PURE__ */ new Map();
    for (const result of results) {
      map.set(result.id, result);
    }
    return [
      ...map.values()
    ];
  }
  getResults() {
    if (!this._query) {
      return [];
    }
    const trivial = isSimpleSelectionQuery(this._query);
    if (!trivial) {
      return [];
    }
    const { filter, options } = trivial;
    if (!this._results) {
      prohibitSignalActions(() => {
        this._results = this._queryWorkingSet(filter, options);
      });
    }
    return this._results;
  }
  update(query) {
    if (!this._isValidSourceForQuery(query)) {
      this._query = void 0;
      return;
    }
    void this._ctx.dispose().catch(() => {
    });
    this._ctx = new Context(void 0, {
      F: __dxlog_file3,
      L: 266
    });
    this._query = query;
    this._database.coreDatabase._updateEvent.on(this._ctx, this._onUpdate);
    this._results = void 0;
    this.changed.emit();
  }
  /**
  * Queries from already loaded objects.
  */
  _queryWorkingSet(filter, options) {
    const filteredCores = isObjectIdFilter(filter) ? filter.id.map((id) => this._database.coreDatabase.getObjectCoreById(id, {
      load: true
    })).filter(isNotUndefined).filter((core) => this._filterCore(core, filter, options)) : this._database.coreDatabase.allObjectCores().filter((core) => this._filterCore(core, filter, options));
    return filteredCores.map((core) => this._mapCoreToResult(core));
  }
  _isValidSourceForQuery(query) {
    const targetSpaces = getTargetSpacesForQuery(query);
    if (targetSpaces.length > 0 && !targetSpaces.includes(this.spaceId)) {
      return false;
    }
    return true;
  }
  _mapCoreToResult(core) {
    return {
      id: core.id,
      spaceId: this.spaceId,
      spaceKey: this.spaceKey,
      object: this._database.getObjectById(core.id, {
        deleted: true
      }),
      resolution: {
        source: "local",
        time: 0
      }
    };
  }
  _filterCore(core, filter, options) {
    return filterCoreByDeletedFlag(core, options) && filterMatchObject(filter, {
      id: core.id,
      doc: core.getObjectStructure(),
      spaceId: this.spaceId
    });
  }
};
var isObjectIdFilter = (filter) => {
  return filter.type === "object" && filter.id !== void 0 && filter.id.length > 0;
};
var filterCoreByDeletedFlag = (core, options) => {
  switch (options?.deleted) {
    case void 0:
    case "exclude":
      return !core.isDeleted();
    case "include":
      return true;
    case "only":
      return core.isDeleted();
  }
};

// packages/core/echo/echo-db/src/core-db/types.ts
import { get } from "@dxos/util";
var DocAccessor = {
  getValue: (accessor) => get(accessor.handle.doc(), accessor.path)
};
var isValidKeyPath = (value) => Array.isArray(value) && value.every((v) => typeof v === "string" || typeof v === "number");

// packages/core/echo/echo-db/src/core-db/object-core.ts
import { next as A } from "@automerge/automerge";
import { Event as Event3 } from "@dxos/async";
import { inspectCustom } from "@dxos/debug";
import { decodeReference, encodeReference, isEncodedReference, Reference, DATA_NAMESPACE } from "@dxos/echo-protocol";
import { ObjectId, EntityKind } from "@dxos/echo-schema";
import { invariant as invariant2 } from "@dxos/invariant";
import { DXN } from "@dxos/keys";
import { isLiveObject } from "@dxos/live-object";
import { log as log5 } from "@dxos/log";
import { setDeep, defer, getDeep, throwUnhandledError, deepMapValues } from "@dxos/util";

// packages/core/echo/echo-db/src/core-db/doc-semaphore.ts
import { failedInvariant } from "@dxos/invariant";
import { log as log4 } from "@dxos/log";
import { getDebugName } from "@dxos/util";
var __dxlog_file4 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-db/src/core-db/doc-semaphore.ts";
var beingChanged = /* @__PURE__ */ new WeakSet();
var docChangeSemaphore = (handle) => {
  log4("begin change", {
    handled: getDebugName(handle)
  }, {
    F: __dxlog_file4,
    L: 14,
    S: void 0,
    C: (f, a) => f(...a)
  });
  if (beingChanged.has(handle)) {
    failedInvariant("Recursive call to doc.change");
  }
  beingChanged.add(handle);
  return () => {
    log4("end change", {
      handled: getDebugName(handle)
    }, {
      F: __dxlog_file4,
      L: 22,
      S: void 0,
      C: (f, a) => f(...a)
    });
    beingChanged.delete(handle);
  };
};

// packages/core/echo/echo-db/src/core-db/object-core.ts
function _ts_add_disposable_resource(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = function() {
      try {
        inner.call(this);
      } catch (e) {
        return Promise.reject(e);
      }
    };
    env.stack.push({
      value,
      dispose,
      async
    });
  } else if (async) {
    env.stack.push({
      async: true
    });
  }
  return value;
}
function _ts_dispose_resources(env) {
  var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  };
  return (_ts_dispose_resources = function _ts_dispose_resources4(env2) {
    function fail(e) {
      env2.error = env2.hasError ? new _SuppressedError(e, env2.error, "An error was suppressed during disposal.") : e;
      env2.hasError = true;
    }
    var r, s = 0;
    function next() {
      while (r = env2.stack.pop()) {
        try {
          if (!r.async && s === 1) return s = 0, env2.stack.push(r), Promise.resolve().then(next);
          if (r.dispose) {
            var result = r.dispose.call(r.value);
            if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
              fail(e);
              return next();
            });
          } else s |= 1;
        } catch (e) {
          fail(e);
        }
      }
      if (s === 1) return env2.hasError ? Promise.reject(env2.error) : Promise.resolve();
      if (env2.hasError) throw env2.error;
    }
    return next();
  })(env);
}
var __dxlog_file5 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-db/src/core-db/object-core.ts";
var STRING_CRDT_LIMIT = 3e5;
var META_NAMESPACE = "meta";
var SYSTEM_NAMESPACE = "system";
var ObjectCore = class {
  constructor() {
    // TODO(dmaretskyi): Start making some of those fields private.
    // TODO(dmaretskyi): Create a discriminated union for the bound/not bound states.
    /**
    * Id of the ECHO object.
    */
    this.id = ObjectId.random();
    /**
    * Set if when the object is bound to a database.
    */
    this.docHandle = void 0;
    /**
    * Key path at where we are mounted in the `doc` or `docHandle`.
    * The value at path must be of type `ObjectStructure`.
    */
    this.mountPath = [];
    /**
    * Handles link resolution as well as manual changes.
    */
    this.updates = new Event3();
    /**
    * Fire a synchronous update notification via signal and event subscriptions.
    * Called after local changes and link resolution.
    * This function can be used unbound.
    */
    this.notifyUpdate = () => {
      try {
        this.updates.emit();
      } catch (err) {
        log5.catch(err, void 0, {
          F: __dxlog_file5,
          L: 246,
          S: this,
          C: (f, a) => f(...a)
        });
        throwUnhandledError(err);
      }
    };
  }
  toString() {
    return `ObjectCore { id: ${this.id} }`;
  }
  [inspectCustom](depth, options, inspectFn) {
    return `ObjectCore ${inspectFn({
      id: this.id
    }, options)}`;
  }
  /**
  * Create local doc with initial state from this object.
  */
  initNewObject(initialProps, opts) {
    invariant2(!this.docHandle && !this.doc, void 0, {
      F: __dxlog_file5,
      L: 96,
      S: this,
      A: [
        "!this.docHandle && !this.doc",
        ""
      ]
    });
    initialProps ??= {};
    this.doc = A.from({
      data: this.encode(initialProps),
      meta: this.encode({
        keys: [],
        ...opts?.meta
      }),
      system: {}
    });
  }
  bind(options) {
    invariant2(options.docHandle.isReady(), void 0, {
      F: __dxlog_file5,
      L: 111,
      S: this,
      A: [
        "options.docHandle.isReady()",
        ""
      ]
    });
    this.database = options.db;
    this.docHandle = options.docHandle;
    this.mountPath = options.path;
    const doc = this.doc;
    this.doc = void 0;
    if (options.assignFromLocalState) {
      const env = {
        stack: [],
        error: void 0,
        hasError: false
      };
      try {
        invariant2(doc, "assignFromLocalState", {
          F: __dxlog_file5,
          L: 120,
          S: this,
          A: [
            "doc",
            "'assignFromLocalState'"
          ]
        });
        const _ = _ts_add_disposable_resource(env, defer(docChangeSemaphore(this.docHandle ?? this)), false);
        this.docHandle.change((newDoc) => {
          setDeep(newDoc, this.mountPath, doc);
        });
      } catch (e) {
        env.error = e;
        env.hasError = true;
      } finally {
        _ts_dispose_resources(env);
      }
    }
    this.notifyUpdate();
  }
  getDoc() {
    if (this.doc) {
      return this.doc;
    }
    if (this.docHandle) {
      return this.docHandle.doc();
    }
    throw new Error("Invalid ObjectCore state");
  }
  getObjectStructure() {
    return getDeep(this.getDoc(), this.mountPath);
  }
  /**
  * Do not take into account mountPath.
  */
  change(changeFn, options) {
    const env = {
      stack: [],
      error: void 0,
      hasError: false
    };
    try {
      const _ = _ts_add_disposable_resource(env, defer(docChangeSemaphore(this.docHandle ?? this)), false);
      if (this.doc) {
        if (options) {
          this.doc = A.change(this.doc, options, changeFn);
        } else {
          this.doc = A.change(this.doc, changeFn);
        }
        this.notifyUpdate();
      } else {
        invariant2(this.docHandle, void 0, {
          F: __dxlog_file5,
          L: 166,
          S: this,
          A: [
            "this.docHandle",
            ""
          ]
        });
        this.docHandle.change(changeFn, options);
      }
    } catch (e) {
      env.error = e;
      env.hasError = true;
    } finally {
      _ts_dispose_resources(env);
    }
  }
  /**
  * Do not take into account mountPath.
  */
  changeAt(heads, callback, options) {
    const env = {
      stack: [],
      error: void 0,
      hasError: false
    };
    try {
      const _ = _ts_add_disposable_resource(env, defer(docChangeSemaphore(this.docHandle ?? this)), false);
      let result;
      if (this.doc) {
        if (options) {
          const { newDoc, newHeads } = A.changeAt(this.doc, heads, options, callback);
          this.doc = newDoc;
          result = newHeads ?? void 0;
        } else {
          const { newDoc, newHeads } = A.changeAt(this.doc, heads, callback);
          this.doc = newDoc;
          result = newHeads ?? void 0;
        }
        this.notifyUpdate();
      } else {
        invariant2(this.docHandle, void 0, {
          F: __dxlog_file5,
          L: 194,
          S: this,
          A: [
            "this.docHandle",
            ""
          ]
        });
        result = this.docHandle.changeAt(heads, callback, options);
      }
      return result;
    } catch (e) {
      env.error = e;
      env.hasError = true;
    } finally {
      _ts_dispose_resources(env);
    }
  }
  getDocAccessor(path = []) {
    invariant2(isValidKeyPath(path), void 0, {
      F: __dxlog_file5,
      L: 203,
      S: this,
      A: [
        "isValidKeyPath(path)",
        ""
      ]
    });
    const self = this;
    return {
      handle: {
        doc: () => this.getDoc(),
        change: (callback, options) => {
          this.change(callback, options);
        },
        changeAt: (heads, callback, options) => {
          return this.changeAt(heads, callback, options);
        },
        addListener: (event, listener) => {
          if (event === "change") {
            this.docHandle?.on("change", listener);
            this.updates.on(listener);
          }
        },
        removeListener: (event, listener) => {
          if (event === "change") {
            this.docHandle?.off("change", listener);
            this.updates.off(listener);
          }
        }
      },
      get path() {
        return [
          ...self.mountPath,
          "data",
          ...path
        ];
      }
    };
  }
  /**
  * Encode a value to be stored in the Automerge document.
  */
  encode(value) {
    if (isLiveObject(value)) {
      throw new TypeError("Linking is not allowed");
    }
    if (value instanceof A.RawString) {
      return value;
    }
    if (value === void 0) {
      return null;
    }
    if (value instanceof Reference) {
      return encodeReference(value);
    }
    if (Array.isArray(value)) {
      const values = value.map((val) => this.encode(val));
      return values;
    }
    if (typeof value === "object" && value !== null) {
      const entries = Object.entries(value).filter(([_, value2]) => value2 !== void 0);
      return Object.fromEntries(entries.map(([key, value2]) => [
        key,
        this.encode(value2)
      ]));
    }
    if (typeof value === "string" && value.length > STRING_CRDT_LIMIT) {
      return new A.RawString(value);
    }
    return value;
  }
  /**
  * Decode a value from the Automerge document.
  */
  decode(value) {
    if (value === null) {
      return value;
    }
    if (Array.isArray(value)) {
      return value.map((val) => this.decode(val));
    }
    if (value instanceof A.RawString) {
      return value.toString();
    }
    if (isEncodedReference(value) || maybeReference(value)) {
      return decodeReference(value);
    }
    if (typeof value === "object") {
      return Object.fromEntries(Object.entries(value).map(([key, value2]) => [
        key,
        this.decode(value2)
      ]));
    }
    return value;
  }
  arrayPush(path, items) {
    const itemsEncoded = items.map((item) => this.encode(item));
    let newLength = -1;
    this.change((doc) => {
      const fullPath = [
        ...this.mountPath,
        ...path
      ];
      const array = getDeep(doc, fullPath);
      invariant2(Array.isArray(array), void 0, {
        F: __dxlog_file5,
        L: 322,
        S: this,
        A: [
          "Array.isArray(array)",
          ""
        ]
      });
      newLength = array.push(...itemsEncoded);
    });
    invariant2(newLength !== -1, void 0, {
      F: __dxlog_file5,
      L: 325,
      S: this,
      A: [
        "newLength !== -1",
        ""
      ]
    });
    return newLength;
  }
  _getRaw(path) {
    const fullPath = [
      ...this.mountPath,
      ...path
    ];
    let value = this.getDoc();
    for (const key of fullPath) {
      value = value?.[key];
    }
    return value;
  }
  _setRaw(path, value) {
    const fullPath = [
      ...this.mountPath,
      ...path
    ];
    this.change((doc) => {
      setDeep(doc, fullPath, value);
    });
  }
  // TODO(dmaretskyi): Rename to `get`.
  getDecoded(path) {
    return this.decode(this._getRaw(path));
  }
  // TODO(dmaretskyi): Rename to `set`.
  setDecoded(path, value) {
    this._setRaw(path, this.encode(value));
  }
  /**
  * Deletes key at path.
  */
  delete(path) {
    const fullPath = [
      ...this.mountPath,
      ...path
    ];
    this.change((doc) => {
      const value = getDeep(doc, fullPath.slice(0, fullPath.length - 1));
      delete value[fullPath[fullPath.length - 1]];
    });
  }
  getKind() {
    return this._getRaw([
      SYSTEM_NAMESPACE,
      "kind"
    ]) ?? EntityKind.Object;
  }
  // TODO(dmaretskyi): Just set statically during construction.
  setKind(kind) {
    this._setRaw([
      SYSTEM_NAMESPACE,
      "kind"
    ], kind);
  }
  getSource() {
    const res = this.getDecoded([
      SYSTEM_NAMESPACE,
      "source"
    ]);
    invariant2(res === void 0 || res instanceof Reference, void 0, {
      F: __dxlog_file5,
      L: 381,
      S: this,
      A: [
        "res === undefined || res instanceof Reference",
        ""
      ]
    });
    return res;
  }
  // TODO(dmaretskyi): Just set statically during construction.
  setSource(ref) {
    this.setDecoded([
      SYSTEM_NAMESPACE,
      "source"
    ], ref);
  }
  getTarget() {
    const res = this.getDecoded([
      SYSTEM_NAMESPACE,
      "target"
    ]);
    invariant2(res === void 0 || res instanceof Reference, void 0, {
      F: __dxlog_file5,
      L: 392,
      S: this,
      A: [
        "res === undefined || res instanceof Reference",
        ""
      ]
    });
    return res;
  }
  // TODO(dmaretskyi): Just set statically during construction.
  setTarget(ref) {
    this.setDecoded([
      SYSTEM_NAMESPACE,
      "target"
    ], ref);
  }
  getType() {
    const value = this.decode(this._getRaw([
      SYSTEM_NAMESPACE,
      "type"
    ]));
    if (!value) {
      return void 0;
    }
    invariant2(value instanceof Reference, void 0, {
      F: __dxlog_file5,
      L: 407,
      S: this,
      A: [
        "value instanceof Reference",
        ""
      ]
    });
    return value;
  }
  setType(reference) {
    this._setRaw([
      SYSTEM_NAMESPACE,
      "type"
    ], this.encode(reference));
  }
  getMeta() {
    return this.getDecoded([
      META_NAMESPACE
    ]);
  }
  setMeta(meta) {
    this._setRaw([
      META_NAMESPACE
    ], this.encode(meta));
  }
  isDeleted() {
    const value = this._getRaw([
      SYSTEM_NAMESPACE,
      "deleted"
    ]);
    return typeof value === "boolean" ? value : false;
  }
  setDeleted(value) {
    this._setRaw([
      SYSTEM_NAMESPACE,
      "deleted"
    ], value);
  }
  /**
  * @deprecated
  */
  toPlainObject() {
    let data = this.getDecoded([
      DATA_NAMESPACE
    ]);
    if (typeof data !== "object") {
      log5.error("Corrupted object data property", {
        type: typeof data
      }, {
        F: __dxlog_file5,
        L: 438,
        S: this,
        C: (f, a) => f(...a)
      });
      data = {};
    }
    const dataMapped = deepMapValues(data, (value, recurse) => {
      if (value instanceof Reference) {
        return {
          "/": value.toDXN().toString()
        };
      }
      return recurse(value);
    });
    return {
      id: this.id,
      __typename: this.getType()?.toDXN().toString() ?? null,
      __meta: this.getDecoded([
        META_NAMESPACE
      ]),
      ...dataMapped
    };
  }
  /**
  * DXNs of objects that this object strongly depends on.
  * Strong references are loaded together with the source object.
  * Currently this is the schema reference and the source and target for relations
  */
  getStrongDependencies() {
    const res = [];
    const type = this.getType()?.toDXN();
    if (type && type.kind === DXN.kind.ECHO) {
      res.push(type);
    }
    if (this.getKind() === EntityKind.Relation) {
      const source = this.getSource()?.toDXN();
      if (source) {
        res.push(source);
      }
      const target = this.getTarget()?.toDXN();
      if (target) {
        res.push(target);
      }
    }
    return res;
  }
};
var objectIsUpdated = (objId, event) => {
  if (event.patches.some((patch) => patch.path[0] === "objects" && patch.path[1] === objId)) {
    return true;
  }
  return false;
};
var maybeReference = (value) => typeof value === "object" && value !== null && Object.keys(value).length === 3 && "objectId" in value && // TODO(burdon): 'objectId'
"protocol" in value && "host" in value;

// packages/core/echo/echo-db/src/automerge/doc-handle-proxy.ts
import { next as A2 } from "@automerge/automerge";
import { stringifyAutomergeUrl } from "@automerge/automerge-repo";
import { EventEmitter } from "eventemitter3";
import { Trigger, TriggerState } from "@dxos/async";
import { invariant as invariant3 } from "@dxos/invariant";
var __dxlog_file6 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-db/src/automerge/doc-handle-proxy.ts";
var DocHandleProxy = class extends EventEmitter {
  constructor(_documentId, options = {}, _callbacks) {
    super(), this._documentId = _documentId, this._callbacks = _callbacks, this._ready = new Trigger(), this._doc = void 0, this._lastSentHeads = [], this._currentlySendingHeads = [];
    if (options.isNew) {
      this._doc = A2.from(options.initialValue);
      this._doc = A2.emptyChange(this._doc);
      this._ready.wake();
    } else {
      this._doc = A2.init();
    }
  }
  get url() {
    return stringifyAutomergeUrl(this._documentId);
  }
  get documentId() {
    return this._documentId;
  }
  get state() {
    return this._ready.state === TriggerState.RESOLVED ? "ready" : "pending";
  }
  doc() {
    if (!this._doc) {
      throw new Error("DocHandleProxy.doc called on deleted doc");
    }
    return this._doc;
  }
  async whenReady() {
    await this._ready.wait();
  }
  isReady() {
    return this._ready.state === TriggerState.RESOLVED;
  }
  change(fn, opts) {
    invariant3(this._doc, "DocHandleProxy.change called on deleted doc", {
      F: __dxlog_file6,
      L: 90,
      S: this,
      A: [
        "this._doc",
        "'DocHandleProxy.change called on deleted doc'"
      ]
    });
    const before = this._doc;
    const headsBefore = A2.getHeads(this._doc);
    this._doc = opts ? A2.change(this._doc, opts, fn) : A2.change(this._doc, fn);
    this.emit("change", {
      handle: this,
      doc: this._doc,
      patches: A2.diff(this._doc, headsBefore, A2.getHeads(this._doc)),
      patchInfo: {
        before,
        after: this._doc,
        source: "change"
      }
    });
  }
  changeAt(heads, fn, opts) {
    invariant3(this._doc, "DocHandleProxy.changeAt called on deleted doc", {
      F: __dxlog_file6,
      L: 103,
      S: this,
      A: [
        "this._doc",
        "'DocHandleProxy.changeAt called on deleted doc'"
      ]
    });
    const before = this._doc;
    const headsBefore = A2.getHeads(this._doc);
    const { newDoc, newHeads } = opts ? A2.changeAt(this._doc, heads, opts, fn) : A2.changeAt(this._doc, heads, fn);
    this._doc = newDoc;
    this.emit("change", {
      handle: this,
      doc: this._doc,
      patches: newHeads ? A2.diff(this._doc, headsBefore, newHeads) : [],
      patchInfo: {
        before,
        after: this._doc,
        source: "change"
      }
    });
    return newHeads ?? void 0;
  }
  update(updateCallback) {
    invariant3(this._doc, "DocHandleProxy.update called on deleted doc", {
      F: __dxlog_file6,
      L: 119,
      S: this,
      A: [
        "this._doc",
        "'DocHandleProxy.update called on deleted doc'"
      ]
    });
    const before = this._doc;
    const headsBefore = A2.getHeads(this._doc);
    const newDoc = updateCallback(this._doc);
    invariant3(newDoc, "DocHandleProxy.update returned undefined doc", {
      F: __dxlog_file6,
      L: 123,
      S: this,
      A: [
        "newDoc",
        "'DocHandleProxy.update returned undefined doc'"
      ]
    });
    this._doc = newDoc;
    this.emit("change", {
      handle: this,
      doc: this._doc,
      patches: A2.diff(this._doc, headsBefore, A2.getHeads(this._doc)),
      patchInfo: {
        before,
        after: this._doc,
        source: "change"
      }
    });
  }
  delete() {
    this._callbacks?.onDelete();
    this.emit("delete", {
      handle: this
    });
    this._doc = void 0;
  }
  /**
  * Get pending changes since last write.
  * @internal
  */
  _getPendingChanges() {
    invariant3(this._doc, "Doc is deleted, cannot get last write mutation", {
      F: __dxlog_file6,
      L: 144,
      S: this,
      A: [
        "this._doc",
        "'Doc is deleted, cannot get last write mutation'"
      ]
    });
    if (A2.equals(A2.getHeads(this._doc), this._lastSentHeads)) {
      return;
    }
    const mutation = A2.saveSince(this._doc, this._lastSentHeads);
    if (mutation.length === 0) {
      return;
    }
    this._currentlySendingHeads = A2.getHeads(this._doc);
    return mutation;
  }
  /**
  * Confirm that the last write was successful.
  * @internal
  */
  _confirmSync() {
    this._lastSentHeads = this._currentlySendingHeads;
  }
  /**
  * Update the doc with a foreign mutation from worker.
  * @internal
  */
  _integrateHostUpdate(mutation) {
    invariant3(this._doc, "Doc is deleted, cannot write mutation", {
      F: __dxlog_file6,
      L: 170,
      S: this,
      A: [
        "this._doc",
        "'Doc is deleted, cannot write mutation'"
      ]
    });
    const before = this._doc;
    const headsBefore = A2.getHeads(this._doc);
    this._doc = A2.loadIncremental(this._doc, mutation);
    if (A2.equals(headsBefore, this._lastSentHeads)) {
      this._lastSentHeads = A2.getHeads(this._doc);
    }
    this._ready.wake();
    this.emit("change", {
      handle: this,
      doc: this._doc,
      patches: A2.diff(this._doc, headsBefore, A2.getHeads(this._doc)),
      patchInfo: {
        before,
        after: this._doc,
        source: "change"
      }
    });
  }
};

// packages/core/echo/echo-db/src/automerge/repo-proxy.ts
import { next as A3 } from "@automerge/automerge";
import { generateAutomergeUrl, interpretAsDocumentId, parseAutomergeUrl } from "@automerge/automerge-repo";
import { Event as Event4, UpdateScheduler } from "@dxos/async";
import { LifecycleState, Resource } from "@dxos/context";
import { invariant as invariant4 } from "@dxos/invariant";
import { PublicKey } from "@dxos/keys";
import { log as log6 } from "@dxos/log";
import { trace as trace2 } from "@dxos/tracing";
function _ts_decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file7 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-db/src/automerge/repo-proxy.ts";
var MAX_UPDATE_FREQ = 10;
var RPC_TIMEOUT = 3e4;
var RepoProxy = class extends Resource {
  constructor(_dataService, _spaceId) {
    super(), this._dataService = _dataService, this._spaceId = _spaceId, this._handles = {}, this._subscriptionId = PublicKey.random().toHex(), this._subscription = void 0, this._pendingCreateIds = /* @__PURE__ */ new Set(), this._pendingAddIds = /* @__PURE__ */ new Set(), this._pendingRemoveIds = /* @__PURE__ */ new Set(), this._pendingUpdateIds = /* @__PURE__ */ new Set(), this._sendUpdatesJob = void 0, this.saveStateChanged = new Event4();
  }
  get handles() {
    return this._handles;
  }
  find(id) {
    if (typeof id !== "string") {
      throw new TypeError(`Invalid documentId ${id}`);
    }
    const documentId = interpretAsDocumentId(id);
    return this._getHandle({
      documentId,
      isNew: false
    });
  }
  import(dump) {
    const handle = this.create();
    handle.update(() => A3.load(dump));
    return handle;
  }
  create(initialValue) {
    const { documentId } = parseAutomergeUrl(generateAutomergeUrl());
    return this._getHandle({
      documentId,
      isNew: true,
      initialValue
    });
  }
  async flush() {
    await this._sendUpdatesJob?.runBlocking();
  }
  async _open() {
    this._subscription = this._dataService.subscribe({
      subscriptionId: this._subscriptionId,
      spaceId: this._spaceId
    });
    this._sendUpdatesJob = new UpdateScheduler(this._ctx, async () => this._sendUpdates(), {
      maxFrequency: MAX_UPDATE_FREQ
    });
    this._subscription.subscribe((updates) => this._receiveUpdate(updates));
  }
  async _close() {
    await this._sendUpdatesJob?.join();
    this._sendUpdatesJob = void 0;
    for (const handle of Object.values(this._handles)) {
      handle.off("change");
    }
    this._handles = {};
    await this._subscription?.close();
    this._subscription = void 0;
  }
  /** Returns an existing handle if we have it; creates one otherwise. */
  _getHandle({ documentId, isNew, initialValue }) {
    if (this._handles[documentId]) {
      return this._handles[documentId];
    }
    if (!documentId) {
      throw new Error(`Invalid documentId ${documentId}`);
    }
    return this._createHandle({
      documentId,
      isNew,
      initialValue
    });
  }
  _createHandle({ documentId, isNew, initialValue }) {
    invariant4(this._lifecycleState === LifecycleState.OPEN, void 0, {
      F: __dxlog_file7,
      L: 170,
      S: this,
      A: [
        "this._lifecycleState === LifecycleState.OPEN",
        ""
      ]
    });
    const onChange = () => {
      log6("onChange", {
        documentId
      }, {
        F: __dxlog_file7,
        L: 174,
        S: this,
        C: (f, a) => f(...a)
      });
      this._pendingUpdateIds.add(documentId);
      this._sendUpdatesJob?.trigger();
      this._emitSaveStateEvent();
    };
    const onDelete = () => {
      log6("onDelete", {
        documentId
      }, {
        F: __dxlog_file7,
        L: 181,
        S: this,
        C: (f, a) => f(...a)
      });
      handle.off("change", onChange);
      this._pendingRemoveIds.add(documentId);
      this._sendUpdatesJob?.trigger();
      delete this._handles[documentId];
    };
    const handle = new DocHandleProxy(documentId, {
      isNew,
      initialValue
    }, {
      onDelete
    });
    handle.on("change", onChange);
    this._handles[documentId] = handle;
    if (isNew) {
      this._pendingCreateIds.add(documentId);
    } else {
      this._pendingAddIds.add(documentId);
    }
    this._sendUpdatesJob.trigger();
    return handle;
  }
  _receiveUpdate({ updates }) {
    if (!updates) {
      return;
    }
    for (const update of updates) {
      const { documentId, mutation } = update;
      const handle = this._handles[documentId];
      if (!handle) {
        log6.warn("Received update for unknown document", {
          documentId
        }, {
          F: __dxlog_file7,
          L: 211,
          S: this,
          C: (f, a) => f(...a)
        });
        continue;
      }
      handle._integrateHostUpdate(mutation);
    }
  }
  async _sendUpdates() {
    const createIds = Array.from(this._pendingCreateIds);
    const addIds = Array.from(this._pendingAddIds);
    const removeIds = Array.from(this._pendingRemoveIds);
    const updateIds = Array.from(this._pendingUpdateIds);
    this._pendingCreateIds.clear();
    this._pendingAddIds.clear();
    this._pendingRemoveIds.clear();
    this._pendingUpdateIds.clear();
    try {
      await this._dataService.updateSubscription({
        subscriptionId: this._subscriptionId,
        addIds,
        removeIds
      }, {
        timeout: RPC_TIMEOUT
      });
      const updates = [];
      const addMutations = (documentIds, isNew) => {
        for (const documentId of documentIds) {
          const handle = this._handles[documentId];
          invariant4(handle, `No handle found for documentId ${documentId}`, {
            F: __dxlog_file7,
            L: 240,
            S: this,
            A: [
              "handle",
              "`No handle found for documentId ${documentId}`"
            ]
          });
          const mutation = handle._getPendingChanges();
          if (mutation) {
            updates.push({
              documentId,
              mutation,
              isNew
            });
          }
        }
      };
      addMutations(createIds, true);
      addMutations(updateIds);
      if (updates.length > 0) {
        await this._dataService.update({
          subscriptionId: this._subscriptionId,
          updates
        }, {
          timeout: RPC_TIMEOUT
        });
        for (const { documentId } of updates) {
          this._handles[documentId]._confirmSync();
        }
      }
      this._emitSaveStateEvent();
    } catch (err) {
      createIds.forEach((id) => this._pendingCreateIds.add(id));
      addIds.forEach((id) => this._pendingAddIds.add(id));
      removeIds.forEach((id) => this._pendingRemoveIds.add(id));
      updateIds.forEach((id) => this._pendingUpdateIds.add(id));
      this._ctx.raise(err);
    }
  }
  _emitSaveStateEvent() {
    const unsavedDocuments = [
      ...this._pendingCreateIds,
      ...this._pendingUpdateIds
    ];
    this.saveStateChanged.emit({
      unsavedDocuments
    });
  }
};
RepoProxy = _ts_decorate([
  trace2.resource()
], RepoProxy);

// packages/core/echo/echo-db/src/core-db/core-database.ts
import { getHeads } from "@automerge/automerge";
import { interpretAsDocumentId as interpretAsDocumentId3 } from "@automerge/automerge-repo";
import { asyncTimeout as asyncTimeout2, Event as Event7, runInContextAsync, synchronized, TimeoutError, Trigger as Trigger2, UpdateScheduler as UpdateScheduler2 } from "@dxos/async";
import { Stream as Stream2 } from "@dxos/codec-protobuf/stream";
import { Context as Context3, ContextDisposedError } from "@dxos/context";
import { raise } from "@dxos/debug";
import { encodeReference as encodeReference2, isEncodedReference as isEncodedReference3, Reference as Reference2, DATA_NAMESPACE as DATA_NAMESPACE2 } from "@dxos/echo-protocol";
import { Ref } from "@dxos/echo-schema";
import { compositeRuntime as compositeRuntime2 } from "@dxos/echo-signals/runtime";
import { invariant as invariant7 } from "@dxos/invariant";
import { DXN as DXN3, LOCAL_SPACE_TAG } from "@dxos/keys";
import { log as log9 } from "@dxos/log";
import { trace as trace4 } from "@dxos/tracing";
import { chunkArray, deepMapValues as deepMapValues2, defaultMap, setDeep as setDeep2 } from "@dxos/util";

// packages/core/echo/echo-db/src/core-db/automerge-doc-loader.ts
import { next as A4 } from "@automerge/automerge";
import { interpretAsDocumentId as interpretAsDocumentId2 } from "@automerge/automerge-repo";
import { Event as Event5 } from "@dxos/async";
import { cancelWithContext } from "@dxos/context";
import { warnAfterTimeout } from "@dxos/debug";
import { DatabaseDirectory, SpaceDocVersion } from "@dxos/echo-protocol";
import { assertState, invariant as invariant5 } from "@dxos/invariant";
import { log as log7 } from "@dxos/log";
import { trace as trace3 } from "@dxos/tracing";
import { ComplexSet } from "@dxos/util";
function _ts_decorate2(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file8 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-db/src/core-db/automerge-doc-loader.ts";
var AutomergeDocumentLoaderImpl = class {
  constructor(_repo, _spaceId, _spaceKey) {
    this._repo = _repo;
    this._spaceId = _spaceId;
    this._spaceKey = _spaceKey;
    this._spaceRootDocHandle = null;
    this._objectDocumentHandles = /* @__PURE__ */ new Map();
    this._objectsPendingDocumentLoad = /* @__PURE__ */ new Set();
    this._currentlyLoadingObjects = new ComplexSet(({ url, objectId }) => `${url}:${objectId}`);
    this.onObjectDocumentLoaded = new Event5();
  }
  get hasRootHandle() {
    return this._spaceRootDocHandle != null;
  }
  getAllHandles() {
    return this._spaceRootDocHandle != null ? [
      this._spaceRootDocHandle,
      ...new Set(this._objectDocumentHandles.values())
    ] : [];
  }
  getLinkedDocHandles() {
    return [
      ...new Set(this._objectDocumentHandles.values())
    ];
  }
  async loadSpaceRootDocHandle(ctx, spaceState) {
    if (this._spaceRootDocHandle != null) {
      return;
    }
    if (!spaceState.rootUrl) {
      throw new Error("Database opened with no rootUrl");
    }
    const existingDocHandle = await this._initDocHandle(ctx, spaceState.rootUrl);
    const doc = existingDocHandle.doc();
    invariant5(doc, void 0, {
      F: __dxlog_file8,
      L: 107,
      S: this,
      A: [
        "doc",
        ""
      ]
    });
    invariant5(doc.version === SpaceDocVersion.CURRENT, void 0, {
      F: __dxlog_file8,
      L: 108,
      S: this,
      A: [
        "doc.version === SpaceDocVersion.CURRENT",
        ""
      ]
    });
    if (doc.access == null) {
      this._initDocAccess(existingDocHandle);
    }
    this._spaceRootDocHandle = existingDocHandle;
  }
  objectPresent(id) {
    assertState(this._spaceRootDocHandle, "Database was not initialized with root object.");
    return DatabaseDirectory.getInlineObject(this._spaceRootDocHandle.doc(), id) != null || DatabaseDirectory.getLink(this._spaceRootDocHandle.doc(), id) != null;
  }
  loadObjectDocument(objectIdOrMany) {
    const objectIds = Array.isArray(objectIdOrMany) ? objectIdOrMany : [
      objectIdOrMany
    ];
    let hasUrlsToLoad = false;
    const urlsToLoad = {};
    for (const objectId of objectIds) {
      invariant5(this._spaceRootDocHandle, "Database was not initialized with root object.", {
        F: __dxlog_file8,
        L: 128,
        S: this,
        A: [
          "this._spaceRootDocHandle",
          "'Database was not initialized with root object.'"
        ]
      });
      if (this._objectDocumentHandles.has(objectId) || this._objectsPendingDocumentLoad.has(objectId)) {
        continue;
      }
      const documentUrl = this._getLinkedDocumentUrl(objectId);
      if (documentUrl == null) {
        this._objectsPendingDocumentLoad.add(objectId);
        log7("loading delayed until object links are initialized", {
          objectId
        }, {
          F: __dxlog_file8,
          L: 135,
          S: this,
          C: (f, a) => f(...a)
        });
      } else {
        urlsToLoad[objectId] = documentUrl;
        hasUrlsToLoad = true;
      }
    }
    if (hasUrlsToLoad) {
      this._loadLinkedObjects(urlsToLoad);
    }
  }
  getObjectDocumentId(objectId) {
    invariant5(this._spaceRootDocHandle, "Database was not initialized with root object.", {
      F: __dxlog_file8,
      L: 147,
      S: this,
      A: [
        "this._spaceRootDocHandle",
        "'Database was not initialized with root object.'"
      ]
    });
    const spaceRootDoc = this._spaceRootDocHandle.doc();
    invariant5(spaceRootDoc, void 0, {
      F: __dxlog_file8,
      L: 149,
      S: this,
      A: [
        "spaceRootDoc",
        ""
      ]
    });
    if (spaceRootDoc.objects?.[objectId]) {
      return this._spaceRootDocHandle.documentId;
    }
    const documentUrl = this._getLinkedDocumentUrl(objectId);
    return documentUrl && interpretAsDocumentId2(documentUrl.toString());
  }
  onObjectLinksUpdated(links) {
    if (!links) {
      return;
    }
    const linksAwaitingLoad = Object.entries(links).filter(([objectId]) => this._objectsPendingDocumentLoad.has(objectId));
    this._loadLinkedObjects(Object.fromEntries(linksAwaitingLoad));
    linksAwaitingLoad.forEach(([objectId]) => this._objectsPendingDocumentLoad.delete(objectId));
  }
  getSpaceRootDocHandle() {
    invariant5(this._spaceRootDocHandle, "Database was not initialized with root object.", {
      F: __dxlog_file8,
      L: 169,
      S: this,
      A: [
        "this._spaceRootDocHandle",
        "'Database was not initialized with root object.'"
      ]
    });
    return this._spaceRootDocHandle;
  }
  createDocumentForObject(objectId) {
    invariant5(this._spaceRootDocHandle, "Database was not initialized with root object.", {
      F: __dxlog_file8,
      L: 174,
      S: this,
      A: [
        "this._spaceRootDocHandle",
        "'Database was not initialized with root object.'"
      ]
    });
    const spaceDocHandle = this._repo.create({
      version: SpaceDocVersion.CURRENT,
      access: {
        spaceKey: this._spaceKey.toHex()
      }
    });
    this.onObjectBoundToDocument(spaceDocHandle, objectId);
    this._spaceRootDocHandle.change((newDoc) => {
      newDoc.links ??= {};
      newDoc.links[objectId] = new A4.RawString(spaceDocHandle.url);
    });
    return spaceDocHandle;
  }
  onObjectBoundToDocument(handle, objectId) {
    this._objectDocumentHandles.set(objectId, handle);
  }
  clearHandleReferences() {
    const objectsWithHandles = [
      ...this._objectDocumentHandles.keys()
    ];
    this._objectDocumentHandles.clear();
    this._spaceRootDocHandle = null;
    return objectsWithHandles;
  }
  _getLinkedDocumentUrl(objectId) {
    const spaceRootDoc = this._spaceRootDocHandle?.doc();
    invariant5(spaceRootDoc, void 0, {
      F: __dxlog_file8,
      L: 200,
      S: this,
      A: [
        "spaceRootDoc",
        ""
      ]
    });
    return (spaceRootDoc.links ?? {})[objectId]?.toString();
  }
  _loadLinkedObjects(links) {
    if (!links) {
      return;
    }
    for (const [objectId, automergeUrlData] of Object.entries(links)) {
      const automergeUrl = automergeUrlData.toString();
      const logMeta = {
        objectId,
        automergeUrl
      };
      const objectDocumentHandle = this._objectDocumentHandles.get(objectId);
      if (objectDocumentHandle != null && objectDocumentHandle.url !== automergeUrl) {
        log7.warn("object already inlined in a different document, ignoring the link", {
          ...logMeta,
          actualDocumentUrl: objectDocumentHandle.url
        }, {
          F: __dxlog_file8,
          L: 213,
          S: this,
          C: (f, a) => f(...a)
        });
        continue;
      }
      if (objectDocumentHandle?.url === automergeUrl) {
        log7.warn("object document was already loaded", logMeta, {
          F: __dxlog_file8,
          L: 220,
          S: this,
          C: (f, a) => f(...a)
        });
        continue;
      }
      const handle = this._repo.find(automergeUrl);
      log7.debug("document loading triggered", logMeta, {
        F: __dxlog_file8,
        L: 224,
        S: this,
        C: (f, a) => f(...a)
      });
      this._objectDocumentHandles.set(objectId, handle);
      void this._loadHandleForObject(handle, objectId);
    }
  }
  async _initDocHandle(ctx, url) {
    const docHandle = this._repo.find(url);
    await warnAfterTimeout(5e3, "Automerge root doc load timeout (CoreDatabase)", async () => {
      await cancelWithContext(ctx, docHandle.whenReady());
    });
    return docHandle;
  }
  _initDocAccess(handle) {
    handle.change((newDoc) => {
      newDoc.access ??= {
        spaceKey: this._spaceKey.toHex()
      };
      newDoc.access.spaceKey = this._spaceKey.toHex();
    });
  }
  async _loadHandleForObject(handle, objectId) {
    try {
      if (this._currentlyLoadingObjects.has({
        url: handle.url,
        objectId
      })) {
        log7.warn("document is already loading", {
          objectId
        }, {
          F: __dxlog_file8,
          L: 249,
          S: this,
          C: (f, a) => f(...a)
        });
        return;
      }
      this._currentlyLoadingObjects.add({
        url: handle.url,
        objectId
      });
      await handle.whenReady();
      this._currentlyLoadingObjects.delete({
        url: handle.url,
        objectId
      });
      const logMeta = {
        objectId,
        docUrl: handle.url
      };
      if (this.onObjectDocumentLoaded.listenerCount() === 0) {
        log7.info("document loaded after all listeners were removed", logMeta, {
          F: __dxlog_file8,
          L: 258,
          S: this,
          C: (f, a) => f(...a)
        });
        return;
      }
      const objectDocHandle = this._objectDocumentHandles.get(objectId);
      if (objectDocHandle?.url !== handle.url) {
        log7.warn("object was rebound while a document was loading, discarding handle", logMeta, {
          F: __dxlog_file8,
          L: 263,
          S: this,
          C: (f, a) => f(...a)
        });
        return;
      }
      this.onObjectDocumentLoaded.emit({
        handle,
        objectId
      });
    } catch (err) {
      this._currentlyLoadingObjects.delete({
        url: handle.url,
        objectId
      });
      const shouldRetryLoading = this.onObjectDocumentLoaded.listenerCount() > 0;
      log7.warn("failed to load a document", {
        objectId,
        automergeUrl: handle.url,
        retryLoading: shouldRetryLoading,
        err
      }, {
        F: __dxlog_file8,
        L: 270,
        S: this,
        C: (f, a) => f(...a)
      });
      if (shouldRetryLoading) {
        await this._loadHandleForObject(handle, objectId);
      }
    }
  }
};
_ts_decorate2([
  trace3.span({
    showInBrowserTimeline: true
  })
], AutomergeDocumentLoaderImpl.prototype, "loadSpaceRootDocHandle", null);
AutomergeDocumentLoaderImpl = _ts_decorate2([
  trace3.resource()
], AutomergeDocumentLoaderImpl);

// packages/core/echo/echo-db/src/core-db/core-database-query-context.ts
import { next as A5 } from "@automerge/automerge";
import { Event as Event6 } from "@dxos/async";
import { Stream } from "@dxos/codec-protobuf/stream";
import { Context as Context2 } from "@dxos/context";
import { filterMatchObject as filterMatchObject2 } from "@dxos/echo-pipeline/filter";
import { isEncodedReference as isEncodedReference2 } from "@dxos/echo-protocol";
import { invariant as invariant6 } from "@dxos/invariant";
import { DXN as DXN2, PublicKey as PublicKey2, SpaceId as SpaceId2 } from "@dxos/keys";
import { log as log8 } from "@dxos/log";
import { QueryReactivity } from "@dxos/protocols/proto/dxos/echo/query";
import { isNonNullable as isNonNullable2 } from "@dxos/util";
function _ts_add_disposable_resource2(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = function() {
      try {
        inner.call(this);
      } catch (e) {
        return Promise.reject(e);
      }
    };
    env.stack.push({
      value,
      dispose,
      async
    });
  } else if (async) {
    env.stack.push({
      async: true
    });
  }
  return value;
}
function _ts_dispose_resources2(env) {
  var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  };
  return (_ts_dispose_resources2 = function _ts_dispose_resources4(env2) {
    function fail(e) {
      env2.error = env2.hasError ? new _SuppressedError(e, env2.error, "An error was suppressed during disposal.") : e;
      env2.hasError = true;
    }
    var r, s = 0;
    function next() {
      while (r = env2.stack.pop()) {
        try {
          if (!r.async && s === 1) return s = 0, env2.stack.push(r), Promise.resolve().then(next);
          if (r.dispose) {
            var result = r.dispose.call(r.value);
            if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
              fail(e);
              return next();
            });
          } else s |= 1;
        } catch (e) {
          fail(e);
        }
      }
      if (s === 1) return env2.hasError ? Promise.reject(env2.error) : Promise.resolve();
      if (env2.hasError) throw env2.error;
    }
    return next();
  })(env);
}
var __dxlog_file9 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-db/src/core-db/core-database-query-context.ts";
var QUERY_SERVICE_TIMEOUT = 2e4;
var CoreDatabaseQueryContext = class {
  constructor(_coreDatabase, _queryService) {
    this._coreDatabase = _coreDatabase;
    this._queryService = _queryService;
    this._lastResult = [];
    this.changed = new Event6();
  }
  // TODO(dmaretskyi): Make async.
  start() {
  }
  // TODO(dmaretskyi): Make async.
  stop() {
  }
  getResults() {
    return this._lastResult;
  }
  async run(query) {
    const env = {
      stack: [],
      error: void 0,
      hasError: false
    };
    try {
      const queryId = nextQueryId++;
      const ctx = _ts_add_disposable_resource2(env, new Context2(void 0, {
        F: __dxlog_file9,
        L: 56
      }), true);
      const start = Date.now();
      const trivial = isSimpleSelectionQuery(query);
      if (!trivial) {
        return [];
      }
      const { filter, options: _options } = trivial;
      if (filter.type === "object" && filter.id?.length === 1) {
        const core = await this._coreDatabase.loadObjectCoreById(filter.id[0]);
        if (!core || ctx.disposed) {
          return [];
        }
        return (await Promise.all([
          this._filterMapCore(filter, core, start, void 0)
        ])).filter(isNonNullable2);
      }
      const response = await Stream.first(this._queryService.execQuery({
        query: JSON.stringify(query),
        reactivity: QueryReactivity.ONE_SHOT
      }, {
        timeout: QUERY_SERVICE_TIMEOUT
      }));
      if (!response) {
        throw new Error("Query terminated without a response.");
      }
      log8("raw results", {
        queryId,
        length: response.results?.length ?? 0
      }, {
        F: __dxlog_file9,
        L: 89,
        S: this,
        C: (f, a) => f(...a)
      });
      const processedResults = await Promise.all((response.results ?? []).map((result) => this._filterMapResult(ctx, filter, start, result)));
      const results = processedResults.filter(isNonNullable2);
      log8("processed results", {
        queryId,
        fetchedFromIndex: response.results?.length ?? 0,
        loaded: results.length
      }, {
        F: __dxlog_file9,
        L: 101,
        S: this,
        C: (f, a) => f(...a)
      });
      return results;
    } catch (e) {
      env.error = e;
      env.hasError = true;
    } finally {
      const result = _ts_dispose_resources2(env);
      if (result) await result;
    }
  }
  update(query) {
  }
  async _filterMapResult(ctx, filter, queryStartTimestamp, result) {
    if (!SpaceId2.isValid(result.spaceId)) {
      log8.warn("dropping result with invalid space id", {
        id: result.id,
        spaceId: result.spaceId
      }, {
        F: __dxlog_file9,
        L: 124,
        S: this,
        C: (f, a) => f(...a)
      });
      return null;
    }
    const FORCE_DATA_SERVICE_FETCH = true;
    if (!FORCE_DATA_SERVICE_FETCH && result.documentJson) {
      return {
        id: result.id,
        spaceId: result.spaceId,
        spaceKey: PublicKey2.ZERO,
        object: JSON.parse(result.documentJson),
        match: {
          rank: result.rank
        },
        resolution: {
          source: "remote",
          time: Date.now() - queryStartTimestamp
        }
      };
    } else if (!FORCE_DATA_SERVICE_FETCH && result.documentAutomerge) {
      const doc = A5.load(result.documentAutomerge);
      const object = doc.objects?.[result.id];
      if (!object) {
        return null;
      }
      return {
        id: result.id,
        spaceId: result.spaceId,
        spaceKey: PublicKey2.ZERO,
        object,
        match: {
          rank: result.rank
        },
        resolution: {
          source: "remote",
          time: Date.now() - queryStartTimestamp
        }
      };
    } else {
      const objectDocId = this._coreDatabase._automergeDocLoader.getObjectDocumentId(result.id);
      if (objectDocId !== result.documentId) {
        log8("documentIds don't match", {
          objectId: result.id,
          expected: result.documentId,
          actual: objectDocId ?? null
        }, {
          F: __dxlog_file9,
          L: 164,
          S: this,
          C: (f, a) => f(...a)
        });
        return null;
      }
      const core = await this._coreDatabase.loadObjectCoreById(result.id);
      if (!core || ctx.disposed) {
        return null;
      }
      return this._filterMapCore(filter, core, queryStartTimestamp, result);
    }
  }
  async _filterMapCore(filter, core, queryStartTimestamp, result) {
    if (!filterMatchObject2(filter, {
      doc: core.getObjectStructure(),
      id: core.id,
      spaceId: core.database.spaceId
    })) {
      return null;
    }
    return {
      id: core.id,
      spaceId: core.database.spaceId,
      spaceKey: core.database.spaceKey,
      object: core.toPlainObject(),
      match: result && {
        rank: result.rank
      },
      resolution: {
        source: "remote",
        time: Date.now() - queryStartTimestamp
      }
    };
  }
  async _recursivelyJoinFields(data, joinSpec) {
    if (!joinSpec) {
      return data;
    }
    const newData = {
      ...data
    };
    for (const [key, spec] of Object.entries(joinSpec)) {
      if (spec === true || typeof spec === "object" && spec !== null) {
        if (isEncodedReference2(newData[key])) {
          const dxn = DXN2.parse(newData[key]["/"]);
          invariant6(dxn.isLocalObjectId(), void 0, {
            F: __dxlog_file9,
            L: 227,
            S: this,
            A: [
              "dxn.isLocalObjectId()",
              ""
            ]
          });
          const core = await this._coreDatabase.loadObjectCoreById(dxn.parts[1]);
          newData[key] = core ? await this._recursivelyJoinFields(core.toPlainObject(), spec !== true ? spec : void 0) : null;
        } else {
          throw new Error(`Invalid join spec: ${spec}`);
        }
      }
    }
    return newData;
  }
};
var nextQueryId = 1;

// packages/core/echo/echo-db/src/core-db/util.ts
import { next as A6 } from "@automerge/automerge";
import { isValidAutomergeUrl } from "@automerge/automerge-repo";
var getInlineAndLinkChanges = (event) => {
  const inlineChangedObjectIds = /* @__PURE__ */ new Set();
  const linkedDocuments = {};
  for (const { path, value } of event.patches) {
    if (path.length < 2) {
      continue;
    }
    switch (path[0]) {
      case "objects":
        if (path.length >= 2) {
          inlineChangedObjectIds.add(path[1]);
        }
        break;
      case "links":
        if (path.length >= 2 && (typeof value === "string" || value instanceof A6.RawString)) {
          const valueStr = value.toString();
          if (isValidAutomergeUrl(valueStr)) {
            linkedDocuments[path[1]] = valueStr;
          }
        }
        break;
    }
  }
  return {
    inlineChangedObjects: [
      ...inlineChangedObjectIds
    ],
    linkedDocuments
  };
};

// packages/core/echo/echo-db/src/core-db/core-database.ts
function _ts_decorate3(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file10 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-db/src/core-db/core-database.ts";
var THROTTLED_UPDATE_FREQUENCY = 10;
var TRACE_LOADING = false;
var CoreDatabase = class {
  constructor({ graph, dataService, queryService, spaceId, spaceKey }) {
    this._objects = /* @__PURE__ */ new Map();
    /**
    * DXN string -> ObjectId.
    * Stores the targets of strong dependencies to the objects that depend on them.
    * When we load an object that doesn't have it's strong deps resolved, we wait for the deps to be loaded first.
    */
    this._strongDepsIndex = /* @__PURE__ */ new Map();
    this._updateEvent = new Event7();
    this._state = 0;
    this._ctx = new Context3(void 0, {
      F: __dxlog_file10,
      L: 113
    });
    // TODO(dmaretskyi): Refactor this.
    this.opened = new Trigger2();
    this.rootChanged = new Event7();
    /**
    * Keep as field to have a reference to pass for unsubscribing from handle changes.
    */
    this._onDocumentUpdate = (event) => {
      const documentChanges = this._processDocumentUpdate(event);
      this._rebindObjects(event.handle, documentChanges.objectsToRebind);
      this._automergeDocLoader.onObjectLinksUpdated(documentChanges.linkedDocuments);
      this._createInlineObjects(event.handle, documentChanges.createdObjectIds);
      this._emitObjectUpdateEvent(documentChanges.updatedObjectIds);
      this._scheduleThrottledDbUpdate(documentChanges.updatedObjectIds);
    };
    /**
    * Throttled db query updates. Signal updates were already emitted for these objects to immediately
    * update the UI. This happens for locally changed objects (_onDocumentUpdate).
    */
    this._objectsForNextDbUpdate = /* @__PURE__ */ new Set();
    /**
    * Objects for which we throttled a db update event and a signal update event.
    * This happens for objects which were loaded for the first time (_onObjectDocumentLoaded).
    */
    this._objectsForNextUpdate = /* @__PURE__ */ new Set();
    this._updateScheduler = new UpdateScheduler2(this._ctx, async () => this._emitDbUpdateEvents(), {
      maxFrequency: THROTTLED_UPDATE_FREQUENCY
    });
    this._hypergraph = graph;
    this._dataService = dataService;
    this._queryService = queryService;
    this._spaceId = spaceId;
    this._spaceKey = spaceKey;
    this._repoProxy = new RepoProxy(this._dataService, this._spaceId);
    this.saveStateChanged = this._repoProxy.saveStateChanged;
    this._automergeDocLoader = new AutomergeDocumentLoaderImpl(this._repoProxy, spaceId, spaceKey);
  }
  toJSON() {
    return {
      id: this._spaceId,
      objects: this._objects.size
    };
  }
  get graph() {
    return this._hypergraph;
  }
  get spaceId() {
    return this._spaceId;
  }
  /**
  * @deprecated
  */
  get spaceKey() {
    return this._spaceKey;
  }
  // TODO(dmaretskyi): Stop exposing repo.
  // Currently needed for migration-builder and unit-tests.
  get _repo() {
    return this._repoProxy;
  }
  async open(spaceState) {
    const start = performance.now();
    if (this._state !== 0) {
      log9.info("Already open", void 0, {
        F: __dxlog_file10,
        L: 170,
        S: this,
        C: (f, a) => f(...a)
      });
      return;
    }
    this._state = 1;
    await this._repoProxy.open();
    this._ctx.onDispose(this._unsubscribeFromHandles.bind(this));
    this._automergeDocLoader.onObjectDocumentLoaded.on(this._ctx, this._onObjectDocumentLoaded.bind(this));
    try {
      await this._automergeDocLoader.loadSpaceRootDocHandle(this._ctx, spaceState);
      const spaceRootDocHandle = this._automergeDocLoader.getSpaceRootDocHandle();
      const spaceRootDoc = spaceRootDocHandle.doc();
      invariant7(spaceRootDoc, void 0, {
        F: __dxlog_file10,
        L: 183,
        S: this,
        A: [
          "spaceRootDoc",
          ""
        ]
      });
      const objectIds = Object.keys(spaceRootDoc.objects ?? {});
      this._createInlineObjects(spaceRootDocHandle, objectIds);
      spaceRootDocHandle.on("change", this._onDocumentUpdate);
    } catch (err) {
      if (err instanceof ContextDisposedError) {
        return;
      }
      log9.catch(err, void 0, {
        F: __dxlog_file10,
        L: 191,
        S: this,
        C: (f, a) => f(...a)
      });
      throw err;
    }
    const elapsed = performance.now() - start;
    if (elapsed > 1e3) {
      log9.warn("slow AM open", {
        docId: spaceState.rootUrl,
        duration: elapsed
      }, {
        F: __dxlog_file10,
        L: 197,
        S: this,
        C: (f, a) => f(...a)
      });
    }
    this._state = 2;
    this.opened.wake();
  }
  // TODO(dmaretskyi): Cant close while opening.
  async close() {
    if (this._state === 0) {
      return;
    }
    this._state = 0;
    this.opened.throw(new ContextDisposedError());
    this.opened.reset();
    await this._ctx.dispose();
    this._ctx = new Context3(void 0, {
      F: __dxlog_file10,
      L: 216
    });
    await this._repoProxy.close();
  }
  /**
  * Update DB in response to space state change.
  * Can be used to change the root AM document.
  */
  // TODO(dmaretskyi): should it be synchronized and/or cancelable?
  async updateSpaceState(spaceState) {
    invariant7(this._ctx, "Must be open", {
      F: __dxlog_file10,
      L: 228,
      S: this,
      A: [
        "this._ctx",
        "'Must be open'"
      ]
    });
    if (spaceState.rootUrl === this._automergeDocLoader.getSpaceRootDocHandle().url) {
      return;
    }
    this._unsubscribeFromHandles();
    const objectIdsToLoad = this._automergeDocLoader.clearHandleReferences();
    try {
      await this._automergeDocLoader.loadSpaceRootDocHandle(this._ctx, spaceState);
      const spaceRootDocHandle = this._automergeDocLoader.getSpaceRootDocHandle();
      await this._handleSpaceRootDocumentChange(spaceRootDocHandle, objectIdsToLoad);
      spaceRootDocHandle.on("change", this._onDocumentUpdate);
    } catch (err) {
      if (err instanceof ContextDisposedError) {
        return;
      }
      log9.catch(err, void 0, {
        F: __dxlog_file10,
        L: 244,
        S: this,
        C: (f, a) => f(...a)
      });
      throw err;
    }
  }
  /**
  * Returns ids for loaded and not loaded objects.
  */
  getAllObjectIds() {
    if (this._state !== 2) {
      return [];
    }
    const hasLoadedHandles = this._automergeDocLoader.getAllHandles().length > 0;
    if (!hasLoadedHandles) {
      return [];
    }
    const rootDoc = this._automergeDocLoader.getSpaceRootDocHandle().doc();
    if (!rootDoc) {
      return [];
    }
    return [
      .../* @__PURE__ */ new Set([
        ...Object.keys(rootDoc.objects ?? {}),
        ...Object.keys(rootDoc.links ?? {})
      ])
    ];
  }
  getNumberOfInlineObjects() {
    return Object.keys(this._automergeDocLoader.getSpaceRootDocHandle().doc()?.objects ?? {}).length;
  }
  getNumberOfLinkedObjects() {
    return Object.keys(this._automergeDocLoader.getSpaceRootDocHandle().doc()?.links ?? {}).length;
  }
  getTotalNumberOfObjects() {
    return this.getNumberOfInlineObjects() + this.getNumberOfLinkedObjects();
  }
  /**
  * @deprecated
  * Return only loaded objects.
  */
  allObjectCores() {
    return Array.from(this._objects.values());
  }
  getObjectCoreById(id, { load = true } = {}) {
    if (!this._automergeDocLoader.hasRootHandle) {
      throw new Error("Database is not ready.");
    }
    const objCore = this._objects.get(id);
    if (load && !objCore) {
      this._automergeDocLoader.loadObjectDocument(id);
      return void 0;
    }
    invariant7(objCore instanceof ObjectCore, void 0, {
      F: __dxlog_file10,
      L: 300,
      S: this,
      A: [
        "objCore instanceof ObjectCore",
        ""
      ]
    });
    return objCore;
  }
  // TODO(Mykola): Reconcile with `getObjectById`.
  async loadObjectCoreById(objectId, { timeout, returnWithUnsatisfiedDeps } = {}) {
    const core = this.getObjectCoreById(objectId);
    if (core && (returnWithUnsatisfiedDeps || this._areDepsSatisfied(core))) {
      return core;
    }
    const isReady = () => {
      const core2 = this.getObjectCoreById(objectId);
      return core2 ? returnWithUnsatisfiedDeps || this._areDepsSatisfied(core2) : false;
    };
    const waitForUpdate = this._updateEvent.waitFor((event) => event.itemsUpdated.some(({ id }) => id === objectId) && isReady()).then(() => this.getObjectCoreById(objectId));
    this._automergeDocLoader.loadObjectDocument(objectId);
    return timeout ? asyncTimeout2(waitForUpdate, timeout) : waitForUpdate;
  }
  async batchLoadObjectCores(objectIds, { inactivityTimeout = 3e4, returnDeleted = false, returnWithUnsatisfiedDeps = false, failOnTimeout = false } = {}) {
    if (!this._automergeDocLoader.hasRootHandle) {
      throw new Error("Database is not ready.");
    }
    const result = new Array(objectIds.length);
    const objectsToLoad = [];
    for (let i = 0; i < objectIds.length; i++) {
      const objectId = objectIds[i];
      if (!this._automergeDocLoader.objectPresent(objectId)) {
        result[i] = void 0;
        continue;
      }
      const core = this.getObjectCoreById(objectId, {
        load: true
      });
      if (!returnDeleted && this._objects.get(objectId)?.isDeleted()) {
        result[i] = void 0;
      } else if (!returnWithUnsatisfiedDeps && core && !this._areDepsSatisfied(core)) {
        result[i] = void 0;
      } else if (core != null) {
        result[i] = core;
      } else {
        objectsToLoad.push({
          id: objectId,
          resultIndex: i
        });
      }
    }
    if (objectsToLoad.length === 0) {
      return result;
    }
    const idsToLoad = objectsToLoad.map((v) => v.id);
    this._automergeDocLoader.loadObjectDocument(idsToLoad);
    const startTime = TRACE_LOADING ? performance.now() : 0;
    const diagnostics = [];
    try {
      return await new Promise((resolve, reject) => {
        let unsubscribe = null;
        let inactivityTimeoutTimer;
        const scheduleInactivityTimeout = () => {
          inactivityTimeoutTimer = setTimeout(() => {
            unsubscribe?.();
            if (failOnTimeout) {
              diagnostics.push("inactivity-rejected");
              reject(new TimeoutError(inactivityTimeout));
            } else {
              diagnostics.push("inactivity-resolved");
              resolve(result);
            }
          }, inactivityTimeout);
        };
        unsubscribe = this._updateEvent.on(({ itemsUpdated }) => {
          const updatedIds = itemsUpdated.map((v) => v.id);
          for (let i = objectsToLoad.length - 1; i >= 0; i--) {
            const objectToLoad = objectsToLoad[i];
            if (updatedIds.includes(objectToLoad.id)) {
              clearTimeout(inactivityTimeoutTimer);
              const isDeleted = this._objects.get(objectToLoad.id)?.isDeleted();
              const depsUnsatisfied = this._objects.get(objectToLoad.id) && !this._areDepsSatisfied(this._objects.get(objectToLoad.id));
              if (!returnDeleted && isDeleted) {
                diagnostics.push("object-deleted");
                result[objectToLoad.resultIndex] = void 0;
              } else if (!returnWithUnsatisfiedDeps && depsUnsatisfied) {
                diagnostics.push("deps-unsatisfied");
                result[objectToLoad.resultIndex] = void 0;
              } else {
                result[objectToLoad.resultIndex] = this.getObjectCoreById(objectToLoad.id);
              }
              objectsToLoad.splice(i, 1);
              scheduleInactivityTimeout();
            }
          }
          if (objectsToLoad.length === 0) {
            clearTimeout(inactivityTimeoutTimer);
            unsubscribe?.();
            resolve(result);
          }
        });
        scheduleInactivityTimeout();
      });
    } finally {
      if (TRACE_LOADING) {
        log9.info("loading objects", {
          objectIds,
          elapsed: performance.now() - startTime,
          diagnostics
        }, {
          F: __dxlog_file10,
          L: 423,
          S: this,
          C: (f, a) => f(...a)
        });
      }
    }
  }
  static {
    this.prototype.query = this.prototype._query;
  }
  _query(filter, options) {
    return new QueryResult(this._createQueryContext(), normalizeQuery(filter, options, {
      defaultSpaceId: this.spaceId
    }));
  }
  /**
  * @internal
  */
  _createQueryContext() {
    return new CoreDatabaseQueryContext(this, this._queryService);
  }
  /**
  * Update objects.
  */
  async update(filter, operation) {
    const ast = filter.ast;
    if (ast.type !== "object" || ast.id?.length !== 1) {
      throw new Error("Only object id filters with one id are currently supported");
    }
    const id = ast.id[0];
    const core = this.getObjectCoreById(id);
    if (!core) {
      throw new Error(`Object not found: ${id}`);
    }
    core.change((doc) => {
      for (const key in operation) {
        if (key === "id") {
          continue;
        }
        setDeep2(doc, [
          ...core.mountPath,
          DATA_NAMESPACE2,
          key
        ], operation[key]);
      }
    });
    await this.flush();
  }
  async insert(data) {
    const isBatch = Array.isArray(data);
    const dataArray = isBatch ? data : [
      data
    ];
    const cores = dataArray.map((item) => {
      const core = createCoreFromInsertData(item);
      this.addCore(core);
      return core;
    });
    await this.flush();
    return isBatch ? cores.map((core) => core.toPlainObject()) : cores[0].toPlainObject();
  }
  addCore(core, opts) {
    if (core.database) {
      if (core.database !== this) {
        throw new Error("Object already belongs to another database");
      }
      if (core.isDeleted()) {
        core.setDeleted(false);
      }
      return;
    }
    invariant7(!this._objects.has(core.id), void 0, {
      F: __dxlog_file10,
      L: 508,
      S: this,
      A: [
        "!this._objects.has(core.id)",
        ""
      ]
    });
    this._objects.set(core.id, core);
    let spaceDocHandle;
    const placement = opts?.placeIn ?? "linked-doc";
    switch (placement) {
      case "linked-doc": {
        spaceDocHandle = this._automergeDocLoader.createDocumentForObject(core.id);
        spaceDocHandle.on("change", this._onDocumentUpdate);
        break;
      }
      // TODO(dmaretskyi): In the future we should forbid object placement in the root doc.
      case "root-doc": {
        spaceDocHandle = this._automergeDocLoader.getSpaceRootDocHandle();
        this._automergeDocLoader.onObjectBoundToDocument(spaceDocHandle, core.id);
        break;
      }
      default:
        throw new TypeError(`Unknown object placement: ${placement}`);
    }
    core.bind({
      db: this,
      docHandle: spaceDocHandle,
      path: [
        "objects",
        core.id
      ],
      assignFromLocalState: true
    });
  }
  removeCore(core) {
    invariant7(this._objects.has(core.id), void 0, {
      F: __dxlog_file10,
      L: 538,
      S: this,
      A: [
        "this._objects.has(core.id)",
        ""
      ]
    });
    core.setDeleted(true);
  }
  /**
  * Removes an object link from the space root document.
  */
  unlinkObjects(objectIds) {
    const root = this._automergeDocLoader.getSpaceRootDocHandle();
    for (const objectId of objectIds) {
      if (!root.doc().links?.[objectId]) {
        throw new Error(`Link not found: ${objectId}`);
      }
    }
    root.change((doc) => {
      for (const objectId of objectIds) {
        delete doc.links[objectId];
      }
    });
  }
  /**
  * Removes all objects that are marked as deleted.
  */
  async unlinkDeletedObjects({ batchSize = 10 } = {}) {
    const idChunks = chunkArray(this.getAllObjectIds(), batchSize);
    for (const ids of idChunks) {
      const objects = await this.batchLoadObjectCores(ids, {
        returnDeleted: true
      });
      const toUnlink = objects.filter((o) => o?.isDeleted()).map((o) => o.id);
      this.unlinkObjects(toUnlink);
    }
  }
  /**
  * Resets the object to the new state.
  * Intended way to change the type of the object (for schema migrations).
  * Any concurrent changes made by other peers will be overwritten.
  */
  async atomicReplaceObject(id, params) {
    const { data, type } = params;
    const core = await this.loadObjectCoreById(id);
    invariant7(core, void 0, {
      F: __dxlog_file10,
      L: 580,
      S: this,
      A: [
        "core",
        ""
      ]
    });
    const mappedData = deepMapValues2(data, (value, recurse) => {
      if (Ref.isRef(value)) {
        return {
          "/": value.dxn.toString()
        };
      }
      return recurse(value);
    });
    delete mappedData.id;
    invariant7(mappedData["@type"] === void 0, void 0, {
      F: __dxlog_file10,
      L: 589,
      S: this,
      A: [
        "mappedData['@type'] === undefined",
        ""
      ]
    });
    invariant7(mappedData["@meta"] === void 0, void 0, {
      F: __dxlog_file10,
      L: 590,
      S: this,
      A: [
        "mappedData['@meta'] === undefined",
        ""
      ]
    });
    const existingStruct = core.getDecoded([]);
    const newStruct = {
      ...existingStruct,
      data: mappedData
    };
    if (type !== void 0) {
      newStruct.system.type = encodeReference2(Reference2.fromDXN(type));
    }
    core.setDecoded([], newStruct);
  }
  async flush({ disk = true, indexes = false, updates = false } = {}) {
    log9("flush", {
      disk,
      indexes,
      updates
    }, {
      F: __dxlog_file10,
      L: 606,
      S: this,
      C: (f, a) => f(...a)
    });
    if (disk) {
      await this._repoProxy.flush();
      await this._dataService.flush({
        documentIds: this._automergeDocLoader.getAllHandles().map((handle) => handle.documentId)
      }, {
        timeout: RPC_TIMEOUT2
      });
    }
    if (indexes) {
      await this._dataService.updateIndexes(void 0, {
        timeout: 0
      });
    }
    if (updates) {
      await this._updateScheduler.runBlocking();
    }
  }
  /**
  * Returns document heads for all documents in the space.
  */
  async getDocumentHeads() {
    const root = this._automergeDocLoader.getSpaceRootDocHandle();
    const doc = root.doc();
    if (!doc) {
      return {
        heads: {}
      };
    }
    const headsStates = await this._dataService.getDocumentHeads({
      documentIds: Object.values(doc.links ?? {}).map((link) => interpretAsDocumentId3(link.toString()))
    }, {
      timeout: RPC_TIMEOUT2
    });
    const heads = {};
    for (const state of headsStates.heads.entries ?? []) {
      heads[state.documentId] = state.heads ?? [];
    }
    heads[root.documentId] = getHeads(doc);
    return {
      heads
    };
  }
  /**
  * Ensures that document heads have been replicated on the ECHO host.
  * Waits for the changes to be flushed to disk.
  * Does not ensure that this data has been propagated to the client.
  *
  * Note:
  *   For queries to return up-to-date results, the client must call `this.updateIndexes()`.
  *   This is also why flushing to disk is important.
  */
  // TODO(dmaretskyi): Find a way to ensure client propagation.
  async waitUntilHeadsReplicated(heads) {
    await this._dataService.waitUntilHeadsReplicated({
      heads: {
        entries: Object.entries(heads.heads).map(([documentId, heads2]) => ({
          documentId,
          heads: heads2
        }))
      }
    }, {
      timeout: 0
    });
  }
  /**
  * Returns document heads for all documents in the space.
  */
  async reIndexHeads() {
    const root = this._automergeDocLoader.getSpaceRootDocHandle();
    const doc = root.doc();
    invariant7(doc, void 0, {
      F: __dxlog_file10,
      L: 680,
      S: this,
      A: [
        "doc",
        ""
      ]
    });
    await this._dataService.reIndexHeads({
      documentIds: [
        root.documentId,
        ...Object.values(doc.links ?? {}).map((link) => interpretAsDocumentId3(link))
      ]
    }, {
      timeout: 0
    });
  }
  /**
  * @deprecated Use `flush({ indexes: true })`.
  */
  async updateIndexes() {
    await this._dataService.updateIndexes(void 0, {
      timeout: 0
    });
  }
  async getSyncState() {
    const value = await Stream2.first(this._dataService.subscribeSpaceSyncState({
      spaceId: this.spaceId
    }, {
      timeout: RPC_TIMEOUT2
    }));
    return value ?? raise(new Error("Failed to get sync state"));
  }
  subscribeToSyncState(ctx, callback) {
    const stream = this._dataService.subscribeSpaceSyncState({
      spaceId: this.spaceId
    }, {
      timeout: RPC_TIMEOUT2
    });
    stream.subscribe((data) => {
      void runInContextAsync(ctx, () => callback(data));
    }, (err) => {
      if (err) {
        ctx.raise(err);
      }
    });
    ctx.onDispose(() => stream.close());
    return () => stream.close();
  }
  getLoadedDocumentHandles() {
    return Object.values(this._repoProxy.handles);
  }
  async _handleSpaceRootDocumentChange(spaceRootDocHandle, objectsToLoad) {
    const spaceRootDoc = spaceRootDocHandle.doc();
    const inlinedObjectIds = new Set(Object.keys(spaceRootDoc.objects ?? {}));
    const linkedObjectIds = new Map(Object.entries(spaceRootDoc.links ?? {}).map(([k, v]) => [
      k,
      v.toString()
    ]));
    const objectsToRebind = /* @__PURE__ */ new Map();
    objectsToRebind.set(spaceRootDocHandle.url, {
      handle: spaceRootDocHandle,
      objectIds: []
    });
    const objectsToRemove = [];
    const objectsToCreate = [
      ...inlinedObjectIds.values()
    ].filter((oid) => !this._objects.has(oid));
    for (const object of this._objects.values()) {
      if (inlinedObjectIds.has(object.id)) {
        if (spaceRootDocHandle.url === object.docHandle?.url) {
          continue;
        }
        objectsToRebind.get(spaceRootDocHandle.url).objectIds.push(object.id);
      } else if (linkedObjectIds.has(object.id)) {
        const newObjectDocUrl = linkedObjectIds.get(object.id);
        if (newObjectDocUrl === object.docHandle?.url) {
          continue;
        }
        const existing = objectsToRebind.get(newObjectDocUrl.toString());
        if (existing != null) {
          existing.objectIds.push(object.id);
          continue;
        }
        const newDocHandle = this._repoProxy.find(newObjectDocUrl);
        await newDocHandle.whenReady();
        newDocHandle.doc();
        objectsToRebind.set(newObjectDocUrl.toString(), {
          handle: newDocHandle,
          objectIds: [
            object.id
          ]
        });
      } else {
        objectsToRemove.push(object.id);
      }
    }
    objectsToRemove.forEach((oid) => this._objects.delete(oid));
    this._createInlineObjects(spaceRootDocHandle, objectsToCreate);
    for (const { handle, objectIds } of objectsToRebind.values()) {
      this._rebindObjects(handle, objectIds);
    }
    for (const objectId of objectsToLoad) {
      if (!this._objects.has(objectId)) {
        this._automergeDocLoader.loadObjectDocument(objectId);
      }
    }
    this._automergeDocLoader.onObjectLinksUpdated(spaceRootDoc.links);
    this.rootChanged.emit();
  }
  _emitObjectUpdateEvent(itemsUpdated) {
    if (itemsUpdated.length === 0) {
      return;
    }
    compositeRuntime2.batch(() => {
      for (const id of itemsUpdated) {
        const objCore = this._objects.get(id);
        if (objCore) {
          objCore.notifyUpdate();
        }
      }
    });
  }
  _processDocumentUpdate(event) {
    const { inlineChangedObjects, linkedDocuments } = getInlineAndLinkChanges(event);
    const createdObjectIds = [];
    const objectsToRebind = [];
    for (const updatedObject of inlineChangedObjects) {
      const objectCore = this._objects.get(updatedObject);
      if (!objectCore) {
        createdObjectIds.push(updatedObject);
      } else if (objectCore?.docHandle && objectCore.docHandle.url !== event.handle.url) {
        log9.verbose("object bound to incorrect document, going to rebind", {
          updatedObject,
          documentUrl: objectCore.docHandle.url,
          actualUrl: event.handle.url
        }, {
          F: __dxlog_file10,
          L: 816,
          S: this,
          C: (f, a) => f(...a)
        });
        objectsToRebind.push(updatedObject);
      }
    }
    return {
      updatedObjectIds: inlineChangedObjects,
      objectsToRebind,
      createdObjectIds,
      linkedDocuments
    };
  }
  _unsubscribeFromHandles() {
    for (const docHandle of Object.values(this._repoProxy.handles)) {
      docHandle.off("change", this._onDocumentUpdate);
    }
  }
  _onObjectDocumentLoaded({ handle, objectId }) {
    handle.on("change", this._onDocumentUpdate);
    const core = this._createObjectInDocument(handle, objectId);
    if (this._areDepsSatisfied(core)) {
      this._scheduleThrottledUpdate([
        objectId
      ]);
    } else {
      for (const dep of core.getStrongDependencies()) {
        if (dep.isLocalObjectId()) {
          const id = dep.parts[1];
          this._automergeDocLoader.loadObjectDocument(id);
        }
      }
    }
    for (const dep of this._strongDepsIndex.get(objectId) ?? []) {
      const core2 = this._objects.get(dep);
      if (core2 && this._areDepsSatisfied(core2)) {
        this._scheduleThrottledUpdate([
          core2.id
        ]);
      }
    }
  }
  /**
  * Loads all objects on open and handles objects that are being created not by this client.
  */
  _createInlineObjects(docHandle, objectIds) {
    for (const id of objectIds) {
      invariant7(!this._objects.has(id), void 0, {
        F: __dxlog_file10,
        L: 865,
        S: this,
        A: [
          "!this._objects.has(id)",
          ""
        ]
      });
      this._createObjectInDocument(docHandle, id);
    }
  }
  _createObjectInDocument(docHandle, objectId) {
    invariant7(!this._objects.get(objectId), void 0, {
      F: __dxlog_file10,
      L: 871,
      S: this,
      A: [
        "!this._objects.get(objectId)",
        ""
      ]
    });
    const core = new ObjectCore();
    core.id = objectId;
    this._objects.set(core.id, core);
    this._automergeDocLoader.onObjectBoundToDocument(docHandle, objectId);
    core.bind({
      db: this,
      docHandle,
      path: [
        "objects",
        core.id
      ],
      assignFromLocalState: false
    });
    const deps = core.getStrongDependencies();
    for (const dxn of deps) {
      if (!dxn.isLocalObjectId()) {
        continue;
      }
      const depObjectId = dxn.parts[1];
      if (this._objects.has(depObjectId)) {
        continue;
      }
      defaultMap(this._strongDepsIndex, depObjectId, []).push(core.id);
    }
    return core;
  }
  _areDepsSatisfied(core, seen) {
    seen ??= /* @__PURE__ */ new Set();
    const deps = core.getStrongDependencies();
    seen.add(core.id);
    return deps.every((dep) => {
      if (!dep.isLocalObjectId()) {
        return true;
      }
      const depObjectId = dep.parts[1];
      const depCore = this._objects.get(depObjectId);
      if (!depCore) {
        return false;
      }
      if (seen.has(depCore.id)) {
        return true;
      }
      return this._areDepsSatisfied(depCore, seen);
    });
  }
  _rebindObjects(docHandle, objectIds) {
    for (const objectId of objectIds) {
      const objectCore = this._objects.get(objectId);
      invariant7(objectCore, void 0, {
        F: __dxlog_file10,
        L: 923,
        S: this,
        A: [
          "objectCore",
          ""
        ]
      });
      objectCore.bind({
        db: this,
        docHandle,
        path: objectCore.mountPath,
        assignFromLocalState: false
      });
      this._automergeDocLoader.onObjectBoundToDocument(docHandle, objectId);
    }
  }
  _emitDbUpdateEvents() {
    const fullUpdateIds = [
      ...this._objectsForNextUpdate
    ];
    const allDbUpdates = /* @__PURE__ */ new Set([
      ...this._objectsForNextUpdate,
      ...this._objectsForNextDbUpdate
    ]);
    this._objectsForNextUpdate.clear();
    this._objectsForNextDbUpdate.clear();
    compositeRuntime2.batch(() => {
      if (allDbUpdates.size > 0) {
        this._updateEvent.emit({
          spaceId: this.spaceId,
          itemsUpdated: [
            ...allDbUpdates
          ].map((id) => ({
            id
          }))
        });
      }
      this._emitObjectUpdateEvent(fullUpdateIds);
    });
  }
  // TODO(dmaretskyi): Pass all remote updates through this.
  // Scheduled db and signal update events.
  _scheduleThrottledUpdate(objectId) {
    for (const id of objectId) {
      this._objectsForNextUpdate.add(id);
    }
    if (DISABLE_THROTTLING) {
      this._updateScheduler.forceTrigger();
    } else {
      this._updateScheduler.trigger();
    }
  }
  // Scheduled db update event only.
  _scheduleThrottledDbUpdate(objectId) {
    for (const id of objectId) {
      this._objectsForNextDbUpdate.add(id);
    }
    if (DISABLE_THROTTLING) {
      this._updateScheduler.forceTrigger();
    } else {
      this._updateScheduler.trigger();
    }
  }
};
_ts_decorate3([
  synchronized
], CoreDatabase.prototype, "open", null);
_ts_decorate3([
  synchronized
], CoreDatabase.prototype, "close", null);
_ts_decorate3([
  synchronized
], CoreDatabase.prototype, "updateSpaceState", null);
_ts_decorate3([
  trace4.span({
    showInBrowserTimeline: true
  })
], CoreDatabase.prototype, "_emitDbUpdateEvents", null);
CoreDatabase = _ts_decorate3([
  trace4.resource()
], CoreDatabase);
var RPC_TIMEOUT2 = 2e4;
var DISABLE_THROTTLING = true;
var sanitizeTypename = (typename) => {
  if (typename.startsWith("dxn:")) {
    return DXN3.parse(typename);
  } else {
    if (typename.includes(":")) {
      throw new Error(`Invalid typename: ${typename}`);
    }
    return new DXN3(DXN3.kind.TYPE, [
      typename
    ]);
  }
};
var createCoreFromInsertData = (data) => {
  if ("id" in data) {
    throw new Error("Cannot insert object with id");
  }
  const { __typename, ...rest } = data;
  let type;
  if (__typename) {
    type = sanitizeTypename(__typename);
  }
  const fieldsMapped = deepMapValues2(rest, (value, recurse) => {
    if (isEncodedReference3(value)) {
      if (value["/"].startsWith("dxn:")) {
        return value;
      } else {
        return {
          "/": new DXN3(DXN3.kind.ECHO, [
            LOCAL_SPACE_TAG,
            value["/"]
          ]).toString()
        };
      }
    } else {
      return recurse(value);
    }
  });
  const core = new ObjectCore();
  core.initNewObject(fieldsMapped);
  if (type) {
    core.setType(Reference2.fromDXN(type));
  }
  return core;
};

// packages/core/echo/echo-db/src/echo-handler/echo-handler.ts
import { Schema } from "effect";
import { devtoolsFormatter, inspectCustom as inspectCustom3 } from "@dxos/debug";
import { DATA_NAMESPACE as DATA_NAMESPACE3, encodeReference as encodeReference3, PROPERTY_ID, Reference as Reference3 } from "@dxos/echo-protocol";
import { ATTR_META, ATTR_TYPE, defineHiddenProperty, DeletedId, EchoSchema, EntityKind as EntityKind2, EntityKindId, getRefSavedTarget, getTypeAnnotation, isInstanceOf, MetaId, ObjectMetaSchema, Ref as Ref2, RefImpl, RelationSourceId, RelationTargetId, SchemaId, SchemaMetaSymbol, SchemaValidator, setRefResolver, StoredSchema, TypeId, getEntityKind, getSchema, requireTypeReference, RelationTargetDXNId, RelationSourceDXNId, assertObjectModelShape } from "@dxos/echo-schema";
import { invariant as invariant8, assertArgument } from "@dxos/invariant";
import { DXN as DXN4 } from "@dxos/keys";
import { createProxy, getProxyHandler, getProxyTarget, isLiveObject as isLiveObject2, symbolIsProxy } from "@dxos/live-object";
import { getMeta, getProxySlot } from "@dxos/live-object";
import { log as log10 } from "@dxos/log";
import { deepMapValues as deepMapValues3, defaultMap as defaultMap2, getDeep as getDeep2, setDeep as setDeep3 } from "@dxos/util";

// packages/core/echo/echo-db/src/echo-handler/devtools-formatter.ts
var idStyle = {
  style: "color: #777"
};
var listStyle = {
  style: "list-style-type: none; padding: 0; margin: 0 0 0 12px; font-style: normal; position: relative"
};
var liStyle = {
  style: "min-height: 16px;"
};
var nestedObjectContainerStyle = {
  style: "margin: -2px 0 0; display: inline-flex"
};
var keyStyle = {
  style: "color: #881391"
};
var defaultValueKeyStyle = {
  style: "color: #777"
};
var alteredValueKeyStyle = {
  style: "color: #881391; font-weight: bolder"
};
var nullStyle = {
  style: "color: #777"
};
var defaultKeys = [
  "id",
  "@type",
  "@meta"
];
var getHeader = (tag, id, config) => {
  return [
    "span",
    {
      style: (config?.nested ? "padding: 2px 0 0;" : "") + "\n height: 18px;"
    },
    `${tag}`,
    [
      "span",
      idStyle,
      `#${id}`
    ]
  ];
};
var formatValue = (object, config) => {
  if (typeof object === "undefined") {
    return [
      "span",
      nullStyle,
      "undefined"
    ];
  } else if (object === "null") {
    return [
      "span",
      nullStyle,
      "null"
    ];
  } else {
    return [
      "span",
      nestedObjectContainerStyle,
      [
        "object",
        {
          object,
          config
        }
      ]
    ];
  }
};
var getBody = (objData) => {
  return [
    "ol",
    listStyle,
    ...Object.keys(objData).map((key) => [
      "li",
      liStyle,
      [
        "span",
        defaultKeys.includes(key) ? keyStyle : key.startsWith("[[") ? defaultValueKeyStyle : alteredValueKeyStyle,
        key
      ],
      [
        "span",
        {},
        ": "
      ],
      formatValue(objData[key], {
        nested: true
      })
    ])
  ];
};

// packages/core/echo/echo-db/src/echo-handler/echo-array.ts
import { compositeRuntime as compositeRuntime4 } from "@dxos/echo-signals/runtime";

// packages/core/echo/echo-db/src/echo-handler/echo-proxy-target.ts
import { inspectCustom as inspectCustom2 } from "@dxos/debug";
import { compositeRuntime as compositeRuntime3 } from "@dxos/echo-signals/runtime";
import { ComplexMap } from "@dxos/util";
var symbolPath = Symbol("path");
var symbolNamespace = Symbol("namespace");
var symbolHandler = Symbol("handler");
var symbolInternals = Symbol("internals");
var TargetKey = {
  /**
  * Constructor function forces the order of the fields.
  */
  new: (path, namespace, type) => ({
    path,
    namespace,
    type
  }),
  hash: (key) => JSON.stringify(key)
};
var _a;
_a = inspectCustom2;
var ObjectInternals = class {
  constructor(core, database) {
    /**
    * Signal for reactive updates to the object.
    */
    this.signal = compositeRuntime3.createSignal();
    /**
    * Caching targets based on key path.
    * Only used for records and arrays.
    */
    this.targetsMap = new ComplexMap((key) => JSON.stringify(key));
    /**
    * Until object is persisted in the database, the linked object references are stored in this cache.
    * Set only when the object is not bound to a database.
    */
    this.linkCache = /* @__PURE__ */ new Map();
    this.subscriptions = [];
    /**
    * Schema of the root object.
    * Only used if this is not bound to a database.
    */
    this.rootSchema = void 0;
    this[_a] = () => `ObjectInternals(${this.core.id}${this.database ? " bound" : ""})`;
    this.core = core;
    this.database = database;
  }
};

// packages/core/echo/echo-db/src/echo-handler/echo-array.ts
var _a2, _b, _c, _d, _e;
var EchoArray = class extends Array {
  constructor() {
    super(...arguments);
    // Will be initialize when the proxy is created.
    this[_d] = null;
    this[_c] = null;
    this[_b] = null;
    this[_a2] = null;
  }
  static get [(_e = Symbol.species, _d = symbolInternals, _c = symbolPath, _b = symbolNamespace, _a2 = symbolHandler, _e)]() {
    return Array;
  }
  static {
    const BATCHED_METHODS = [
      "push",
      "pop",
      "shift",
      "unshift",
      "splice",
      "sort",
      "reverse"
    ];
    for (const method of BATCHED_METHODS) {
      const handlerMethodName = `array${method.slice(0, 1).toUpperCase()}${method.slice(1)}`;
      const fn = function(...args) {
        let result;
        compositeRuntime4.batch(() => {
          const handler = this[symbolHandler];
          result = handler[handlerMethodName].apply(handler, [
            this,
            this[symbolPath],
            ...args
          ]);
        });
        return result;
      };
      Object.defineProperty(fn, "name", {
        value: method
      });
      Object.defineProperty(this.prototype, method, {
        enumerable: false,
        value: fn
      });
    }
  }
};

// packages/core/echo/echo-db/src/echo-handler/echo-handler.ts
var __dxlog_file11 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-db/src/echo-handler/echo-handler.ts";
var EchoReactiveHandler = class _EchoReactiveHandler {
  constructor() {
    this._proxyMap = /* @__PURE__ */ new WeakMap();
    // Will be bound to the proxy target.
    this._inspect = function(_, options, inspectFn) {
      const handler = this[symbolHandler];
      const typename = handler._getTypename(this);
      const isRelation2 = this[symbolInternals].core.getKind() === EntityKind2.Relation;
      const isTyped = !!this[symbolInternals].core.getType();
      const reified = handler._getReified(this);
      reified.id = this[symbolInternals].core.id;
      return `${isTyped ? "Typed" : ""}Echo${isRelation2 ? "Relation" : "Object"}${typename ? `(${typename})` : ""} ${inspectFn(reified, {
        ...options,
        compact: true,
        showHidden: false,
        customInspect: false
      })}`;
    };
  }
  static {
    this.instance = new _EchoReactiveHandler();
  }
  init(target) {
    invariant8(target[symbolInternals], void 0, {
      F: __dxlog_file11,
      L: 83,
      S: this,
      A: [
        "target[symbolInternals]",
        ""
      ]
    });
    invariant8(!target[symbolIsProxy], void 0, {
      F: __dxlog_file11,
      L: 84,
      S: this,
      A: [
        "!(target as any)[symbolIsProxy]",
        ""
      ]
    });
    invariant8(Array.isArray(target[symbolPath]), void 0, {
      F: __dxlog_file11,
      L: 85,
      S: this,
      A: [
        "Array.isArray(target[symbolPath])",
        ""
      ]
    });
    if (!Array.isArray(target)) {
      for (const key in target) {
        if (typeof key !== "symbol") {
          delete target[key];
        }
      }
    }
    defineHiddenProperty(target, symbolHandler, this);
    Object.defineProperty(target, inspectCustom3, {
      enumerable: false,
      configurable: true,
      value: this._inspect.bind(target)
    });
  }
  ownKeys(target) {
    target[symbolInternals].signal.notifyRead();
    const { value } = this._getDecodedValueAtPath(target);
    const keys = typeof value === "object" ? Reflect.ownKeys(value) : [];
    if (isRootDataObject(target)) {
      keys.push(PROPERTY_ID);
    }
    return keys;
  }
  getOwnPropertyDescriptor(target, p) {
    const { value } = this._getDecodedValueAtPath(target);
    if (isRootDataObject(target) && p === PROPERTY_ID) {
      return {
        enumerable: true,
        configurable: true,
        writable: false
      };
    }
    return typeof value === "object" ? Reflect.getOwnPropertyDescriptor(value, p) : void 0;
  }
  defineProperty(target, property, attributes) {
    return this.set(target, property, attributes.value, target);
  }
  has(target, p) {
    if (target instanceof EchoArray) {
      return this._arrayHas(target, p);
    }
    const { value } = this._getDecodedValueAtPath(target);
    return typeof value === "object" ? Reflect.has(value, p) : false;
  }
  get(target, prop, receiver) {
    invariant8(Array.isArray(target[symbolPath]), void 0, {
      F: __dxlog_file11,
      L: 139,
      S: this,
      A: [
        "Array.isArray(target[symbolPath])",
        ""
      ]
    });
    switch (prop) {
      case symbolInternals:
        return target[symbolInternals];
      case SchemaId:
        return this.getSchema(target);
    }
    if (isRootDataObject(target)) {
      switch (prop) {
        case "id": {
          return target[symbolInternals].core.id;
        }
        case EntityKindId: {
          return target[symbolInternals].core.getKind();
        }
        case RelationSourceDXNId: {
          return target[symbolInternals].core.getSource()?.toDXN();
        }
        case RelationTargetDXNId: {
          return target[symbolInternals].core.getTarget()?.toDXN();
        }
        case RelationSourceId: {
          return this._getRelationSource(target);
        }
        case RelationTargetId: {
          return this._getRelationTarget(target);
        }
        case TypeId:
          return this.getTypeReference(target)?.toDXN();
        case MetaId:
          return this.getMeta(target);
        case DeletedId:
          return this.isDeleted(target);
      }
    } else {
      switch (prop) {
        case EntityKindId:
        case RelationSourceDXNId:
        case RelationTargetDXNId:
        case RelationSourceId:
        case RelationTargetId:
        case TypeId:
        case MetaId:
        case DeletedId:
          return void 0;
      }
    }
    target[symbolInternals].signal.notifyRead();
    switch (prop) {
      case devtoolsFormatter:
        return this._getDevtoolsFormatter(target);
    }
    if (isRootDataObject(target)) {
      switch (prop) {
        case "toJSON":
          return () => this._toJSON(target);
        case PROPERTY_ID:
          return target[symbolInternals].core.id;
      }
    }
    if (typeof prop === "symbol") {
      return Reflect.get(target, prop);
    }
    if (target instanceof EchoArray) {
      return this._arrayGet(target, prop);
    }
    const decodedValueAtPath = this._getDecodedValueAtPath(target, prop);
    return this._wrapInProxyIfRequired(target, decodedValueAtPath);
  }
  // TODO(burdon): arg `receiver` not used.
  set(target, prop, value, receiver) {
    invariant8(Array.isArray(target[symbolPath]), void 0, {
      F: __dxlog_file11,
      L: 223,
      S: this,
      A: [
        "Array.isArray(target[symbolPath])",
        ""
      ]
    });
    invariant8(typeof prop === "string", void 0, {
      F: __dxlog_file11,
      L: 224,
      S: this,
      A: [
        "typeof prop === 'string'",
        ""
      ]
    });
    if (target instanceof EchoArray && prop === "length") {
      this._arraySetLength(target, target[symbolPath], value);
      return true;
    }
    const fullPath = [
      getNamespace(target),
      ...target[symbolPath],
      prop
    ];
    const validatedValue = this._validateValue(target, [
      ...target[symbolPath],
      prop
    ], value);
    if (validatedValue === void 0) {
      target[symbolInternals].core.delete(fullPath);
    } else {
      const withLinks = this._handleLinksAssignment(target, validatedValue);
      target[symbolInternals].core.setDecoded(fullPath, withLinks);
    }
    return true;
  }
  /**
  * @returns The typename without version for static schema or object id for dynamic schema.
  */
  _getTypename(target) {
    const schema = this.getSchema(target);
    if (schema && typeof schema === "object" && SchemaMetaSymbol in schema) {
      return schema[SchemaMetaSymbol].typename;
    }
    return this.getTypeReference(target)?.objectId;
  }
  _getRelationSource(target) {
    const sourceRef = target[symbolInternals].core.getSource();
    invariant8(sourceRef, void 0, {
      F: __dxlog_file11,
      L: 256,
      S: this,
      A: [
        "sourceRef",
        ""
      ]
    });
    const database = target[symbolInternals].database;
    if (database) {
      return database.graph.createRefResolver({
        context: {
          space: database.spaceId
        }
      }).resolveSync(sourceRef.toDXN(), false);
    } else {
      invariant8(target[symbolInternals].linkCache, void 0, {
        F: __dxlog_file11,
        L: 268,
        S: this,
        A: [
          "target[symbolInternals].linkCache",
          ""
        ]
      });
      return target[symbolInternals].linkCache.get(sourceRef.objectId);
    }
  }
  _getRelationTarget(target) {
    const targetRef = target[symbolInternals].core.getTarget();
    invariant8(targetRef, void 0, {
      F: __dxlog_file11,
      L: 275,
      S: this,
      A: [
        "targetRef",
        ""
      ]
    });
    const database = target[symbolInternals].database;
    if (database) {
      return database.graph.createRefResolver({
        context: {
          space: database.spaceId
        }
      }).resolveSync(targetRef.toDXN(), false);
    } else {
      invariant8(target[symbolInternals].linkCache, void 0, {
        F: __dxlog_file11,
        L: 286,
        S: this,
        A: [
          "target[symbolInternals].linkCache",
          ""
        ]
      });
      return target[symbolInternals].linkCache.get(targetRef.objectId);
    }
  }
  /**
  * Takes a decoded value from the document, and wraps it in a proxy if required.
  * We use it to wrap records and arrays to provide deep mutability.
  * Wrapped targets are cached in the `targetsMap` to ensure that the same proxy is returned for the same path.
  */
  _wrapInProxyIfRequired(target, decodedValueAtPath) {
    const { value: decoded, dataPath, namespace } = decodedValueAtPath;
    if (decoded == null) {
      return decoded;
    }
    if (decoded[symbolIsProxy]) {
      return this._handleStoredSchema(target, decoded);
    }
    if (decoded instanceof Reference3) {
      return this.lookupRef(target, decoded);
    }
    if (Array.isArray(decoded)) {
      const targetKey = TargetKey.new(dataPath, namespace, "array");
      const newTarget = defaultMap2(target[symbolInternals].targetsMap, targetKey, () => {
        const array = new EchoArray();
        array[symbolInternals] = target[symbolInternals];
        array[symbolPath] = dataPath;
        array[symbolNamespace] = namespace;
        array[symbolHandler] = this;
        return array;
      });
      return createProxy(newTarget, this);
    }
    if (typeof decoded === "object") {
      const targetKey = TargetKey.new(dataPath, namespace, "record");
      const newTarget = defaultMap2(target[symbolInternals].targetsMap, targetKey, () => ({
        [symbolInternals]: target[symbolInternals],
        [symbolPath]: dataPath,
        [symbolNamespace]: namespace
      }));
      return createProxy(newTarget, this);
    }
    return decoded;
  }
  _handleStoredSchema(target, object) {
    const database = target[symbolInternals].database;
    if (database && isInstanceOf(StoredSchema, object)) {
      return database.schemaRegistry._registerSchema(object);
    }
    return object;
  }
  _getDecodedValueAtPath(target, prop) {
    const dataPath = [
      ...target[symbolPath]
    ];
    if (prop != null) {
      dataPath.push(prop);
    }
    const fullPath = [
      getNamespace(target),
      ...dataPath
    ];
    const value = target[symbolInternals].core.getDecoded(fullPath);
    return {
      namespace: getNamespace(target),
      value,
      dataPath
    };
  }
  _arrayGet(target, prop) {
    invariant8(target instanceof EchoArray, void 0, {
      F: __dxlog_file11,
      L: 365,
      S: this,
      A: [
        "target instanceof EchoArray",
        ""
      ]
    });
    if (prop === "constructor") {
      return Array.prototype.constructor;
    }
    if (prop !== "length" && isNaN(parseInt(prop))) {
      return Reflect.get(target, prop);
    }
    const decodedValueAtPath = this._getDecodedValueAtPath(target, prop);
    return this._wrapInProxyIfRequired(target, decodedValueAtPath);
  }
  _arrayHas(target, prop) {
    invariant8(target instanceof EchoArray, void 0, {
      F: __dxlog_file11,
      L: 378,
      S: this,
      A: [
        "target instanceof EchoArray",
        ""
      ]
    });
    if (typeof prop === "string") {
      const parsedIndex = parseInt(prop);
      const { value: length } = this._getDecodedValueAtPath(target, "length");
      invariant8(typeof length === "number", void 0, {
        F: __dxlog_file11,
        L: 382,
        S: this,
        A: [
          "typeof length === 'number'",
          ""
        ]
      });
      if (!isNaN(parsedIndex)) {
        return parsedIndex < length;
      }
    }
    return Reflect.has(target, prop);
  }
  _validateValue(target, path, value) {
    invariant8(path.length > 0, void 0, {
      F: __dxlog_file11,
      L: 392,
      S: this,
      A: [
        "path.length > 0",
        ""
      ]
    });
    throwIfCustomClass(path[path.length - 1], value);
    const rootObjectSchema = this.getSchema(target);
    if (rootObjectSchema == null) {
      const typeReference = target[symbolInternals].core.getType();
      if (typeReference) {
        throw new Error(`Schema not found in schema registry: ${typeReference.toDXN().toString()}`);
      }
      return value;
    }
    const unwrappedValue = value instanceof EchoSchema ? value.storedSchema : value;
    const propertySchema = SchemaValidator.getPropertySchema(rootObjectSchema, path, (path2) => {
      return target[symbolInternals].core.getDecoded([
        getNamespace(target),
        ...path2
      ]);
    });
    if (propertySchema == null) {
      return unwrappedValue;
    }
    const _ = Schema.asserts(propertySchema)(unwrappedValue);
    return unwrappedValue;
  }
  _handleLinksAssignment(target, value) {
    return deepMapValues3(value, (value2, recurse) => {
      if (isEchoObjectField(value2)) {
        return recurse({
          ...value2
        });
      } else if (isLiveObject2(value2)) {
        throw new Error("Object references must be wrapped with `Ref.make`");
      } else if (Ref2.isRef(value2)) {
        const savedTarget = getRefSavedTarget(value2);
        if (savedTarget) {
          return this.createRef(target, savedTarget);
        } else {
          return Reference3.fromDXN(value2.dxn);
        }
      } else {
        return recurse(value2);
      }
    });
  }
  getSchema(target) {
    if (target[symbolNamespace] === META_NAMESPACE) {
      return ObjectMetaSchema;
    }
    if (!target[symbolInternals].database) {
      if (target[symbolInternals].rootSchema != null) {
        return target[symbolInternals].rootSchema;
      }
      return void 0;
    }
    const typeReference = target[symbolInternals].core.getType();
    if (typeReference == null) {
      return void 0;
    }
    const staticSchema = target[symbolInternals].database.graph.schemaRegistry.getSchemaByDXN(typeReference.toDXN());
    if (staticSchema != null) {
      return staticSchema;
    }
    if (typeReference.protocol === "protobuf") {
      return void 0;
    }
    return target[symbolInternals].database.schemaRegistry.query({
      id: typeReference.toDXN().toString()
    }).runSync()[0];
  }
  getTypeReference(target) {
    return target[symbolNamespace] === DATA_NAMESPACE3 ? target[symbolInternals].core.getType() : void 0;
  }
  isDeleted(target) {
    return target[symbolInternals].core.isDeleted();
  }
  deleteProperty(target, property) {
    if (target instanceof EchoArray) {
      log10.warn("Deleting properties from EchoArray is not supported. Use `EchoArray.splice` instead.", void 0, {
        F: __dxlog_file11,
        L: 491,
        S: this,
        C: (f, a) => f(...a)
      });
      return false;
    } else if (isRootDataObject(target) && property === PROPERTY_ID) {
      return false;
    } else if (typeof property === "symbol") {
      return false;
    } else if (target instanceof EchoArray && isNaN(parseInt(property))) {
      return false;
    } else if (typeof property === "string") {
      const fullPath = [
        getNamespace(target),
        ...target[symbolPath],
        property
      ];
      target[symbolInternals].core.delete(fullPath);
      return true;
    }
    return false;
  }
  arrayPush(target, path, ...items) {
    const validatedItems = this._validateForArray(target, path, items, target.length);
    const encodedItems = this._encodeForArray(target, validatedItems);
    return target[symbolInternals].core.arrayPush([
      getNamespace(target),
      ...path
    ], encodedItems);
  }
  arrayPop(target, path) {
    const fullPath = this._getPropertyMountPath(target, path);
    let returnValue;
    target[symbolInternals].core.change((doc) => {
      const array = getDeep2(doc, fullPath);
      invariant8(Array.isArray(array), void 0, {
        F: __dxlog_file11,
        L: 520,
        S: this,
        A: [
          "Array.isArray(array)",
          ""
        ]
      });
      returnValue = array.pop();
    });
    return returnValue;
  }
  arrayShift(target, path) {
    const fullPath = this._getPropertyMountPath(target, path);
    let returnValue;
    target[symbolInternals].core.change((doc) => {
      const array = getDeep2(doc, fullPath);
      invariant8(Array.isArray(array), void 0, {
        F: __dxlog_file11,
        L: 533,
        S: this,
        A: [
          "Array.isArray(array)",
          ""
        ]
      });
      returnValue = array.shift();
    });
    return returnValue;
  }
  arrayUnshift(target, path, ...items) {
    const validatedItems = this._validateForArray(target, path, items, 0);
    const fullPath = this._getPropertyMountPath(target, path);
    const encodedItems = this._encodeForArray(target, validatedItems);
    let newLength = -1;
    target[symbolInternals].core.change((doc) => {
      const array = getDeep2(doc, fullPath);
      invariant8(Array.isArray(array), void 0, {
        F: __dxlog_file11,
        L: 549,
        S: this,
        A: [
          "Array.isArray(array)",
          ""
        ]
      });
      newLength = array.unshift(...encodedItems);
    });
    invariant8(newLength !== -1, void 0, {
      F: __dxlog_file11,
      L: 552,
      S: this,
      A: [
        "newLength !== -1",
        ""
      ]
    });
    return newLength;
  }
  arraySplice(target, path, start, deleteCount, ...items) {
    const validatedItems = this._validateForArray(target, path, items, start);
    const fullPath = this._getPropertyMountPath(target, path);
    const encodedItems = this._encodeForArray(target, validatedItems);
    let deletedElements;
    target[symbolInternals].core.change((doc) => {
      const array = getDeep2(doc, fullPath);
      invariant8(Array.isArray(array), void 0, {
        F: __dxlog_file11,
        L: 566,
        S: this,
        A: [
          "Array.isArray(array)",
          ""
        ]
      });
      if (deleteCount != null) {
        deletedElements = array.splice(start, deleteCount, ...encodedItems);
      } else {
        deletedElements = array.splice(start);
      }
    });
    invariant8(deletedElements, void 0, {
      F: __dxlog_file11,
      L: 574,
      S: this,
      A: [
        "deletedElements",
        ""
      ]
    });
    return deletedElements;
  }
  arraySort(target, path, compareFn) {
    const fullPath = this._getPropertyMountPath(target, path);
    target[symbolInternals].core.change((doc) => {
      const array = getDeep2(doc, fullPath);
      invariant8(Array.isArray(array), void 0, {
        F: __dxlog_file11,
        L: 583,
        S: this,
        A: [
          "Array.isArray(array)",
          ""
        ]
      });
      const sortedArray = [
        ...array
      ].sort(compareFn);
      setDeep3(doc, fullPath, sortedArray);
    });
    return target;
  }
  arrayReverse(target, path) {
    const fullPath = this._getPropertyMountPath(target, path);
    target[symbolInternals].core.change((doc) => {
      const array = getDeep2(doc, fullPath);
      invariant8(Array.isArray(array), void 0, {
        F: __dxlog_file11,
        L: 596,
        S: this,
        A: [
          "Array.isArray(array)",
          ""
        ]
      });
      const reversedArray = [
        ...array
      ].reverse();
      setDeep3(doc, fullPath, reversedArray);
    });
    return target;
  }
  getMeta(target) {
    const metaTarget = {
      [symbolInternals]: target[symbolInternals],
      [symbolPath]: [],
      [symbolNamespace]: META_NAMESPACE
    };
    return createProxy(metaTarget, this);
  }
  setDatabase(target, database) {
    target[symbolInternals].database = database;
  }
  /**
  * Store referenced object.
  * Used when `set` and other mutating methods are called with a proxy.
  * @param target - self
  * @param proxy - the proxy that was passed to the method
  */
  createRef(target, proxy) {
    let otherEchoObj = proxy instanceof EchoSchema ? proxy.storedSchema : proxy;
    otherEchoObj = !isEchoObject(otherEchoObj) ? createObject(otherEchoObj) : otherEchoObj;
    const otherObjId = otherEchoObj.id;
    invariant8(typeof otherObjId === "string" && otherObjId.length > 0, void 0, {
      F: __dxlog_file11,
      L: 629,
      S: this,
      A: [
        "typeof otherObjId === 'string' && otherObjId.length > 0",
        ""
      ]
    });
    const database = target[symbolInternals].database;
    if (!database) {
      invariant8(target[symbolInternals].linkCache, void 0, {
        F: __dxlog_file11,
        L: 634,
        S: this,
        A: [
          "target[symbolInternals].linkCache",
          ""
        ]
      });
      invariant8(otherObjId != null, void 0, {
        F: __dxlog_file11,
        L: 638,
        S: this,
        A: [
          "otherObjId != null",
          ""
        ]
      });
      target[symbolInternals].linkCache.set(otherObjId, otherEchoObj);
      return Reference3.localObjectReference(otherObjId);
    }
    const foreignDatabase = getProxyTarget(otherEchoObj)[symbolInternals].database;
    if (!foreignDatabase) {
      database.add(otherEchoObj);
      return Reference3.localObjectReference(otherObjId);
    }
    if (foreignDatabase !== database) {
      return Reference3.fromDXN(new DXN4(DXN4.kind.ECHO, [
        foreignDatabase.spaceId,
        otherObjId
      ]));
    }
    return Reference3.localObjectReference(otherObjId);
  }
  /**
  * Lookup referenced object.
  */
  lookupRef(target, ref) {
    const database = target[symbolInternals].database;
    if (database) {
      const refImpl = new RefImpl(ref.toDXN());
      setRefResolver(refImpl, database.graph.createRefResolver({
        context: {
          space: database.spaceId
        },
        middleware: (obj) => this._handleStoredSchema(target, obj)
      }));
      return refImpl;
    } else {
      invariant8(target[symbolInternals].linkCache, void 0, {
        F: __dxlog_file11,
        L: 678,
        S: this,
        A: [
          "target[symbolInternals].linkCache",
          ""
        ]
      });
      return new RefImpl(ref.toDXN(), this._handleStoredSchema(target, target[symbolInternals].linkCache.get(ref.objectId)));
    }
  }
  /**
  *
  */
  saveRefs(target) {
    if (!target[symbolInternals].linkCache) {
      return;
    }
    if (target[symbolInternals].linkCache) {
      for (const obj of target[symbolInternals].linkCache.values()) {
        this.createRef(target, obj);
      }
      target[symbolInternals].linkCache = void 0;
    }
  }
  _arraySetLength(target, path, newLength) {
    if (newLength < 0) {
      throw new RangeError("Invalid array length");
    }
    const fullPath = this._getPropertyMountPath(target, path);
    target[symbolInternals].core.change((doc) => {
      const array = getDeep2(doc, fullPath);
      invariant8(Array.isArray(array), void 0, {
        F: __dxlog_file11,
        L: 711,
        S: this,
        A: [
          "Array.isArray(array)",
          ""
        ]
      });
      const trimmedArray = [
        ...array
      ];
      trimmedArray.length = newLength;
      setDeep3(doc, fullPath, trimmedArray);
    });
  }
  _validateForArray(target, path, items, start) {
    return items.map((item, index) => {
      return this._validateValue(target, [
        ...path,
        String(start + index)
      ], item);
    });
  }
  // TODO(dmaretskyi): Change to not rely on object-core doing linking.
  _encodeForArray(target, items) {
    const linksEncoded = this._handleLinksAssignment(target, items);
    return target[symbolInternals].core.encode(linksEncoded);
  }
  _getPropertyMountPath(target, path) {
    return [
      ...target[symbolInternals].core.mountPath,
      getNamespace(target),
      ...path
    ];
  }
  // TODO(dmaretskyi): Re-use existing json serializer
  _toJSON(target) {
    target[symbolInternals].signal.notifyRead();
    const typeRef = target[symbolInternals].core.getType();
    const reified = this._getReified(target);
    return {
      [ATTR_TYPE]: typeRef ? encodeReference3(typeRef) : void 0,
      ...target[symbolInternals].core.isDeleted() ? {
        "@deleted": true
      } : {},
      [ATTR_META]: {
        ...this.getMeta(target)
      },
      // TODO(dmaretskyi): Change to just `id`.
      "@id": target[symbolInternals].core.id,
      ...deepMapValues3(reified, (value, recurse) => {
        if (value instanceof Reference3) {
          return encodeReference3(value);
        }
        return recurse(value);
      })
    };
  }
  _getReified(target) {
    const dataPath = [
      ...target[symbolPath]
    ];
    const fullPath = [
      getNamespace(target),
      ...dataPath
    ];
    return target[symbolInternals].core.getDecoded(fullPath);
  }
  _getDevtoolsFormatter(target) {
    const schema = this.getSchema(target);
    const typename = schema ? getTypeAnnotation(schema)?.typename : void 0;
    return {
      header: (config) => getHeader(typename ?? "EchoObject", target[symbolInternals].core.id, config),
      hasBody: () => true,
      body: () => {
        let data = deepMapValues3(this._getReified(target), (value, recurse) => {
          if (value instanceof Reference3) {
            return this.lookupRef(target, value);
          }
          return recurse(value);
        });
        if (isRootDataObject(target)) {
          const metaTarget = {
            [symbolInternals]: target[symbolInternals],
            [symbolPath]: [],
            [symbolNamespace]: META_NAMESPACE
          };
          const metaReified = this._getReified(metaTarget);
          data = {
            id: target[symbolInternals].core.id,
            "@type": this.getTypeReference(target)?.objectId,
            "@meta": metaReified,
            ...data,
            "[[Schema]]": this.getSchema(target),
            "[[Core]]": target[symbolInternals].core
          };
        }
        return getBody(data);
      }
    };
  }
};
var throwIfCustomClass = (prop, value) => {
  if (value == null || Array.isArray(value) || value instanceof EchoSchema || Ref2.isRef(value)) {
    return;
  }
  const proto = Object.getPrototypeOf(value);
  if (typeof value === "object" && proto !== Object.prototype) {
    throw new Error(`class instances are not supported: setting ${proto} on ${String(prop)}`);
  }
};
var getObjectCore = (obj) => {
  if (!obj[symbolInternals]) {
    throw new Error("object is not an EchoObject");
  }
  const { core } = obj[symbolInternals];
  return core;
};
var isRootDataObject = (target) => {
  const path = target[symbolPath];
  if (!Array.isArray(path) || path.length > 0) {
    return false;
  }
  return getNamespace(target) === DATA_NAMESPACE3;
};
var isEchoObjectField = (value) => {
  return isLiveObject2(value) && getProxyHandler(value) instanceof EchoReactiveHandler && !isRootDataObject(getProxyTarget(value));
};
var getNamespace = (target) => target[symbolNamespace];
var isEchoObject = (value) => {
  if (!isLiveObject2(value)) {
    return false;
  }
  const handler = getProxyHandler(value);
  if (!(handler instanceof EchoReactiveHandler)) {
    return false;
  }
  return isRootDataObject(getProxyTarget(value));
};
var isTypedObjectProxy = (value) => {
  if (isEchoObject(value)) {
    return true;
  }
  const schema = getSchema(value);
  if (schema != null) {
    return !!getTypeAnnotation(schema);
  }
  return false;
};
var createObject = (obj) => {
  assertArgument(!isEchoObject(obj), "Object is already an ECHO object");
  const schema = getSchema(obj);
  if (schema != null) {
    validateSchema(schema);
  }
  validateInitialProps(obj);
  const core = new ObjectCore();
  if (isLiveObject2(obj)) {
    const meta = getProxyTarget(getMeta(obj));
    const slot = getProxySlot(obj);
    slot.setHandler(EchoReactiveHandler.instance);
    const target = slot.target;
    target[symbolInternals] = new ObjectInternals(core);
    target[symbolInternals].rootSchema = schema;
    target[symbolPath] = [];
    target[symbolNamespace] = DATA_NAMESPACE3;
    slot.handler._proxyMap.set(target, obj);
    target[symbolInternals].subscriptions.push(core.updates.on(() => target[symbolInternals].signal.notifyWrite()));
    initCore(core, target);
    slot.handler.init(target);
    setSchemaPropertiesOnObjectCore(target[symbolInternals], schema);
    setRelationSourceAndTarget(target, core, schema);
    if (meta && meta.keys.length > 0) {
      target[symbolInternals].core.setMeta(meta);
    }
    return obj;
  } else {
    const target = {
      [symbolInternals]: new ObjectInternals(core),
      [symbolPath]: [],
      [symbolNamespace]: DATA_NAMESPACE3,
      ...obj
    };
    target[symbolInternals].rootSchema = schema;
    target[symbolInternals].subscriptions.push(core.updates.on(() => target[symbolInternals].signal.notifyWrite()));
    initCore(core, target);
    const proxy = createProxy(target, EchoReactiveHandler.instance);
    setSchemaPropertiesOnObjectCore(target[symbolInternals], schema);
    setRelationSourceAndTarget(target, core, schema);
    return proxy;
  }
};
var initCore = (core, target) => {
  if (PROPERTY_ID in target) {
    target[symbolInternals].core.id = target[PROPERTY_ID];
    delete target[PROPERTY_ID];
  }
  core.initNewObject(linkAllNestedProperties(target));
};
var initEchoReactiveObjectRootProxy = (core, database) => {
  const target = {
    [symbolInternals]: new ObjectInternals(core, database),
    [symbolPath]: [],
    [symbolNamespace]: DATA_NAMESPACE3
  };
  core.updates.on(() => target[symbolInternals].signal.notifyWrite());
  const obj = createProxy(target, EchoReactiveHandler.instance);
  assertObjectModelShape(obj);
  return obj;
};
var validateSchema = (schema) => {
  requireTypeReference(schema);
  const entityKind = getEntityKind(schema);
  invariant8(entityKind === "object" || entityKind === "relation", void 0, {
    F: __dxlog_file11,
    L: 1034,
    S: void 0,
    A: [
      "entityKind === 'object' || entityKind === 'relation'",
      ""
    ]
  });
  SchemaValidator.validateSchema(schema);
};
var setSchemaPropertiesOnObjectCore = (internals, schema) => {
  if (schema != null) {
    internals.core.setType(requireTypeReference(schema));
    const kind = getEntityKind(schema);
    invariant8(kind, void 0, {
      F: __dxlog_file11,
      L: 1046,
      S: void 0,
      A: [
        "kind",
        ""
      ]
    });
    internals.core.setKind(kind);
  }
};
var setRelationSourceAndTarget = (target, core, schema) => {
  const kind = schema && getEntityKind(schema);
  if (kind === EntityKind2.Relation) {
    const sourceRef = target[RelationSourceId];
    const targetRef = target[RelationTargetId];
    if (!sourceRef || !targetRef) {
      throw new TypeError("Relation source and target must be specified");
    }
    if (!isLiveObject2(sourceRef)) {
      throw new TypeError("source must be an ECHO object");
    }
    if (!isLiveObject2(targetRef)) {
      throw new TypeError("target must be an ECHO object");
    }
    core.setSource(EchoReactiveHandler.instance.createRef(target, sourceRef));
    core.setTarget(EchoReactiveHandler.instance.createRef(target, targetRef));
  }
};
var validateInitialProps = (target, seen = /* @__PURE__ */ new Set()) => {
  if (seen.has(target)) {
    return;
  }
  seen.add(target);
  for (const key in target) {
    const value = target[key];
    if (value === void 0) {
      delete target[key];
    } else if (typeof value === "object") {
      if (Ref2.isRef(value)) {
      } else if (value instanceof EchoSchema || isTypedObjectProxy(value)) {
        throw new Error("Object references must be wrapped with `Ref.make`");
      } else {
        throwIfCustomClass(key, value);
        validateInitialProps(target[key], seen);
      }
    }
  }
};
var linkAllNestedProperties = (target) => {
  return deepMapValues3(target, (value, recurse) => {
    if (Ref2.isRef(value)) {
      return refToEchoReference(target, value);
    }
    return recurse(value);
  });
};
var refToEchoReference = (target, ref) => {
  const savedTarget = getRefSavedTarget(ref);
  if (savedTarget) {
    return EchoReactiveHandler.instance.createRef(target, savedTarget);
  } else {
    return Reference3.fromDXN(ref.dxn);
  }
};

// packages/core/echo/echo-db/src/echo-handler/clone.ts
import { ObjectId as ObjectId2 } from "@dxos/echo-schema";
import { invariant as invariant9, assertArgument as assertArgument2 } from "@dxos/invariant";
var __dxlog_file12 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-db/src/echo-handler/clone.ts";
var requireAutomergeCore = (obj) => {
  const core = getObjectCore(obj);
  invariant9(core, "object is not an EchoObject", {
    F: __dxlog_file12,
    L: 27,
    S: void 0,
    A: [
      "core",
      "'object is not an EchoObject'"
    ]
  });
  return core;
};
var clone = (obj, { retainId = true, additional = [] } = {}) => {
  assertArgument2(isEchoObject(obj), "expect obj to be an EchoObject");
  assertArgument2(retainId === true || additional.length === 0, "retainId must be true when additional is not empty");
  const clone2 = cloneInner(obj, retainId ? obj.id : ObjectId2.random());
  const clones = [
    clone2
  ];
  for (const innerObj of additional) {
    if (innerObj) {
      clones.push(cloneInner(innerObj, retainId ? innerObj.id : ObjectId2.random()));
    }
  }
  for (const clone3 of clones) {
    if (!isEchoObject(clone3)) {
      continue;
    }
    for (const ref of clones) {
      if (ref === clone3) {
        continue;
      }
      clone3[symbolInternals].linkCache.set(ref.id, ref);
    }
  }
  return clone2;
};
var cloneInner = (obj, id) => {
  const core = requireAutomergeCore(obj);
  const coreClone = new ObjectCore();
  coreClone.initNewObject();
  coreClone.id = id;
  const proxy = initEchoReactiveObjectRootProxy(coreClone);
  const automergeSnapshot = getObjectDoc(core);
  coreClone.change((doc) => {
    for (const key of Object.keys(automergeSnapshot)) {
      doc[key] = automergeSnapshot[key];
    }
  });
  return proxy;
};
var getObjectDoc = (core) => {
  let value = core.doc ?? core.docHandle.doc();
  for (const key of core.mountPath) {
    value = value?.[key];
  }
  return value;
};

// packages/core/echo/echo-db/src/echo-handler/edit-history.ts
import { next as am } from "@automerge/automerge";
import { ATTR_META as ATTR_META2, ATTR_TYPE as ATTR_TYPE2 } from "@dxos/echo-schema";
import { assertArgument as assertArgument3 } from "@dxos/invariant";
var getEditHistory = (object) => {
  assertArgument3(isEchoObject(object), "expected ECHO object stored in the database");
  const objectCore = getObjectCore(object);
  const doc = objectCore.getDoc();
  const changes = am.getHistory(doc);
  return changes;
};
var checkoutVersion = (object, version) => {
  assertArgument3(isEchoObject(object), "expected ECHO object stored in the database");
  assertArgument3(Array.isArray(version), "expected automerge heads array");
  const objectCore = getObjectCore(object);
  const doc = objectCore.getDoc();
  const snapshot = am.view(doc, version);
  const versionCore = new ObjectCore();
  versionCore.id = objectCore.id;
  versionCore.doc = snapshot;
  versionCore.mountPath = objectCore.mountPath;
  const { id, __typename, __meta, ...data } = versionCore.toPlainObject();
  return {
    id,
    [ATTR_TYPE2]: __typename,
    [ATTR_META2]: __meta,
    ...data
  };
};

// packages/core/echo/echo-db/src/echo-handler/relations.ts
import { EntityKind as EntityKind3, EntityKindId as EntityKindId2, RelationSourceId as RelationSourceId2, RelationTargetId as RelationTargetId2 } from "@dxos/echo-schema";
import { invariant as invariant10 } from "@dxos/invariant";
var __dxlog_file13 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-db/src/echo-handler/relations.ts";
var isRelation = (object) => {
  const kind = object[EntityKindId2];
  if (kind === void 0) {
    throw new TypeError("Provided value is not a valid ECHO object or relation");
  }
  return kind === EntityKind3.Relation;
};
var getSource = (relation) => {
  invariant10(isRelation(relation), void 0, {
    F: __dxlog_file13,
    L: 41,
    S: void 0,
    A: [
      "isRelation(relation)",
      ""
    ]
  });
  const obj = relation[RelationSourceId2];
  invariant10(obj !== void 0, void 0, {
    F: __dxlog_file13,
    L: 43,
    S: void 0,
    A: [
      "obj !== undefined",
      ""
    ]
  });
  return obj;
};
var getTarget = (relation) => {
  invariant10(isRelation(relation), void 0, {
    F: __dxlog_file13,
    L: 53,
    S: void 0,
    A: [
      "isRelation(relation)",
      ""
    ]
  });
  const obj = relation[RelationTargetId2];
  invariant10(obj !== void 0, void 0, {
    F: __dxlog_file13,
    L: 55,
    S: void 0,
    A: [
      "obj !== undefined",
      ""
    ]
  });
  return obj;
};

// packages/core/echo/echo-db/src/echo-handler/util.ts
import { Reference as Reference4 } from "@dxos/echo-protocol";
import { invariant as invariant11 } from "@dxos/invariant";
import { getMeta as getMeta2, getProxyTarget as getProxyTarget2 } from "@dxos/live-object";
var __dxlog_file14 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-db/src/echo-handler/util.ts";
var getDatabaseFromObject = (obj) => {
  if (!isEchoObject(obj)) {
    return void 0;
  }
  const target = getProxyTarget2(obj);
  return target[symbolInternals].database;
};
var getReferenceWithSpaceKey = (obj) => {
  invariant11(obj, void 0, {
    F: __dxlog_file14,
    L: 28,
    S: void 0,
    A: [
      "obj",
      ""
    ]
  });
  const db = getDatabaseFromObject(obj);
  return db && Reference4.fromObjectIdAndSpaceKey(obj.id, db.spaceKey);
};
var findObjectWithForeignKey = (objects, foreignKey) => {
  return objects.find((result) => {
    return getMeta2(result).keys.find(({ source, id }) => source === foreignKey.source && id === foreignKey.id);
  });
};
var matchKeys = (a, b) => {
  return a.some((keyA) => b.some((keyB) => keyA.source === keyB.source && keyA.id === keyB.id));
};

// packages/core/echo/echo-db/src/echo-handler/doc-accessor.ts
import { assertArgument as assertArgument4 } from "@dxos/invariant";
import { isLiveObject as isLiveObject3 } from "@dxos/live-object";
var createDocAccessor = (obj, path) => {
  if (!Array.isArray(path)) {
    path = [
      path
    ];
  }
  assertArgument4(isLiveObject3(obj), "expect obj to be a LiveObject");
  assertArgument4(path === void 0 || isValidKeyPath(path), "expect path to be a valid key path");
  const core = getObjectCore(obj);
  const basePath = obj[symbolPath];
  const fullPath = basePath ? [
    ...basePath,
    ...path
  ] : path;
  return core.getDocAccessor(fullPath);
};

// packages/core/echo/echo-db/src/echo-handler/version.ts
import { next as Automerge } from "@automerge/automerge";
var ObjectVersion = Object.freeze({
  equals: (a, b) => {
    return JSON.stringify(a) === JSON.stringify(b);
  }
});
var getVersion = (obj) => {
  const docAccessor = createDocAccessor(obj, []);
  const doc = docAccessor.handle.doc();
  if (!doc) {
    return {
      heads: []
    };
  }
  return {
    heads: Automerge.getHeads(doc)
  };
};

// packages/core/echo/echo-db/src/echo-handler/subscription.ts
var createSubscription = (onUpdate) => {
  let subscribed = true;
  let firstUpdate = true;
  const subscriptions = /* @__PURE__ */ new Map();
  const handle = {
    update: (selection) => {
      const newSelected = new Set(selection.filter(isEchoObject));
      const removed = [
        ...handle.selected
      ].filter((item) => !newSelected.has(item));
      const added = [
        ...newSelected
      ].filter((item) => !handle.selected.has(item));
      handle.selected = newSelected;
      if (removed.length > 0 || added.length > 0 || firstUpdate) {
        firstUpdate = false;
        removed.forEach((obj) => {
          subscriptions.get(obj)?.();
          subscriptions.delete(obj);
        });
        added.forEach((obj) => {
          subscriptions.set(obj, getObjectCore(obj).updates.on(() => {
            onUpdate({
              added: [],
              removed: [],
              updated: [
                obj
              ]
            });
          }));
        });
        onUpdate({
          added,
          removed,
          updated: []
        });
      }
      return handle;
    },
    subscribed,
    selected: /* @__PURE__ */ new Set(),
    unsubscribe: () => {
      Array.from(subscriptions.values()).forEach((unsubscribe) => unsubscribe());
      subscriptions.clear();
      subscribed = false;
    }
  };
  return handle;
};

// packages/core/echo/echo-db/src/hypergraph.ts
import { Event as Event8 } from "@dxos/async";
import { Context as Context4 } from "@dxos/context";
import { raise as raise2, StackTrace as StackTrace2 } from "@dxos/debug";
import { Query as Query2, Filter as Filter2 } from "@dxos/echo";
import { ImmutableSchema, RuntimeSchemaRegistry } from "@dxos/echo-schema";
import { compositeRuntime as compositeRuntime5 } from "@dxos/echo-signals/runtime";
import { failedInvariant as failedInvariant2, invariant as invariant12 } from "@dxos/invariant";
import { DXN as DXN5 } from "@dxos/keys";
import { log as log11 } from "@dxos/log";
import { trace as trace5 } from "@dxos/tracing";
import { entry } from "@dxos/util";
var __dxlog_file15 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-db/src/hypergraph.ts";
var TRACE_REF_RESOLUTION = false;
var Hypergraph = class {
  constructor() {
    this._databases = /* @__PURE__ */ new Map();
    this._queueFactories = /* @__PURE__ */ new Map();
    // TODO(burdon): Comment/rename?
    this._owningObjects = /* @__PURE__ */ new Map();
    this._schemaRegistry = new RuntimeSchemaRegistry();
    this._updateEvent = new Event8();
    this._resolveEvents = /* @__PURE__ */ new Map();
    this._queryContexts = /* @__PURE__ */ new Set();
    this._querySourceProviders = [];
  }
  get schemaRegistry() {
    return this._schemaRegistry;
  }
  /**
  * @deprecated
  */
  // TODO(burdon): Use DXN.
  // TODO(burdon): Ensure static and dynamic schema do not have overlapping type names.
  async getSchemaByTypename(typename, db) {
    const schema = this.schemaRegistry.getSchema(typename);
    if (schema) {
      return new ImmutableSchema(schema);
    }
    return await db.schemaRegistry.query({
      typename
    }).firstOrUndefined();
  }
  /**
  * Register a database.
  * @param spaceId Space id.
  * @param spaceKey Space key.
  * @param database Database backend.
  * @param owningObject Database owner, usually a space.
  */
  // TODO(burdon): When is the owner not a space?
  _registerDatabase(spaceId, database, owningObject) {
    this._databases.set(spaceId, database);
    this._owningObjects.set(spaceId, owningObject);
    database.coreDatabase._updateEvent.on(this._onUpdate.bind(this));
    const map = this._resolveEvents.get(spaceId);
    if (map) {
      for (const [id, event] of map) {
        const obj = database.getObjectById(id);
        if (obj) {
          log11("resolve", {
            spaceId,
            objectId: id
          }, {
            F: __dxlog_file15,
            L: 130,
            S: this,
            C: (f, a) => f(...a)
          });
          event.emit(obj);
          map.delete(id);
        }
      }
    }
    for (const context of this._queryContexts.values()) {
      context.addQuerySource(new SpaceQuerySource(database));
    }
  }
  /**
  * @internal
  */
  _unregisterDatabase(spaceId) {
    this._databases.delete(spaceId);
  }
  /**
  * @internal
  */
  _registerQueueFactory(spaceId, factory) {
    this._queueFactories.set(spaceId, factory);
  }
  /**
  * @internal
  */
  _unregisterQueueFactory(spaceId) {
    this._queueFactories.delete(spaceId);
  }
  _getOwningObject(spaceId) {
    return this._owningObjects.get(spaceId);
  }
  static {
    this.prototype.query = this.prototype._query;
  }
  _query(query, options) {
    query = Filter2.is(query) ? Query2.select(query) : query;
    const resultFormat = options?.format ?? ResultFormat.Live;
    if (typeof resultFormat !== "string") {
      throw new TypeError("Invalid result format");
    }
    switch (resultFormat) {
      // TODO(dmaretskyi): Remove.
      case ResultFormat.Plain: {
        const spaceIds = options?.spaceIds;
        invariant12(spaceIds && spaceIds.length === 1, "Plain format requires a single space.", {
          F: __dxlog_file15,
          L: 187,
          S: this,
          A: [
            "spaceIds && spaceIds.length === 1",
            "'Plain format requires a single space.'"
          ]
        });
        return new QueryResult(this._createPlainObjectQueryContext(spaceIds[0]), normalizeQuery(query, options));
      }
      case ResultFormat.Live: {
        return new QueryResult(this._createLiveObjectQueryContext(), normalizeQuery(query, options));
      }
      // TODO(dmaretskyi): Remove.
      case ResultFormat.AutomergeDocAccessor: {
        throw new Error("Not implemented: ResultFormat.AutomergeDocAccessor");
      }
      default: {
        throw new TypeError(`Invalid result format: ${resultFormat}`);
      }
    }
  }
  /**
  * @param hostDb Host database for reference resolution.
  * @param middleware Called with the loaded object. The caller may change the object.
  * @returns Result of `onLoad`.
  */
  // TODO(dmaretskyi): Restructure API: Remove middleware, move `hostDb` into context option. Make accessible on Database objects.
  createRefResolver({ context = {}, middleware = (obj) => obj }) {
    return {
      // TODO(dmaretskyi): Respect `load` flag.
      resolveSync: (dxn, load, onLoad) => {
        if (dxn.kind === DXN5.kind.QUEUE && dxn.asQueueDXN()?.objectId === void 0) {
          const { spaceId, subspaceTag, queueId } = dxn.asQueueDXN();
          return this._resolveQueueSync(spaceId, subspaceTag, queueId);
        }
        if (dxn.kind !== DXN5.kind.ECHO) {
          return void 0;
        }
        const res = this._resolveSync(dxn, context, onLoad);
        if (res) {
          return middleware(res);
        } else {
          return void 0;
        }
      },
      resolve: async (dxn) => {
        const obj = await this._resolveAsync(dxn, context);
        if (obj) {
          return middleware(obj);
        } else {
          return void 0;
        }
      },
      resolveSchema: async (dxn) => {
        const beginTime = TRACE_REF_RESOLUTION ? performance.now() : 0;
        let status = "";
        try {
          switch (dxn.kind) {
            case DXN5.kind.TYPE: {
              const schema = this.schemaRegistry.getSchemaByDXN(dxn);
              status = schema != null ? "resolved" : "missing";
              return schema;
            }
            case DXN5.kind.ECHO: {
              status = "error";
              throw new Error("Not implemented: Resolving schema stored in the database");
            }
            default: {
              status = "unknown dxn";
              return void 0;
            }
          }
        } finally {
          if (TRACE_REF_RESOLUTION) {
            log11.info("resolveSchema", {
              dxn: dxn.toString(),
              status,
              time: performance.now() - beginTime
            }, {
              F: __dxlog_file15,
              L: 266,
              S: this,
              C: (f, a) => f(...a)
            });
          }
        }
      }
    };
  }
  /**
  * @param db
  * @param ref
  * @param onResolve will be weakly referenced.
  */
  _resolveSync(dxn, context, onResolve) {
    if (!dxn.asEchoDXN()) {
      throw new Error("Unsupported DXN kind");
    }
    const dxnData = dxn.asEchoDXN();
    const spaceId = dxnData.spaceId ?? context.space;
    const objectId = dxnData.echoId;
    if (spaceId === void 0) {
      throw new Error("Unable to determine space to resolve the reference from");
    }
    const db = this._databases.get(spaceId);
    if (db) {
      const obj = db.getObjectById(objectId);
      if (obj) {
        return obj;
      }
    }
    if (!OBJECT_DIAGNOSTICS.has(objectId)) {
      OBJECT_DIAGNOSTICS.set(objectId, {
        objectId,
        spaceId,
        loadReason: "reference access",
        loadedStack: new StackTrace2()
      });
    }
    log11("trap", {
      spaceId,
      objectId
    }, {
      F: __dxlog_file15,
      L: 314,
      S: this,
      C: (f, a) => f(...a)
    });
    if (onResolve) {
      entry(this._resolveEvents, spaceId).orInsert(/* @__PURE__ */ new Map()).deep(objectId).orInsert(new Event8()).value.on(new Context4(void 0, {
        F: __dxlog_file15,
        L: 320
      }), onResolve);
    }
  }
  async _resolveAsync(dxn, context) {
    const beginTime = TRACE_REF_RESOLUTION ? performance.now() : 0;
    let status = "";
    try {
      switch (dxn.kind) {
        case DXN5.kind.ECHO: {
          if (!dxn.isLocalObjectId()) {
            status = "error";
            throw new Error("Cross-space references are not supported");
          }
          const { echoId } = dxn.asEchoDXN() ?? failedInvariant2();
          if (context.queue) {
            const { subspaceTag, spaceId, queueId } = context.queue.asQueueDXN() ?? failedInvariant2();
            const obj2 = await this._resolveQueueObjectAsync(spaceId, subspaceTag, queueId, echoId);
            if (obj2) {
              status = "resolved";
              return obj2;
            }
          }
          if (!context.space) {
            status = "error";
            throw new Error("Resolving context-free references is not supported");
          }
          const obj = await this._resolveDatabaseObjectAsync(context.space, echoId);
          if (obj) {
            status = "resolved";
            return obj;
          }
          status = "missing";
          return void 0;
        }
        case DXN5.kind.QUEUE: {
          const { subspaceTag, spaceId, queueId, objectId } = dxn.asQueueDXN() ?? failedInvariant2();
          if (!objectId) {
            status = "error";
            return this._resolveQueueSync(spaceId, subspaceTag, queueId);
          }
          const obj = await this._resolveQueueObjectAsync(spaceId, subspaceTag, queueId, objectId);
          if (obj) {
            status = "resolved";
            return obj;
          }
          status = "missing queue";
          return void 0;
        }
        default: {
          status = "error";
          throw new Error(`Unsupported DXN kind: ${dxn.kind}`);
        }
      }
    } finally {
      if (TRACE_REF_RESOLUTION) {
        log11.info("resolve", {
          dxn: dxn.toString(),
          status,
          time: performance.now() - beginTime
        }, {
          F: __dxlog_file15,
          L: 382,
          S: this,
          C: (f, a) => f(...a)
        });
      }
    }
  }
  async _resolveDatabaseObjectAsync(spaceId, objectId) {
    const db = this._databases.get(spaceId);
    if (!db) {
      return void 0;
    }
    const { objects: [obj] } = await db.query(Filter2.ids(objectId)).run();
    return obj;
  }
  _resolveQueueSync(spaceId, subspaceTag, queueId) {
    const queueFactory = this._queueFactories.get(spaceId);
    if (!queueFactory) {
      return void 0;
    }
    return queueFactory.get(DXN5.fromQueue(subspaceTag, spaceId, queueId));
  }
  async _resolveQueueObjectAsync(spaceId, subspaceTag, queueId, objectId) {
    const queueFactory = this._queueFactories.get(spaceId);
    if (!queueFactory) {
      return void 0;
    }
    const queue = queueFactory.get(DXN5.fromQueue(subspaceTag, spaceId, queueId));
    if (!queue) {
      return void 0;
    }
    const [obj] = await queue.getObjectsById([
      objectId
    ]);
    return obj ?? void 0;
  }
  registerQuerySourceProvider(provider) {
    this._querySourceProviders.push(provider);
    for (const context of this._queryContexts.values()) {
      context.addQuerySource(provider.create());
    }
  }
  /**
  * Does not remove the provider from active query contexts.
  */
  unregisterQuerySourceProvider(provider) {
    const index = this._querySourceProviders.indexOf(provider);
    if (index !== -1) {
      this._querySourceProviders.splice(index, 1);
    }
  }
  _onUpdate(updateEvent) {
    const listenerMap = this._resolveEvents.get(updateEvent.spaceId);
    if (listenerMap) {
      compositeRuntime5.batch(() => {
        for (const item of updateEvent.itemsUpdated) {
          const listeners = listenerMap.get(item.id);
          if (!listeners) {
            continue;
          }
          const db = this._databases.get(updateEvent.spaceId);
          if (!db) {
            continue;
          }
          const obj = db.getObjectById(item.id);
          if (!obj) {
            continue;
          }
          log11("resolve", {
            spaceId: updateEvent.spaceId,
            objectId: obj.id
          }, {
            F: __dxlog_file15,
            L: 459,
            S: this,
            C: (f, a) => f(...a)
          });
          listeners.emit(obj);
          listenerMap.delete(item.id);
        }
      });
    }
    this._updateEvent.emit(updateEvent);
  }
  _createLiveObjectQueryContext() {
    const context = new GraphQueryContext({
      onStart: () => {
        this._queryContexts.add(context);
      },
      onStop: () => {
        this._queryContexts.delete(context);
      }
    });
    for (const database of this._databases.values()) {
      context.addQuerySource(new SpaceQuerySource(database));
    }
    for (const provider of this._querySourceProviders) {
      context.addQuerySource(provider.create());
    }
    return context;
  }
  _createPlainObjectQueryContext(spaceId) {
    const space = this._databases.get(spaceId) ?? raise2(new Error(`Space not found: ${spaceId}`));
    return space._coreDatabase._createQueryContext();
  }
};
var OBJECT_DIAGNOSTICS = /* @__PURE__ */ new Map();
trace5.diagnostic({
  id: "referenced-objects",
  name: "Referenced Objects (Client)",
  fetch: () => {
    return Array.from(OBJECT_DIAGNOSTICS.values()).map((object) => {
      return {
        objectId: object.objectId,
        spaceId: object.spaceId,
        loadReason: object.loadReason,
        creationStack: object.loadedStack?.getStack(),
        query: object.query
      };
    });
  }
});

// packages/core/echo/echo-db/src/proxy-db/echo-schema-registry.ts
import { Schema as Schema2 } from "effect";
import { Event as Event10 } from "@dxos/async";
import { Resource as Resource2 } from "@dxos/context";
import { TypeIdentifierAnnotationId, EchoSchema as EchoSchema2, getTypeIdentifierAnnotation, getTypeAnnotation as getTypeAnnotation2, TypeAnnotationId, StoredSchema as StoredSchema2, toJsonSchema, create, createJsonSchema } from "@dxos/echo-schema";
import { invariant as invariant13 } from "@dxos/invariant";
import { DXN as DXN6 } from "@dxos/keys";
import { log as log13 } from "@dxos/log";

// packages/core/echo/echo-db/src/proxy-db/schema-registry-prepared-query.ts
import { Event as Event9, Mutex } from "@dxos/async";
import { log as log12 } from "@dxos/log";
function _ts_add_disposable_resource3(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = function() {
      try {
        inner.call(this);
      } catch (e) {
        return Promise.reject(e);
      }
    };
    env.stack.push({
      value,
      dispose,
      async
    });
  } else if (async) {
    env.stack.push({
      async: true
    });
  }
  return value;
}
function _ts_dispose_resources3(env) {
  var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  };
  return (_ts_dispose_resources3 = function _ts_dispose_resources4(env2) {
    function fail(e) {
      env2.error = env2.hasError ? new _SuppressedError(e, env2.error, "An error was suppressed during disposal.") : e;
      env2.hasError = true;
    }
    var r, s = 0;
    function next() {
      while (r = env2.stack.pop()) {
        try {
          if (!r.async && s === 1) return s = 0, env2.stack.push(r), Promise.resolve().then(next);
          if (r.dispose) {
            var result = r.dispose.call(r.value);
            if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
              fail(e);
              return next();
            });
          } else s |= 1;
        } catch (e) {
          fail(e);
        }
      }
      if (s === 1) return env2.hasError ? Promise.reject(env2.error) : Promise.resolve();
      if (env2.hasError) throw env2.error;
    }
    return next();
  })(env);
}
var __dxlog_file16 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-db/src/proxy-db/schema-registry-prepared-query.ts";
var SchemaRegistryPreparedQueryImpl = class {
  constructor(_resolver) {
    this._resolver = _resolver;
    this._mutex = new Mutex();
    this._changes = new Event9();
    this._isReactiveQueryRunning = false;
    this._subscriberCount = 0;
    this._isFiring = false;
  }
  get results() {
    if (!this._isReactiveQueryRunning && !this._isFiring) {
      throw new Error("Query must have at least 1 subscriber for `.results` to be used. Use query.run() for single-use result retrieval.");
    }
    return this._resolver.getResultsSync();
  }
  run() {
    return this._resolver.getResults();
  }
  runSync() {
    return this._resolver.getResultsSync();
  }
  async first() {
    const results = await this._resolver.getResults();
    if (results.length === 0) {
      throw new Error("Query returned 0 entries");
    }
    return results[0];
  }
  async firstOrUndefined() {
    const results = await this._resolver.getResults();
    return results[0];
  }
  subscribe(cb, opts) {
    if (cb) {
      this._changes.on(cb);
    }
    this._subscriberCount++;
    this._onSubscriberCountChange();
    if (opts?.fire) {
      if (!cb) {
        throw new Error("Cannot fire without a callback");
      }
      try {
        this._isFiring = true;
        cb(this);
      } finally {
        this._isFiring = false;
      }
    }
    return () => {
      if (cb) {
        this._changes.off(cb);
      }
      this._subscriberCount--;
      this._onSubscriberCountChange();
    };
  }
  _onSubscriberCountChange() {
    if (this._subscriberCount === 0) {
      this._stop();
    } else if (this._subscriberCount > 0) {
      this._start();
    }
  }
  _start() {
    if (this._isReactiveQueryRunning) {
      return;
    }
    queueMicrotask(async () => {
      const env = {
        stack: [],
        error: void 0,
        hasError: false
      };
      try {
        const _guard = _ts_add_disposable_resource3(env, await this._mutex.acquire(), false);
        if (this._isReactiveQueryRunning) {
          return;
        }
        try {
          await this._resolver.start();
          this._isReactiveQueryRunning = true;
        } catch (err) {
          log12.catch(err, void 0, {
            F: __dxlog_file16,
            L: 120,
            S: this,
            C: (f, a) => f(...a)
          });
        }
      } catch (e) {
        env.error = e;
        env.hasError = true;
      } finally {
        _ts_dispose_resources3(env);
      }
    });
  }
  _stop() {
    if (!this._isReactiveQueryRunning) {
      return;
    }
    queueMicrotask(async () => {
      const env = {
        stack: [],
        error: void 0,
        hasError: false
      };
      try {
        const _guard = _ts_add_disposable_resource3(env, await this._mutex.acquire(), false);
        if (!this._isReactiveQueryRunning) {
          return;
        }
        try {
          await this._resolver.stop();
          this._isReactiveQueryRunning = false;
        } catch (err) {
          log12.catch(err, void 0, {
            F: __dxlog_file16,
            L: 139,
            S: this,
            C: (f, a) => f(...a)
          });
        }
      } catch (e) {
        env.error = e;
        env.hasError = true;
      } finally {
        _ts_dispose_resources3(env);
      }
    });
  }
};

// packages/core/echo/echo-db/src/proxy-db/echo-schema-registry.ts
var __dxlog_file17 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-db/src/proxy-db/echo-schema-registry.ts";
var EchoSchemaRegistry = class extends Resource2 {
  constructor(_db, { reactiveQuery = true, preloadSchemaOnOpen = true } = {}) {
    super(), this._db = _db, this._schemaById = /* @__PURE__ */ new Map(), this._schemaByType = /* @__PURE__ */ new Map(), this._unsubscribeById = /* @__PURE__ */ new Map(), this._schemaSubscriptionCallbacks = [];
    this._reactiveQuery = reactiveQuery;
    this._preloadSchemaOnOpen = preloadSchemaOnOpen;
  }
  async _open(ctx) {
    if (this._preloadSchemaOnOpen) {
      const { objects } = await this._db.query(Filter.type(StoredSchema2)).run();
      objects.forEach((object) => this._registerSchema(object));
    }
    if (this._reactiveQuery) {
      const unsubscribe = this._db.query(Filter.type(StoredSchema2)).subscribe(({ objects }) => {
        const currentObjectIds = new Set(objects.map((o) => o.id));
        const newObjects = objects.filter((object) => !this._schemaById.has(object.id));
        const removedObjects = [
          ...this._schemaById.keys()
        ].filter((oid) => !currentObjectIds.has(oid));
        newObjects.forEach((obj) => this._register(obj));
        removedObjects.forEach((idoid) => this._unregister(idoid));
        if (newObjects.length > 0 || removedObjects.length > 0) {
          this._notifySchemaListChanged();
        }
      });
      this._ctx.onDispose(unsubscribe);
    }
  }
  async _close(ctx) {
  }
  query(query = {}) {
    const self = this;
    const filterOrderResults = (schemas) => {
      log13("Filtering schemas", {
        schemas,
        query
      }, {
        F: __dxlog_file17,
        L: 105,
        S: this,
        C: (f, a) => f(...a)
      });
      return schemas.filter((schema) => validateStoredSchemaIntegrity(schema.storedSchema)).filter((object) => {
        const idFilter = coerceArray(query.id);
        if (idFilter.length > 0) {
          if (object.jsonSchema.$id && !idFilter.includes(object.jsonSchema.$id)) {
            return false;
          }
        }
        const backingObjectIdFilter = coerceArray(query.backingObjectId);
        if (backingObjectIdFilter.length > 0) {
          if (!backingObjectIdFilter.includes(object.id)) {
            return false;
          }
        }
        const typenameFilter = coerceArray(query.typename);
        if (typenameFilter.length > 0) {
          if (!typenameFilter.includes(object.typename)) {
            return false;
          }
        }
        if (query.version) {
          if (!query.version.match(/^[0-9.]+$/)) {
            throw new Error("Semver version ranges not supported.");
          }
          if (object.version !== query.version) {
            return false;
          }
        }
        return true;
      }).sort((a, b) => a.id.localeCompare(b.id));
    };
    const changes = new Event10();
    let unsubscribe;
    return new SchemaRegistryPreparedQueryImpl({
      changes,
      getResultsSync() {
        const objects = self._db.query(Filter.type(StoredSchema2)).runSync().map((result) => result.object).filter((object) => object != null);
        const results = filterOrderResults(objects.map((stored) => {
          return self._register(stored);
        }));
        return results;
      },
      async getResults() {
        const { objects } = await self._db.query(Filter.type(StoredSchema2)).run();
        return filterOrderResults(objects.map((stored) => {
          return self._register(stored);
        }));
      },
      async start() {
        if (unsubscribe) {
          return;
        }
        unsubscribe = self._subscribe(() => {
          changes.emit();
        });
      },
      async stop() {
        unsubscribe?.();
        unsubscribe = void 0;
      }
    });
  }
  // TODO(burdon): Tighten type signature to TypedObject?
  async register(inputs) {
    const results = [];
    for (const input of inputs) {
      if (!Schema2.isSchema(input)) {
        throw new TypeError("Invalid schema");
      }
      results.push(this._addSchema(input));
    }
    return results;
  }
  hasSchema(schema) {
    const schemaId = schema instanceof EchoSchema2 ? schema.id : getObjectIdFromSchema(schema);
    return schemaId != null && this.getSchemaById(schemaId) != null;
  }
  /**
  * @deprecated Use `query` instead.
  */
  getSchema(typename) {
    return this.query({
      typename
    }).runSync()[0];
  }
  /**
  * @deprecated Use `query` instead.
  */
  getSchemaById(id) {
    const existing = this._schemaById.get(id);
    if (existing != null) {
      return existing;
    }
    const typeObject = this._db.getObjectById(id);
    if (typeObject == null) {
      return void 0;
    }
    if (!Schema2.is(StoredSchema2)(typeObject)) {
      log13.warn("type object is not a stored schema", {
        id: typeObject?.id
      }, {
        F: __dxlog_file17,
        L: 231,
        S: this,
        C: (f, a) => f(...a)
      });
      return void 0;
    }
    return this._register(typeObject);
  }
  /**
  * @internal
  *
  * Registers a StoredSchema object if necessary and returns a EchoSchema object.
  */
  _registerSchema(schema) {
    const existing = this._schemaById.get(schema.id);
    if (existing != null) {
      return existing;
    }
    const registered = this._register(schema);
    this._notifySchemaListChanged();
    return registered;
  }
  _register(schema) {
    const existing = this._schemaById.get(schema.id);
    if (existing != null) {
      return existing;
    }
    let previousTypename;
    const echoSchema = new EchoSchema2(schema);
    const subscription = getObjectCore(schema).updates.on(() => {
      echoSchema._invalidate();
    });
    if (previousTypename !== void 0 && schema.typename !== previousTypename) {
      if (this._schemaByType.get(previousTypename) === echoSchema) {
        this._schemaByType.delete(previousTypename);
      }
      previousTypename = schema.typename;
      this._schemaByType.set(schema.typename, echoSchema);
      this._notifySchemaListChanged();
    }
    this._schemaById.set(schema.id, echoSchema);
    this._schemaByType.set(schema.typename, echoSchema);
    this._unsubscribeById.set(schema.id, subscription);
    return echoSchema;
  }
  // TODO(dmaretskyi): Figure out how to migrate the usages to the async `register` method.
  _addSchema(schema) {
    if (schema instanceof EchoSchema2) {
      schema = schema.snapshot.annotations({
        [TypeIdentifierAnnotationId]: void 0
      });
    }
    const meta = getTypeAnnotation2(schema);
    invariant13(meta, "use Schema.Struct({}).pipe(Type.Obj()) or class syntax to create a valid schema", {
      F: __dxlog_file17,
      L: 290,
      S: this,
      A: [
        "meta",
        "'use Schema.Struct({}).pipe(Type.Obj()) or class syntax to create a valid schema'"
      ]
    });
    const schemaToStore = create(StoredSchema2, {
      ...meta,
      jsonSchema: createJsonSchema()
    });
    schemaToStore.jsonSchema = toJsonSchema(schema.annotations({
      [TypeAnnotationId]: meta,
      [TypeIdentifierAnnotationId]: `dxn:echo:@:${schemaToStore.id}`
    }));
    const storedSchema = this._db.add(schemaToStore);
    const result = this._register(storedSchema);
    this._notifySchemaListChanged();
    result._rebuild();
    return result;
  }
  _unregister(id) {
    const schema = this._schemaById.get(id);
    if (schema != null) {
      this._schemaById.delete(id);
      this._schemaByType.delete(schema.typename);
      this._unsubscribeById.get(schema.id)?.();
      this._unsubscribeById.delete(schema.id);
    }
  }
  _subscribe(callback) {
    callback([
      ...this._schemaById.values()
    ]);
    this._schemaSubscriptionCallbacks.push(callback);
    return () => {
      const index = this._schemaSubscriptionCallbacks.indexOf(callback);
      if (index >= 0) {
        this._schemaSubscriptionCallbacks.splice(index, 1);
      }
    };
  }
  _notifySchemaListChanged() {
    const list = [
      ...this._schemaById.values()
    ];
    this._schemaSubscriptionCallbacks.forEach((s) => s(list));
  }
};
var coerceArray = (arr) => {
  if (arr === void 0) {
    return [];
  }
  return Array.isArray(arr) ? arr : [
    arr
  ];
};
var validateStoredSchemaIntegrity = (schema) => {
  if (!schema.jsonSchema.$id && !schema.jsonSchema.$id?.startsWith("dxn:")) {
    log13.warn("Schema is missing $id or has invalid $id", {
      schema
    }, {
      F: __dxlog_file17,
      L: 343,
      S: void 0,
      C: (f, a) => f(...a)
    });
    return false;
  }
  if (schema.jsonSchema.type !== "object") {
    log13.warn("Schema is not of object type", {
      schema
    }, {
      F: __dxlog_file17,
      L: 348,
      S: void 0,
      C: (f, a) => f(...a)
    });
    return false;
  }
  return true;
};
var getObjectIdFromSchema = (schema) => {
  const echoIdentifier = getTypeIdentifierAnnotation(schema);
  if (!echoIdentifier) {
    return void 0;
  }
  const dxn = DXN6.parse(echoIdentifier);
  invariant13(dxn.isLocalObjectId(), void 0, {
    F: __dxlog_file17,
    L: 362,
    S: void 0,
    A: [
      "dxn.isLocalObjectId()",
      ""
    ]
  });
  return dxn.parts[1];
};

// packages/core/echo/echo-db/src/proxy-db/database.ts
import { inspect } from "node:util";
import { Event as Event11, synchronized as synchronized2 } from "@dxos/async";
import { LifecycleState as LifecycleState2, Resource as Resource3 } from "@dxos/context";
import { inspectObject } from "@dxos/debug";
import { assertObjectModelShape as assertObjectModelShape2 } from "@dxos/echo-schema";
import { getSchema as getSchema2 } from "@dxos/echo-schema";
import { invariant as invariant14 } from "@dxos/invariant";
import { DXN as DXN7 } from "@dxos/keys";
import { getProxyTarget as getProxyTarget3, getType, isLiveObject as isLiveObject4 } from "@dxos/live-object";
import { log as log14 } from "@dxos/log";
import { defaultMap as defaultMap3 } from "@dxos/util";
function _ts_decorate4(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file18 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-db/src/proxy-db/database.ts";
var EchoDatabaseImpl = class extends Resource3 {
  constructor(params) {
    super();
    this._rootUrl = void 0;
    /**
    * Mapping `object core` -> `root proxy` (User facing proxies).
    * @internal
    */
    this._rootProxies = /* @__PURE__ */ new Map();
    //
    // Deprecated API.
    //
    /**
    * @deprecated
    */
    this.pendingBatch = new Event11();
    this._coreDatabase = new CoreDatabase({
      graph: params.graph,
      dataService: params.dataService,
      queryService: params.queryService,
      spaceId: params.spaceId,
      spaceKey: params.spaceKey
    });
    this._schemaRegistry = new EchoSchemaRegistry(this, {
      reactiveQuery: params.reactiveSchemaQuery,
      preloadSchemaOnOpen: params.preloadSchemaOnOpen
    });
  }
  [inspect.custom]() {
    return inspectObject(this);
  }
  toJSON() {
    return this._coreDatabase.toJSON();
  }
  get spaceId() {
    return this._coreDatabase.spaceId;
  }
  /**
  * @deprecated Use `spaceId`.
  */
  get spaceKey() {
    return this._coreDatabase.spaceKey;
  }
  get rootUrl() {
    return this._rootUrl;
  }
  get graph() {
    return this._coreDatabase.graph;
  }
  // TODO(burdon): Rename.
  get schemaRegistry() {
    return this._schemaRegistry;
  }
  async _open() {
    if (this._rootUrl !== void 0) {
      await this._coreDatabase.open({
        rootUrl: this._rootUrl
      });
    }
    await this._schemaRegistry.open();
  }
  async _close() {
    await this._schemaRegistry.close();
    await this._coreDatabase.close();
  }
  async setSpaceRoot(rootUrl) {
    log14("setSpaceRoot", {
      rootUrl
    }, {
      F: __dxlog_file18,
      L: 234,
      S: this,
      C: (f, a) => f(...a)
    });
    const firstTime = this._rootUrl === void 0;
    this._rootUrl = rootUrl;
    if (this._lifecycleState === LifecycleState2.OPEN) {
      if (firstTime) {
        await this._coreDatabase.open({
          rootUrl
        });
      } else {
        await this._coreDatabase.updateSpaceState({
          rootUrl
        });
      }
    }
  }
  getObjectById(id, { deleted = false } = {}) {
    const core = this._coreDatabase.getObjectCoreById(id);
    if (!core || core.isDeleted() && !deleted) {
      return void 0;
    }
    const object = defaultMap3(this._rootProxies, core, () => initEchoReactiveObjectRootProxy(core, this));
    invariant14(isLiveObject4(object), void 0, {
      F: __dxlog_file18,
      L: 253,
      S: this,
      A: [
        "isLiveObject(object)",
        ""
      ]
    });
    return object;
  }
  static {
    this.prototype.query = this.prototype._query;
  }
  _query(query, options) {
    query = Filter.is(query) ? Query.select(query) : query;
    return this._coreDatabase.graph.query(query, {
      ...options,
      spaceIds: [
        this.spaceId
      ]
    });
  }
  /**
  * Update objects.
  */
  async update(filter, operation) {
    await this._coreDatabase.update(filter, operation);
  }
  async insert(data) {
    return this._coreDatabase.insert(data);
  }
  /**
  * Add reactive object.
  */
  // TODO(dmaretskyi): Lock to Obj.Any | Relation.Any.
  add(obj, opts) {
    if (!isEchoObject(obj)) {
      const schema = getSchema2(obj);
      if (schema != null) {
        if (!this.schemaRegistry.hasSchema(schema) && !this.graph.schemaRegistry.hasSchema(schema)) {
          throw createSchemaNotRegisteredError(schema);
        }
      }
      obj = createObject(obj);
    }
    assertObjectModelShape2(obj);
    invariant14(isEchoObject(obj), void 0, {
      F: __dxlog_file18,
      L: 303,
      S: this,
      A: [
        "isEchoObject(obj)",
        ""
      ]
    });
    this._rootProxies.set(getObjectCore(obj), obj);
    const target = getProxyTarget3(obj);
    EchoReactiveHandler.instance.setDatabase(target, this);
    EchoReactiveHandler.instance.saveRefs(target);
    this._coreDatabase.addCore(getObjectCore(obj), opts);
    return obj;
  }
  /**
  * Remove reactive object.
  */
  remove(obj) {
    invariant14(isEchoObject(obj), void 0, {
      F: __dxlog_file18,
      L: 318,
      S: this,
      A: [
        "isEchoObject(obj)",
        ""
      ]
    });
    return this._coreDatabase.removeCore(getObjectCore(obj));
  }
  async flush(opts) {
    await this._coreDatabase.flush(opts);
  }
  async runMigrations(migrations) {
    for (const migration of migrations) {
      const { objects } = await this._coreDatabase.graph.query(Query.select(Filter.typeDXN(migration.fromType))).run();
      log14.verbose("migrate", {
        from: migration.fromType,
        to: migration.toType,
        objects: objects.length
      }, {
        F: __dxlog_file18,
        L: 329,
        S: this,
        C: (f, a) => f(...a)
      });
      for (const object of objects) {
        const output = await migration.transform(object, {
          db: this
        });
        delete output.id;
        await this._coreDatabase.atomicReplaceObject(object.id, {
          data: output,
          type: migration.toType
        });
        const postMigrationType = getType(object);
        invariant14(postMigrationType != null && DXN7.equals(postMigrationType, migration.toType), void 0, {
          F: __dxlog_file18,
          L: 341,
          S: this,
          A: [
            "postMigrationType != null && DXN.equals(postMigrationType, migration.toType)",
            ""
          ]
        });
        await migration.onMigration({
          before: object,
          object,
          db: this
        });
      }
    }
    await this.flush();
  }
  /**
  * @internal
  */
  async _loadObjectById(objectId, options = {}) {
    const core = await this._coreDatabase.loadObjectCoreById(objectId, options);
    if (!core || core?.isDeleted()) {
      return void 0;
    }
    const obj = defaultMap3(this._rootProxies, core, () => initEchoReactiveObjectRootProxy(core, this));
    invariant14(isLiveObject4(obj), void 0, {
      F: __dxlog_file18,
      L: 362,
      S: this,
      A: [
        "isLiveObject(obj)",
        ""
      ]
    });
    return obj;
  }
  /**
  * @deprecated
  */
  get coreDatabase() {
    return this._coreDatabase;
  }
};
_ts_decorate4([
  synchronized2
], EchoDatabaseImpl.prototype, "_open", null);
_ts_decorate4([
  synchronized2
], EchoDatabaseImpl.prototype, "_close", null);
_ts_decorate4([
  synchronized2
], EchoDatabaseImpl.prototype, "setSpaceRoot", null);
var createSchemaNotRegisteredError = (schema) => {
  const message = "Schema not registered";
  if (schema?.typename) {
    return new Error(`${message} Schema: ${schema.typename}`);
  }
  return new Error(message);
};

// packages/core/echo/echo-db/src/proxy-db/load-object.ts
import { asyncTimeout as asyncTimeout3 } from "@dxos/async";
var loadObject = (obj) => {
  return getObjectCore(obj).getDecoded([
    "data"
  ]);
};
var loadObjectReferences = async (objOrArray, valueAccessor, { timeout } = {
  timeout: 5e3
}) => {
  const objectArray = Array.isArray(objOrArray) ? objOrArray : [
    objOrArray
  ];
  const tasks = objectArray.map((obj) => {
    const core = getObjectCore(obj);
    const value = valueAccessor(obj);
    if (core.database == null) {
      return value;
    }
    const isLoadedPredicate = Array.isArray(value) ? () => valueAccessor(obj).every((v) => v != null) : () => valueAccessor(obj) != null;
    if (isLoadedPredicate()) {
      return value;
    }
    return asyncTimeout3(core.database._updateEvent.waitFor(() => isLoadedPredicate()).then(() => valueAccessor(obj)), timeout);
  });
  const result = await Promise.all(tasks);
  return Array.isArray(objOrArray) ? result : result[0];
};

// packages/core/echo/echo-db/src/proxy-db/object-migration.ts
import { getSchemaDXN } from "@dxos/echo-schema";
var defineObjectMigration = (options) => {
  const fromType = getSchemaDXN(options.from);
  if (!fromType) {
    throw new Error("Invalid from schema");
  }
  const toType = getSchemaDXN(options.to);
  if (!toType) {
    throw new Error("Invalid to schema");
  }
  return {
    fromType,
    toType,
    fromSchema: options.from,
    toSchema: options.to,
    transform: options.transform,
    onMigration: options.onMigration
  };
};

// packages/core/echo/echo-db/src/queue/memory-queue.ts
import { ObjectId as ObjectId3 } from "@dxos/echo-schema";
import { compositeRuntime as compositeRuntime6 } from "@dxos/echo-signals/runtime";
import { invariant as invariant15 } from "@dxos/invariant";
import { DXN as DXN8, SpaceId as SpaceId3 } from "@dxos/keys";
var __dxlog_file19 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-db/src/queue/memory-queue.ts";
var MemoryQueue = class _MemoryQueue {
  static make({ spaceId, queueId, dxn, objects }) {
    if (!dxn) {
      dxn = new DXN8(DXN8.kind.QUEUE, [
        spaceId ?? SpaceId3.random(),
        queueId ?? ObjectId3.random()
      ]);
    } else {
      invariant15(spaceId == null && queueId == null, void 0, {
        F: __dxlog_file19,
        L: 34,
        S: this,
        A: [
          "spaceId == null && queueId == null",
          ""
        ]
      });
    }
    const queue = new _MemoryQueue(dxn);
    if (objects?.length) {
      void queue.append(objects);
    }
    return queue;
  }
  constructor(_dxn) {
    this._dxn = _dxn;
    this._signal = compositeRuntime6.createSignal();
    this._objects = [];
  }
  toJSON() {
    return {
      dxn: this._dxn.toString(),
      objects: this._objects.length
    };
  }
  get dxn() {
    return this._dxn;
  }
  get isLoading() {
    return false;
  }
  get error() {
    return null;
  }
  get objects() {
    this._signal.notifyRead();
    return [
      ...this._objects
    ];
  }
  /**
  * Insert into queue with optimistic update.
  */
  async append(objects) {
    this._objects = [
      ...this._objects,
      ...objects
    ];
    this._signal.notifyWrite();
  }
  async queryObjects() {
    return this._objects;
  }
  async getObjectsById(ids) {
    return ids.map((id) => this._objects.find((object) => object.id === id) ?? null);
  }
  async delete(ids) {
    this._objects = this._objects.filter((object) => !ids.includes(object.id));
    this._signal.notifyWrite();
  }
  async refresh() {
  }
};

// packages/core/echo/echo-db/src/queue/queue.ts
import { Obj } from "@dxos/echo";
import { assertObjectModelShape as assertObjectModelShape3 } from "@dxos/echo-schema";
import { compositeRuntime as compositeRuntime7 } from "@dxos/echo-signals/runtime";
import { failedInvariant as failedInvariant3 } from "@dxos/invariant";
import { log as log15 } from "@dxos/log";
var __dxlog_file20 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-db/src/queue/queue.ts";
var TRACE_QUEUE_LOAD = false;
var QueueImpl = class {
  constructor(_service, _refResolver, _dxn) {
    this._service = _service;
    this._refResolver = _refResolver;
    this._dxn = _dxn;
    this._signal = compositeRuntime7.createSignal();
    this._objectCache = /* @__PURE__ */ new Map();
    this._objects = [];
    this._isLoading = true;
    this._error = null;
    this._refreshId = 0;
    this._querying = false;
    const { subspaceTag, spaceId, queueId } = this._dxn.asQueueDXN() ?? {};
    this._subspaceTag = subspaceTag ?? failedInvariant3();
    this._spaceId = spaceId ?? failedInvariant3();
    this._queueId = queueId ?? failedInvariant3();
  }
  toJSON() {
    return {
      dxn: this._dxn.toString(),
      objects: this._objects.length
    };
  }
  // TODO(burdon): Rename to objects.
  get dxn() {
    return this._dxn;
  }
  get isLoading() {
    this._signal.notifyRead();
    return this._isLoading;
  }
  get error() {
    this._signal.notifyRead();
    return this._error;
  }
  get objects() {
    this._signal.notifyRead();
    return this._objects;
  }
  /**
  * Insert into queue with optimistic update.
  */
  async append(items) {
    items.forEach((item) => assertObjectModelShape3(item));
    this._objects = [
      ...this._objects,
      ...items
    ];
    for (const item of items) {
      this._objectCache.set(item.id, item);
    }
    this._signal.notifyWrite();
    try {
      await this._service.insertIntoQueue(this._subspaceTag, this._spaceId, this._queueId, items.map((item) => Obj.toJSON(item)));
    } catch (err) {
      log15.catch(err, void 0, {
        F: __dxlog_file20,
        L: 93,
        S: this,
        C: (f, a) => f(...a)
      });
      this._error = err;
      this._signal.notifyWrite();
    }
  }
  async delete(ids) {
    this._objects = this._objects.filter((item) => !ids.includes(item.id));
    for (const id of ids) {
      this._objectCache.delete(id);
    }
    this._signal.notifyWrite();
    try {
      await this._service.deleteFromQueue(this._subspaceTag, this._spaceId, this._queueId, ids);
    } catch (err) {
      this._error = err;
      this._signal.notifyWrite();
    }
  }
  async queryObjects() {
    const { objects } = await this._service.queryQueue(this._subspaceTag, this._spaceId, {
      queueId: this._queueId
    });
    const decodedObjects = await Promise.all(objects.map(async (obj) => {
      const decoded = await Obj.fromJSON(obj, {
        refResolver: this._refResolver
      });
      this._objectCache.set(decoded.id, decoded);
      return decoded;
    }));
    return decodedObjects;
  }
  async getObjectsById(ids) {
    const missingIds = ids.filter((id) => !this._objectCache.has(id));
    if (missingIds.length > 0) {
      if (!this._querying) {
        try {
          this._querying = true;
          await this.queryObjects();
        } finally {
          this._querying = false;
        }
      }
    }
    return ids.map((id) => this._objectCache.get(id) ?? null);
  }
  /**
  * Reload state from server.
  * Overrides optimistic updates.
  */
  // TODO(dmaretskyi): Split optimistic into separate state so it doesn't get overridden.
  async refresh() {
    const thisRefreshId = ++this._refreshId;
    let changed = false;
    try {
      TRACE_QUEUE_LOAD && log15.info("queue refresh begin", {
        currentObjects: this._objects.length,
        refreshId: thisRefreshId
      }, {
        F: __dxlog_file20,
        L: 153,
        S: this,
        C: (f, a) => f(...a)
      });
      const { objects } = await this._service.queryQueue(this._subspaceTag, this._spaceId, {
        queueId: this._queueId
      });
      TRACE_QUEUE_LOAD && log15.info("items fetched", {
        refreshId: thisRefreshId,
        count: objects.length
      }, {
        F: __dxlog_file20,
        L: 155,
        S: this,
        C: (f, a) => f(...a)
      });
      if (thisRefreshId !== this._refreshId) {
        return;
      }
      const decodedObjects = await Promise.all(objects.map((obj) => Obj.fromJSON(obj, {
        refResolver: this._refResolver
      })));
      if (thisRefreshId !== this._refreshId) {
        return;
      }
      for (const obj of decodedObjects) {
        this._objectCache.set(obj.id, obj);
      }
      changed = objectSetChanged(this._objects, decodedObjects);
      TRACE_QUEUE_LOAD && log15.info("queue refresh", {
        changed,
        objects: objects.length,
        refreshId: thisRefreshId
      }, {
        F: __dxlog_file20,
        L: 173,
        S: this,
        C: (f, a) => f(...a)
      });
      this._objects = decodedObjects;
    } catch (err) {
      log15.catch(err, void 0, {
        F: __dxlog_file20,
        L: 176,
        S: this,
        C: (f, a) => f(...a)
      });
      this._error = err;
    } finally {
      this._isLoading = false;
      if (changed) {
        this._signal.notifyWrite();
      }
    }
  }
};
var objectSetChanged = (before, after) => {
  if (before.length !== after.length) {
    return true;
  }
  return before.some((item, index) => item.id !== after[index].id);
};

// packages/core/echo/echo-db/src/queue/queue-factory.ts
import { Resource as Resource4 } from "@dxos/context";
import { assertState as assertState2 } from "@dxos/invariant";
import { DXN as DXN9, ObjectId as ObjectId4, QueueSubspaceTags } from "@dxos/keys";
var QueueFactory = class extends Resource4 {
  constructor(_spaceId, _graph) {
    super(), this._spaceId = _spaceId, this._graph = _graph, this._queues = /* @__PURE__ */ new Map(), this._service = void 0;
  }
  setService(service) {
    this._service = service;
  }
  get(dxn) {
    assertState2(this._service, "Service not set");
    const stringDxn = dxn.toString();
    const queue = this._queues.get(stringDxn);
    if (queue) {
      return queue;
    }
    const newQueue = new QueueImpl(this._service, this._graph.createRefResolver({
      context: {
        space: this._spaceId,
        queue: dxn
      }
    }), dxn);
    this._queues.set(stringDxn, newQueue);
    return newQueue;
  }
  create({ subspaceTag = QueueSubspaceTags.DATA } = {}) {
    const dxn = DXN9.fromQueue(subspaceTag, this._spaceId, ObjectId4.random());
    return this.get(dxn);
  }
};

// packages/core/echo/echo-db/src/queue/queue-service.ts
import { ComplexMap as ComplexMap2 } from "@dxos/util";
var QueueServiceImpl = class {
  constructor(_client) {
    this._client = _client;
  }
  queryQueue(subspaceTag, spaceId, query) {
    return this._client.queryQueue(subspaceTag, spaceId, query);
  }
  insertIntoQueue(subspaceTag, spaceId, queueId, objects) {
    return this._client.insertIntoQueue(subspaceTag, spaceId, queueId, objects);
  }
  deleteFromQueue(subspaceTag, spaceId, queueId, objectIds) {
    return this._client.deleteFromQueue(subspaceTag, spaceId, queueId, objectIds);
  }
};
var QueueServiceStub = class {
  queryQueue(subspaceTag, spaceId, query) {
    throw new Error("Not available.");
  }
  insertIntoQueue(subspaceTag, spaceId, queueId, objects) {
    throw new Error("Not available.");
  }
  deleteFromQueue(subspaceTag, spaceId, queueId, objectIds) {
    throw new Error("Not available.");
  }
};
var MockQueueService = class {
  constructor() {
    this._queues = new ComplexMap2(([subspaceTag, spaceId, queueId]) => `${subspaceTag}:${spaceId}:${queueId}`);
  }
  async queryQueue(subspaceTag, spaceId, query) {
    const objects = this._queues.get([
      subspaceTag,
      spaceId,
      query.queueId
    ]) ?? [];
    return {
      objects,
      nextCursor: null,
      prevCursor: null
    };
  }
  async insertIntoQueue(subspaceTag, spaceId, queueId, objects) {
    const key = [
      subspaceTag,
      spaceId,
      queueId
    ];
    const existing = this._queues.get(key) ?? [];
    this._queues.set(key, [
      ...existing,
      ...objects
    ]);
  }
  async deleteFromQueue(subspaceTag, spaceId, queueId, objectIds) {
    const key = [
      subspaceTag,
      spaceId,
      queueId
    ];
    const existing = this._queues.get(key) ?? [];
    this._queues.set(key, existing.filter((obj) => !objectIds.includes(obj.id)));
  }
};

// packages/core/echo/echo-db/src/queue/types.ts
import { Schema as Schema3 } from "effect";
import { EntityKind as EntityKind4, TypeAnnotationId as TypeAnnotationId2 } from "@dxos/echo-schema";
var isQueue = (value) => {
  return false;
};
var Queue = Schema3.declare(isQueue, {
  [TypeAnnotationId2]: {
    // TODO(dmaretskyi): Perhaps queue should be its own entity kind.
    kind: EntityKind4.Object,
    typename: "dxos.org/type/Queue",
    version: "0.1.0"
  }
});

// packages/core/echo/echo-db/src/client/echo-client.ts
import { LifecycleState as LifecycleState3, Resource as Resource5, ContextDisposedError as ContextDisposedError2 } from "@dxos/context";
import { invariant as invariant17 } from "@dxos/invariant";
import { log as log17 } from "@dxos/log";

// packages/core/echo/echo-db/src/client/index-query-source-provider.ts
import { Event as Event12 } from "@dxos/async";
import { Context as Context5 } from "@dxos/context";
import { invariant as invariant16 } from "@dxos/invariant";
import { SpaceId as SpaceId4 } from "@dxos/keys";
import { log as log16 } from "@dxos/log";
import { RpcClosedError } from "@dxos/protocols";
import { QueryReactivity as QueryReactivity2 } from "@dxos/protocols/proto/dxos/echo/query";
import { isNonNullable as isNonNullable3 } from "@dxos/util";
var __dxlog_file21 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-db/src/client/index-query-source-provider.ts";
var QUERY_SERVICE_TIMEOUT2 = 2e4;
var IndexQuerySourceProvider = class {
  // TODO(burdon): OK for options, but not params. Pass separately and type readonly here.
  constructor(_params) {
    this._params = _params;
  }
  // TODO(burdon): Rename createQuerySource
  create() {
    return new IndexQuerySource({
      service: this._params.service,
      objectLoader: this._params.objectLoader
    });
  }
};
var IndexQuerySource = class {
  constructor(_params) {
    this._params = _params;
    this.changed = new Event12();
    this._query = void 0;
    this._results = [];
  }
  open() {
  }
  close() {
    this._results = void 0;
    this._closeStream();
  }
  getResults() {
    return this._results ?? [];
  }
  async run(query) {
    this._query = query;
    return new Promise((resolve, reject) => {
      this._queryIndex(query, QueryReactivity2.ONE_SHOT, resolve, reject);
    });
  }
  update(query) {
    this._query = query;
    this._closeStream();
    this._results = [];
    this.changed.emit();
    this._queryIndex(query, QueryReactivity2.REACTIVE, (results) => {
      this._results = results;
      this.changed.emit();
    });
  }
  _queryIndex(query, queryType, onResult, onError) {
    const queryId = nextQueryId2++;
    log16("queryIndex", {
      queryId
    }, {
      F: __dxlog_file21,
      L: 109,
      S: this,
      C: (f, a) => f(...a)
    });
    const start = Date.now();
    let currentCtx;
    const stream = this._params.service.execQuery({
      query: JSON.stringify(query),
      queryId: String(queryId),
      reactivity: queryType
    }, {
      timeout: QUERY_SERVICE_TIMEOUT2
    });
    if (queryType === QueryReactivity2.REACTIVE) {
      if (this._stream) {
        log16.warn("Query stream already open", void 0, {
          F: __dxlog_file21,
          L: 120,
          S: this,
          C: (f, a) => f(...a)
        });
      }
      this._stream = stream;
    }
    stream.subscribe(async (response) => {
      try {
        const targetSpaces = getTargetSpacesForQuery(query);
        if (targetSpaces.length > 0) {
          invariant16(response.results?.every((r) => targetSpaces.includes(SpaceId4.make(r.spaceId))), "Result spaceId mismatch", {
            F: __dxlog_file21,
            L: 130,
            S: this,
            A: [
              "response.results?.every((r) => targetSpaces.includes(SpaceId.make(r.spaceId)))",
              "'Result spaceId mismatch'"
            ]
          });
        }
        if (queryType === QueryReactivity2.ONE_SHOT) {
          if (currentCtx) {
            return;
          }
          void stream.close().catch(() => {
          });
        }
        await currentCtx?.dispose();
        const ctx = new Context5(void 0, {
          F: __dxlog_file21,
          L: 144
        });
        currentCtx = ctx;
        log16("queryIndex raw results", {
          queryId,
          length: response.results?.length ?? 0
        }, {
          F: __dxlog_file21,
          L: 147,
          S: this,
          C: (f, a) => f(...a)
        });
        const processedResults = await Promise.all((response.results ?? []).map((result) => this._filterMapResult(ctx, start, result)));
        const results = processedResults.filter(isNonNullable3);
        log16("queryIndex processed results", {
          queryId,
          fetchedFromIndex: response.results?.length ?? 0,
          loaded: results.length
        }, {
          F: __dxlog_file21,
          L: 157,
          S: this,
          C: (f, a) => f(...a)
        });
        if (currentCtx === ctx) {
          onResult(results);
        } else {
          log16.warn("results from the previous update are ignored", {
            queryId
          }, {
            F: __dxlog_file21,
            L: 166,
            S: this,
            C: (f, a) => f(...a)
          });
        }
      } catch (err) {
        if (onError) {
          onError(err);
        } else {
          log16.catch(err, void 0, {
            F: __dxlog_file21,
            L: 172,
            S: this,
            C: (f, a) => f(...a)
          });
        }
      }
    }, (err) => {
      if (err != null) {
        if (onError) {
          onError(err);
        } else if (!(err instanceof RpcClosedError)) {
          log16.catch(err, void 0, {
            F: __dxlog_file21,
            L: 181,
            S: this,
            C: (f, a) => f(...a)
          });
        }
      }
    });
  }
  async _filterMapResult(ctx, queryStartTimestamp, result) {
    if (!OBJECT_DIAGNOSTICS.has(result.id)) {
      OBJECT_DIAGNOSTICS.set(result.id, {
        objectId: result.id,
        spaceId: result.spaceId,
        loadReason: "query",
        query: JSON.stringify(this._query ?? null)
      });
    }
    invariant16(SpaceId4.isValid(result.spaceId), "Invalid spaceId", {
      F: __dxlog_file21,
      L: 202,
      S: this,
      A: [
        "SpaceId.isValid(result.spaceId)",
        "'Invalid spaceId'"
      ]
    });
    const object = await this._params.objectLoader.loadObject({
      spaceId: result.spaceId,
      objectId: result.id,
      documentId: result.documentId
    });
    if (!object) {
      return null;
    }
    if (ctx.disposed) {
      return null;
    }
    const core = getObjectCore(object);
    const queryResult = {
      id: object.id,
      spaceId: core.database.spaceId,
      spaceKey: core.database.spaceKey,
      object,
      match: {
        rank: result.rank
      },
      resolution: {
        source: "index",
        time: Date.now() - queryStartTimestamp
      }
    };
    return queryResult;
  }
  _closeStream() {
    void this._stream?.close().catch(() => {
    });
    this._stream = void 0;
  }
};
var nextQueryId2 = 1;

// packages/core/echo/echo-db/src/client/echo-client.ts
var __dxlog_file22 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-db/src/client/echo-client.ts";
var EchoClient = class extends Resource5 {
  constructor(_ = {}) {
    super();
    this._databases = /* @__PURE__ */ new Map();
    this._dataService = void 0;
    this._queryService = void 0;
    this._queuesService = void 0;
    this._indexQuerySourceProvider = void 0;
    this._graph = new Hypergraph();
  }
  get graph() {
    return this._graph;
  }
  get openDatabases() {
    return this._databases.values();
  }
  /**
  * Connects to the ECHO service.
  * Must be called before open.
  */
  connectToService({ dataService, queryService, queueService }) {
    invariant17(this._lifecycleState === LifecycleState3.CLOSED, void 0, {
      F: __dxlog_file22,
      L: 83,
      S: this,
      A: [
        "this._lifecycleState === LifecycleState.CLOSED",
        ""
      ]
    });
    this._dataService = dataService;
    this._queryService = queryService;
    this._queuesService = queueService;
  }
  disconnectFromService() {
    invariant17(this._lifecycleState === LifecycleState3.CLOSED, void 0, {
      F: __dxlog_file22,
      L: 90,
      S: this,
      A: [
        "this._lifecycleState === LifecycleState.CLOSED",
        ""
      ]
    });
    this._dataService = void 0;
    this._queryService = void 0;
  }
  async _open(ctx) {
    invariant17(this._dataService && this._queryService, "Invalid state: not connected", {
      F: __dxlog_file22,
      L: 96,
      S: this,
      A: [
        "this._dataService && this._queryService",
        "'Invalid state: not connected'"
      ]
    });
    this._indexQuerySourceProvider = new IndexQuerySourceProvider({
      service: this._queryService,
      objectLoader: {
        loadObject: this._loadObjectFromDocument.bind(this)
      }
    });
    this._graph.registerQuerySourceProvider(this._indexQuerySourceProvider);
  }
  async _close(ctx) {
    if (this._indexQuerySourceProvider) {
      this._graph.unregisterQuerySourceProvider(this._indexQuerySourceProvider);
    }
    for (const db of this._databases.values()) {
      this._graph._unregisterDatabase(db.spaceId);
      await db.close();
    }
    this._databases.clear();
  }
  // TODO(dmaretskyi): Make async?
  constructDatabase({ spaceId, owningObject, reactiveSchemaQuery, preloadSchemaOnOpen, spaceKey }) {
    invariant17(this._lifecycleState === LifecycleState3.OPEN, void 0, {
      F: __dxlog_file22,
      L: 126,
      S: this,
      A: [
        "this._lifecycleState === LifecycleState.OPEN",
        ""
      ]
    });
    invariant17(!this._databases.has(spaceId), "Database already exists.", {
      F: __dxlog_file22,
      L: 127,
      S: this,
      A: [
        "!this._databases.has(spaceId)",
        "'Database already exists.'"
      ]
    });
    const db = new EchoDatabaseImpl({
      dataService: this._dataService,
      queryService: this._queryService,
      graph: this._graph,
      spaceId,
      reactiveSchemaQuery,
      preloadSchemaOnOpen,
      spaceKey
    });
    this._graph._registerDatabase(spaceId, db, owningObject);
    this._databases.set(spaceId, db);
    return db;
  }
  constructQueueFactory(spaceId) {
    const queueFactory = new QueueFactory(spaceId, this._graph);
    this._graph._registerQueueFactory(spaceId, queueFactory);
    if (this._queuesService) {
      queueFactory.setService(this._queuesService);
    }
    return queueFactory;
  }
  async _loadObjectFromDocument({ spaceId, objectId, documentId }) {
    const db = this._databases.get(spaceId);
    if (!db) {
      return void 0;
    }
    try {
      await db.coreDatabase.opened.wait();
    } catch (err) {
      if (err instanceof ContextDisposedError2) {
        return void 0;
      }
      throw err;
    }
    const objectDocId = db._coreDatabase._automergeDocLoader.getObjectDocumentId(objectId);
    if (objectDocId !== documentId) {
      log17("documentIds don't match", {
        objectId,
        expected: documentId,
        actual: objectDocId ?? null
      }, {
        F: __dxlog_file22,
        L: 170,
        S: this,
        C: (f, a) => f(...a)
      });
      return void 0;
    }
    return db._loadObjectById(objectId);
  }
};

export {
  prohibitSignalActions,
  QueryResult,
  Filter,
  Query,
  ResultFormat,
  optionsToProto,
  normalizeQuery,
  getTargetSpacesForQuery,
  isSimpleSelectionQuery,
  GraphQueryContext,
  SpaceQuerySource,
  DocAccessor,
  isValidKeyPath,
  META_NAMESPACE,
  ObjectCore,
  objectIsUpdated,
  DocHandleProxy,
  RepoProxy,
  CoreDatabase,
  EchoReactiveHandler,
  getObjectCore,
  isEchoObject,
  createObject,
  initEchoReactiveObjectRootProxy,
  clone,
  getEditHistory,
  checkoutVersion,
  isRelation,
  getSource,
  getTarget,
  getDatabaseFromObject,
  getReferenceWithSpaceKey,
  findObjectWithForeignKey,
  matchKeys,
  createDocAccessor,
  ObjectVersion,
  getVersion,
  createSubscription,
  Hypergraph,
  OBJECT_DIAGNOSTICS,
  EchoSchemaRegistry,
  EchoDatabaseImpl,
  loadObject,
  loadObjectReferences,
  defineObjectMigration,
  MemoryQueue,
  QueueImpl,
  QueueFactory,
  QueueServiceImpl,
  QueueServiceStub,
  MockQueueService,
  Queue,
  EchoClient
};
//# sourceMappingURL=chunk-SRCS64NC.mjs.map
