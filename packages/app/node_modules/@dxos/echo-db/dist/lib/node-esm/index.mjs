import { createRequire } from 'node:module';const require = createRequire(import.meta.url);
import {
  CoreDatabase,
  DocAccessor,
  DocHandleProxy,
  EchoClient,
  EchoDatabaseImpl,
  EchoReactiveHandler,
  EchoSchemaRegistry,
  Filter,
  GraphQueryContext,
  Hypergraph,
  META_NAMESPACE,
  MemoryQueue,
  MockQueueService,
  OBJECT_DIAGNOSTICS,
  ObjectCore,
  ObjectVersion,
  Query,
  QueryResult,
  Queue,
  QueueFactory,
  QueueImpl,
  QueueServiceImpl,
  QueueServiceStub,
  RepoProxy,
  ResultFormat,
  SpaceQuerySource,
  checkoutVersion,
  clone,
  createDocAccessor,
  createObject,
  createSubscription,
  defineObjectMigration,
  findObjectWithForeignKey,
  getDatabaseFromObject,
  getEditHistory,
  getObjectCore,
  getReferenceWithSpaceKey,
  getSource,
  getTarget,
  getTargetSpacesForQuery,
  getVersion,
  initEchoReactiveObjectRootProxy,
  isEchoObject,
  isRelation,
  isSimpleSelectionQuery,
  isValidKeyPath,
  loadObject,
  loadObjectReferences,
  matchKeys,
  normalizeQuery,
  objectIsUpdated,
  optionsToProto,
  prohibitSignalActions
} from "./chunk-SRCS64NC.mjs";

// packages/core/echo/echo-db/src/serializer.ts
import { Filter as Filter2 } from "@dxos/echo";
import { decodeReference, encodeReference, Reference } from "@dxos/echo-protocol";
import { invariant } from "@dxos/invariant";
import { deepMapValues, isNonNullable, stripUndefined } from "@dxos/util";
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/core/echo/echo-db/src/serializer.ts";
var MAX_LOAD_OBJECT_CHUNK_SIZE = 30;
var LEGACY_REFERENCE_TYPE_TAG = "dxos.echo.model.document.Reference";
var Serializer = class _Serializer {
  static {
    this.version = 1;
  }
  async export(database) {
    const ids = database.coreDatabase.getAllObjectIds();
    const loadedObjects = [];
    for (const chunk of chunkArray(ids, MAX_LOAD_OBJECT_CHUNK_SIZE)) {
      const { objects } = await database.query(Filter2.ids(...chunk)).run({
        timeout: 6e4
      });
      loadedObjects.push(...objects);
    }
    const data = {
      objects: loadedObjects.filter(isNonNullable).map((object) => {
        return this.exportObject(object);
      }),
      version: _Serializer.version,
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      spaceKey: database.spaceKey.toHex()
    };
    return data;
  }
  async import(database, data, opts) {
    invariant(data.version === _Serializer.version, `Invalid version: ${data.version}`, {
      F: __dxlog_file,
      L: 56,
      S: this,
      A: [
        "data.version === Serializer.version",
        "`Invalid version: ${data.version}`"
      ]
    });
    const { objects } = data;
    for (const object of objects) {
      const shouldImport = opts?.onObject ? await opts.onObject(object) : true;
      if (shouldImport) {
        this._importObject(database, object);
      }
    }
    await database.flush();
  }
  exportObject(object) {
    const core = getObjectCore(object);
    const typeRef = core.getType();
    const data = serializeEchoData(core.getDecoded([
      "data"
    ]));
    const meta = serializeEchoData(core.getDecoded([
      "meta"
    ]));
    return stripUndefined({
      "@id": core.id,
      "@type": typeRef ? encodeReference(typeRef) : void 0,
      ...data,
      "@version": _Serializer.version,
      "@meta": meta,
      "@timestamp": (/* @__PURE__ */ new Date()).toISOString()
    });
  }
  _importObject(database, object) {
    const { "@id": id, "@type": type, "@deleted": deleted, "@meta": meta, ...data } = object;
    const dataProperties = Object.fromEntries(Object.entries(data).filter(([key]) => !key.startsWith("@")));
    const decodedData = deepMapValues(dataProperties, (value, recurse) => {
      if (isEncodedReferenceJSON(value)) {
        return decodeReferenceJSON(value);
      } else {
        return recurse(value);
      }
    });
    const core = new ObjectCore();
    core.id = id;
    core.initNewObject(decodedData, {
      meta
    });
    core.setType(decodeReferenceJSON(type));
    if (deleted) {
      core.setDeleted(deleted);
    }
    database.coreDatabase.addCore(core);
  }
};
var isEncodedReferenceJSON = (value) => typeof value === "object" && value !== null && ("/" in value || value["@type"] === LEGACY_REFERENCE_TYPE_TAG);
var decodeReferenceJSON = (encoded) => {
  if (typeof encoded === "object" && encoded !== null && "/" in encoded) {
    return decodeReference(encoded);
  } else if (typeof encoded === "string") {
    return Reference.fromLegacyTypename(encoded);
  }
};
var chunkArray = (arr, chunkSize) => {
  if (arr.length === 0 || chunkSize < 1) {
    return [];
  }
  let index = 0;
  let resIndex = 0;
  const result = new Array(Math.ceil(arr.length / chunkSize));
  while (index < arr.length) {
    result[resIndex++] = arr.slice(index, index += chunkSize);
  }
  return result;
};
var serializeEchoData = (data) => deepMapValues(data, (value, recurse) => {
  if (value instanceof Reference) {
    return encodeReference(value);
  }
  return recurse(value);
});

// packages/core/echo/echo-db/src/serialized-space.ts
import { deepMapValuesAsync } from "@dxos/util";
var normalizeSerializedObjectData = async (data) => {
  data = await deepMapValuesAsync(data, async (value, recurse) => {
    return recurse(value);
  });
  if (data["@timestamp"]) {
    data["@timestamp"] = new Date(data["@timestamp"]).toISOString();
  }
  return data;
};

// packages/core/echo/echo-db/src/text.ts
import { next as A } from "@automerge/automerge";
import { invariant as invariant2 } from "@dxos/invariant";
import { isLiveObject } from "@dxos/live-object";
import { get } from "@dxos/util";
var __dxlog_file2 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-db/src/text.ts";
var toCursor = (accessor, pos, assoc = 0) => {
  const doc = accessor.handle.doc();
  if (!doc) {
    return "";
  }
  const value = get(doc, accessor.path);
  if (typeof value === "string" && value.length <= pos) {
    return "end";
  }
  return A.getCursor(doc, accessor.path.slice(), pos);
};
var toCursorRange = (accessor, start, end) => {
  return `${toCursor(accessor, start)}:${toCursor(accessor, end)}`;
};
var fromCursor = (accessor, cursor) => {
  if (cursor === "") {
    return 0;
  }
  const doc = accessor.handle.doc();
  if (!doc) {
    return 0;
  }
  if (cursor === "end") {
    const value = get(doc, accessor.path);
    if (typeof value === "string") {
      return value.length;
    } else {
      return 0;
    }
  }
  return A.getCursorPosition(doc, accessor.path.slice(), cursor);
};
var getTextInRange = (accessor, start, end) => {
  const doc = accessor.handle.doc();
  const value = get(doc, accessor.path);
  if (typeof value === "string") {
    const beginIdx = fromCursor(accessor, start);
    const endIdx = fromCursor(accessor, end);
    if (beginIdx <= value.length) {
      return value.slice(beginIdx, endIdx);
    }
  }
};
var getRangeFromCursor = (accessor, cursor) => {
  const [start, end] = cursor.split(":");
  if (start === void 0 || end === void 0) {
    return void 0;
  }
  return {
    start: fromCursor(accessor, start),
    end: fromCursor(accessor, end)
  };
};
var updateText = (obj, path, newText) => {
  invariant2(isLiveObject(obj), void 0, {
    F: __dxlog_file2,
    L: 94,
    S: void 0,
    A: [
      "isLiveObject(obj)",
      ""
    ]
  });
  invariant2(path === void 0 || isValidKeyPath(path), void 0, {
    F: __dxlog_file2,
    L: 95,
    S: void 0,
    A: [
      "path === undefined || isValidKeyPath(path)",
      ""
    ]
  });
  const accessor = createDocAccessor(obj, path);
  accessor.handle.change((doc) => {
    A.updateText(doc, accessor.path.slice(), newText);
  });
  return obj;
};

// packages/core/echo/echo-db/src/util/devtools-formatter.ts
import { objectData } from "@dxos/live-object";
var idStyle = {
  style: "color: #777"
};
var listStyle = {
  style: "list-style-type: none; padding: 0; margin: 0 0 0 12px; font-style: normal; position: relative"
};
var liStyle = {
  style: "min-height: 16px;"
};
var nestedObjectContainerStyle = {
  style: "margin: -2px 0 0; display: inline-flex"
};
var keyStyle = {
  style: "color: #881391"
};
var defaultValueKeyStyle = {
  style: "color: #777"
};
var alteredValueKeyStyle = {
  style: "color: #881391; font-weight: bolder"
};
var nullStyle = {
  style: "color: #777"
};
var defaultKeys = [
  "id",
  "__typename",
  "__schema",
  "meta"
];
var getHeader = (obj, config) => {
  return [
    "span",
    {
      style: (config?.nested ? "padding: 2px 0 0;" : "") + "\n height: 18px;"
    },
    `${obj[Symbol.toStringTag]}`,
    [
      "span",
      idStyle,
      `#${obj.id}`
    ]
  ];
};
var formatValue = (object, config) => {
  if (typeof object === "undefined") {
    return [
      "span",
      nullStyle,
      "undefined"
    ];
  } else if (object === "null") {
    return [
      "span",
      nullStyle,
      "null"
    ];
  } else {
    return [
      "span",
      nestedObjectContainerStyle,
      [
        "object",
        {
          object,
          config
        }
      ]
    ];
  }
};
var getBody = (obj) => {
  const objData = obj[objectData];
  return [
    "ol",
    listStyle,
    ...Object.keys(objData).map((key) => [
      "li",
      liStyle,
      [
        "span",
        defaultKeys.includes(key) ? keyStyle : key.startsWith("[[") ? defaultValueKeyStyle : alteredValueKeyStyle,
        key
      ],
      [
        "span",
        {},
        ": "
      ],
      formatValue(objData[key], {
        nested: true
      })
    ])
  ];
};

// packages/core/echo/echo-db/src/util/migrate-document.ts
import { next as am } from "@automerge/automerge";
import { invariant as invariant3 } from "@dxos/invariant";
import { log } from "@dxos/log";
var __dxlog_file3 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-db/src/util/migrate-document.ts";
var migrateDocument = (source, targetData) => {
  log("begin migration", {
    source,
    targetData
  }, {
    F: __dxlog_file3,
    L: 14,
    S: void 0,
    C: (f, a) => f(...a)
  });
  const clonedDoc = am.clone(source);
  const changedDoc = am.change(clonedDoc, (applyTo) => {
    const coalesce = (applyTo2, targetData2) => {
      invariant3(typeof applyTo2 === "object" && applyTo2 !== null, void 0, {
        F: __dxlog_file3,
        L: 20,
        S: void 0,
        A: [
          "typeof applyTo === 'object' && applyTo !== null",
          ""
        ]
      });
      invariant3(typeof targetData2 === "object" && targetData2 !== null, void 0, {
        F: __dxlog_file3,
        L: 21,
        S: void 0,
        A: [
          "typeof targetData === 'object' && targetData !== null",
          ""
        ]
      });
      for (const key in targetData2) {
        if (targetData2[key] !== applyTo2[key]) {
          if (typeof targetData2[key] === "object" && targetData2[key] !== null) {
            if (Array.isArray(targetData2[key]) && !Array.isArray(applyTo2[key])) {
              applyTo2[key] = [];
            } else if (typeof applyTo2[key] !== "object" || applyTo2[key] === null) {
              applyTo2[key] = {};
            }
            coalesce(applyTo2[key], targetData2[key]);
          } else {
            applyTo2[key] = targetData2[key];
          }
        }
      }
      for (const key in applyTo2) {
        if (!(key in targetData2)) {
          delete applyTo2[key];
        }
      }
    };
    coalesce(applyTo, targetData);
  });
  log("end migration", {
    changedDoc
  }, {
    F: __dxlog_file3,
    L: 51,
    S: void 0,
    C: (f, a) => f(...a)
  });
  return changedDoc;
};
export {
  CoreDatabase,
  DocAccessor,
  DocHandleProxy,
  EchoClient,
  EchoDatabaseImpl,
  EchoReactiveHandler,
  EchoSchemaRegistry,
  Filter,
  GraphQueryContext,
  Hypergraph,
  META_NAMESPACE,
  MemoryQueue,
  MockQueueService,
  OBJECT_DIAGNOSTICS,
  ObjectCore,
  ObjectVersion,
  Query,
  QueryResult,
  Queue,
  QueueFactory,
  QueueImpl,
  QueueServiceImpl,
  QueueServiceStub,
  RepoProxy,
  ResultFormat,
  Serializer,
  SpaceQuerySource,
  checkoutVersion,
  clone,
  createDocAccessor,
  createObject,
  createSubscription,
  decodeReferenceJSON,
  defineObjectMigration,
  findObjectWithForeignKey,
  fromCursor,
  getBody,
  getDatabaseFromObject,
  getEditHistory,
  getHeader,
  getObjectCore,
  getRangeFromCursor,
  getReferenceWithSpaceKey,
  getSource,
  getTarget,
  getTargetSpacesForQuery,
  getTextInRange,
  getVersion,
  initEchoReactiveObjectRootProxy,
  isEchoObject,
  isRelation,
  isSimpleSelectionQuery,
  isValidKeyPath,
  loadObject,
  loadObjectReferences,
  matchKeys,
  migrateDocument,
  normalizeQuery,
  normalizeSerializedObjectData,
  objectIsUpdated,
  optionsToProto,
  prohibitSignalActions,
  toCursor,
  toCursorRange,
  updateText
};
//# sourceMappingURL=index.mjs.map
