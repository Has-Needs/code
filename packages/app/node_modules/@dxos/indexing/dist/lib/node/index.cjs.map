{
  "version": 3,
  "sources": ["../../../src/indexer.ts", "../../../src/indexes/index-text.ts", "../../../src/indexes/text.ts", "../../../src/types.ts", "../../../src/indexes/index-schema.ts", "../../../src/indexes/index-constructors.ts", "../../../src/indexes/index-graph.ts", "../../../src/indexes/index-vector.ts", "../../../src/indexes/embeddings.ts", "../../../src/indexing-engine.ts", "../../../src/store/index-store.ts", "../../../src/store/index-metadata-store.ts"],
  "sourcesContent": ["//\n// Copyright 2024 DXOS.org\n//\n\nimport isEqual from 'lodash.isequal';\n\nimport { DeferredTask, Event, sleepWithContext, synchronized } from '@dxos/async';\nimport { type Context, LifecycleState, Resource } from '@dxos/context';\nimport { invariant } from '@dxos/invariant';\nimport { type LevelDB } from '@dxos/kv-store';\nimport { log } from '@dxos/log';\nimport { IndexKind, type IndexConfig } from '@dxos/protocols/proto/dxos/echo/indexing';\nimport { trace } from '@dxos/tracing';\n\nimport { IndexConstructors } from './indexes';\nimport { IndexingEngine } from './indexing-engine';\nimport { type IndexMetadataStore, type IndexStore } from './store';\nimport { type FindResult, type IdToHeads, type IndexQuery, type ObjectSnapshot } from './types';\n\nconst DEFAULT_INDEX_UPDATE_BATCH_SIZE = 100;\n\nconst DEFAULT_INDEX_COOLDOWN_TIME = 100;\n\nconst DEFAULT_INDEX_TIME_BUDGET = 300;\n\nexport type IndexerParams = {\n  db: LevelDB;\n\n  metadataStore: IndexMetadataStore;\n  indexStore: IndexStore;\n\n  /**\n   * Load documents by their pointers at specific hash.\n   */\n  loadDocuments: (ids: IdToHeads) => AsyncGenerator<ObjectSnapshot[]>;\n\n  /**\n   * Amount of documents processed in a batch to save indexes after.\n   */\n  indexUpdateBatchSize?: number;\n\n  /**\n   * Minimum time between indexing runs.\n   */\n  indexCooldownTime?: number;\n\n  /**\n   * Time budget for indexing run.\n   * Does not cover creating new indexes.\n   */\n  indexTimeBudget?: number;\n};\n\n// TODO(burdon): Rename package @dxos/indexer?\n@trace.resource()\nexport class Indexer extends Resource {\n  public readonly updated = new Event<void>();\n\n  private readonly _db: LevelDB;\n  private readonly _metadataStore: IndexMetadataStore;\n  private readonly _engine: IndexingEngine;\n\n  private readonly _indexUpdateBatchSize: number;\n  private readonly _indexCooldownTime: number;\n  private readonly _indexTimeBudget: number;\n\n  private _indexConfig?: IndexConfig;\n  private _lastRunFinishedAt = 0;\n  private _run!: DeferredTask;\n\n  constructor({\n    db,\n    metadataStore,\n    indexStore,\n    loadDocuments,\n    indexUpdateBatchSize = DEFAULT_INDEX_UPDATE_BATCH_SIZE,\n    indexCooldownTime = DEFAULT_INDEX_COOLDOWN_TIME,\n    indexTimeBudget = DEFAULT_INDEX_TIME_BUDGET,\n  }: IndexerParams) {\n    super();\n    this._db = db;\n    this._metadataStore = metadataStore;\n    this._indexUpdateBatchSize = indexUpdateBatchSize;\n    this._indexCooldownTime = indexCooldownTime;\n    this._indexTimeBudget = indexTimeBudget;\n    this._engine = new IndexingEngine({\n      db,\n      metadataStore,\n      indexStore,\n      documentLoader: {\n        loadDocuments,\n      },\n    });\n  }\n\n  get initialized() {\n    return this._lifecycleState === LifecycleState.OPEN;\n  }\n\n  @synchronized\n  // TODO(mykola): Make it iterative (e.g. `initConfig(<index1>); initConfig(<index2>); ...`).\n  async setConfig(config: IndexConfig): Promise<void> {\n    this._indexConfig = config;\n    if (this._lifecycleState === LifecycleState.OPEN) {\n      log.warn('Setting index config after initialization, this is unstable', { config });\n      for (const kind of this._engine.indexKinds) {\n        if (!config.indexes?.some((kind) => isEqual(kind, kind))) {\n          this._engine.deleteIndex(kind);\n        }\n      }\n      await this._loadIndexes();\n      this._run.schedule();\n    }\n  }\n\n  @trace.span({ showInBrowserTimeline: true })\n  protected override async _open(ctx: Context): Promise<void> {\n    if (!this._indexConfig) {\n      log.warn('Index config is not set');\n    }\n\n    await this._engine.open(ctx);\n\n    // Needs to be re-created because context changes.\n    // TODO(dmaretskyi): Find a way to express this better for resources.\n    this._run = new DeferredTask(this._ctx, async () => {\n      try {\n        if (this._lifecycleState !== LifecycleState.OPEN || this._indexConfig?.enabled !== true) {\n          return;\n        }\n\n        const cooldownMs = this._lastRunFinishedAt + this._indexCooldownTime - Date.now();\n        if (cooldownMs > 0) {\n          await sleepWithContext(this._ctx, cooldownMs);\n        }\n\n        if (this._engine.newIndexCount > 0) {\n          await this._promoteNewIndexes();\n        }\n        await this._indexUpdatedObjects();\n      } finally {\n        this._lastRunFinishedAt = Date.now();\n      }\n    });\n\n    // Load indexes from disk.\n    await this._loadIndexes();\n\n    if (this._indexConfig?.enabled === true) {\n      this._metadataStore.dirty.on(this._ctx, () => this._run.schedule());\n      this._run.schedule();\n    }\n  }\n\n  protected override async _close(ctx: Context): Promise<void> {\n    await this._run.join();\n    await this._engine.close(ctx);\n  }\n\n  protected override async _catch(err: Error): Promise<void> {\n    // TODO(dmaretskyi): Better error handling.\n    log.catch(err);\n  }\n\n  // TODO(dmaretskyi): Allow consumers to get specific index instances and query them directly.\n  @synchronized\n  async execQuery(filter: IndexQuery): Promise<FindResult[]> {\n    if (this._lifecycleState !== LifecycleState.OPEN || this._indexConfig?.enabled !== true) {\n      // TODO(burdon): Unexpectedly thrown in query.test.ts.\n      throw new Error('Indexer is not initialized or not enabled');\n    }\n\n    if (filter.graph) {\n      const graphIndex = this._engine.getIndex({ kind: IndexKind.Kind.GRAPH });\n      if (!graphIndex) {\n        // TODO(dmaretskyi): This shouldn't be the default?\n        return [];\n      }\n      return graphIndex.find(filter);\n    } else if (filter.text?.kind === 'vector') {\n      const vectorIndex = this._engine.getIndex({ kind: IndexKind.Kind.VECTOR });\n      if (!vectorIndex) {\n        // TODO(dmaretskyi): This shouldn't be the default?\n        return [];\n      }\n      return vectorIndex.find(filter);\n    } else if (filter.text?.kind === 'text') {\n      const textIndex = this._engine.getIndex({ kind: IndexKind.Kind.FULL_TEXT });\n      if (!textIndex) {\n        // TODO(dmaretskyi): This shouldn't be the default?\n        return [];\n      }\n      return textIndex.find(filter);\n    } else {\n      const typenameIndex = this._engine.getIndex({ kind: IndexKind.Kind.SCHEMA_MATCH });\n      if (!typenameIndex) {\n        // TODO(dmaretskyi): This shouldn't be the default?\n        return [];\n      }\n      return typenameIndex.find(filter);\n    }\n  }\n\n  @trace.span({ showInBrowserTimeline: true })\n  async reindex(idToHeads: IdToHeads): Promise<void> {\n    const batch = this._db.batch();\n    this._metadataStore.markDirty(idToHeads, batch);\n    this._metadataStore.dropFromClean(Array.from(idToHeads.keys()), batch);\n    await batch.write();\n    await this._run.runBlocking();\n  }\n\n  /**\n   * Perform any pending index updates.\n   */\n  async updateIndexes(): Promise<void> {\n    await this._run.runBlocking();\n  }\n\n  private async _loadIndexes(): Promise<void> {\n    const kinds = await this._engine.loadIndexKindsFromDisk();\n    for (const [identifier, kind] of kinds.entries()) {\n      if (!this._indexConfig || this._indexConfig.indexes?.some((configKind) => isEqual(configKind, kind))) {\n        try {\n          await this._engine.loadIndexFromDisk(identifier);\n        } catch (err) {\n          log.warn('Failed to load index', { err, identifier });\n        }\n      } else {\n        // Note: We remove indexes that are not used\n        //       to not store indexes that are getting out of sync with database.\n        await this._engine.removeIndexFromDisk(identifier);\n      }\n    }\n\n    // Create indexes that are not loaded from disk.\n    for (const kind of this._indexConfig?.indexes || []) {\n      if (!this._engine.getIndex(kind)) {\n        const IndexConstructor = IndexConstructors[kind.kind];\n        invariant(IndexConstructor, `Index kind ${kind.kind} is not supported`);\n        // Note: New indexes are not saved to disk until they are promoted.\n        //       New Indexes will be promoted to `_indexes` map on indexing job run.\n        await this._engine.addNewIndex(new IndexConstructor(kind));\n      }\n    }\n  }\n\n  @trace.span({ showInBrowserTimeline: true })\n  private async _promoteNewIndexes(): Promise<void> {\n    await this._engine.promoteNewIndexes();\n    this.updated.emit();\n  }\n\n  @trace.span({ showInBrowserTimeline: true })\n  private async _indexUpdatedObjects(): Promise<void> {\n    if (this._ctx.disposed) {\n      return;\n    }\n\n    const { completed, updated } = await this._engine.indexUpdatedObjects({\n      indexTimeBudget: this._indexTimeBudget,\n      indexUpdateBatchSize: this._indexUpdateBatchSize,\n    });\n\n    if (!completed) {\n      this._run.schedule();\n    }\n\n    if (updated) {\n      this.updated.emit();\n    }\n  }\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport * as Orama from '@orama/orama';\n\nimport { Event } from '@dxos/async';\nimport { Resource } from '@dxos/context';\nimport { type ObjectStructure } from '@dxos/echo-protocol';\nimport { invariant } from '@dxos/invariant';\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport type { ObjectPointerEncoded } from '@dxos/protocols';\nimport { IndexKind } from '@dxos/protocols/proto/dxos/echo/indexing';\nimport { trace } from '@dxos/tracing';\n\nimport { extractTextBlocks } from './text';\nimport {\n  type IndexQuery,\n  staticImplements,\n  type Index,\n  type IndexStaticProps,\n  type LoadParams,\n  type FindResult,\n} from '../types';\n\n// Note: By default, Orama search returns 10 results.\n// const ORAMA_LIMIT = 1_000_000;\n\ntype OramaSchemaType = Orama.Orama<\n  {\n    chunks: 'string[]';\n  },\n  Orama.IIndex<Orama.components.index.Index>,\n  Orama.IDocumentsStore<Orama.components.documentsStore.DocumentsStore>\n>;\n\n@trace.resource()\n@staticImplements<IndexStaticProps>()\nexport class IndexText extends Resource implements Index {\n  private _identifier = PublicKey.random().toString();\n  public readonly kind: IndexKind = { kind: IndexKind.Kind.FULL_TEXT };\n  public readonly updated = new Event<void>();\n\n  private _orama?: OramaSchemaType = undefined;\n\n  override async _open(): Promise<void> {\n    this._orama = await Orama.create({\n      schema: {\n        chunks: 'string[]',\n      },\n    });\n  }\n\n  get identifier() {\n    return this._identifier;\n  }\n\n  @trace.span({ showInBrowserTimeline: true })\n  async update(id: ObjectPointerEncoded, object: Partial<ObjectStructure>): Promise<boolean> {\n    const blocks = extractTextBlocks(object);\n\n    invariant(this._orama, 'Index is not initialized');\n    await Orama.remove(this._orama, id);\n    await Orama.insert(this._orama, {\n      id,\n      chunks: blocks.map((block) => block.content),\n    });\n    return true;\n  }\n\n  async remove(id: ObjectPointerEncoded): Promise<void> {\n    invariant(this._orama, 'Index is not initialized');\n    await Orama.remove(this._orama, id);\n  }\n\n  @trace.span({ showInBrowserTimeline: true })\n  async find(filter: IndexQuery): Promise<FindResult[]> {\n    invariant(filter.typenames.length === 0, 'Typenames are not supported');\n    invariant(!filter.inverted, 'Inverted search is not supported');\n    invariant(!filter.graph, 'Graph search is not supported');\n    invariant(typeof filter.text?.query === 'string');\n    invariant(filter.text?.kind === 'text');\n\n    invariant(this._orama, 'Index is not initialized');\n    const results = await Orama.search(this._orama, {\n      mode: 'fulltext',\n      term: filter.text.query,\n\n      // TODO(dmaretskyi): Add a way to configure these.\n      limit: 10, // Defaults to `10`\n      offset: 0, // Defaults to `0`\n    });\n\n    log.info('Text search results', { query: filter.text.query, results });\n\n    return results.hits.map((hit) => ({\n      id: hit.id,\n      rank: hit.score,\n    })); // TODO(dmaretskyi): This re-runs all queries even if nothing changed.\n  }\n\n  @trace.span({ showInBrowserTimeline: true })\n  async serialize(): Promise<string> {\n    invariant(this._orama, 'Index is not initialized');\n    return JSON.stringify(await Orama.save(this._orama), null, 2);\n  }\n\n  @trace.span({ showInBrowserTimeline: true })\n  static async load({ serialized, identifier }: LoadParams): Promise<IndexText> {\n    const deserialized = JSON.parse(serialized);\n\n    const index = new IndexText();\n    await index.open();\n    invariant(index._orama, 'Index is not initialized');\n    index._identifier = identifier;\n    await Orama.load(index._orama, deserialized);\n    return index;\n  }\n}\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { decodeReference, isEncodedReference, ObjectStructure } from '@dxos/echo-protocol';\nimport { visitValues } from '@dxos/util';\n\n/**\n * Types that are excluded from text indexing.\n */\nconst IGNORED_TYPENAMES: string[] = ['dxos.org/type/Canvas'];\n\nexport type ExtractInputBlock = {\n  content: string;\n\n  /**\n   * The weight of the block.\n   */\n  // TODO(dmaretskyi): Currently not supported.\n  weight?: number;\n};\n\n/**\n * Extracts all text field values from an object.\n */\nexport const extractTextBlocks = (object: Partial<ObjectStructure>): ExtractInputBlock[] => {\n  const type = ObjectStructure.getTypeReference(object as any);\n  const dxnType = type && decodeReference(type).toDXN();\n\n  if (IGNORED_TYPENAMES.includes(dxnType?.asTypeDXN()?.type ?? '')) {\n    return [];\n  }\n\n  const blocks: ExtractInputBlock[] = [];\n\n  const go = (value: any, _key: string | number) => {\n    if (isEncodedReference(value)) {\n      return;\n    }\n    if (typeof value === 'string') {\n      blocks.push({ content: value });\n    }\n    visitValues(value, go);\n  };\n  visitValues(object.data, go);\n\n  return blocks;\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { type Heads } from '@automerge/automerge';\nimport { Schema } from 'effect';\nimport type { SchemaClass } from 'effect/Schema';\n\nimport { type Event } from '@dxos/async';\nimport { type ObjectPropPath, type ObjectStructure } from '@dxos/echo-protocol';\nimport type { ObjectId } from '@dxos/echo-schema';\nimport { invariant } from '@dxos/invariant';\nimport { type ObjectPointerEncoded } from '@dxos/protocols';\nimport { type IndexKind } from '@dxos/protocols/proto/dxos/echo/indexing';\n\n/**\n * Unified query interface for all indexes.\n * @deprecated To be replaced by a specialized API for each index.\n */\n// TODO(burdon): Reconcile with proto def.\nexport type IndexQuery = {\n  /**\n   * empty array means all objects (no filter).\n   */\n  typenames: string[];\n\n  // TODO(burdon): Hack to exclude.\n  inverted?: boolean;\n\n  /**\n   * Graph-based search.\n   */\n  graph?: {\n    /**\n     * Relation kind.\n     */\n    kind: 'inbound-reference' | 'relation-source' | 'relation-target';\n\n    /**\n     * anchor objects to search from.\n     */\n    anchors: ObjectId[];\n\n    /**\n     * Filter by property name.\n     * Only when kind is 'inbound-reference'.\n     */\n    property: EscapedPropPath | null;\n  };\n\n  text?: {\n    query: string;\n\n    kind: 'vector' | 'text';\n  };\n};\n\nexport type ObjectSnapshot = {\n  /**\n   * Object ID in the indexer format.\n   */\n  id: ObjectPointerEncoded;\n  object: ObjectStructure;\n  heads: Heads;\n};\n\nexport type IdToHeads = Map<ObjectPointerEncoded, Heads>;\nexport type FindResult = { id: ObjectPointerEncoded; rank: number };\n\nexport interface Index {\n  identifier: string;\n  kind: IndexKind;\n  updated: Event;\n\n  open(): Promise<Index>;\n  close(): Promise<Index>;\n\n  /**\n   * Add an object to the index.\n   * @returns {Promise<boolean>} true if the index was updated, false otherwise.\n   */\n  update(id: ObjectPointerEncoded, object: ObjectStructure): Promise<boolean>;\n\n  /**\n   * Remove an object from the index.\n   */\n  remove(id: ObjectPointerEncoded): Promise<void>;\n\n  // TODO(dmaretskyi): Remove from interface -- Each index has its own query api.\n  find(filter: IndexQuery): Promise<FindResult[]>;\n\n  serialize(): Promise<string>;\n}\n\nexport type LoadParams = { serialized: string; indexKind: IndexKind; identifier: string };\n\nexport interface IndexStaticProps {\n  new (kind: IndexKind): Index;\n  load(params: LoadParams): Promise<Index>;\n}\n\n/**\n * Type-only annotation to assert that a class-constructor implements an interface T (with it's static methods).\n */\nexport const staticImplements =\n  <T>() =>\n  <U extends T>(constructor: U) => {\n    return constructor;\n  };\n\n/**\n * Escaped property path within an object.\n *\n * Escaping rules:\n *\n * - '.' -> '\\.'\n * - '\\' -> '\\\\'\n * - contact with .\n */\nexport const EscapedPropPath: SchemaClass<string, string> & {\n  escape: (path: ObjectPropPath) => EscapedPropPath;\n  unescape: (path: EscapedPropPath) => ObjectPropPath;\n} = class extends Schema.String.annotations({ title: 'EscapedPropPath' }) {\n  static escape(path: ObjectPropPath): EscapedPropPath {\n    return path.map((p) => p.toString().replaceAll('\\\\', '\\\\\\\\').replaceAll('.', '\\\\.')).join('.');\n  }\n\n  static unescape(path: EscapedPropPath): ObjectPropPath {\n    const parts: string[] = [];\n    let current = '';\n\n    for (let i = 0; i < path.length; i++) {\n      if (path[i] === '\\\\') {\n        invariant(i + 1 < path.length && (path[i + 1] === '.' || path[i + 1] === '\\\\'), 'Malformed escaping.');\n        current = current + path[i + 1];\n        i++;\n      } else if (path[i] === '.') {\n        parts.push(current);\n        current = '';\n      } else {\n        current += path[i];\n      }\n    }\n    parts.push(current);\n\n    return parts;\n  }\n};\nexport type EscapedPropPath = Schema.Schema.Type<typeof EscapedPropPath>;\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { Event } from '@dxos/async';\nimport { Resource } from '@dxos/context';\nimport { decodeReference, type ObjectStructure } from '@dxos/echo-protocol';\nimport { EXPANDO_TYPENAME } from '@dxos/echo-schema';\nimport { DXN, PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { type ObjectPointerEncoded } from '@dxos/protocols';\nimport { IndexKind } from '@dxos/protocols/proto/dxos/echo/indexing';\nimport { trace } from '@dxos/tracing';\nimport { defaultMap } from '@dxos/util';\n\nimport {\n  type FindResult,\n  type Index,\n  type IndexQuery,\n  type IndexStaticProps,\n  type LoadParams,\n  staticImplements,\n} from '../types';\n\n/**\n * Indexes objects by their typename.\n */\n@trace.resource()\n@staticImplements<IndexStaticProps>()\nexport class IndexSchema extends Resource implements Index {\n  private _identifier = PublicKey.random().toString();\n  public readonly kind: IndexKind = { kind: IndexKind.Kind.SCHEMA_MATCH };\n  public readonly updated = new Event<void>();\n\n  /**\n   * Map `typename` -> Set `index id`.\n   * @see https://v8.dev/blog/hash-code for performance estimations.\n   */\n  private readonly _index = new Map<string | null, Set<ObjectPointerEncoded>>();\n\n  get identifier() {\n    return this._identifier;\n  }\n\n  @trace.span({ showInBrowserTimeline: true })\n  async update(id: ObjectPointerEncoded, object: Partial<ObjectStructure>): Promise<boolean> {\n    if (this._index.get(getTypeFromObject(object))?.has(id)) {\n      return false;\n    }\n    defaultMap(this._index, getTypeFromObject(object), new Set()).add(id);\n    return true;\n  }\n\n  async remove(id: ObjectPointerEncoded): Promise<void> {\n    for (const [_, ids] of this._index.entries()) {\n      if (ids.has(id)) {\n        ids.delete(id);\n        return;\n      }\n    }\n  }\n\n  @trace.span({ showInBrowserTimeline: true })\n  async find(filter: IndexQuery): Promise<FindResult[]> {\n    // TODO(burdon): Handle inversion.\n    if (filter.inverted) {\n      return Array.from(this._index.entries())\n        .filter(([key]) => !filter.typenames.includes(key ?? EXPANDO_TYPENAME) === false)\n        .flatMap(([, value]) => Array.from(value))\n        .map((id) => ({ id, rank: 0 }));\n    }\n\n    if (filter.typenames.length === 0) {\n      return Array.from(this._index.values())\n        .flatMap((ids) => Array.from(ids))\n        .map((id) => ({ id, rank: 0 }));\n    }\n\n    const results: FindResult[] = [];\n    for (const typename of filter.typenames) {\n      if (\n        typename === EXPANDO_TYPENAME ||\n        (DXN.isDXNString(typename) && DXN.parse(typename).asTypeDXN()?.type === EXPANDO_TYPENAME)\n      ) {\n        results.push(...Array.from(this._index.get(null) ?? []).map((id) => ({ id, rank: 0 })));\n      } else if (DXN.isDXNString(typename)) {\n        const dxn = DXN.parse(typename);\n        if (dxn.isLocalObjectId()) {\n          const objectId = dxn.parts[1];\n          results.push(...Array.from(this._index.get(objectId) ?? []).map((id) => ({ id, rank: 0 })));\n        } else if (dxn.kind === DXN.kind.TYPE) {\n          const typename = dxn.parts[0];\n          results.push(...Array.from(this._index.get(typename) ?? []).map((id) => ({ id, rank: 0 })));\n        } else {\n          log.warn('Unsupported DXN', { dxn });\n        }\n      } else {\n        results.push(...Array.from(this._index.get(typename) ?? []).map((id) => ({ id, rank: 0 })));\n      }\n    }\n    return results.flat();\n  }\n\n  @trace.span({ showInBrowserTimeline: true })\n  async serialize(): Promise<string> {\n    return JSON.stringify({\n      index: Array.from(this._index.entries()).map(([type, ids]) => ({\n        type,\n        ids: Array.from(ids),\n      })),\n    });\n  }\n\n  @trace.span({ showInBrowserTimeline: true })\n  static async load({ serialized, identifier }: LoadParams): Promise<IndexSchema> {\n    const index = new IndexSchema();\n    const serializedIndex: { type: string | null; ids: string[] }[] = JSON.parse(serialized).index;\n    index._identifier = identifier;\n    for (const { type, ids } of serializedIndex) {\n      index._index.set(type, new Set(ids));\n    }\n    return index;\n  }\n}\n\nconst getTypeFromObject = (object: Partial<ObjectStructure>): string | null =>\n  object.system?.type ? decodeReference(object.system.type).objectId ?? null : null;\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { IndexKind } from '@dxos/protocols/proto/dxos/echo/indexing';\n\nimport { IndexGraph } from './index-graph';\nimport { IndexSchema } from './index-schema';\nimport { IndexText } from './index-text';\nimport { IndexVector } from './index-vector';\nimport { type IndexStaticProps } from '../types';\n\nexport const IndexConstructors: { [key in IndexKind['kind']]?: IndexStaticProps } = {\n  [IndexKind.Kind.SCHEMA_MATCH]: IndexSchema,\n  [IndexKind.Kind.GRAPH]: IndexGraph,\n  [IndexKind.Kind.VECTOR]: IndexVector,\n  [IndexKind.Kind.FULL_TEXT]: IndexText,\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { pipe, Schema } from 'effect';\n\nimport { Event } from '@dxos/async';\nimport { Resource } from '@dxos/context';\nimport { decodeReference, ObjectStructure } from '@dxos/echo-protocol';\nimport { EntityKind, ObjectId } from '@dxos/echo-schema';\nimport { InternalError } from '@dxos/errors';\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { ObjectPointerEncoded } from '@dxos/protocols';\nimport { IndexKind } from '@dxos/protocols/proto/dxos/echo/indexing';\nimport { trace } from '@dxos/tracing';\nimport { defaultMap, entries } from '@dxos/util';\n\nimport {\n  EscapedPropPath,\n  type FindResult,\n  type Index,\n  type IndexQuery,\n  type IndexStaticProps,\n  type LoadParams,\n  staticImplements,\n} from '../types';\n\n/**\n * Indexes graph relationships between objects.\n * Includes incoming references for relations as well.\n */\n@trace.resource()\n@staticImplements<IndexStaticProps>()\nexport class IndexGraph extends Resource implements Index {\n  private _identifier = PublicKey.random().toString();\n  public readonly kind: IndexKind = { kind: IndexKind.Kind.GRAPH };\n  public readonly updated = new Event<void>();\n\n  /**\n   * Tracks inbound references for each object.\n   *\n   * target object id -> prop name -> set of source object ids\n   */\n  private readonly _inboundReferences = new Map<ObjectId, Map<string, Set<ObjectPointerEncoded>>>();\n\n  /**\n   * Tracks relation targets for each object.\n   *\n   * relation target object id -> set of relation ids\n   */\n  private readonly _relationTargets = new Map<ObjectId, Set<ObjectPointerEncoded>>();\n\n  /**\n   * Tracks relation sources for each object.\n   *\n   * relation source object id -> set of relation ids\n   */\n  private readonly _relationSources = new Map<ObjectId, Set<ObjectPointerEncoded>>();\n\n  /**\n   * Mapping from the object to the list of reference targets.\n   * We need this because on index update we don't know what the previous version of the object was.\n   * This mapping is used to remove the old relations on update.\n   */\n  // TODO(dmaretskyi): Index should have access to the previous state on update.\n  private readonly _objectToTargets = new Map<ObjectPointerEncoded, Set<ObjectId>>();\n\n  get identifier() {\n    return this._identifier;\n  }\n\n  @trace.span({ showInBrowserTimeline: true })\n  async update(id: ObjectPointerEncoded, object: ObjectStructure): Promise<boolean> {\n    const kind = ObjectStructure.getEntityKind(object);\n    switch (kind) {\n      case EntityKind.Object: {\n        // Clear old links.\n        this._removeReferencesFrom(id);\n        this._trackOutgoingReferences(id, object);\n\n        break;\n      }\n      case EntityKind.Relation: {\n        this._removeReferencesFrom(id);\n        this._trackOutgoingReferences(id, object);\n\n        const targetMapping = defaultMap(this._objectToTargets, id, () => new Set());\n        const source = ObjectStructure.getRelationSource(object);\n        const target = ObjectStructure.getRelationTarget(object);\n        if (source) {\n          const sourceObject = decodeReference(source).toDXN().asEchoDXN()?.echoId;\n          if (sourceObject) {\n            defaultMap(this._relationSources, sourceObject, () => new Set()).add(id);\n            targetMapping.add(sourceObject);\n          }\n        } else {\n          log.warn('relation has no source', { id });\n        }\n        if (target) {\n          const targetObject = decodeReference(target).toDXN().asEchoDXN()?.echoId;\n          if (targetObject) {\n            defaultMap(this._relationTargets, targetObject, () => new Set()).add(id);\n            targetMapping.add(targetObject);\n          }\n        } else {\n          log.warn('relation has no target', { id });\n        }\n        break;\n      }\n      default: {\n        log.warn('unknown entity kind', { kind });\n        break;\n      }\n    }\n\n    return true; // TODO(dmaretskyi): Actually check if anything changed. This will cause the index to be saved on every object change batch.\n  }\n\n  async remove(id: ObjectPointerEncoded): Promise<void> {\n    this._removeReferencesFrom(id);\n  }\n\n  private _removeReferencesFrom(id: ObjectPointerEncoded): void {\n    for (const target of this._objectToTargets.get(id) ?? []) {\n      const perField = this._inboundReferences.get(target);\n      if (!perField) {\n        continue;\n      }\n      // TODO(dmaretskyi): Not efficient, but unlikely to cause issues.\n      for (const field of perField.keys()) {\n        perField.get(field)?.delete(id);\n      }\n\n      // TODO(dmaretskyi): Technically relation endpoints cannot change, but we still track them here for safety.\n      this._relationTargets.get(target)?.delete(id);\n      this._relationSources.get(target)?.delete(id);\n    }\n\n    this._objectToTargets.get(id)?.clear();\n  }\n\n  private _trackOutgoingReferences(id: ObjectPointerEncoded, object: ObjectStructure): void {\n    const targetMapping = defaultMap(this._objectToTargets, id, () => new Set());\n\n    const references = ObjectStructure.getAllOutgoingReferences(object);\n    for (const { path, reference } of references) {\n      const targetObject = decodeReference(reference).toDXN().asEchoDXN()?.echoId;\n      if (!targetObject) {\n        continue;\n      }\n      const escapedPath = EscapedPropPath.escape(path);\n      pipe(\n        this._inboundReferences,\n        (map) => defaultMap(map, targetObject, () => new Map()),\n        (map) => defaultMap(map, escapedPath, () => new Set()),\n      ).add(id);\n\n      targetMapping.add(targetObject);\n    }\n  }\n\n  @trace.span({ showInBrowserTimeline: true })\n  async find(filter: IndexQuery): Promise<FindResult[]> {\n    if (filter.inverted || filter.typenames.length > 0 || !filter.graph) {\n      throw new InternalError('Invalid filter for graph query');\n    }\n\n    const { kind, anchors, property } = filter.graph;\n\n    switch (kind) {\n      case 'inbound-reference': {\n        const results: FindResult[] = [];\n        for (const anchor of anchors) {\n          const sources = this._inboundReferences.get(anchor);\n          if (!sources) {\n            continue;\n          }\n          if (property !== null) {\n            for (const [escapedProp, source] of sources.entries()) {\n              const prop = EscapedPropPath.unescape(escapedProp);\n              const firstSegmentMatches = prop[0] === property;\n              const secondSegmentIsNumeric = !isNaN(Number(prop[1]));\n              if (firstSegmentMatches && (prop.length === 1 || (prop.length === 2 && secondSegmentIsNumeric))) {\n                results.push(...Array.from(source).map((id) => ({ id, rank: 0 })));\n              }\n            }\n          } else {\n            for (const source of sources.values()) {\n              results.push(...Array.from(source).map((id) => ({ id, rank: 0 })));\n            }\n          }\n        }\n        return results;\n      }\n      case 'relation-source': {\n        const results: FindResult[] = [];\n        for (const anchor of anchors) {\n          const sources = this._relationSources.get(anchor);\n          if (!sources) {\n            continue;\n          }\n          results.push(...Array.from(sources).map((id) => ({ id, rank: 0 })));\n        }\n        return results;\n      }\n      case 'relation-target': {\n        const results: FindResult[] = [];\n        for (const anchor of anchors) {\n          const sources = this._relationTargets.get(anchor);\n          if (!sources) {\n            continue;\n          }\n          results.push(...Array.from(sources).map((id) => ({ id, rank: 0 })));\n        }\n        return results;\n      }\n      default: {\n        throw new TypeError('Unknown graph query kind');\n      }\n    }\n  }\n\n  @trace.span({ showInBrowserTimeline: true })\n  async serialize(): Promise<string> {\n    const data: GraphIndexData = {\n      inboundReferences: Object.fromEntries(\n        [...this._inboundReferences.entries()].map(([target, perProp]) => [\n          target,\n          Object.fromEntries([...perProp.entries()].map(([prop, sources]) => [prop, Array.from(sources)])),\n        ]),\n      ),\n      relationTargets: Object.fromEntries(\n        [...this._relationTargets.entries()].map(([target, sources]) => [target, Array.from(sources)]),\n      ),\n      relationSources: Object.fromEntries(\n        [...this._relationSources.entries()].map(([target, sources]) => [target, Array.from(sources)]),\n      ),\n      objectToTargets: Object.fromEntries(\n        [...this._objectToTargets.entries()].map(([target, sources]) => [target, Array.from(sources)]),\n      ),\n    };\n    return JSON.stringify(data);\n  }\n\n  @trace.span({ showInBrowserTimeline: true })\n  static async load({ serialized, identifier }: LoadParams): Promise<IndexGraph> {\n    const index = new IndexGraph();\n    await index.open();\n\n    const data = GraphIndexData.pipe(Schema.decodeUnknownSync)(JSON.parse(serialized));\n    index._loadFrom(data);\n    return index;\n  }\n\n  private _loadFrom(data: GraphIndexData): void {\n    this._inboundReferences.clear();\n    this._relationTargets.clear();\n    this._relationSources.clear();\n    this._objectToTargets.clear();\n\n    for (const [target, perProp] of entries(data.inboundReferences)) {\n      const propMap = new Map<string, Set<ObjectPointerEncoded>>();\n      this._inboundReferences.set(target, propMap);\n      for (const [prop, sources] of entries(perProp)) {\n        propMap.set(prop, new Set(sources));\n      }\n    }\n\n    for (const [target, sources] of entries(data.relationTargets)) {\n      this._relationTargets.set(target, new Set(sources));\n    }\n\n    for (const [target, sources] of entries(data.relationSources)) {\n      this._relationSources.set(target, new Set(sources));\n    }\n\n    for (const [target, sources] of entries(data.objectToTargets)) {\n      this._objectToTargets.set(target, new Set(sources));\n    }\n  }\n}\n\nconst GraphIndexData = Schema.Struct({\n  inboundReferences: Schema.Record({\n    key: ObjectId,\n    value: Schema.Record({\n      key: EscapedPropPath,\n      value: Schema.Array(ObjectPointerEncoded),\n    }),\n  }),\n  relationTargets: Schema.Record({\n    key: ObjectId,\n    value: Schema.Array(ObjectPointerEncoded),\n  }),\n  relationSources: Schema.Record({\n    key: ObjectId,\n    value: Schema.Array(ObjectPointerEncoded),\n  }),\n  objectToTargets: Schema.Record({\n    key: ObjectPointerEncoded,\n    value: Schema.Array(ObjectId),\n  }),\n});\ninterface GraphIndexData extends Schema.Schema.Type<typeof GraphIndexData> {}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport * as Orama from '@orama/orama';\n\nimport { Event } from '@dxos/async';\nimport { Resource } from '@dxos/context';\nimport { type ObjectStructure } from '@dxos/echo-protocol';\nimport { invariant } from '@dxos/invariant';\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport type { ObjectPointerEncoded } from '@dxos/protocols';\nimport { IndexKind } from '@dxos/protocols/proto/dxos/echo/indexing';\nimport { trace } from '@dxos/tracing';\n\nimport { EmbeddingExtractor } from './embeddings';\nimport { extractTextBlocks } from './text';\nimport {\n  type IndexQuery,\n  staticImplements,\n  type Index,\n  type IndexStaticProps,\n  type LoadParams,\n  type FindResult,\n} from '../types';\n\n// Note: By default, Orama search returns 10 results.\n// const ORAMA_LIMIT = 1_000_000;\n\n// Type of the Orama instance with the specific schema we're using\ntype OramaInstanceType = Orama.Orama<\n  {\n    embedding: `vector[${number}]`;\n  },\n  Orama.IIndex<Orama.components.index.Index>,\n  Orama.IDocumentsStore<Orama.components.documentsStore.DocumentsStore>\n>;\n\n// Must match the vector dimension of the embedding extractor.\nconst VECTOR_DIMENSION = 384;\n\n@trace.resource()\n@staticImplements<IndexStaticProps>()\nexport class IndexVector extends Resource implements Index {\n  private _identifier = PublicKey.random().toString();\n\n  private _extractor = new EmbeddingExtractor();\n\n  public readonly kind: IndexKind = { kind: IndexKind.Kind.VECTOR };\n  public readonly updated = new Event<void>();\n\n  private _orama?: OramaInstanceType = undefined;\n\n  override async _open(): Promise<void> {\n    await this._extractor.open();\n\n    this._orama = await Orama.create({\n      schema: {\n        embedding: `vector[${VECTOR_DIMENSION}]`,\n      },\n    });\n  }\n\n  get identifier() {\n    return this._identifier;\n  }\n\n  @trace.span({ showInBrowserTimeline: true })\n  async update(id: ObjectPointerEncoded, object: Partial<ObjectStructure>): Promise<boolean> {\n    const blocks = extractTextBlocks(object);\n\n    log('Extracting embeddings', { id, blocks });\n    if (blocks.length === 0) {\n      invariant(this._orama, 'Index is not initialized');\n      await Orama.remove(this._orama, id);\n      return true; // TODO(dmaretskyi): This re-runs all queries even if nothing changed.\n    }\n\n    const embeddings = await this._extractor.extract(blocks);\n    invariant(embeddings.length === 1, 'Vectors must be combined');\n    invariant(embeddings[0].length === VECTOR_DIMENSION, 'Vector dimension mismatch');\n\n    invariant(this._orama, 'Index is not initialized');\n    await Orama.remove(this._orama, id);\n    await Orama.insert(this._orama, {\n      id,\n      embedding: embeddings[0],\n    });\n    return true; // TODO(dmaretskyi): This re-runs all queries even if nothing changed.\n  }\n\n  async remove(id: ObjectPointerEncoded): Promise<void> {\n    invariant(this._orama, 'Index is not initialized');\n    await Orama.remove(this._orama, id);\n  }\n\n  @trace.span({ showInBrowserTimeline: true })\n  async find(filter: IndexQuery): Promise<FindResult[]> {\n    invariant(filter.typenames.length === 0, 'Typenames are not supported');\n    invariant(!filter.inverted, 'Inverted search is not supported');\n    invariant(!filter.graph, 'Graph search is not supported');\n    invariant(typeof filter.text?.query === 'string');\n    invariant(filter.text?.kind === 'vector');\n\n    const embeddings = await this._extractor.extract([{ content: filter.text.query }]);\n    invariant(embeddings.length === 1, 'Vectors must be combined');\n    invariant(embeddings[0].length === VECTOR_DIMENSION, 'Vector dimension mismatch');\n\n    invariant(this._orama, 'Index is not initialized');\n    const results = await Orama.search(this._orama, {\n      mode: 'vector',\n      vector: {\n        value: embeddings[0],\n        property: 'embedding',\n      },\n\n      // TODO(dmaretskyi): Add a way to configure these.\n      similarity: 0.2, // Minimum vector search similarity. Defaults to `0.8`\n      includeVectors: true, // Defaults to `false`\n      limit: 10, // Defaults to `10`\n      offset: 0, // Defaults to `0`\n    });\n\n    log.info('Vector search results', { query: filter.text.query, results });\n\n    return results.hits.map((hit) => ({\n      id: hit.id,\n      rank: hit.score,\n    }));\n  }\n\n  @trace.span({ showInBrowserTimeline: true })\n  async serialize(): Promise<string> {\n    invariant(this._orama, 'Index is not initialized');\n    return JSON.stringify(await Orama.save(this._orama), null, 2);\n  }\n\n  @trace.span({ showInBrowserTimeline: true })\n  static async load({ serialized, identifier }: LoadParams): Promise<IndexVector> {\n    const deserialized = JSON.parse(serialized);\n\n    const index = new IndexVector();\n    await index.open();\n    invariant(index._orama, 'Index is not initialized');\n    index._identifier = identifier;\n    await Orama.load(index._orama, deserialized);\n    return index;\n  }\n}\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { pipeline, type FeatureExtractionPipeline } from '@xenova/transformers';\n\nimport { Resource } from '@dxos/context';\n\nimport type { ExtractInputBlock } from './text';\n\nexport interface EmbeddingExtractorOptions {\n  /**\n   * Extraction model to use.\n   */\n  model: string;\n\n  /**\n   * Combine all chunks into a single vector.\n   */\n  chunkCombination: 'disabled' | 'mean' | 'max';\n\n  /**\n   * In characters.\n   */\n  maxChunkSize: number;\n}\n\nconst DEFAULT_OPTIONS: EmbeddingExtractorOptions = {\n  model: 'Xenova/all-MiniLM-L6-v2',\n  chunkCombination: 'mean',\n\n  maxChunkSize: 500,\n};\n\nexport class EmbeddingExtractor extends Resource {\n  private _options: EmbeddingExtractorOptions;\n\n  private _extractor?: FeatureExtractionPipeline = undefined;\n\n  constructor(options: Partial<EmbeddingExtractorOptions> = {}) {\n    super();\n    this._options = { ...DEFAULT_OPTIONS, ...options };\n  }\n\n  protected override async _open(): Promise<void> {\n    this._extractor = await pipeline('feature-extraction', this._options.model);\n  }\n\n  protected override async _close(): Promise<void> {\n    await this._extractor?.dispose();\n  }\n\n  /**\n   * Extracts embeddings from the object.\n   * @returns Embeddings for each chunk of the object or a single embedding if chunks are combined.\n   */\n  async extract(data: ExtractInputBlock[]): Promise<number[][]> {\n    const extractor = await pipeline('feature-extraction', this._options.model);\n\n    const chunks = breakIntoChunks(data, this._options.maxChunkSize);\n\n    const embedding = await extractor(\n      chunks.map((block) => block.content),\n      {\n        pooling: 'mean',\n        normalize: true,\n      },\n    );\n\n    let vectors = embedding.tolist();\n\n    vectors = combineChunks(vectors, this._options.chunkCombination);\n\n    return vectors;\n  }\n}\n\nconst combineChunks = (\n  vectors: number[][],\n  chunkCombination: EmbeddingExtractorOptions['chunkCombination'],\n): number[][] => {\n  switch (chunkCombination) {\n    case 'mean': {\n      const combined: number[] = Array(vectors[0].length).fill(0);\n      for (const vector of vectors) {\n        for (let i = 0; i < vector.length; i++) {\n          combined[i] += vector[i] / vectors.length;\n        }\n      }\n      return [combined.map((value) => value / vectors.length)];\n    }\n\n    case 'max': {\n      const combined: number[] = Array(vectors[0].length).fill(0);\n      for (const vector of vectors) {\n        for (let i = 0; i < vector.length; i++) {\n          combined[i] = Math.max(combined[i], vector[i]);\n        }\n      }\n      return [combined];\n    }\n    case 'disabled':\n      return vectors;\n  }\n};\n\n/**\n * Breaks the data into chunks.\n * @param data - The data to break into chunks.\n * @param maxChunkSize - The maximum size of a chunk in characters.\n * @returns The chunks.\n */\nexport const breakIntoChunks = (data: ExtractInputBlock[], maxChunkSize: number): ExtractInputBlock[] => {\n  const chunks: ExtractInputBlock[] = [];\n\n  for (const block of data) {\n    // Try to break by paragraphs first\n    const paragraphs = block.content.split(/\\n\\s*\\n/);\n\n    for (const paragraph of paragraphs) {\n      const content = paragraph.trim();\n      if (!content) {\n        continue;\n      }\n\n      // If paragraph fits within maxChunkSize, add it directly\n      if (content.length <= maxChunkSize) {\n        chunks.push({ ...block, content });\n        continue;\n      }\n\n      // Otherwise break into sentences\n      const sentences = content.split(/([.!?]+\\s+)/);\n      let currentChunk = '';\n\n      for (let i = 0; i < sentences.length; i += 2) {\n        const sentence = sentences[i];\n        const delimiter = sentences[i + 1] || '';\n        const sentenceContent = sentence.trim() + delimiter;\n\n        if (!sentenceContent) {\n          continue;\n        }\n\n        // If adding this sentence would exceed maxChunkSize\n        if (currentChunk.length + sentenceContent.length > maxChunkSize) {\n          // Save current chunk if we have one\n          if (currentChunk) {\n            chunks.push({ ...block, content: currentChunk });\n            currentChunk = '';\n          }\n\n          // If single sentence is too large, need to break it into words\n          if (sentenceContent.length > maxChunkSize) {\n            const words = sentenceContent.split(/(\\s+)/);\n            currentChunk = '';\n\n            for (let j = 0; j < words.length; j += 2) {\n              const word = words[j];\n              const wordDelimiter = words[j + 1] || '';\n              const wordContent = word.trim() + wordDelimiter;\n\n              if (!wordContent) {\n                continue;\n              }\n\n              if (currentChunk.length + wordContent.length > maxChunkSize) {\n                if (currentChunk) {\n                  chunks.push({ ...block, content: currentChunk });\n                  currentChunk = '';\n                }\n                // If single word is too large, break into characters\n                if (wordContent.length > maxChunkSize) {\n                  for (let k = 0; k < wordContent.length; k += maxChunkSize) {\n                    chunks.push({\n                      ...block,\n                      content: wordContent.slice(k, k + maxChunkSize),\n                    });\n                  }\n                } else {\n                  currentChunk = wordContent;\n                }\n              } else {\n                currentChunk += wordContent;\n              }\n            }\n          } else {\n            currentChunk = sentenceContent;\n          }\n        } else {\n          currentChunk += sentenceContent;\n        }\n      }\n\n      if (currentChunk) {\n        chunks.push({ ...block, content: currentChunk });\n      }\n    }\n  }\n\n  return chunks;\n};\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { synchronized } from '@dxos/async';\nimport { Resource, type Context } from '@dxos/context';\nimport { invariant } from '@dxos/invariant';\nimport type { LevelDB } from '@dxos/kv-store';\nimport { log } from '@dxos/log';\nimport { IndexKind } from '@dxos/protocols/proto/dxos/echo/indexing';\nimport { trace } from '@dxos/tracing';\nimport { ComplexMap } from '@dxos/util';\n\nimport type { IndexMetadataStore, IndexStore } from './store';\nimport type { IdToHeads, Index, ObjectSnapshot } from './types';\n\n/**\n * Loads documents by their ID and version.\n */\ninterface DocumentLoader {\n  loadDocuments: (ids: IdToHeads) => AsyncGenerator<ObjectSnapshot[]>;\n}\n\nexport type IndexingEngineOptions = {\n  db: LevelDB;\n\n  metadataStore: IndexMetadataStore;\n  indexStore: IndexStore;\n\n  /**\n   * Load documents by their pointers at specific hash.\n   */\n  documentLoader: DocumentLoader;\n};\n\ntype IndexUpdatedObjectsOptions = {\n  indexTimeBudget: number;\n  indexUpdateBatchSize: number;\n};\n\n/**\n * Manages multiple asynchronous indexes.\n */\nexport class IndexingEngine extends Resource {\n  private readonly _db: LevelDB;\n  private readonly _metadataStore: IndexMetadataStore;\n  private readonly _indexStore: IndexStore;\n  private readonly _documentLoader: DocumentLoader;\n\n  /**\n   * Indexes that are kept in-sync with the documents and are serialized to disk.\n   */\n  private readonly _indexes = new ComplexMap<IndexKind, Index>((kind) =>\n    kind.kind === IndexKind.Kind.FIELD_MATCH ? `${kind.kind}:${kind.field}` : kind.kind,\n  );\n\n  /**\n   * Indexes that were recently created and might not be fully caught up with the documents.\n   * They are not serialized to disk until they are promoted.\n   *\n   * This separation is needed because the tracking of processed documents is done globally and not per-index.\n   * This means that all indexes will be updated with the same documents in lockstep.\n   * This also means that newly created indexes cannot be saved to disk until they have processed all clean documents.\n   */\n  private readonly _newIndexes: Index[] = [];\n\n  constructor(options: IndexingEngineOptions) {\n    super();\n\n    this._db = options.db;\n    this._metadataStore = options.metadataStore;\n    this._indexStore = options.indexStore;\n    this._documentLoader = options.documentLoader;\n  }\n\n  protected override async _open(ctx: Context): Promise<void> {}\n\n  protected override async _close(ctx: Context): Promise<void> {\n    for (const index of this._indexes.values()) {\n      await index.close();\n    }\n    this._newIndexes.length = 0;\n    this._indexes.clear();\n  }\n\n  get indexKinds(): IndexKind[] {\n    return [...this._indexes.keys()];\n  }\n\n  get indexes(): Index[] {\n    return [...this._indexes.values()];\n  }\n\n  get newIndexCount(): number {\n    return this._newIndexes.length;\n  }\n\n  getIndex(kind: IndexKind): Index | undefined {\n    return this._indexes.get(kind);\n  }\n\n  deleteIndex(kind: IndexKind): void {\n    this._indexes.delete(kind);\n  }\n\n  async addPersistentIndex(index: Index): Promise<void> {\n    this._indexes.set(index.kind, index);\n    await index.open();\n  }\n\n  async addNewIndex(index: Index): Promise<void> {\n    this._newIndexes.push(index);\n    await index.open();\n  }\n\n  async loadIndexKindsFromDisk(): Promise<Map<string, IndexKind>> {\n    return this._indexStore.loadIndexKindsFromDisk();\n  }\n\n  async loadIndexFromDisk(identifier: string): Promise<void> {\n    const index = await this._indexStore.load(identifier);\n    this._indexes.set(index.kind, index);\n    await index.open();\n  }\n\n  async removeIndexFromDisk(identifier: string): Promise<void> {\n    await this._indexStore.remove(identifier);\n  }\n\n  /**\n   * Promotes new indexes to the main indexes.\n   */\n  @trace.span({ showInBrowserTimeline: true })\n  async promoteNewIndexes(): Promise<void> {\n    const documentsToIndex = await this._metadataStore.getAllIndexedDocuments();\n    for await (const documents of this._documentLoader.loadDocuments(documentsToIndex)) {\n      if (this._ctx.disposed) {\n        return;\n      }\n      await this._updateIndexes(this._newIndexes, documents);\n    }\n    this._newIndexes.forEach((index) => this._indexes.set(index.kind, index));\n    this._newIndexes.length = 0; // Clear new indexes.\n    await this._saveIndexes();\n  }\n\n  /**\n   * Indexes updated objects.\n   * @returns completed - whether the indexing was completed\n   * @returns updated - whether the indexing updated any indexes\n   */\n  @trace.span({ showInBrowserTimeline: true })\n  async indexUpdatedObjects(options: IndexUpdatedObjectsOptions): Promise<{ completed: boolean; updated: boolean }> {\n    let completed = true;\n    let updated = false;\n\n    if (this._ctx.disposed) {\n      return { completed, updated };\n    }\n    const idToHeads = await this._metadataStore.getDirtyDocuments();\n\n    log('dirty objects to index', { count: idToHeads.size });\n    if (idToHeads.size === 0 || this._ctx.disposed) {\n      return { completed, updated };\n    }\n\n    const startTime = Date.now();\n    const documentsUpdated: ObjectSnapshot[] = [];\n    const saveIndexChanges = async () => {\n      log('Saving index changes', { count: documentsUpdated.length, timeSinceStart: Date.now() - startTime });\n      await this._saveIndexes();\n      const batch = this._db.batch();\n      this._metadataStore.markClean(new Map(documentsUpdated.map((document) => [document.id, document.heads])), batch);\n      await batch.write();\n    };\n\n    const updates: boolean[] = [];\n    for await (const documents of this._documentLoader.loadDocuments(idToHeads)) {\n      if (this._ctx.disposed) {\n        return { completed, updated };\n      }\n      updates.push(...(await this._updateIndexes(Array.from(this._indexes.values()), documents)));\n      documentsUpdated.push(...documents);\n      if (documentsUpdated.length >= options.indexUpdateBatchSize) {\n        await saveIndexChanges();\n        documentsUpdated.length = 0;\n      }\n      if (Date.now() - startTime > options.indexTimeBudget) {\n        if (documentsUpdated.length > 0) {\n          await saveIndexChanges();\n        }\n        log('Indexing time budget exceeded', { time: Date.now() - startTime });\n        completed = false;\n        break;\n      }\n    }\n    await saveIndexChanges();\n    if (updates.some(Boolean)) {\n      updated = true;\n    }\n\n    log('Indexing finished', { time: Date.now() - startTime });\n    return { completed, updated };\n  }\n\n  @trace.span({ showInBrowserTimeline: true })\n  private async _updateIndexes(indexes: Index[], documents: ObjectSnapshot[]): Promise<boolean[]> {\n    const updates: boolean[] = [];\n    for (const index of indexes) {\n      if (this._ctx.disposed) {\n        return updates;\n      }\n      switch (index.kind.kind) {\n        case IndexKind.Kind.FIELD_MATCH:\n          invariant(index.kind.field, 'Field match index kind should have a field');\n          updates.push(\n            ...(await updateIndexWithObjects(\n              index,\n              documents.filter((document) => index.kind.field! in document.object),\n            )),\n          );\n          break;\n        case IndexKind.Kind.SCHEMA_MATCH:\n          updates.push(...(await updateIndexWithObjects(index, documents)));\n          break;\n        case IndexKind.Kind.GRAPH:\n          updates.push(...(await updateIndexWithObjects(index, documents)));\n          break;\n        case IndexKind.Kind.VECTOR:\n          updates.push(...(await updateIndexWithObjects(index, documents)));\n          break;\n        case IndexKind.Kind.FULL_TEXT:\n          updates.push(...(await updateIndexWithObjects(index, documents)));\n          break;\n      }\n    }\n    return updates;\n  }\n\n  @trace.span({ showInBrowserTimeline: true })\n  @synchronized\n  private async _saveIndexes(): Promise<void> {\n    for (const index of this._indexes.values()) {\n      if (this._ctx.disposed) {\n        return;\n      }\n      await this._indexStore.save(index);\n    }\n  }\n}\n\nconst updateIndexWithObjects = async (index: Index, snapshots: ObjectSnapshot[]) =>\n  Promise.all(snapshots.map((snapshot) => index.update(snapshot.id, snapshot.object)));\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport isEqual from 'lodash.isequal';\n\nimport { invariant } from '@dxos/invariant';\nimport { type SublevelDB } from '@dxos/kv-store';\nimport { type IndexKind } from '@dxos/protocols/proto/dxos/echo/indexing';\nimport { trace } from '@dxos/tracing';\n\nimport { IndexConstructors } from '../indexes';\nimport { type Index } from '../types';\n\nconst CODEC_VERSION = 2;\n\ntype IndexData = {\n  kind: IndexKind;\n  index: string;\n  version: number;\n};\n\nexport type IndexStoreParams = {\n  db: SublevelDB;\n};\n\n// TODO(mykola): Delete header from storage codec.\nexport class IndexStore {\n  private readonly _db: SublevelDB;\n  constructor({ db }: IndexStoreParams) {\n    this._db = db;\n\n    trace.diagnostic({\n      id: 'indexes',\n      name: 'Indexes',\n      fetch: async () => {\n        const indexes = await this._db.iterator<string, IndexData>(encodings).all();\n        return indexes.map(([identifier, { index, ...rest }]) => ({\n          identifier,\n          ...rest,\n        }));\n      },\n    });\n  }\n\n  async save(index: Index): Promise<void> {\n    await this._db.put<string, IndexData>(index.identifier, await indexCodec.encode(index), encodings);\n  }\n\n  async load(identifier: string): Promise<Index> {\n    const data = await this._db.get<string, IndexData>(identifier, encodings);\n    return indexCodec.decode(identifier, data);\n  }\n\n  async remove(identifier: string): Promise<void> {\n    await this._db.del(identifier, encodings);\n  }\n\n  /**\n   *\n   * @returns Map of index identifiers vs their kinds.\n   */\n  async loadIndexKindsFromDisk(): Promise<Map<string, IndexKind>> {\n    const kinds = new Map<string, IndexKind>();\n\n    for await (const [identifier, data] of this._db.iterator<string, IndexData>(encodings)) {\n      data.kind && kinds.set(identifier, data.kind);\n    }\n\n    // Delete all indexes that are colliding with the same kind.\n    {\n      const seenKinds: IndexKind[] = [];\n      const allKinds = Array.from(kinds.values());\n      for (const kind of allKinds) {\n        if (!seenKinds.some((seenKind) => isEqual(seenKind, kind))) {\n          seenKinds.push(kind);\n          continue;\n        }\n\n        const entries = Array.from(kinds.entries());\n        for (const [identifier, indexKind] of entries) {\n          if (isEqual(indexKind, kind)) {\n            await this.remove(identifier);\n            kinds.delete(identifier);\n          }\n        }\n      }\n    }\n\n    return kinds;\n  }\n}\n\nconst encodings = { keyEncoding: 'utf8', valueEncoding: 'json' };\n\nconst indexCodec = {\n  encode: async (index: Index): Promise<IndexData> => {\n    return {\n      index: await index.serialize(),\n      kind: index.kind,\n      version: CODEC_VERSION,\n    };\n  },\n  decode: async (identifier: string, data: IndexData): Promise<Index> => {\n    invariant(data.version === CODEC_VERSION, `Index version ${data.version} is not supported`);\n    const IndexConstructor = IndexConstructors[data.kind.kind];\n    invariant(IndexConstructor, `Index kind ${data.kind.kind} is not supported`);\n    return IndexConstructor.load({ serialized: data.index, indexKind: data.kind, identifier });\n  },\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { type Heads } from '@automerge/automerge';\nimport { type MixedEncoding } from 'level-transcoder';\n\nimport { Event } from '@dxos/async';\nimport type { ProtoCodec } from '@dxos/codec-protobuf';\nimport { invariant } from '@dxos/invariant';\nimport { type SublevelDB, type BatchLevel } from '@dxos/kv-store';\nimport { log } from '@dxos/log';\nimport { type ObjectPointerEncoded, objectPointerCodec } from '@dxos/protocols';\nimport { schema } from '@dxos/protocols/proto';\nimport { type Heads as HeadsProto } from '@dxos/protocols/proto/dxos/echo/query';\nimport { trace } from '@dxos/tracing';\nimport { joinTables } from '@dxos/util';\n\nimport { type IdToHeads } from '../types';\n\nexport type IndexMetadataStoreParams = {\n  db: SublevelDB;\n};\n\n@trace.resource()\nexport class IndexMetadataStore {\n  public readonly dirty = new Event<void>();\n  public readonly clean = new Event<void>();\n\n  /**\n   * Documents that were saved by automerge-repo but maybe not indexed (also includes indexed documents).\n   * ObjectPointerEncoded -> Heads\n   */\n  private readonly _lastSeen: SublevelDB;\n\n  /**\n   * Documents that were indexing\n   * ObjectPointerEncoded -> Heads\n   */\n  private readonly _lastIndexed: SublevelDB;\n\n  constructor({ db }: IndexMetadataStoreParams) {\n    this._lastSeen = db.sublevel('last-seen', { valueEncoding: headsEncoding, keyEncoding: 'utf8' });\n    this._lastIndexed = db.sublevel('last-indexed', { valueEncoding: headsEncoding, keyEncoding: 'utf8' });\n\n    trace.diagnostic({\n      id: 'indexed-documents',\n      name: 'Indexed Documents',\n      fetch: async () => {\n        const [dirty, indexed] = await Promise.all([this.getDirtyDocuments(), this.getAllIndexedDocuments()]);\n\n        return joinTables(\n          'id',\n          'id',\n          Array.from(dirty.entries()).map(([id, heads]) => ({ id, dirtyHeads: heads.join(',') })),\n          Array.from(indexed.entries()).map(([id, heads]) => ({ id, indexedHeads: heads.join(',') })),\n        );\n      },\n    });\n  }\n\n  @trace.span({ showInBrowserTimeline: true })\n  async getDirtyDocuments(): Promise<IdToHeads> {\n    return new Map(await this._lastSeen.iterator<ObjectPointerEncoded>({}).all());\n  }\n\n  /**\n   * @returns All document id's that were already indexed. May include dirty documents.\n   */\n  async getAllIndexedDocuments(): Promise<IdToHeads> {\n    return new Map(await this._lastIndexed.iterator<ObjectPointerEncoded>({}).all());\n  }\n\n  @trace.span({ showInBrowserTimeline: true })\n  markDirty(idToHeads: IdToHeads, batch: BatchLevel): void {\n    log('mark dirty', { count: idToHeads.size });\n    for (const [id, heads] of idToHeads.entries()) {\n      batch.put(id, heads, { sublevel: this._lastSeen, valueEncoding: headsEncoding });\n\n      // Delete old v0 entries.\n      batch.del(objectPointerCodec.convertV1ToV0(id), { sublevel: this._lastIndexed });\n    }\n  }\n\n  /**\n   * Called after leveldb batch commit.\n   */\n  notifyMarkedDirty(): void {\n    this.dirty.emit();\n  }\n\n  @trace.span({ showInBrowserTimeline: true })\n  markClean(idToHeads: IdToHeads, batch: BatchLevel): void {\n    log('mark clean', { count: idToHeads.size });\n    for (const [id, heads] of idToHeads.entries()) {\n      batch.put(id, heads, { sublevel: this._lastIndexed, valueEncoding: headsEncoding });\n      batch.del(id, { sublevel: this._lastSeen });\n\n      // Delete old v0 entries.\n      batch.del(objectPointerCodec.convertV1ToV0(id), { sublevel: this._lastIndexed });\n      batch.del(objectPointerCodec.convertV1ToV0(id), { sublevel: this._lastSeen });\n    }\n  }\n\n  /**\n   * Called on re-indexing.\n   */\n  dropFromClean(ids: ObjectPointerEncoded[], batch: BatchLevel): void {\n    for (const id of ids) {\n      batch.del(id, { sublevel: this._lastIndexed });\n    }\n  }\n}\n\n// NOTE: Lazy so that code that doesn't use indexing doesn't need to load the codec (breaks in workerd).\nlet headsCodec!: ProtoCodec<HeadsProto>;\nconst getHeadsCodec = () => (headsCodec ??= schema.getCodecForType('dxos.echo.query.Heads'));\n\nlet showedWarning = false;\nexport const headsEncoding: MixedEncoding<Heads, Uint8Array, Heads> = {\n  encode: (value: Heads): Uint8Array => getHeadsCodec().encode({ hashes: value }),\n  decode: (encodedValue: Uint8Array): Heads => {\n    try {\n      return getHeadsCodec().decode(encodedValue).hashes!;\n    } catch (err) {\n      // TODO(mykola): remove this before 0.7 release.\n      // Migration from old format.\n      if (!showedWarning) {\n        showedWarning = true;\n        log.warn('Detected legacy encoding of heads in the indexer. \\nRun `await dxos.client.repair()`');\n      }\n      /**\n       * Document head hashes concatenated with no  separator.\n       */\n      const concatenatedHeads = Buffer.from(encodedValue).toString('utf8').replace(/\"/g, '');\n\n      // Split concatenated heads into individual hashes by 64 characters.\n      invariant(concatenatedHeads.length % 64 === 0, 'Invalid concatenated heads length');\n      const heads = [];\n      for (let i = 0; i < concatenatedHeads.length; i += 64) {\n        heads.push(concatenatedHeads.slice(i, i + 64));\n      }\n      return heads;\n    }\n  },\n  format: 'buffer',\n};\n"],
  "mappings": "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",
  "names": ["import_async", "import_context", "import_invariant", "import_log", "import_indexing", "import_tracing", "import_echo_protocol", "import_keys", "import_util", "import_effect", "import_echo_schema", "import_lodash", "import_protocols", "IGNORED_TYPENAMES", "extractTextBlocks", "object", "type", "ObjectStructure", "getTypeReference", "dxnType", "decodeReference", "toDXN", "includes", "asTypeDXN", "blocks", "go", "value", "_key", "isEncodedReference", "push", "content", "visitValues", "data", "staticImplements", "constructor", "EscapedPropPath", "Schema", "String", "annotations", "title", "escape", "path", "map", "p", "toString", "replaceAll", "join", "unescape", "parts", "current", "i", "length", "invariant", "IndexText", "Resource", "_identifier", "PublicKey", "random", "kind", "IndexKind", "Kind", "FULL_TEXT", "updated", "Event", "_orama", "undefined", "_open", "create", "schema", "chunks", "identifier", "update", "id", "remove", "insert", "block", "find", "filter", "typenames", "inverted", "graph", "text", "query", "results", "search", "mode", "term", "limit", "offset", "log", "info", "hits", "hit", "rank", "score", "serialize", "JSON", "stringify", "save", "load", "serialized", "deserialized", "parse", "index", "open", "span", "showInBrowserTimeline", "resource", "IndexSchema", "SCHEMA_MATCH", "Map", "_index", "get", "getTypeFromObject", "has", "defaultMap", "Set", "add", "_", "ids", "entries", "delete", "Array", "from", "key", "EXPANDO_TYPENAME", "flatMap", "values", "typename", "DXN", "isDXNString", "dxn", "isLocalObjectId", "objectId", "TYPE", "warn", "flat", "serializedIndex", "set", "system", "IndexGraph", "GRAPH", "getEntityKind", "EntityKind", "Object", "_removeReferencesFrom", "_trackOutgoingReferences", "Relation", "targetMapping", "_objectToTargets", "source", "getRelationSource", "target", "getRelationTarget", "sourceObject", "asEchoDXN", "echoId", "_relationSources", "targetObject", "_relationTargets", "perField", "_inboundReferences", "field", "keys", "clear", "references", "getAllOutgoingReferences", "reference", "escapedPath", "pipe", "InternalError", "anchors", "property", "anchor", "sources", "escapedProp", "prop", "firstSegmentMatches", "secondSegmentIsNumeric", "isNaN", "Number", "TypeError", "inboundReferences", "fromEntries", "perProp", "relationTargets", "relationSources", "objectToTargets", "GraphIndexData", "decodeUnknownSync", "_loadFrom", "propMap", "Struct", "Record", "ObjectId", "ObjectPointerEncoded", "DEFAULT_OPTIONS", "model", "chunkCombination", "maxChunkSize", "EmbeddingExtractor", "options", "_extractor", "_options", "pipeline", "_close", "dispose", "extract", "extractor", "breakIntoChunks", "embedding", "pooling", "normalize", "vectors", "tolist", "combineChunks", "combined", "fill", "vector", "Math", "max", "paragraphs", "split", "paragraph", "trim", "sentences", "currentChunk", "sentence", "delimiter", "sentenceContent", "words", "j", "word", "wordDelimiter", "wordContent", "k", "slice", "VECTOR_DIMENSION", "IndexVector", "VECTOR", "embeddings", "similarity", "includeVectors", "IndexConstructors", "IndexingEngine", "ComplexMap", "FIELD_MATCH", "_db", "db", "_metadataStore", "metadataStore", "_indexStore", "indexStore", "_documentLoader", "documentLoader", "ctx", "_indexes", "close", "_newIndexes", "indexKinds", "indexes", "newIndexCount", "getIndex", "deleteIndex", "addPersistentIndex", "addNewIndex", "loadIndexKindsFromDisk", "loadIndexFromDisk", "removeIndexFromDisk", "promoteNewIndexes", "documentsToIndex", "getAllIndexedDocuments", "documents", "loadDocuments", "_ctx", "disposed", "_updateIndexes", "forEach", "_saveIndexes", "indexUpdatedObjects", "completed", "idToHeads", "getDirtyDocuments", "count", "size", "startTime", "Date", "now", "documentsUpdated", "saveIndexChanges", "timeSinceStart", "batch", "markClean", "document", "heads", "write", "updates", "indexUpdateBatchSize", "indexTimeBudget", "time", "some", "Boolean", "updateIndexWithObjects", "snapshots", "Promise", "all", "snapshot", "DEFAULT_INDEX_UPDATE_BATCH_SIZE", "DEFAULT_INDEX_COOLDOWN_TIME", "DEFAULT_INDEX_TIME_BUDGET", "Indexer", "indexCooldownTime", "_lastRunFinishedAt", "_indexUpdateBatchSize", "_indexCooldownTime", "_indexTimeBudget", "_engine", "initialized", "_lifecycleState", "LifecycleState", "OPEN", "setConfig", "config", "_indexConfig", "isEqual", "_loadIndexes", "_run", "schedule", "DeferredTask", "enabled", "cooldownMs", "sleepWithContext", "_promoteNewIndexes", "_indexUpdatedObjects", "dirty", "on", "_catch", "err", "catch", "execQuery", "Error", "graphIndex", "vectorIndex", "textIndex", "typenameIndex", "reindex", "markDirty", "dropFromClean", "runBlocking", "updateIndexes", "kinds", "configKind", "IndexConstructor", "emit", "CODEC_VERSION", "IndexStore", "trace", "diagnostic", "name", "fetch", "iterator", "encodings", "rest", "put", "indexCodec", "encode", "decode", "del", "seenKinds", "allKinds", "seenKind", "indexKind", "keyEncoding", "valueEncoding", "version", "IndexMetadataStore", "clean", "_lastSeen", "sublevel", "headsEncoding", "_lastIndexed", "indexed", "joinTables", "dirtyHeads", "indexedHeads", "objectPointerCodec", "convertV1ToV0", "notifyMarkedDirty", "headsCodec", "getHeadsCodec", "getCodecForType", "showedWarning", "hashes", "encodedValue", "concatenatedHeads", "Buffer", "replace", "format"]
}
