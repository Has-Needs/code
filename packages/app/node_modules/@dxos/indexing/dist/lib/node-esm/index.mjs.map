{
  "version": 3,
  "sources": ["../../../src/indexer.ts", "../../../src/indexes/index-text.ts", "../../../src/indexes/text.ts", "../../../src/types.ts", "../../../src/indexes/index-schema.ts", "../../../src/indexes/index-constructors.ts", "../../../src/indexes/index-graph.ts", "../../../src/indexes/index-vector.ts", "../../../src/indexes/embeddings.ts", "../../../src/indexing-engine.ts", "../../../src/store/index-store.ts", "../../../src/store/index-metadata-store.ts"],
  "sourcesContent": ["//\n// Copyright 2024 DXOS.org\n//\n\nimport isEqual from 'lodash.isequal';\n\nimport { DeferredTask, Event, sleepWithContext, synchronized } from '@dxos/async';\nimport { type Context, LifecycleState, Resource } from '@dxos/context';\nimport { invariant } from '@dxos/invariant';\nimport { type LevelDB } from '@dxos/kv-store';\nimport { log } from '@dxos/log';\nimport { IndexKind, type IndexConfig } from '@dxos/protocols/proto/dxos/echo/indexing';\nimport { trace } from '@dxos/tracing';\n\nimport { IndexConstructors } from './indexes';\nimport { IndexingEngine } from './indexing-engine';\nimport { type IndexMetadataStore, type IndexStore } from './store';\nimport { type FindResult, type IdToHeads, type IndexQuery, type ObjectSnapshot } from './types';\n\nconst DEFAULT_INDEX_UPDATE_BATCH_SIZE = 100;\n\nconst DEFAULT_INDEX_COOLDOWN_TIME = 100;\n\nconst DEFAULT_INDEX_TIME_BUDGET = 300;\n\nexport type IndexerParams = {\n  db: LevelDB;\n\n  metadataStore: IndexMetadataStore;\n  indexStore: IndexStore;\n\n  /**\n   * Load documents by their pointers at specific hash.\n   */\n  loadDocuments: (ids: IdToHeads) => AsyncGenerator<ObjectSnapshot[]>;\n\n  /**\n   * Amount of documents processed in a batch to save indexes after.\n   */\n  indexUpdateBatchSize?: number;\n\n  /**\n   * Minimum time between indexing runs.\n   */\n  indexCooldownTime?: number;\n\n  /**\n   * Time budget for indexing run.\n   * Does not cover creating new indexes.\n   */\n  indexTimeBudget?: number;\n};\n\n// TODO(burdon): Rename package @dxos/indexer?\n@trace.resource()\nexport class Indexer extends Resource {\n  public readonly updated = new Event<void>();\n\n  private readonly _db: LevelDB;\n  private readonly _metadataStore: IndexMetadataStore;\n  private readonly _engine: IndexingEngine;\n\n  private readonly _indexUpdateBatchSize: number;\n  private readonly _indexCooldownTime: number;\n  private readonly _indexTimeBudget: number;\n\n  private _indexConfig?: IndexConfig;\n  private _lastRunFinishedAt = 0;\n  private _run!: DeferredTask;\n\n  constructor({\n    db,\n    metadataStore,\n    indexStore,\n    loadDocuments,\n    indexUpdateBatchSize = DEFAULT_INDEX_UPDATE_BATCH_SIZE,\n    indexCooldownTime = DEFAULT_INDEX_COOLDOWN_TIME,\n    indexTimeBudget = DEFAULT_INDEX_TIME_BUDGET,\n  }: IndexerParams) {\n    super();\n    this._db = db;\n    this._metadataStore = metadataStore;\n    this._indexUpdateBatchSize = indexUpdateBatchSize;\n    this._indexCooldownTime = indexCooldownTime;\n    this._indexTimeBudget = indexTimeBudget;\n    this._engine = new IndexingEngine({\n      db,\n      metadataStore,\n      indexStore,\n      documentLoader: {\n        loadDocuments,\n      },\n    });\n  }\n\n  get initialized() {\n    return this._lifecycleState === LifecycleState.OPEN;\n  }\n\n  @synchronized\n  // TODO(mykola): Make it iterative (e.g. `initConfig(<index1>); initConfig(<index2>); ...`).\n  async setConfig(config: IndexConfig): Promise<void> {\n    this._indexConfig = config;\n    if (this._lifecycleState === LifecycleState.OPEN) {\n      log.warn('Setting index config after initialization, this is unstable', { config });\n      for (const kind of this._engine.indexKinds) {\n        if (!config.indexes?.some((kind) => isEqual(kind, kind))) {\n          this._engine.deleteIndex(kind);\n        }\n      }\n      await this._loadIndexes();\n      this._run.schedule();\n    }\n  }\n\n  @trace.span({ showInBrowserTimeline: true })\n  protected override async _open(ctx: Context): Promise<void> {\n    if (!this._indexConfig) {\n      log.warn('Index config is not set');\n    }\n\n    await this._engine.open(ctx);\n\n    // Needs to be re-created because context changes.\n    // TODO(dmaretskyi): Find a way to express this better for resources.\n    this._run = new DeferredTask(this._ctx, async () => {\n      try {\n        if (this._lifecycleState !== LifecycleState.OPEN || this._indexConfig?.enabled !== true) {\n          return;\n        }\n\n        const cooldownMs = this._lastRunFinishedAt + this._indexCooldownTime - Date.now();\n        if (cooldownMs > 0) {\n          await sleepWithContext(this._ctx, cooldownMs);\n        }\n\n        if (this._engine.newIndexCount > 0) {\n          await this._promoteNewIndexes();\n        }\n        await this._indexUpdatedObjects();\n      } finally {\n        this._lastRunFinishedAt = Date.now();\n      }\n    });\n\n    // Load indexes from disk.\n    await this._loadIndexes();\n\n    if (this._indexConfig?.enabled === true) {\n      this._metadataStore.dirty.on(this._ctx, () => this._run.schedule());\n      this._run.schedule();\n    }\n  }\n\n  protected override async _close(ctx: Context): Promise<void> {\n    await this._run.join();\n    await this._engine.close(ctx);\n  }\n\n  protected override async _catch(err: Error): Promise<void> {\n    // TODO(dmaretskyi): Better error handling.\n    log.catch(err);\n  }\n\n  // TODO(dmaretskyi): Allow consumers to get specific index instances and query them directly.\n  @synchronized\n  async execQuery(filter: IndexQuery): Promise<FindResult[]> {\n    if (this._lifecycleState !== LifecycleState.OPEN || this._indexConfig?.enabled !== true) {\n      // TODO(burdon): Unexpectedly thrown in query.test.ts.\n      throw new Error('Indexer is not initialized or not enabled');\n    }\n\n    if (filter.graph) {\n      const graphIndex = this._engine.getIndex({ kind: IndexKind.Kind.GRAPH });\n      if (!graphIndex) {\n        // TODO(dmaretskyi): This shouldn't be the default?\n        return [];\n      }\n      return graphIndex.find(filter);\n    } else if (filter.text?.kind === 'vector') {\n      const vectorIndex = this._engine.getIndex({ kind: IndexKind.Kind.VECTOR });\n      if (!vectorIndex) {\n        // TODO(dmaretskyi): This shouldn't be the default?\n        return [];\n      }\n      return vectorIndex.find(filter);\n    } else if (filter.text?.kind === 'text') {\n      const textIndex = this._engine.getIndex({ kind: IndexKind.Kind.FULL_TEXT });\n      if (!textIndex) {\n        // TODO(dmaretskyi): This shouldn't be the default?\n        return [];\n      }\n      return textIndex.find(filter);\n    } else {\n      const typenameIndex = this._engine.getIndex({ kind: IndexKind.Kind.SCHEMA_MATCH });\n      if (!typenameIndex) {\n        // TODO(dmaretskyi): This shouldn't be the default?\n        return [];\n      }\n      return typenameIndex.find(filter);\n    }\n  }\n\n  @trace.span({ showInBrowserTimeline: true })\n  async reindex(idToHeads: IdToHeads): Promise<void> {\n    const batch = this._db.batch();\n    this._metadataStore.markDirty(idToHeads, batch);\n    this._metadataStore.dropFromClean(Array.from(idToHeads.keys()), batch);\n    await batch.write();\n    await this._run.runBlocking();\n  }\n\n  /**\n   * Perform any pending index updates.\n   */\n  async updateIndexes(): Promise<void> {\n    await this._run.runBlocking();\n  }\n\n  private async _loadIndexes(): Promise<void> {\n    const kinds = await this._engine.loadIndexKindsFromDisk();\n    for (const [identifier, kind] of kinds.entries()) {\n      if (!this._indexConfig || this._indexConfig.indexes?.some((configKind) => isEqual(configKind, kind))) {\n        try {\n          await this._engine.loadIndexFromDisk(identifier);\n        } catch (err) {\n          log.warn('Failed to load index', { err, identifier });\n        }\n      } else {\n        // Note: We remove indexes that are not used\n        //       to not store indexes that are getting out of sync with database.\n        await this._engine.removeIndexFromDisk(identifier);\n      }\n    }\n\n    // Create indexes that are not loaded from disk.\n    for (const kind of this._indexConfig?.indexes || []) {\n      if (!this._engine.getIndex(kind)) {\n        const IndexConstructor = IndexConstructors[kind.kind];\n        invariant(IndexConstructor, `Index kind ${kind.kind} is not supported`);\n        // Note: New indexes are not saved to disk until they are promoted.\n        //       New Indexes will be promoted to `_indexes` map on indexing job run.\n        await this._engine.addNewIndex(new IndexConstructor(kind));\n      }\n    }\n  }\n\n  @trace.span({ showInBrowserTimeline: true })\n  private async _promoteNewIndexes(): Promise<void> {\n    await this._engine.promoteNewIndexes();\n    this.updated.emit();\n  }\n\n  @trace.span({ showInBrowserTimeline: true })\n  private async _indexUpdatedObjects(): Promise<void> {\n    if (this._ctx.disposed) {\n      return;\n    }\n\n    const { completed, updated } = await this._engine.indexUpdatedObjects({\n      indexTimeBudget: this._indexTimeBudget,\n      indexUpdateBatchSize: this._indexUpdateBatchSize,\n    });\n\n    if (!completed) {\n      this._run.schedule();\n    }\n\n    if (updated) {\n      this.updated.emit();\n    }\n  }\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport * as Orama from '@orama/orama';\n\nimport { Event } from '@dxos/async';\nimport { Resource } from '@dxos/context';\nimport { type ObjectStructure } from '@dxos/echo-protocol';\nimport { invariant } from '@dxos/invariant';\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport type { ObjectPointerEncoded } from '@dxos/protocols';\nimport { IndexKind } from '@dxos/protocols/proto/dxos/echo/indexing';\nimport { trace } from '@dxos/tracing';\n\nimport { extractTextBlocks } from './text';\nimport {\n  type IndexQuery,\n  staticImplements,\n  type Index,\n  type IndexStaticProps,\n  type LoadParams,\n  type FindResult,\n} from '../types';\n\n// Note: By default, Orama search returns 10 results.\n// const ORAMA_LIMIT = 1_000_000;\n\ntype OramaSchemaType = Orama.Orama<\n  {\n    chunks: 'string[]';\n  },\n  Orama.IIndex<Orama.components.index.Index>,\n  Orama.IDocumentsStore<Orama.components.documentsStore.DocumentsStore>\n>;\n\n@trace.resource()\n@staticImplements<IndexStaticProps>()\nexport class IndexText extends Resource implements Index {\n  private _identifier = PublicKey.random().toString();\n  public readonly kind: IndexKind = { kind: IndexKind.Kind.FULL_TEXT };\n  public readonly updated = new Event<void>();\n\n  private _orama?: OramaSchemaType = undefined;\n\n  override async _open(): Promise<void> {\n    this._orama = await Orama.create({\n      schema: {\n        chunks: 'string[]',\n      },\n    });\n  }\n\n  get identifier() {\n    return this._identifier;\n  }\n\n  @trace.span({ showInBrowserTimeline: true })\n  async update(id: ObjectPointerEncoded, object: Partial<ObjectStructure>): Promise<boolean> {\n    const blocks = extractTextBlocks(object);\n\n    invariant(this._orama, 'Index is not initialized');\n    await Orama.remove(this._orama, id);\n    await Orama.insert(this._orama, {\n      id,\n      chunks: blocks.map((block) => block.content),\n    });\n    return true;\n  }\n\n  async remove(id: ObjectPointerEncoded): Promise<void> {\n    invariant(this._orama, 'Index is not initialized');\n    await Orama.remove(this._orama, id);\n  }\n\n  @trace.span({ showInBrowserTimeline: true })\n  async find(filter: IndexQuery): Promise<FindResult[]> {\n    invariant(filter.typenames.length === 0, 'Typenames are not supported');\n    invariant(!filter.inverted, 'Inverted search is not supported');\n    invariant(!filter.graph, 'Graph search is not supported');\n    invariant(typeof filter.text?.query === 'string');\n    invariant(filter.text?.kind === 'text');\n\n    invariant(this._orama, 'Index is not initialized');\n    const results = await Orama.search(this._orama, {\n      mode: 'fulltext',\n      term: filter.text.query,\n\n      // TODO(dmaretskyi): Add a way to configure these.\n      limit: 10, // Defaults to `10`\n      offset: 0, // Defaults to `0`\n    });\n\n    log.info('Text search results', { query: filter.text.query, results });\n\n    return results.hits.map((hit) => ({\n      id: hit.id,\n      rank: hit.score,\n    })); // TODO(dmaretskyi): This re-runs all queries even if nothing changed.\n  }\n\n  @trace.span({ showInBrowserTimeline: true })\n  async serialize(): Promise<string> {\n    invariant(this._orama, 'Index is not initialized');\n    return JSON.stringify(await Orama.save(this._orama), null, 2);\n  }\n\n  @trace.span({ showInBrowserTimeline: true })\n  static async load({ serialized, identifier }: LoadParams): Promise<IndexText> {\n    const deserialized = JSON.parse(serialized);\n\n    const index = new IndexText();\n    await index.open();\n    invariant(index._orama, 'Index is not initialized');\n    index._identifier = identifier;\n    await Orama.load(index._orama, deserialized);\n    return index;\n  }\n}\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { decodeReference, isEncodedReference, ObjectStructure } from '@dxos/echo-protocol';\nimport { visitValues } from '@dxos/util';\n\n/**\n * Types that are excluded from text indexing.\n */\nconst IGNORED_TYPENAMES: string[] = ['dxos.org/type/Canvas'];\n\nexport type ExtractInputBlock = {\n  content: string;\n\n  /**\n   * The weight of the block.\n   */\n  // TODO(dmaretskyi): Currently not supported.\n  weight?: number;\n};\n\n/**\n * Extracts all text field values from an object.\n */\nexport const extractTextBlocks = (object: Partial<ObjectStructure>): ExtractInputBlock[] => {\n  const type = ObjectStructure.getTypeReference(object as any);\n  const dxnType = type && decodeReference(type).toDXN();\n\n  if (IGNORED_TYPENAMES.includes(dxnType?.asTypeDXN()?.type ?? '')) {\n    return [];\n  }\n\n  const blocks: ExtractInputBlock[] = [];\n\n  const go = (value: any, _key: string | number) => {\n    if (isEncodedReference(value)) {\n      return;\n    }\n    if (typeof value === 'string') {\n      blocks.push({ content: value });\n    }\n    visitValues(value, go);\n  };\n  visitValues(object.data, go);\n\n  return blocks;\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { type Heads } from '@automerge/automerge';\nimport { Schema } from 'effect';\nimport type { SchemaClass } from 'effect/Schema';\n\nimport { type Event } from '@dxos/async';\nimport { type ObjectPropPath, type ObjectStructure } from '@dxos/echo-protocol';\nimport type { ObjectId } from '@dxos/echo-schema';\nimport { invariant } from '@dxos/invariant';\nimport { type ObjectPointerEncoded } from '@dxos/protocols';\nimport { type IndexKind } from '@dxos/protocols/proto/dxos/echo/indexing';\n\n/**\n * Unified query interface for all indexes.\n * @deprecated To be replaced by a specialized API for each index.\n */\n// TODO(burdon): Reconcile with proto def.\nexport type IndexQuery = {\n  /**\n   * empty array means all objects (no filter).\n   */\n  typenames: string[];\n\n  // TODO(burdon): Hack to exclude.\n  inverted?: boolean;\n\n  /**\n   * Graph-based search.\n   */\n  graph?: {\n    /**\n     * Relation kind.\n     */\n    kind: 'inbound-reference' | 'relation-source' | 'relation-target';\n\n    /**\n     * anchor objects to search from.\n     */\n    anchors: ObjectId[];\n\n    /**\n     * Filter by property name.\n     * Only when kind is 'inbound-reference'.\n     */\n    property: EscapedPropPath | null;\n  };\n\n  text?: {\n    query: string;\n\n    kind: 'vector' | 'text';\n  };\n};\n\nexport type ObjectSnapshot = {\n  /**\n   * Object ID in the indexer format.\n   */\n  id: ObjectPointerEncoded;\n  object: ObjectStructure;\n  heads: Heads;\n};\n\nexport type IdToHeads = Map<ObjectPointerEncoded, Heads>;\nexport type FindResult = { id: ObjectPointerEncoded; rank: number };\n\nexport interface Index {\n  identifier: string;\n  kind: IndexKind;\n  updated: Event;\n\n  open(): Promise<Index>;\n  close(): Promise<Index>;\n\n  /**\n   * Add an object to the index.\n   * @returns {Promise<boolean>} true if the index was updated, false otherwise.\n   */\n  update(id: ObjectPointerEncoded, object: ObjectStructure): Promise<boolean>;\n\n  /**\n   * Remove an object from the index.\n   */\n  remove(id: ObjectPointerEncoded): Promise<void>;\n\n  // TODO(dmaretskyi): Remove from interface -- Each index has its own query api.\n  find(filter: IndexQuery): Promise<FindResult[]>;\n\n  serialize(): Promise<string>;\n}\n\nexport type LoadParams = { serialized: string; indexKind: IndexKind; identifier: string };\n\nexport interface IndexStaticProps {\n  new (kind: IndexKind): Index;\n  load(params: LoadParams): Promise<Index>;\n}\n\n/**\n * Type-only annotation to assert that a class-constructor implements an interface T (with it's static methods).\n */\nexport const staticImplements =\n  <T>() =>\n  <U extends T>(constructor: U) => {\n    return constructor;\n  };\n\n/**\n * Escaped property path within an object.\n *\n * Escaping rules:\n *\n * - '.' -> '\\.'\n * - '\\' -> '\\\\'\n * - contact with .\n */\nexport const EscapedPropPath: SchemaClass<string, string> & {\n  escape: (path: ObjectPropPath) => EscapedPropPath;\n  unescape: (path: EscapedPropPath) => ObjectPropPath;\n} = class extends Schema.String.annotations({ title: 'EscapedPropPath' }) {\n  static escape(path: ObjectPropPath): EscapedPropPath {\n    return path.map((p) => p.toString().replaceAll('\\\\', '\\\\\\\\').replaceAll('.', '\\\\.')).join('.');\n  }\n\n  static unescape(path: EscapedPropPath): ObjectPropPath {\n    const parts: string[] = [];\n    let current = '';\n\n    for (let i = 0; i < path.length; i++) {\n      if (path[i] === '\\\\') {\n        invariant(i + 1 < path.length && (path[i + 1] === '.' || path[i + 1] === '\\\\'), 'Malformed escaping.');\n        current = current + path[i + 1];\n        i++;\n      } else if (path[i] === '.') {\n        parts.push(current);\n        current = '';\n      } else {\n        current += path[i];\n      }\n    }\n    parts.push(current);\n\n    return parts;\n  }\n};\nexport type EscapedPropPath = Schema.Schema.Type<typeof EscapedPropPath>;\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { Event } from '@dxos/async';\nimport { Resource } from '@dxos/context';\nimport { decodeReference, type ObjectStructure } from '@dxos/echo-protocol';\nimport { EXPANDO_TYPENAME } from '@dxos/echo-schema';\nimport { DXN, PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { type ObjectPointerEncoded } from '@dxos/protocols';\nimport { IndexKind } from '@dxos/protocols/proto/dxos/echo/indexing';\nimport { trace } from '@dxos/tracing';\nimport { defaultMap } from '@dxos/util';\n\nimport {\n  type FindResult,\n  type Index,\n  type IndexQuery,\n  type IndexStaticProps,\n  type LoadParams,\n  staticImplements,\n} from '../types';\n\n/**\n * Indexes objects by their typename.\n */\n@trace.resource()\n@staticImplements<IndexStaticProps>()\nexport class IndexSchema extends Resource implements Index {\n  private _identifier = PublicKey.random().toString();\n  public readonly kind: IndexKind = { kind: IndexKind.Kind.SCHEMA_MATCH };\n  public readonly updated = new Event<void>();\n\n  /**\n   * Map `typename` -> Set `index id`.\n   * @see https://v8.dev/blog/hash-code for performance estimations.\n   */\n  private readonly _index = new Map<string | null, Set<ObjectPointerEncoded>>();\n\n  get identifier() {\n    return this._identifier;\n  }\n\n  @trace.span({ showInBrowserTimeline: true })\n  async update(id: ObjectPointerEncoded, object: Partial<ObjectStructure>): Promise<boolean> {\n    if (this._index.get(getTypeFromObject(object))?.has(id)) {\n      return false;\n    }\n    defaultMap(this._index, getTypeFromObject(object), new Set()).add(id);\n    return true;\n  }\n\n  async remove(id: ObjectPointerEncoded): Promise<void> {\n    for (const [_, ids] of this._index.entries()) {\n      if (ids.has(id)) {\n        ids.delete(id);\n        return;\n      }\n    }\n  }\n\n  @trace.span({ showInBrowserTimeline: true })\n  async find(filter: IndexQuery): Promise<FindResult[]> {\n    // TODO(burdon): Handle inversion.\n    if (filter.inverted) {\n      return Array.from(this._index.entries())\n        .filter(([key]) => !filter.typenames.includes(key ?? EXPANDO_TYPENAME) === false)\n        .flatMap(([, value]) => Array.from(value))\n        .map((id) => ({ id, rank: 0 }));\n    }\n\n    if (filter.typenames.length === 0) {\n      return Array.from(this._index.values())\n        .flatMap((ids) => Array.from(ids))\n        .map((id) => ({ id, rank: 0 }));\n    }\n\n    const results: FindResult[] = [];\n    for (const typename of filter.typenames) {\n      if (\n        typename === EXPANDO_TYPENAME ||\n        (DXN.isDXNString(typename) && DXN.parse(typename).asTypeDXN()?.type === EXPANDO_TYPENAME)\n      ) {\n        results.push(...Array.from(this._index.get(null) ?? []).map((id) => ({ id, rank: 0 })));\n      } else if (DXN.isDXNString(typename)) {\n        const dxn = DXN.parse(typename);\n        if (dxn.isLocalObjectId()) {\n          const objectId = dxn.parts[1];\n          results.push(...Array.from(this._index.get(objectId) ?? []).map((id) => ({ id, rank: 0 })));\n        } else if (dxn.kind === DXN.kind.TYPE) {\n          const typename = dxn.parts[0];\n          results.push(...Array.from(this._index.get(typename) ?? []).map((id) => ({ id, rank: 0 })));\n        } else {\n          log.warn('Unsupported DXN', { dxn });\n        }\n      } else {\n        results.push(...Array.from(this._index.get(typename) ?? []).map((id) => ({ id, rank: 0 })));\n      }\n    }\n    return results.flat();\n  }\n\n  @trace.span({ showInBrowserTimeline: true })\n  async serialize(): Promise<string> {\n    return JSON.stringify({\n      index: Array.from(this._index.entries()).map(([type, ids]) => ({\n        type,\n        ids: Array.from(ids),\n      })),\n    });\n  }\n\n  @trace.span({ showInBrowserTimeline: true })\n  static async load({ serialized, identifier }: LoadParams): Promise<IndexSchema> {\n    const index = new IndexSchema();\n    const serializedIndex: { type: string | null; ids: string[] }[] = JSON.parse(serialized).index;\n    index._identifier = identifier;\n    for (const { type, ids } of serializedIndex) {\n      index._index.set(type, new Set(ids));\n    }\n    return index;\n  }\n}\n\nconst getTypeFromObject = (object: Partial<ObjectStructure>): string | null =>\n  object.system?.type ? decodeReference(object.system.type).objectId ?? null : null;\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { IndexKind } from '@dxos/protocols/proto/dxos/echo/indexing';\n\nimport { IndexGraph } from './index-graph';\nimport { IndexSchema } from './index-schema';\nimport { IndexText } from './index-text';\nimport { IndexVector } from './index-vector';\nimport { type IndexStaticProps } from '../types';\n\nexport const IndexConstructors: { [key in IndexKind['kind']]?: IndexStaticProps } = {\n  [IndexKind.Kind.SCHEMA_MATCH]: IndexSchema,\n  [IndexKind.Kind.GRAPH]: IndexGraph,\n  [IndexKind.Kind.VECTOR]: IndexVector,\n  [IndexKind.Kind.FULL_TEXT]: IndexText,\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { pipe, Schema } from 'effect';\n\nimport { Event } from '@dxos/async';\nimport { Resource } from '@dxos/context';\nimport { decodeReference, ObjectStructure } from '@dxos/echo-protocol';\nimport { EntityKind, ObjectId } from '@dxos/echo-schema';\nimport { InternalError } from '@dxos/errors';\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { ObjectPointerEncoded } from '@dxos/protocols';\nimport { IndexKind } from '@dxos/protocols/proto/dxos/echo/indexing';\nimport { trace } from '@dxos/tracing';\nimport { defaultMap, entries } from '@dxos/util';\n\nimport {\n  EscapedPropPath,\n  type FindResult,\n  type Index,\n  type IndexQuery,\n  type IndexStaticProps,\n  type LoadParams,\n  staticImplements,\n} from '../types';\n\n/**\n * Indexes graph relationships between objects.\n * Includes incoming references for relations as well.\n */\n@trace.resource()\n@staticImplements<IndexStaticProps>()\nexport class IndexGraph extends Resource implements Index {\n  private _identifier = PublicKey.random().toString();\n  public readonly kind: IndexKind = { kind: IndexKind.Kind.GRAPH };\n  public readonly updated = new Event<void>();\n\n  /**\n   * Tracks inbound references for each object.\n   *\n   * target object id -> prop name -> set of source object ids\n   */\n  private readonly _inboundReferences = new Map<ObjectId, Map<string, Set<ObjectPointerEncoded>>>();\n\n  /**\n   * Tracks relation targets for each object.\n   *\n   * relation target object id -> set of relation ids\n   */\n  private readonly _relationTargets = new Map<ObjectId, Set<ObjectPointerEncoded>>();\n\n  /**\n   * Tracks relation sources for each object.\n   *\n   * relation source object id -> set of relation ids\n   */\n  private readonly _relationSources = new Map<ObjectId, Set<ObjectPointerEncoded>>();\n\n  /**\n   * Mapping from the object to the list of reference targets.\n   * We need this because on index update we don't know what the previous version of the object was.\n   * This mapping is used to remove the old relations on update.\n   */\n  // TODO(dmaretskyi): Index should have access to the previous state on update.\n  private readonly _objectToTargets = new Map<ObjectPointerEncoded, Set<ObjectId>>();\n\n  get identifier() {\n    return this._identifier;\n  }\n\n  @trace.span({ showInBrowserTimeline: true })\n  async update(id: ObjectPointerEncoded, object: ObjectStructure): Promise<boolean> {\n    const kind = ObjectStructure.getEntityKind(object);\n    switch (kind) {\n      case EntityKind.Object: {\n        // Clear old links.\n        this._removeReferencesFrom(id);\n        this._trackOutgoingReferences(id, object);\n\n        break;\n      }\n      case EntityKind.Relation: {\n        this._removeReferencesFrom(id);\n        this._trackOutgoingReferences(id, object);\n\n        const targetMapping = defaultMap(this._objectToTargets, id, () => new Set());\n        const source = ObjectStructure.getRelationSource(object);\n        const target = ObjectStructure.getRelationTarget(object);\n        if (source) {\n          const sourceObject = decodeReference(source).toDXN().asEchoDXN()?.echoId;\n          if (sourceObject) {\n            defaultMap(this._relationSources, sourceObject, () => new Set()).add(id);\n            targetMapping.add(sourceObject);\n          }\n        } else {\n          log.warn('relation has no source', { id });\n        }\n        if (target) {\n          const targetObject = decodeReference(target).toDXN().asEchoDXN()?.echoId;\n          if (targetObject) {\n            defaultMap(this._relationTargets, targetObject, () => new Set()).add(id);\n            targetMapping.add(targetObject);\n          }\n        } else {\n          log.warn('relation has no target', { id });\n        }\n        break;\n      }\n      default: {\n        log.warn('unknown entity kind', { kind });\n        break;\n      }\n    }\n\n    return true; // TODO(dmaretskyi): Actually check if anything changed. This will cause the index to be saved on every object change batch.\n  }\n\n  async remove(id: ObjectPointerEncoded): Promise<void> {\n    this._removeReferencesFrom(id);\n  }\n\n  private _removeReferencesFrom(id: ObjectPointerEncoded): void {\n    for (const target of this._objectToTargets.get(id) ?? []) {\n      const perField = this._inboundReferences.get(target);\n      if (!perField) {\n        continue;\n      }\n      // TODO(dmaretskyi): Not efficient, but unlikely to cause issues.\n      for (const field of perField.keys()) {\n        perField.get(field)?.delete(id);\n      }\n\n      // TODO(dmaretskyi): Technically relation endpoints cannot change, but we still track them here for safety.\n      this._relationTargets.get(target)?.delete(id);\n      this._relationSources.get(target)?.delete(id);\n    }\n\n    this._objectToTargets.get(id)?.clear();\n  }\n\n  private _trackOutgoingReferences(id: ObjectPointerEncoded, object: ObjectStructure): void {\n    const targetMapping = defaultMap(this._objectToTargets, id, () => new Set());\n\n    const references = ObjectStructure.getAllOutgoingReferences(object);\n    for (const { path, reference } of references) {\n      const targetObject = decodeReference(reference).toDXN().asEchoDXN()?.echoId;\n      if (!targetObject) {\n        continue;\n      }\n      const escapedPath = EscapedPropPath.escape(path);\n      pipe(\n        this._inboundReferences,\n        (map) => defaultMap(map, targetObject, () => new Map()),\n        (map) => defaultMap(map, escapedPath, () => new Set()),\n      ).add(id);\n\n      targetMapping.add(targetObject);\n    }\n  }\n\n  @trace.span({ showInBrowserTimeline: true })\n  async find(filter: IndexQuery): Promise<FindResult[]> {\n    if (filter.inverted || filter.typenames.length > 0 || !filter.graph) {\n      throw new InternalError('Invalid filter for graph query');\n    }\n\n    const { kind, anchors, property } = filter.graph;\n\n    switch (kind) {\n      case 'inbound-reference': {\n        const results: FindResult[] = [];\n        for (const anchor of anchors) {\n          const sources = this._inboundReferences.get(anchor);\n          if (!sources) {\n            continue;\n          }\n          if (property !== null) {\n            for (const [escapedProp, source] of sources.entries()) {\n              const prop = EscapedPropPath.unescape(escapedProp);\n              const firstSegmentMatches = prop[0] === property;\n              const secondSegmentIsNumeric = !isNaN(Number(prop[1]));\n              if (firstSegmentMatches && (prop.length === 1 || (prop.length === 2 && secondSegmentIsNumeric))) {\n                results.push(...Array.from(source).map((id) => ({ id, rank: 0 })));\n              }\n            }\n          } else {\n            for (const source of sources.values()) {\n              results.push(...Array.from(source).map((id) => ({ id, rank: 0 })));\n            }\n          }\n        }\n        return results;\n      }\n      case 'relation-source': {\n        const results: FindResult[] = [];\n        for (const anchor of anchors) {\n          const sources = this._relationSources.get(anchor);\n          if (!sources) {\n            continue;\n          }\n          results.push(...Array.from(sources).map((id) => ({ id, rank: 0 })));\n        }\n        return results;\n      }\n      case 'relation-target': {\n        const results: FindResult[] = [];\n        for (const anchor of anchors) {\n          const sources = this._relationTargets.get(anchor);\n          if (!sources) {\n            continue;\n          }\n          results.push(...Array.from(sources).map((id) => ({ id, rank: 0 })));\n        }\n        return results;\n      }\n      default: {\n        throw new TypeError('Unknown graph query kind');\n      }\n    }\n  }\n\n  @trace.span({ showInBrowserTimeline: true })\n  async serialize(): Promise<string> {\n    const data: GraphIndexData = {\n      inboundReferences: Object.fromEntries(\n        [...this._inboundReferences.entries()].map(([target, perProp]) => [\n          target,\n          Object.fromEntries([...perProp.entries()].map(([prop, sources]) => [prop, Array.from(sources)])),\n        ]),\n      ),\n      relationTargets: Object.fromEntries(\n        [...this._relationTargets.entries()].map(([target, sources]) => [target, Array.from(sources)]),\n      ),\n      relationSources: Object.fromEntries(\n        [...this._relationSources.entries()].map(([target, sources]) => [target, Array.from(sources)]),\n      ),\n      objectToTargets: Object.fromEntries(\n        [...this._objectToTargets.entries()].map(([target, sources]) => [target, Array.from(sources)]),\n      ),\n    };\n    return JSON.stringify(data);\n  }\n\n  @trace.span({ showInBrowserTimeline: true })\n  static async load({ serialized, identifier }: LoadParams): Promise<IndexGraph> {\n    const index = new IndexGraph();\n    await index.open();\n\n    const data = GraphIndexData.pipe(Schema.decodeUnknownSync)(JSON.parse(serialized));\n    index._loadFrom(data);\n    return index;\n  }\n\n  private _loadFrom(data: GraphIndexData): void {\n    this._inboundReferences.clear();\n    this._relationTargets.clear();\n    this._relationSources.clear();\n    this._objectToTargets.clear();\n\n    for (const [target, perProp] of entries(data.inboundReferences)) {\n      const propMap = new Map<string, Set<ObjectPointerEncoded>>();\n      this._inboundReferences.set(target, propMap);\n      for (const [prop, sources] of entries(perProp)) {\n        propMap.set(prop, new Set(sources));\n      }\n    }\n\n    for (const [target, sources] of entries(data.relationTargets)) {\n      this._relationTargets.set(target, new Set(sources));\n    }\n\n    for (const [target, sources] of entries(data.relationSources)) {\n      this._relationSources.set(target, new Set(sources));\n    }\n\n    for (const [target, sources] of entries(data.objectToTargets)) {\n      this._objectToTargets.set(target, new Set(sources));\n    }\n  }\n}\n\nconst GraphIndexData = Schema.Struct({\n  inboundReferences: Schema.Record({\n    key: ObjectId,\n    value: Schema.Record({\n      key: EscapedPropPath,\n      value: Schema.Array(ObjectPointerEncoded),\n    }),\n  }),\n  relationTargets: Schema.Record({\n    key: ObjectId,\n    value: Schema.Array(ObjectPointerEncoded),\n  }),\n  relationSources: Schema.Record({\n    key: ObjectId,\n    value: Schema.Array(ObjectPointerEncoded),\n  }),\n  objectToTargets: Schema.Record({\n    key: ObjectPointerEncoded,\n    value: Schema.Array(ObjectId),\n  }),\n});\ninterface GraphIndexData extends Schema.Schema.Type<typeof GraphIndexData> {}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport * as Orama from '@orama/orama';\n\nimport { Event } from '@dxos/async';\nimport { Resource } from '@dxos/context';\nimport { type ObjectStructure } from '@dxos/echo-protocol';\nimport { invariant } from '@dxos/invariant';\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport type { ObjectPointerEncoded } from '@dxos/protocols';\nimport { IndexKind } from '@dxos/protocols/proto/dxos/echo/indexing';\nimport { trace } from '@dxos/tracing';\n\nimport { EmbeddingExtractor } from './embeddings';\nimport { extractTextBlocks } from './text';\nimport {\n  type IndexQuery,\n  staticImplements,\n  type Index,\n  type IndexStaticProps,\n  type LoadParams,\n  type FindResult,\n} from '../types';\n\n// Note: By default, Orama search returns 10 results.\n// const ORAMA_LIMIT = 1_000_000;\n\n// Type of the Orama instance with the specific schema we're using\ntype OramaInstanceType = Orama.Orama<\n  {\n    embedding: `vector[${number}]`;\n  },\n  Orama.IIndex<Orama.components.index.Index>,\n  Orama.IDocumentsStore<Orama.components.documentsStore.DocumentsStore>\n>;\n\n// Must match the vector dimension of the embedding extractor.\nconst VECTOR_DIMENSION = 384;\n\n@trace.resource()\n@staticImplements<IndexStaticProps>()\nexport class IndexVector extends Resource implements Index {\n  private _identifier = PublicKey.random().toString();\n\n  private _extractor = new EmbeddingExtractor();\n\n  public readonly kind: IndexKind = { kind: IndexKind.Kind.VECTOR };\n  public readonly updated = new Event<void>();\n\n  private _orama?: OramaInstanceType = undefined;\n\n  override async _open(): Promise<void> {\n    await this._extractor.open();\n\n    this._orama = await Orama.create({\n      schema: {\n        embedding: `vector[${VECTOR_DIMENSION}]`,\n      },\n    });\n  }\n\n  get identifier() {\n    return this._identifier;\n  }\n\n  @trace.span({ showInBrowserTimeline: true })\n  async update(id: ObjectPointerEncoded, object: Partial<ObjectStructure>): Promise<boolean> {\n    const blocks = extractTextBlocks(object);\n\n    log('Extracting embeddings', { id, blocks });\n    if (blocks.length === 0) {\n      invariant(this._orama, 'Index is not initialized');\n      await Orama.remove(this._orama, id);\n      return true; // TODO(dmaretskyi): This re-runs all queries even if nothing changed.\n    }\n\n    const embeddings = await this._extractor.extract(blocks);\n    invariant(embeddings.length === 1, 'Vectors must be combined');\n    invariant(embeddings[0].length === VECTOR_DIMENSION, 'Vector dimension mismatch');\n\n    invariant(this._orama, 'Index is not initialized');\n    await Orama.remove(this._orama, id);\n    await Orama.insert(this._orama, {\n      id,\n      embedding: embeddings[0],\n    });\n    return true; // TODO(dmaretskyi): This re-runs all queries even if nothing changed.\n  }\n\n  async remove(id: ObjectPointerEncoded): Promise<void> {\n    invariant(this._orama, 'Index is not initialized');\n    await Orama.remove(this._orama, id);\n  }\n\n  @trace.span({ showInBrowserTimeline: true })\n  async find(filter: IndexQuery): Promise<FindResult[]> {\n    invariant(filter.typenames.length === 0, 'Typenames are not supported');\n    invariant(!filter.inverted, 'Inverted search is not supported');\n    invariant(!filter.graph, 'Graph search is not supported');\n    invariant(typeof filter.text?.query === 'string');\n    invariant(filter.text?.kind === 'vector');\n\n    const embeddings = await this._extractor.extract([{ content: filter.text.query }]);\n    invariant(embeddings.length === 1, 'Vectors must be combined');\n    invariant(embeddings[0].length === VECTOR_DIMENSION, 'Vector dimension mismatch');\n\n    invariant(this._orama, 'Index is not initialized');\n    const results = await Orama.search(this._orama, {\n      mode: 'vector',\n      vector: {\n        value: embeddings[0],\n        property: 'embedding',\n      },\n\n      // TODO(dmaretskyi): Add a way to configure these.\n      similarity: 0.2, // Minimum vector search similarity. Defaults to `0.8`\n      includeVectors: true, // Defaults to `false`\n      limit: 10, // Defaults to `10`\n      offset: 0, // Defaults to `0`\n    });\n\n    log.info('Vector search results', { query: filter.text.query, results });\n\n    return results.hits.map((hit) => ({\n      id: hit.id,\n      rank: hit.score,\n    }));\n  }\n\n  @trace.span({ showInBrowserTimeline: true })\n  async serialize(): Promise<string> {\n    invariant(this._orama, 'Index is not initialized');\n    return JSON.stringify(await Orama.save(this._orama), null, 2);\n  }\n\n  @trace.span({ showInBrowserTimeline: true })\n  static async load({ serialized, identifier }: LoadParams): Promise<IndexVector> {\n    const deserialized = JSON.parse(serialized);\n\n    const index = new IndexVector();\n    await index.open();\n    invariant(index._orama, 'Index is not initialized');\n    index._identifier = identifier;\n    await Orama.load(index._orama, deserialized);\n    return index;\n  }\n}\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { pipeline, type FeatureExtractionPipeline } from '@xenova/transformers';\n\nimport { Resource } from '@dxos/context';\n\nimport type { ExtractInputBlock } from './text';\n\nexport interface EmbeddingExtractorOptions {\n  /**\n   * Extraction model to use.\n   */\n  model: string;\n\n  /**\n   * Combine all chunks into a single vector.\n   */\n  chunkCombination: 'disabled' | 'mean' | 'max';\n\n  /**\n   * In characters.\n   */\n  maxChunkSize: number;\n}\n\nconst DEFAULT_OPTIONS: EmbeddingExtractorOptions = {\n  model: 'Xenova/all-MiniLM-L6-v2',\n  chunkCombination: 'mean',\n\n  maxChunkSize: 500,\n};\n\nexport class EmbeddingExtractor extends Resource {\n  private _options: EmbeddingExtractorOptions;\n\n  private _extractor?: FeatureExtractionPipeline = undefined;\n\n  constructor(options: Partial<EmbeddingExtractorOptions> = {}) {\n    super();\n    this._options = { ...DEFAULT_OPTIONS, ...options };\n  }\n\n  protected override async _open(): Promise<void> {\n    this._extractor = await pipeline('feature-extraction', this._options.model);\n  }\n\n  protected override async _close(): Promise<void> {\n    await this._extractor?.dispose();\n  }\n\n  /**\n   * Extracts embeddings from the object.\n   * @returns Embeddings for each chunk of the object or a single embedding if chunks are combined.\n   */\n  async extract(data: ExtractInputBlock[]): Promise<number[][]> {\n    const extractor = await pipeline('feature-extraction', this._options.model);\n\n    const chunks = breakIntoChunks(data, this._options.maxChunkSize);\n\n    const embedding = await extractor(\n      chunks.map((block) => block.content),\n      {\n        pooling: 'mean',\n        normalize: true,\n      },\n    );\n\n    let vectors = embedding.tolist();\n\n    vectors = combineChunks(vectors, this._options.chunkCombination);\n\n    return vectors;\n  }\n}\n\nconst combineChunks = (\n  vectors: number[][],\n  chunkCombination: EmbeddingExtractorOptions['chunkCombination'],\n): number[][] => {\n  switch (chunkCombination) {\n    case 'mean': {\n      const combined: number[] = Array(vectors[0].length).fill(0);\n      for (const vector of vectors) {\n        for (let i = 0; i < vector.length; i++) {\n          combined[i] += vector[i] / vectors.length;\n        }\n      }\n      return [combined.map((value) => value / vectors.length)];\n    }\n\n    case 'max': {\n      const combined: number[] = Array(vectors[0].length).fill(0);\n      for (const vector of vectors) {\n        for (let i = 0; i < vector.length; i++) {\n          combined[i] = Math.max(combined[i], vector[i]);\n        }\n      }\n      return [combined];\n    }\n    case 'disabled':\n      return vectors;\n  }\n};\n\n/**\n * Breaks the data into chunks.\n * @param data - The data to break into chunks.\n * @param maxChunkSize - The maximum size of a chunk in characters.\n * @returns The chunks.\n */\nexport const breakIntoChunks = (data: ExtractInputBlock[], maxChunkSize: number): ExtractInputBlock[] => {\n  const chunks: ExtractInputBlock[] = [];\n\n  for (const block of data) {\n    // Try to break by paragraphs first\n    const paragraphs = block.content.split(/\\n\\s*\\n/);\n\n    for (const paragraph of paragraphs) {\n      const content = paragraph.trim();\n      if (!content) {\n        continue;\n      }\n\n      // If paragraph fits within maxChunkSize, add it directly\n      if (content.length <= maxChunkSize) {\n        chunks.push({ ...block, content });\n        continue;\n      }\n\n      // Otherwise break into sentences\n      const sentences = content.split(/([.!?]+\\s+)/);\n      let currentChunk = '';\n\n      for (let i = 0; i < sentences.length; i += 2) {\n        const sentence = sentences[i];\n        const delimiter = sentences[i + 1] || '';\n        const sentenceContent = sentence.trim() + delimiter;\n\n        if (!sentenceContent) {\n          continue;\n        }\n\n        // If adding this sentence would exceed maxChunkSize\n        if (currentChunk.length + sentenceContent.length > maxChunkSize) {\n          // Save current chunk if we have one\n          if (currentChunk) {\n            chunks.push({ ...block, content: currentChunk });\n            currentChunk = '';\n          }\n\n          // If single sentence is too large, need to break it into words\n          if (sentenceContent.length > maxChunkSize) {\n            const words = sentenceContent.split(/(\\s+)/);\n            currentChunk = '';\n\n            for (let j = 0; j < words.length; j += 2) {\n              const word = words[j];\n              const wordDelimiter = words[j + 1] || '';\n              const wordContent = word.trim() + wordDelimiter;\n\n              if (!wordContent) {\n                continue;\n              }\n\n              if (currentChunk.length + wordContent.length > maxChunkSize) {\n                if (currentChunk) {\n                  chunks.push({ ...block, content: currentChunk });\n                  currentChunk = '';\n                }\n                // If single word is too large, break into characters\n                if (wordContent.length > maxChunkSize) {\n                  for (let k = 0; k < wordContent.length; k += maxChunkSize) {\n                    chunks.push({\n                      ...block,\n                      content: wordContent.slice(k, k + maxChunkSize),\n                    });\n                  }\n                } else {\n                  currentChunk = wordContent;\n                }\n              } else {\n                currentChunk += wordContent;\n              }\n            }\n          } else {\n            currentChunk = sentenceContent;\n          }\n        } else {\n          currentChunk += sentenceContent;\n        }\n      }\n\n      if (currentChunk) {\n        chunks.push({ ...block, content: currentChunk });\n      }\n    }\n  }\n\n  return chunks;\n};\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { synchronized } from '@dxos/async';\nimport { Resource, type Context } from '@dxos/context';\nimport { invariant } from '@dxos/invariant';\nimport type { LevelDB } from '@dxos/kv-store';\nimport { log } from '@dxos/log';\nimport { IndexKind } from '@dxos/protocols/proto/dxos/echo/indexing';\nimport { trace } from '@dxos/tracing';\nimport { ComplexMap } from '@dxos/util';\n\nimport type { IndexMetadataStore, IndexStore } from './store';\nimport type { IdToHeads, Index, ObjectSnapshot } from './types';\n\n/**\n * Loads documents by their ID and version.\n */\ninterface DocumentLoader {\n  loadDocuments: (ids: IdToHeads) => AsyncGenerator<ObjectSnapshot[]>;\n}\n\nexport type IndexingEngineOptions = {\n  db: LevelDB;\n\n  metadataStore: IndexMetadataStore;\n  indexStore: IndexStore;\n\n  /**\n   * Load documents by their pointers at specific hash.\n   */\n  documentLoader: DocumentLoader;\n};\n\ntype IndexUpdatedObjectsOptions = {\n  indexTimeBudget: number;\n  indexUpdateBatchSize: number;\n};\n\n/**\n * Manages multiple asynchronous indexes.\n */\nexport class IndexingEngine extends Resource {\n  private readonly _db: LevelDB;\n  private readonly _metadataStore: IndexMetadataStore;\n  private readonly _indexStore: IndexStore;\n  private readonly _documentLoader: DocumentLoader;\n\n  /**\n   * Indexes that are kept in-sync with the documents and are serialized to disk.\n   */\n  private readonly _indexes = new ComplexMap<IndexKind, Index>((kind) =>\n    kind.kind === IndexKind.Kind.FIELD_MATCH ? `${kind.kind}:${kind.field}` : kind.kind,\n  );\n\n  /**\n   * Indexes that were recently created and might not be fully caught up with the documents.\n   * They are not serialized to disk until they are promoted.\n   *\n   * This separation is needed because the tracking of processed documents is done globally and not per-index.\n   * This means that all indexes will be updated with the same documents in lockstep.\n   * This also means that newly created indexes cannot be saved to disk until they have processed all clean documents.\n   */\n  private readonly _newIndexes: Index[] = [];\n\n  constructor(options: IndexingEngineOptions) {\n    super();\n\n    this._db = options.db;\n    this._metadataStore = options.metadataStore;\n    this._indexStore = options.indexStore;\n    this._documentLoader = options.documentLoader;\n  }\n\n  protected override async _open(ctx: Context): Promise<void> {}\n\n  protected override async _close(ctx: Context): Promise<void> {\n    for (const index of this._indexes.values()) {\n      await index.close();\n    }\n    this._newIndexes.length = 0;\n    this._indexes.clear();\n  }\n\n  get indexKinds(): IndexKind[] {\n    return [...this._indexes.keys()];\n  }\n\n  get indexes(): Index[] {\n    return [...this._indexes.values()];\n  }\n\n  get newIndexCount(): number {\n    return this._newIndexes.length;\n  }\n\n  getIndex(kind: IndexKind): Index | undefined {\n    return this._indexes.get(kind);\n  }\n\n  deleteIndex(kind: IndexKind): void {\n    this._indexes.delete(kind);\n  }\n\n  async addPersistentIndex(index: Index): Promise<void> {\n    this._indexes.set(index.kind, index);\n    await index.open();\n  }\n\n  async addNewIndex(index: Index): Promise<void> {\n    this._newIndexes.push(index);\n    await index.open();\n  }\n\n  async loadIndexKindsFromDisk(): Promise<Map<string, IndexKind>> {\n    return this._indexStore.loadIndexKindsFromDisk();\n  }\n\n  async loadIndexFromDisk(identifier: string): Promise<void> {\n    const index = await this._indexStore.load(identifier);\n    this._indexes.set(index.kind, index);\n    await index.open();\n  }\n\n  async removeIndexFromDisk(identifier: string): Promise<void> {\n    await this._indexStore.remove(identifier);\n  }\n\n  /**\n   * Promotes new indexes to the main indexes.\n   */\n  @trace.span({ showInBrowserTimeline: true })\n  async promoteNewIndexes(): Promise<void> {\n    const documentsToIndex = await this._metadataStore.getAllIndexedDocuments();\n    for await (const documents of this._documentLoader.loadDocuments(documentsToIndex)) {\n      if (this._ctx.disposed) {\n        return;\n      }\n      await this._updateIndexes(this._newIndexes, documents);\n    }\n    this._newIndexes.forEach((index) => this._indexes.set(index.kind, index));\n    this._newIndexes.length = 0; // Clear new indexes.\n    await this._saveIndexes();\n  }\n\n  /**\n   * Indexes updated objects.\n   * @returns completed - whether the indexing was completed\n   * @returns updated - whether the indexing updated any indexes\n   */\n  @trace.span({ showInBrowserTimeline: true })\n  async indexUpdatedObjects(options: IndexUpdatedObjectsOptions): Promise<{ completed: boolean; updated: boolean }> {\n    let completed = true;\n    let updated = false;\n\n    if (this._ctx.disposed) {\n      return { completed, updated };\n    }\n    const idToHeads = await this._metadataStore.getDirtyDocuments();\n\n    log('dirty objects to index', { count: idToHeads.size });\n    if (idToHeads.size === 0 || this._ctx.disposed) {\n      return { completed, updated };\n    }\n\n    const startTime = Date.now();\n    const documentsUpdated: ObjectSnapshot[] = [];\n    const saveIndexChanges = async () => {\n      log('Saving index changes', { count: documentsUpdated.length, timeSinceStart: Date.now() - startTime });\n      await this._saveIndexes();\n      const batch = this._db.batch();\n      this._metadataStore.markClean(new Map(documentsUpdated.map((document) => [document.id, document.heads])), batch);\n      await batch.write();\n    };\n\n    const updates: boolean[] = [];\n    for await (const documents of this._documentLoader.loadDocuments(idToHeads)) {\n      if (this._ctx.disposed) {\n        return { completed, updated };\n      }\n      updates.push(...(await this._updateIndexes(Array.from(this._indexes.values()), documents)));\n      documentsUpdated.push(...documents);\n      if (documentsUpdated.length >= options.indexUpdateBatchSize) {\n        await saveIndexChanges();\n        documentsUpdated.length = 0;\n      }\n      if (Date.now() - startTime > options.indexTimeBudget) {\n        if (documentsUpdated.length > 0) {\n          await saveIndexChanges();\n        }\n        log('Indexing time budget exceeded', { time: Date.now() - startTime });\n        completed = false;\n        break;\n      }\n    }\n    await saveIndexChanges();\n    if (updates.some(Boolean)) {\n      updated = true;\n    }\n\n    log('Indexing finished', { time: Date.now() - startTime });\n    return { completed, updated };\n  }\n\n  @trace.span({ showInBrowserTimeline: true })\n  private async _updateIndexes(indexes: Index[], documents: ObjectSnapshot[]): Promise<boolean[]> {\n    const updates: boolean[] = [];\n    for (const index of indexes) {\n      if (this._ctx.disposed) {\n        return updates;\n      }\n      switch (index.kind.kind) {\n        case IndexKind.Kind.FIELD_MATCH:\n          invariant(index.kind.field, 'Field match index kind should have a field');\n          updates.push(\n            ...(await updateIndexWithObjects(\n              index,\n              documents.filter((document) => index.kind.field! in document.object),\n            )),\n          );\n          break;\n        case IndexKind.Kind.SCHEMA_MATCH:\n          updates.push(...(await updateIndexWithObjects(index, documents)));\n          break;\n        case IndexKind.Kind.GRAPH:\n          updates.push(...(await updateIndexWithObjects(index, documents)));\n          break;\n        case IndexKind.Kind.VECTOR:\n          updates.push(...(await updateIndexWithObjects(index, documents)));\n          break;\n        case IndexKind.Kind.FULL_TEXT:\n          updates.push(...(await updateIndexWithObjects(index, documents)));\n          break;\n      }\n    }\n    return updates;\n  }\n\n  @trace.span({ showInBrowserTimeline: true })\n  @synchronized\n  private async _saveIndexes(): Promise<void> {\n    for (const index of this._indexes.values()) {\n      if (this._ctx.disposed) {\n        return;\n      }\n      await this._indexStore.save(index);\n    }\n  }\n}\n\nconst updateIndexWithObjects = async (index: Index, snapshots: ObjectSnapshot[]) =>\n  Promise.all(snapshots.map((snapshot) => index.update(snapshot.id, snapshot.object)));\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport isEqual from 'lodash.isequal';\n\nimport { invariant } from '@dxos/invariant';\nimport { type SublevelDB } from '@dxos/kv-store';\nimport { type IndexKind } from '@dxos/protocols/proto/dxos/echo/indexing';\nimport { trace } from '@dxos/tracing';\n\nimport { IndexConstructors } from '../indexes';\nimport { type Index } from '../types';\n\nconst CODEC_VERSION = 2;\n\ntype IndexData = {\n  kind: IndexKind;\n  index: string;\n  version: number;\n};\n\nexport type IndexStoreParams = {\n  db: SublevelDB;\n};\n\n// TODO(mykola): Delete header from storage codec.\nexport class IndexStore {\n  private readonly _db: SublevelDB;\n  constructor({ db }: IndexStoreParams) {\n    this._db = db;\n\n    trace.diagnostic({\n      id: 'indexes',\n      name: 'Indexes',\n      fetch: async () => {\n        const indexes = await this._db.iterator<string, IndexData>(encodings).all();\n        return indexes.map(([identifier, { index, ...rest }]) => ({\n          identifier,\n          ...rest,\n        }));\n      },\n    });\n  }\n\n  async save(index: Index): Promise<void> {\n    await this._db.put<string, IndexData>(index.identifier, await indexCodec.encode(index), encodings);\n  }\n\n  async load(identifier: string): Promise<Index> {\n    const data = await this._db.get<string, IndexData>(identifier, encodings);\n    return indexCodec.decode(identifier, data);\n  }\n\n  async remove(identifier: string): Promise<void> {\n    await this._db.del(identifier, encodings);\n  }\n\n  /**\n   *\n   * @returns Map of index identifiers vs their kinds.\n   */\n  async loadIndexKindsFromDisk(): Promise<Map<string, IndexKind>> {\n    const kinds = new Map<string, IndexKind>();\n\n    for await (const [identifier, data] of this._db.iterator<string, IndexData>(encodings)) {\n      data.kind && kinds.set(identifier, data.kind);\n    }\n\n    // Delete all indexes that are colliding with the same kind.\n    {\n      const seenKinds: IndexKind[] = [];\n      const allKinds = Array.from(kinds.values());\n      for (const kind of allKinds) {\n        if (!seenKinds.some((seenKind) => isEqual(seenKind, kind))) {\n          seenKinds.push(kind);\n          continue;\n        }\n\n        const entries = Array.from(kinds.entries());\n        for (const [identifier, indexKind] of entries) {\n          if (isEqual(indexKind, kind)) {\n            await this.remove(identifier);\n            kinds.delete(identifier);\n          }\n        }\n      }\n    }\n\n    return kinds;\n  }\n}\n\nconst encodings = { keyEncoding: 'utf8', valueEncoding: 'json' };\n\nconst indexCodec = {\n  encode: async (index: Index): Promise<IndexData> => {\n    return {\n      index: await index.serialize(),\n      kind: index.kind,\n      version: CODEC_VERSION,\n    };\n  },\n  decode: async (identifier: string, data: IndexData): Promise<Index> => {\n    invariant(data.version === CODEC_VERSION, `Index version ${data.version} is not supported`);\n    const IndexConstructor = IndexConstructors[data.kind.kind];\n    invariant(IndexConstructor, `Index kind ${data.kind.kind} is not supported`);\n    return IndexConstructor.load({ serialized: data.index, indexKind: data.kind, identifier });\n  },\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { type Heads } from '@automerge/automerge';\nimport { type MixedEncoding } from 'level-transcoder';\n\nimport { Event } from '@dxos/async';\nimport type { ProtoCodec } from '@dxos/codec-protobuf';\nimport { invariant } from '@dxos/invariant';\nimport { type SublevelDB, type BatchLevel } from '@dxos/kv-store';\nimport { log } from '@dxos/log';\nimport { type ObjectPointerEncoded, objectPointerCodec } from '@dxos/protocols';\nimport { schema } from '@dxos/protocols/proto';\nimport { type Heads as HeadsProto } from '@dxos/protocols/proto/dxos/echo/query';\nimport { trace } from '@dxos/tracing';\nimport { joinTables } from '@dxos/util';\n\nimport { type IdToHeads } from '../types';\n\nexport type IndexMetadataStoreParams = {\n  db: SublevelDB;\n};\n\n@trace.resource()\nexport class IndexMetadataStore {\n  public readonly dirty = new Event<void>();\n  public readonly clean = new Event<void>();\n\n  /**\n   * Documents that were saved by automerge-repo but maybe not indexed (also includes indexed documents).\n   * ObjectPointerEncoded -> Heads\n   */\n  private readonly _lastSeen: SublevelDB;\n\n  /**\n   * Documents that were indexing\n   * ObjectPointerEncoded -> Heads\n   */\n  private readonly _lastIndexed: SublevelDB;\n\n  constructor({ db }: IndexMetadataStoreParams) {\n    this._lastSeen = db.sublevel('last-seen', { valueEncoding: headsEncoding, keyEncoding: 'utf8' });\n    this._lastIndexed = db.sublevel('last-indexed', { valueEncoding: headsEncoding, keyEncoding: 'utf8' });\n\n    trace.diagnostic({\n      id: 'indexed-documents',\n      name: 'Indexed Documents',\n      fetch: async () => {\n        const [dirty, indexed] = await Promise.all([this.getDirtyDocuments(), this.getAllIndexedDocuments()]);\n\n        return joinTables(\n          'id',\n          'id',\n          Array.from(dirty.entries()).map(([id, heads]) => ({ id, dirtyHeads: heads.join(',') })),\n          Array.from(indexed.entries()).map(([id, heads]) => ({ id, indexedHeads: heads.join(',') })),\n        );\n      },\n    });\n  }\n\n  @trace.span({ showInBrowserTimeline: true })\n  async getDirtyDocuments(): Promise<IdToHeads> {\n    return new Map(await this._lastSeen.iterator<ObjectPointerEncoded>({}).all());\n  }\n\n  /**\n   * @returns All document id's that were already indexed. May include dirty documents.\n   */\n  async getAllIndexedDocuments(): Promise<IdToHeads> {\n    return new Map(await this._lastIndexed.iterator<ObjectPointerEncoded>({}).all());\n  }\n\n  @trace.span({ showInBrowserTimeline: true })\n  markDirty(idToHeads: IdToHeads, batch: BatchLevel): void {\n    log('mark dirty', { count: idToHeads.size });\n    for (const [id, heads] of idToHeads.entries()) {\n      batch.put(id, heads, { sublevel: this._lastSeen, valueEncoding: headsEncoding });\n\n      // Delete old v0 entries.\n      batch.del(objectPointerCodec.convertV1ToV0(id), { sublevel: this._lastIndexed });\n    }\n  }\n\n  /**\n   * Called after leveldb batch commit.\n   */\n  notifyMarkedDirty(): void {\n    this.dirty.emit();\n  }\n\n  @trace.span({ showInBrowserTimeline: true })\n  markClean(idToHeads: IdToHeads, batch: BatchLevel): void {\n    log('mark clean', { count: idToHeads.size });\n    for (const [id, heads] of idToHeads.entries()) {\n      batch.put(id, heads, { sublevel: this._lastIndexed, valueEncoding: headsEncoding });\n      batch.del(id, { sublevel: this._lastSeen });\n\n      // Delete old v0 entries.\n      batch.del(objectPointerCodec.convertV1ToV0(id), { sublevel: this._lastIndexed });\n      batch.del(objectPointerCodec.convertV1ToV0(id), { sublevel: this._lastSeen });\n    }\n  }\n\n  /**\n   * Called on re-indexing.\n   */\n  dropFromClean(ids: ObjectPointerEncoded[], batch: BatchLevel): void {\n    for (const id of ids) {\n      batch.del(id, { sublevel: this._lastIndexed });\n    }\n  }\n}\n\n// NOTE: Lazy so that code that doesn't use indexing doesn't need to load the codec (breaks in workerd).\nlet headsCodec!: ProtoCodec<HeadsProto>;\nconst getHeadsCodec = () => (headsCodec ??= schema.getCodecForType('dxos.echo.query.Heads'));\n\nlet showedWarning = false;\nexport const headsEncoding: MixedEncoding<Heads, Uint8Array, Heads> = {\n  encode: (value: Heads): Uint8Array => getHeadsCodec().encode({ hashes: value }),\n  decode: (encodedValue: Uint8Array): Heads => {\n    try {\n      return getHeadsCodec().decode(encodedValue).hashes!;\n    } catch (err) {\n      // TODO(mykola): remove this before 0.7 release.\n      // Migration from old format.\n      if (!showedWarning) {\n        showedWarning = true;\n        log.warn('Detected legacy encoding of heads in the indexer. \\nRun `await dxos.client.repair()`');\n      }\n      /**\n       * Document head hashes concatenated with no  separator.\n       */\n      const concatenatedHeads = Buffer.from(encodedValue).toString('utf8').replace(/\"/g, '');\n\n      // Split concatenated heads into individual hashes by 64 characters.\n      invariant(concatenatedHeads.length % 64 === 0, 'Invalid concatenated heads length');\n      const heads = [];\n      for (let i = 0; i < concatenatedHeads.length; i += 64) {\n        heads.push(concatenatedHeads.slice(i, i + 64));\n      }\n      return heads;\n    }\n  },\n  format: 'buffer',\n};\n"],
  "mappings": "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",
  "names": ["isEqual", "DeferredTask", "Event", "sleepWithContext", "synchronized", "LifecycleState", "Resource", "invariant", "log", "IndexKind", "trace", "Orama", "Event", "Resource", "invariant", "PublicKey", "log", "IndexKind", "trace", "decodeReference", "isEncodedReference", "ObjectStructure", "visitValues", "IGNORED_TYPENAMES", "extractTextBlocks", "object", "type", "ObjectStructure", "getTypeReference", "dxnType", "decodeReference", "toDXN", "includes", "asTypeDXN", "blocks", "go", "value", "_key", "isEncodedReference", "push", "content", "visitValues", "data", "Schema", "invariant", "staticImplements", "constructor", "EscapedPropPath", "String", "annotations", "title", "escape", "path", "map", "p", "toString", "replaceAll", "join", "unescape", "parts", "current", "i", "length", "push", "IndexText", "Resource", "_identifier", "PublicKey", "random", "toString", "kind", "IndexKind", "Kind", "FULL_TEXT", "updated", "Event", "_orama", "undefined", "_open", "create", "schema", "chunks", "identifier", "update", "id", "object", "blocks", "extractTextBlocks", "invariant", "remove", "insert", "map", "block", "content", "find", "filter", "typenames", "length", "inverted", "graph", "text", "query", "results", "search", "mode", "term", "limit", "offset", "log", "info", "hits", "hit", "rank", "score", "serialize", "JSON", "stringify", "save", "load", "serialized", "deserialized", "parse", "index", "open", "span", "showInBrowserTimeline", "resource", "Event", "Resource", "decodeReference", "EXPANDO_TYPENAME", "DXN", "PublicKey", "log", "IndexKind", "trace", "defaultMap", "IndexSchema", "Resource", "_identifier", "PublicKey", "random", "toString", "kind", "IndexKind", "Kind", "SCHEMA_MATCH", "updated", "Event", "_index", "Map", "identifier", "update", "id", "object", "get", "getTypeFromObject", "has", "defaultMap", "Set", "add", "remove", "_", "ids", "entries", "delete", "find", "filter", "inverted", "Array", "from", "key", "typenames", "includes", "EXPANDO_TYPENAME", "flatMap", "value", "map", "rank", "length", "values", "results", "typename", "DXN", "isDXNString", "parse", "asTypeDXN", "type", "push", "dxn", "isLocalObjectId", "objectId", "parts", "TYPE", "log", "warn", "flat", "serialize", "JSON", "stringify", "index", "load", "serialized", "serializedIndex", "set", "span", "showInBrowserTimeline", "resource", "system", "decodeReference", "IndexKind", "pipe", "Schema", "Event", "Resource", "decodeReference", "ObjectStructure", "EntityKind", "ObjectId", "InternalError", "PublicKey", "log", "ObjectPointerEncoded", "IndexKind", "trace", "defaultMap", "entries", "IndexGraph", "Resource", "_identifier", "PublicKey", "random", "toString", "kind", "IndexKind", "Kind", "GRAPH", "updated", "Event", "_inboundReferences", "Map", "_relationTargets", "_relationSources", "_objectToTargets", "identifier", "update", "id", "object", "ObjectStructure", "getEntityKind", "EntityKind", "Object", "_removeReferencesFrom", "_trackOutgoingReferences", "Relation", "targetMapping", "defaultMap", "Set", "source", "getRelationSource", "target", "getRelationTarget", "sourceObject", "decodeReference", "toDXN", "asEchoDXN", "echoId", "add", "log", "warn", "targetObject", "remove", "get", "perField", "field", "keys", "delete", "clear", "references", "getAllOutgoingReferences", "path", "reference", "escapedPath", "EscapedPropPath", "escape", "pipe", "map", "find", "filter", "inverted", "typenames", "length", "graph", "InternalError", "anchors", "property", "results", "anchor", "sources", "escapedProp", "entries", "prop", "unescape", "firstSegmentMatches", "secondSegmentIsNumeric", "isNaN", "Number", "push", "Array", "from", "rank", "values", "TypeError", "serialize", "data", "inboundReferences", "fromEntries", "perProp", "relationTargets", "relationSources", "objectToTargets", "JSON", "stringify", "load", "serialized", "index", "open", "GraphIndexData", "Schema", "decodeUnknownSync", "parse", "_loadFrom", "propMap", "set", "span", "showInBrowserTimeline", "resource", "Struct", "Record", "key", "ObjectId", "value", "ObjectPointerEncoded", "Orama", "Event", "Resource", "invariant", "PublicKey", "log", "IndexKind", "trace", "pipeline", "Resource", "DEFAULT_OPTIONS", "model", "chunkCombination", "maxChunkSize", "EmbeddingExtractor", "Resource", "options", "_extractor", "undefined", "_options", "_open", "pipeline", "_close", "dispose", "extract", "data", "extractor", "chunks", "breakIntoChunks", "embedding", "map", "block", "content", "pooling", "normalize", "vectors", "tolist", "combineChunks", "combined", "Array", "length", "fill", "vector", "i", "value", "Math", "max", "paragraphs", "split", "paragraph", "trim", "push", "sentences", "currentChunk", "sentence", "delimiter", "sentenceContent", "words", "j", "word", "wordDelimiter", "wordContent", "k", "slice", "VECTOR_DIMENSION", "IndexVector", "Resource", "_identifier", "PublicKey", "random", "toString", "_extractor", "EmbeddingExtractor", "kind", "IndexKind", "Kind", "VECTOR", "updated", "Event", "_orama", "undefined", "_open", "open", "create", "schema", "embedding", "identifier", "update", "id", "object", "blocks", "extractTextBlocks", "log", "length", "invariant", "remove", "embeddings", "extract", "insert", "find", "filter", "typenames", "inverted", "graph", "text", "query", "content", "results", "search", "mode", "vector", "value", "property", "similarity", "includeVectors", "limit", "offset", "info", "hits", "map", "hit", "rank", "score", "serialize", "JSON", "stringify", "save", "load", "serialized", "deserialized", "parse", "index", "span", "showInBrowserTimeline", "resource", "IndexConstructors", "IndexKind", "Kind", "SCHEMA_MATCH", "IndexSchema", "GRAPH", "IndexGraph", "VECTOR", "IndexVector", "FULL_TEXT", "IndexText", "synchronized", "Resource", "invariant", "log", "IndexKind", "trace", "ComplexMap", "IndexingEngine", "options", "_indexes", "kind", "Kind", "FIELD_MATCH", "field", "_newIndexes", "_db", "db", "_metadataStore", "metadataStore", "_indexStore", "indexStore", "_documentLoader", "documentLoader", "_open", "ctx", "_close", "index", "values", "close", "length", "clear", "indexKinds", "keys", "indexes", "newIndexCount", "getIndex", "get", "deleteIndex", "delete", "addPersistentIndex", "set", "open", "addNewIndex", "push", "loadIndexKindsFromDisk", "loadIndexFromDisk", "identifier", "load", "removeIndexFromDisk", "remove", "promoteNewIndexes", "documentsToIndex", "getAllIndexedDocuments", "documents", "loadDocuments", "_ctx", "disposed", "_updateIndexes", "forEach", "_saveIndexes", "indexUpdatedObjects", "completed", "updated", "idToHeads", "getDirtyDocuments", "count", "size", "startTime", "Date", "now", "documentsUpdated", "saveIndexChanges", "timeSinceStart", "batch", "markClean", "Map", "map", "document", "id", "heads", "write", "updates", "Array", "from", "indexUpdateBatchSize", "indexTimeBudget", "time", "some", "Boolean", "updateIndexWithObjects", "filter", "object", "SCHEMA_MATCH", "GRAPH", "VECTOR", "FULL_TEXT", "save", "span", "showInBrowserTimeline", "snapshots", "Promise", "all", "snapshot", "update", "DEFAULT_INDEX_UPDATE_BATCH_SIZE", "DEFAULT_INDEX_COOLDOWN_TIME", "DEFAULT_INDEX_TIME_BUDGET", "Indexer", "Resource", "db", "metadataStore", "indexStore", "loadDocuments", "indexUpdateBatchSize", "indexCooldownTime", "indexTimeBudget", "updated", "Event", "_lastRunFinishedAt", "_db", "_metadataStore", "_indexUpdateBatchSize", "_indexCooldownTime", "_indexTimeBudget", "_engine", "IndexingEngine", "documentLoader", "initialized", "_lifecycleState", "LifecycleState", "OPEN", "setConfig", "config", "_indexConfig", "log", "warn", "kind", "indexKinds", "indexes", "some", "isEqual", "deleteIndex", "_loadIndexes", "_run", "schedule", "_open", "ctx", "open", "DeferredTask", "_ctx", "enabled", "cooldownMs", "Date", "now", "sleepWithContext", "newIndexCount", "_promoteNewIndexes", "_indexUpdatedObjects", "dirty", "on", "_close", "join", "close", "_catch", "err", "catch", "execQuery", "filter", "Error", "graph", "graphIndex", "getIndex", "IndexKind", "Kind", "GRAPH", "find", "text", "vectorIndex", "VECTOR", "textIndex", "FULL_TEXT", "typenameIndex", "SCHEMA_MATCH", "reindex", "idToHeads", "batch", "markDirty", "dropFromClean", "Array", "from", "keys", "write", "runBlocking", "updateIndexes", "kinds", "loadIndexKindsFromDisk", "identifier", "entries", "configKind", "loadIndexFromDisk", "removeIndexFromDisk", "IndexConstructor", "IndexConstructors", "invariant", "addNewIndex", "promoteNewIndexes", "emit", "disposed", "completed", "indexUpdatedObjects", "span", "showInBrowserTimeline", "resource", "isEqual", "invariant", "trace", "CODEC_VERSION", "IndexStore", "db", "_db", "trace", "diagnostic", "id", "name", "fetch", "indexes", "iterator", "encodings", "all", "map", "identifier", "index", "rest", "save", "put", "indexCodec", "encode", "load", "data", "get", "decode", "remove", "del", "loadIndexKindsFromDisk", "kinds", "Map", "kind", "set", "seenKinds", "allKinds", "Array", "from", "values", "some", "seenKind", "isEqual", "push", "entries", "indexKind", "delete", "keyEncoding", "valueEncoding", "serialize", "version", "invariant", "IndexConstructor", "IndexConstructors", "serialized", "Event", "invariant", "log", "objectPointerCodec", "schema", "trace", "joinTables", "IndexMetadataStore", "db", "dirty", "clean", "_lastSeen", "sublevel", "valueEncoding", "headsEncoding", "keyEncoding", "_lastIndexed", "diagnostic", "id", "name", "fetch", "indexed", "Promise", "all", "getDirtyDocuments", "getAllIndexedDocuments", "Array", "from", "entries", "map", "heads", "dirtyHeads", "join", "indexedHeads", "Map", "iterator", "markDirty", "idToHeads", "batch", "count", "size", "put", "del", "convertV1ToV0", "notifyMarkedDirty", "emit", "markClean", "dropFromClean", "ids", "span", "showInBrowserTimeline", "resource", "headsCodec", "getHeadsCodec", "getCodecForType", "showedWarning", "encode", "value", "hashes", "decode", "encodedValue", "err", "warn", "concatenatedHeads", "Buffer", "toString", "replace", "length", "i", "push", "slice", "format"]
}
