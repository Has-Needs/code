import { type Heads } from '@automerge/automerge';
import { type MixedEncoding } from 'level-transcoder';
import { Event } from '@dxos/async';
import { type SublevelDB, type BatchLevel } from '@dxos/kv-store';
import { type ObjectPointerEncoded } from '@dxos/protocols';
import { type IdToHeads } from '../types';
export type IndexMetadataStoreParams = {
    db: SublevelDB;
};
export declare class IndexMetadataStore {
    readonly dirty: Event<void>;
    readonly clean: Event<void>;
    /**
     * Documents that were saved by automerge-repo but maybe not indexed (also includes indexed documents).
     * ObjectPointerEncoded -> Heads
     */
    private readonly _lastSeen;
    /**
     * Documents that were indexing
     * ObjectPointerEncoded -> Heads
     */
    private readonly _lastIndexed;
    constructor({ db }: IndexMetadataStoreParams);
    getDirtyDocuments(): Promise<IdToHeads>;
    /**
     * @returns All document id's that were already indexed. May include dirty documents.
     */
    getAllIndexedDocuments(): Promise<IdToHeads>;
    markDirty(idToHeads: IdToHeads, batch: BatchLevel): void;
    /**
     * Called after leveldb batch commit.
     */
    notifyMarkedDirty(): void;
    markClean(idToHeads: IdToHeads, batch: BatchLevel): void;
    /**
     * Called on re-indexing.
     */
    dropFromClean(ids: ObjectPointerEncoded[], batch: BatchLevel): void;
}
export declare const headsEncoding: MixedEncoding<Heads, Uint8Array, Heads>;
//# sourceMappingURL=index-metadata-store.d.ts.map