import { type Heads } from '@automerge/automerge';
import { Schema } from 'effect';
import type { SchemaClass } from 'effect/Schema';
import { type Event } from '@dxos/async';
import { type ObjectPropPath, type ObjectStructure } from '@dxos/echo-protocol';
import type { ObjectId } from '@dxos/echo-schema';
import { type ObjectPointerEncoded } from '@dxos/protocols';
import { type IndexKind } from '@dxos/protocols/proto/dxos/echo/indexing';
/**
 * Unified query interface for all indexes.
 * @deprecated To be replaced by a specialized API for each index.
 */
export type IndexQuery = {
    /**
     * empty array means all objects (no filter).
     */
    typenames: string[];
    inverted?: boolean;
    /**
     * Graph-based search.
     */
    graph?: {
        /**
         * Relation kind.
         */
        kind: 'inbound-reference' | 'relation-source' | 'relation-target';
        /**
         * anchor objects to search from.
         */
        anchors: ObjectId[];
        /**
         * Filter by property name.
         * Only when kind is 'inbound-reference'.
         */
        property: EscapedPropPath | null;
    };
    text?: {
        query: string;
        kind: 'vector' | 'text';
    };
};
export type ObjectSnapshot = {
    /**
     * Object ID in the indexer format.
     */
    id: ObjectPointerEncoded;
    object: ObjectStructure;
    heads: Heads;
};
export type IdToHeads = Map<ObjectPointerEncoded, Heads>;
export type FindResult = {
    id: ObjectPointerEncoded;
    rank: number;
};
export interface Index {
    identifier: string;
    kind: IndexKind;
    updated: Event;
    open(): Promise<Index>;
    close(): Promise<Index>;
    /**
     * Add an object to the index.
     * @returns {Promise<boolean>} true if the index was updated, false otherwise.
     */
    update(id: ObjectPointerEncoded, object: ObjectStructure): Promise<boolean>;
    /**
     * Remove an object from the index.
     */
    remove(id: ObjectPointerEncoded): Promise<void>;
    find(filter: IndexQuery): Promise<FindResult[]>;
    serialize(): Promise<string>;
}
export type LoadParams = {
    serialized: string;
    indexKind: IndexKind;
    identifier: string;
};
export interface IndexStaticProps {
    new (kind: IndexKind): Index;
    load(params: LoadParams): Promise<Index>;
}
/**
 * Type-only annotation to assert that a class-constructor implements an interface T (with it's static methods).
 */
export declare const staticImplements: <T>() => <U extends T>(constructor: U) => U;
/**
 * Escaped property path within an object.
 *
 * Escaping rules:
 *
 * - '.' -> '\.'
 * - '\' -> '\\'
 * - contact with .
 */
export declare const EscapedPropPath: SchemaClass<string, string> & {
    escape: (path: ObjectPropPath) => EscapedPropPath;
    unescape: (path: EscapedPropPath) => ObjectPropPath;
};
export type EscapedPropPath = Schema.Schema.Type<typeof EscapedPropPath>;
//# sourceMappingURL=types.d.ts.map