{
  "version": 3,
  "sources": ["../../../../src/testing/test-peer.ts", "../../../../src/testing/utils.ts", "../../../../src/testing/test-messages.ts", "../../../../src/testing/test-builder.ts"],
  "sourcesContent": ["//\n// Copyright 2022 DXOS.org\n//\n\nimport { Event } from '@dxos/async';\nimport { Resource } from '@dxos/context';\nimport { PeerSchema } from '@dxos/edge-client';\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { buf } from '@dxos/protocols/buf';\n\nimport { type TestBuilder } from './test-builder';\nimport { expectPeerAvailable, expectPeerLeft, expectReceivedMessage } from './utils';\nimport { Messenger } from '../messenger';\nimport { type SignalManager } from '../signal-manager';\nimport { type Message, type PeerInfo } from '../signal-methods';\n\nexport class TestPeer extends Resource {\n  public peerId = PublicKey.random();\n  public signalManager!: SignalManager;\n  public messenger!: Messenger;\n  public defaultReceived = new Event<Message>();\n\n  constructor(private readonly testBuilder: TestBuilder) {\n    super();\n  }\n\n  get peerInfo(): PeerInfo {\n    return buf.create(PeerSchema, { peerKey: this.peerId.toHex(), identityKey: this.peerId.toHex() });\n  }\n\n  async waitTillReceive(message: Message): Promise<Message> {\n    return expectReceivedMessage(this.defaultReceived, message);\n  }\n\n  async waitForPeerAvailable(topic: PublicKey, peer: PeerInfo) {\n    return expectPeerAvailable(this.signalManager, topic, peer);\n  }\n\n  async waitForPeerLeft(topic: PublicKey, peer: PeerInfo) {\n    return expectPeerLeft(this.signalManager, topic, peer);\n  }\n\n  protected override async _open(): Promise<void> {\n    this.signalManager = await this.testBuilder.createSignalManager(this);\n    this.messenger = new Messenger({ signalManager: this.signalManager, retryDelay: 300 });\n\n    await this.signalManager.open();\n    this.messenger.open();\n    await this.messenger\n      .listen({\n        peer: this.peerInfo,\n        onMessage: async (msg) => {\n          this.defaultReceived.emit(msg);\n        },\n      })\n      .catch((err) => log.catch(err));\n  }\n\n  protected override async _close(): Promise<void> {\n    await this.messenger.close();\n    await this.signalManager.close();\n  }\n}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { asyncTimeout, type Event } from '@dxos/async';\nimport { type Any } from '@dxos/codec-protobuf';\nimport { PublicKey } from '@dxos/keys';\n\nimport { PAYLOAD_1 } from './test-messages';\nimport { type SignalMethods, type Message, type PeerInfo } from '../signal-methods';\n\nexport const expectPeerAvailable = (client: SignalMethods, expectedTopic: PublicKey, peer: PeerInfo) =>\n  asyncTimeout(\n    client.swarmEvent.waitFor(\n      ({ peerAvailable, topic }) =>\n        !!peerAvailable && peer.peerKey === peerAvailable.peer.peerKey && expectedTopic.equals(topic),\n    ),\n    6000,\n  );\n\nexport const expectPeerLeft = (client: SignalMethods, expectedTopic: PublicKey, peer: PeerInfo) =>\n  asyncTimeout(\n    client.swarmEvent.waitFor(\n      ({ peerLeft, topic }) => !!peerLeft && peer.peerKey === peerLeft.peer.peerKey && expectedTopic.equals(topic),\n    ),\n    6000,\n  );\n\nexport const expectReceivedMessage = (event: Event<Message>, expectedMessage: Message) => {\n  return asyncTimeout(\n    event.waitFor(\n      (msg) =>\n        msg.author.peerKey === expectedMessage.author.peerKey &&\n        msg.recipient.peerKey === expectedMessage.recipient.peerKey &&\n        PublicKey.from(msg.payload.value).equals(expectedMessage.payload.value),\n    ),\n    5000,\n  );\n};\n\nexport const createMessage = (author: PeerInfo, recipient: PeerInfo, payload: Any = PAYLOAD_1): Message => ({\n  author,\n  recipient,\n  payload,\n});\n\nexport const messageEqual = (msg1: Message, msg2: Message) =>\n  msg1.author.peerKey === msg2.author.peerKey &&\n  msg1.recipient.peerKey === msg2.recipient.peerKey &&\n  PublicKey.from(msg1.payload.value).equals(msg2.payload.value);\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { type TaggedType } from '@dxos/codec-protobuf';\nimport { type TYPES } from '@dxos/protocols/proto';\n\nexport const PAYLOAD_1: TaggedType<TYPES, 'google.protobuf.Any'> = {\n  '@type': 'google.protobuf.Any',\n  type_url: 'dxos.Example1',\n  value: Buffer.from('1'),\n};\n\nexport const PAYLOAD_2: TaggedType<TYPES, 'google.protobuf.Any'> = {\n  '@type': 'google.protobuf.Any',\n  type_url: 'dxos.Example2',\n  value: Buffer.from('2'),\n};\n\nexport const PAYLOAD_3: TaggedType<TYPES, 'google.protobuf.Any'> = {\n  '@type': 'google.protobuf.Any',\n  type_url: 'dxos.Example3',\n  value: Buffer.from('3'),\n};\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { TestPeer } from './test-peer';\nimport { type SignalManager, MemorySignalManager, MemorySignalManagerContext } from '../signal-manager';\nimport { type Message } from '../signal-methods';\n\nexport type TestBuilderOptions = {\n  signalManagerFactory?: (peer: TestPeer) => Promise<SignalManager>;\n  messageDisruption?: (msg: Message) => Message[];\n};\n\nexport class TestBuilder {\n  private _signalContext = new MemorySignalManagerContext();\n  private readonly _peers: TestPeer[] = [];\n\n  constructor(public options: TestBuilderOptions) {}\n\n  async createSignalManager(peer: TestPeer): Promise<SignalManager> {\n    const signalManager =\n      (await this.options.signalManagerFactory?.(peer)) ?? new MemorySignalManager(this._signalContext);\n\n    if (this.options.messageDisruption) {\n      // Imitates signal network disruptions (e. g. message doubling, ).\n      const trueSend = signalManager.sendMessage.bind(signalManager);\n      signalManager.sendMessage = async (message: Message) => {\n        for (const msg of this.options.messageDisruption!(message)) {\n          await trueSend(msg);\n        }\n      };\n    }\n\n    return signalManager;\n  }\n\n  async createPeer(): Promise<TestPeer> {\n    const peer = new TestPeer(this);\n    await peer.open();\n    this._peers.push(peer);\n    return peer;\n  }\n\n  async createPeers(count: number): Promise<TestPeer[]> {\n    return Promise.all(Array.from({ length: count }, () => this.createPeer()));\n  }\n\n  async close(): Promise<void> {\n    await Promise.all(this._peers.map((peer) => peer.close()));\n  }\n}\n"],
  "mappings": "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",
  "names": ["import_async", "import_keys", "PAYLOAD_1", "type_url", "value", "Buffer", "from", "PAYLOAD_2", "PAYLOAD_3", "expectPeerAvailable", "client", "expectedTopic", "peer", "asyncTimeout", "swarmEvent", "waitFor", "peerAvailable", "topic", "peerKey", "equals", "expectPeerLeft", "peerLeft", "expectReceivedMessage", "event", "expectedMessage", "msg", "author", "recipient", "PublicKey", "payload", "createMessage", "messageEqual", "msg1", "msg2", "TestPeer", "Resource", "testBuilder", "peerId", "random", "defaultReceived", "Event", "peerInfo", "buf", "create", "PeerSchema", "toHex", "identityKey", "waitTillReceive", "message", "waitForPeerAvailable", "signalManager", "waitForPeerLeft", "_open", "createSignalManager", "messenger", "Messenger", "retryDelay", "open", "listen", "onMessage", "emit", "catch", "err", "log", "_close", "close", "TestBuilder", "options", "_signalContext", "MemorySignalManagerContext", "_peers", "signalManagerFactory", "MemorySignalManager", "messageDisruption", "trueSend", "sendMessage", "bind", "createPeer", "push", "createPeers", "count", "Promise", "all", "Array", "length", "map"]
}
