"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var testing_exports = {};
__export(testing_exports, {
  PAYLOAD_1: () => PAYLOAD_1,
  PAYLOAD_2: () => PAYLOAD_2,
  PAYLOAD_3: () => PAYLOAD_3,
  TestBuilder: () => TestBuilder,
  TestPeer: () => TestPeer,
  createMessage: () => createMessage,
  expectPeerAvailable: () => expectPeerAvailable,
  expectPeerLeft: () => expectPeerLeft,
  expectReceivedMessage: () => expectReceivedMessage,
  messageEqual: () => messageEqual
});
module.exports = __toCommonJS(testing_exports);
var import_chunk_GMND65DN = require("../chunk-GMND65DN.cjs");
var import_async = require("@dxos/async");
var import_context = require("@dxos/context");
var import_edge_client = require("@dxos/edge-client");
var import_keys = require("@dxos/keys");
var import_log = require("@dxos/log");
var import_buf = require("@dxos/protocols/buf");
var import_async2 = require("@dxos/async");
var import_keys2 = require("@dxos/keys");
var PAYLOAD_1 = {
  "@type": "google.protobuf.Any",
  type_url: "dxos.Example1",
  value: Buffer.from("1")
};
var PAYLOAD_2 = {
  "@type": "google.protobuf.Any",
  type_url: "dxos.Example2",
  value: Buffer.from("2")
};
var PAYLOAD_3 = {
  "@type": "google.protobuf.Any",
  type_url: "dxos.Example3",
  value: Buffer.from("3")
};
var expectPeerAvailable = (client, expectedTopic, peer) => (0, import_async2.asyncTimeout)(client.swarmEvent.waitFor(({ peerAvailable, topic }) => !!peerAvailable && peer.peerKey === peerAvailable.peer.peerKey && expectedTopic.equals(topic)), 6e3);
var expectPeerLeft = (client, expectedTopic, peer) => (0, import_async2.asyncTimeout)(client.swarmEvent.waitFor(({ peerLeft, topic }) => !!peerLeft && peer.peerKey === peerLeft.peer.peerKey && expectedTopic.equals(topic)), 6e3);
var expectReceivedMessage = (event, expectedMessage) => {
  return (0, import_async2.asyncTimeout)(event.waitFor((msg) => msg.author.peerKey === expectedMessage.author.peerKey && msg.recipient.peerKey === expectedMessage.recipient.peerKey && import_keys2.PublicKey.from(msg.payload.value).equals(expectedMessage.payload.value)), 5e3);
};
var createMessage = (author, recipient, payload = PAYLOAD_1) => ({
  author,
  recipient,
  payload
});
var messageEqual = (msg1, msg2) => msg1.author.peerKey === msg2.author.peerKey && msg1.recipient.peerKey === msg2.recipient.peerKey && import_keys2.PublicKey.from(msg1.payload.value).equals(msg2.payload.value);
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/core/mesh/messaging/src/testing/test-peer.ts";
var TestPeer = class extends import_context.Resource {
  constructor(testBuilder) {
    super(), this.testBuilder = testBuilder, this.peerId = import_keys.PublicKey.random(), this.defaultReceived = new import_async.Event();
  }
  get peerInfo() {
    return import_buf.buf.create(import_edge_client.PeerSchema, {
      peerKey: this.peerId.toHex(),
      identityKey: this.peerId.toHex()
    });
  }
  async waitTillReceive(message) {
    return expectReceivedMessage(this.defaultReceived, message);
  }
  async waitForPeerAvailable(topic, peer) {
    return expectPeerAvailable(this.signalManager, topic, peer);
  }
  async waitForPeerLeft(topic, peer) {
    return expectPeerLeft(this.signalManager, topic, peer);
  }
  async _open() {
    this.signalManager = await this.testBuilder.createSignalManager(this);
    this.messenger = new import_chunk_GMND65DN.Messenger({
      signalManager: this.signalManager,
      retryDelay: 300
    });
    await this.signalManager.open();
    this.messenger.open();
    await this.messenger.listen({
      peer: this.peerInfo,
      onMessage: async (msg) => {
        this.defaultReceived.emit(msg);
      }
    }).catch((err) => import_log.log.catch(err, void 0, {
      F: __dxlog_file,
      L: 57,
      S: this,
      C: (f, a) => f(...a)
    }));
  }
  async _close() {
    await this.messenger.close();
    await this.signalManager.close();
  }
};
var TestBuilder = class {
  constructor(options) {
    this.options = options;
    this._signalContext = new import_chunk_GMND65DN.MemorySignalManagerContext();
    this._peers = [];
  }
  async createSignalManager(peer) {
    const signalManager = await this.options.signalManagerFactory?.(peer) ?? new import_chunk_GMND65DN.MemorySignalManager(this._signalContext);
    if (this.options.messageDisruption) {
      const trueSend = signalManager.sendMessage.bind(signalManager);
      signalManager.sendMessage = async (message) => {
        for (const msg of this.options.messageDisruption(message)) {
          await trueSend(msg);
        }
      };
    }
    return signalManager;
  }
  async createPeer() {
    const peer = new TestPeer(this);
    await peer.open();
    this._peers.push(peer);
    return peer;
  }
  async createPeers(count) {
    return Promise.all(Array.from({
      length: count
    }, () => this.createPeer()));
  }
  async close() {
    await Promise.all(this._peers.map((peer) => peer.close()));
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  PAYLOAD_1,
  PAYLOAD_2,
  PAYLOAD_3,
  TestBuilder,
  TestPeer,
  createMessage,
  expectPeerAvailable,
  expectPeerLeft,
  expectReceivedMessage,
  messageEqual
});
//# sourceMappingURL=index.cjs.map
