{
  "version": 3,
  "sources": ["../../../../src/testing/test-peer.ts", "../../../../src/testing/utils.ts", "../../../../src/testing/test-messages.ts", "../../../../src/testing/test-builder.ts"],
  "sourcesContent": ["//\n// Copyright 2022 DXOS.org\n//\n\nimport { Event } from '@dxos/async';\nimport { Resource } from '@dxos/context';\nimport { PeerSchema } from '@dxos/edge-client';\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { buf } from '@dxos/protocols/buf';\n\nimport { type TestBuilder } from './test-builder';\nimport { expectPeerAvailable, expectPeerLeft, expectReceivedMessage } from './utils';\nimport { Messenger } from '../messenger';\nimport { type SignalManager } from '../signal-manager';\nimport { type Message, type PeerInfo } from '../signal-methods';\n\nexport class TestPeer extends Resource {\n  public peerId = PublicKey.random();\n  public signalManager!: SignalManager;\n  public messenger!: Messenger;\n  public defaultReceived = new Event<Message>();\n\n  constructor(private readonly testBuilder: TestBuilder) {\n    super();\n  }\n\n  get peerInfo(): PeerInfo {\n    return buf.create(PeerSchema, { peerKey: this.peerId.toHex(), identityKey: this.peerId.toHex() });\n  }\n\n  async waitTillReceive(message: Message): Promise<Message> {\n    return expectReceivedMessage(this.defaultReceived, message);\n  }\n\n  async waitForPeerAvailable(topic: PublicKey, peer: PeerInfo) {\n    return expectPeerAvailable(this.signalManager, topic, peer);\n  }\n\n  async waitForPeerLeft(topic: PublicKey, peer: PeerInfo) {\n    return expectPeerLeft(this.signalManager, topic, peer);\n  }\n\n  protected override async _open(): Promise<void> {\n    this.signalManager = await this.testBuilder.createSignalManager(this);\n    this.messenger = new Messenger({ signalManager: this.signalManager, retryDelay: 300 });\n\n    await this.signalManager.open();\n    this.messenger.open();\n    await this.messenger\n      .listen({\n        peer: this.peerInfo,\n        onMessage: async (msg) => {\n          this.defaultReceived.emit(msg);\n        },\n      })\n      .catch((err) => log.catch(err));\n  }\n\n  protected override async _close(): Promise<void> {\n    await this.messenger.close();\n    await this.signalManager.close();\n  }\n}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { asyncTimeout, type Event } from '@dxos/async';\nimport { type Any } from '@dxos/codec-protobuf';\nimport { PublicKey } from '@dxos/keys';\n\nimport { PAYLOAD_1 } from './test-messages';\nimport { type SignalMethods, type Message, type PeerInfo } from '../signal-methods';\n\nexport const expectPeerAvailable = (client: SignalMethods, expectedTopic: PublicKey, peer: PeerInfo) =>\n  asyncTimeout(\n    client.swarmEvent.waitFor(\n      ({ peerAvailable, topic }) =>\n        !!peerAvailable && peer.peerKey === peerAvailable.peer.peerKey && expectedTopic.equals(topic),\n    ),\n    6000,\n  );\n\nexport const expectPeerLeft = (client: SignalMethods, expectedTopic: PublicKey, peer: PeerInfo) =>\n  asyncTimeout(\n    client.swarmEvent.waitFor(\n      ({ peerLeft, topic }) => !!peerLeft && peer.peerKey === peerLeft.peer.peerKey && expectedTopic.equals(topic),\n    ),\n    6000,\n  );\n\nexport const expectReceivedMessage = (event: Event<Message>, expectedMessage: Message) => {\n  return asyncTimeout(\n    event.waitFor(\n      (msg) =>\n        msg.author.peerKey === expectedMessage.author.peerKey &&\n        msg.recipient.peerKey === expectedMessage.recipient.peerKey &&\n        PublicKey.from(msg.payload.value).equals(expectedMessage.payload.value),\n    ),\n    5000,\n  );\n};\n\nexport const createMessage = (author: PeerInfo, recipient: PeerInfo, payload: Any = PAYLOAD_1): Message => ({\n  author,\n  recipient,\n  payload,\n});\n\nexport const messageEqual = (msg1: Message, msg2: Message) =>\n  msg1.author.peerKey === msg2.author.peerKey &&\n  msg1.recipient.peerKey === msg2.recipient.peerKey &&\n  PublicKey.from(msg1.payload.value).equals(msg2.payload.value);\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { type TaggedType } from '@dxos/codec-protobuf';\nimport { type TYPES } from '@dxos/protocols/proto';\n\nexport const PAYLOAD_1: TaggedType<TYPES, 'google.protobuf.Any'> = {\n  '@type': 'google.protobuf.Any',\n  type_url: 'dxos.Example1',\n  value: Buffer.from('1'),\n};\n\nexport const PAYLOAD_2: TaggedType<TYPES, 'google.protobuf.Any'> = {\n  '@type': 'google.protobuf.Any',\n  type_url: 'dxos.Example2',\n  value: Buffer.from('2'),\n};\n\nexport const PAYLOAD_3: TaggedType<TYPES, 'google.protobuf.Any'> = {\n  '@type': 'google.protobuf.Any',\n  type_url: 'dxos.Example3',\n  value: Buffer.from('3'),\n};\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { TestPeer } from './test-peer';\nimport { type SignalManager, MemorySignalManager, MemorySignalManagerContext } from '../signal-manager';\nimport { type Message } from '../signal-methods';\n\nexport type TestBuilderOptions = {\n  signalManagerFactory?: (peer: TestPeer) => Promise<SignalManager>;\n  messageDisruption?: (msg: Message) => Message[];\n};\n\nexport class TestBuilder {\n  private _signalContext = new MemorySignalManagerContext();\n  private readonly _peers: TestPeer[] = [];\n\n  constructor(public options: TestBuilderOptions) {}\n\n  async createSignalManager(peer: TestPeer): Promise<SignalManager> {\n    const signalManager =\n      (await this.options.signalManagerFactory?.(peer)) ?? new MemorySignalManager(this._signalContext);\n\n    if (this.options.messageDisruption) {\n      // Imitates signal network disruptions (e. g. message doubling, ).\n      const trueSend = signalManager.sendMessage.bind(signalManager);\n      signalManager.sendMessage = async (message: Message) => {\n        for (const msg of this.options.messageDisruption!(message)) {\n          await trueSend(msg);\n        }\n      };\n    }\n\n    return signalManager;\n  }\n\n  async createPeer(): Promise<TestPeer> {\n    const peer = new TestPeer(this);\n    await peer.open();\n    this._peers.push(peer);\n    return peer;\n  }\n\n  async createPeers(count: number): Promise<TestPeer[]> {\n    return Promise.all(Array.from({ length: count }, () => this.createPeer()));\n  }\n\n  async close(): Promise<void> {\n    await Promise.all(this._peers.map((peer) => peer.close()));\n  }\n}\n"],
  "mappings": "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",
  "names": ["Event", "Resource", "PeerSchema", "PublicKey", "log", "buf", "asyncTimeout", "PublicKey", "PAYLOAD_1", "type_url", "value", "Buffer", "from", "PAYLOAD_2", "PAYLOAD_3", "expectPeerAvailable", "client", "expectedTopic", "peer", "asyncTimeout", "swarmEvent", "waitFor", "peerAvailable", "topic", "peerKey", "equals", "expectPeerLeft", "peerLeft", "expectReceivedMessage", "event", "expectedMessage", "msg", "author", "recipient", "PublicKey", "from", "payload", "value", "createMessage", "PAYLOAD_1", "messageEqual", "msg1", "msg2", "TestPeer", "Resource", "testBuilder", "peerId", "PublicKey", "random", "defaultReceived", "Event", "peerInfo", "buf", "create", "PeerSchema", "peerKey", "toHex", "identityKey", "waitTillReceive", "message", "expectReceivedMessage", "waitForPeerAvailable", "topic", "peer", "expectPeerAvailable", "signalManager", "waitForPeerLeft", "expectPeerLeft", "_open", "createSignalManager", "messenger", "Messenger", "retryDelay", "open", "listen", "onMessage", "msg", "emit", "catch", "err", "log", "_close", "close", "TestBuilder", "options", "_signalContext", "MemorySignalManagerContext", "_peers", "createSignalManager", "peer", "signalManager", "signalManagerFactory", "MemorySignalManager", "messageDisruption", "trueSend", "sendMessage", "bind", "message", "msg", "createPeer", "TestPeer", "open", "push", "createPeers", "count", "Promise", "all", "Array", "from", "length", "close", "map"]
}
