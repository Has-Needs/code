import { Event } from '@dxos/async';
import { Resource } from '@dxos/context';
import { type Runtime } from '@dxos/protocols/proto/dxos/config';
import { type SwarmResponse } from '@dxos/protocols/proto/dxos/edge/messenger';
import { type JoinRequest, type LeaveRequest, type QueryRequest } from '@dxos/protocols/proto/dxos/edge/signal';
import { type SignalManager } from './signal-manager';
import { type PeerInfo, type Message, type SignalStatus, type SwarmEvent } from '../signal-methods';
/**
 * Manages connection to multiple Signal Servers over WebSocket
 * TODO(mykola): Delete.
 * @deprecated
 */
export declare class WebsocketSignalManager extends Resource implements SignalManager {
    private readonly _hosts;
    private readonly _getMetadata?;
    private readonly _servers;
    private readonly _monitor;
    /**
     * Used to avoid logging failed server restarts more than once until the server actually recovers.
     */
    private readonly _failedServersBitfield;
    readonly failureCount: Map<string, number>;
    readonly statusChanged: Event<SignalStatus[]>;
    readonly swarmEvent: Event<SwarmEvent>;
    readonly onMessage: Event<Message>;
    private readonly _instanceId;
    constructor(_hosts: Runtime.Services.Signal[], _getMetadata?: (() => any) | undefined);
    protected _open(): Promise<void>;
    protected _close(): Promise<void>;
    restartServer(serverName: string): Promise<void>;
    getStatus(): SignalStatus[];
    join({ topic, peer }: JoinRequest): Promise<void>;
    leave({ topic, peer }: LeaveRequest): Promise<void>;
    query({ topic }: QueryRequest): Promise<SwarmResponse>;
    sendMessage({ author, recipient, payload }: Message): Promise<void>;
    checkServerFailure(serverName: string, index: number): Promise<void>;
    private _clearServerFailedFlag;
    subscribeMessages(peer: PeerInfo): Promise<void>;
    unsubscribeMessages(peer: PeerInfo): Promise<void>;
    private _forEachServer;
}
//# sourceMappingURL=websocket-signal-manager.d.ts.map