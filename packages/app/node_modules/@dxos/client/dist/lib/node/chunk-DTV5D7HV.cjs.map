{
  "version": 3,
  "sources": ["../../../src/version.ts", "../../../src/client/client.ts", "../../../src/client/client-runtime.ts"],
  "sourcesContent": ["//\n// Copyright 2023 DXOS.org\n//\n\nexport const DXOS_VERSION = '0.8.3'; // {x-release-please-version}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { type Schema } from 'effect';\nimport { inspect } from 'node:util';\n\nimport { Event, MulticastObservable, synchronized, Trigger } from '@dxos/async';\nimport {\n  DEFAULT_CLIENT_CHANNEL,\n  STATUS_TIMEOUT,\n  clientServiceBundle,\n  type ClientServices,\n  type ClientServicesProvider,\n  type Echo,\n  type Halo,\n  PropertiesType,\n} from '@dxos/client-protocol';\nimport { type Stream } from '@dxos/codec-protobuf/stream';\nimport { Config, SaveConfig } from '@dxos/config';\nimport { Context } from '@dxos/context';\nimport { raise } from '@dxos/debug';\nimport { EchoClient, type QueueService, QueueServiceImpl, QueueServiceStub, type Hypergraph } from '@dxos/echo-db';\nimport { getTypename } from '@dxos/echo-schema';\nimport { EdgeHttpClient } from '@dxos/edge-client';\nimport { invariant } from '@dxos/invariant';\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { ApiError, trace as Trace } from '@dxos/protocols';\nimport { type QueryStatusResponse, SystemStatus } from '@dxos/protocols/proto/dxos/client/services';\nimport { createProtoRpcPeer, type ProtoRpcPeer } from '@dxos/rpc';\nimport { createIFramePort } from '@dxos/rpc-tunnel';\nimport { trace } from '@dxos/tracing';\nimport { type JsonKeyOptions, type MaybePromise } from '@dxos/util';\n\nimport { ClientRuntime } from './client-runtime';\nimport { type MeshProxy } from '../mesh/mesh-proxy';\nimport type { IFrameManager, Shell, ShellManager } from '../services';\nimport { DXOS_VERSION } from '../version';\n\n/**\n * This options object configures the DXOS Client.\n */\n// TODO(burdon): Reconcile with ClientProviderProps.\nexport type ClientOptions = {\n  /** Client configuration object. */\n  config?: Config;\n  /** Custom services provider. */\n  services?: MaybePromise<ClientServicesProvider>;\n  /** ECHO schema. */\n  types?: Schema.Schema.AnyNoContext[];\n  /** Shell path. */\n  shell?: string;\n  /** Create client worker. */\n  createWorker?: () => SharedWorker;\n};\n\n/**\n * The Client class encapsulates the core client-side API of DXOS.\n */\n@trace.resource()\nexport class Client {\n  /**\n   * Emitted after the client is reset and the services have finished restarting.\n   */\n  readonly reloaded = new Event<void>();\n\n  // TODO(wittjosiah): Make `null` status part of enum.\n  private readonly _statusUpdate = new Event<SystemStatus | null>();\n  private readonly _status = MulticastObservable.from(this._statusUpdate, null);\n\n  private readonly _echoClient = new EchoClient();\n\n  private readonly _options: ClientOptions;\n\n  /**\n   * Unique id of the Client, local to the current peer.\n   */\n  @trace.info()\n  private readonly _instanceId = PublicKey.random().toHex();\n\n  /**\n   * The version of this client API.\n   */\n  @trace.info()\n  readonly version = DXOS_VERSION;\n\n  @trace.info()\n  private _services?: ClientServicesProvider;\n\n  @trace.info()\n  private _initialized = false;\n\n  @trace.info()\n  private _resetting = false;\n\n  private _runtime?: ClientRuntime;\n\n  private _ctx = new Context();\n  private _config?: Config;\n  private _statusStream?: Stream<QueryStatusResponse>;\n  private _statusTimeout?: NodeJS.Timeout;\n  private _iframeManager?: IFrameManager;\n  private _shellManager?: ShellManager;\n  private _shellClientProxy?: ProtoRpcPeer<ClientServices>;\n  private _edgeClient?: EdgeHttpClient = undefined;\n  private _queuesService?: QueueService = undefined;\n\n  constructor(options: ClientOptions = {}) {\n    if (\n      typeof window !== 'undefined' &&\n      typeof window.location !== 'undefined' &&\n      window.location.protocol !== 'https:' &&\n      window.location.protocol !== 'chrome-extension:' &&\n      window.location.protocol !== 'socket:' &&\n      !window.location.hostname.endsWith('localhost')\n    ) {\n      log.warn(\n        `DXOS Client will not function in a non-secure context ${window.location.origin}. Either serve with a certificate or use a tunneling service (https://docs.dxos.org/guide/kube/tunneling.html).`,\n      );\n    }\n\n    this._options = options;\n\n    // TODO(wittjosiah): Reconcile this with @dxos/log loading config from localStorage.\n    const filter = options.config?.get('runtime.client.log.filter');\n    if (filter) {\n      const prefix = options.config?.get('runtime.client.log.prefix');\n      log.config({ filter, prefix });\n    }\n\n    this._echoClient.graph.schemaRegistry.addSchema([PropertiesType]);\n    if (options.types) {\n      this.addTypes(options.types);\n    }\n  }\n\n  [inspect.custom](): string {\n    return this.toString();\n  }\n\n  toString(): string {\n    return `Client(${this._instanceId})`;\n  }\n\n  @trace.info({ depth: null })\n  toJSON() {\n    return {\n      initialized: this.initialized,\n      spaces: this._runtime?.spaces,\n      halo: this._runtime?.halo,\n      mesh: this._runtime?.mesh,\n    };\n  }\n\n  /**\n   * Current configuration object.\n   */\n  get config(): Config {\n    invariant(this._config, 'Client not initialized.');\n    return this._config;\n  }\n\n  /**\n   * Current client services provider.\n   */\n  // TODO(burdon): Return services.services. Move to debug endpoint.\n  get services(): ClientServicesProvider {\n    invariant(this._services, 'Client not initialized.');\n    return this._services;\n  }\n\n  /**\n   * Returns true if the client has been initialized. Initialize by calling `.initialize()`.\n   */\n  get initialized() {\n    return this._initialized;\n  }\n\n  /**\n   * Client services system status.\n   */\n  get status(): MulticastObservable<SystemStatus | null> {\n    return this._status;\n  }\n\n  /**\n   * ECHO Spaces.\n   */\n  get spaces(): Echo {\n    invariant(this._runtime, 'Client not initialized.');\n    return this._runtime.spaces;\n  }\n\n  /**\n   * HALO credentials.\n   */\n  get halo(): Halo {\n    invariant(this._runtime, 'Client not initialized.');\n    return this._runtime.halo;\n  }\n\n  /**\n   * MESH networking.\n   */\n  get mesh(): MeshProxy {\n    invariant(this._runtime, 'Client not initialized.');\n    return this._runtime.mesh;\n  }\n\n  /**\n   * EDGE client.\n   * This API is experimental and subject to change.\n   */\n  get edge(): EdgeHttpClient {\n    invariant(this._edgeClient, 'Client not initialized.');\n    return this._edgeClient;\n  }\n\n  /**\n   * @deprecated Temporary.\n   */\n  get graph(): Hypergraph {\n    return this._echoClient.graph;\n  }\n\n  /**\n   * Shell API.\n   */\n  get shell(): Shell {\n    invariant(this._runtime, 'Client not initialized.');\n    invariant(this._runtime.shell, 'Shell not available.');\n    return this._runtime.shell;\n  }\n\n  /**\n   * Add schema types to the client.\n   */\n  // TODO(burdon): Check if already registered (and remove downstream checks).\n  addTypes(types: Schema.Schema.AnyNoContext[]): this {\n    log('addTypes', { schema: types.map((type) => getTypename(type)) });\n\n    // TODO(dmaretskyi): Uncomment after release.\n    // if (!this._initialized) {\n    //   throw new ApiError('Client not open.');\n    // }\n\n    // TODO(burdon): Find?\n    const exists = types.filter((type) => !this._echoClient.graph.schemaRegistry.hasSchema(type));\n    if (exists.length > 0) {\n      this._echoClient.graph.schemaRegistry.addSchema(exists);\n    }\n\n    return this;\n  }\n\n  /**\n   * Get client diagnostics data.\n   */\n  // TODO(burdon): Return type?\n  async diagnostics(options: JsonKeyOptions = {}): Promise<any> {\n    const { DiagnosticsCollector } = await import('@dxos/client-services');\n    invariant(this._services?.services.SystemService, 'SystemService is not available.');\n    return DiagnosticsCollector.collect(this._config, this.services, options);\n  }\n\n  /**\n   * Test and repair database.\n   */\n  async repair(): Promise<any> {\n    const { createLevel } = await import('@dxos/client-services');\n\n    // TODO(burdon): Factor out.\n    const repairSummary: any = {};\n\n    {\n      // Cleanup OPFS.\n      const spaces = this.spaces.get();\n      const docs = spaces\n        .map((space) =>\n          (space as any)._data.pipeline.currentEpoch?.subject.assertion.automergeRoot.slice('automerge:'.length),\n        )\n        .filter(Boolean);\n\n      repairSummary.OPFSRemovedFiles = 0;\n      if (typeof navigator !== 'undefined' && navigator.storage) {\n        const dir = await navigator.storage.getDirectory();\n        for await (const filename of (dir as any)?.keys()) {\n          if (filename.includes('automerge_') && !docs.some((doc) => filename.includes(doc))) {\n            await dir.removeEntry(filename);\n            repairSummary.OPFSRemovedFiles++;\n          }\n        }\n      }\n    }\n\n    {\n      // Fix storage config.\n      const config = {\n        runtime: {\n          client: {\n            storage: {\n              dataStore: this.config.values.runtime?.client?.storage?.dataStore,\n            },\n          },\n        },\n      };\n      await SaveConfig(config);\n\n      repairSummary.storageConfig = config;\n    }\n\n    {\n      repairSummary.levelDBRemovedEntries = 0;\n      // Cleanup old index-data from level db.\n      const level = await createLevel(this._config?.values.runtime?.client?.storage ?? {});\n      const sublevelsToCleanup = [\n        level.sublevel('index-store'),\n        level.sublevel('index-metadata').sublevel('clean'),\n        level.sublevel('index-metadata').sublevel('dirty'),\n      ];\n\n      for (const sublevel of sublevelsToCleanup) {\n        repairSummary.levelDBRemovedEntries += (await sublevel.keys().all()).length;\n        await sublevel.clear();\n      }\n    }\n\n    {\n      await this._services?.services.QueryService?.reindex(undefined, { timeout: 30_000 });\n    }\n\n    log.info('Repair succeeded', { repairSummary });\n    return repairSummary;\n  }\n\n  /**\n   * Initializes internal resources in an idempotent way.\n   * Required before using the Client instance.\n   */\n  @synchronized\n  async initialize(): Promise<void> {\n    if (this._initialized) {\n      return;\n    }\n\n    log.trace('dxos.sdk.client.open', Trace.begin({ id: this._instanceId }));\n    const { createClientServices, IFrameManager, ShellManager } = await import('../services');\n\n    this._ctx = new Context();\n    this._config = this._options.config ?? new Config();\n    // NOTE: Must currently match the host.\n    this._services = await (this._options.services ?? createClientServices(this._config, this._options.createWorker));\n    this._iframeManager = this._options.shell\n      ? new IFrameManager({ source: new URL(this._options.shell, window.location.origin) })\n      : undefined;\n    this._shellManager = this._iframeManager ? new ShellManager(this._iframeManager) : undefined;\n    await this._open();\n    invariant(this._runtime, 'Client runtime initialization failed.');\n\n    // TODO(dmaretskyi): Refactor devtools init.\n    if (typeof window !== 'undefined') {\n      const { mountDevtoolsHooks } = await import('../devtools');\n      mountDevtoolsHooks({ client: this });\n    }\n\n    this._initialized = true;\n    log.trace('dxos.sdk.client.open', Trace.end({ id: this._instanceId }));\n  }\n\n  private async _open(): Promise<void> {\n    log('opening...');\n    invariant(this._services);\n    const { SpaceList } = await import('../echo/space-list');\n    const { HaloProxy } = await import('../halo/halo-proxy');\n    const { MeshProxy } = await import('../mesh/mesh-proxy');\n    const { Shell } = await import('../services');\n\n    const trigger = new Trigger<Error | undefined>();\n    this._services.closed?.on(async (error) => {\n      log('terminated', { resetting: this._resetting });\n      if (error instanceof ApiError) {\n        log.error('fatal', { error });\n        trigger.wake(error);\n      }\n      if (!this._resetting) {\n        await this._close();\n        await this._open();\n        this.reloaded.emit();\n      }\n    });\n    await this._services.open();\n\n    const edgeUrl = this._config!.get('runtime.services.edge.url');\n    if (edgeUrl) {\n      this._edgeClient = new EdgeHttpClient(edgeUrl);\n      this._queuesService = new QueueServiceImpl(this._edgeClient);\n    } else {\n      this._queuesService = new QueueServiceStub();\n    }\n\n    this._echoClient.connectToService({\n      dataService: this._services.services.DataService ?? raise(new Error('DataService not available')),\n      queryService: this._services.services.QueryService ?? raise(new Error('QueryService not available')),\n      queueService: this._queuesService,\n    });\n    await this._echoClient.open(this._ctx);\n\n    const mesh = new MeshProxy(this._services, this._instanceId);\n    const halo = new HaloProxy(this._services, this._instanceId);\n    const spaces = new SpaceList(this._config, this._services, this._echoClient, halo, this._instanceId);\n\n    const shell = this._shellManager\n      ? new Shell({\n          shellManager: this._shellManager,\n          identity: halo.identity,\n          devices: halo.devices,\n          spaces,\n        })\n      : undefined;\n    this._runtime = new ClientRuntime({ spaces, halo, mesh, shell });\n\n    invariant(this._services.services.SystemService, 'SystemService is not available.');\n    this._statusStream = this._services.services.SystemService.queryStatus({ interval: 3_000 });\n    this._statusStream.subscribe(\n      async ({ status }) => {\n        this._statusTimeout && clearTimeout(this._statusTimeout);\n        trigger.wake(undefined);\n\n        this._statusUpdate.emit(status);\n        this._statusTimeout = setTimeout(() => {\n          this._statusUpdate.emit(null);\n        }, STATUS_TIMEOUT);\n      },\n      (err) => {\n        trigger.wake(err);\n        if (err) {\n          this._statusUpdate.emit(null);\n        }\n      },\n    );\n\n    const err = await trigger.wait();\n    if (err) {\n      throw err;\n    }\n\n    await this._runtime.open();\n\n    // TODO(wittjosiah): Factor out iframe manager and proxy into shell manager.\n    await this._iframeManager?.open();\n    await this._shellManager?.open();\n    if (this._iframeManager?.iframe) {\n      // TODO(wittjosiah): Remove. Workaround for socket runtime bug.\n      //   https://github.com/socketsupply/socket/issues/893\n      const origin =\n        this._iframeManager.source.origin === 'null'\n          ? this._iframeManager.source.toString().split('/').slice(0, 3).join('/')\n          : this._iframeManager.source.origin;\n\n      this._shellClientProxy = createProtoRpcPeer({\n        exposed: clientServiceBundle,\n        handlers: this._services.services as ClientServices,\n        port: createIFramePort({\n          channel: DEFAULT_CLIENT_CHANNEL,\n          iframe: this._iframeManager.iframe,\n          origin,\n        }),\n        handlerRpcOptions: {\n          timeout: 60_000, // Timeout is specifically very high because shell will be managing its own timeouts on RPCs.\n        },\n      });\n\n      await this._shellClientProxy.open();\n    }\n\n    log('opened');\n  }\n\n  /**\n   * Cleanup, release resources.\n   * Open/close is re-entrant.\n   */\n  @synchronized\n  async destroy(): Promise<void> {\n    if (!this._initialized) {\n      return;\n    }\n\n    // TODO(burdon): Call flush?\n    await this._close();\n    this._statusUpdate.emit(null);\n    await this._ctx.dispose();\n\n    this._initialized = false;\n  }\n\n  private async _close(): Promise<void> {\n    log('closing...');\n    this._statusTimeout && clearTimeout(this._statusTimeout);\n    await this._statusStream?.close();\n    await this._runtime?.close();\n    await this._echoClient.close(this._ctx);\n    await this._services?.close();\n    this._edgeClient = undefined;\n    log('closed');\n  }\n\n  /**\n   * Reinitialized the client session with the remote service host.\n   * This is useful when connecting to a host running behind a resource lock\n   * (e.g., HALO when SharedWorker is unavailable).\n   */\n  async resumeHostServices(): Promise<void> {\n    invariant(this.services.services.SystemService, 'SystemService is not available.');\n    await this.services.services.SystemService.updateStatus({ status: SystemStatus.ACTIVE });\n  }\n\n  /**\n   * Resets and destroys client storage.\n   * This will currently leave the client in a closed state.\n   * Re-using the client after reset is not currently supported.\n   */\n  @synchronized\n  async reset(): Promise<void> {\n    if (!this._initialized) {\n      throw new ApiError('Client not open.');\n    }\n\n    log('resetting...');\n    this._resetting = true;\n    invariant(this._services?.services.SystemService, 'SystemService is not available.');\n    await this._services?.services.SystemService.reset();\n    await this._close();\n\n    // TODO(wittjosiah): Re-open after reset.\n    // await this._open();\n    // this._resetting = false;\n    // this.reloaded.emit();\n    log('reset complete');\n  }\n}\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport type { SpaceList } from '../echo/space-list';\nimport type { HaloProxy } from '../halo/halo-proxy';\nimport type { MeshProxy } from '../mesh/mesh-proxy';\nimport type { Shell } from '../services';\n\nexport class ClientRuntime {\n  readonly spaces: SpaceList;\n  readonly halo: HaloProxy;\n  readonly mesh: MeshProxy;\n  readonly shell?: Shell;\n\n  constructor({ spaces, halo, mesh, shell }: { spaces: SpaceList; halo: HaloProxy; mesh: MeshProxy; shell?: Shell }) {\n    this.spaces = spaces;\n    this.halo = halo;\n    this.mesh = mesh;\n    this.shell = shell;\n  }\n\n  async open(): Promise<void> {\n    await this.mesh._open();\n    await this.spaces._open();\n    await this.halo._open();\n  }\n\n  async close(): Promise<void> {\n    await this.halo._close();\n    await this.spaces._close();\n    await this.mesh._close();\n  }\n}\n"],
  "mappings": "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",
  "names": ["DXOS_VERSION", "ClientRuntime", "spaces", "halo", "mesh", "shell", "open", "_open", "close", "_close", "Client", "options", "Event", "_status", "MulticastObservable", "from", "_statusUpdate", "_echoClient", "EchoClient", "PublicKey", "random", "toHex", "_initialized", "_resetting", "_ctx", "Context", "_edgeClient", "undefined", "_queuesService", "window", "location", "protocol", "hostname", "endsWith", "log", "warn", "origin", "_options", "filter", "config", "get", "prefix", "graph", "schemaRegistry", "addSchema", "PropertiesType", "types", "addTypes", "inspect", "custom", "toString", "_instanceId", "toJSON", "initialized", "_runtime", "invariant", "_config", "services", "_services", "status", "edge", "schema", "map", "type", "getTypename", "exists", "hasSchema", "length", "diagnostics", "DiagnosticsCollector", "SystemService", "collect", "repair", "createLevel", "repairSummary", "docs", "space", "_data", "pipeline", "currentEpoch", "subject", "assertion", "automergeRoot", "slice", "Boolean", "OPFSRemovedFiles", "navigator", "storage", "dir", "getDirectory", "filename", "keys", "includes", "some", "doc", "removeEntry", "runtime", "client", "dataStore", "values", "SaveConfig", "storageConfig", "levelDBRemovedEntries", "level", "sublevelsToCleanup", "sublevel", "all", "clear", "QueryService", "reindex", "timeout", "info", "initialize", "trace", "Trace", "begin", "id", "createClientServices", "IFrameManager", "ShellManager", "Config", "createWorker", "_iframeManager", "source", "URL", "_shellManager", "mountDevtoolsHooks", "end", "SpaceList", "HaloProxy", "MeshProxy", "Shell", "trigger", "Trigger", "closed", "on", "error", "resetting", "ApiError", "wake", "reloaded", "emit", "edgeUrl", "EdgeHttpClient", "QueueServiceImpl", "QueueServiceStub", "connectToService", "dataService", "DataService", "raise", "Error", "queryService", "queueService", "shellManager", "identity", "devices", "_statusStream", "queryStatus", "interval", "subscribe", "_statusTimeout", "clearTimeout", "setTimeout", "STATUS_TIMEOUT", "err", "wait", "iframe", "split", "join", "_shellClientProxy", "createProtoRpcPeer", "exposed", "clientServiceBundle", "handlers", "port", "createIFramePort", "channel", "DEFAULT_CLIENT_CHANNEL", "handlerRpcOptions", "destroy", "dispose", "resumeHostServices", "updateStatus", "SystemStatus", "ACTIVE", "reset", "depth", "resource"]
}
