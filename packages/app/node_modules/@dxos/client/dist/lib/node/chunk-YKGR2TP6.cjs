"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var chunk_YKGR2TP6_exports = {};
__export(chunk_YKGR2TP6_exports, {
  KeyType: () => import_keys.KeyType,
  mountDevtoolsHooks: () => mountDevtoolsHooks,
  unmountDevtoolsHooks: () => unmountDevtoolsHooks
});
module.exports = __toCommonJS(chunk_YKGR2TP6_exports);
var import_chunk_HIRCX7XT = require("./chunk-HIRCX7XT.cjs");
var import_keys = require("@dxos/protocols/proto/dxos/halo/keys");
var import_automerge = require("@automerge/automerge");
var import_automerge_repo = require("@automerge/automerge-repo");
var import_debug = require("@dxos/debug");
var import_keys2 = require("@dxos/keys");
var import_log = require("@dxos/log");
var import_rpc = require("@dxos/rpc");
var import_tracing = require("@dxos/tracing");
var import_util = require("@dxos/util");
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/sdk/client/src/devtools/devtools.ts";
(0, import_debug.exposeModule)("@automerge/automerge", import_automerge.next);
var mountDevtoolsHooks = ({ client, host }) => {
  let server;
  let diagnostics = [];
  const hook = {
    // To debug client from console using 'window.__DXOS__.client'.
    client,
    host,
    tracing: import_tracing.TRACE_PROCESSOR,
    openClientRpcServer: async () => {
      if (!client) {
        import_log.log.error("Client not available", void 0, {
          F: __dxlog_file,
          L: 87,
          S: void 0,
          C: (f, a) => f(...a)
        });
        return false;
      }
      if (server) {
        (0, import_log.log)("Closing existing client RPC server.", void 0, {
          F: __dxlog_file,
          L: 92,
          S: void 0,
          C: (f, a) => f(...a)
        });
        await server.close();
      }
      (0, import_log.log)("Opening devtools client RPC server...", void 0, {
        F: __dxlog_file,
        L: 96,
        S: void 0,
        C: (f, a) => f(...a)
      });
      server = (0, import_rpc.createBundledRpcServer)({
        services: client.services.descriptors,
        handlers: client.services.services,
        port
      });
      await server.open().catch((err) => {
        import_log.log.error(`Failed to open RPC server: ${err}`, void 0, {
          F: __dxlog_file,
          L: 104,
          S: void 0,
          C: (f, a) => f(...a)
        });
        return false;
      });
      (0, import_log.log)("Opened devtools client RPC server.", void 0, {
        F: __dxlog_file,
        L: 108,
        S: void 0,
        C: (f, a) => f(...a)
      });
      return true;
    },
    reset,
    importModule: import_debug.importModule,
    listDiagnostics: async () => {
      diagnostics = await import_tracing.TRACE_PROCESSOR.diagnosticsChannel.discover();
      console.table(diagnostics.map((diagnostic) => ({
        ...diagnostic,
        get fetch() {
          queueMicrotask(async () => {
            const { data, error } = await import_tracing.TRACE_PROCESSOR.diagnosticsChannel.fetch(diagnostic);
            if (error) {
              import_log.log.error(`Error fetching diagnostic ${diagnostic.id}: ${error}`, void 0, {
                F: __dxlog_file,
                L: 127,
                S: this,
                C: (f, a) => f(...a)
              });
              return;
            }
            console.table(data);
          });
          return void 0;
        }
      })));
    },
    // TODO(dmaretskyi): Joins across multiple diagnostics.
    fetchDiagnostics: async (id, instanceTag) => {
      const { data, error } = await import_tracing.TRACE_PROCESSOR.diagnosticsChannel.fetch({
        id,
        instanceTag
      });
      if (error) {
        import_log.log.error(`Error fetching diagnostic ${id}: ${error}`, void 0, {
          F: __dxlog_file,
          L: 144,
          S: void 0,
          C: (f, a) => f(...a)
        });
        return;
      }
      return data;
    },
    joinTables: import_util.joinTables,
    // Globals.
    Filter: import_chunk_HIRCX7XT.Filter,
    getMeta: import_chunk_HIRCX7XT.getMeta
  };
  if (client) {
    hook.spaces = createAccessor({
      getAll: () => client.spaces.get(),
      getByKey: (key) => client.spaces.get().find((space) => space.key.equals(key)),
      getSearchMap: () => new Map(client.spaces.get().flatMap((space) => [
        [
          space.id,
          space
        ],
        ...space.state.get() === import_chunk_HIRCX7XT.SpaceState.SPACE_READY ? [
          [
            space.properties.name,
            space
          ]
        ] : [],
        [
          space.key.toHex(),
          space
        ]
      ]))
    });
    hook.halo = client.halo;
    hook.openDevtoolsApp = async () => {
      const vault = client.config?.values.runtime?.client?.remoteSource ?? "https://halo.dxos.org";
      let hasLocalDevtools = false;
      try {
        await fetch("http://localhost:5174/");
        hasLocalDevtools = true;
      } catch {
      }
      const isDev = window.location.href.includes(".dev.") || window.location.href.includes("localhost");
      const devtoolsApp = hasLocalDevtools ? "http://localhost:5174/" : `https://devtools${isDev ? ".dev." : "."}dxos.org/`;
      const devtoolsUrl = `${devtoolsApp}?target=${vault}`;
      window.open(devtoolsUrl, "_blank");
    };
    hook.downloadDiagnostics = async () => {
      const diagnostics2 = JSON.stringify(await client.diagnostics(), null, 4);
      downloadFile(diagnostics2, "application/json", `diagnostics-${window.location.hostname}-${(/* @__PURE__ */ new Date()).toISOString()}.json`);
    };
    hook.exportProfile = async () => {
      const { createLevel, createStorageObjects, exportProfileData } = await import("@dxos/client-services");
      const storageConfig = client.config.get("runtime.client.storage", {});
      const { storage } = createStorageObjects(storageConfig);
      const level = await createLevel(storageConfig);
      import_log.log.info("begin profile export", {
        storageConfig
      }, {
        F: __dxlog_file,
        L: 210,
        S: void 0,
        C: (f, a) => f(...a)
      });
      const archive = await exportProfileData({
        storage,
        level
      });
      import_log.log.info("done profile export", {
        storageEntries: archive.storage.length
      }, {
        F: __dxlog_file,
        L: 213,
        S: void 0,
        C: (f, a) => f(...a)
      });
      downloadFile(import_automerge_repo.cbor.encode(archive), "application/octet-stream", "profile.dxprofile");
    };
    hook.importProfile = async () => {
      import_log.log.warn("Make sure to clear your data before importing a profile (Site Settings -> Clear data)", void 0, {
        F: __dxlog_file,
        L: 219,
        S: void 0,
        C: (f, a) => f(...a)
      });
      const data = await uploadFile();
      const { createLevel, createStorageObjects, decodeProfileArchive, importProfileData } = await import("@dxos/client-services");
      const storageConfig = client.config.get("runtime.client.storage", {});
      await client.destroy().catch(() => {
      });
      const { storage } = createStorageObjects(storageConfig);
      const level = await createLevel(storageConfig);
      const archive = decodeProfileArchive(data);
      import_log.log.info("begin profile import", {
        storageConfig,
        storageEntries: archive.storage.length
      }, {
        F: __dxlog_file,
        L: 236,
        S: void 0,
        C: (f, a) => f(...a)
      });
      await importProfileData({
        storage,
        level
      }, archive);
      import_log.log.info("done profile import", void 0, {
        F: __dxlog_file,
        L: 240,
        S: void 0,
        C: (f, a) => f(...a)
      });
      window.location.reload();
    };
  }
  if (host) {
    hook.spaces = createAccessor({
      getAll: () => Array.from(host.context.dataSpaceManager?.spaces.values() ?? []),
      getByKey: (key) => host.context.dataSpaceManager?.spaces.get(key),
      getSearchMap: () => new Map(Array.from(host.context.dataSpaceManager?.spaces.values() ?? []).flatMap((space) => [
        [
          space.key.toHex(),
          space
        ]
      ]))
    });
    hook.feeds = createAccessor({
      getAll: () => Array.from(host.context.feedStore?.feeds.values() ?? []),
      getByKey: (key) => host.context.feedStore?.feeds.find((feed) => feed.key.equals(key)),
      getSearchMap: () => new Map(Array.from(host.context.feedStore?.feeds.values() ?? []).flatMap((feed) => [
        [
          feed.key.toHex(),
          feed
        ]
      ]))
    });
  }
  globalThis.__DXOS__ = hook;
  let warningShown = false;
  Object.defineProperty(globalThis, "dxos", {
    get: () => {
      if (!warningShown) {
        warningShown = true;
        import_log.log.warn("globalThis.dxos is an undocumented API and may changed or removed entirely without notice.", void 0, {
          F: __dxlog_file,
          L: 272,
          S: void 0,
          C: (f, a) => f(...a)
        });
      }
      return hook;
    },
    configurable: true
  });
};
var unmountDevtoolsHooks = () => {
  delete globalThis.__DXOS__;
  delete globalThis.dxos;
};
var createAccessor = ({ getByKey, getSearchMap, getAll }) => (keyOrSearch) => {
  if (typeof keyOrSearch === "undefined") {
    return getAll?.() ?? [];
  }
  if (keyOrSearch instanceof import_keys2.PublicKey) {
    return getByKey?.(keyOrSearch);
  }
  const searchSpace = getSearchMap?.() ?? /* @__PURE__ */ new Map();
  if (searchSpace.has(keyOrSearch)) {
    return searchSpace.get(keyOrSearch);
  }
  for (const [key, value] of searchSpace.entries()) {
    if (key.startsWith(keyOrSearch)) {
      return value;
    }
  }
  for (const [key, value] of searchSpace.entries()) {
    if (key.includes(keyOrSearch)) {
      return value;
    }
  }
  return void 0;
};
var port = {
  send: async (message) => window.postMessage({
    data: Array.from(message),
    source: "dxos-client"
  }, "*"),
  subscribe: (callback) => {
    const handler = (event) => {
      if (event.source !== window) {
        return;
      }
      const message = event.data;
      if (typeof message !== "object" || message === null || message.source !== "content-script") {
        return;
      }
      callback(new Uint8Array(message.data));
    };
    window.addEventListener("message", handler);
    return () => window.removeEventListener("message", handler);
  }
};
var reset = async () => {
  import_log.log.info(`Deleting all data from ${typeof window.localStorage !== "undefined" ? window.location?.origin : ""}`, void 0, {
    F: __dxlog_file,
    L: 355,
    S: void 0,
    C: (f, a) => f(...a)
  });
  if (typeof localStorage !== "undefined") {
    localStorage.clear();
    import_log.log.info("Cleared local storage", void 0, {
      F: __dxlog_file,
      L: 359,
      S: void 0,
      C: (f, a) => f(...a)
    });
  }
  if (typeof navigator !== "undefined" && typeof navigator.storage !== "undefined" && typeof navigator.storage.getDirectory === "function") {
    const root = await navigator.storage.getDirectory();
    for await (const entry of root.keys()) {
      try {
        await root.removeEntry(entry, {
          recursive: true
        });
      } catch (err) {
        import_log.log.error(`Failed to delete ${entry}: ${err}`, void 0, {
          F: __dxlog_file,
          L: 372,
          S: void 0,
          C: (f, a) => f(...a)
        });
      }
    }
    import_log.log.info("Cleared OPFS", void 0, {
      F: __dxlog_file,
      L: 375,
      S: void 0,
      C: (f, a) => f(...a)
    });
    if (typeof location !== "undefined" && typeof location.reload === "function") {
      location.reload();
    } else if (typeof close === "function") {
      close();
    }
  }
};
var downloadFile = (data, contentType, filename) => {
  const url = URL.createObjectURL(new Blob([
    data
  ], {
    type: contentType
  }));
  const element = document.createElement("a");
  element.setAttribute("href", url);
  element.setAttribute("download", filename);
  element.setAttribute("target", "download");
  element.click();
};
var uploadFile = () => {
  return new Promise((resolve, reject) => {
    const dropArea = document.createElement("div");
    dropArea.style.width = "100%";
    dropArea.style.height = "100%";
    dropArea.style.backgroundColor = "rgba(0, 0, 0, 0.5)";
    dropArea.style.display = "flex";
    dropArea.style.justifyContent = "center";
    dropArea.style.alignItems = "center";
    dropArea.style.position = "fixed";
    const text = document.createElement("p");
    text.textContent = "Drop file here";
    text.style.color = "white";
    text.style.fontSize = "24px";
    dropArea.appendChild(text);
    document.body.appendChild(dropArea);
    const handleDrop = (event) => {
      event.preventDefault();
      const file = event.dataTransfer?.files?.[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = () => {
          const arrayBuffer = reader.result;
          const uint8Array = new Uint8Array(arrayBuffer);
          resolve(uint8Array);
        };
        reader.onerror = () => {
          reject(new Error("Failed to read file"));
        };
        reader.readAsArrayBuffer(file);
      }
      dropArea.remove();
    };
    const handleDragOver = (event) => {
      event.preventDefault();
    };
    const handleDragLeave = () => {
      dropArea.style.backgroundColor = "rgba(0, 0, 0, 0.5)";
    };
    const handleDragEnter = () => {
      dropArea.style.backgroundColor = "rgba(0, 0, 0, 0.8)";
    };
    dropArea.addEventListener("drop", handleDrop);
    dropArea.addEventListener("dragover", handleDragOver);
    dropArea.addEventListener("dragleave", handleDragLeave);
    dropArea.addEventListener("dragenter", handleDragEnter);
  });
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  KeyType,
  mountDevtoolsHooks,
  unmountDevtoolsHooks
});
//# sourceMappingURL=chunk-YKGR2TP6.cjs.map
