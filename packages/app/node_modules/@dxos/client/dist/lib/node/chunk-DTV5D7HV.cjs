"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var chunk_DTV5D7HV_exports = {};
__export(chunk_DTV5D7HV_exports, {
  Client: () => Client,
  DXOS_VERSION: () => DXOS_VERSION
});
module.exports = __toCommonJS(chunk_DTV5D7HV_exports);
var import_node_util = require("node:util");
var import_async = require("@dxos/async");
var import_client_protocol = require("@dxos/client-protocol");
var import_config = require("@dxos/config");
var import_context = require("@dxos/context");
var import_debug = require("@dxos/debug");
var import_echo_db = require("@dxos/echo-db");
var import_echo_schema = require("@dxos/echo-schema");
var import_edge_client = require("@dxos/edge-client");
var import_invariant = require("@dxos/invariant");
var import_keys = require("@dxos/keys");
var import_log = require("@dxos/log");
var import_protocols = require("@dxos/protocols");
var import_services = require("@dxos/protocols/proto/dxos/client/services");
var import_rpc = require("@dxos/rpc");
var import_rpc_tunnel = require("@dxos/rpc-tunnel");
var import_tracing = require("@dxos/tracing");
var DXOS_VERSION = "0.8.3";
var ClientRuntime = class {
  constructor({ spaces, halo, mesh, shell }) {
    this.spaces = spaces;
    this.halo = halo;
    this.mesh = mesh;
    this.shell = shell;
  }
  async open() {
    await this.mesh._open();
    await this.spaces._open();
    await this.halo._open();
  }
  async close() {
    await this.halo._close();
    await this.spaces._close();
    await this.mesh._close();
  }
};
function _ts_decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/sdk/client/src/client/client.ts";
var Client = class {
  constructor(options = {}) {
    this.reloaded = new import_async.Event();
    this._statusUpdate = new import_async.Event();
    this._status = import_async.MulticastObservable.from(this._statusUpdate, null);
    this._echoClient = new import_echo_db.EchoClient();
    this._instanceId = import_keys.PublicKey.random().toHex();
    this.version = DXOS_VERSION;
    this._initialized = false;
    this._resetting = false;
    this._ctx = new import_context.Context(void 0, {
      F: __dxlog_file,
      L: 99
    });
    this._edgeClient = void 0;
    this._queuesService = void 0;
    if (typeof window !== "undefined" && typeof window.location !== "undefined" && window.location.protocol !== "https:" && window.location.protocol !== "chrome-extension:" && window.location.protocol !== "socket:" && !window.location.hostname.endsWith("localhost")) {
      import_log.log.warn(`DXOS Client will not function in a non-secure context ${window.location.origin}. Either serve with a certificate or use a tunneling service (https://docs.dxos.org/guide/kube/tunneling.html).`, void 0, {
        F: __dxlog_file,
        L: 118,
        S: this,
        C: (f, a) => f(...a)
      });
    }
    this._options = options;
    const filter = options.config?.get("runtime.client.log.filter");
    if (filter) {
      const prefix = options.config?.get("runtime.client.log.prefix");
      import_log.log.config({
        filter,
        prefix
      }, void 0, {
        F: __dxlog_file,
        L: 129,
        S: this,
        C: (f, a) => f(...a)
      });
    }
    this._echoClient.graph.schemaRegistry.addSchema([
      import_client_protocol.PropertiesType
    ]);
    if (options.types) {
      this.addTypes(options.types);
    }
  }
  [import_node_util.inspect.custom]() {
    return this.toString();
  }
  toString() {
    return `Client(${this._instanceId})`;
  }
  toJSON() {
    return {
      initialized: this.initialized,
      spaces: this._runtime?.spaces,
      halo: this._runtime?.halo,
      mesh: this._runtime?.mesh
    };
  }
  /**
  * Current configuration object.
  */
  get config() {
    (0, import_invariant.invariant)(this._config, "Client not initialized.", {
      F: __dxlog_file,
      L: 160,
      S: this,
      A: [
        "this._config",
        "'Client not initialized.'"
      ]
    });
    return this._config;
  }
  /**
  * Current client services provider.
  */
  // TODO(burdon): Return services.services. Move to debug endpoint.
  get services() {
    (0, import_invariant.invariant)(this._services, "Client not initialized.", {
      F: __dxlog_file,
      L: 169,
      S: this,
      A: [
        "this._services",
        "'Client not initialized.'"
      ]
    });
    return this._services;
  }
  /**
  * Returns true if the client has been initialized. Initialize by calling `.initialize()`.
  */
  get initialized() {
    return this._initialized;
  }
  /**
  * Client services system status.
  */
  get status() {
    return this._status;
  }
  /**
  * ECHO Spaces.
  */
  get spaces() {
    (0, import_invariant.invariant)(this._runtime, "Client not initialized.", {
      F: __dxlog_file,
      L: 191,
      S: this,
      A: [
        "this._runtime",
        "'Client not initialized.'"
      ]
    });
    return this._runtime.spaces;
  }
  /**
  * HALO credentials.
  */
  get halo() {
    (0, import_invariant.invariant)(this._runtime, "Client not initialized.", {
      F: __dxlog_file,
      L: 199,
      S: this,
      A: [
        "this._runtime",
        "'Client not initialized.'"
      ]
    });
    return this._runtime.halo;
  }
  /**
  * MESH networking.
  */
  get mesh() {
    (0, import_invariant.invariant)(this._runtime, "Client not initialized.", {
      F: __dxlog_file,
      L: 207,
      S: this,
      A: [
        "this._runtime",
        "'Client not initialized.'"
      ]
    });
    return this._runtime.mesh;
  }
  /**
  * EDGE client.
  * This API is experimental and subject to change.
  */
  get edge() {
    (0, import_invariant.invariant)(this._edgeClient, "Client not initialized.", {
      F: __dxlog_file,
      L: 216,
      S: this,
      A: [
        "this._edgeClient",
        "'Client not initialized.'"
      ]
    });
    return this._edgeClient;
  }
  /**
  * @deprecated Temporary.
  */
  get graph() {
    return this._echoClient.graph;
  }
  /**
  * Shell API.
  */
  get shell() {
    (0, import_invariant.invariant)(this._runtime, "Client not initialized.", {
      F: __dxlog_file,
      L: 231,
      S: this,
      A: [
        "this._runtime",
        "'Client not initialized.'"
      ]
    });
    (0, import_invariant.invariant)(this._runtime.shell, "Shell not available.", {
      F: __dxlog_file,
      L: 232,
      S: this,
      A: [
        "this._runtime.shell",
        "'Shell not available.'"
      ]
    });
    return this._runtime.shell;
  }
  /**
  * Add schema types to the client.
  */
  // TODO(burdon): Check if already registered (and remove downstream checks).
  addTypes(types) {
    (0, import_log.log)("addTypes", {
      schema: types.map((type) => (0, import_echo_schema.getTypename)(type))
    }, {
      F: __dxlog_file,
      L: 241,
      S: this,
      C: (f, a) => f(...a)
    });
    const exists = types.filter((type) => !this._echoClient.graph.schemaRegistry.hasSchema(type));
    if (exists.length > 0) {
      this._echoClient.graph.schemaRegistry.addSchema(exists);
    }
    return this;
  }
  /**
  * Get client diagnostics data.
  */
  // TODO(burdon): Return type?
  async diagnostics(options = {}) {
    const { DiagnosticsCollector } = await import("@dxos/client-services");
    (0, import_invariant.invariant)(this._services?.services.SystemService, "SystemService is not available.", {
      F: __dxlog_file,
      L: 263,
      S: this,
      A: [
        "this._services?.services.SystemService",
        "'SystemService is not available.'"
      ]
    });
    return DiagnosticsCollector.collect(this._config, this.services, options);
  }
  /**
  * Test and repair database.
  */
  async repair() {
    const { createLevel } = await import("@dxos/client-services");
    const repairSummary = {};
    {
      const spaces = this.spaces.get();
      const docs = spaces.map((space) => space._data.pipeline.currentEpoch?.subject.assertion.automergeRoot.slice("automerge:".length)).filter(Boolean);
      repairSummary.OPFSRemovedFiles = 0;
      if (typeof navigator !== "undefined" && navigator.storage) {
        const dir = await navigator.storage.getDirectory();
        for await (const filename of dir?.keys()) {
          if (filename.includes("automerge_") && !docs.some((doc) => filename.includes(doc))) {
            await dir.removeEntry(filename);
            repairSummary.OPFSRemovedFiles++;
          }
        }
      }
    }
    {
      const config = {
        runtime: {
          client: {
            storage: {
              dataStore: this.config.values.runtime?.client?.storage?.dataStore
            }
          }
        }
      };
      await (0, import_config.SaveConfig)(config);
      repairSummary.storageConfig = config;
    }
    {
      repairSummary.levelDBRemovedEntries = 0;
      const level = await createLevel(this._config?.values.runtime?.client?.storage ?? {});
      const sublevelsToCleanup = [
        level.sublevel("index-store"),
        level.sublevel("index-metadata").sublevel("clean"),
        level.sublevel("index-metadata").sublevel("dirty")
      ];
      for (const sublevel of sublevelsToCleanup) {
        repairSummary.levelDBRemovedEntries += (await sublevel.keys().all()).length;
        await sublevel.clear();
      }
    }
    {
      await this._services?.services.QueryService?.reindex(void 0, {
        timeout: 3e4
      });
    }
    import_log.log.info("Repair succeeded", {
      repairSummary
    }, {
      F: __dxlog_file,
      L: 333,
      S: this,
      C: (f, a) => f(...a)
    });
    return repairSummary;
  }
  /**
  * Initializes internal resources in an idempotent way.
  * Required before using the Client instance.
  */
  async initialize() {
    if (this._initialized) {
      return;
    }
    import_log.log.trace("dxos.sdk.client.open", import_protocols.trace.begin({
      id: this._instanceId
    }), {
      F: __dxlog_file,
      L: 347,
      S: this,
      C: (f, a) => f(...a)
    });
    const { createClientServices, IFrameManager, ShellManager } = await import("./services-NYQN2ZCW.cjs");
    this._ctx = new import_context.Context(void 0, {
      F: __dxlog_file,
      L: 350
    });
    this._config = this._options.config ?? new import_config.Config();
    this._services = await (this._options.services ?? createClientServices(this._config, this._options.createWorker));
    this._iframeManager = this._options.shell ? new IFrameManager({
      source: new URL(this._options.shell, window.location.origin)
    }) : void 0;
    this._shellManager = this._iframeManager ? new ShellManager(this._iframeManager) : void 0;
    await this._open();
    (0, import_invariant.invariant)(this._runtime, "Client runtime initialization failed.", {
      F: __dxlog_file,
      L: 359,
      S: this,
      A: [
        "this._runtime",
        "'Client runtime initialization failed.'"
      ]
    });
    if (typeof window !== "undefined") {
      const { mountDevtoolsHooks } = await import("./devtools/index.cjs");
      mountDevtoolsHooks({
        client: this
      });
    }
    this._initialized = true;
    import_log.log.trace("dxos.sdk.client.open", import_protocols.trace.end({
      id: this._instanceId
    }), {
      F: __dxlog_file,
      L: 368,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  async _open() {
    (0, import_log.log)("opening...", void 0, {
      F: __dxlog_file,
      L: 372,
      S: this,
      C: (f, a) => f(...a)
    });
    (0, import_invariant.invariant)(this._services, void 0, {
      F: __dxlog_file,
      L: 373,
      S: this,
      A: [
        "this._services",
        ""
      ]
    });
    const { SpaceList } = await import("./space-list-XIHSA7VU.cjs");
    const { HaloProxy } = await import("./halo-proxy-L4NPYTSH.cjs");
    const { MeshProxy } = await import("./mesh-proxy-KXJSGRHB.cjs");
    const { Shell } = await import("./services-NYQN2ZCW.cjs");
    const trigger = new import_async.Trigger();
    this._services.closed?.on(async (error) => {
      (0, import_log.log)("terminated", {
        resetting: this._resetting
      }, {
        F: __dxlog_file,
        L: 381,
        S: this,
        C: (f, a) => f(...a)
      });
      if (error instanceof import_protocols.ApiError) {
        import_log.log.error("fatal", {
          error
        }, {
          F: __dxlog_file,
          L: 383,
          S: this,
          C: (f, a) => f(...a)
        });
        trigger.wake(error);
      }
      if (!this._resetting) {
        await this._close();
        await this._open();
        this.reloaded.emit();
      }
    });
    await this._services.open();
    const edgeUrl = this._config.get("runtime.services.edge.url");
    if (edgeUrl) {
      this._edgeClient = new import_edge_client.EdgeHttpClient(edgeUrl);
      this._queuesService = new import_echo_db.QueueServiceImpl(this._edgeClient);
    } else {
      this._queuesService = new import_echo_db.QueueServiceStub();
    }
    this._echoClient.connectToService({
      dataService: this._services.services.DataService ?? (0, import_debug.raise)(new Error("DataService not available")),
      queryService: this._services.services.QueryService ?? (0, import_debug.raise)(new Error("QueryService not available")),
      queueService: this._queuesService
    });
    await this._echoClient.open(this._ctx);
    const mesh = new MeshProxy(this._services, this._instanceId);
    const halo = new HaloProxy(this._services, this._instanceId);
    const spaces = new SpaceList(this._config, this._services, this._echoClient, halo, this._instanceId);
    const shell = this._shellManager ? new Shell({
      shellManager: this._shellManager,
      identity: halo.identity,
      devices: halo.devices,
      spaces
    }) : void 0;
    this._runtime = new ClientRuntime({
      spaces,
      halo,
      mesh,
      shell
    });
    (0, import_invariant.invariant)(this._services.services.SystemService, "SystemService is not available.", {
      F: __dxlog_file,
      L: 423,
      S: this,
      A: [
        "this._services.services.SystemService",
        "'SystemService is not available.'"
      ]
    });
    this._statusStream = this._services.services.SystemService.queryStatus({
      interval: 3e3
    });
    this._statusStream.subscribe(async ({ status }) => {
      this._statusTimeout && clearTimeout(this._statusTimeout);
      trigger.wake(void 0);
      this._statusUpdate.emit(status);
      this._statusTimeout = setTimeout(() => {
        this._statusUpdate.emit(null);
      }, import_client_protocol.STATUS_TIMEOUT);
    }, (err2) => {
      trigger.wake(err2);
      if (err2) {
        this._statusUpdate.emit(null);
      }
    });
    const err = await trigger.wait();
    if (err) {
      throw err;
    }
    await this._runtime.open();
    await this._iframeManager?.open();
    await this._shellManager?.open();
    if (this._iframeManager?.iframe) {
      const origin = this._iframeManager.source.origin === "null" ? this._iframeManager.source.toString().split("/").slice(0, 3).join("/") : this._iframeManager.source.origin;
      this._shellClientProxy = (0, import_rpc.createProtoRpcPeer)({
        exposed: import_client_protocol.clientServiceBundle,
        handlers: this._services.services,
        port: (0, import_rpc_tunnel.createIFramePort)({
          channel: import_client_protocol.DEFAULT_CLIENT_CHANNEL,
          iframe: this._iframeManager.iframe,
          origin
        }),
        handlerRpcOptions: {
          timeout: 6e4
        }
      });
      await this._shellClientProxy.open();
    }
    (0, import_log.log)("opened", void 0, {
      F: __dxlog_file,
      L: 477,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  /**
  * Cleanup, release resources.
  * Open/close is re-entrant.
  */
  async destroy() {
    if (!this._initialized) {
      return;
    }
    await this._close();
    this._statusUpdate.emit(null);
    await this._ctx.dispose();
    this._initialized = false;
  }
  async _close() {
    (0, import_log.log)("closing...", void 0, {
      F: __dxlog_file,
      L: 499,
      S: this,
      C: (f, a) => f(...a)
    });
    this._statusTimeout && clearTimeout(this._statusTimeout);
    await this._statusStream?.close();
    await this._runtime?.close();
    await this._echoClient.close(this._ctx);
    await this._services?.close();
    this._edgeClient = void 0;
    (0, import_log.log)("closed", void 0, {
      F: __dxlog_file,
      L: 506,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  /**
  * Reinitialized the client session with the remote service host.
  * This is useful when connecting to a host running behind a resource lock
  * (e.g., HALO when SharedWorker is unavailable).
  */
  async resumeHostServices() {
    (0, import_invariant.invariant)(this.services.services.SystemService, "SystemService is not available.", {
      F: __dxlog_file,
      L: 515,
      S: this,
      A: [
        "this.services.services.SystemService",
        "'SystemService is not available.'"
      ]
    });
    await this.services.services.SystemService.updateStatus({
      status: import_services.SystemStatus.ACTIVE
    });
  }
  /**
  * Resets and destroys client storage.
  * This will currently leave the client in a closed state.
  * Re-using the client after reset is not currently supported.
  */
  async reset() {
    if (!this._initialized) {
      throw new import_protocols.ApiError("Client not open.");
    }
    (0, import_log.log)("resetting...", void 0, {
      F: __dxlog_file,
      L: 530,
      S: this,
      C: (f, a) => f(...a)
    });
    this._resetting = true;
    (0, import_invariant.invariant)(this._services?.services.SystemService, "SystemService is not available.", {
      F: __dxlog_file,
      L: 532,
      S: this,
      A: [
        "this._services?.services.SystemService",
        "'SystemService is not available.'"
      ]
    });
    await this._services?.services.SystemService.reset();
    await this._close();
    (0, import_log.log)("reset complete", void 0, {
      F: __dxlog_file,
      L: 540,
      S: this,
      C: (f, a) => f(...a)
    });
  }
};
_ts_decorate([
  import_tracing.trace.info()
], Client.prototype, "_instanceId", void 0);
_ts_decorate([
  import_tracing.trace.info()
], Client.prototype, "version", void 0);
_ts_decorate([
  import_tracing.trace.info()
], Client.prototype, "_services", void 0);
_ts_decorate([
  import_tracing.trace.info()
], Client.prototype, "_initialized", void 0);
_ts_decorate([
  import_tracing.trace.info()
], Client.prototype, "_resetting", void 0);
_ts_decorate([
  import_tracing.trace.info({
    depth: null
  })
], Client.prototype, "toJSON", null);
_ts_decorate([
  import_async.synchronized
], Client.prototype, "initialize", null);
_ts_decorate([
  import_async.synchronized
], Client.prototype, "destroy", null);
_ts_decorate([
  import_async.synchronized
], Client.prototype, "reset", null);
Client = _ts_decorate([
  import_tracing.trace.resource()
], Client);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Client,
  DXOS_VERSION
});
//# sourceMappingURL=chunk-DTV5D7HV.cjs.map
