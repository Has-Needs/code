{
  "version": 3,
  "sources": ["../../../src/version.ts", "../../../src/client/client.ts", "../../../src/client/client-runtime.ts"],
  "sourcesContent": ["//\n// Copyright 2023 DXOS.org\n//\n\nexport const DXOS_VERSION = '0.8.3'; // {x-release-please-version}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { type Schema } from 'effect';\nimport { inspect } from 'node:util';\n\nimport { Event, MulticastObservable, synchronized, Trigger } from '@dxos/async';\nimport {\n  DEFAULT_CLIENT_CHANNEL,\n  STATUS_TIMEOUT,\n  clientServiceBundle,\n  type ClientServices,\n  type ClientServicesProvider,\n  type Echo,\n  type Halo,\n  PropertiesType,\n} from '@dxos/client-protocol';\nimport { type Stream } from '@dxos/codec-protobuf/stream';\nimport { Config, SaveConfig } from '@dxos/config';\nimport { Context } from '@dxos/context';\nimport { raise } from '@dxos/debug';\nimport { EchoClient, type QueueService, QueueServiceImpl, QueueServiceStub, type Hypergraph } from '@dxos/echo-db';\nimport { getTypename } from '@dxos/echo-schema';\nimport { EdgeHttpClient } from '@dxos/edge-client';\nimport { invariant } from '@dxos/invariant';\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { ApiError, trace as Trace } from '@dxos/protocols';\nimport { type QueryStatusResponse, SystemStatus } from '@dxos/protocols/proto/dxos/client/services';\nimport { createProtoRpcPeer, type ProtoRpcPeer } from '@dxos/rpc';\nimport { createIFramePort } from '@dxos/rpc-tunnel';\nimport { trace } from '@dxos/tracing';\nimport { type JsonKeyOptions, type MaybePromise } from '@dxos/util';\n\nimport { ClientRuntime } from './client-runtime';\nimport { type MeshProxy } from '../mesh/mesh-proxy';\nimport type { IFrameManager, Shell, ShellManager } from '../services';\nimport { DXOS_VERSION } from '../version';\n\n/**\n * This options object configures the DXOS Client.\n */\n// TODO(burdon): Reconcile with ClientProviderProps.\nexport type ClientOptions = {\n  /** Client configuration object. */\n  config?: Config;\n  /** Custom services provider. */\n  services?: MaybePromise<ClientServicesProvider>;\n  /** ECHO schema. */\n  types?: Schema.Schema.AnyNoContext[];\n  /** Shell path. */\n  shell?: string;\n  /** Create client worker. */\n  createWorker?: () => SharedWorker;\n};\n\n/**\n * The Client class encapsulates the core client-side API of DXOS.\n */\n@trace.resource()\nexport class Client {\n  /**\n   * Emitted after the client is reset and the services have finished restarting.\n   */\n  readonly reloaded = new Event<void>();\n\n  // TODO(wittjosiah): Make `null` status part of enum.\n  private readonly _statusUpdate = new Event<SystemStatus | null>();\n  private readonly _status = MulticastObservable.from(this._statusUpdate, null);\n\n  private readonly _echoClient = new EchoClient();\n\n  private readonly _options: ClientOptions;\n\n  /**\n   * Unique id of the Client, local to the current peer.\n   */\n  @trace.info()\n  private readonly _instanceId = PublicKey.random().toHex();\n\n  /**\n   * The version of this client API.\n   */\n  @trace.info()\n  readonly version = DXOS_VERSION;\n\n  @trace.info()\n  private _services?: ClientServicesProvider;\n\n  @trace.info()\n  private _initialized = false;\n\n  @trace.info()\n  private _resetting = false;\n\n  private _runtime?: ClientRuntime;\n\n  private _ctx = new Context();\n  private _config?: Config;\n  private _statusStream?: Stream<QueryStatusResponse>;\n  private _statusTimeout?: NodeJS.Timeout;\n  private _iframeManager?: IFrameManager;\n  private _shellManager?: ShellManager;\n  private _shellClientProxy?: ProtoRpcPeer<ClientServices>;\n  private _edgeClient?: EdgeHttpClient = undefined;\n  private _queuesService?: QueueService = undefined;\n\n  constructor(options: ClientOptions = {}) {\n    if (\n      typeof window !== 'undefined' &&\n      typeof window.location !== 'undefined' &&\n      window.location.protocol !== 'https:' &&\n      window.location.protocol !== 'chrome-extension:' &&\n      window.location.protocol !== 'socket:' &&\n      !window.location.hostname.endsWith('localhost')\n    ) {\n      log.warn(\n        `DXOS Client will not function in a non-secure context ${window.location.origin}. Either serve with a certificate or use a tunneling service (https://docs.dxos.org/guide/kube/tunneling.html).`,\n      );\n    }\n\n    this._options = options;\n\n    // TODO(wittjosiah): Reconcile this with @dxos/log loading config from localStorage.\n    const filter = options.config?.get('runtime.client.log.filter');\n    if (filter) {\n      const prefix = options.config?.get('runtime.client.log.prefix');\n      log.config({ filter, prefix });\n    }\n\n    this._echoClient.graph.schemaRegistry.addSchema([PropertiesType]);\n    if (options.types) {\n      this.addTypes(options.types);\n    }\n  }\n\n  [inspect.custom](): string {\n    return this.toString();\n  }\n\n  toString(): string {\n    return `Client(${this._instanceId})`;\n  }\n\n  @trace.info({ depth: null })\n  toJSON() {\n    return {\n      initialized: this.initialized,\n      spaces: this._runtime?.spaces,\n      halo: this._runtime?.halo,\n      mesh: this._runtime?.mesh,\n    };\n  }\n\n  /**\n   * Current configuration object.\n   */\n  get config(): Config {\n    invariant(this._config, 'Client not initialized.');\n    return this._config;\n  }\n\n  /**\n   * Current client services provider.\n   */\n  // TODO(burdon): Return services.services. Move to debug endpoint.\n  get services(): ClientServicesProvider {\n    invariant(this._services, 'Client not initialized.');\n    return this._services;\n  }\n\n  /**\n   * Returns true if the client has been initialized. Initialize by calling `.initialize()`.\n   */\n  get initialized() {\n    return this._initialized;\n  }\n\n  /**\n   * Client services system status.\n   */\n  get status(): MulticastObservable<SystemStatus | null> {\n    return this._status;\n  }\n\n  /**\n   * ECHO Spaces.\n   */\n  get spaces(): Echo {\n    invariant(this._runtime, 'Client not initialized.');\n    return this._runtime.spaces;\n  }\n\n  /**\n   * HALO credentials.\n   */\n  get halo(): Halo {\n    invariant(this._runtime, 'Client not initialized.');\n    return this._runtime.halo;\n  }\n\n  /**\n   * MESH networking.\n   */\n  get mesh(): MeshProxy {\n    invariant(this._runtime, 'Client not initialized.');\n    return this._runtime.mesh;\n  }\n\n  /**\n   * EDGE client.\n   * This API is experimental and subject to change.\n   */\n  get edge(): EdgeHttpClient {\n    invariant(this._edgeClient, 'Client not initialized.');\n    return this._edgeClient;\n  }\n\n  /**\n   * @deprecated Temporary.\n   */\n  get graph(): Hypergraph {\n    return this._echoClient.graph;\n  }\n\n  /**\n   * Shell API.\n   */\n  get shell(): Shell {\n    invariant(this._runtime, 'Client not initialized.');\n    invariant(this._runtime.shell, 'Shell not available.');\n    return this._runtime.shell;\n  }\n\n  /**\n   * Add schema types to the client.\n   */\n  // TODO(burdon): Check if already registered (and remove downstream checks).\n  addTypes(types: Schema.Schema.AnyNoContext[]): this {\n    log('addTypes', { schema: types.map((type) => getTypename(type)) });\n\n    // TODO(dmaretskyi): Uncomment after release.\n    // if (!this._initialized) {\n    //   throw new ApiError('Client not open.');\n    // }\n\n    // TODO(burdon): Find?\n    const exists = types.filter((type) => !this._echoClient.graph.schemaRegistry.hasSchema(type));\n    if (exists.length > 0) {\n      this._echoClient.graph.schemaRegistry.addSchema(exists);\n    }\n\n    return this;\n  }\n\n  /**\n   * Get client diagnostics data.\n   */\n  // TODO(burdon): Return type?\n  async diagnostics(options: JsonKeyOptions = {}): Promise<any> {\n    const { DiagnosticsCollector } = await import('@dxos/client-services');\n    invariant(this._services?.services.SystemService, 'SystemService is not available.');\n    return DiagnosticsCollector.collect(this._config, this.services, options);\n  }\n\n  /**\n   * Test and repair database.\n   */\n  async repair(): Promise<any> {\n    const { createLevel } = await import('@dxos/client-services');\n\n    // TODO(burdon): Factor out.\n    const repairSummary: any = {};\n\n    {\n      // Cleanup OPFS.\n      const spaces = this.spaces.get();\n      const docs = spaces\n        .map((space) =>\n          (space as any)._data.pipeline.currentEpoch?.subject.assertion.automergeRoot.slice('automerge:'.length),\n        )\n        .filter(Boolean);\n\n      repairSummary.OPFSRemovedFiles = 0;\n      if (typeof navigator !== 'undefined' && navigator.storage) {\n        const dir = await navigator.storage.getDirectory();\n        for await (const filename of (dir as any)?.keys()) {\n          if (filename.includes('automerge_') && !docs.some((doc) => filename.includes(doc))) {\n            await dir.removeEntry(filename);\n            repairSummary.OPFSRemovedFiles++;\n          }\n        }\n      }\n    }\n\n    {\n      // Fix storage config.\n      const config = {\n        runtime: {\n          client: {\n            storage: {\n              dataStore: this.config.values.runtime?.client?.storage?.dataStore,\n            },\n          },\n        },\n      };\n      await SaveConfig(config);\n\n      repairSummary.storageConfig = config;\n    }\n\n    {\n      repairSummary.levelDBRemovedEntries = 0;\n      // Cleanup old index-data from level db.\n      const level = await createLevel(this._config?.values.runtime?.client?.storage ?? {});\n      const sublevelsToCleanup = [\n        level.sublevel('index-store'),\n        level.sublevel('index-metadata').sublevel('clean'),\n        level.sublevel('index-metadata').sublevel('dirty'),\n      ];\n\n      for (const sublevel of sublevelsToCleanup) {\n        repairSummary.levelDBRemovedEntries += (await sublevel.keys().all()).length;\n        await sublevel.clear();\n      }\n    }\n\n    {\n      await this._services?.services.QueryService?.reindex(undefined, { timeout: 30_000 });\n    }\n\n    log.info('Repair succeeded', { repairSummary });\n    return repairSummary;\n  }\n\n  /**\n   * Initializes internal resources in an idempotent way.\n   * Required before using the Client instance.\n   */\n  @synchronized\n  async initialize(): Promise<void> {\n    if (this._initialized) {\n      return;\n    }\n\n    log.trace('dxos.sdk.client.open', Trace.begin({ id: this._instanceId }));\n    const { createClientServices, IFrameManager, ShellManager } = await import('../services');\n\n    this._ctx = new Context();\n    this._config = this._options.config ?? new Config();\n    // NOTE: Must currently match the host.\n    this._services = await (this._options.services ?? createClientServices(this._config, this._options.createWorker));\n    this._iframeManager = this._options.shell\n      ? new IFrameManager({ source: new URL(this._options.shell, window.location.origin) })\n      : undefined;\n    this._shellManager = this._iframeManager ? new ShellManager(this._iframeManager) : undefined;\n    await this._open();\n    invariant(this._runtime, 'Client runtime initialization failed.');\n\n    // TODO(dmaretskyi): Refactor devtools init.\n    if (typeof window !== 'undefined') {\n      const { mountDevtoolsHooks } = await import('../devtools');\n      mountDevtoolsHooks({ client: this });\n    }\n\n    this._initialized = true;\n    log.trace('dxos.sdk.client.open', Trace.end({ id: this._instanceId }));\n  }\n\n  private async _open(): Promise<void> {\n    log('opening...');\n    invariant(this._services);\n    const { SpaceList } = await import('../echo/space-list');\n    const { HaloProxy } = await import('../halo/halo-proxy');\n    const { MeshProxy } = await import('../mesh/mesh-proxy');\n    const { Shell } = await import('../services');\n\n    const trigger = new Trigger<Error | undefined>();\n    this._services.closed?.on(async (error) => {\n      log('terminated', { resetting: this._resetting });\n      if (error instanceof ApiError) {\n        log.error('fatal', { error });\n        trigger.wake(error);\n      }\n      if (!this._resetting) {\n        await this._close();\n        await this._open();\n        this.reloaded.emit();\n      }\n    });\n    await this._services.open();\n\n    const edgeUrl = this._config!.get('runtime.services.edge.url');\n    if (edgeUrl) {\n      this._edgeClient = new EdgeHttpClient(edgeUrl);\n      this._queuesService = new QueueServiceImpl(this._edgeClient);\n    } else {\n      this._queuesService = new QueueServiceStub();\n    }\n\n    this._echoClient.connectToService({\n      dataService: this._services.services.DataService ?? raise(new Error('DataService not available')),\n      queryService: this._services.services.QueryService ?? raise(new Error('QueryService not available')),\n      queueService: this._queuesService,\n    });\n    await this._echoClient.open(this._ctx);\n\n    const mesh = new MeshProxy(this._services, this._instanceId);\n    const halo = new HaloProxy(this._services, this._instanceId);\n    const spaces = new SpaceList(this._config, this._services, this._echoClient, halo, this._instanceId);\n\n    const shell = this._shellManager\n      ? new Shell({\n          shellManager: this._shellManager,\n          identity: halo.identity,\n          devices: halo.devices,\n          spaces,\n        })\n      : undefined;\n    this._runtime = new ClientRuntime({ spaces, halo, mesh, shell });\n\n    invariant(this._services.services.SystemService, 'SystemService is not available.');\n    this._statusStream = this._services.services.SystemService.queryStatus({ interval: 3_000 });\n    this._statusStream.subscribe(\n      async ({ status }) => {\n        this._statusTimeout && clearTimeout(this._statusTimeout);\n        trigger.wake(undefined);\n\n        this._statusUpdate.emit(status);\n        this._statusTimeout = setTimeout(() => {\n          this._statusUpdate.emit(null);\n        }, STATUS_TIMEOUT);\n      },\n      (err) => {\n        trigger.wake(err);\n        if (err) {\n          this._statusUpdate.emit(null);\n        }\n      },\n    );\n\n    const err = await trigger.wait();\n    if (err) {\n      throw err;\n    }\n\n    await this._runtime.open();\n\n    // TODO(wittjosiah): Factor out iframe manager and proxy into shell manager.\n    await this._iframeManager?.open();\n    await this._shellManager?.open();\n    if (this._iframeManager?.iframe) {\n      // TODO(wittjosiah): Remove. Workaround for socket runtime bug.\n      //   https://github.com/socketsupply/socket/issues/893\n      const origin =\n        this._iframeManager.source.origin === 'null'\n          ? this._iframeManager.source.toString().split('/').slice(0, 3).join('/')\n          : this._iframeManager.source.origin;\n\n      this._shellClientProxy = createProtoRpcPeer({\n        exposed: clientServiceBundle,\n        handlers: this._services.services as ClientServices,\n        port: createIFramePort({\n          channel: DEFAULT_CLIENT_CHANNEL,\n          iframe: this._iframeManager.iframe,\n          origin,\n        }),\n        handlerRpcOptions: {\n          timeout: 60_000, // Timeout is specifically very high because shell will be managing its own timeouts on RPCs.\n        },\n      });\n\n      await this._shellClientProxy.open();\n    }\n\n    log('opened');\n  }\n\n  /**\n   * Cleanup, release resources.\n   * Open/close is re-entrant.\n   */\n  @synchronized\n  async destroy(): Promise<void> {\n    if (!this._initialized) {\n      return;\n    }\n\n    // TODO(burdon): Call flush?\n    await this._close();\n    this._statusUpdate.emit(null);\n    await this._ctx.dispose();\n\n    this._initialized = false;\n  }\n\n  private async _close(): Promise<void> {\n    log('closing...');\n    this._statusTimeout && clearTimeout(this._statusTimeout);\n    await this._statusStream?.close();\n    await this._runtime?.close();\n    await this._echoClient.close(this._ctx);\n    await this._services?.close();\n    this._edgeClient = undefined;\n    log('closed');\n  }\n\n  /**\n   * Reinitialized the client session with the remote service host.\n   * This is useful when connecting to a host running behind a resource lock\n   * (e.g., HALO when SharedWorker is unavailable).\n   */\n  async resumeHostServices(): Promise<void> {\n    invariant(this.services.services.SystemService, 'SystemService is not available.');\n    await this.services.services.SystemService.updateStatus({ status: SystemStatus.ACTIVE });\n  }\n\n  /**\n   * Resets and destroys client storage.\n   * This will currently leave the client in a closed state.\n   * Re-using the client after reset is not currently supported.\n   */\n  @synchronized\n  async reset(): Promise<void> {\n    if (!this._initialized) {\n      throw new ApiError('Client not open.');\n    }\n\n    log('resetting...');\n    this._resetting = true;\n    invariant(this._services?.services.SystemService, 'SystemService is not available.');\n    await this._services?.services.SystemService.reset();\n    await this._close();\n\n    // TODO(wittjosiah): Re-open after reset.\n    // await this._open();\n    // this._resetting = false;\n    // this.reloaded.emit();\n    log('reset complete');\n  }\n}\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport type { SpaceList } from '../echo/space-list';\nimport type { HaloProxy } from '../halo/halo-proxy';\nimport type { MeshProxy } from '../mesh/mesh-proxy';\nimport type { Shell } from '../services';\n\nexport class ClientRuntime {\n  readonly spaces: SpaceList;\n  readonly halo: HaloProxy;\n  readonly mesh: MeshProxy;\n  readonly shell?: Shell;\n\n  constructor({ spaces, halo, mesh, shell }: { spaces: SpaceList; halo: HaloProxy; mesh: MeshProxy; shell?: Shell }) {\n    this.spaces = spaces;\n    this.halo = halo;\n    this.mesh = mesh;\n    this.shell = shell;\n  }\n\n  async open(): Promise<void> {\n    await this.mesh._open();\n    await this.spaces._open();\n    await this.halo._open();\n  }\n\n  async close(): Promise<void> {\n    await this.halo._close();\n    await this.spaces._close();\n    await this.mesh._close();\n  }\n}\n"],
  "mappings": "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",
  "names": ["DXOS_VERSION", "inspect", "Event", "MulticastObservable", "synchronized", "Trigger", "DEFAULT_CLIENT_CHANNEL", "STATUS_TIMEOUT", "clientServiceBundle", "PropertiesType", "Config", "SaveConfig", "Context", "raise", "EchoClient", "QueueServiceImpl", "QueueServiceStub", "getTypename", "EdgeHttpClient", "invariant", "PublicKey", "log", "ApiError", "trace", "Trace", "SystemStatus", "createProtoRpcPeer", "createIFramePort", "ClientRuntime", "spaces", "halo", "mesh", "shell", "open", "_open", "close", "_close", "Client", "options", "reloaded", "Event", "_statusUpdate", "_status", "MulticastObservable", "from", "_echoClient", "EchoClient", "_instanceId", "PublicKey", "random", "toHex", "version", "DXOS_VERSION", "_initialized", "_resetting", "_ctx", "Context", "_edgeClient", "undefined", "_queuesService", "window", "location", "protocol", "hostname", "endsWith", "log", "warn", "origin", "_options", "filter", "config", "get", "prefix", "graph", "schemaRegistry", "addSchema", "PropertiesType", "types", "addTypes", "inspect", "custom", "toString", "toJSON", "initialized", "spaces", "_runtime", "halo", "mesh", "invariant", "_config", "services", "_services", "status", "edge", "shell", "schema", "map", "type", "getTypename", "exists", "hasSchema", "length", "diagnostics", "DiagnosticsCollector", "SystemService", "collect", "repair", "createLevel", "repairSummary", "docs", "space", "_data", "pipeline", "currentEpoch", "subject", "assertion", "automergeRoot", "slice", "Boolean", "OPFSRemovedFiles", "navigator", "storage", "dir", "getDirectory", "filename", "keys", "includes", "some", "doc", "removeEntry", "runtime", "client", "dataStore", "values", "SaveConfig", "storageConfig", "levelDBRemovedEntries", "level", "sublevelsToCleanup", "sublevel", "all", "clear", "QueryService", "reindex", "timeout", "info", "initialize", "trace", "Trace", "begin", "id", "createClientServices", "IFrameManager", "ShellManager", "Config", "createWorker", "_iframeManager", "source", "URL", "_shellManager", "_open", "mountDevtoolsHooks", "end", "SpaceList", "HaloProxy", "MeshProxy", "Shell", "trigger", "Trigger", "closed", "on", "error", "resetting", "ApiError", "wake", "_close", "emit", "open", "edgeUrl", "EdgeHttpClient", "QueueServiceImpl", "QueueServiceStub", "connectToService", "dataService", "DataService", "raise", "Error", "queryService", "queueService", "shellManager", "identity", "devices", "ClientRuntime", "_statusStream", "queryStatus", "interval", "subscribe", "_statusTimeout", "clearTimeout", "setTimeout", "STATUS_TIMEOUT", "err", "wait", "iframe", "split", "join", "_shellClientProxy", "createProtoRpcPeer", "exposed", "clientServiceBundle", "handlers", "port", "createIFramePort", "channel", "DEFAULT_CLIENT_CHANNEL", "handlerRpcOptions", "destroy", "dispose", "close", "resumeHostServices", "updateStatus", "SystemStatus", "ACTIVE", "reset", "depth", "resource"]
}
