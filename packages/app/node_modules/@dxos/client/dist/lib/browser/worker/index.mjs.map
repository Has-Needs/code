{
  "version": 3,
  "sources": ["../../../../src/worker/onconnect.ts"],
  "sourcesContent": ["//\n// Copyright 2024 DXOS.org\n//\n\nimport { Trigger } from '@dxos/async';\nimport { Config, Defaults, Envs, Local, Storage } from '@dxos/config';\nimport { log } from '@dxos/log';\nimport { createWorkerPort } from '@dxos/rpc-tunnel';\nimport { TRACE_PROCESSOR } from '@dxos/tracing';\n\nimport { mountDevtoolsHooks } from '../devtools';\nimport { LOCK_KEY } from '../lock-key';\n\nTRACE_PROCESSOR.setInstanceTag('shared-worker');\n\nlet releaseLock: () => void;\nconst lockPromise = new Promise<void>((resolve) => (releaseLock = resolve));\nconst lockAcquired = new Trigger();\nvoid navigator.locks.request(LOCK_KEY, (lock) => {\n  lockAcquired.wake();\n  return lockPromise;\n});\n\nconst setupRuntime = async () => {\n  const { WorkerRuntime } = await import('@dxos/client-services');\n\n  const workerRuntime = new WorkerRuntime({\n    configProvider: async () => {\n      const config = new Config(await Storage(), Envs(), Local(), Defaults());\n      log.config({ filter: config.get('runtime.client.log.filter'), prefix: config.get('runtime.client.log.prefix') });\n      return config;\n    },\n    acquireLock: () => lockAcquired.wait(),\n    releaseLock: () => releaseLock(),\n    onStop: async () => {\n      // Close the shared worker, lock will be released automatically.\n      self.close();\n    },\n  });\n\n  // Allow to access host from console.\n  mountDevtoolsHooks({\n    host: workerRuntime.host,\n  });\n\n  return workerRuntime;\n};\n\nconst workerRuntimePromise = setupRuntime();\n\nconst start = Date.now();\nvoid workerRuntimePromise\n  .then((workerRuntime) => workerRuntime.start())\n  .then(\n    () => {\n      log.info('worker ready', { initTimeMs: Date.now() - start });\n    },\n    (err) => {\n      log.catch(err);\n    },\n  );\n\nexport const onconnect = async (event: MessageEvent<any>) => {\n  log.info('onconnect', { event });\n  const port = event.ports[0];\n\n  const systemChannel = new MessageChannel();\n  const appChannel = new MessageChannel();\n\n  // set log configuration forwarded from localStorage setting\n  // TODO(nf): block worker initialization until this is set? we usually win the race.\n  port.onmessage = (event) => {\n    (globalThis as any).localStorage_dxlog = event.data.dxlog;\n  };\n  // NOTE: This is intentiontally not using protobuf because it occurs before the rpc connection is established.\n  port.postMessage(\n    {\n      command: 'init',\n      payload: {\n        systemPort: systemChannel.port1,\n        appPort: appChannel.port1,\n      },\n    },\n    [systemChannel.port1, appChannel.port1],\n  );\n\n  const workerRuntime = await workerRuntimePromise;\n  await workerRuntime.createSession({\n    systemPort: createWorkerPort({ port: systemChannel.port2 }),\n    appPort: createWorkerPort({ port: appChannel.port2 }),\n  });\n};\n\nexport const getWorkerServiceHost = async () => (await workerRuntimePromise).host;\n"],
  "mappings": ";;;;;;;;;;;;AAIA,SAASA,eAAe;AACxB,SAASC,QAAQC,UAAUC,MAAMC,OAAOC,eAAe;AACvD,SAASC,WAAW;AACpB,SAASC,wBAAwB;AACjC,SAASC,uBAAuB;;AAKhCC,gBAAgBC,eAAe,eAAA;AAE/B,IAAIC;AACJ,IAAMC,cAAc,IAAIC,QAAc,CAACC,YAAaH,cAAcG,OAAAA;AAClE,IAAMC,eAAe,IAAIC,QAAAA;AACzB,KAAKC,UAAUC,MAAMC,QAAQC,UAAU,CAACC,SAAAA;AACtCN,eAAaO,KAAI;AACjB,SAAOV;AACT,CAAA;AAEA,IAAMW,eAAe,YAAA;AACnB,QAAM,EAAEC,cAAa,IAAK,MAAM,OAAO,uBAAA;AAEvC,QAAMC,gBAAgB,IAAID,cAAc;IACtCE,gBAAgB,YAAA;AACd,YAAMC,SAAS,IAAIC,OAAO,MAAMC,QAAAA,GAAWC,KAAAA,GAAQC,MAAAA,GAASC,SAAAA,CAAAA;AAC5DC,UAAIN,OAAO;QAAEO,QAAQP,OAAOQ,IAAI,2BAAA;QAA8BC,QAAQT,OAAOQ,IAAI,2BAAA;MAA6B,GAAA,QAAA;;;;;;AAC9G,aAAOR;IACT;IACAU,aAAa,MAAMtB,aAAauB,KAAI;IACpC3B,aAAa,MAAMA,YAAAA;IACnB4B,QAAQ,YAAA;AAENC,WAAKC,MAAK;IACZ;EACF,CAAA;AAGAC,qBAAmB;IACjBC,MAAMlB,cAAckB;EACtB,CAAA;AAEA,SAAOlB;AACT;AAEA,IAAMmB,uBAAuBrB,aAAAA;AAE7B,IAAMsB,QAAQC,KAAKC,IAAG;AACtB,KAAKH,qBACFI,KAAK,CAACvB,kBAAkBA,cAAcoB,MAAK,CAAA,EAC3CG,KACC,MAAA;AACEf,MAAIgB,KAAK,gBAAgB;IAAEC,YAAYJ,KAAKC,IAAG,IAAKF;EAAM,GAAA;;;;;;AAC5D,GACA,CAACM,QAAAA;AACClB,MAAImB,MAAMD,KAAAA,QAAAA;;;;;;AACZ,CAAA;AAGG,IAAME,YAAY,OAAOC,UAAAA;AAC9BrB,MAAIgB,KAAK,aAAa;IAAEK;EAAM,GAAA;;;;;;AAC9B,QAAMC,OAAOD,MAAME,MAAM,CAAA;AAEzB,QAAMC,gBAAgB,IAAIC,eAAAA;AAC1B,QAAMC,aAAa,IAAID,eAAAA;AAIvBH,OAAKK,YAAY,CAACN,WAAAA;AACfO,eAAmBC,qBAAqBR,OAAMS,KAAKC;EACtD;AAEAT,OAAKU,YACH;IACEC,SAAS;IACTC,SAAS;MACPC,YAAYX,cAAcY;MAC1BC,SAASX,WAAWU;IACtB;EACF,GACA;IAACZ,cAAcY;IAAOV,WAAWU;GAAM;AAGzC,QAAM5C,gBAAgB,MAAMmB;AAC5B,QAAMnB,cAAc8C,cAAc;IAChCH,YAAYI,iBAAiB;MAAEjB,MAAME,cAAcgB;IAAM,CAAA;IACzDH,SAASE,iBAAiB;MAAEjB,MAAMI,WAAWc;IAAM,CAAA;EACrD,CAAA;AACF;AAEO,IAAMC,uBAAuB,aAAa,MAAM9B,sBAAsBD;",
  "names": ["Trigger", "Config", "Defaults", "Envs", "Local", "Storage", "log", "createWorkerPort", "TRACE_PROCESSOR", "TRACE_PROCESSOR", "setInstanceTag", "releaseLock", "lockPromise", "Promise", "resolve", "lockAcquired", "Trigger", "navigator", "locks", "request", "LOCK_KEY", "lock", "wake", "setupRuntime", "WorkerRuntime", "workerRuntime", "configProvider", "config", "Config", "Storage", "Envs", "Local", "Defaults", "log", "filter", "get", "prefix", "acquireLock", "wait", "onStop", "self", "close", "mountDevtoolsHooks", "host", "workerRuntimePromise", "start", "Date", "now", "then", "info", "initTimeMs", "err", "catch", "onconnect", "event", "port", "ports", "systemChannel", "MessageChannel", "appChannel", "onmessage", "globalThis", "localStorage_dxlog", "data", "dxlog", "postMessage", "command", "payload", "systemPort", "port1", "appPort", "createSession", "createWorkerPort", "port2", "getWorkerServiceHost"]
}
