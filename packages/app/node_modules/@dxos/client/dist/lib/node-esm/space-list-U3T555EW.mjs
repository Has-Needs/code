import { createRequire } from 'node:module';const require = createRequire(import.meta.url);
import {
  SpaceProxy
} from "./chunk-YSDZCRRN.mjs";
import {
  InvitationsProxy
} from "./chunk-RT5VBVJV.mjs";
import {
  RPC_TIMEOUT
} from "./chunk-YV6DEKSE.mjs";

// packages/sdk/client/src/echo/space-list.ts
import { inspect } from "node:util";
import { Event as Event2, MulticastObservable, PushStream, scheduleMicroTask, Trigger } from "@dxos/async";
import { CREATE_SPACE_TIMEOUT, PropertiesType } from "@dxos/client-protocol";
import { Context } from "@dxos/context";
import { getCredentialAssertion } from "@dxos/credentials";
import { failUndefined, inspectObject } from "@dxos/debug";
import { Filter, Query } from "@dxos/echo-db";
import { failedInvariant, invariant as invariant2 } from "@dxos/invariant";
import { PublicKey as PublicKey2, SpaceId } from "@dxos/keys";
import { live } from "@dxos/live-object";
import { log as log2 } from "@dxos/log";
import { ApiError, trace as Trace } from "@dxos/protocols";
import { Invitation, SpaceState } from "@dxos/protocols/proto/dxos/client/services";
import { trace } from "@dxos/tracing";

// packages/sdk/client/src/echo/agent.ts
import { Event } from "@dxos/async";
import { todo } from "@dxos/debug";
import { invariant } from "@dxos/invariant";
import { PublicKey } from "@dxos/keys";
import { log } from "@dxos/log";
import { QUERY_CHANNEL } from "@dxos/protocols";
import { QueryReactivity } from "@dxos/protocols/proto/dxos/echo/query";
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/sdk/client/src/echo/agent.ts";
var ERR_CLOSING = new Error();
var AgentQuerySourceProvider = class {
  /**
  * Constructor.
  * @param _space Space instance that will be used for messaging with the agent through the gossip protocol.
  */
  constructor(_space) {
    this._space = _space;
    this._responsePromises = /* @__PURE__ */ new Map();
    this._unsubscribe = void 0;
  }
  async open() {
    this._unsubscribe = this._space.listen(QUERY_CHANNEL, (message) => this._handleMessage(message));
  }
  async close() {
    this._unsubscribe?.();
    this._responsePromises.forEach((promise) => promise.reject(ERR_CLOSING));
    this._responsePromises.clear();
  }
  // TODO(burdon): Make async?
  // TODO(burdon): Define return type.
  _sendRequest(query) {
    const request = {
      queryId: PublicKey.random().toHex(),
      query: JSON.stringify(query),
      reactivity: QueryReactivity.ONE_SHOT
    };
    this._space.postMessage(QUERY_CHANNEL, {
      "@type": "dxos.agent.query.QueryRequest",
      ...request
    }).catch((error) => log.catch(error, void 0, {
      F: __dxlog_file,
      L: 57,
      S: this,
      C: (f, a) => f(...a)
    }));
    let cancelRequest;
    return {
      response: new Promise((resolve, reject) => {
        invariant(request.queryId, void 0, {
          F: __dxlog_file,
          L: 62,
          S: this,
          A: [
            "request.queryId",
            ""
          ]
        });
        this._responsePromises.set(request.queryId, {
          resolve,
          reject
        });
        cancelRequest = () => {
          reject(new Error("Request cancelled."));
          this._responsePromises.delete(request.queryId);
        };
      }),
      cancelRequest: () => {
        cancelRequest();
      }
    };
  }
  _handleMessage(message) {
    if (message.payload["@type"] !== "dxos.agent.query.QueryResponse") {
      return;
    }
    const response = message.payload;
    invariant(response.queryId, "QueryId is undefined.", {
      F: __dxlog_file,
      L: 81,
      S: this,
      A: [
        "response.queryId",
        "'QueryId is undefined.'"
      ]
    });
    const responsePromise = this._responsePromises.get(response.queryId);
    if (!responsePromise) {
      log("Request for this response was canceled.", {
        response
      }, {
        F: __dxlog_file,
        L: 84,
        S: this,
        C: (f, a) => f(...a)
      });
      return;
    }
    responsePromise.resolve(response);
    this._responsePromises.delete(response.queryId);
  }
  create() {
    return new AgentQuerySource({
      sendRequest: this._sendRequest.bind(this)
    });
  }
};
var AgentQuerySource = class {
  constructor(_params) {
    this._params = _params;
    this._cancelPreviousRequest = void 0;
    this.changed = new Event();
  }
  open() {
  }
  close() {
  }
  getResults() {
    return this._results ?? [];
  }
  async run() {
    return this._results ?? [];
  }
  update(query) {
    this._results = void 0;
    this.changed.emit();
    if (this._cancelPreviousRequest) {
      this._cancelPreviousRequest();
    }
    const startTime = Date.now();
    const { response, cancelRequest } = this._params.sendRequest(query);
    this._cancelPreviousRequest = cancelRequest;
    response.then((response2) => {
      this._results = response2.results?.map((result) => {
        const objSnapshot = response2.objects?.find((obj) => obj.objectId === result.id);
        return {
          id: result.id,
          spaceKey: result.spaceKey,
          spaceId: result.spaceId,
          object: objSnapshot && getEchoObjectFromSnapshot(objSnapshot),
          match: {
            rank: result.rank
          },
          resolution: {
            source: "remote",
            time: Date.now() - startTime
          }
        };
      }) ?? [];
      this.changed.emit();
    }).catch((error) => error === ERR_CLOSING || log.catch(error, void 0, {
      F: __dxlog_file,
      L: 164,
      S: this,
      C: (f, a) => f(...a)
    }));
  }
};
var getEchoObjectFromSnapshot = (objSnapshot) => {
  invariant(objSnapshot.genesis, "Genesis is undefined.", {
    F: __dxlog_file,
    L: 169,
    S: void 0,
    A: [
      "objSnapshot.genesis",
      "'Genesis is undefined.'"
    ]
  });
  invariant(objSnapshot.snapshot, "Genesis model type is undefined.", {
    F: __dxlog_file,
    L: 170,
    S: void 0,
    A: [
      "objSnapshot.snapshot",
      "'Genesis model type is undefined.'"
    ]
  });
  return todo();
};

// packages/sdk/client/src/echo/space-list.ts
function _ts_decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file2 = "/home/runner/work/dxos/dxos/packages/sdk/client/src/echo/space-list.ts";
var ENABLE_AGENT_QUERY_SOURCE = false;
var SpaceList = class extends MulticastObservable {
  get _isReadyState() {
    return this._isReady.get();
  }
  constructor(_config, _serviceProvider, _echoClient, _halo, _traceParent) {
    const spacesStream = new PushStream();
    super(spacesStream.observable, []), this._config = _config, this._serviceProvider = _serviceProvider, this._echoClient = _echoClient, this._halo = _halo, this._traceParent = _traceParent, this._defaultSpaceAvailable = new PushStream(), this._isReady = new MulticastObservable(this._defaultSpaceAvailable.observable, false), this._spaceCreated = new Event2(), this._instanceId = PublicKey2.random().toHex();
    this._spacesStream = spacesStream;
  }
  [inspect.custom]() {
    return inspectObject(this);
  }
  get echoClient() {
    return this._echoClient;
  }
  toJSON() {
    return {
      spaces: this._value?.length
    };
  }
  /**
  * @internal
  */
  async _open() {
    log2.trace("dxos.sdk.echo-proxy.open", Trace.begin({
      id: this._instanceId,
      parentId: this._traceParent
    }), {
      F: __dxlog_file2,
      L: 94,
      S: this,
      C: (f, a) => f(...a)
    });
    this._ctx = new Context({
      onError: (error) => {
        log2.catch(error, void 0, {
          F: __dxlog_file2,
          L: 97,
          S: this,
          C: (f, a) => f(...a)
        });
      }
    }, {
      F: __dxlog_file2,
      L: 95
    });
    const credentialsSubscription = this._halo.credentials.subscribe(() => {
      if (this._updateAndOpenDefaultSpace()) {
        credentialsSubscription.unsubscribe();
      }
    });
    this._ctx.onDispose(() => credentialsSubscription.unsubscribe());
    invariant2(this._serviceProvider.services.SpacesService, "SpacesService is not available.", {
      F: __dxlog_file2,
      L: 108,
      S: this,
      A: [
        "this._serviceProvider.services.SpacesService",
        "'SpacesService is not available.'"
      ]
    });
    invariant2(this._serviceProvider.services.InvitationsService, "InvitationsService is not available.", {
      F: __dxlog_file2,
      L: 109,
      S: this,
      A: [
        "this._serviceProvider.services.InvitationsService",
        "'InvitationsService is not available.'"
      ]
    });
    this._invitationProxy = new InvitationsProxy(this._serviceProvider.services.InvitationsService, this._serviceProvider.services.IdentityService, () => ({
      kind: Invitation.Kind.SPACE
    }));
    await this._invitationProxy.open();
    const gotInitialUpdate = new Trigger();
    const spacesStream = this._serviceProvider.services.SpacesService.querySpaces(void 0, {
      timeout: RPC_TIMEOUT
    });
    spacesStream.subscribe((data) => {
      let emitUpdate = false;
      const newSpaces = this.get();
      for (const space of data.spaces ?? []) {
        if (this._ctx.disposed) {
          return;
        }
        let spaceProxy = newSpaces.find(({ key }) => key.equals(space.spaceKey));
        if (!spaceProxy) {
          spaceProxy = new SpaceProxy(this._serviceProvider, space, this._echoClient);
          if (this._shouldOpenSpace(space)) {
            this._openSpaceAsync(spaceProxy);
          }
          spaceProxy._stateUpdate.on(this._ctx, () => {
            this._spacesStream.next([
              ...this.get()
            ]);
          });
          newSpaces.push(spaceProxy);
          this._spaceCreated.emit(spaceProxy.key);
          if (this._defaultSpaceId && spaceProxy.id === this._defaultSpaceId) {
            this._defaultSpaceAvailable.next(true);
          }
          emitUpdate = true;
        }
        scheduleMicroTask(this._ctx, async () => {
          await spaceProxy._processSpaceUpdate(space);
        });
      }
      gotInitialUpdate.wake();
      if (emitUpdate) {
        this._spacesStream.next([
          ...newSpaces
        ]);
      }
    });
    this._ctx.onDispose(() => spacesStream.close());
    if (ENABLE_AGENT_QUERY_SOURCE) {
      const subscription = this._isReady.subscribe(async (ready) => {
        if (!ready) {
          return;
        }
        const agentQuerySourceProvider = new AgentQuerySourceProvider(this.default);
        await agentQuerySourceProvider.open();
        this._echoClient.graph.registerQuerySourceProvider(agentQuerySourceProvider);
        this._ctx.onDispose(() => agentQuerySourceProvider.close());
        subscription.unsubscribe();
      });
      this._ctx.onDispose(() => subscription.unsubscribe());
    }
    await gotInitialUpdate.wait();
    log2.trace("dxos.sdk.echo-proxy.open", Trace.end({
      id: this._instanceId
    }), {
      F: __dxlog_file2,
      L: 188,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  _updateAndOpenDefaultSpace() {
    const defaultSpaceCredential = this._halo.queryCredentials({
      type: "dxos.halo.credentials.DefaultSpace"
    })[0];
    const defaultSpaceAssertion = defaultSpaceCredential && getCredentialAssertion(defaultSpaceCredential);
    if (defaultSpaceAssertion?.["@type"] !== "dxos.halo.credentials.DefaultSpace") {
      return false;
    }
    if (!SpaceId.isValid(defaultSpaceAssertion.spaceId)) {
      return false;
    }
    this._defaultSpaceId = defaultSpaceAssertion.spaceId;
    const defaultSpace = this._spaces.find((space) => space.id === defaultSpaceAssertion.spaceId);
    log2("defaultSpaceKey read from a credential", {
      spaceExists: defaultSpace != null,
      spaceOpen: defaultSpace?.isOpen,
      spaceId: this._defaultSpaceId
    }, {
      F: __dxlog_file2,
      L: 205,
      S: this,
      C: (f, a) => f(...a)
    });
    if (defaultSpace) {
      if (defaultSpace.state.get() === SpaceState.SPACE_CLOSED) {
        this._openSpaceAsync(defaultSpace);
      }
      this._defaultSpaceAvailable.next(true);
    }
    return true;
  }
  _openSpaceAsync(spaceProxy) {
    void spaceProxy.open().catch((err) => log2.catch(err, void 0, {
      F: __dxlog_file2,
      L: 222,
      S: this,
      C: (f, a) => f(...a)
    }));
  }
  _shouldOpenSpace(space) {
    if (this._ctx.disposed || space.state === SpaceState.SPACE_INACTIVE) {
      return false;
    }
    if (!this._config?.values?.runtime?.client?.lazySpaceOpen) {
      return true;
    }
    return space.id === this._defaultSpaceId;
  }
  async setConfig(config) {
    await this._serviceProvider.services.QueryService?.setConfig(config, {
      timeout: 2e4
    });
  }
  /**
  * @internal
  */
  async _close() {
    await this._ctx.dispose();
    await Promise.all(this.get().map((space) => space._destroy()));
    this._spacesStream.next([]);
    await this._invitationProxy?.close();
    this._invitationProxy = void 0;
    this._defaultSpaceAvailable.next(false);
    this._defaultSpaceId = void 0;
  }
  get isReady() {
    return this._isReady;
  }
  async waitUntilReady() {
    return new Promise((resolve) => {
      const subscription = this._isReady.subscribe((isReady) => {
        if (isReady) {
          subscription.unsubscribe();
          resolve();
        }
      });
    });
  }
  get(spaceIdOrKey) {
    if (!spaceIdOrKey) {
      return this._value;
    }
    if (spaceIdOrKey instanceof PublicKey2) {
      return this._value?.find(({ key }) => key.equals(spaceIdOrKey));
    } else {
      if (!SpaceId.isValid(spaceIdOrKey)) {
        throw new ApiError("Invalid space id.");
      }
      return this._value?.find(({ id }) => id === spaceIdOrKey);
    }
  }
  get _spaces() {
    return this.get();
  }
  get default() {
    invariant2(this._defaultSpaceId, "Default space ID not set.", {
      F: __dxlog_file2,
      L: 293,
      S: this,
      A: [
        "this._defaultSpaceId",
        "'Default space ID not set.'"
      ]
    });
    const space = this.get().find((space2) => space2.id === this._defaultSpaceId);
    invariant2(space, "Default space is not yet available. Use `client.spaces.isReady` to wait for the default space.", {
      F: __dxlog_file2,
      L: 295,
      S: this,
      A: [
        "space",
        "'Default space is not yet available. Use `client.spaces.isReady` to wait for the default space.'"
      ]
    });
    return space;
  }
  async create(meta) {
    invariant2(this._serviceProvider.services.SpacesService, "SpacesService is not available.", {
      F: __dxlog_file2,
      L: 300,
      S: this,
      A: [
        "this._serviceProvider.services.SpacesService",
        "'SpacesService is not available.'"
      ]
    });
    const traceId = PublicKey2.random().toHex();
    log2.trace("dxos.sdk.echo-proxy.create-space", Trace.begin({
      id: traceId
    }), {
      F: __dxlog_file2,
      L: 302,
      S: this,
      C: (f, a) => f(...a)
    });
    const space = await this._serviceProvider.services.SpacesService.createSpace(void 0, {
      timeout: RPC_TIMEOUT
    });
    await this._spaceCreated.waitForCondition(() => {
      return this.get().some(({ key }) => key.equals(space.spaceKey));
    });
    const spaceProxy = this._findProxy(space);
    await spaceProxy._databaseInitialized.wait({
      timeout: CREATE_SPACE_TIMEOUT
    });
    spaceProxy.db.add(live(PropertiesType, meta ?? {}), {
      placeIn: "root-doc"
    });
    await spaceProxy.db.flush();
    await spaceProxy._initializationComplete.wait();
    log2.trace("dxos.sdk.echo-proxy.create-space", Trace.end({
      id: traceId
    }), {
      F: __dxlog_file2,
      L: 315,
      S: this,
      C: (f, a) => f(...a)
    });
    return spaceProxy;
  }
  /**
  * @internal
  */
  async import(archive) {
    invariant2(this._serviceProvider.services.SpacesService, "SpaceService is not available.", {
      F: __dxlog_file2,
      L: 323,
      S: this,
      A: [
        "this._serviceProvider.services.SpacesService",
        "'SpaceService is not available.'"
      ]
    });
    const { newSpaceId } = await this._serviceProvider.services.SpacesService.importSpace({
      archive
    }, {
      timeout: CREATE_SPACE_TIMEOUT
    });
    invariant2(SpaceId.isValid(newSpaceId), "Invalid space ID", {
      F: __dxlog_file2,
      L: 328,
      S: this,
      A: [
        "SpaceId.isValid(newSpaceId)",
        "'Invalid space ID'"
      ]
    });
    await this._spaceCreated.waitForCondition(() => {
      return this.get().some((space) => space.id === newSpaceId);
    });
    const spaceProxy = this.get(newSpaceId) ?? failedInvariant();
    await spaceProxy.waitUntilReady();
    return spaceProxy;
  }
  join(invitation) {
    if (!this._invitationProxy) {
      throw new ApiError("Client not open.");
    }
    log2("accept invitation", invitation, {
      F: __dxlog_file2,
      L: 343,
      S: this,
      C: (f, a) => f(...a)
    });
    return this._invitationProxy.join(invitation);
  }
  async joinBySpaceKey(spaceKey) {
    const response = await this._serviceProvider.services.SpacesService.joinBySpaceKey({
      spaceKey
    });
    return this._findProxy(response.space);
  }
  static {
    this.prototype.query = this.prototype._query;
  }
  _query(query, options) {
    query = Filter.is(query) ? Query.select(query) : query;
    return this._echoClient.graph.query(query, options);
  }
  _findProxy(space) {
    return this.get().find(({ key }) => key.equals(space.spaceKey)) ?? failUndefined();
  }
};
_ts_decorate([
  trace.info()
], SpaceList.prototype, "_isReadyState", null);
_ts_decorate([
  trace.info({
    depth: null
  })
], SpaceList.prototype, "toJSON", null);
_ts_decorate([
  trace.span()
], SpaceList.prototype, "_open", null);
_ts_decorate([
  trace.span()
], SpaceList.prototype, "_close", null);
_ts_decorate([
  trace.info()
], SpaceList.prototype, "_spaces", null);
SpaceList = _ts_decorate([
  trace.resource()
], SpaceList);
export {
  SpaceList
};
//# sourceMappingURL=space-list-U3T555EW.mjs.map
