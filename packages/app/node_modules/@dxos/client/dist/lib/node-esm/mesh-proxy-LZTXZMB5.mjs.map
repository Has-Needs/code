{
  "version": 3,
  "sources": ["../../../src/mesh/mesh-proxy.ts"],
  "sourcesContent": ["//\n// Copyright 2021 DXOS.org\n//\n\nimport { Event, MulticastObservable } from '@dxos/async';\nimport { type ClientServicesProvider } from '@dxos/client-protocol';\nimport { Context } from '@dxos/context';\nimport { invariant } from '@dxos/invariant';\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { trace } from '@dxos/protocols';\nimport { type NetworkStatus, ConnectionState } from '@dxos/protocols/proto/dxos/client/services';\n\nimport { RPC_TIMEOUT } from '../common';\n\n/**\n * Public API for MESH services.\n */\nexport class MeshProxy {\n  private readonly _networkStatusUpdated = new Event<NetworkStatus>();\n  private readonly _networkStatus = MulticastObservable.from(this._networkStatusUpdated, {\n    swarm: ConnectionState.OFFLINE,\n    signaling: [],\n  });\n\n  private _ctx?: Context;\n\n  private readonly _instanceId = PublicKey.random().toHex();\n\n  constructor(\n    private readonly _serviceProvider: ClientServicesProvider,\n    /**\n     * @internal\n     */\n    public _traceParent?: string,\n  ) {}\n\n  toJSON(): { networkStatus: NetworkStatus } {\n    return {\n      networkStatus: this._networkStatus.get(),\n    };\n  }\n\n  get networkStatus() {\n    return this._networkStatus;\n  }\n\n  async updateConfig(swarm: ConnectionState): Promise<void> {\n    invariant(this._serviceProvider.services.NetworkService, 'NetworkService is not available.');\n    return this._serviceProvider.services.NetworkService.updateConfig({ swarm }, { timeout: RPC_TIMEOUT });\n  }\n\n  /**\n   * @internal\n   */\n  async _open(): Promise<void> {\n    log.trace('dxos.sdk.mesh-proxy.open', trace.begin({ id: this._instanceId, parentId: this._traceParent }));\n    this._ctx = new Context({ onError: (err) => log.catch(err) });\n\n    invariant(this._serviceProvider.services.NetworkService, 'NetworkService is not available.');\n    const networkStatusStream = this._serviceProvider.services.NetworkService.queryStatus(undefined, {\n      timeout: RPC_TIMEOUT,\n    });\n    networkStatusStream.subscribe((networkStatus: NetworkStatus) => {\n      this._networkStatusUpdated.emit(networkStatus);\n    });\n\n    this._ctx.onDispose(() => networkStatusStream.close());\n    log.trace('dxos.sdk.mesh-proxy.open', trace.end({ id: this._instanceId }));\n  }\n\n  /**\n   * @internal\n   */\n  async _close(): Promise<void> {\n    await this._ctx?.dispose();\n  }\n}\n"],
  "mappings": ";;;;;;AAIA,SAASA,OAAOC,2BAA2B;AAE3C,SAASC,eAAe;AACxB,SAASC,iBAAiB;AAC1B,SAASC,iBAAiB;AAC1B,SAASC,WAAW;AACpB,SAASC,aAAa;AACtB,SAA6BC,uBAAuB;;AAO7C,IAAMC,YAAN,MAAMA;EAWX,YACmBC,kBAIVC,cACP;SALiBD,mBAAAA;SAIVC,eAAAA;SAfQC,wBAAwB,IAAIC,MAAAA;SAC5BC,iBAAiBC,oBAAoBC,KAAK,KAAKJ,uBAAuB;MACrFK,OAAOC,gBAAgBC;MACvBC,WAAW,CAAA;IACb,CAAA;SAIiBC,cAAcC,UAAUC,OAAM,EAAGC,MAAK;EAQpD;EAEHC,SAA2C;AACzC,WAAO;MACLC,eAAe,KAAKZ,eAAea,IAAG;IACxC;EACF;EAEA,IAAID,gBAAgB;AAClB,WAAO,KAAKZ;EACd;EAEA,MAAMc,aAAaX,OAAuC;AACxDY,cAAU,KAAKnB,iBAAiBoB,SAASC,gBAAgB,oCAAA;;;;;;;;;AACzD,WAAO,KAAKrB,iBAAiBoB,SAASC,eAAeH,aAAa;MAAEX;IAAM,GAAG;MAAEe,SAASC;IAAY,CAAA;EACtG;;;;EAKA,MAAMC,QAAuB;AAC3BC,QAAIC,MAAM,4BAA4BA,MAAMC,MAAM;MAAEC,IAAI,KAAKjB;MAAakB,UAAU,KAAK5B;IAAa,CAAA,GAAA;;;;;;AACtG,SAAK6B,OAAO,IAAIC,QAAQ;MAAEC,SAAS,CAACC,QAAQR,IAAIS,MAAMD,KAAAA,QAAAA;;;;;;IAAK,GAAA;;;;AAE3Dd,cAAU,KAAKnB,iBAAiBoB,SAASC,gBAAgB,oCAAA;;;;;;;;;AACzD,UAAMc,sBAAsB,KAAKnC,iBAAiBoB,SAASC,eAAee,YAAYC,QAAW;MAC/Ff,SAASC;IACX,CAAA;AACAY,wBAAoBG,UAAU,CAACtB,kBAAAA;AAC7B,WAAKd,sBAAsBqC,KAAKvB,aAAAA;IAClC,CAAA;AAEA,SAAKc,KAAKU,UAAU,MAAML,oBAAoBM,MAAK,CAAA;AACnDhB,QAAIC,MAAM,4BAA4BA,MAAMgB,IAAI;MAAEd,IAAI,KAAKjB;IAAY,CAAA,GAAA;;;;;;EACzE;;;;EAKA,MAAMgC,SAAwB;AAC5B,UAAM,KAAKb,MAAMc,QAAAA;EACnB;AACF;",
  "names": ["Event", "MulticastObservable", "Context", "invariant", "PublicKey", "log", "trace", "ConnectionState", "MeshProxy", "_serviceProvider", "_traceParent", "_networkStatusUpdated", "Event", "_networkStatus", "MulticastObservable", "from", "swarm", "ConnectionState", "OFFLINE", "signaling", "_instanceId", "PublicKey", "random", "toHex", "toJSON", "networkStatus", "get", "updateConfig", "invariant", "services", "NetworkService", "timeout", "RPC_TIMEOUT", "_open", "log", "trace", "begin", "id", "parentId", "_ctx", "Context", "onError", "err", "catch", "networkStatusStream", "queryStatus", "undefined", "subscribe", "emit", "onDispose", "close", "end", "_close", "dispose"]
}
