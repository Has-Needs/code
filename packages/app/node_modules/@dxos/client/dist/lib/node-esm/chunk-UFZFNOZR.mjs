import { createRequire } from 'node:module';const require = createRequire(import.meta.url);

// packages/sdk/client/src/version.ts
var DXOS_VERSION = "0.8.3";

// packages/sdk/client/src/client/client.ts
import { inspect } from "node:util";
import { Event, MulticastObservable, synchronized, Trigger } from "@dxos/async";
import { DEFAULT_CLIENT_CHANNEL, STATUS_TIMEOUT, clientServiceBundle, PropertiesType } from "@dxos/client-protocol";
import { Config, SaveConfig } from "@dxos/config";
import { Context } from "@dxos/context";
import { raise } from "@dxos/debug";
import { EchoClient, QueueServiceImpl, QueueServiceStub } from "@dxos/echo-db";
import { getTypename } from "@dxos/echo-schema";
import { EdgeHttpClient } from "@dxos/edge-client";
import { invariant } from "@dxos/invariant";
import { PublicKey } from "@dxos/keys";
import { log } from "@dxos/log";
import { ApiError, trace as Trace } from "@dxos/protocols";
import { SystemStatus } from "@dxos/protocols/proto/dxos/client/services";
import { createProtoRpcPeer } from "@dxos/rpc";
import { createIFramePort } from "@dxos/rpc-tunnel";
import { trace } from "@dxos/tracing";

// packages/sdk/client/src/client/client-runtime.ts
var ClientRuntime = class {
  constructor({ spaces, halo, mesh, shell }) {
    this.spaces = spaces;
    this.halo = halo;
    this.mesh = mesh;
    this.shell = shell;
  }
  async open() {
    await this.mesh._open();
    await this.spaces._open();
    await this.halo._open();
  }
  async close() {
    await this.halo._close();
    await this.spaces._close();
    await this.mesh._close();
  }
};

// packages/sdk/client/src/client/client.ts
function _ts_decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/sdk/client/src/client/client.ts";
var Client = class {
  constructor(options = {}) {
    /**
    * Emitted after the client is reset and the services have finished restarting.
    */
    this.reloaded = new Event();
    // TODO(wittjosiah): Make `null` status part of enum.
    this._statusUpdate = new Event();
    this._status = MulticastObservable.from(this._statusUpdate, null);
    this._echoClient = new EchoClient();
    /**
    * Unique id of the Client, local to the current peer.
    */
    this._instanceId = PublicKey.random().toHex();
    /**
    * The version of this client API.
    */
    this.version = DXOS_VERSION;
    this._initialized = false;
    this._resetting = false;
    this._ctx = new Context(void 0, {
      F: __dxlog_file,
      L: 99
    });
    this._edgeClient = void 0;
    this._queuesService = void 0;
    if (typeof window !== "undefined" && typeof window.location !== "undefined" && window.location.protocol !== "https:" && window.location.protocol !== "chrome-extension:" && window.location.protocol !== "socket:" && !window.location.hostname.endsWith("localhost")) {
      log.warn(`DXOS Client will not function in a non-secure context ${window.location.origin}. Either serve with a certificate or use a tunneling service (https://docs.dxos.org/guide/kube/tunneling.html).`, void 0, {
        F: __dxlog_file,
        L: 118,
        S: this,
        C: (f, a) => f(...a)
      });
    }
    this._options = options;
    const filter = options.config?.get("runtime.client.log.filter");
    if (filter) {
      const prefix = options.config?.get("runtime.client.log.prefix");
      log.config({
        filter,
        prefix
      }, void 0, {
        F: __dxlog_file,
        L: 129,
        S: this,
        C: (f, a) => f(...a)
      });
    }
    this._echoClient.graph.schemaRegistry.addSchema([
      PropertiesType
    ]);
    if (options.types) {
      this.addTypes(options.types);
    }
  }
  [inspect.custom]() {
    return this.toString();
  }
  toString() {
    return `Client(${this._instanceId})`;
  }
  toJSON() {
    return {
      initialized: this.initialized,
      spaces: this._runtime?.spaces,
      halo: this._runtime?.halo,
      mesh: this._runtime?.mesh
    };
  }
  /**
  * Current configuration object.
  */
  get config() {
    invariant(this._config, "Client not initialized.", {
      F: __dxlog_file,
      L: 160,
      S: this,
      A: [
        "this._config",
        "'Client not initialized.'"
      ]
    });
    return this._config;
  }
  /**
  * Current client services provider.
  */
  // TODO(burdon): Return services.services. Move to debug endpoint.
  get services() {
    invariant(this._services, "Client not initialized.", {
      F: __dxlog_file,
      L: 169,
      S: this,
      A: [
        "this._services",
        "'Client not initialized.'"
      ]
    });
    return this._services;
  }
  /**
  * Returns true if the client has been initialized. Initialize by calling `.initialize()`.
  */
  get initialized() {
    return this._initialized;
  }
  /**
  * Client services system status.
  */
  get status() {
    return this._status;
  }
  /**
  * ECHO Spaces.
  */
  get spaces() {
    invariant(this._runtime, "Client not initialized.", {
      F: __dxlog_file,
      L: 191,
      S: this,
      A: [
        "this._runtime",
        "'Client not initialized.'"
      ]
    });
    return this._runtime.spaces;
  }
  /**
  * HALO credentials.
  */
  get halo() {
    invariant(this._runtime, "Client not initialized.", {
      F: __dxlog_file,
      L: 199,
      S: this,
      A: [
        "this._runtime",
        "'Client not initialized.'"
      ]
    });
    return this._runtime.halo;
  }
  /**
  * MESH networking.
  */
  get mesh() {
    invariant(this._runtime, "Client not initialized.", {
      F: __dxlog_file,
      L: 207,
      S: this,
      A: [
        "this._runtime",
        "'Client not initialized.'"
      ]
    });
    return this._runtime.mesh;
  }
  /**
  * EDGE client.
  * This API is experimental and subject to change.
  */
  get edge() {
    invariant(this._edgeClient, "Client not initialized.", {
      F: __dxlog_file,
      L: 216,
      S: this,
      A: [
        "this._edgeClient",
        "'Client not initialized.'"
      ]
    });
    return this._edgeClient;
  }
  /**
  * @deprecated Temporary.
  */
  get graph() {
    return this._echoClient.graph;
  }
  /**
  * Shell API.
  */
  get shell() {
    invariant(this._runtime, "Client not initialized.", {
      F: __dxlog_file,
      L: 231,
      S: this,
      A: [
        "this._runtime",
        "'Client not initialized.'"
      ]
    });
    invariant(this._runtime.shell, "Shell not available.", {
      F: __dxlog_file,
      L: 232,
      S: this,
      A: [
        "this._runtime.shell",
        "'Shell not available.'"
      ]
    });
    return this._runtime.shell;
  }
  /**
  * Add schema types to the client.
  */
  // TODO(burdon): Check if already registered (and remove downstream checks).
  addTypes(types) {
    log("addTypes", {
      schema: types.map((type) => getTypename(type))
    }, {
      F: __dxlog_file,
      L: 241,
      S: this,
      C: (f, a) => f(...a)
    });
    const exists = types.filter((type) => !this._echoClient.graph.schemaRegistry.hasSchema(type));
    if (exists.length > 0) {
      this._echoClient.graph.schemaRegistry.addSchema(exists);
    }
    return this;
  }
  /**
  * Get client diagnostics data.
  */
  // TODO(burdon): Return type?
  async diagnostics(options = {}) {
    const { DiagnosticsCollector } = await import("@dxos/client-services");
    invariant(this._services?.services.SystemService, "SystemService is not available.", {
      F: __dxlog_file,
      L: 263,
      S: this,
      A: [
        "this._services?.services.SystemService",
        "'SystemService is not available.'"
      ]
    });
    return DiagnosticsCollector.collect(this._config, this.services, options);
  }
  /**
  * Test and repair database.
  */
  async repair() {
    const { createLevel } = await import("@dxos/client-services");
    const repairSummary = {};
    {
      const spaces = this.spaces.get();
      const docs = spaces.map((space) => space._data.pipeline.currentEpoch?.subject.assertion.automergeRoot.slice("automerge:".length)).filter(Boolean);
      repairSummary.OPFSRemovedFiles = 0;
      if (typeof navigator !== "undefined" && navigator.storage) {
        const dir = await navigator.storage.getDirectory();
        for await (const filename of dir?.keys()) {
          if (filename.includes("automerge_") && !docs.some((doc) => filename.includes(doc))) {
            await dir.removeEntry(filename);
            repairSummary.OPFSRemovedFiles++;
          }
        }
      }
    }
    {
      const config = {
        runtime: {
          client: {
            storage: {
              dataStore: this.config.values.runtime?.client?.storage?.dataStore
            }
          }
        }
      };
      await SaveConfig(config);
      repairSummary.storageConfig = config;
    }
    {
      repairSummary.levelDBRemovedEntries = 0;
      const level = await createLevel(this._config?.values.runtime?.client?.storage ?? {});
      const sublevelsToCleanup = [
        level.sublevel("index-store"),
        level.sublevel("index-metadata").sublevel("clean"),
        level.sublevel("index-metadata").sublevel("dirty")
      ];
      for (const sublevel of sublevelsToCleanup) {
        repairSummary.levelDBRemovedEntries += (await sublevel.keys().all()).length;
        await sublevel.clear();
      }
    }
    {
      await this._services?.services.QueryService?.reindex(void 0, {
        timeout: 3e4
      });
    }
    log.info("Repair succeeded", {
      repairSummary
    }, {
      F: __dxlog_file,
      L: 333,
      S: this,
      C: (f, a) => f(...a)
    });
    return repairSummary;
  }
  /**
  * Initializes internal resources in an idempotent way.
  * Required before using the Client instance.
  */
  async initialize() {
    if (this._initialized) {
      return;
    }
    log.trace("dxos.sdk.client.open", Trace.begin({
      id: this._instanceId
    }), {
      F: __dxlog_file,
      L: 347,
      S: this,
      C: (f, a) => f(...a)
    });
    const { createClientServices, IFrameManager, ShellManager } = await import("./services-JMGZ46ED.mjs");
    this._ctx = new Context(void 0, {
      F: __dxlog_file,
      L: 350
    });
    this._config = this._options.config ?? new Config();
    this._services = await (this._options.services ?? createClientServices(this._config, this._options.createWorker));
    this._iframeManager = this._options.shell ? new IFrameManager({
      source: new URL(this._options.shell, window.location.origin)
    }) : void 0;
    this._shellManager = this._iframeManager ? new ShellManager(this._iframeManager) : void 0;
    await this._open();
    invariant(this._runtime, "Client runtime initialization failed.", {
      F: __dxlog_file,
      L: 359,
      S: this,
      A: [
        "this._runtime",
        "'Client runtime initialization failed.'"
      ]
    });
    if (typeof window !== "undefined") {
      const { mountDevtoolsHooks } = await import("./devtools/index.mjs");
      mountDevtoolsHooks({
        client: this
      });
    }
    this._initialized = true;
    log.trace("dxos.sdk.client.open", Trace.end({
      id: this._instanceId
    }), {
      F: __dxlog_file,
      L: 368,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  async _open() {
    log("opening...", void 0, {
      F: __dxlog_file,
      L: 372,
      S: this,
      C: (f, a) => f(...a)
    });
    invariant(this._services, void 0, {
      F: __dxlog_file,
      L: 373,
      S: this,
      A: [
        "this._services",
        ""
      ]
    });
    const { SpaceList } = await import("./space-list-U3T555EW.mjs");
    const { HaloProxy } = await import("./halo-proxy-WKTHF4OP.mjs");
    const { MeshProxy } = await import("./mesh-proxy-LZTXZMB5.mjs");
    const { Shell } = await import("./services-JMGZ46ED.mjs");
    const trigger = new Trigger();
    this._services.closed?.on(async (error) => {
      log("terminated", {
        resetting: this._resetting
      }, {
        F: __dxlog_file,
        L: 381,
        S: this,
        C: (f, a) => f(...a)
      });
      if (error instanceof ApiError) {
        log.error("fatal", {
          error
        }, {
          F: __dxlog_file,
          L: 383,
          S: this,
          C: (f, a) => f(...a)
        });
        trigger.wake(error);
      }
      if (!this._resetting) {
        await this._close();
        await this._open();
        this.reloaded.emit();
      }
    });
    await this._services.open();
    const edgeUrl = this._config.get("runtime.services.edge.url");
    if (edgeUrl) {
      this._edgeClient = new EdgeHttpClient(edgeUrl);
      this._queuesService = new QueueServiceImpl(this._edgeClient);
    } else {
      this._queuesService = new QueueServiceStub();
    }
    this._echoClient.connectToService({
      dataService: this._services.services.DataService ?? raise(new Error("DataService not available")),
      queryService: this._services.services.QueryService ?? raise(new Error("QueryService not available")),
      queueService: this._queuesService
    });
    await this._echoClient.open(this._ctx);
    const mesh = new MeshProxy(this._services, this._instanceId);
    const halo = new HaloProxy(this._services, this._instanceId);
    const spaces = new SpaceList(this._config, this._services, this._echoClient, halo, this._instanceId);
    const shell = this._shellManager ? new Shell({
      shellManager: this._shellManager,
      identity: halo.identity,
      devices: halo.devices,
      spaces
    }) : void 0;
    this._runtime = new ClientRuntime({
      spaces,
      halo,
      mesh,
      shell
    });
    invariant(this._services.services.SystemService, "SystemService is not available.", {
      F: __dxlog_file,
      L: 423,
      S: this,
      A: [
        "this._services.services.SystemService",
        "'SystemService is not available.'"
      ]
    });
    this._statusStream = this._services.services.SystemService.queryStatus({
      interval: 3e3
    });
    this._statusStream.subscribe(async ({ status }) => {
      this._statusTimeout && clearTimeout(this._statusTimeout);
      trigger.wake(void 0);
      this._statusUpdate.emit(status);
      this._statusTimeout = setTimeout(() => {
        this._statusUpdate.emit(null);
      }, STATUS_TIMEOUT);
    }, (err2) => {
      trigger.wake(err2);
      if (err2) {
        this._statusUpdate.emit(null);
      }
    });
    const err = await trigger.wait();
    if (err) {
      throw err;
    }
    await this._runtime.open();
    await this._iframeManager?.open();
    await this._shellManager?.open();
    if (this._iframeManager?.iframe) {
      const origin = this._iframeManager.source.origin === "null" ? this._iframeManager.source.toString().split("/").slice(0, 3).join("/") : this._iframeManager.source.origin;
      this._shellClientProxy = createProtoRpcPeer({
        exposed: clientServiceBundle,
        handlers: this._services.services,
        port: createIFramePort({
          channel: DEFAULT_CLIENT_CHANNEL,
          iframe: this._iframeManager.iframe,
          origin
        }),
        handlerRpcOptions: {
          timeout: 6e4
        }
      });
      await this._shellClientProxy.open();
    }
    log("opened", void 0, {
      F: __dxlog_file,
      L: 477,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  /**
  * Cleanup, release resources.
  * Open/close is re-entrant.
  */
  async destroy() {
    if (!this._initialized) {
      return;
    }
    await this._close();
    this._statusUpdate.emit(null);
    await this._ctx.dispose();
    this._initialized = false;
  }
  async _close() {
    log("closing...", void 0, {
      F: __dxlog_file,
      L: 499,
      S: this,
      C: (f, a) => f(...a)
    });
    this._statusTimeout && clearTimeout(this._statusTimeout);
    await this._statusStream?.close();
    await this._runtime?.close();
    await this._echoClient.close(this._ctx);
    await this._services?.close();
    this._edgeClient = void 0;
    log("closed", void 0, {
      F: __dxlog_file,
      L: 506,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  /**
  * Reinitialized the client session with the remote service host.
  * This is useful when connecting to a host running behind a resource lock
  * (e.g., HALO when SharedWorker is unavailable).
  */
  async resumeHostServices() {
    invariant(this.services.services.SystemService, "SystemService is not available.", {
      F: __dxlog_file,
      L: 515,
      S: this,
      A: [
        "this.services.services.SystemService",
        "'SystemService is not available.'"
      ]
    });
    await this.services.services.SystemService.updateStatus({
      status: SystemStatus.ACTIVE
    });
  }
  /**
  * Resets and destroys client storage.
  * This will currently leave the client in a closed state.
  * Re-using the client after reset is not currently supported.
  */
  async reset() {
    if (!this._initialized) {
      throw new ApiError("Client not open.");
    }
    log("resetting...", void 0, {
      F: __dxlog_file,
      L: 530,
      S: this,
      C: (f, a) => f(...a)
    });
    this._resetting = true;
    invariant(this._services?.services.SystemService, "SystemService is not available.", {
      F: __dxlog_file,
      L: 532,
      S: this,
      A: [
        "this._services?.services.SystemService",
        "'SystemService is not available.'"
      ]
    });
    await this._services?.services.SystemService.reset();
    await this._close();
    log("reset complete", void 0, {
      F: __dxlog_file,
      L: 540,
      S: this,
      C: (f, a) => f(...a)
    });
  }
};
_ts_decorate([
  trace.info()
], Client.prototype, "_instanceId", void 0);
_ts_decorate([
  trace.info()
], Client.prototype, "version", void 0);
_ts_decorate([
  trace.info()
], Client.prototype, "_services", void 0);
_ts_decorate([
  trace.info()
], Client.prototype, "_initialized", void 0);
_ts_decorate([
  trace.info()
], Client.prototype, "_resetting", void 0);
_ts_decorate([
  trace.info({
    depth: null
  })
], Client.prototype, "toJSON", null);
_ts_decorate([
  synchronized
], Client.prototype, "initialize", null);
_ts_decorate([
  synchronized
], Client.prototype, "destroy", null);
_ts_decorate([
  synchronized
], Client.prototype, "reset", null);
Client = _ts_decorate([
  trace.resource()
], Client);

export {
  DXOS_VERSION,
  Client
};
//# sourceMappingURL=chunk-UFZFNOZR.mjs.map
