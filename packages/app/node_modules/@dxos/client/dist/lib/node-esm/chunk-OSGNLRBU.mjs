import { createRequire } from 'node:module';const require = createRequire(import.meta.url);
import {
  LOCK_KEY
} from "./chunk-CTQW2QQD.mjs";
import {
  RPC_TIMEOUT
} from "./chunk-YV6DEKSE.mjs";

// packages/sdk/client/src/services/agent.ts
import { Event } from "@dxos/async";
import { DX_RUNTIME, ENV_DX_PROFILE, ENV_DX_PROFILE_DEFAULT, clientServiceBundle, getProfilePath } from "@dxos/client-protocol";
import { ClientServicesProviderResource } from "@dxos/client-protocol";
import { log } from "@dxos/log";
import { trace } from "@dxos/tracing";
function _ts_decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/sdk/client/src/services/agent.ts";
var getUnixSocket = (profile, protocol = "unix") => `${protocol}://` + getProfilePath(DX_RUNTIME, profile, "agent.sock");
var fromAgent = ({ profile = process.env[ENV_DX_PROFILE] ?? ENV_DX_PROFILE_DEFAULT } = {}) => {
  return new AgentClientServiceProvider(profile);
};
var AgentClientServiceProvider = class {
  constructor(_profile) {
    this._profile = _profile;
    this.closed = new Event();
  }
  get descriptors() {
    return clientServiceBundle;
  }
  get services() {
    return this._client.rpc;
  }
  async open() {
    const { WebsocketRpcClient } = await import("@dxos/websocket-rpc");
    this._client = new WebsocketRpcClient({
      url: getUnixSocket(this._profile, "ws+unix"),
      requested: clientServiceBundle,
      exposed: {},
      handlers: {}
    });
    this._client.error.on((error) => {
      this.closed.emit(error);
    });
    await this._client.open();
  }
  async close() {
    try {
      await this._client?.close();
    } catch (err) {
      log.warn("Failed to close", err, {
        F: __dxlog_file,
        L: 72,
        S: this,
        C: (f, a) => f(...a)
      });
    }
  }
};
AgentClientServiceProvider = _ts_decorate([
  trace.resource({
    annotation: ClientServicesProviderResource
  })
], AgentClientServiceProvider);

// packages/sdk/client/src/services/client-services-factory.tsx
import { UAParser } from "ua-parser-js";

// packages/sdk/client/src/services/local-client-services.ts
import { Event as Event2, synchronized } from "@dxos/async";
import { clientServiceBundle as clientServiceBundle2, ClientServicesProviderResource as ClientServicesProviderResource2 } from "@dxos/client-protocol";
import { Config } from "@dxos/config";
import { Context } from "@dxos/context";
import { log as log2 } from "@dxos/log";
import { createIceProvider } from "@dxos/network-manager";
import { trace as trace2 } from "@dxos/tracing";
function _ts_decorate2(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file2 = "/home/runner/work/dxos/dxos/packages/sdk/client/src/services/local-client-services.ts";
var fromHost = async (config = new Config(), params, observabilityGroup, signalTelemetryEnabled) => {
  const networking = await setupNetworking(config, {}, () => signalTelemetryEnabled ? {
    ...services.signalMetadataTags,
    ...observabilityGroup ? {
      group: observabilityGroup
    } : {}
  } : {});
  const services = new LocalClientServices({
    config,
    ...networking,
    ...params
  });
  return services;
};
var setupNetworking = async (config, options = {}, signalMetadata) => {
  const { MemorySignalManager, MemorySignalManagerContext, WebsocketSignalManager } = await import("@dxos/messaging");
  const { createRtcTransportFactory, MemoryTransportFactory } = await import("@dxos/network-manager");
  const signals = config.get("runtime.services.signaling");
  const edgeFeatures = config.get("runtime.client.edgeFeatures");
  if (signals || edgeFeatures?.signaling) {
    const { signalManager: signalManager2 = edgeFeatures?.signaling || !signals ? void 0 : new WebsocketSignalManager(signals, signalMetadata), transportFactory: transportFactory2 = createRtcTransportFactory({
      iceServers: config.get("runtime.services.ice")
    }, config.get("runtime.services.iceProviders") && createIceProvider(config.get("runtime.services.iceProviders"))) } = options;
    return {
      signalManager: signalManager2,
      transportFactory: transportFactory2
    };
  }
  log2("P2P network is not configured.", void 0, {
    F: __dxlog_file2,
    L: 80,
    S: void 0,
    C: (f, a) => f(...a)
  });
  const signalManager = new MemorySignalManager(new MemorySignalManagerContext());
  const transportFactory = MemoryTransportFactory;
  return {
    signalManager,
    transportFactory
  };
};
var LocalClientServices = class {
  constructor(params) {
    this.closed = new Event2();
    this._ctx = new Context(void 0, {
      F: __dxlog_file2,
      L: 95
    });
    this.signalMetadataTags = {
      runtime: "local-client-services"
    };
    this._isOpen = false;
    this._params = params;
    if (typeof window === "undefined" || typeof window.location === "undefined") {
      this.signalMetadataTags.origin = "undefined";
    } else {
      if (globalThis.__args) {
        this.signalMetadataTags.runtime = "native";
        this.signalMetadataTags.origin = window.location.origin;
      } else {
        this.signalMetadataTags.origin = window.location.origin;
      }
    }
  }
  get descriptors() {
    return clientServiceBundle2;
  }
  get services() {
    return this._host?.services ?? {};
  }
  get host() {
    return this._host;
  }
  async open() {
    if (this._isOpen) {
      return;
    }
    const { ClientServicesHost } = await import("@dxos/client-services");
    const { setIdentityTags } = await import("@dxos/messaging");
    this._host = new ClientServicesHost({
      ...this._params,
      callbacks: {
        ...this._params.callbacks,
        onReset: async () => {
          this.closed.emit(void 0);
          await this._params.callbacks?.onReset?.();
        }
      }
    });
    await this._host.open(this._ctx);
    this._isOpen = true;
    setIdentityTags({
      identityService: this._host.services.IdentityService,
      devicesService: this._host.services.DevicesService,
      setTag: (k, v) => {
        this.signalMetadataTags[k] = v;
      }
    });
  }
  async close() {
    if (!this._isOpen) {
      return;
    }
    await this._host?.close();
    this._isOpen = false;
  }
};
_ts_decorate2([
  trace2.info()
], LocalClientServices.prototype, "_isOpen", void 0);
_ts_decorate2([
  synchronized
], LocalClientServices.prototype, "open", null);
_ts_decorate2([
  synchronized
], LocalClientServices.prototype, "close", null);
LocalClientServices = _ts_decorate2([
  trace2.resource({
    annotation: ClientServicesProviderResource2
  })
], LocalClientServices);

// packages/sdk/client/src/services/socket.ts
import { Event as Event3 } from "@dxos/async";
import { clientServiceBundle as clientServiceBundle3 } from "@dxos/client-protocol";
import { log as log3 } from "@dxos/log";
import { ApiError } from "@dxos/protocols";
var __dxlog_file3 = "/home/runner/work/dxos/dxos/packages/sdk/client/src/services/socket.ts";
var fromSocket = async (url, authenticationToken) => {
  const closed = new Event3();
  let dxRpcClient;
  return {
    get closed() {
      return closed;
    },
    get descriptors() {
      return clientServiceBundle3;
    },
    get services() {
      return dxRpcClient.rpc;
    },
    open: async () => {
      const { WebsocketRpcClient } = await import("@dxos/websocket-rpc");
      dxRpcClient = new WebsocketRpcClient({
        url,
        authenticationToken,
        requested: clientServiceBundle3,
        exposed: {},
        handlers: {}
      });
      dxRpcClient.error.on(async (error) => {
        log3.warn("websocket rpc client error", {
          error
        }, {
          F: __dxlog_file3,
          L: 42,
          S: void 0,
          C: (f, a) => f(...a)
        });
        if (error.message.includes("401")) {
          log3.warn("websocket authentication failed", void 0, {
            F: __dxlog_file3,
            L: 45,
            S: void 0,
            C: (f, a) => f(...a)
          });
        }
        closed.emit(new ApiError("websocket error"));
      });
      await dxRpcClient.open();
    },
    close: async () => {
      await dxRpcClient.close();
    }
  };
};

// packages/sdk/client/src/services/worker-client-services.ts
import { Event as Event5, Trigger as Trigger2, synchronized as synchronized2 } from "@dxos/async";
import { clientServiceBundle as clientServiceBundle5 } from "@dxos/client-protocol";
import { Config as Config2 } from "@dxos/config";
import { parseFilter, log as log5 } from "@dxos/log";
import { LogLevel } from "@dxos/protocols/proto/dxos/client/services";
import { createWorkerPort } from "@dxos/rpc-tunnel";
import { trace as trace4 } from "@dxos/tracing";

// packages/sdk/client/src/services/service-proxy.ts
import { asyncTimeout, Event as Event4 } from "@dxos/async";
import { clientServiceBundle as clientServiceBundle4, ClientServicesProviderResource as ClientServicesProviderResource3 } from "@dxos/client-protocol";
import { invariant } from "@dxos/invariant";
import { RemoteServiceConnectionTimeout } from "@dxos/protocols";
import { createProtoRpcPeer } from "@dxos/rpc";
import { trace as trace3 } from "@dxos/tracing";
function _ts_decorate3(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file4 = "/home/runner/work/dxos/dxos/packages/sdk/client/src/services/service-proxy.ts";
var ClientServicesProxy = class {
  constructor(_port, _timeout = 3e4) {
    this._port = _port;
    this._timeout = _timeout;
    this.closed = new Event4();
  }
  get proxy() {
    invariant(this._proxy, "Client services not open", {
      F: __dxlog_file4,
      L: 34,
      S: this,
      A: [
        "this._proxy",
        "'Client services not open'"
      ]
    });
    return this._proxy;
  }
  get descriptors() {
    return clientServiceBundle4;
  }
  get services() {
    invariant(this._proxy, "Client services not open", {
      F: __dxlog_file4,
      L: 43,
      S: this,
      A: [
        "this._proxy",
        "'Client services not open'"
      ]
    });
    return this._proxy.rpc;
  }
  async open() {
    if (this._proxy) {
      return;
    }
    this._proxy = createProtoRpcPeer({
      requested: clientServiceBundle4,
      exposed: {},
      handlers: {},
      port: this._port
    });
    await asyncTimeout(this._proxy.open(), this._timeout, new RemoteServiceConnectionTimeout("Failed to establish dxrpc connection", {
      timeout: this._timeout
    }));
  }
  async close() {
    if (!this._proxy) {
      return;
    }
    await this._proxy.close();
    this._proxy = void 0;
  }
};
ClientServicesProxy = _ts_decorate3([
  trace3.resource({
    annotation: ClientServicesProviderResource3
  })
], ClientServicesProxy);

// packages/sdk/client/src/services/shared-worker-connection.ts
import { Trigger } from "@dxos/async";
import { iframeServiceBundle, workerServiceBundle } from "@dxos/client-protocol";
import { log as log4 } from "@dxos/log";
import { createIceProvider as createIceProvider2 } from "@dxos/network-manager";
import { RemoteServiceConnectionError } from "@dxos/protocols";
import { createProtoRpcPeer as createProtoRpcPeer2 } from "@dxos/rpc";
import { getAsyncProviderValue } from "@dxos/util";
var __dxlog_file5 = "/home/runner/work/dxos/dxos/packages/sdk/client/src/services/shared-worker-connection.ts";
var SharedWorkerConnection = class {
  constructor({ config, systemPort }) {
    this._id = String(Math.floor(Math.random() * 1e6));
    this._release = new Trigger();
    this._configProvider = config;
    this._systemPort = systemPort;
  }
  async open(params) {
    const { RtcTransportService } = await import("@dxos/network-manager");
    this._config = await getAsyncProviderValue(this._configProvider);
    this._transportService = new RtcTransportService({
      iceServers: [
        ...this._config.get("runtime.services.ice") ?? []
      ]
    }, this._config.get("runtime.services.iceProviders") && createIceProvider2(this._config.get("runtime.services.iceProviders")));
    this._systemRpc = createProtoRpcPeer2({
      requested: workerServiceBundle,
      exposed: iframeServiceBundle,
      handlers: {
        BridgeService: this._transportService
      },
      port: this._systemPort,
      // TODO(wittjosiah): Make longer and factor out to constant.
      // TODO(wittjosiah): If this is too long then it breaks the reset flows in Composer.
      timeout: 200
    });
    let lockKey;
    if (typeof navigator !== "undefined") {
      lockKey = this._lockKey(params.origin);
      this._release = new Trigger();
      const ready = new Trigger();
      void navigator.locks.request(lockKey, async () => {
        ready.wake();
        await this._release.wait();
      });
      await ready.wait();
    }
    try {
      await this._systemRpc.open();
      await this._systemRpc.rpc.WorkerService.start({
        lockKey,
        ...params
      });
    } catch (err) {
      log4.catch(err, void 0, {
        F: __dxlog_file5,
        L: 81,
        S: this,
        C: (f, a) => f(...a)
      });
      throw new RemoteServiceConnectionError("Failed to connect to worker");
    }
  }
  async close() {
    this._release.wake();
    try {
      await this._systemRpc.rpc.WorkerService.stop();
    } catch {
    }
    await this._systemRpc.close();
  }
  _lockKey(origin) {
    return `${origin}-${this._id}`;
  }
};

// packages/sdk/client/src/services/worker-client-services.ts
function _ts_decorate4(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file6 = "/home/runner/work/dxos/dxos/packages/sdk/client/src/services/worker-client-services.ts";
var fromWorker = async (config = new Config2(), options) => new WorkerClientServices({
  config,
  ...options
});
var WorkerClientServices = class {
  constructor({ config, createWorker, logFilter = "error,warn", observabilityGroup, signalTelemetryEnabled }) {
    this.closed = new Event5();
    this.joinedSpace = new Event5();
    this._isOpen = false;
    this._config = config;
    this._createWorker = createWorker;
    this._logFilter = parseFilter(logFilter);
    this._observabilityGroup = observabilityGroup;
    this._signalTelemetryEnabled = signalTelemetryEnabled ?? false;
  }
  get descriptors() {
    return clientServiceBundle5;
  }
  get services() {
    return this._services.services;
  }
  get runtime() {
    return this._runtime;
  }
  async open() {
    if (this._isOpen) {
      return;
    }
    log5("opening...", void 0, {
      F: __dxlog_file6,
      L: 88,
      S: this,
      C: (f, a) => f(...a)
    });
    const ports = new Trigger2();
    const worker = this._createWorker();
    worker.port.postMessage({
      dxlog: localStorage.getItem("dxlog")
    });
    worker.port.onmessage = (event) => {
      const { command, payload } = event.data;
      if (command === "init") {
        ports.wake(payload);
      }
    };
    const { systemPort, appPort } = await ports.wait();
    this._runtime = new SharedWorkerConnection({
      config: this._config,
      systemPort: createWorkerPort({
        port: systemPort
      })
    });
    await this._runtime.open({
      origin: location.origin,
      observabilityGroup: this._observabilityGroup,
      signalTelemetryEnabled: this._signalTelemetryEnabled
    });
    this._services = new ClientServicesProxy(createWorkerPort({
      port: appPort
    }));
    await this._services.open();
    void navigator.locks.request(LOCK_KEY, () => {
      log5("terminated", void 0, {
        F: __dxlog_file6,
        L: 113,
        S: this,
        C: (f, a) => f(...a)
      });
      if (this._isOpen) {
        this.closed.emit(new Error("Shared worker terminated."));
      }
    });
    this._loggingStream = this._services.services.LoggingService.queryLogs({
      filters: this._logFilter
    }, {
      timeout: RPC_TIMEOUT
    });
    this._loggingStream.subscribe((entry) => {
      switch (entry.level) {
        case LogLevel.DEBUG:
          log5.debug(entry.message, entry.context, mapLogMeta(entry.meta));
          break;
        case LogLevel.VERBOSE:
          log5.verbose(entry.message, entry.context, mapLogMeta(entry.meta));
          break;
        case LogLevel.INFO:
          log5.info(entry.message, entry.context, mapLogMeta(entry.meta));
          break;
        case LogLevel.WARN:
          log5.warn(entry.message, entry.context, mapLogMeta(entry.meta));
          break;
        case LogLevel.ERROR:
          log5.error(entry.message, entry.context, mapLogMeta(entry.meta));
          break;
      }
    });
    log5("opened", void 0, {
      F: __dxlog_file6,
      L: 145,
      S: this,
      C: (f, a) => f(...a)
    });
    this._isOpen = true;
  }
  async close() {
    if (!this._isOpen) {
      return;
    }
    log5("closing...", void 0, {
      F: __dxlog_file6,
      L: 155,
      S: this,
      C: (f, a) => f(...a)
    });
    await this._loggingStream?.close();
    await this._runtime.close();
    await this._services.close();
    log5("closed", void 0, {
      F: __dxlog_file6,
      L: 160,
      S: this,
      C: (f, a) => f(...a)
    });
    this._isOpen = false;
  }
};
_ts_decorate4([
  trace4.info()
], WorkerClientServices.prototype, "_isOpen", void 0);
_ts_decorate4([
  synchronized2
], WorkerClientServices.prototype, "open", null);
_ts_decorate4([
  synchronized2
], WorkerClientServices.prototype, "close", null);
WorkerClientServices = _ts_decorate4([
  trace4.resource()
], WorkerClientServices);
var mapLogMeta = (meta) => {
  return meta && {
    F: meta.file,
    L: meta.line,
    S: {
      ...meta.scope,
      remoteSessionId: meta.scope?.hostSessionId,
      hostSessionId: void 0
    }
  };
};

// packages/sdk/client/src/services/client-services-factory.tsx
var createClientServices = (config, createWorker, observabilityGroup, signalTelemetryEnabled) => {
  const remote = config.values.runtime?.client?.remoteSource;
  if (remote) {
    const url = new URL(remote);
    const protocol = url.protocol.slice(0, -1);
    switch (protocol) {
      case "ws":
      case "wss": {
        return fromSocket(remote, config.values.runtime?.client?.remoteSourceAuthenticationToken);
      }
      case "http":
      case "https": {
        throw new Error("IFrame services deprecated.");
      }
    }
  }
  let useWorker = false;
  if (typeof navigator !== "undefined" && navigator.userAgent) {
    const parser = new UAParser(navigator.userAgent);
    useWorker = typeof SharedWorker !== "undefined" && parser.getOS().name !== "iOS";
  }
  return createWorker && useWorker ? fromWorker(config, {
    createWorker,
    observabilityGroup,
    signalTelemetryEnabled
  }) : fromHost(config, {}, observabilityGroup, signalTelemetryEnabled);
};

// packages/sdk/client/src/services/iframe-manager.ts
import { PublicKey } from "@dxos/keys";
import { createIFrame } from "@dxos/rpc-tunnel";
var IFrameManager = class {
  constructor({ source, onOpen, onMessage }) {
    this._source = source;
    this._onOpen = onOpen;
    this._onMessage = onMessage;
    this._messageHandler = this._messageHandler.bind(this);
  }
  get source() {
    return this._source;
  }
  get iframe() {
    return this._iframe;
  }
  async open() {
    if (this._iframe) {
      return;
    }
    window.addEventListener("message", this._messageHandler);
    const iframeId = `__DXOS_CLIENT_${PublicKey.random().toHex()}__`;
    this._iframe = createIFrame(this._source.toString(), iframeId, {
      allow: "clipboard-read; clipboard-write"
    });
    await this._onOpen?.();
  }
  async close() {
    window.removeEventListener("message", this._messageHandler);
    this._iframe?.remove();
    this._iframe = void 0;
  }
  async _messageHandler(event) {
    void this._onMessage?.(event);
  }
};

// packages/sdk/client/src/services/shell.ts
import { ShellDisplay, ShellLayout } from "@dxos/protocols/proto/dxos/iframe";
import { ComplexSet } from "@dxos/util";
var Shell = class {
  constructor({ shellManager, identity, devices, spaces }) {
    this._shellManager = shellManager;
    this._identity = identity;
    this._devices = devices;
    this._spaces = spaces;
  }
  async setInvitationUrl(request) {
    await this._shellManager.setInvitationUrl(request);
  }
  /**
  * Open the shell with the given layout.
  */
  async open(layout = ShellLayout.IDENTITY, options = {}) {
    await this._shellManager.setLayout({
      layout,
      ...options
    });
  }
  get display() {
    return this._shellManager.display;
  }
  /**
  * Listen for changes to the shell display.
  */
  onDisplayChange(cb) {
    return this._shellManager.contextUpdate.on((data) => {
      if ("display" in data) {
        cb(data.display);
      }
    });
  }
  /**
  * Listen for reset event.
  */
  onReset(cb) {
    return this._shellManager.contextUpdate.on((data) => {
      if ("reset" in data && data.reset) {
        cb(data.target);
      }
    });
  }
  /**
  * Create a new identity.
  * Opens the shell and starts the identity creation flow.
  *
  * @returns Shell result with the new identity.
  */
  async createIdentity() {
    await this._shellManager.setLayout({
      layout: ShellLayout.INITIALIZE_IDENTITY
    });
    return new Promise((resolve) => {
      this._shellManager.contextUpdate.on((context) => {
        if (context.display === ShellDisplay.NONE) {
          resolve({
            cancelled: true
          });
        }
      });
      this._identity.subscribe((identity) => {
        if (identity) {
          resolve({
            identity,
            cancelled: false
          });
        }
      });
    });
  }
  /**
  * Join an existing identity.
  * Opens the shell and starts the device invitation flow based on the given options.
  *
  * @param options.invitationCode If provided, join an existing identity via device invitation.
  *
  * @returns Shell result with the new identity.
  */
  async joinIdentity({ invitationCode } = {}) {
    await this._shellManager.setLayout({
      layout: ShellLayout.INITIALIZE_IDENTITY_FROM_INVITATION,
      invitationCode
    });
    return new Promise((resolve) => {
      this._shellManager.contextUpdate.on((context) => {
        if (context.display === ShellDisplay.NONE) {
          resolve({
            cancelled: true
          });
        }
      });
      this._identity.subscribe((identity) => {
        if (identity) {
          resolve({
            identity,
            cancelled: false
          });
        }
      });
    });
  }
  /**
  * Invite a new device to join the current identity.
  * Opens the shell and presents a device invitation.
  *
  * @returns Shell result with the new device.
  */
  async shareIdentity() {
    if (!this._identity.get()) {
      return {
        error: new Error("Identity does not exist"),
        cancelled: false
      };
    }
    const initialDevices = new ComplexSet((key) => key.toHex(), this._devices.get().map((device) => device.deviceKey));
    await this._shellManager.setLayout({
      layout: ShellLayout.SHARE_IDENTITY
    });
    return new Promise((resolve) => {
      this._shellManager.contextUpdate.on((context) => {
        if (context.display === ShellDisplay.NONE) {
          const device = this._devices.get().find((device2) => !initialDevices.has(device2.deviceKey));
          resolve({
            device,
            cancelled: !device
          });
        }
      });
    });
  }
  /**
  * Initialize a new device with an existing identity using a recovery code.
  *
  * @returns Shell result with the identity.
  */
  async recoverIdentity() {
    await this._shellManager.setLayout({
      layout: ShellLayout.INITIALIZE_IDENTITY_FROM_RECOVERY
    });
    return new Promise((resolve) => {
      this._shellManager.contextUpdate.on((context) => {
        if (context.display === ShellDisplay.NONE) {
          resolve({
            cancelled: true
          });
        }
      });
      this._identity.subscribe((identity) => {
        if (identity) {
          resolve({
            identity,
            cancelled: false
          });
        }
      });
    });
  }
  /**
  * Invite new members to join the current space.
  * Opens the shell to the specified space, showing current members and allowing new members to be invited.
  *
  * @param options.spaceKey The space to share. (Deprecated, use spaceId instead.)
  * @param options.spaceId The space to share.
  * @param options.target The target location to share with new members.
  *
  * @returns Shell result with any new members that join while the shell is open.
  */
  async shareSpace({ spaceKey, spaceId, target }) {
    if (!this._identity.get()) {
      return {
        error: new Error("Identity does not exist"),
        cancelled: false
      };
    }
    const space = this._spaces.get().find((space2) => spaceKey?.equals(space2.key) || space2.id === spaceId);
    if (!space) {
      return {
        error: new Error("Space does not exist"),
        cancelled: false
      };
    }
    const initialMembers = new ComplexSet((key) => key.toHex(), space.members.get().map((member) => member.identity.identityKey));
    await this._shellManager.setLayout({
      layout: ShellLayout.SPACE,
      spaceKey,
      spaceId,
      target
    });
    return new Promise((resolve) => {
      this._shellManager.contextUpdate.on((context) => {
        if (context.display === ShellDisplay.NONE) {
          const members = space.members.get().filter((member) => !initialMembers.has(member.identity.identityKey));
          resolve({
            members,
            cancelled: members.length === 0
          });
        }
      });
    });
  }
  /**
  * Join an existing space.
  * Opens the shell and starts the space join flow based on the given options.
  *
  * @param options.invitationCode If provided, redeem the invitation code to join the space.
  *
  * @returns The joined space.
  * @throws {Error} If no identity exists.
  */
  async joinSpace({ invitationCode } = {}) {
    if (!this._identity.get()) {
      return {
        error: new Error("Identity does not exist"),
        cancelled: false
      };
    }
    await this._shellManager.setLayout({
      layout: ShellLayout.JOIN_SPACE,
      invitationCode
    });
    return new Promise((resolve) => {
      this._shellManager.contextUpdate.on((context) => {
        const space = context.spaceKey && this._spaces.get().find((space2) => context.spaceKey?.equals(space2.key));
        if (space) {
          resolve({
            space,
            target: context.target,
            cancelled: false
          });
        }
        if (context.display === ShellDisplay.NONE) {
          resolve({
            cancelled: true
          });
        }
      });
    });
  }
};

// packages/sdk/client/src/services/shell-manager.ts
import { Event as Event6 } from "@dxos/async";
import { DEFAULT_SHELL_CHANNEL, appServiceBundle, shellServiceBundle } from "@dxos/client-protocol";
import { invariant as invariant2 } from "@dxos/invariant";
import { log as log6 } from "@dxos/log";
import { ShellDisplay as ShellDisplay2 } from "@dxos/protocols/proto/dxos/iframe";
import { createProtoRpcPeer as createProtoRpcPeer3 } from "@dxos/rpc";
import { createIFramePort } from "@dxos/rpc-tunnel";
var __dxlog_file7 = "/home/runner/work/dxos/dxos/packages/sdk/client/src/services/shell-manager.ts";
var shellStyles = Object.entries({
  display: "none",
  position: "fixed",
  top: 0,
  left: 0,
  width: "100vw",
  height: "100vh",
  border: 0,
  "z-index": 60
}).reduce((acc, [key, value]) => `${acc}${key}: ${value};`, "");
var ShellManager = class {
  // prettier-ignore
  constructor(_iframeManager, _channel = DEFAULT_SHELL_CHANNEL) {
    this._iframeManager = _iframeManager;
    this._channel = _channel;
    this.contextUpdate = new Event6();
    this._display = ShellDisplay2.NONE;
  }
  get display() {
    return this._display;
  }
  async setLayout(request) {
    invariant2(this._shellRpc, "ShellManager not open", {
      F: __dxlog_file7,
      L: 57,
      S: this,
      A: [
        "this._shellRpc",
        "'ShellManager not open'"
      ]
    });
    log6("set layout", request, {
      F: __dxlog_file7,
      L: 58,
      S: this,
      C: (f, a) => f(...a)
    });
    this._display = ShellDisplay2.FULLSCREEN;
    this.contextUpdate.emit({
      display: this._display
    });
    await this._shellRpc.rpc.ShellService.setLayout(request, {
      timeout: RPC_TIMEOUT
    });
    this._iframeManager.iframe?.contentDocument?.querySelector('a[href], button:not([disabled]), input:not([disabled]), textarea:not([disabled]), select:not([disabled]), [tabindex]:not([tabindex="-1"])')?.focus();
  }
  async setInvitationUrl(request) {
    log6("set invitation url", request, {
      F: __dxlog_file7,
      L: 71,
      S: this,
      C: (f, a) => f(...a)
    });
    await this._shellRpc?.rpc.ShellService.setInvitationUrl(request, {
      timeout: RPC_TIMEOUT
    });
  }
  async open() {
    if (this._shellRpc) {
      return;
    }
    await this._iframeManager.open();
    const iframe = this._iframeManager.iframe;
    iframe.setAttribute("style", shellStyles);
    iframe.setAttribute("name", "dxos-shell");
    iframe.setAttribute("data-testid", "dxos-shell");
    this.contextUpdate.on(({ display }) => {
      iframe.style.display = display === ShellDisplay2.NONE ? "none" : "";
      if (display === ShellDisplay2.NONE) {
        iframe.blur();
      }
    });
    const origin = this._iframeManager.source.origin === "null" ? this._iframeManager.source.toString().split("/").slice(0, 3).join("/") : this._iframeManager.source.origin;
    const port = createIFramePort({
      origin,
      channel: this._channel,
      iframe: this._iframeManager.iframe
    });
    this._shellRpc = createProtoRpcPeer3({
      requested: shellServiceBundle,
      exposed: appServiceBundle,
      handlers: {
        AppService: {
          setContext: async (request) => {
            log6("set context", request, {
              F: __dxlog_file7,
              L: 112,
              S: this,
              C: (f, a) => f(...a)
            });
            if (request.display) {
              this._display = request.display;
            }
            this.contextUpdate.emit(request);
          }
        }
      },
      port
    });
    await this._shellRpc.open();
  }
  async close() {
    if (!this._shellRpc) {
      return;
    }
    await this._shellRpc?.close();
    this._shellRpc = void 0;
  }
};

// packages/sdk/client/src/services/agent-hosting-provider.ts
import { jwtDecode } from "jwt-decode";
import { synchronized as synchronized3 } from "@dxos/async";
import { invariant as invariant3 } from "@dxos/invariant";
import { PublicKey as PublicKey2 } from "@dxos/keys";
import { log as log7 } from "@dxos/log";
import { schema } from "@dxos/protocols/proto";
import { InitAuthSequenceResponse } from "@dxos/protocols/proto/dxos/service/agentmanager";
function _ts_decorate5(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file8 = "/home/runner/work/dxos/dxos/packages/sdk/client/src/services/agent-hosting-provider.ts";
var ProviderApiError = class extends Error {
};
var defaultConfig = {
  name: "default",
  baseUrl: "http://localhost:8082/v1alpha1/",
  username: "dxos"
};
var COMPOSER_BETA_COOKIE_NAME = "COMPOSER-BETA";
var HUB_SERVICE_ACCESS_CAPABILITY = "agent:beta";
var HUB_SERVICE_ACCESS_MAGIC = "HubServiceAccessCredential";
var AgentManagerClient = class {
  // TODO(nf): just accept Client instead?
  constructor(_clientConfig, _halo) {
    this._clientConfig = _clientConfig;
    this._halo = _halo;
    this.DXRPC_PATH = "dxrpc";
    this._rpcState = "disconnected";
    this._authToken = null;
    const runtimeAgentHostingConfig = this._clientConfig.get("runtime.services.agentHosting");
    invariant3(runtimeAgentHostingConfig, "agentHosting config not found", {
      F: __dxlog_file8,
      L: 75,
      S: this,
      A: [
        "runtimeAgentHostingConfig",
        "'agentHosting config not found'"
      ]
    });
    invariant3(runtimeAgentHostingConfig.server, "agentHosting server not found", {
      F: __dxlog_file8,
      L: 76,
      S: this,
      A: [
        "runtimeAgentHostingConfig.server",
        "'agentHosting server not found'"
      ]
    });
    this._config = {
      ...defaultConfig,
      baseUrl: runtimeAgentHostingConfig.server,
      password: this._clientConfig.get("runtime.app.env.DX_AGENTHOSTING_PASSWORD")
    };
    if (!this._config.baseUrl.endsWith("/")) {
      this._config.baseUrl += "/";
    }
    this._wsDxrpcUrl = new URL(this.DXRPC_PATH, this._config.baseUrl.replace("http", "ws")).href;
  }
  init(authToken) {
    if (!this._checkAuthorization(authToken)) {
      return false;
    }
    return true;
  }
  /**
  * Check auth token/credential from CF worker whether identity is allowed to create agent.
  *
  * Note: This will prevent the client from making unnecessary requests to the AgentHostingProvider API.
  * The AgentHostingProvider will also validate the auth token/credential on its own.
  */
  _checkAuthorization(authToken) {
    const validCookie = this._checkAuthCookie(authToken);
    if (validCookie) {
      log7("beta JWT found", void 0, {
        F: __dxlog_file8,
        L: 111,
        S: this,
        C: (f, a) => f(...a)
      });
      return true;
    }
    const credential = this._getAuthorizationCredential();
    if (credential) {
      log7("beta credential found", {
        credential
      }, {
        F: __dxlog_file8,
        L: 117,
        S: this,
        C: (f, a) => f(...a)
      });
      return true;
    }
    log7("neither JWT nor beta credential found", void 0, {
      F: __dxlog_file8,
      L: 121,
      S: this,
      C: (f, a) => f(...a)
    });
    return false;
  }
  _checkAuthCookie(authToken) {
    const cookies = Object.fromEntries(document.cookie.split("; ").map((v) => v.split(/=(.*)/s).map(decodeURIComponent)));
    if (cookies[COMPOSER_BETA_COOKIE_NAME] == null) {
      return false;
    }
    const composerBetaJwt = this._decodeComposerBetaJwt();
    if (composerBetaJwt && composerBetaJwt.auth_agent) {
      return true;
    }
    return false;
  }
  // TODO(nf): use asymmetric key to verify token?
  _decodeComposerBetaJwt() {
    const decoded = jwtDecode(this._getComposerBetaCookie());
    return decoded;
  }
  _getComposerBetaCookie() {
    const cookies = Object.fromEntries(document.cookie.split("; ").map((v) => v.split(/=(.*)/s).map(decodeURIComponent)));
    if (cookies[COMPOSER_BETA_COOKIE_NAME] == null) {
      return null;
    }
    return cookies[COMPOSER_BETA_COOKIE_NAME];
  }
  _getAuthorizationCredential() {
    return this._halo.queryCredentials().toSorted((a, b) => b.issuanceDate.getTime() - a.issuanceDate.getTime()).find(matchServiceCredential([
      HUB_SERVICE_ACCESS_CAPABILITY
    ]));
  }
  requestInitWithCredentials(req) {
    return {
      ...req,
      headers: {
        ...req.headers,
        Authorization: "Basic " + Buffer.from(`${this._config.username}:${this._config.password}`).toString("base64")
      }
    };
  }
  requestInitWithAuthToken(req) {
    return {
      ...req,
      headers: {
        ...req.headers,
        Authorization: "Bearer " + this._authToken
      }
    };
  }
  async _ensureAuthenticated() {
    if (this._validAuthToken()) {
      return;
    }
    const { deviceKey } = this._halo.device;
    invariant3(deviceKey, "deviceKey not found", {
      F: __dxlog_file8,
      L: 195,
      S: this,
      A: [
        "deviceKey",
        "'deviceKey not found'"
      ]
    });
    const authDeviceCreds = await this._queryCredentials("dxos.halo.credentials.AuthorizedDevice", (cred) => PublicKey2.equals(cred.subject.id, deviceKey));
    invariant3(authDeviceCreds.length === 1, "Improper number of authorized devices", {
      F: __dxlog_file8,
      L: 200,
      S: this,
      A: [
        "authDeviceCreds.length === 1",
        "'Improper number of authorized devices'"
      ]
    });
    const agentBetaCredential = this._getAuthorizationCredential();
    await this._agentManagerAuth(authDeviceCreds[0], agentBetaCredential);
  }
  async _openRpc() {
    if (this._rpcState === "connected") {
      return;
    }
    const { WebsocketRpcClient } = await import("@dxos/websocket-rpc");
    this._rpc = new WebsocketRpcClient({
      url: this._wsDxrpcUrl,
      requested: {
        AgentManager: schema.getService("dxos.service.agentmanager.AgentManager")
      },
      noHandshake: true
    });
    this._rpc.connected.on(() => {
      this._rpcState = "connected";
    });
    this._rpc.disconnected.on(() => {
      this._rpcState = "disconnected";
    });
    this._rpc.error.on((err) => {
      log7.info("rpc error", {
        err
      }, {
        F: __dxlog_file8,
        L: 226,
        S: this,
        C: (f, a) => f(...a)
      });
      this._rpcState = "disconnected";
    });
    try {
      await this._rpc.open();
    } catch (err) {
      log7.warn("failed to open rpc", {
        err
      }, {
        F: __dxlog_file8,
        L: 232,
        S: this,
        C: (f, a) => f(...a)
      });
      throw new Error("Failed to open rpc");
    }
  }
  // Authenticate to the agentmanager service using dxrpc and obtain a JWT token for subsequent HTTP requests.
  async _agentManagerAuth(authDeviceCreds, agentAuthzCredential) {
    await this._openRpc();
    invariant3(this._rpc, "RPC not initialized", {
      F: __dxlog_file8,
      L: 240,
      S: this,
      A: [
        "this._rpc",
        "'RPC not initialized'"
      ]
    });
    const { result, nonce, agentmanagerKey, initAuthResponseReason } = await this._rpc.rpc.AgentManager.initAuthSequence({
      authToken: agentAuthzCredential ? HUB_SERVICE_ACCESS_MAGIC : this._getComposerBetaCookie()
    });
    if (result !== InitAuthSequenceResponse.InitAuthSequenceResult.SUCCESS || !nonce || !agentmanagerKey) {
      log7("auth init failed", {
        result,
        nonce,
        agentmanagerKey,
        initAuthResponseReason
      }, {
        F: __dxlog_file8,
        L: 247,
        S: this,
        C: (f, a) => f(...a)
      });
      throw new Error("Failed to initialize auth sequence");
    }
    const agentmanagerAccessCreds = await this._queryCredentials("dxos.halo.credentials.ServiceAccess", (cred) => PublicKey2.equals(cred.issuer, agentmanagerKey));
    if (!agentmanagerAccessCreds.length) {
      log7.info("no access credentials - requesting...", void 0, {
        F: __dxlog_file8,
        L: 254,
        S: this,
        C: (f, a) => f(...a)
      });
    } else {
      log7.info("access credentials found - requesting session token..", void 0, {
        F: __dxlog_file8,
        L: 256,
        S: this,
        C: (f, a) => f(...a)
      });
    }
    const credsToPresent = [
      authDeviceCreds.id,
      agentmanagerAccessCreds[0]?.id,
      agentAuthzCredential?.id
    ].filter(Boolean);
    const presentation = await this._halo.presentCredentials({
      ids: credsToPresent,
      nonce
    });
    const { token, credential } = await this._rpc.rpc.AgentManager.authenticate({
      presentation
    });
    if (token) {
      this._authToken = token;
      if (!this._validAuthToken()) {
        log7("received invalid authToken", {
          token
        }, {
          F: __dxlog_file8,
          L: 271,
          S: this,
          C: (f, a) => f(...a)
        });
        throw new ProviderApiError("Received invalid authToken");
      }
    } else {
      invariant3(credential, "No credential or token received", {
        F: __dxlog_file8,
        L: 275,
        S: this,
        A: [
          "credential",
          "'No credential or token received'"
        ]
      });
      log7("received credential, writing to HALO", {
        credential
      }, {
        F: __dxlog_file8,
        L: 276,
        S: this,
        C: (f, a) => f(...a)
      });
      await this._halo.writeCredentials([
        credential
      ]);
      await this._agentManagerAuth(authDeviceCreds, agentAuthzCredential);
    }
  }
  _validAuthToken() {
    if (!this._authToken) {
      return null;
    }
    const decoded = jwtDecode(this._authToken);
    if (!decoded.exp) {
      log7.warn("authToken missing expiry", {
        decoded
      }, {
        F: __dxlog_file8,
        L: 289,
        S: this,
        C: (f, a) => f(...a)
      });
      return null;
    }
    if (decoded.exp * 1e3 < Date.now()) {
      log7("authToken expired", {
        decoded
      }, {
        F: __dxlog_file8,
        L: 293,
        S: this,
        C: (f, a) => f(...a)
      });
      return null;
    }
    return decoded;
  }
  async _queryCredentials(type, predicate) {
    const haloCredentials = this._halo.credentials.get();
    return haloCredentials.filter((cred) => {
      if (type && cred.subject.assertion["@type"] !== type) {
        return false;
      }
      if (predicate && !predicate(cred)) {
        return false;
      }
      return true;
    });
  }
  async createAgent(invitationCode, identityKey) {
    await this._ensureAuthenticated();
    const res = await fetch(new URL("agent", this._config.baseUrl), this.requestInitWithAuthToken({
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        invitation: invitationCode,
        identityKey
      })
    }));
    try {
      const agent = await res.json();
      return agent.metadata.uid;
    } catch (err) {
      if (err instanceof TypeError) {
        log7.warn("failed to parse response from agent create", {
          res
        }, {
          F: __dxlog_file8,
          L: 335,
          S: this,
          C: (f, a) => f(...a)
        });
        throw new ProviderApiError("failed to parse response from hosting provider");
      }
      log7.warn("bad response from agent create", {
        res
      }, {
        F: __dxlog_file8,
        L: 338,
        S: this,
        C: (f, a) => f(...a)
      });
      throw new ProviderApiError("bad response from hosting provider");
    }
  }
  async getAgent(agentID) {
    await this._ensureAuthenticated();
    const res = await fetch(new URL("agent/" + agentID, this._config.baseUrl), this.requestInitWithAuthToken({
      method: "GET"
    }));
    switch (res.status) {
      // TODO(nf): other status codes?
      case 200:
        break;
      case 404:
        return null;
      case 401:
        throw new ProviderApiError("unauthorized");
      case 403:
        throw new ProviderApiError("forbidden");
      case 500:
        log7.warn("request to agent get failed", {
          res
        }, {
          F: __dxlog_file8,
          L: 363,
          S: this,
          C: (f, a) => f(...a)
        });
        throw new ProviderApiError("internal server error from hosting provider");
      default:
        log7.warn("request to agent get failed", {
          res
        }, {
          F: __dxlog_file8,
          L: 366,
          S: this,
          C: (f, a) => f(...a)
        });
        throw new ProviderApiError("unknown API error");
    }
    log7.info("getAgent", {
      res
    }, {
      F: __dxlog_file8,
      L: 370,
      S: this,
      C: (f, a) => f(...a)
    });
    try {
      const agent = await res.json();
      return agent.metadata.uid;
    } catch (err) {
      if (err instanceof TypeError) {
        log7.warn("failed to parse response from agent get", {
          err
        }, {
          F: __dxlog_file8,
          L: 377,
          S: this,
          C: (f, a) => f(...a)
        });
        throw new ProviderApiError("failed to parse response from hosting provider");
      }
      log7.warn("bad response from agent get", {
        res
      }, {
        F: __dxlog_file8,
        L: 380,
        S: this,
        C: (f, a) => f(...a)
      });
      throw new ProviderApiError("bad response from hosting provider");
    }
  }
  async destroyAgent(agentID) {
    await this._ensureAuthenticated();
    const res = await fetch(new URL("agent/" + agentID, this._config.baseUrl), this.requestInitWithAuthToken({
      method: "DELETE"
    }));
    switch (res.status) {
      // TODO(nf): other status codes?
      case 204:
        return true;
      case 404:
        log7.warn("requested destroy on non-existent agent", void 0, {
          F: __dxlog_file8,
          L: 399,
          S: this,
          C: (f, a) => f(...a)
        });
        return false;
      case 403:
        throw new ProviderApiError("forbidden");
      case 500:
        log7.warn("request to agent destroy failed", {
          res
        }, {
          F: __dxlog_file8,
          L: 404,
          S: this,
          C: (f, a) => f(...a)
        });
        throw new ProviderApiError("internal server error from hosting provider");
      default:
        log7.warn("request to agent destroy failed", {
          res
        }, {
          F: __dxlog_file8,
          L: 407,
          S: this,
          C: (f, a) => f(...a)
        });
        throw new ProviderApiError("unknown API error");
    }
  }
};
_ts_decorate5([
  synchronized3
], AgentManagerClient.prototype, "_ensureAuthenticated", null);
var matchServiceCredential = (capabilities = []) => (credential) => {
  if (credential.subject.assertion["@type"] !== "dxos.halo.credentials.ServiceAccess") {
    return false;
  }
  const { capabilities: credentialCapabilities } = credential.subject.assertion;
  return capabilities.every((capability) => credentialCapabilities.includes(capability));
};

// packages/sdk/client/src/services/fake-agent-hosting-provider.ts
import { sleep } from "@dxos/async";
var FakeAgentHostingProvider = class {
  constructor(_throw = false) {
    this._throw = _throw;
    this._agents = /* @__PURE__ */ new Map();
  }
  async createAgent(invitationCode, identityKey) {
    await sleep(3e3);
    const agentID = crypto.randomUUID();
    this._agents.set(identityKey, agentID);
    return agentID;
  }
  async getAgent(agentID) {
    await sleep(3e3);
    return this._agents.get(agentID) ?? null;
  }
  async destroyAgent(agentID) {
    await sleep(3e3);
    return this._agents.delete(agentID);
  }
  init(authToken) {
    return true;
  }
};

export {
  getUnixSocket,
  fromAgent,
  AgentClientServiceProvider,
  fromHost,
  LocalClientServices,
  fromSocket,
  ClientServicesProxy,
  SharedWorkerConnection,
  fromWorker,
  WorkerClientServices,
  createClientServices,
  IFrameManager,
  Shell,
  ShellManager,
  AgentManagerClient,
  FakeAgentHostingProvider
};
//# sourceMappingURL=chunk-OSGNLRBU.mjs.map
