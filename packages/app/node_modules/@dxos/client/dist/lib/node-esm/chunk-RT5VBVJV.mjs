import { createRequire } from 'node:module';const require = createRequire(import.meta.url);
import {
  RPC_TIMEOUT
} from "./chunk-YV6DEKSE.mjs";

// packages/sdk/client/src/invitations/index.ts
import { AuthenticatingInvitation as AuthenticatingInvitation2, CancellableInvitation as CancellableInvitation2, InvitationEncoder as InvitationEncoder2 } from "@dxos/client-protocol";
import { Invitation as Invitation2 } from "@dxos/protocols/proto/dxos/client/services";

// packages/sdk/client/src/invitations/invitations-proxy.ts
import { Event, MulticastObservable, PushStream, Trigger } from "@dxos/async";
import { AuthenticatingInvitation, CancellableInvitation, InvitationEncoder } from "@dxos/client-protocol";
import { Context } from "@dxos/context";
import { invariant } from "@dxos/invariant";
import { PublicKey } from "@dxos/keys";
import { log } from "@dxos/log";
import { Invitation, QueryInvitationsResponse } from "@dxos/protocols/proto/dxos/client/services";
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/sdk/client/src/invitations/invitations-proxy.ts";
var createObservable = (rpcStream) => {
  const pushStream = new PushStream();
  rpcStream.subscribe((value) => {
    pushStream.next(value);
  }, (err) => {
    if (err) {
      pushStream.error(err);
    } else {
      pushStream.complete();
    }
  });
  return pushStream.observable;
};
var InvitationsProxy = class {
  constructor(_invitationsService, _identityService, _getInvitationContext) {
    this._invitationsService = _invitationsService;
    this._identityService = _identityService;
    this._getInvitationContext = _getInvitationContext;
    this._createdUpdate = new Event();
    this._acceptedUpdate = new Event();
    this._savedUpdate = new Event();
    this._created = MulticastObservable.from(this._createdUpdate, []);
    this._accepted = MulticastObservable.from(this._acceptedUpdate, []);
    this._saved = MulticastObservable.from(this._savedUpdate, []);
    this._invitations = /* @__PURE__ */ new Set();
    this._invitationsLoaded = new Trigger();
    this._opened = false;
  }
  get created() {
    return this._created;
  }
  get accepted() {
    return this._accepted;
  }
  /**
  * @test-only
  */
  get saved() {
    return this._saved;
  }
  get isOpen() {
    return this._opened;
  }
  async open() {
    if (this._opened) {
      return;
    }
    log("opening...", this._getInvitationContext(), {
      F: __dxlog_file,
      L: 94,
      S: this,
      C: (f, a) => f(...a)
    });
    this._ctx = new Context(void 0, {
      F: __dxlog_file,
      L: 95
    });
    const persistentLoaded = new Trigger();
    const initialCreatedReceived = new Trigger();
    const initialAcceptedReceived = new Trigger();
    const stream = this._invitationsService.queryInvitations(void 0, {
      timeout: RPC_TIMEOUT
    });
    stream.subscribe(({ action, type, invitations, existing }) => {
      switch (action) {
        case QueryInvitationsResponse.Action.ADDED: {
          log("remote invitations added", {
            type,
            invitations
          }, {
            F: __dxlog_file,
            L: 105,
            S: this,
            C: (f, a) => f(...a)
          });
          invitations?.filter((invitation) => this._matchesInvitationContext(invitation)).filter((invitation) => !this._invitations.has(invitation.invitationId)).forEach((invitation) => {
            type === QueryInvitationsResponse.Type.CREATED ? this.share(invitation) : this.join(invitation);
          });
          if (existing) {
            type === QueryInvitationsResponse.Type.CREATED ? initialCreatedReceived.wake() : initialAcceptedReceived.wake();
          }
          break;
        }
        case QueryInvitationsResponse.Action.REMOVED: {
          log("remote invitations removed", {
            type,
            invitations
          }, {
            F: __dxlog_file,
            L: 120,
            S: this,
            C: (f, a) => f(...a)
          });
          const cache = type === QueryInvitationsResponse.Type.CREATED ? this._created : this._accepted;
          const cacheUpdate = type === QueryInvitationsResponse.Type.CREATED ? this._createdUpdate : this._acceptedUpdate;
          invitations?.forEach((removed) => {
            const index = cache.get().findIndex((invitation) => invitation.get().invitationId === removed.invitationId);
            void cache.get()[index]?.cancel();
            index >= 0 && cacheUpdate.emit([
              ...cache.get().slice(0, index),
              ...cache.get().slice(index + 1)
            ]);
          });
          existing && initialAcceptedReceived.wake();
          break;
        }
        case QueryInvitationsResponse.Action.LOAD_COMPLETE: {
          persistentLoaded.wake();
          break;
        }
        case QueryInvitationsResponse.Action.SAVED: {
          log("remote invitations saved", {
            invitations
          }, {
            F: __dxlog_file,
            L: 141,
            S: this,
            C: (f, a) => f(...a)
          });
          this._savedUpdate.emit(invitations ?? []);
          break;
        }
      }
    });
    this._ctx.onDispose(() => stream.close());
    await persistentLoaded.wait();
    await initialAcceptedReceived.wait();
    await initialCreatedReceived.wait();
    this._opened = true;
    log("opened", this._getInvitationContext(), {
      F: __dxlog_file,
      L: 154,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  async close() {
    if (!this._opened) {
      return;
    }
    log("closing...", this._getInvitationContext(), {
      F: __dxlog_file,
      L: 162,
      S: this,
      C: (f, a) => f(...a)
    });
    await this._ctx.dispose();
    this._createdUpdate.emit([]);
    this._acceptedUpdate.emit([]);
    log("closed", this._getInvitationContext(), {
      F: __dxlog_file,
      L: 166,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  getInvitationOptions() {
    return {
      invitationId: PublicKey.random().toHex(),
      type: Invitation.Type.INTERACTIVE,
      authMethod: Invitation.AuthMethod.SHARED_SECRET,
      state: Invitation.State.INIT,
      swarmKey: PublicKey.random(),
      ...this._getInvitationContext()
    };
  }
  // TODO(nf): Some way to retrieve observables for resumed invitations?
  share(options) {
    const invitation = {
      ...this.getInvitationOptions(),
      ...options
    };
    this._invitations.add(invitation.invitationId);
    const existing = this._created.get().find((created) => created.get().invitationId === invitation.invitationId);
    if (existing) {
      return existing;
    }
    const observable = new CancellableInvitation({
      initialInvitation: invitation,
      subscriber: createObservable(this._invitationsService.createInvitation(invitation)),
      onCancel: async () => {
        const invitationId = observable.get().invitationId;
        invariant(invitationId, "Invitation missing identifier", {
          F: __dxlog_file,
          L: 195,
          S: this,
          A: [
            "invitationId",
            "'Invitation missing identifier'"
          ]
        });
        await this._invitationsService.cancelInvitation({
          invitationId
        });
      }
    });
    this._createdUpdate.emit([
      ...this._created.get(),
      observable
    ]);
    return observable;
  }
  join(invitation, deviceProfile) {
    if (typeof invitation === "string") {
      invitation = InvitationEncoder.decode(invitation);
    }
    invariant(invitation && invitation.swarmKey, void 0, {
      F: __dxlog_file,
      L: 208,
      S: this,
      A: [
        "invitation && invitation.swarmKey",
        ""
      ]
    });
    this._invitations.add(invitation.invitationId);
    const id = invitation.invitationId;
    const existing = this._accepted.get().find((accepted) => accepted.get().invitationId === id);
    if (existing) {
      return existing;
    }
    const observable = new AuthenticatingInvitation({
      initialInvitation: invitation,
      subscriber: createObservable(this._invitationsService.acceptInvitation({
        invitation,
        deviceProfile
      })),
      onCancel: async () => {
        const invitationId = observable.get().invitationId;
        invariant(invitationId, "Invitation missing identifier", {
          F: __dxlog_file,
          L: 222,
          S: this,
          A: [
            "invitationId",
            "'Invitation missing identifier'"
          ]
        });
        await this._invitationsService.cancelInvitation({
          invitationId
        });
      },
      onAuthenticate: async (authCode) => {
        const invitationId = observable.get().invitationId;
        invariant(invitationId, "Invitation missing identifier", {
          F: __dxlog_file,
          L: 227,
          S: this,
          A: [
            "invitationId",
            "'Invitation missing identifier'"
          ]
        });
        await this._invitationsService.authenticate({
          invitationId,
          authCode
        });
      }
    });
    this._acceptedUpdate.emit([
      ...this._accepted.get(),
      observable
    ]);
    return observable;
  }
  _matchesInvitationContext(invitation) {
    const context = this._getInvitationContext();
    log("checking invitation context", {
      invitation,
      context
    }, {
      F: __dxlog_file,
      L: 239,
      S: this,
      C: (f, a) => f(...a)
    });
    return Object.entries(context).reduce((acc, [key, value]) => {
      const invitationValue = invitation[key];
      if (invitationValue instanceof PublicKey && value instanceof PublicKey) {
        return acc && invitationValue.equals(value);
      } else {
        return acc && invitationValue === value;
      }
    }, true);
  }
};

export {
  InvitationsProxy,
  AuthenticatingInvitation2 as AuthenticatingInvitation,
  CancellableInvitation2 as CancellableInvitation,
  InvitationEncoder2 as InvitationEncoder,
  Invitation2 as Invitation
};
//# sourceMappingURL=chunk-RT5VBVJV.mjs.map
