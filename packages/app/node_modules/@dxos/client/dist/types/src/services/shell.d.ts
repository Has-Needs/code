import type { MulticastObservable } from '@dxos/async';
import { type PublicKey } from '@dxos/keys';
import { type LayoutRequest, ShellDisplay, ShellLayout } from '@dxos/protocols/proto/dxos/iframe';
import type { ShellManager } from './shell-manager';
import type { Space, SpaceMember } from '../echo';
import type { Device, Identity } from '../halo';
type ShellResult = {
    cancelled: boolean;
    error?: Error;
};
type InitializeIdentityResult = ShellResult & {
    identity?: Identity;
};
type ShareIdentityResult = ShellResult & {
    device?: Device;
};
type ShareSpaceResult = ShellResult & {
    members?: SpaceMember[];
};
type JoinSpaceResult = ShellResult & {
    space?: Space;
    target?: string;
};
type ShellParams = {
    shellManager: ShellManager;
    identity: MulticastObservable<Identity | null>;
    devices: MulticastObservable<Device[]>;
    spaces: MulticastObservable<Space[]>;
};
/**
 * Interface for controlling the shell.
 */
export declare class Shell {
    private readonly _shellManager;
    private readonly _identity;
    private readonly _devices;
    private readonly _spaces;
    constructor({ shellManager, identity, devices, spaces }: ShellParams);
    setInvitationUrl(request: {
        invitationUrl: string;
        deviceInvitationParam: string;
        spaceInvitationParam: string;
    }): Promise<void>;
    /**
     * Open the shell with the given layout.
     */
    open(layout?: ShellLayout, options?: Omit<LayoutRequest, 'layout'>): Promise<void>;
    get display(): ShellDisplay;
    /**
     * Listen for changes to the shell display.
     */
    onDisplayChange(cb: (display: ShellDisplay) => void): import("@dxos/async").CleanupFn;
    /**
     * Listen for reset event.
     */
    onReset(cb: (target?: string) => void): import("@dxos/async").CleanupFn;
    /**
     * Create a new identity.
     * Opens the shell and starts the identity creation flow.
     *
     * @returns Shell result with the new identity.
     */
    createIdentity(): Promise<InitializeIdentityResult>;
    /**
     * Join an existing identity.
     * Opens the shell and starts the device invitation flow based on the given options.
     *
     * @param options.invitationCode If provided, join an existing identity via device invitation.
     *
     * @returns Shell result with the new identity.
     */
    joinIdentity({ invitationCode }?: {
        invitationCode?: string;
    }): Promise<InitializeIdentityResult>;
    /**
     * Invite a new device to join the current identity.
     * Opens the shell and presents a device invitation.
     *
     * @returns Shell result with the new device.
     */
    shareIdentity(): Promise<ShareIdentityResult>;
    /**
     * Initialize a new device with an existing identity using a recovery code.
     *
     * @returns Shell result with the identity.
     */
    recoverIdentity(): Promise<InitializeIdentityResult>;
    /**
     * Invite new members to join the current space.
     * Opens the shell to the specified space, showing current members and allowing new members to be invited.
     *
     * @param options.spaceKey The space to share. (Deprecated, use spaceId instead.)
     * @param options.spaceId The space to share.
     * @param options.target The target location to share with new members.
     *
     * @returns Shell result with any new members that join while the shell is open.
     */
    shareSpace({ spaceKey, spaceId, target, }: {
        spaceKey?: PublicKey;
        spaceId?: string;
        target?: string;
    }): Promise<ShareSpaceResult>;
    /**
     * Join an existing space.
     * Opens the shell and starts the space join flow based on the given options.
     *
     * @param options.invitationCode If provided, redeem the invitation code to join the space.
     *
     * @returns The joined space.
     * @throws {Error} If no identity exists.
     */
    joinSpace({ invitationCode }?: {
        invitationCode?: string;
    }): Promise<JoinSpaceResult>;
}
export {};
//# sourceMappingURL=shell.d.ts.map