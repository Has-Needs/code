{
  "version": 3,
  "sources": ["../../../../src/echo/index.ts", "../../../../src/echo/useMembers.ts", "../../../../src/echo/useSpaces.ts", "../../../../src/echo/useQuery.ts", "../../../../src/echo/useQueue.ts", "../../../../src/echo/useSchema.ts", "../../../../src/echo/useSpaceInvitations.ts", "../../../../src/echo/useSubscription.ts", "../../../../src/echo/useSyncState.ts"],
  "sourcesContent": ["//\n// Copyright 2020 DXOS.org\n//\n\nexport * from '@dxos/client/echo';\n\nexport * from './useMembers';\nexport * from './useQuery';\nexport * from './useQueue';\nexport * from './useSchema';\nexport * from './useSpaces';\nexport * from './useSpaceInvitations';\nexport * from './useSubscription';\nexport * from './useSyncState';\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { MulticastObservable } from '@dxos/async';\nimport { type PublicKey } from '@dxos/client';\nimport { HaloSpaceMember, type SpaceMember } from '@dxos/client/echo';\nimport { useMulticastObservable } from '@dxos/react-hooks';\n\nimport { useSpaces } from './useSpaces';\n\nexport const useMembers = (spaceKey: PublicKey | undefined): SpaceMember[] => {\n  // TODO(dmaretskyi): useSpace hook for spaces that are not ready.\n  const spaces = useSpaces({ all: true });\n  const space = spaceKey ? spaces.find((space) => space.key.equals(spaceKey)) : undefined;\n\n  // EMPTY_OBSERVABLE needs to be a stable reference to avoid re-subscribing on every render.\n  const members = useMulticastObservable(space?.members ?? MulticastObservable.empty()) ?? [];\n  return members.filter((member) => member.role !== HaloSpaceMember.Role.REMOVED);\n};\n", "//\n// Copyright 2020 DXOS.org\n//\n\nimport { useEffect, useState } from 'react';\n\nimport { type PublicKeyLike } from '@dxos/client';\nimport { type Space, SpaceState } from '@dxos/client/echo';\nimport { useMulticastObservable } from '@dxos/react-hooks';\n\nimport { useClient } from '../client';\n\n/**\n * Get a specific Space using its key.\n * The space is not guaranteed to be in the ready state.\n * Returns the default space if no key is provided.\n * Requires a ClientProvider somewhere in the parent tree.\n *\n * @param spaceKeyLike the key of the space to look for\n */\nexport const useSpace = (spaceKeyLike?: PublicKeyLike): Space | undefined => {\n  const client = useClient();\n  const spaces = useMulticastObservable<Space[]>(client.spaces);\n  const [ready, setReady] = useState(false);\n\n  useEffect(() => {\n    // Only wait for ready if looking for the default space.\n    if (spaceKeyLike) {\n      return;\n    }\n\n    const timeout = setTimeout(async () => {\n      await client.spaces.waitUntilReady();\n      setReady(true);\n    });\n\n    return () => clearTimeout(timeout);\n  }, [client, spaceKeyLike]);\n\n  if (spaceKeyLike) {\n    return spaces.find((space) => space.key.equals(spaceKeyLike) || space.id === spaceKeyLike);\n  }\n\n  if (ready && client.halo.identity.get()) {\n    return client.spaces.default;\n  }\n};\n\nexport type UseSpacesParams = {\n  /**\n   * Return uninitialized spaces as well.\n   */\n  all?: boolean;\n};\n\n/**\n * Get all Spaces available to current user.\n * Requires a ClientProvider somewhere in the parent tree.\n * By default, only ready spaces are returned.\n * @returns an array of Spaces\n */\nexport const useSpaces = ({ all = false }: UseSpacesParams = {}): Space[] => {\n  const client = useClient();\n  const spaces = useMulticastObservable<Space[]>(client.spaces);\n\n  // TODO(dmaretskyi): Array reference equality.\n  return spaces.filter((space) => all || space.state.get() === SpaceState.SPACE_READY);\n};\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { useMemo, useSyncExternalStore } from 'react';\n\nimport { type Echo, Filter, type Live, Query, type Space, isSpace } from '@dxos/client/echo';\n\nconst EMPTY_ARRAY: never[] = [];\n\nconst noop = () => {};\n\n// TODO(dmaretskyi): Queries are fully serializable, so we can remove `deps` argument.\ninterface UseQueryFn {\n  <Q extends Query.Any>(spaceOrEcho: Space | Echo | undefined, query: Q, deps?: any[]): Live<Query.Type<Q>>[];\n\n  <F extends Filter.Any>(spaceOrEcho: Space | Echo | undefined, filter: F, deps?: any[]): Live<Filter.Type<F>>[];\n}\n\n/**\n * Create subscription.\n */\nexport const useQuery: UseQueryFn = (\n  spaceOrEcho: Space | Echo | undefined,\n  queryOrFilter: Query.Any | Filter.Any,\n  deps?: any[],\n): Live<unknown>[] => {\n  const query = Filter.is(queryOrFilter) ? Query.select(queryOrFilter) : queryOrFilter;\n\n  const { getObjects, subscribe } = useMemo(() => {\n    let subscribed = false;\n    const queryResult =\n      spaceOrEcho === undefined\n        ? undefined\n        : isSpace(spaceOrEcho)\n          ? spaceOrEcho.db.query(query)\n          : spaceOrEcho.query(query);\n\n    return {\n      getObjects: () => (subscribed && queryResult ? queryResult.objects : EMPTY_ARRAY),\n      subscribe: (cb: () => void) => {\n        subscribed = true;\n        const unsubscribe = queryResult?.subscribe(cb) ?? noop;\n        return () => {\n          unsubscribe?.();\n          subscribed = false;\n        };\n      },\n    };\n  }, [spaceOrEcho, JSON.stringify(query.ast), ...(deps ?? [])]);\n\n  // https://beta.reactjs.org/reference/react/useSyncExternalStore\n  // NOTE: This hook will resubscribe whenever the callback passed to the first argument changes; make sure it is stable.\n  const objects = useSyncExternalStore<Live<unknown>[] | undefined>(subscribe, getObjects);\n  return objects ?? [];\n};\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { useEffect, useMemo, useRef } from 'react';\n\nimport { type Queue } from '@dxos/client/echo';\nimport { raise } from '@dxos/debug';\nimport { type Obj, type Relation } from '@dxos/echo';\nimport { type DXN } from '@dxos/keys';\n\nimport { useClient } from '../client';\n\nconst MIN_POLL_INTERVAL = 1_000;\n\nexport type UseQueueOptions = {\n  pollInterval?: number;\n};\n\n/**\n * Polls the given Edge queue.\n */\n// TODO(burdon): Replace polling with socket?\n// TODO(dmaretskyi): Move into client package.\n// TODO(dmaretskyi): Consider passing the space into the hook to support queue DXNs without space id.\n// TODO(ZaymonFC): If queue is unchanged returned object should be refferentially stable on poll.\nexport const useQueue = <T extends Obj.Any | Relation.Any>(\n  queueDxn?: DXN,\n  options: UseQueueOptions = {},\n): Queue<T> | undefined => {\n  const client = useClient();\n  const mountedRef = useRef(true);\n\n  const queue = useMemo<Queue<T> | undefined>(() => {\n    if (!queueDxn) {\n      return undefined;\n    }\n\n    const { spaceId } = queueDxn.asQueueDXN() ?? raise(new TypeError('Invalid queue DXN'));\n    return client.spaces.get(spaceId)?.queues.get<T>(queueDxn);\n  }, [client, queueDxn?.toString()]);\n\n  useEffect(() => {\n    void queue?.refresh();\n  }, [queue]);\n\n  useEffect(() => {\n    let timeout: NodeJS.Timeout;\n    mountedRef.current = true;\n\n    const poll = () => {\n      if (!mountedRef.current) {\n        return;\n      }\n\n      void queue?.refresh().finally(() => {\n        if (mountedRef.current && options.pollInterval) {\n          timeout = setTimeout(poll, Math.max(options.pollInterval ?? 0, MIN_POLL_INTERVAL));\n        }\n      });\n    };\n\n    if (options.pollInterval) {\n      poll();\n    }\n\n    return () => {\n      mountedRef.current = false;\n      clearTimeout(timeout);\n    };\n  }, [queue, options.pollInterval]);\n\n  return queue;\n};\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { type Schema } from 'effect';\nimport { useMemo, useSyncExternalStore } from 'react';\n\nimport { type Client } from '@dxos/client';\nimport { type Space } from '@dxos/client/echo';\nimport { type BaseSchema } from '@dxos/echo-schema';\n\n/**\n * Subscribe to and retrieve schema changes from a space's schema registry.\n */\nexport const useSchema = (\n  client: Client,\n  space: Space | undefined,\n  typename: string | undefined,\n): Schema.Schema.AnyNoContext | undefined => {\n  const { subscribe, getSchema } = useMemo(() => {\n    if (!typename || !space) {\n      return {\n        subscribe: () => () => {},\n        getSchema: () => undefined,\n      };\n    }\n\n    const staticSchema = client.graph.schemaRegistry.getSchema(typename);\n    if (staticSchema) {\n      return {\n        subscribe: () => () => {},\n        getSchema: () => staticSchema,\n      };\n    }\n\n    const query = space.db.schemaRegistry.query({ typename });\n    const initialResult: BaseSchema = query.runSync()[0];\n    let currentSchema = initialResult;\n\n    return {\n      subscribe: (onStoreChange: () => void) => {\n        const unsubscribe = query.subscribe(() => {\n          currentSchema = query.results[0];\n          onStoreChange();\n        });\n\n        return unsubscribe;\n      },\n      getSchema: () => currentSchema,\n    };\n  }, [typename, space]);\n\n  return useSyncExternalStore(subscribe, getSchema);\n};\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { useMemo } from 'react';\n\nimport { MulticastObservable } from '@dxos/async';\nimport { type PublicKey } from '@dxos/client';\nimport { useMulticastObservable } from '@dxos/react-hooks';\n\nimport { useSpace } from './useSpaces';\nimport { type CancellableInvitationObservable, useInvitationStatus } from '../invitations';\n\nexport const useSpaceInvitations = (spaceKey?: PublicKey): CancellableInvitationObservable[] => {\n  const space = useSpace(spaceKey);\n  return useMulticastObservable(space?.invitations ?? MulticastObservable.empty()) ?? [];\n};\n\nexport const useSpaceInvitation = (spaceKey?: PublicKey, invitationId?: string) => {\n  const invitations = useSpaceInvitations(spaceKey);\n  const invitation = useMemo(\n    () => invitations.find((invitation) => invitation.get().invitationId === invitationId),\n    [invitations],\n  );\n  return useInvitationStatus(invitation);\n};\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { useEffect, useRef } from 'react';\n\nimport { type Selection, type SubscriptionHandle, createSubscription } from '@dxos/client/echo';\n\n/**\n * Create reactive selection.\n * Calls the callback when the selection changes and during the first render.\n */\n// TODO(wittjosiah): Is this still needed with signals reactivity? If not, remove or update jsdoc with usage info.\nexport const useSubscription = (cb: () => void, selection: Selection) => {\n  // Make sure that the callback is always the one from the latest render.\n  // Without this, we would always call the callback from the initial render,\n  // which might contain stale data.\n  const callbackRef = useRef(cb);\n  callbackRef.current = cb;\n\n  const subscriptionRef = useRef<SubscriptionHandle>();\n\n  useEffect(() => {\n    subscriptionRef.current = createSubscription(() => {\n      callbackRef.current();\n    });\n\n    return () => subscriptionRef.current?.unsubscribe();\n  }, []);\n\n  subscriptionRef.current?.update(selection);\n  return subscriptionRef.current;\n};\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { useEffect, useState } from 'react';\n\nimport { type PeerSyncState, type SpaceSyncStateMap, type Space } from '@dxos/client/echo';\nimport { Context } from '@dxos/context';\nimport { type SpaceId } from '@dxos/keys';\nimport { EdgeService } from '@dxos/protocols';\n\nimport { useClient } from '../client';\n\nconst isEdgePeerId = (peerId: string, spaceId: SpaceId) =>\n  peerId.startsWith(`${EdgeService.AUTOMERGE_REPLICATOR}:${spaceId}`);\n\n/**\n * Hook Subscribes to sync state for each space.\n */\nexport const useSyncState = (): SpaceSyncStateMap => {\n  const client = useClient();\n  const [spaceState, setSpaceState] = useState<SpaceSyncStateMap>({});\n\n  useEffect(() => {\n    const ctx = new Context();\n    const createSubscriptions = (spaces: Space[]) => {\n      for (const space of spaces) {\n        if (spaceState[space.id]) {\n          continue;\n        }\n\n        ctx.onDispose(\n          space.crud.subscribeToSyncState(ctx, ({ peers = [] }) => {\n            const syncState = peers.find((state) => isEdgePeerId(state.peerId, space.id));\n            if (syncState) {\n              setSpaceState((spaceState) => ({ ...spaceState, [space.id]: syncState }));\n            }\n          }),\n        );\n      }\n    };\n\n    createSubscriptions(client.spaces.get());\n    client.spaces.subscribe((spaces) => {\n      createSubscriptions(spaces);\n    });\n\n    return () => {\n      void ctx.dispose();\n    };\n  }, [client]);\n\n  return spaceState;\n};\n\n/**\n * Hook Subscribes to sync state for a single space.\n */\n// TODO(wittjosiah): Reconcile w/ useSyncState.\nexport const useSpaceSyncState = (space: Space): PeerSyncState | undefined => {\n  const [spaceState, setSpaceState] = useState<PeerSyncState>();\n\n  useEffect(() => {\n    const ctx = new Context();\n    space.crud.subscribeToSyncState(ctx, ({ peers = [] }) => {\n      const syncState = peers.find((state) => isEdgePeerId(state.peerId, space.id));\n      if (syncState) {\n        setSpaceState(syncState);\n      }\n    });\n\n    return () => {\n      void ctx.dispose();\n    };\n  }, [space]);\n\n  return spaceState;\n};\n"],
  "mappings": "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",
  "names": ["import_echo", "import_react_hooks", "import_react", "import_async", "useSpace", "spaceKeyLike", "client", "useClient", "spaces", "useMulticastObservable", "ready", "setReady", "useState", "useEffect", "timeout", "setTimeout", "waitUntilReady", "clearTimeout", "find", "space", "key", "equals", "id", "halo", "identity", "get", "default", "useSpaces", "all", "filter", "state", "SpaceState", "SPACE_READY", "useMembers", "spaceKey", "undefined", "members", "MulticastObservable", "empty", "member", "role", "HaloSpaceMember", "Role", "REMOVED", "EMPTY_ARRAY", "noop", "useQuery", "spaceOrEcho", "queryOrFilter", "deps", "query", "Filter", "is", "Query", "select", "getObjects", "subscribe", "useMemo", "subscribed", "queryResult", "isSpace", "db", "objects", "cb", "unsubscribe", "JSON", "stringify", "ast", "useSyncExternalStore", "MIN_POLL_INTERVAL", "useQueue", "queueDxn", "options", "mountedRef", "useRef", "queue", "spaceId", "asQueueDXN", "raise", "TypeError", "queues", "toString", "refresh", "current", "poll", "finally", "pollInterval", "Math", "max", "useSchema", "typename", "getSchema", "staticSchema", "graph", "schemaRegistry", "initialResult", "runSync", "currentSchema", "onStoreChange", "results", "useSpaceInvitations", "invitations", "useSpaceInvitation", "invitationId", "invitation", "useInvitationStatus", "useSubscription", "selection", "callbackRef", "subscriptionRef", "createSubscription", "update", "isEdgePeerId", "peerId", "startsWith", "EdgeService", "AUTOMERGE_REPLICATOR", "useSyncState", "spaceState", "setSpaceState", "ctx", "Context", "createSubscriptions", "onDispose", "crud", "subscribeToSyncState", "peers", "syncState", "dispose", "useSpaceSyncState"]
}
