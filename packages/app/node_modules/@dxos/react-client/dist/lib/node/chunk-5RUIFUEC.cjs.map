{
  "version": 3,
  "sources": ["../../../src/client/AgentHostingProvider.tsx", "../../../src/client/ClientProvider.tsx", "../../../src/client/context.ts", "../../../src/banner.ts", "../../../src/client/useClient.ts", "../../../src/client/useClientStatus.ts", "../../../src/client/useConfig.ts", "../../../src/client/useShell.ts", "../../../src/client/useStatus.ts"],
  "sourcesContent": ["//\n// Copyright 2023 DXOS.org\n//\n\nimport React, { createContext, type PropsWithChildren, useContext, useState } from 'react';\n\nimport { type AgentHostingProviderClient, AgentManagerClient, FakeAgentHostingProvider } from '@dxos/client';\nimport { type Halo } from '@dxos/client/halo';\nimport { type Config } from '@dxos/config';\nimport { log } from '@dxos/log';\n\nimport { useClient } from '../client';\n\nexport type AgentHostingProviderProps = { config: Config; halo: Halo };\n\nexport const AgentHostingContext = createContext<AgentHostingProviderClient | null>(null);\n\n/**\n * Experimental agent hosting provider.\n * @param props\n * @constructor\n * @deprecated\n */\nexport const AgentHostingProvider = (props: PropsWithChildren) => {\n  const client = useClient();\n  const [agentHostingProviderClient] = useState(makeClient(client));\n  return (\n    <AgentHostingContext.Provider value={agentHostingProviderClient}> {props.children}</AgentHostingContext.Provider>\n  );\n};\n\nexport const useAgentHostingClient = () => {\n  return useContext(AgentHostingContext);\n};\n\nconst makeClient = ({ config, halo }: AgentHostingProviderProps) => {\n  const agentHostingConfig = config.get('runtime.services.agentHosting');\n  if (!agentHostingConfig) {\n    log('no agent hosting configured');\n    return null;\n  }\n\n  // TODO(nf): Dynamically discover based on runtime config.\n  let agentHostingProviderClient: AgentHostingProviderClient | null = null;\n  switch (agentHostingConfig.type) {\n    case 'LOCAL_TESTING': {\n      log('using FakeAgentHostingProvider');\n      return new FakeAgentHostingProvider();\n    }\n\n    case 'AGENTHOSTING_API': {\n      agentHostingProviderClient = new AgentManagerClient(config, halo);\n      if (agentHostingProviderClient.init()) {\n        return agentHostingProviderClient;\n      } else {\n        // Not authorized or error initializing.\n        return null;\n      }\n    }\n\n    default: {\n      log.error('Unknown agent hosting provider type: ' + agentHostingConfig.type);\n      return null;\n    }\n  }\n};\n", "//\n// Copyright 2020 DXOS.org\n//\n\nimport React, {\n  forwardRef,\n  type FunctionComponent,\n  type PropsWithChildren,\n  useEffect,\n  useImperativeHandle,\n  useState,\n} from 'react';\n\nimport { Client, type ClientOptions, type ClientServicesProvider, SystemStatus } from '@dxos/client';\nimport { type Config } from '@dxos/config';\nimport { registerSignalsRuntime } from '@dxos/echo-signals/react';\nimport { log } from '@dxos/log';\nimport { useControlledState } from '@dxos/react-hooks';\nimport { getAsyncProviderValue, type MaybePromise, type Provider } from '@dxos/util';\n\nimport { ClientContext, type ClientContextProps } from './context';\nimport { printBanner } from '../banner';\n\n/**\n * Properties for the ClientProvider.\n */\nexport type ClientProviderProps = Omit<ClientOptions, 'config' | 'services'> &\n  Pick<ClientContextProps, 'status'> &\n  PropsWithChildren<{\n    /**\n     * Client object or async provider to enable to caller to do custom initialization.\n     *\n     * NOTE: For advanced use cases only.\n     */\n    client?: Client | Provider<Promise<Client>>;\n\n    /**\n     * Config object or async provider.\n     *\n     * NOTE: If a `client` is provided then `config` is ignored.\n     */\n    // TODO(burdon): Reconcile with ClientOptions.\n    config?: Config | Provider<Promise<Config>>;\n\n    /**\n     * Callback to enable the caller to create a custom ClientServicesProvider.\n     *\n     * NOTE: If a `client` is provided then `services` is ignored.\n     */\n    // TODO(burdon): Reconcile with ClientOptions.\n    services?: ClientServicesProvider | ((config?: Config) => MaybePromise<ClientServicesProvider>);\n\n    /**\n     * ReactNode to display until the client is available.\n     */\n    fallback?: FunctionComponent<Partial<ClientContextProps>>;\n\n    /**\n     * Enable (by default) registration of Preact signals runtime for reactive ECHO objects.\n     * @see https://www.npmjs.com/package/@preact/signals-react\n     */\n    signalsRuntime?: boolean;\n\n    /**\n     * Skip the DXOS banner.\n     */\n    noBanner?: boolean;\n\n    /**\n     * Post initialization hook to enable to caller to do custom initialization.\n     */\n    onInitialized?: (client: Client) => MaybePromise<void>;\n  }>;\n\n/**\n * Root component that provides the DXOS client instance to child components.\n * To be used with the `useClient` hook.\n */\nexport const ClientProvider = forwardRef<Client | undefined, ClientProviderProps>(\n  (\n    {\n      children,\n      config: configProvider,\n      client: clientProvider,\n      services: servicesProvider,\n      status: controlledStatus,\n      fallback: Fallback = () => null,\n      signalsRuntime = true,\n      noBanner,\n      onInitialized,\n      ...options\n    },\n    forwardedRef,\n  ) => {\n    useEffect(() => {\n      // TODO(wittjosiah): Ideally this should be imported asynchronously because it is optional.\n      //   Unfortunately, async import seemed to break signals React instrumentation.\n      signalsRuntime && registerSignalsRuntime();\n    }, []);\n\n    // The client is initialized asynchronously.\n    // If an error occurs during initialization, it is caught and the state is set.\n    // This allows the error to be thrown in the render method.\n    // The assumption is that a client initialization error is fatal to the app.\n    // This error will be caught by the nearest error boundary.\n    const [error, setError] = useState();\n    if (error) {\n      throw error;\n    }\n\n    const [client, setClient] = useState(clientProvider instanceof Client ? clientProvider : undefined);\n\n    // Provide external access.\n    useImperativeHandle(forwardedRef, () => client, [client]);\n\n    // Client status subscription.\n    const [status, setStatus] = useControlledState(controlledStatus);\n    useEffect(() => {\n      if (!client) {\n        return;\n      }\n\n      const subscription = client.status.subscribe((status) => setStatus(status));\n      return () => subscription.unsubscribe();\n    }, [client]);\n\n    // Create and/or initialize client.\n    useEffect(() => {\n      let disposed = false;\n      const initialize = async (client: Client) => {\n        if (!client.initialized) {\n          await client.initialize().catch((err) => {\n            if (!disposed) {\n              setError(err);\n            }\n          });\n          log('client ready');\n          await onInitialized?.(client);\n          log('initialization complete');\n        }\n\n        setClient(client);\n\n        if (!noBanner) {\n          printBanner(client);\n        }\n      };\n\n      let client: Client;\n      const t = setTimeout(async () => {\n        try {\n          if (clientProvider) {\n            // Asynchronously request client.\n            client = await getAsyncProviderValue(clientProvider);\n            await initialize(client);\n          } else {\n            // Asynchronously construct client (config may be undefined).\n            const config = await getAsyncProviderValue(configProvider);\n            log('resolved config', { config });\n            const services = await getAsyncProviderValue(servicesProvider, config);\n            log('created services', { services });\n            client = new Client({ config, services, ...options });\n            log('created client');\n            await initialize(client);\n          }\n        } catch (err) {\n          if (!disposed) {\n            log.catch(err);\n          }\n        }\n      });\n\n      return () => {\n        log('clean up');\n        disposed = true;\n        clearTimeout(t);\n        // Only destroy if the client is not provided by the parent.\n        if (!clientProvider) {\n          void client\n            ?.destroy()\n            .then(() => {\n              log('destroyed');\n            })\n            .catch((err) => log.catch(err));\n        }\n      };\n    }, [configProvider, clientProvider, servicesProvider, noBanner]);\n\n    if (!client?.initialized || status !== SystemStatus.ACTIVE) {\n      return <Fallback client={client} status={status} />;\n    }\n\n    return <ClientContext.Provider value={{ client, status }}>{children}</ClientContext.Provider>;\n  },\n);\n", "//\n// Copyright 2020 DXOS.org\n//\n\nimport { type Context, createContext } from 'react';\n\nimport { type Client, type SystemStatus } from '@dxos/client';\n\nexport type ClientContextProps = {\n  client: Client;\n  status?: SystemStatus | null;\n};\n\n/**\n * @internal Use ClientProvider to create or initialize the Client.\n */\nexport const ClientContext: Context<ClientContextProps | undefined> = createContext<ClientContextProps | undefined>(\n  undefined,\n);\n", "//\n// Copyright 2021 DXOS.org\n//\n\nimport { type Client } from '@dxos/client';\n\n// http://patorjk.com/software/taag/#p=testall&f=Patorjk-HeX&t=DXOS\nconst BANNER = (client: Client) => {\n  const commitHash = client.config.get('runtime.app.build.commitHash');\n  const hash = commitHash ? ` App Commit ${commitHash} \\n` : '';\n\n  return (\n    '\\n' +\n    '_/\\\\/\\\\/\\\\/\\\\/\\\\____/\\\\/\\\\____/\\\\/\\\\____/\\\\/\\\\/\\\\/\\\\______/\\\\/\\\\/\\\\/\\\\/\\\\_\\n' +\n    '_/\\\\/\\\\____/\\\\/\\\\____/\\\\/\\\\/\\\\/\\\\____/\\\\/\\\\____/\\\\/\\\\__/\\\\/\\\\_________\\n' +\n    '_/\\\\/\\\\____/\\\\/\\\\______/\\\\/\\\\______/\\\\/\\\\____/\\\\/\\\\____/\\\\/\\\\/\\\\/\\\\___\\n' +\n    '_/\\\\/\\\\____/\\\\/\\\\____/\\\\/\\\\/\\\\/\\\\____/\\\\/\\\\____/\\\\/\\\\__________/\\\\/\\\\_\\n' +\n    '_/\\\\/\\\\/\\\\/\\\\/\\\\____/\\\\/\\\\____/\\\\/\\\\____/\\\\/\\\\/\\\\/\\\\____/\\\\/\\\\/\\\\/\\\\/\\\\___\\n' +\n    `\\n DXOS Client ${client.version} \\n${hash}`\n  );\n};\n\nlet bannerPrinted = false;\n\nexport const printBanner = (client: Client) => {\n  if (bannerPrinted || window.location.hostname === 'localhost') {\n    return;\n  }\n\n  bannerPrinted = true;\n  // eslint-disable-next-line no-console\n  console.log(`%c${BANNER(client)}`, 'font-family: monospace;');\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { useContext } from 'react';\n\nimport { raise } from '@dxos/debug';\n\nimport { ClientContext } from '../client/context';\n\n/**\n * Hook returning instance of DXOS client.\n * Requires ClientContext to be set via ClientProvider.\n */\nexport const useClient = () => {\n  const { client } = useContext(ClientContext) ?? raise(new Error('Missing ClientContext.'));\n  return client;\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { useEffect, useState } from 'react';\n\nimport { type Client, type SystemStatus } from '@dxos/client';\n\nexport const useClientStatus = (client: Client) => {\n  const [status, setStatus] = useState<SystemStatus | null>();\n  useEffect(() => {\n    if (!client) {\n      return;\n    }\n\n    const subscription = client.status.subscribe((status) => setStatus(status));\n    return () => subscription.unsubscribe();\n  }, [client, setStatus]);\n\n  return status;\n};\n", "//\n// Copyright 2020 DXOS.org\n//\n\nimport { useContext } from 'react';\n\nimport { raise } from '@dxos/debug';\n\nimport { ClientContext } from './context';\n\n/**\n * Hook returning config object used to initialize the DXOS client instance.\n * Requires ClientContext to be set via ClientProvider.\n */\nexport const useConfig = () => {\n  const { client } = useContext(ClientContext) ?? raise(new Error('Missing ClientContext.'));\n  return client.config;\n};\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { useEffect, useState } from 'react';\n\nimport { type Shell, type ShellDisplay } from '@dxos/client';\n\nimport { useClient } from './useClient';\n\n/**\n * Helper hook to access the shell.\n */\nexport const useShell = (): Shell => {\n  const client = useClient();\n  return client.shell;\n};\n\n/**\n * Hook to access the shell’s display state.\n */\nexport const useShellDisplay = (): ShellDisplay => {\n  const client = useClient();\n  const [display, setDisplay] = useState(client.shell.display);\n  useEffect(() => client.shell.onDisplayChange(setDisplay), [client]);\n  return display;\n};\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { useContext } from 'react';\n\nimport { type SystemStatus } from '@dxos/client';\nimport { raise } from '@dxos/debug';\n\nimport { ClientContext } from './context';\n\nexport const useStatus = (): SystemStatus | null | undefined => {\n  const { status } = useContext(ClientContext) ?? raise(new Error('Missing ClientContext.'));\n  return status;\n};\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA,mBAAmF;AAEnF,oBAA8F;AAG9F,iBAAoB;ACLpB,IAAAA,gBAOO;AAEP,IAAAC,iBAAsF;AAEtF,IAAAD,gBAAuC;AACvC,IAAAE,cAAoB;AACpB,yBAAmC;AACnC,kBAAwE;ACdxE,IAAAF,gBAA4C;AEA5C,IAAAA,gBAA2B;AAE3B,mBAAsB;ACFtB,IAAAA,gBAAoC;ACApC,IAAAA,gBAA2B;AAE3B,IAAAG,gBAAsB;ACFtB,IAAAH,gBAAoC;ACApC,IAAAA,gBAA2B;AAG3B,IAAAG,gBAAsB;ANSf,IAAMC,oBAAyDC,6BACpEC,MAAAA;ACVF,IAAMC,SAAS,CAACC,WAAAA;AACd,QAAMC,aAAaD,OAAOE,OAAOC,IAAI,8BAAA;AACrC,QAAMC,OAAOH,aAAa,eAAeA,UAAAA;IAAkB;AAE3D,SACE;;;;;;;eAMkBD,OAAOK,OAAO;EAAMD,IAAAA;AAE1C;AAEA,IAAIE,gBAAgB;AAEb,IAAMC,cAAc,CAACP,WAAAA;AAC1B,MAAIM,iBAAiBE,OAAOC,SAASC,aAAa,aAAa;AAC7D;EACF;AAEAJ,kBAAgB;AAEhBK,UAAQC,IAAI,KAAKb,OAAOC,MAAAA,CAAAA,IAAW,yBAAA;AACrC;;AF8CO,IAAMa,iBAAiBC,8CAC5B,CACE,EACEC,UACAb,QAAQc,gBACRhB,QAAQiB,gBACRC,UAAUC,kBACVC,QAAQC,kBACRC,UAAUC,WAAW,MAAM,MAC3BC,iBAAiB,MACjBC,UACAC,eACA,GAAGC,QAAAA,GAELC,iBAAAA;AAEAC,+BAAU,MAAA;AAGRL,0BAAkBM,sCAAAA;EACpB,GAAG,CAAA,CAAE;AAOL,QAAM,CAACC,OAAOC,QAAAA,QAAYC,wBAAAA;AAC1B,MAAIF,OAAO;AACT,UAAMA;EACR;AAEA,QAAM,CAAC/B,QAAQkC,SAAAA,QAAaD,wBAAShB,0BAA0BkB,wBAASlB,iBAAiBnB,MAAAA;AAGzFsC,yCAAoBR,cAAc,MAAM5B,QAAQ;IAACA;GAAO;AAGxD,QAAM,CAACoB,QAAQiB,SAAAA,QAAaC,uCAAmBjB,gBAAAA;AAC/CQ,+BAAU,MAAA;AACR,QAAI,CAAC7B,QAAQ;AACX;IACF;AAEA,UAAMuC,eAAevC,OAAOoB,OAAOoB,UAAU,CAACpB,YAAWiB,UAAUjB,OAAAA,CAAAA;AACnE,WAAO,MAAMmB,aAAaE,YAAW;EACvC,GAAG;IAACzC;GAAO;AAGX6B,+BAAU,MAAA;AACR,QAAIa,WAAW;AACf,UAAMC,aAAa,OAAO3C,YAAAA;AACxB,UAAI,CAACA,QAAO4C,aAAa;AACvB,cAAM5C,QAAO2C,WAAU,EAAGE,MAAM,CAACC,QAAAA;AAC/B,cAAI,CAACJ,UAAU;AACbV,qBAASc,GAAAA;UACX;QACF,CAAA;AACAlC,6BAAI,gBAAA,QAAA;;;;;;AACJ,cAAMc,gBAAgB1B,OAAAA;AACtBY,6BAAI,2BAAA,QAAA;;;;;;MACN;AAEAsB,gBAAUlC,OAAAA;AAEV,UAAI,CAACyB,UAAU;AACblB,oBAAYP,OAAAA;MACd;IACF;AAEA,QAAIA;AACJ,UAAM+C,IAAIC,WAAW,YAAA;AACnB,UAAI;AACF,YAAI/B,gBAAgB;AAElBjB,oBAAS,UAAMiD,mCAAsBhC,cAAAA;AACrC,gBAAM0B,WAAW3C,OAAAA;QACnB,OAAO;AAEL,gBAAME,SAAS,UAAM+C,mCAAsBjC,cAAAA;AAC3CJ,+BAAI,mBAAmB;YAAEV;UAAO,GAAA;;;;;;AAChC,gBAAMgB,WAAW,UAAM+B,mCAAsB9B,kBAAkBjB,MAAAA;AAC/DU,+BAAI,oBAAoB;YAAEM;UAAS,GAAA;;;;;;AACnClB,oBAAS,IAAImC,sBAAO;YAAEjC;YAAQgB;YAAU,GAAGS;UAAQ,CAAA;AACnDf,+BAAI,kBAAA,QAAA;;;;;;AACJ,gBAAM+B,WAAW3C,OAAAA;QACnB;MACF,SAAS8C,KAAK;AACZ,YAAI,CAACJ,UAAU;AACb9B,0BAAIiC,MAAMC,KAAAA,QAAAA;;;;;;QACZ;MACF;IACF,CAAA;AAEA,WAAO,MAAA;AACLlC,2BAAI,YAAA,QAAA;;;;;;AACJ8B,iBAAW;AACXQ,mBAAaH,CAAAA;AAEb,UAAI,CAAC9B,gBAAgB;AACnB,aAAKjB,SACDmD,QAAAA,EACDC,KAAK,MAAA;AACJxC,+BAAI,aAAA,QAAA;;;;;;QACN,CAAA,EACCiC,MAAM,CAACC,QAAQlC,gBAAIiC,MAAMC,KAAAA,QAAAA;;;;;;MAC9B;IACF;EACF,GAAG;IAAC9B;IAAgBC;IAAgBE;IAAkBM;GAAS;AAE/D,MAAI,CAACzB,QAAQ4C,eAAexB,WAAWiC,4BAAaC,QAAQ;AAC1D,WAAO,8BAAAC,QAAA,cAAChC,UAAAA;MAASvB;MAAgBoB;;EACnC;AAEA,SAAO,8BAAAmC,QAAA,cAAC3D,cAAc4D,UAAQ;IAACC,OAAO;MAAEzD;MAAQoB;IAAO;KAAIL,QAAAA;AAC7D,CAAA;AGnLK,IAAM2C,YAAY,MAAA;AACvB,QAAM,EAAE1D,OAAM,QAAK2D,0BAAW/D,aAAAA,SAAkBgE,oBAAM,IAAIC,MAAM,wBAAA,CAAA;AAChE,SAAO7D;AACT;ACTO,IAAM8D,kBAAkB,CAAC9D,WAAAA;AAC9B,QAAM,CAACoB,QAAQiB,SAAAA,QAAaJ,cAAAA,UAAAA;AAC5BJ,oBAAAA,WAAU,MAAA;AACR,QAAI,CAAC7B,QAAQ;AACX;IACF;AAEA,UAAMuC,eAAevC,OAAOoB,OAAOoB,UAAU,CAACpB,YAAWiB,UAAUjB,OAAAA,CAAAA;AACnE,WAAO,MAAMmB,aAAaE,YAAW;EACvC,GAAG;IAACzC;IAAQqC;GAAU;AAEtB,SAAOjB;AACT;ACNO,IAAM2C,YAAY,MAAA;AACvB,QAAM,EAAE/D,OAAM,QAAK2D,cAAAA,YAAW/D,aAAAA,SAAkBgE,cAAAA,OAAM,IAAIC,MAAM,wBAAA,CAAA;AAChE,SAAO7D,OAAOE;AAChB;ACJO,IAAM8D,WAAW,MAAA;AACtB,QAAMhE,SAAS0D,UAAAA;AACf,SAAO1D,OAAOiE;AAChB;AAKO,IAAMC,kBAAkB,MAAA;AAC7B,QAAMlE,SAAS0D,UAAAA;AACf,QAAM,CAACS,SAASC,UAAAA,QAAcnC,cAAAA,UAASjC,OAAOiE,MAAME,OAAO;AAC3DtC,oBAAAA,WAAU,MAAM7B,OAAOiE,MAAMI,gBAAgBD,UAAAA,GAAa;IAACpE;GAAO;AAClE,SAAOmE;AACT;ACfO,IAAMG,YAAY,MAAA;AACvB,QAAM,EAAElD,OAAM,QAAKuC,cAAAA,YAAW/D,aAAAA,SAAkBgE,cAAAA,OAAM,IAAIC,MAAM,wBAAA,CAAA;AAChE,SAAOzC;AACT;;ARCO,IAAMmD,sBAAsB1E,iCAAAA,eAAiD,IAAA;AAQ7E,IAAM2E,uBAAuB,CAACC,UAAAA;AACnC,QAAMzE,SAAS0D,UAAAA;AACf,QAAM,CAACgB,0BAAAA,QAA8BzC,aAAAA,UAAS0C,WAAW3E,MAAAA,CAAAA;AACzD,SACEuD,6BAAAA,QAAA,cAACgB,oBAAoBf,UAAQ;IAACC,OAAOiB;KAA4B,KAAED,MAAM1D,QAAQ;AAErF;AAEO,IAAM6D,wBAAwB,MAAA;AACnC,aAAOjB,aAAAA,YAAWY,mBAAAA;AACpB;AAEA,IAAMI,aAAa,CAAC,EAAEzE,QAAQ2E,KAAI,MAA6B;AAC7D,QAAMC,qBAAqB5E,OAAOC,IAAI,+BAAA;AACtC,MAAI,CAAC2E,oBAAoB;AACvBlE,mBAAAA,KAAI,+BAAA,QAAA;;;;;;AACJ,WAAO;EACT;AAGA,MAAI8D,6BAAgE;AACpE,UAAQI,mBAAmBC,MAAI;IAC7B,KAAK,iBAAiB;AACpBnE,qBAAAA,KAAI,kCAAA,QAAA;;;;;;AACJ,aAAO,IAAIoE,uCAAAA;IACb;IAEA,KAAK,oBAAoB;AACvBN,mCAA6B,IAAIO,iCAAmB/E,QAAQ2E,IAAAA;AAC5D,UAAIH,2BAA2BQ,KAAI,GAAI;AACrC,eAAOR;MACT,OAAO;AAEL,eAAO;MACT;IACF;IAEA,SAAS;AACP9D,iBAAAA,IAAImB,MAAM,0CAA0C+C,mBAAmBC,MAAI,QAAA;;;;;;AAC3E,aAAO;IACT;EACF;AACF;",
  "names": ["import_react", "import_client", "import_log", "import_debug", "ClientContext", "createContext", "undefined", "BANNER", "client", "commitHash", "config", "get", "hash", "version", "bannerPrinted", "printBanner", "window", "location", "hostname", "console", "log", "ClientProvider", "forwardRef", "children", "configProvider", "clientProvider", "services", "servicesProvider", "status", "controlledStatus", "fallback", "Fallback", "signalsRuntime", "noBanner", "onInitialized", "options", "forwardedRef", "useEffect", "registerSignalsRuntime", "error", "setError", "useState", "setClient", "Client", "useImperativeHandle", "setStatus", "useControlledState", "subscription", "subscribe", "unsubscribe", "disposed", "initialize", "initialized", "catch", "err", "t", "setTimeout", "getAsyncProviderValue", "clearTimeout", "destroy", "then", "SystemStatus", "ACTIVE", "React", "Provider", "value", "useClient", "useContext", "raise", "Error", "useClientStatus", "useConfig", "useShell", "shell", "useShellDisplay", "display", "setDisplay", "onDisplayChange", "useStatus", "AgentHostingContext", "AgentHostingProvider", "props", "agentHostingProviderClient", "makeClient", "useAgentHostingClient", "halo", "agentHostingConfig", "type", "FakeAgentHostingProvider", "AgentManagerClient", "init"]
}
