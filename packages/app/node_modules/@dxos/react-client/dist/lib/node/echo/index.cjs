"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var echo_exports = {};
__export(echo_exports, {
  useMembers: () => useMembers,
  useQuery: () => useQuery,
  useQueue: () => useQueue,
  useSchema: () => useSchema,
  useSpace: () => useSpace,
  useSpaceInvitation: () => useSpaceInvitation,
  useSpaceInvitations: () => useSpaceInvitations,
  useSpaceSyncState: () => useSpaceSyncState,
  useSpaces: () => useSpaces,
  useSubscription: () => useSubscription,
  useSyncState: () => useSyncState
});
module.exports = __toCommonJS(echo_exports);
var import_chunk_FYOAVV65 = require("../chunk-FYOAVV65.cjs");
var import_chunk_5RUIFUEC = require("../chunk-5RUIFUEC.cjs");
__reExport(echo_exports, require("@dxos/client/echo"), module.exports);
var import_async = require("@dxos/async");
var import_echo = require("@dxos/client/echo");
var import_react_hooks = require("@dxos/react-hooks");
var import_react = require("react");
var import_echo2 = require("@dxos/client/echo");
var import_react_hooks2 = require("@dxos/react-hooks");
var import_react2 = require("react");
var import_echo3 = require("@dxos/client/echo");
var import_react3 = require("react");
var import_debug = require("@dxos/debug");
var import_react4 = require("react");
var import_react5 = require("react");
var import_async2 = require("@dxos/async");
var import_react_hooks3 = require("@dxos/react-hooks");
var import_react6 = require("react");
var import_echo4 = require("@dxos/client/echo");
var import_react7 = require("react");
var import_context = require("@dxos/context");
var import_protocols = require("@dxos/protocols");
var useSpace = (spaceKeyLike) => {
  const client = (0, import_chunk_5RUIFUEC.useClient)();
  const spaces = (0, import_react_hooks2.useMulticastObservable)(client.spaces);
  const [ready, setReady] = (0, import_react.useState)(false);
  (0, import_react.useEffect)(() => {
    if (spaceKeyLike) {
      return;
    }
    const timeout = setTimeout(async () => {
      await client.spaces.waitUntilReady();
      setReady(true);
    });
    return () => clearTimeout(timeout);
  }, [
    client,
    spaceKeyLike
  ]);
  if (spaceKeyLike) {
    return spaces.find((space) => space.key.equals(spaceKeyLike) || space.id === spaceKeyLike);
  }
  if (ready && client.halo.identity.get()) {
    return client.spaces.default;
  }
};
var useSpaces = ({ all = false } = {}) => {
  const client = (0, import_chunk_5RUIFUEC.useClient)();
  const spaces = (0, import_react_hooks2.useMulticastObservable)(client.spaces);
  return spaces.filter((space) => all || space.state.get() === import_echo2.SpaceState.SPACE_READY);
};
var useMembers = (spaceKey) => {
  const spaces = useSpaces({
    all: true
  });
  const space = spaceKey ? spaces.find((space2) => space2.key.equals(spaceKey)) : void 0;
  const members = (0, import_react_hooks.useMulticastObservable)(space?.members ?? import_async.MulticastObservable.empty()) ?? [];
  return members.filter((member) => member.role !== import_echo.HaloSpaceMember.Role.REMOVED);
};
var EMPTY_ARRAY = [];
var noop = () => {
};
var useQuery = (spaceOrEcho, queryOrFilter, deps) => {
  const query = import_echo3.Filter.is(queryOrFilter) ? import_echo3.Query.select(queryOrFilter) : queryOrFilter;
  const { getObjects, subscribe } = (0, import_react2.useMemo)(() => {
    let subscribed = false;
    const queryResult = spaceOrEcho === void 0 ? void 0 : (0, import_echo3.isSpace)(spaceOrEcho) ? spaceOrEcho.db.query(query) : spaceOrEcho.query(query);
    return {
      getObjects: () => subscribed && queryResult ? queryResult.objects : EMPTY_ARRAY,
      subscribe: (cb) => {
        subscribed = true;
        const unsubscribe = queryResult?.subscribe(cb) ?? noop;
        return () => {
          unsubscribe?.();
          subscribed = false;
        };
      }
    };
  }, [
    spaceOrEcho,
    JSON.stringify(query.ast),
    ...deps ?? []
  ]);
  const objects = (0, import_react2.useSyncExternalStore)(subscribe, getObjects);
  return objects ?? [];
};
var MIN_POLL_INTERVAL = 1e3;
var useQueue = (queueDxn, options = {}) => {
  const client = (0, import_chunk_5RUIFUEC.useClient)();
  const mountedRef = (0, import_react3.useRef)(true);
  const queue = (0, import_react3.useMemo)(() => {
    if (!queueDxn) {
      return void 0;
    }
    const { spaceId } = queueDxn.asQueueDXN() ?? (0, import_debug.raise)(new TypeError("Invalid queue DXN"));
    return client.spaces.get(spaceId)?.queues.get(queueDxn);
  }, [
    client,
    queueDxn?.toString()
  ]);
  (0, import_react3.useEffect)(() => {
    void queue?.refresh();
  }, [
    queue
  ]);
  (0, import_react3.useEffect)(() => {
    let timeout;
    mountedRef.current = true;
    const poll = () => {
      if (!mountedRef.current) {
        return;
      }
      void queue?.refresh().finally(() => {
        if (mountedRef.current && options.pollInterval) {
          timeout = setTimeout(poll, Math.max(options.pollInterval ?? 0, MIN_POLL_INTERVAL));
        }
      });
    };
    if (options.pollInterval) {
      poll();
    }
    return () => {
      mountedRef.current = false;
      clearTimeout(timeout);
    };
  }, [
    queue,
    options.pollInterval
  ]);
  return queue;
};
var useSchema = (client, space, typename) => {
  const { subscribe, getSchema } = (0, import_react4.useMemo)(() => {
    if (!typename || !space) {
      return {
        subscribe: () => () => {
        },
        getSchema: () => void 0
      };
    }
    const staticSchema = client.graph.schemaRegistry.getSchema(typename);
    if (staticSchema) {
      return {
        subscribe: () => () => {
        },
        getSchema: () => staticSchema
      };
    }
    const query = space.db.schemaRegistry.query({
      typename
    });
    const initialResult = query.runSync()[0];
    let currentSchema = initialResult;
    return {
      subscribe: (onStoreChange) => {
        const unsubscribe = query.subscribe(() => {
          currentSchema = query.results[0];
          onStoreChange();
        });
        return unsubscribe;
      },
      getSchema: () => currentSchema
    };
  }, [
    typename,
    space
  ]);
  return (0, import_react4.useSyncExternalStore)(subscribe, getSchema);
};
var useSpaceInvitations = (spaceKey) => {
  const space = useSpace(spaceKey);
  return (0, import_react_hooks3.useMulticastObservable)(space?.invitations ?? import_async2.MulticastObservable.empty()) ?? [];
};
var useSpaceInvitation = (spaceKey, invitationId) => {
  const invitations = useSpaceInvitations(spaceKey);
  const invitation = (0, import_react5.useMemo)(() => invitations.find((invitation2) => invitation2.get().invitationId === invitationId), [
    invitations
  ]);
  return (0, import_chunk_FYOAVV65.useInvitationStatus)(invitation);
};
var useSubscription = (cb, selection) => {
  const callbackRef = (0, import_react6.useRef)(cb);
  callbackRef.current = cb;
  const subscriptionRef = (0, import_react6.useRef)();
  (0, import_react6.useEffect)(() => {
    subscriptionRef.current = (0, import_echo4.createSubscription)(() => {
      callbackRef.current();
    });
    return () => subscriptionRef.current?.unsubscribe();
  }, []);
  subscriptionRef.current?.update(selection);
  return subscriptionRef.current;
};
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/sdk/react-client/src/echo/useSyncState.ts";
var isEdgePeerId = (peerId, spaceId) => peerId.startsWith(`${import_protocols.EdgeService.AUTOMERGE_REPLICATOR}:${spaceId}`);
var useSyncState = () => {
  const client = (0, import_chunk_5RUIFUEC.useClient)();
  const [spaceState, setSpaceState] = (0, import_react7.useState)({});
  (0, import_react7.useEffect)(() => {
    const ctx = new import_context.Context(void 0, {
      F: __dxlog_file,
      L: 25
    });
    const createSubscriptions = (spaces) => {
      for (const space of spaces) {
        if (spaceState[space.id]) {
          continue;
        }
        ctx.onDispose(space.crud.subscribeToSyncState(ctx, ({ peers = [] }) => {
          const syncState = peers.find((state) => isEdgePeerId(state.peerId, space.id));
          if (syncState) {
            setSpaceState((spaceState2) => ({
              ...spaceState2,
              [space.id]: syncState
            }));
          }
        }));
      }
    };
    createSubscriptions(client.spaces.get());
    client.spaces.subscribe((spaces) => {
      createSubscriptions(spaces);
    });
    return () => {
      void ctx.dispose();
    };
  }, [
    client
  ]);
  return spaceState;
};
var useSpaceSyncState = (space) => {
  const [spaceState, setSpaceState] = (0, import_react7.useState)();
  (0, import_react7.useEffect)(() => {
    const ctx = new import_context.Context(void 0, {
      F: __dxlog_file,
      L: 64
    });
    space.crud.subscribeToSyncState(ctx, ({ peers = [] }) => {
      const syncState = peers.find((state) => isEdgePeerId(state.peerId, space.id));
      if (syncState) {
        setSpaceState(syncState);
      }
    });
    return () => {
      void ctx.dispose();
    };
  }, [
    space
  ]);
  return spaceState;
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  useMembers,
  useQuery,
  useQueue,
  useSchema,
  useSpace,
  useSpaceInvitation,
  useSpaceInvitations,
  useSpaceSyncState,
  useSpaces,
  useSubscription,
  useSyncState,
  ...require("@dxos/client/echo")
});
//# sourceMappingURL=index.cjs.map
