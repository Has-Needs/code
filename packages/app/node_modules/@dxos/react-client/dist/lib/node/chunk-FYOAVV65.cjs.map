{
  "version": 3,
  "sources": ["../../../src/invitations/index.ts", "../../../src/invitations/useInvitationStatus.ts"],
  "sourcesContent": ["//\n// Copyright 2020 DXOS.org\n//\n\n// NOTE: Export * fails here.\nexport {\n  AuthenticatingInvitationObservable,\n  CancellableInvitationObservable,\n  InvitationEncoder,\n  Invitation,\n  type Invitations,\n  InvitationsProxy,\n} from '@dxos/client/invitations';\n\nexport * from './useInvitationStatus';\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { useReducer, type Reducer, useMemo, useCallback, useEffect } from 'react';\n\nimport { type PublicKey } from '@dxos/client';\nimport {\n  type AuthenticatingInvitationObservable,\n  type CancellableInvitationObservable,\n  Invitation,\n  InvitationEncoder,\n} from '@dxos/client/invitations';\nimport { log } from '@dxos/log';\n\nexport type InvitationResult = {\n  spaceKey: PublicKey | null;\n  identityKey: PublicKey | null;\n  swarmKey: PublicKey | null;\n  target: string | null;\n};\n\ninterface InvitationReducerState {\n  status: Invitation.State; // TODO(burdon): Rename state.\n  haltedAt?: Invitation.State;\n  result: InvitationResult;\n  error?: number;\n  id?: string;\n  multiUse?: boolean;\n  invitationCode?: string;\n  authCode?: string;\n  authMethod?: Invitation.AuthMethod;\n  type?: Invitation.Type;\n}\n\ntype InvitationPayload = { invitation: Invitation };\n\nexport type InvitationAction =\n  | ({\n      status:\n        | Invitation.State.INIT\n        | Invitation.State.CONNECTED\n        | Invitation.State.READY_FOR_AUTHENTICATION\n        | Invitation.State.AUTHENTICATING;\n    } & InvitationPayload)\n  | ({\n      status: Invitation.State.CONNECTING;\n      observable: CancellableInvitationObservable;\n    } & InvitationPayload)\n  | ({\n      status: Invitation.State.SUCCESS;\n      result: InvitationResult;\n    } & InvitationPayload)\n  | ({\n      status: Invitation.State.CANCELLED | Invitation.State.TIMEOUT;\n      haltedAt: Invitation.State;\n    } & InvitationPayload)\n  | {\n      status: Invitation.State.ERROR;\n      error?: Error;\n      haltedAt: Invitation.State;\n    };\n\nexport type InvitationStatus = {\n  id?: string;\n  invitationCode?: string;\n  authCode?: string;\n  authMethod?: Invitation.AuthMethod;\n  type?: Invitation.Type;\n  status: Invitation.State;\n  haltedAt?: Invitation.State;\n  multiUse?: boolean;\n  shareable?: boolean;\n  result: InvitationResult;\n  error?: number;\n  cancel(): void;\n  // TODO(wittjosiah): Remove?\n  connect(observable: CancellableInvitationObservable): void;\n  authenticate(authCode: string): Promise<void>;\n};\n\n// Without private key, the invitation code cannot be created.\n// These invitations are only available to be accepted but not shared.\nconst isShareableInvitation = (invitation: Invitation) =>\n  invitation.authMethod !== Invitation.AuthMethod.KNOWN_PUBLIC_KEY || invitation.guestKeypair?.privateKey;\n\nexport const useInvitationStatus = (observable?: CancellableInvitationObservable): InvitationStatus => {\n  const [state, dispatch] = useReducer<Reducer<InvitationReducerState, InvitationAction>, null>(\n    (prev, action) => {\n      log('useInvitationStatus', { action });\n      const invitationProps =\n        'invitation' in action\n          ? {\n              id: action.invitation.invitationId,\n              multiUse: action.invitation.multiUse,\n              invitationCode: InvitationEncoder.encode(action.invitation),\n              authCode: action.invitation.authCode,\n              authMethod: action.invitation.authMethod,\n              shareable: isShareableInvitation(action.invitation),\n              type: action.invitation.type,\n            }\n          : {};\n      return {\n        ...prev,\n        ...invitationProps,\n        // TODO(burdon): State.\n        status: action.status,\n        // `invitationObservable`, `secret`, and `result` is persisted between the status-actions that set them.\n        result: action.status === Invitation.State.SUCCESS ? action.result : prev.result,\n        // `error` gets set each time we enter the error state\n        ...(action.status === Invitation.State.ERROR && { error: action.error }),\n        // `haltedAt` gets set on only the first error/cancelled/timeout action and reset on any others.\n        ...((action.status === Invitation.State.ERROR ||\n          action.status === Invitation.State.CANCELLED ||\n          action.status === Invitation.State.TIMEOUT) && {\n          haltedAt: typeof prev.haltedAt === 'undefined' ? action.haltedAt : prev.haltedAt,\n        }),\n      } as InvitationReducerState;\n    },\n    null,\n    (_arg: null) => {\n      const invitation = observable?.get();\n      return {\n        status: Invitation.State.INIT,\n        result: { spaceKey: null, identityKey: null, swarmKey: null, target: null },\n        id: invitation?.invitationId,\n        multiUse: invitation?.multiUse,\n        invitationCode: invitation ? InvitationEncoder.encode(invitation) : undefined,\n        authCode: invitation?.authCode,\n        authMethod: invitation?.authMethod,\n        shareable: invitation ? isShareableInvitation(invitation) : false,\n        type: invitation?.type,\n      };\n    },\n  );\n\n  // Handle unmount.\n\n  useEffect(() => {\n    const update = (invitation: Invitation) => {\n      switch (invitation.state) {\n        case Invitation.State.INIT:\n        case Invitation.State.CONNECTED:\n        case Invitation.State.READY_FOR_AUTHENTICATION:\n        case Invitation.State.AUTHENTICATING: {\n          dispatch({\n            invitation,\n            status: invitation.state,\n          });\n          break;\n        }\n\n        case Invitation.State.SUCCESS: {\n          dispatch({\n            invitation,\n            status: invitation.state,\n            result: {\n              spaceKey: invitation.spaceKey || null,\n              identityKey: invitation.identityKey || null,\n              swarmKey: invitation.swarmKey || null,\n              target: invitation.target || null,\n            },\n          });\n          break;\n        }\n\n        case Invitation.State.CANCELLED:\n        case Invitation.State.TIMEOUT: {\n          dispatch({ invitation, status: invitation.state, haltedAt: state.status });\n          break;\n        }\n      }\n    };\n\n    const subscription = observable?.subscribe(update, (err: Error) => {\n      dispatch({ status: Invitation.State.ERROR, error: err, haltedAt: state.status });\n    });\n\n    const currentState = observable?.get();\n    if (currentState) {\n      update(currentState);\n    }\n\n    return () => subscription?.unsubscribe();\n  }, [observable, state.status]);\n\n  // Return memoized callbacks & values.\n\n  const connect = useCallback((observable: CancellableInvitationObservable) => {\n    dispatch({ invitation: observable.get(), status: Invitation.State.CONNECTING, observable });\n  }, []);\n\n  const authenticate = useCallback(\n    (authCode: string) => {\n      log('authenticating...', { authCode });\n      return (observable as AuthenticatingInvitationObservable).authenticate(authCode);\n    },\n    [observable],\n  );\n\n  const cancel = useCallback(async () => observable?.cancel(), [observable]);\n\n  return useMemo(() => {\n    return {\n      ...state,\n      cancel,\n      connect,\n      authenticate,\n    };\n  }, [state, cancel, connect, authenticate]);\n};\n"],
  "mappings": "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",
  "names": ["import_invitations", "isShareableInvitation", "invitation", "authMethod", "Invitation", "AuthMethod", "KNOWN_PUBLIC_KEY", "guestKeypair", "privateKey", "useInvitationStatus", "observable", "state", "dispatch", "useReducer", "prev", "action", "log", "invitationProps", "id", "invitationId", "multiUse", "invitationCode", "InvitationEncoder", "encode", "authCode", "shareable", "type", "status", "result", "State", "SUCCESS", "ERROR", "error", "CANCELLED", "TIMEOUT", "haltedAt", "_arg", "get", "INIT", "spaceKey", "identityKey", "swarmKey", "target", "undefined", "useEffect", "update", "CONNECTED", "READY_FOR_AUTHENTICATION", "AUTHENTICATING", "subscription", "subscribe", "err", "currentState", "unsubscribe", "connect", "useCallback", "CONNECTING", "authenticate", "cancel", "useMemo"]
}
