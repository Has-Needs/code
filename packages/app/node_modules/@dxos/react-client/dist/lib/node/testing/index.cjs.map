{
  "version": 3,
  "sources": ["../../../../src/testing/index.ts", "../../../../src/testing/context.tsx", "../../../../src/testing/ClientRepeater.tsx", "../../../../src/testing/withClientProvider.tsx"],
  "sourcesContent": ["//\n// Copyright 2020 DXOS.org\n//\n\nexport * from '@dxos/client/testing';\n\nexport * from './context';\nexport * from './ClientRepeater';\nexport * from './withClientProvider';\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { createContext, useContext } from 'react';\n\nimport { type Space } from '@dxos/client/echo';\nimport { raise } from '@dxos/debug';\n\nexport type ClientStory = {\n  space?: Space;\n};\n\n// TODO(wittjosiah): Add to multi-client as well.\nexport const ClientStory = createContext<ClientStory | undefined>(undefined);\n\nexport const useClientProvider = (): ClientStory => {\n  return useContext(ClientStory) ?? raise(new Error('Missing ClientStory'));\n};\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport React, { useState, type FC, useEffect, useRef } from 'react';\n\nimport { Client, type PublicKey } from '@dxos/client';\nimport { TestBuilder, performInvitation } from '@dxos/client/testing';\nimport { type TypedObject } from '@dxos/echo-schema';\nimport { registerSignalsRuntime } from '@dxos/echo-signals/react';\nimport { faker } from '@dxos/random';\n\nimport { type WithClientProviderProps } from './withClientProvider';\nimport { ClientProvider } from '../client';\n\nexport type ClientRepeatedComponentProps = { id: number; count: number; spaceKey?: PublicKey };\n\nexport type ClientRepeaterControlsProps = { clients: Client[] };\n\n// TODO(burdon): Reconcile with ClientProviderProps.\nexport type ClientRepeaterProps<P extends ClientRepeatedComponentProps> = {\n  className?: string;\n  component: FC<ClientRepeatedComponentProps>;\n  controls?: FC<ClientRepeaterControlsProps>;\n  count?: number;\n  clients?: Client[];\n  types?: TypedObject[];\n  args?: Omit<P, 'id' | 'count'>;\n} & Pick<WithClientProviderProps, 'createIdentity' | 'createSpace' | 'onSpaceCreated'>;\n\n/**\n * Utility component for Storybook stories which sets up clients for n peers.\n * The `Component` property is rendered n times, once for each peer.\n * @deprecated use `withClientProvider`.\n */\n// TODO(burdon): To discuss: evolve ClientRepeater with optional decorator that uses it.\n// NOTE: This is specifically not a storybook decorator because it broke stories as a decorator.\n//   This seems primarily due to the fact that it required top-level await for the clients to initialize.\n//   Storybook seemed to handle it alright, but Chromatic had a lot of trouble with it.\n//   There was also a question of whether or not calling the story function multiple times was a good idea.\nexport const ClientRepeater = <P extends ClientRepeatedComponentProps>(props: ClientRepeaterProps<P>) => {\n  const {\n    component: Component,\n    controls: Controls,\n    count = 1,\n    types,\n    createIdentity,\n    createSpace,\n    onSpaceCreated,\n  } = props;\n  useEffect(() => {\n    registerSignalsRuntime();\n  }, []);\n\n  const [clients, setClients] = useState(props.clients ?? []);\n  const [spaceKey, setSpaceKey] = useState<PublicKey>();\n\n  const testBuilder = useRef(new TestBuilder());\n  useEffect(() => {\n    const timeout = setTimeout(async () => {\n      const clients = [...Array(count)].map(\n        (_) => new Client({ services: testBuilder.current.createLocalClientServices(), types }),\n      );\n\n      await Promise.all(clients.map((client) => client.initialize()));\n      if (createIdentity || createSpace) {\n        await Promise.all(clients.map((client) => client.halo.createIdentity()));\n      }\n\n      if (createSpace) {\n        const client = clients[0];\n        const space = await client.spaces.create({ name: faker.commerce.productName() });\n        setSpaceKey(space.key);\n        await onSpaceCreated?.({ client, space }, {});\n        await Promise.all(\n          clients.slice(1).flatMap((client) => performInvitation({ host: space, guest: client.spaces })),\n        );\n      }\n\n      setClients(clients);\n    });\n\n    return () => clearTimeout(timeout);\n  }, []);\n\n  if (clients.length === 0) {\n    return null;\n  }\n\n  return (\n    <>\n      {Controls && <Controls clients={clients} />}\n      {clients.map((client, index) => (\n        <ClientProvider key={index} client={client}>\n          <Component id={index} count={clients.length} spaceKey={spaceKey} {...{ ...props.args }} />\n        </ClientProvider>\n      ))}\n    </>\n  );\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { type StoryContext, type Decorator } from '@storybook/react';\nimport React, { createContext, type PropsWithChildren, useContext, useEffect, useRef, useState } from 'react';\nimport { type FallbackProps, ErrorBoundary as NativeErrorBoundary } from 'react-error-boundary';\n\nimport { Trigger } from '@dxos/async';\nimport { type Client } from '@dxos/client';\nimport { type Space } from '@dxos/client/echo';\nimport { performInvitation, TestBuilder } from '@dxos/client/testing';\nimport { log } from '@dxos/log';\nimport { type MaybePromise } from '@dxos/util';\n\nimport { ClientStory } from './context';\nimport { ClientProvider, type ClientProviderProps } from '../client';\n\ntype InitializeProps = {\n  createIdentity?: boolean;\n  createSpace?: boolean;\n  onInitialized?: (client: Client) => MaybePromise<void>;\n  onIdentityCreated?: (props: { client: Client }) => MaybePromise<void>;\n  // NOTE: context must be untyped until ClientRepeater is removed.\n  onSpaceCreated?: (props: { client: Client; space: Space }, context: StoryContext | any) => MaybePromise<void>;\n};\n\n/**\n * Initialize client, identity and first space.\n */\nconst initializeClient = async (\n  client: Client,\n  { createIdentity, createSpace, onSpaceCreated, onIdentityCreated, onInitialized }: InitializeProps,\n  context: StoryContext,\n): Promise<ClientStory> => {\n  await onInitialized?.(client);\n\n  if (createIdentity || createSpace) {\n    if (!client.halo.identity.get()) {\n      await client.halo.createIdentity();\n      await onIdentityCreated?.({ client });\n    }\n  }\n\n  let space: Space | undefined;\n  if (createSpace) {\n    space = await client.spaces.create({ name: 'Test Space' });\n    await onSpaceCreated?.({ client, space }, context);\n  }\n\n  return { space };\n};\n\nexport type WithClientProviderProps = InitializeProps & Omit<ClientProviderProps, 'onInitialized'>;\n\n/**\n * Decorator that provides the client context.\n */\nexport const withClientProvider = ({\n  createIdentity,\n  createSpace,\n  onSpaceCreated,\n  onIdentityCreated,\n  onInitialized,\n  ...props\n}: WithClientProviderProps = {}): Decorator => {\n  return (Story, context) => {\n    const [data, setData] = useState<ClientStory>({});\n    const handleInitialized = async (client: Client) => {\n      const data = await initializeClient(\n        client,\n        {\n          createIdentity,\n          createSpace,\n          onSpaceCreated,\n          onIdentityCreated,\n          onInitialized,\n        },\n        context,\n      );\n\n      setData(data);\n    };\n\n    return (\n      <ErrorBoundary>\n        <ClientProvider onInitialized={handleInitialized} {...props}>\n          <ClientStory.Provider value={data}>\n            <Story />\n          </ClientStory.Provider>\n        </ClientProvider>\n      </ErrorBoundary>\n    );\n  };\n};\n\n// TODO(burdon): Implement context per client for context.\n// TODO(burdon): Callback once all invitations have completed.\n// TODO(burdon): Delay/jitter for creation of other clients.\nexport type WithMultiClientProviderProps = InitializeProps &\n  Omit<ClientProviderProps, 'onInitialized'> & { numClients?: number };\n\nconst MultiClientContext = createContext<{ id: number }>({ id: 0 });\n\nexport const useMultiClient = () => useContext(MultiClientContext);\n\n/**\n * Decorator that creates a scaffold for multiple clients.\n * Orchestrates invitations between a randomly selected host and the remaining clients.\n * NOTE: Should come before withLayout.\n */\nexport const withMultiClientProvider = ({\n  numClients = 2,\n  createIdentity,\n  createSpace,\n  onSpaceCreated,\n  onIdentityCreated,\n  onInitialized,\n  ...props\n}: WithMultiClientProviderProps): Decorator => {\n  return (Story, context) => {\n    const builder = useRef(new TestBuilder());\n    const hostRef = useRef<Client>();\n    const spaceReady = useRef(new Trigger<Space | undefined>());\n\n    // Handle invitations.\n    // NOTE: The zeroth client isn't necessarily the first to be initialized.\n    const handleInitialized = async (client: Client, index: number) => {\n      log.info('initialized', { index });\n      if (createSpace) {\n        if (!hostRef.current) {\n          hostRef.current = client;\n          const { space } = await initializeClient(\n            client,\n            {\n              createIdentity,\n              createSpace,\n              onSpaceCreated,\n              onIdentityCreated,\n              onInitialized,\n            },\n            context,\n          );\n\n          spaceReady.current.wake(space);\n          log.info('inviting', { index });\n        } else {\n          await initializeClient(client, { createIdentity, onInitialized }, context);\n          const space = await spaceReady.current.wait();\n          if (space) {\n            log.info('joining', { index });\n            await Promise.all(performInvitation({ host: space, guest: client.spaces }));\n          }\n        }\n      }\n    };\n\n    return (\n      <ErrorBoundary>\n        {Array.from({ length: numClients }).map((_, index) => (\n          <MultiClientContext.Provider key={index} value={{ id: index }}>\n            <ClientProvider\n              services={builder.current.createLocalClientServices()}\n              onInitialized={(client) => handleInitialized(client, index)}\n              {...props}\n            >\n              <Story />\n            </ClientProvider>\n          </MultiClientContext.Provider>\n        ))}\n      </ErrorBoundary>\n    );\n  };\n};\n\nconst ErrorBoundary = ({ children }: PropsWithChildren) => {\n  const [error, setError] = useState<Error>();\n  useEffect(() => {\n    const handleError = (event: PromiseRejectionEvent) => {\n      setError(event.reason);\n    };\n\n    window.addEventListener('unhandledrejection', handleError);\n    return () => window.removeEventListener('unhandledrejection', handleError);\n  }, []);\n\n  if (error) {\n    return <ErrorFallback error={error} resetErrorBoundary={() => setError(undefined)} />;\n  }\n\n  return <NativeErrorBoundary FallbackComponent={ErrorFallback}>{children}</NativeErrorBoundary>;\n};\n\nconst ErrorFallback = ({ error }: FallbackProps) => {\n  const { name, message, stack } =\n    error instanceof Error ? error : { name: 'Error', message: String(error), stack: undefined };\n  return (\n    <div role='alert' className='flex flex-col p-4 gap-4 overflow-auto'>\n      <h1 className='text-xl text-red-500'>{name}</h1>\n      <div className='text-lg'>{message}</div>\n      {stack && <pre className='whitespace-pre-wrap text-sm text-subdued'>{stack}</pre>}\n    </div>\n  );\n};\n"],
  "mappings": "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",
  "names": ["import_react", "import_testing", "ClientStory", "createContext", "undefined", "useClientProvider", "useContext", "raise", "Error", "ClientRepeater", "props", "component", "Component", "controls", "Controls", "count", "types", "createIdentity", "createSpace", "onSpaceCreated", "useEffect", "registerSignalsRuntime", "clients", "setClients", "useState", "spaceKey", "setSpaceKey", "testBuilder", "useRef", "TestBuilder", "timeout", "setTimeout", "Array", "map", "_", "Client", "services", "current", "createLocalClientServices", "Promise", "all", "client", "initialize", "halo", "space", "spaces", "create", "name", "faker", "commerce", "productName", "key", "slice", "flatMap", "performInvitation", "host", "guest", "clearTimeout", "length", "React", "index", "ClientProvider", "id", "args", "initializeClient", "onIdentityCreated", "onInitialized", "context", "identity", "get", "withClientProvider", "Story", "data", "setData", "handleInitialized", "ErrorBoundary", "Provider", "value", "MultiClientContext", "useMultiClient", "withMultiClientProvider", "numClients", "builder", "hostRef", "spaceReady", "Trigger", "log", "info", "wake", "wait", "from", "children", "error", "setError", "handleError", "event", "reason", "window", "addEventListener", "removeEventListener", "ErrorFallback", "resetErrorBoundary", "NativeErrorBoundary", "FallbackComponent", "message", "stack", "String", "div", "role", "className", "h1", "pre"]
}
