"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var chunk_FYOAVV65_exports = {};
__export(chunk_FYOAVV65_exports, {
  AuthenticatingInvitationObservable: () => import_invitations.AuthenticatingInvitationObservable,
  CancellableInvitationObservable: () => import_invitations.CancellableInvitationObservable,
  Invitation: () => import_invitations.Invitation,
  InvitationEncoder: () => import_invitations.InvitationEncoder,
  InvitationsProxy: () => import_invitations.InvitationsProxy,
  useInvitationStatus: () => useInvitationStatus
});
module.exports = __toCommonJS(chunk_FYOAVV65_exports);
var import_invitations = require("@dxos/client/invitations");
var import_react = require("react");
var import_invitations2 = require("@dxos/client/invitations");
var import_log = require("@dxos/log");
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/sdk/react-client/src/invitations/useInvitationStatus.ts";
var isShareableInvitation = (invitation) => invitation.authMethod !== import_invitations2.Invitation.AuthMethod.KNOWN_PUBLIC_KEY || invitation.guestKeypair?.privateKey;
var useInvitationStatus = (observable) => {
  const [state, dispatch] = (0, import_react.useReducer)((prev, action) => {
    (0, import_log.log)("useInvitationStatus", {
      action
    }, {
      F: __dxlog_file,
      L: 90,
      S: void 0,
      C: (f, a) => f(...a)
    });
    const invitationProps = "invitation" in action ? {
      id: action.invitation.invitationId,
      multiUse: action.invitation.multiUse,
      invitationCode: import_invitations2.InvitationEncoder.encode(action.invitation),
      authCode: action.invitation.authCode,
      authMethod: action.invitation.authMethod,
      shareable: isShareableInvitation(action.invitation),
      type: action.invitation.type
    } : {};
    return {
      ...prev,
      ...invitationProps,
      // TODO(burdon): State.
      status: action.status,
      // `invitationObservable`, `secret`, and `result` is persisted between the status-actions that set them.
      result: action.status === import_invitations2.Invitation.State.SUCCESS ? action.result : prev.result,
      // `error` gets set each time we enter the error state
      ...action.status === import_invitations2.Invitation.State.ERROR && {
        error: action.error
      },
      // `haltedAt` gets set on only the first error/cancelled/timeout action and reset on any others.
      ...(action.status === import_invitations2.Invitation.State.ERROR || action.status === import_invitations2.Invitation.State.CANCELLED || action.status === import_invitations2.Invitation.State.TIMEOUT) && {
        haltedAt: typeof prev.haltedAt === "undefined" ? action.haltedAt : prev.haltedAt
      }
    };
  }, null, (_arg) => {
    const invitation = observable?.get();
    return {
      status: import_invitations2.Invitation.State.INIT,
      result: {
        spaceKey: null,
        identityKey: null,
        swarmKey: null,
        target: null
      },
      id: invitation?.invitationId,
      multiUse: invitation?.multiUse,
      invitationCode: invitation ? import_invitations2.InvitationEncoder.encode(invitation) : void 0,
      authCode: invitation?.authCode,
      authMethod: invitation?.authMethod,
      shareable: invitation ? isShareableInvitation(invitation) : false,
      type: invitation?.type
    };
  });
  (0, import_react.useEffect)(() => {
    const update = (invitation) => {
      switch (invitation.state) {
        case import_invitations2.Invitation.State.INIT:
        case import_invitations2.Invitation.State.CONNECTED:
        case import_invitations2.Invitation.State.READY_FOR_AUTHENTICATION:
        case import_invitations2.Invitation.State.AUTHENTICATING: {
          dispatch({
            invitation,
            status: invitation.state
          });
          break;
        }
        case import_invitations2.Invitation.State.SUCCESS: {
          dispatch({
            invitation,
            status: invitation.state,
            result: {
              spaceKey: invitation.spaceKey || null,
              identityKey: invitation.identityKey || null,
              swarmKey: invitation.swarmKey || null,
              target: invitation.target || null
            }
          });
          break;
        }
        case import_invitations2.Invitation.State.CANCELLED:
        case import_invitations2.Invitation.State.TIMEOUT: {
          dispatch({
            invitation,
            status: invitation.state,
            haltedAt: state.status
          });
          break;
        }
      }
    };
    const subscription = observable?.subscribe(update, (err) => {
      dispatch({
        status: import_invitations2.Invitation.State.ERROR,
        error: err,
        haltedAt: state.status
      });
    });
    const currentState = observable?.get();
    if (currentState) {
      update(currentState);
    }
    return () => subscription?.unsubscribe();
  }, [
    observable,
    state.status
  ]);
  const connect = (0, import_react.useCallback)((observable2) => {
    dispatch({
      invitation: observable2.get(),
      status: import_invitations2.Invitation.State.CONNECTING,
      observable: observable2
    });
  }, []);
  const authenticate = (0, import_react.useCallback)((authCode) => {
    (0, import_log.log)("authenticating...", {
      authCode
    }, {
      F: __dxlog_file,
      L: 195,
      S: void 0,
      C: (f, a) => f(...a)
    });
    return observable.authenticate(authCode);
  }, [
    observable
  ]);
  const cancel = (0, import_react.useCallback)(async () => observable?.cancel(), [
    observable
  ]);
  return (0, import_react.useMemo)(() => {
    return {
      ...state,
      cancel,
      connect,
      authenticate
    };
  }, [
    state,
    cancel,
    connect,
    authenticate
  ]);
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AuthenticatingInvitationObservable,
  CancellableInvitationObservable,
  Invitation,
  InvitationEncoder,
  InvitationsProxy,
  useInvitationStatus
});
//# sourceMappingURL=chunk-FYOAVV65.cjs.map
