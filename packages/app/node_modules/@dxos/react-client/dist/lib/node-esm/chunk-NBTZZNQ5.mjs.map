{
  "version": 3,
  "sources": ["../../../src/client/AgentHostingProvider.tsx", "../../../src/client/ClientProvider.tsx", "../../../src/client/context.ts", "../../../src/banner.ts", "../../../src/client/useClient.ts", "../../../src/client/useClientStatus.ts", "../../../src/client/useConfig.ts", "../../../src/client/useShell.ts", "../../../src/client/useStatus.ts"],
  "sourcesContent": ["//\n// Copyright 2023 DXOS.org\n//\n\nimport React, { createContext, type PropsWithChildren, useContext, useState } from 'react';\n\nimport { type AgentHostingProviderClient, AgentManagerClient, FakeAgentHostingProvider } from '@dxos/client';\nimport { type Halo } from '@dxos/client/halo';\nimport { type Config } from '@dxos/config';\nimport { log } from '@dxos/log';\n\nimport { useClient } from '../client';\n\nexport type AgentHostingProviderProps = { config: Config; halo: Halo };\n\nexport const AgentHostingContext = createContext<AgentHostingProviderClient | null>(null);\n\n/**\n * Experimental agent hosting provider.\n * @param props\n * @constructor\n * @deprecated\n */\nexport const AgentHostingProvider = (props: PropsWithChildren) => {\n  const client = useClient();\n  const [agentHostingProviderClient] = useState(makeClient(client));\n  return (\n    <AgentHostingContext.Provider value={agentHostingProviderClient}> {props.children}</AgentHostingContext.Provider>\n  );\n};\n\nexport const useAgentHostingClient = () => {\n  return useContext(AgentHostingContext);\n};\n\nconst makeClient = ({ config, halo }: AgentHostingProviderProps) => {\n  const agentHostingConfig = config.get('runtime.services.agentHosting');\n  if (!agentHostingConfig) {\n    log('no agent hosting configured');\n    return null;\n  }\n\n  // TODO(nf): Dynamically discover based on runtime config.\n  let agentHostingProviderClient: AgentHostingProviderClient | null = null;\n  switch (agentHostingConfig.type) {\n    case 'LOCAL_TESTING': {\n      log('using FakeAgentHostingProvider');\n      return new FakeAgentHostingProvider();\n    }\n\n    case 'AGENTHOSTING_API': {\n      agentHostingProviderClient = new AgentManagerClient(config, halo);\n      if (agentHostingProviderClient.init()) {\n        return agentHostingProviderClient;\n      } else {\n        // Not authorized or error initializing.\n        return null;\n      }\n    }\n\n    default: {\n      log.error('Unknown agent hosting provider type: ' + agentHostingConfig.type);\n      return null;\n    }\n  }\n};\n", "//\n// Copyright 2020 DXOS.org\n//\n\nimport React, {\n  forwardRef,\n  type FunctionComponent,\n  type PropsWithChildren,\n  useEffect,\n  useImperativeHandle,\n  useState,\n} from 'react';\n\nimport { Client, type ClientOptions, type ClientServicesProvider, SystemStatus } from '@dxos/client';\nimport { type Config } from '@dxos/config';\nimport { registerSignalsRuntime } from '@dxos/echo-signals/react';\nimport { log } from '@dxos/log';\nimport { useControlledState } from '@dxos/react-hooks';\nimport { getAsyncProviderValue, type MaybePromise, type Provider } from '@dxos/util';\n\nimport { ClientContext, type ClientContextProps } from './context';\nimport { printBanner } from '../banner';\n\n/**\n * Properties for the ClientProvider.\n */\nexport type ClientProviderProps = Omit<ClientOptions, 'config' | 'services'> &\n  Pick<ClientContextProps, 'status'> &\n  PropsWithChildren<{\n    /**\n     * Client object or async provider to enable to caller to do custom initialization.\n     *\n     * NOTE: For advanced use cases only.\n     */\n    client?: Client | Provider<Promise<Client>>;\n\n    /**\n     * Config object or async provider.\n     *\n     * NOTE: If a `client` is provided then `config` is ignored.\n     */\n    // TODO(burdon): Reconcile with ClientOptions.\n    config?: Config | Provider<Promise<Config>>;\n\n    /**\n     * Callback to enable the caller to create a custom ClientServicesProvider.\n     *\n     * NOTE: If a `client` is provided then `services` is ignored.\n     */\n    // TODO(burdon): Reconcile with ClientOptions.\n    services?: ClientServicesProvider | ((config?: Config) => MaybePromise<ClientServicesProvider>);\n\n    /**\n     * ReactNode to display until the client is available.\n     */\n    fallback?: FunctionComponent<Partial<ClientContextProps>>;\n\n    /**\n     * Enable (by default) registration of Preact signals runtime for reactive ECHO objects.\n     * @see https://www.npmjs.com/package/@preact/signals-react\n     */\n    signalsRuntime?: boolean;\n\n    /**\n     * Skip the DXOS banner.\n     */\n    noBanner?: boolean;\n\n    /**\n     * Post initialization hook to enable to caller to do custom initialization.\n     */\n    onInitialized?: (client: Client) => MaybePromise<void>;\n  }>;\n\n/**\n * Root component that provides the DXOS client instance to child components.\n * To be used with the `useClient` hook.\n */\nexport const ClientProvider = forwardRef<Client | undefined, ClientProviderProps>(\n  (\n    {\n      children,\n      config: configProvider,\n      client: clientProvider,\n      services: servicesProvider,\n      status: controlledStatus,\n      fallback: Fallback = () => null,\n      signalsRuntime = true,\n      noBanner,\n      onInitialized,\n      ...options\n    },\n    forwardedRef,\n  ) => {\n    useEffect(() => {\n      // TODO(wittjosiah): Ideally this should be imported asynchronously because it is optional.\n      //   Unfortunately, async import seemed to break signals React instrumentation.\n      signalsRuntime && registerSignalsRuntime();\n    }, []);\n\n    // The client is initialized asynchronously.\n    // If an error occurs during initialization, it is caught and the state is set.\n    // This allows the error to be thrown in the render method.\n    // The assumption is that a client initialization error is fatal to the app.\n    // This error will be caught by the nearest error boundary.\n    const [error, setError] = useState();\n    if (error) {\n      throw error;\n    }\n\n    const [client, setClient] = useState(clientProvider instanceof Client ? clientProvider : undefined);\n\n    // Provide external access.\n    useImperativeHandle(forwardedRef, () => client, [client]);\n\n    // Client status subscription.\n    const [status, setStatus] = useControlledState(controlledStatus);\n    useEffect(() => {\n      if (!client) {\n        return;\n      }\n\n      const subscription = client.status.subscribe((status) => setStatus(status));\n      return () => subscription.unsubscribe();\n    }, [client]);\n\n    // Create and/or initialize client.\n    useEffect(() => {\n      let disposed = false;\n      const initialize = async (client: Client) => {\n        if (!client.initialized) {\n          await client.initialize().catch((err) => {\n            if (!disposed) {\n              setError(err);\n            }\n          });\n          log('client ready');\n          await onInitialized?.(client);\n          log('initialization complete');\n        }\n\n        setClient(client);\n\n        if (!noBanner) {\n          printBanner(client);\n        }\n      };\n\n      let client: Client;\n      const t = setTimeout(async () => {\n        try {\n          if (clientProvider) {\n            // Asynchronously request client.\n            client = await getAsyncProviderValue(clientProvider);\n            await initialize(client);\n          } else {\n            // Asynchronously construct client (config may be undefined).\n            const config = await getAsyncProviderValue(configProvider);\n            log('resolved config', { config });\n            const services = await getAsyncProviderValue(servicesProvider, config);\n            log('created services', { services });\n            client = new Client({ config, services, ...options });\n            log('created client');\n            await initialize(client);\n          }\n        } catch (err) {\n          if (!disposed) {\n            log.catch(err);\n          }\n        }\n      });\n\n      return () => {\n        log('clean up');\n        disposed = true;\n        clearTimeout(t);\n        // Only destroy if the client is not provided by the parent.\n        if (!clientProvider) {\n          void client\n            ?.destroy()\n            .then(() => {\n              log('destroyed');\n            })\n            .catch((err) => log.catch(err));\n        }\n      };\n    }, [configProvider, clientProvider, servicesProvider, noBanner]);\n\n    if (!client?.initialized || status !== SystemStatus.ACTIVE) {\n      return <Fallback client={client} status={status} />;\n    }\n\n    return <ClientContext.Provider value={{ client, status }}>{children}</ClientContext.Provider>;\n  },\n);\n", "//\n// Copyright 2020 DXOS.org\n//\n\nimport { type Context, createContext } from 'react';\n\nimport { type Client, type SystemStatus } from '@dxos/client';\n\nexport type ClientContextProps = {\n  client: Client;\n  status?: SystemStatus | null;\n};\n\n/**\n * @internal Use ClientProvider to create or initialize the Client.\n */\nexport const ClientContext: Context<ClientContextProps | undefined> = createContext<ClientContextProps | undefined>(\n  undefined,\n);\n", "//\n// Copyright 2021 DXOS.org\n//\n\nimport { type Client } from '@dxos/client';\n\n// http://patorjk.com/software/taag/#p=testall&f=Patorjk-HeX&t=DXOS\nconst BANNER = (client: Client) => {\n  const commitHash = client.config.get('runtime.app.build.commitHash');\n  const hash = commitHash ? ` App Commit ${commitHash} \\n` : '';\n\n  return (\n    '\\n' +\n    '_/\\\\/\\\\/\\\\/\\\\/\\\\____/\\\\/\\\\____/\\\\/\\\\____/\\\\/\\\\/\\\\/\\\\______/\\\\/\\\\/\\\\/\\\\/\\\\_\\n' +\n    '_/\\\\/\\\\____/\\\\/\\\\____/\\\\/\\\\/\\\\/\\\\____/\\\\/\\\\____/\\\\/\\\\__/\\\\/\\\\_________\\n' +\n    '_/\\\\/\\\\____/\\\\/\\\\______/\\\\/\\\\______/\\\\/\\\\____/\\\\/\\\\____/\\\\/\\\\/\\\\/\\\\___\\n' +\n    '_/\\\\/\\\\____/\\\\/\\\\____/\\\\/\\\\/\\\\/\\\\____/\\\\/\\\\____/\\\\/\\\\__________/\\\\/\\\\_\\n' +\n    '_/\\\\/\\\\/\\\\/\\\\/\\\\____/\\\\/\\\\____/\\\\/\\\\____/\\\\/\\\\/\\\\/\\\\____/\\\\/\\\\/\\\\/\\\\/\\\\___\\n' +\n    `\\n DXOS Client ${client.version} \\n${hash}`\n  );\n};\n\nlet bannerPrinted = false;\n\nexport const printBanner = (client: Client) => {\n  if (bannerPrinted || window.location.hostname === 'localhost') {\n    return;\n  }\n\n  bannerPrinted = true;\n  // eslint-disable-next-line no-console\n  console.log(`%c${BANNER(client)}`, 'font-family: monospace;');\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { useContext } from 'react';\n\nimport { raise } from '@dxos/debug';\n\nimport { ClientContext } from '../client/context';\n\n/**\n * Hook returning instance of DXOS client.\n * Requires ClientContext to be set via ClientProvider.\n */\nexport const useClient = () => {\n  const { client } = useContext(ClientContext) ?? raise(new Error('Missing ClientContext.'));\n  return client;\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { useEffect, useState } from 'react';\n\nimport { type Client, type SystemStatus } from '@dxos/client';\n\nexport const useClientStatus = (client: Client) => {\n  const [status, setStatus] = useState<SystemStatus | null>();\n  useEffect(() => {\n    if (!client) {\n      return;\n    }\n\n    const subscription = client.status.subscribe((status) => setStatus(status));\n    return () => subscription.unsubscribe();\n  }, [client, setStatus]);\n\n  return status;\n};\n", "//\n// Copyright 2020 DXOS.org\n//\n\nimport { useContext } from 'react';\n\nimport { raise } from '@dxos/debug';\n\nimport { ClientContext } from './context';\n\n/**\n * Hook returning config object used to initialize the DXOS client instance.\n * Requires ClientContext to be set via ClientProvider.\n */\nexport const useConfig = () => {\n  const { client } = useContext(ClientContext) ?? raise(new Error('Missing ClientContext.'));\n  return client.config;\n};\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { useEffect, useState } from 'react';\n\nimport { type Shell, type ShellDisplay } from '@dxos/client';\n\nimport { useClient } from './useClient';\n\n/**\n * Helper hook to access the shell.\n */\nexport const useShell = (): Shell => {\n  const client = useClient();\n  return client.shell;\n};\n\n/**\n * Hook to access the shellâ€™s display state.\n */\nexport const useShellDisplay = (): ShellDisplay => {\n  const client = useClient();\n  const [display, setDisplay] = useState(client.shell.display);\n  useEffect(() => client.shell.onDisplayChange(setDisplay), [client]);\n  return display;\n};\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { useContext } from 'react';\n\nimport { type SystemStatus } from '@dxos/client';\nimport { raise } from '@dxos/debug';\n\nimport { ClientContext } from './context';\n\nexport const useStatus = (): SystemStatus | null | undefined => {\n  const { status } = useContext(ClientContext) ?? raise(new Error('Missing ClientContext.'));\n  return status;\n};\n"],
  "mappings": "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",
  "names": ["React", "createContext", "useContext", "useState", "AgentManagerClient", "FakeAgentHostingProvider", "log", "React", "forwardRef", "useEffect", "useImperativeHandle", "useState", "Client", "SystemStatus", "registerSignalsRuntime", "log", "useControlledState", "getAsyncProviderValue", "createContext", "ClientContext", "createContext", "undefined", "BANNER", "client", "commitHash", "config", "get", "hash", "version", "bannerPrinted", "printBanner", "window", "location", "hostname", "console", "log", "ClientProvider", "forwardRef", "children", "config", "configProvider", "client", "clientProvider", "services", "servicesProvider", "status", "controlledStatus", "fallback", "Fallback", "signalsRuntime", "noBanner", "onInitialized", "options", "forwardedRef", "useEffect", "registerSignalsRuntime", "error", "setError", "useState", "setClient", "Client", "undefined", "useImperativeHandle", "setStatus", "useControlledState", "subscription", "subscribe", "unsubscribe", "disposed", "initialize", "initialized", "catch", "err", "log", "printBanner", "t", "setTimeout", "getAsyncProviderValue", "clearTimeout", "destroy", "then", "SystemStatus", "ACTIVE", "ClientContext", "Provider", "value", "useContext", "raise", "useClient", "client", "useContext", "ClientContext", "raise", "Error", "useEffect", "useState", "useClientStatus", "client", "status", "setStatus", "useState", "useEffect", "subscription", "subscribe", "unsubscribe", "useContext", "raise", "useConfig", "client", "useContext", "ClientContext", "raise", "Error", "config", "useEffect", "useState", "useShell", "client", "useClient", "shell", "useShellDisplay", "display", "setDisplay", "useState", "useEffect", "onDisplayChange", "useContext", "raise", "useStatus", "status", "useContext", "ClientContext", "raise", "Error", "AgentHostingContext", "createContext", "AgentHostingProvider", "props", "client", "useClient", "agentHostingProviderClient", "useState", "makeClient", "React", "Provider", "value", "children", "useAgentHostingClient", "useContext", "config", "halo", "agentHostingConfig", "get", "log", "type", "FakeAgentHostingProvider", "AgentManagerClient", "init", "error"]
}
