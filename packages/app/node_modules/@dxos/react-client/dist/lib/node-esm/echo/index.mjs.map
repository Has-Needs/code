{
  "version": 3,
  "sources": ["../../../../src/echo/index.ts", "../../../../src/echo/useMembers.ts", "../../../../src/echo/useSpaces.ts", "../../../../src/echo/useQuery.ts", "../../../../src/echo/useQueue.ts", "../../../../src/echo/useSchema.ts", "../../../../src/echo/useSpaceInvitations.ts", "../../../../src/echo/useSubscription.ts", "../../../../src/echo/useSyncState.ts"],
  "sourcesContent": ["//\n// Copyright 2020 DXOS.org\n//\n\nexport * from '@dxos/client/echo';\n\nexport * from './useMembers';\nexport * from './useQuery';\nexport * from './useQueue';\nexport * from './useSchema';\nexport * from './useSpaces';\nexport * from './useSpaceInvitations';\nexport * from './useSubscription';\nexport * from './useSyncState';\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { MulticastObservable } from '@dxos/async';\nimport { type PublicKey } from '@dxos/client';\nimport { HaloSpaceMember, type SpaceMember } from '@dxos/client/echo';\nimport { useMulticastObservable } from '@dxos/react-hooks';\n\nimport { useSpaces } from './useSpaces';\n\nexport const useMembers = (spaceKey: PublicKey | undefined): SpaceMember[] => {\n  // TODO(dmaretskyi): useSpace hook for spaces that are not ready.\n  const spaces = useSpaces({ all: true });\n  const space = spaceKey ? spaces.find((space) => space.key.equals(spaceKey)) : undefined;\n\n  // EMPTY_OBSERVABLE needs to be a stable reference to avoid re-subscribing on every render.\n  const members = useMulticastObservable(space?.members ?? MulticastObservable.empty()) ?? [];\n  return members.filter((member) => member.role !== HaloSpaceMember.Role.REMOVED);\n};\n", "//\n// Copyright 2020 DXOS.org\n//\n\nimport { useEffect, useState } from 'react';\n\nimport { type PublicKeyLike } from '@dxos/client';\nimport { type Space, SpaceState } from '@dxos/client/echo';\nimport { useMulticastObservable } from '@dxos/react-hooks';\n\nimport { useClient } from '../client';\n\n/**\n * Get a specific Space using its key.\n * The space is not guaranteed to be in the ready state.\n * Returns the default space if no key is provided.\n * Requires a ClientProvider somewhere in the parent tree.\n *\n * @param spaceKeyLike the key of the space to look for\n */\nexport const useSpace = (spaceKeyLike?: PublicKeyLike): Space | undefined => {\n  const client = useClient();\n  const spaces = useMulticastObservable<Space[]>(client.spaces);\n  const [ready, setReady] = useState(false);\n\n  useEffect(() => {\n    // Only wait for ready if looking for the default space.\n    if (spaceKeyLike) {\n      return;\n    }\n\n    const timeout = setTimeout(async () => {\n      await client.spaces.waitUntilReady();\n      setReady(true);\n    });\n\n    return () => clearTimeout(timeout);\n  }, [client, spaceKeyLike]);\n\n  if (spaceKeyLike) {\n    return spaces.find((space) => space.key.equals(spaceKeyLike) || space.id === spaceKeyLike);\n  }\n\n  if (ready && client.halo.identity.get()) {\n    return client.spaces.default;\n  }\n};\n\nexport type UseSpacesParams = {\n  /**\n   * Return uninitialized spaces as well.\n   */\n  all?: boolean;\n};\n\n/**\n * Get all Spaces available to current user.\n * Requires a ClientProvider somewhere in the parent tree.\n * By default, only ready spaces are returned.\n * @returns an array of Spaces\n */\nexport const useSpaces = ({ all = false }: UseSpacesParams = {}): Space[] => {\n  const client = useClient();\n  const spaces = useMulticastObservable<Space[]>(client.spaces);\n\n  // TODO(dmaretskyi): Array reference equality.\n  return spaces.filter((space) => all || space.state.get() === SpaceState.SPACE_READY);\n};\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { useMemo, useSyncExternalStore } from 'react';\n\nimport { type Echo, Filter, type Live, Query, type Space, isSpace } from '@dxos/client/echo';\n\nconst EMPTY_ARRAY: never[] = [];\n\nconst noop = () => {};\n\n// TODO(dmaretskyi): Queries are fully serializable, so we can remove `deps` argument.\ninterface UseQueryFn {\n  <Q extends Query.Any>(spaceOrEcho: Space | Echo | undefined, query: Q, deps?: any[]): Live<Query.Type<Q>>[];\n\n  <F extends Filter.Any>(spaceOrEcho: Space | Echo | undefined, filter: F, deps?: any[]): Live<Filter.Type<F>>[];\n}\n\n/**\n * Create subscription.\n */\nexport const useQuery: UseQueryFn = (\n  spaceOrEcho: Space | Echo | undefined,\n  queryOrFilter: Query.Any | Filter.Any,\n  deps?: any[],\n): Live<unknown>[] => {\n  const query = Filter.is(queryOrFilter) ? Query.select(queryOrFilter) : queryOrFilter;\n\n  const { getObjects, subscribe } = useMemo(() => {\n    let subscribed = false;\n    const queryResult =\n      spaceOrEcho === undefined\n        ? undefined\n        : isSpace(spaceOrEcho)\n          ? spaceOrEcho.db.query(query)\n          : spaceOrEcho.query(query);\n\n    return {\n      getObjects: () => (subscribed && queryResult ? queryResult.objects : EMPTY_ARRAY),\n      subscribe: (cb: () => void) => {\n        subscribed = true;\n        const unsubscribe = queryResult?.subscribe(cb) ?? noop;\n        return () => {\n          unsubscribe?.();\n          subscribed = false;\n        };\n      },\n    };\n  }, [spaceOrEcho, JSON.stringify(query.ast), ...(deps ?? [])]);\n\n  // https://beta.reactjs.org/reference/react/useSyncExternalStore\n  // NOTE: This hook will resubscribe whenever the callback passed to the first argument changes; make sure it is stable.\n  const objects = useSyncExternalStore<Live<unknown>[] | undefined>(subscribe, getObjects);\n  return objects ?? [];\n};\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { useEffect, useMemo, useRef } from 'react';\n\nimport { type Queue } from '@dxos/client/echo';\nimport { raise } from '@dxos/debug';\nimport { type Obj, type Relation } from '@dxos/echo';\nimport { type DXN } from '@dxos/keys';\n\nimport { useClient } from '../client';\n\nconst MIN_POLL_INTERVAL = 1_000;\n\nexport type UseQueueOptions = {\n  pollInterval?: number;\n};\n\n/**\n * Polls the given Edge queue.\n */\n// TODO(burdon): Replace polling with socket?\n// TODO(dmaretskyi): Move into client package.\n// TODO(dmaretskyi): Consider passing the space into the hook to support queue DXNs without space id.\n// TODO(ZaymonFC): If queue is unchanged returned object should be refferentially stable on poll.\nexport const useQueue = <T extends Obj.Any | Relation.Any>(\n  queueDxn?: DXN,\n  options: UseQueueOptions = {},\n): Queue<T> | undefined => {\n  const client = useClient();\n  const mountedRef = useRef(true);\n\n  const queue = useMemo<Queue<T> | undefined>(() => {\n    if (!queueDxn) {\n      return undefined;\n    }\n\n    const { spaceId } = queueDxn.asQueueDXN() ?? raise(new TypeError('Invalid queue DXN'));\n    return client.spaces.get(spaceId)?.queues.get<T>(queueDxn);\n  }, [client, queueDxn?.toString()]);\n\n  useEffect(() => {\n    void queue?.refresh();\n  }, [queue]);\n\n  useEffect(() => {\n    let timeout: NodeJS.Timeout;\n    mountedRef.current = true;\n\n    const poll = () => {\n      if (!mountedRef.current) {\n        return;\n      }\n\n      void queue?.refresh().finally(() => {\n        if (mountedRef.current && options.pollInterval) {\n          timeout = setTimeout(poll, Math.max(options.pollInterval ?? 0, MIN_POLL_INTERVAL));\n        }\n      });\n    };\n\n    if (options.pollInterval) {\n      poll();\n    }\n\n    return () => {\n      mountedRef.current = false;\n      clearTimeout(timeout);\n    };\n  }, [queue, options.pollInterval]);\n\n  return queue;\n};\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { type Schema } from 'effect';\nimport { useMemo, useSyncExternalStore } from 'react';\n\nimport { type Client } from '@dxos/client';\nimport { type Space } from '@dxos/client/echo';\nimport { type BaseSchema } from '@dxos/echo-schema';\n\n/**\n * Subscribe to and retrieve schema changes from a space's schema registry.\n */\nexport const useSchema = (\n  client: Client,\n  space: Space | undefined,\n  typename: string | undefined,\n): Schema.Schema.AnyNoContext | undefined => {\n  const { subscribe, getSchema } = useMemo(() => {\n    if (!typename || !space) {\n      return {\n        subscribe: () => () => {},\n        getSchema: () => undefined,\n      };\n    }\n\n    const staticSchema = client.graph.schemaRegistry.getSchema(typename);\n    if (staticSchema) {\n      return {\n        subscribe: () => () => {},\n        getSchema: () => staticSchema,\n      };\n    }\n\n    const query = space.db.schemaRegistry.query({ typename });\n    const initialResult: BaseSchema = query.runSync()[0];\n    let currentSchema = initialResult;\n\n    return {\n      subscribe: (onStoreChange: () => void) => {\n        const unsubscribe = query.subscribe(() => {\n          currentSchema = query.results[0];\n          onStoreChange();\n        });\n\n        return unsubscribe;\n      },\n      getSchema: () => currentSchema,\n    };\n  }, [typename, space]);\n\n  return useSyncExternalStore(subscribe, getSchema);\n};\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { useMemo } from 'react';\n\nimport { MulticastObservable } from '@dxos/async';\nimport { type PublicKey } from '@dxos/client';\nimport { useMulticastObservable } from '@dxos/react-hooks';\n\nimport { useSpace } from './useSpaces';\nimport { type CancellableInvitationObservable, useInvitationStatus } from '../invitations';\n\nexport const useSpaceInvitations = (spaceKey?: PublicKey): CancellableInvitationObservable[] => {\n  const space = useSpace(spaceKey);\n  return useMulticastObservable(space?.invitations ?? MulticastObservable.empty()) ?? [];\n};\n\nexport const useSpaceInvitation = (spaceKey?: PublicKey, invitationId?: string) => {\n  const invitations = useSpaceInvitations(spaceKey);\n  const invitation = useMemo(\n    () => invitations.find((invitation) => invitation.get().invitationId === invitationId),\n    [invitations],\n  );\n  return useInvitationStatus(invitation);\n};\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { useEffect, useRef } from 'react';\n\nimport { type Selection, type SubscriptionHandle, createSubscription } from '@dxos/client/echo';\n\n/**\n * Create reactive selection.\n * Calls the callback when the selection changes and during the first render.\n */\n// TODO(wittjosiah): Is this still needed with signals reactivity? If not, remove or update jsdoc with usage info.\nexport const useSubscription = (cb: () => void, selection: Selection) => {\n  // Make sure that the callback is always the one from the latest render.\n  // Without this, we would always call the callback from the initial render,\n  // which might contain stale data.\n  const callbackRef = useRef(cb);\n  callbackRef.current = cb;\n\n  const subscriptionRef = useRef<SubscriptionHandle>();\n\n  useEffect(() => {\n    subscriptionRef.current = createSubscription(() => {\n      callbackRef.current();\n    });\n\n    return () => subscriptionRef.current?.unsubscribe();\n  }, []);\n\n  subscriptionRef.current?.update(selection);\n  return subscriptionRef.current;\n};\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { useEffect, useState } from 'react';\n\nimport { type PeerSyncState, type SpaceSyncStateMap, type Space } from '@dxos/client/echo';\nimport { Context } from '@dxos/context';\nimport { type SpaceId } from '@dxos/keys';\nimport { EdgeService } from '@dxos/protocols';\n\nimport { useClient } from '../client';\n\nconst isEdgePeerId = (peerId: string, spaceId: SpaceId) =>\n  peerId.startsWith(`${EdgeService.AUTOMERGE_REPLICATOR}:${spaceId}`);\n\n/**\n * Hook Subscribes to sync state for each space.\n */\nexport const useSyncState = (): SpaceSyncStateMap => {\n  const client = useClient();\n  const [spaceState, setSpaceState] = useState<SpaceSyncStateMap>({});\n\n  useEffect(() => {\n    const ctx = new Context();\n    const createSubscriptions = (spaces: Space[]) => {\n      for (const space of spaces) {\n        if (spaceState[space.id]) {\n          continue;\n        }\n\n        ctx.onDispose(\n          space.crud.subscribeToSyncState(ctx, ({ peers = [] }) => {\n            const syncState = peers.find((state) => isEdgePeerId(state.peerId, space.id));\n            if (syncState) {\n              setSpaceState((spaceState) => ({ ...spaceState, [space.id]: syncState }));\n            }\n          }),\n        );\n      }\n    };\n\n    createSubscriptions(client.spaces.get());\n    client.spaces.subscribe((spaces) => {\n      createSubscriptions(spaces);\n    });\n\n    return () => {\n      void ctx.dispose();\n    };\n  }, [client]);\n\n  return spaceState;\n};\n\n/**\n * Hook Subscribes to sync state for a single space.\n */\n// TODO(wittjosiah): Reconcile w/ useSyncState.\nexport const useSpaceSyncState = (space: Space): PeerSyncState | undefined => {\n  const [spaceState, setSpaceState] = useState<PeerSyncState>();\n\n  useEffect(() => {\n    const ctx = new Context();\n    space.crud.subscribeToSyncState(ctx, ({ peers = [] }) => {\n      const syncState = peers.find((state) => isEdgePeerId(state.peerId, space.id));\n      if (syncState) {\n        setSpaceState(syncState);\n      }\n    });\n\n    return () => {\n      void ctx.dispose();\n    };\n  }, [space]);\n\n  return spaceState;\n};\n"],
  "mappings": "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",
  "names": ["MulticastObservable", "HaloSpaceMember", "useMulticastObservable", "useEffect", "useState", "SpaceState", "useMulticastObservable", "useSpace", "spaceKeyLike", "client", "useClient", "spaces", "useMulticastObservable", "ready", "setReady", "useState", "useEffect", "timeout", "setTimeout", "waitUntilReady", "clearTimeout", "find", "space", "key", "equals", "id", "halo", "identity", "get", "default", "useSpaces", "all", "filter", "state", "SpaceState", "SPACE_READY", "useMembers", "spaceKey", "spaces", "useSpaces", "all", "space", "find", "key", "equals", "undefined", "members", "useMulticastObservable", "MulticastObservable", "empty", "filter", "member", "role", "HaloSpaceMember", "Role", "REMOVED", "useMemo", "useSyncExternalStore", "Filter", "Query", "isSpace", "EMPTY_ARRAY", "noop", "useQuery", "spaceOrEcho", "queryOrFilter", "deps", "query", "Filter", "is", "Query", "select", "getObjects", "subscribe", "useMemo", "subscribed", "queryResult", "undefined", "isSpace", "db", "objects", "cb", "unsubscribe", "JSON", "stringify", "ast", "useSyncExternalStore", "useEffect", "useMemo", "useRef", "raise", "MIN_POLL_INTERVAL", "useQueue", "queueDxn", "options", "client", "useClient", "mountedRef", "useRef", "queue", "useMemo", "undefined", "spaceId", "asQueueDXN", "raise", "TypeError", "spaces", "get", "queues", "toString", "useEffect", "refresh", "timeout", "current", "poll", "finally", "pollInterval", "setTimeout", "Math", "max", "clearTimeout", "useMemo", "useSyncExternalStore", "useSchema", "client", "space", "typename", "subscribe", "getSchema", "useMemo", "undefined", "staticSchema", "graph", "schemaRegistry", "query", "db", "initialResult", "runSync", "currentSchema", "onStoreChange", "unsubscribe", "results", "useSyncExternalStore", "useMemo", "MulticastObservable", "useMulticastObservable", "useSpaceInvitations", "spaceKey", "space", "useSpace", "useMulticastObservable", "invitations", "MulticastObservable", "empty", "useSpaceInvitation", "invitationId", "invitation", "useMemo", "find", "get", "useInvitationStatus", "useEffect", "useRef", "createSubscription", "useSubscription", "cb", "selection", "callbackRef", "useRef", "current", "subscriptionRef", "useEffect", "createSubscription", "unsubscribe", "update", "useEffect", "useState", "Context", "EdgeService", "isEdgePeerId", "peerId", "spaceId", "startsWith", "EdgeService", "AUTOMERGE_REPLICATOR", "useSyncState", "client", "useClient", "spaceState", "setSpaceState", "useState", "useEffect", "ctx", "Context", "createSubscriptions", "spaces", "space", "id", "onDispose", "crud", "subscribeToSyncState", "peers", "syncState", "find", "state", "get", "subscribe", "dispose", "useSpaceSyncState"]
}
