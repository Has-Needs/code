import { createRequire } from 'node:module';const require = createRequire(import.meta.url);
import {
  useInvitationStatus
} from "../chunk-UYJUBYMU.mjs";
import {
  useClient
} from "../chunk-NBTZZNQ5.mjs";

// packages/sdk/react-client/src/echo/index.ts
export * from "@dxos/client/echo";

// packages/sdk/react-client/src/echo/useMembers.ts
import { MulticastObservable } from "@dxos/async";
import { HaloSpaceMember } from "@dxos/client/echo";
import { useMulticastObservable as useMulticastObservable2 } from "@dxos/react-hooks";

// packages/sdk/react-client/src/echo/useSpaces.ts
import { useEffect, useState } from "react";
import { SpaceState } from "@dxos/client/echo";
import { useMulticastObservable } from "@dxos/react-hooks";
var useSpace = (spaceKeyLike) => {
  const client = useClient();
  const spaces = useMulticastObservable(client.spaces);
  const [ready, setReady] = useState(false);
  useEffect(() => {
    if (spaceKeyLike) {
      return;
    }
    const timeout = setTimeout(async () => {
      await client.spaces.waitUntilReady();
      setReady(true);
    });
    return () => clearTimeout(timeout);
  }, [
    client,
    spaceKeyLike
  ]);
  if (spaceKeyLike) {
    return spaces.find((space) => space.key.equals(spaceKeyLike) || space.id === spaceKeyLike);
  }
  if (ready && client.halo.identity.get()) {
    return client.spaces.default;
  }
};
var useSpaces = ({ all = false } = {}) => {
  const client = useClient();
  const spaces = useMulticastObservable(client.spaces);
  return spaces.filter((space) => all || space.state.get() === SpaceState.SPACE_READY);
};

// packages/sdk/react-client/src/echo/useMembers.ts
var useMembers = (spaceKey) => {
  const spaces = useSpaces({
    all: true
  });
  const space = spaceKey ? spaces.find((space2) => space2.key.equals(spaceKey)) : void 0;
  const members = useMulticastObservable2(space?.members ?? MulticastObservable.empty()) ?? [];
  return members.filter((member) => member.role !== HaloSpaceMember.Role.REMOVED);
};

// packages/sdk/react-client/src/echo/useQuery.ts
import { useMemo, useSyncExternalStore } from "react";
import { Filter, Query, isSpace } from "@dxos/client/echo";
var EMPTY_ARRAY = [];
var noop = () => {
};
var useQuery = (spaceOrEcho, queryOrFilter, deps) => {
  const query = Filter.is(queryOrFilter) ? Query.select(queryOrFilter) : queryOrFilter;
  const { getObjects, subscribe } = useMemo(() => {
    let subscribed = false;
    const queryResult = spaceOrEcho === void 0 ? void 0 : isSpace(spaceOrEcho) ? spaceOrEcho.db.query(query) : spaceOrEcho.query(query);
    return {
      getObjects: () => subscribed && queryResult ? queryResult.objects : EMPTY_ARRAY,
      subscribe: (cb) => {
        subscribed = true;
        const unsubscribe = queryResult?.subscribe(cb) ?? noop;
        return () => {
          unsubscribe?.();
          subscribed = false;
        };
      }
    };
  }, [
    spaceOrEcho,
    JSON.stringify(query.ast),
    ...deps ?? []
  ]);
  const objects = useSyncExternalStore(subscribe, getObjects);
  return objects ?? [];
};

// packages/sdk/react-client/src/echo/useQueue.ts
import { useEffect as useEffect2, useMemo as useMemo2, useRef } from "react";
import { raise } from "@dxos/debug";
var MIN_POLL_INTERVAL = 1e3;
var useQueue = (queueDxn, options = {}) => {
  const client = useClient();
  const mountedRef = useRef(true);
  const queue = useMemo2(() => {
    if (!queueDxn) {
      return void 0;
    }
    const { spaceId } = queueDxn.asQueueDXN() ?? raise(new TypeError("Invalid queue DXN"));
    return client.spaces.get(spaceId)?.queues.get(queueDxn);
  }, [
    client,
    queueDxn?.toString()
  ]);
  useEffect2(() => {
    void queue?.refresh();
  }, [
    queue
  ]);
  useEffect2(() => {
    let timeout;
    mountedRef.current = true;
    const poll = () => {
      if (!mountedRef.current) {
        return;
      }
      void queue?.refresh().finally(() => {
        if (mountedRef.current && options.pollInterval) {
          timeout = setTimeout(poll, Math.max(options.pollInterval ?? 0, MIN_POLL_INTERVAL));
        }
      });
    };
    if (options.pollInterval) {
      poll();
    }
    return () => {
      mountedRef.current = false;
      clearTimeout(timeout);
    };
  }, [
    queue,
    options.pollInterval
  ]);
  return queue;
};

// packages/sdk/react-client/src/echo/useSchema.ts
import { useMemo as useMemo3, useSyncExternalStore as useSyncExternalStore2 } from "react";
var useSchema = (client, space, typename) => {
  const { subscribe, getSchema } = useMemo3(() => {
    if (!typename || !space) {
      return {
        subscribe: () => () => {
        },
        getSchema: () => void 0
      };
    }
    const staticSchema = client.graph.schemaRegistry.getSchema(typename);
    if (staticSchema) {
      return {
        subscribe: () => () => {
        },
        getSchema: () => staticSchema
      };
    }
    const query = space.db.schemaRegistry.query({
      typename
    });
    const initialResult = query.runSync()[0];
    let currentSchema = initialResult;
    return {
      subscribe: (onStoreChange) => {
        const unsubscribe = query.subscribe(() => {
          currentSchema = query.results[0];
          onStoreChange();
        });
        return unsubscribe;
      },
      getSchema: () => currentSchema
    };
  }, [
    typename,
    space
  ]);
  return useSyncExternalStore2(subscribe, getSchema);
};

// packages/sdk/react-client/src/echo/useSpaceInvitations.ts
import { useMemo as useMemo4 } from "react";
import { MulticastObservable as MulticastObservable2 } from "@dxos/async";
import { useMulticastObservable as useMulticastObservable3 } from "@dxos/react-hooks";
var useSpaceInvitations = (spaceKey) => {
  const space = useSpace(spaceKey);
  return useMulticastObservable3(space?.invitations ?? MulticastObservable2.empty()) ?? [];
};
var useSpaceInvitation = (spaceKey, invitationId) => {
  const invitations = useSpaceInvitations(spaceKey);
  const invitation = useMemo4(() => invitations.find((invitation2) => invitation2.get().invitationId === invitationId), [
    invitations
  ]);
  return useInvitationStatus(invitation);
};

// packages/sdk/react-client/src/echo/useSubscription.ts
import { useEffect as useEffect3, useRef as useRef2 } from "react";
import { createSubscription } from "@dxos/client/echo";
var useSubscription = (cb, selection) => {
  const callbackRef = useRef2(cb);
  callbackRef.current = cb;
  const subscriptionRef = useRef2();
  useEffect3(() => {
    subscriptionRef.current = createSubscription(() => {
      callbackRef.current();
    });
    return () => subscriptionRef.current?.unsubscribe();
  }, []);
  subscriptionRef.current?.update(selection);
  return subscriptionRef.current;
};

// packages/sdk/react-client/src/echo/useSyncState.ts
import { useEffect as useEffect4, useState as useState2 } from "react";
import { Context } from "@dxos/context";
import { EdgeService } from "@dxos/protocols";
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/sdk/react-client/src/echo/useSyncState.ts";
var isEdgePeerId = (peerId, spaceId) => peerId.startsWith(`${EdgeService.AUTOMERGE_REPLICATOR}:${spaceId}`);
var useSyncState = () => {
  const client = useClient();
  const [spaceState, setSpaceState] = useState2({});
  useEffect4(() => {
    const ctx = new Context(void 0, {
      F: __dxlog_file,
      L: 25
    });
    const createSubscriptions = (spaces) => {
      for (const space of spaces) {
        if (spaceState[space.id]) {
          continue;
        }
        ctx.onDispose(space.crud.subscribeToSyncState(ctx, ({ peers = [] }) => {
          const syncState = peers.find((state) => isEdgePeerId(state.peerId, space.id));
          if (syncState) {
            setSpaceState((spaceState2) => ({
              ...spaceState2,
              [space.id]: syncState
            }));
          }
        }));
      }
    };
    createSubscriptions(client.spaces.get());
    client.spaces.subscribe((spaces) => {
      createSubscriptions(spaces);
    });
    return () => {
      void ctx.dispose();
    };
  }, [
    client
  ]);
  return spaceState;
};
var useSpaceSyncState = (space) => {
  const [spaceState, setSpaceState] = useState2();
  useEffect4(() => {
    const ctx = new Context(void 0, {
      F: __dxlog_file,
      L: 64
    });
    space.crud.subscribeToSyncState(ctx, ({ peers = [] }) => {
      const syncState = peers.find((state) => isEdgePeerId(state.peerId, space.id));
      if (syncState) {
        setSpaceState(syncState);
      }
    });
    return () => {
      void ctx.dispose();
    };
  }, [
    space
  ]);
  return spaceState;
};
export {
  useMembers,
  useQuery,
  useQueue,
  useSchema,
  useSpace,
  useSpaceInvitation,
  useSpaceInvitations,
  useSpaceSyncState,
  useSpaces,
  useSubscription,
  useSyncState
};
//# sourceMappingURL=index.mjs.map
