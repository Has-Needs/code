{
  "version": 3,
  "sources": ["../../../../src/testing/index.ts", "../../../../src/testing/context.tsx", "../../../../src/testing/ClientRepeater.tsx", "../../../../src/testing/withClientProvider.tsx"],
  "sourcesContent": ["//\n// Copyright 2020 DXOS.org\n//\n\nexport * from '@dxos/client/testing';\n\nexport * from './context';\nexport * from './ClientRepeater';\nexport * from './withClientProvider';\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { createContext, useContext } from 'react';\n\nimport { type Space } from '@dxos/client/echo';\nimport { raise } from '@dxos/debug';\n\nexport type ClientStory = {\n  space?: Space;\n};\n\n// TODO(wittjosiah): Add to multi-client as well.\nexport const ClientStory = createContext<ClientStory | undefined>(undefined);\n\nexport const useClientProvider = (): ClientStory => {\n  return useContext(ClientStory) ?? raise(new Error('Missing ClientStory'));\n};\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport React, { useState, type FC, useEffect, useRef } from 'react';\n\nimport { Client, type PublicKey } from '@dxos/client';\nimport { TestBuilder, performInvitation } from '@dxos/client/testing';\nimport { type TypedObject } from '@dxos/echo-schema';\nimport { registerSignalsRuntime } from '@dxos/echo-signals/react';\nimport { faker } from '@dxos/random';\n\nimport { type WithClientProviderProps } from './withClientProvider';\nimport { ClientProvider } from '../client';\n\nexport type ClientRepeatedComponentProps = { id: number; count: number; spaceKey?: PublicKey };\n\nexport type ClientRepeaterControlsProps = { clients: Client[] };\n\n// TODO(burdon): Reconcile with ClientProviderProps.\nexport type ClientRepeaterProps<P extends ClientRepeatedComponentProps> = {\n  className?: string;\n  component: FC<ClientRepeatedComponentProps>;\n  controls?: FC<ClientRepeaterControlsProps>;\n  count?: number;\n  clients?: Client[];\n  types?: TypedObject[];\n  args?: Omit<P, 'id' | 'count'>;\n} & Pick<WithClientProviderProps, 'createIdentity' | 'createSpace' | 'onSpaceCreated'>;\n\n/**\n * Utility component for Storybook stories which sets up clients for n peers.\n * The `Component` property is rendered n times, once for each peer.\n * @deprecated use `withClientProvider`.\n */\n// TODO(burdon): To discuss: evolve ClientRepeater with optional decorator that uses it.\n// NOTE: This is specifically not a storybook decorator because it broke stories as a decorator.\n//   This seems primarily due to the fact that it required top-level await for the clients to initialize.\n//   Storybook seemed to handle it alright, but Chromatic had a lot of trouble with it.\n//   There was also a question of whether or not calling the story function multiple times was a good idea.\nexport const ClientRepeater = <P extends ClientRepeatedComponentProps>(props: ClientRepeaterProps<P>) => {\n  const {\n    component: Component,\n    controls: Controls,\n    count = 1,\n    types,\n    createIdentity,\n    createSpace,\n    onSpaceCreated,\n  } = props;\n  useEffect(() => {\n    registerSignalsRuntime();\n  }, []);\n\n  const [clients, setClients] = useState(props.clients ?? []);\n  const [spaceKey, setSpaceKey] = useState<PublicKey>();\n\n  const testBuilder = useRef(new TestBuilder());\n  useEffect(() => {\n    const timeout = setTimeout(async () => {\n      const clients = [...Array(count)].map(\n        (_) => new Client({ services: testBuilder.current.createLocalClientServices(), types }),\n      );\n\n      await Promise.all(clients.map((client) => client.initialize()));\n      if (createIdentity || createSpace) {\n        await Promise.all(clients.map((client) => client.halo.createIdentity()));\n      }\n\n      if (createSpace) {\n        const client = clients[0];\n        const space = await client.spaces.create({ name: faker.commerce.productName() });\n        setSpaceKey(space.key);\n        await onSpaceCreated?.({ client, space }, {});\n        await Promise.all(\n          clients.slice(1).flatMap((client) => performInvitation({ host: space, guest: client.spaces })),\n        );\n      }\n\n      setClients(clients);\n    });\n\n    return () => clearTimeout(timeout);\n  }, []);\n\n  if (clients.length === 0) {\n    return null;\n  }\n\n  return (\n    <>\n      {Controls && <Controls clients={clients} />}\n      {clients.map((client, index) => (\n        <ClientProvider key={index} client={client}>\n          <Component id={index} count={clients.length} spaceKey={spaceKey} {...{ ...props.args }} />\n        </ClientProvider>\n      ))}\n    </>\n  );\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { type StoryContext, type Decorator } from '@storybook/react';\nimport React, { createContext, type PropsWithChildren, useContext, useEffect, useRef, useState } from 'react';\nimport { type FallbackProps, ErrorBoundary as NativeErrorBoundary } from 'react-error-boundary';\n\nimport { Trigger } from '@dxos/async';\nimport { type Client } from '@dxos/client';\nimport { type Space } from '@dxos/client/echo';\nimport { performInvitation, TestBuilder } from '@dxos/client/testing';\nimport { log } from '@dxos/log';\nimport { type MaybePromise } from '@dxos/util';\n\nimport { ClientStory } from './context';\nimport { ClientProvider, type ClientProviderProps } from '../client';\n\ntype InitializeProps = {\n  createIdentity?: boolean;\n  createSpace?: boolean;\n  onInitialized?: (client: Client) => MaybePromise<void>;\n  onIdentityCreated?: (props: { client: Client }) => MaybePromise<void>;\n  // NOTE: context must be untyped until ClientRepeater is removed.\n  onSpaceCreated?: (props: { client: Client; space: Space }, context: StoryContext | any) => MaybePromise<void>;\n};\n\n/**\n * Initialize client, identity and first space.\n */\nconst initializeClient = async (\n  client: Client,\n  { createIdentity, createSpace, onSpaceCreated, onIdentityCreated, onInitialized }: InitializeProps,\n  context: StoryContext,\n): Promise<ClientStory> => {\n  await onInitialized?.(client);\n\n  if (createIdentity || createSpace) {\n    if (!client.halo.identity.get()) {\n      await client.halo.createIdentity();\n      await onIdentityCreated?.({ client });\n    }\n  }\n\n  let space: Space | undefined;\n  if (createSpace) {\n    space = await client.spaces.create({ name: 'Test Space' });\n    await onSpaceCreated?.({ client, space }, context);\n  }\n\n  return { space };\n};\n\nexport type WithClientProviderProps = InitializeProps & Omit<ClientProviderProps, 'onInitialized'>;\n\n/**\n * Decorator that provides the client context.\n */\nexport const withClientProvider = ({\n  createIdentity,\n  createSpace,\n  onSpaceCreated,\n  onIdentityCreated,\n  onInitialized,\n  ...props\n}: WithClientProviderProps = {}): Decorator => {\n  return (Story, context) => {\n    const [data, setData] = useState<ClientStory>({});\n    const handleInitialized = async (client: Client) => {\n      const data = await initializeClient(\n        client,\n        {\n          createIdentity,\n          createSpace,\n          onSpaceCreated,\n          onIdentityCreated,\n          onInitialized,\n        },\n        context,\n      );\n\n      setData(data);\n    };\n\n    return (\n      <ErrorBoundary>\n        <ClientProvider onInitialized={handleInitialized} {...props}>\n          <ClientStory.Provider value={data}>\n            <Story />\n          </ClientStory.Provider>\n        </ClientProvider>\n      </ErrorBoundary>\n    );\n  };\n};\n\n// TODO(burdon): Implement context per client for context.\n// TODO(burdon): Callback once all invitations have completed.\n// TODO(burdon): Delay/jitter for creation of other clients.\nexport type WithMultiClientProviderProps = InitializeProps &\n  Omit<ClientProviderProps, 'onInitialized'> & { numClients?: number };\n\nconst MultiClientContext = createContext<{ id: number }>({ id: 0 });\n\nexport const useMultiClient = () => useContext(MultiClientContext);\n\n/**\n * Decorator that creates a scaffold for multiple clients.\n * Orchestrates invitations between a randomly selected host and the remaining clients.\n * NOTE: Should come before withLayout.\n */\nexport const withMultiClientProvider = ({\n  numClients = 2,\n  createIdentity,\n  createSpace,\n  onSpaceCreated,\n  onIdentityCreated,\n  onInitialized,\n  ...props\n}: WithMultiClientProviderProps): Decorator => {\n  return (Story, context) => {\n    const builder = useRef(new TestBuilder());\n    const hostRef = useRef<Client>();\n    const spaceReady = useRef(new Trigger<Space | undefined>());\n\n    // Handle invitations.\n    // NOTE: The zeroth client isn't necessarily the first to be initialized.\n    const handleInitialized = async (client: Client, index: number) => {\n      log.info('initialized', { index });\n      if (createSpace) {\n        if (!hostRef.current) {\n          hostRef.current = client;\n          const { space } = await initializeClient(\n            client,\n            {\n              createIdentity,\n              createSpace,\n              onSpaceCreated,\n              onIdentityCreated,\n              onInitialized,\n            },\n            context,\n          );\n\n          spaceReady.current.wake(space);\n          log.info('inviting', { index });\n        } else {\n          await initializeClient(client, { createIdentity, onInitialized }, context);\n          const space = await spaceReady.current.wait();\n          if (space) {\n            log.info('joining', { index });\n            await Promise.all(performInvitation({ host: space, guest: client.spaces }));\n          }\n        }\n      }\n    };\n\n    return (\n      <ErrorBoundary>\n        {Array.from({ length: numClients }).map((_, index) => (\n          <MultiClientContext.Provider key={index} value={{ id: index }}>\n            <ClientProvider\n              services={builder.current.createLocalClientServices()}\n              onInitialized={(client) => handleInitialized(client, index)}\n              {...props}\n            >\n              <Story />\n            </ClientProvider>\n          </MultiClientContext.Provider>\n        ))}\n      </ErrorBoundary>\n    );\n  };\n};\n\nconst ErrorBoundary = ({ children }: PropsWithChildren) => {\n  const [error, setError] = useState<Error>();\n  useEffect(() => {\n    const handleError = (event: PromiseRejectionEvent) => {\n      setError(event.reason);\n    };\n\n    window.addEventListener('unhandledrejection', handleError);\n    return () => window.removeEventListener('unhandledrejection', handleError);\n  }, []);\n\n  if (error) {\n    return <ErrorFallback error={error} resetErrorBoundary={() => setError(undefined)} />;\n  }\n\n  return <NativeErrorBoundary FallbackComponent={ErrorFallback}>{children}</NativeErrorBoundary>;\n};\n\nconst ErrorFallback = ({ error }: FallbackProps) => {\n  const { name, message, stack } =\n    error instanceof Error ? error : { name: 'Error', message: String(error), stack: undefined };\n  return (\n    <div role='alert' className='flex flex-col p-4 gap-4 overflow-auto'>\n      <h1 className='text-xl text-red-500'>{name}</h1>\n      <div className='text-lg'>{message}</div>\n      {stack && <pre className='whitespace-pre-wrap text-sm text-subdued'>{stack}</pre>}\n    </div>\n  );\n};\n"],
  "mappings": "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",
  "names": ["createContext", "useContext", "raise", "ClientStory", "createContext", "undefined", "useClientProvider", "useContext", "raise", "Error", "React", "useState", "useEffect", "useRef", "Client", "TestBuilder", "performInvitation", "registerSignalsRuntime", "faker", "ClientRepeater", "props", "component", "Component", "controls", "Controls", "count", "types", "createIdentity", "createSpace", "onSpaceCreated", "useEffect", "registerSignalsRuntime", "clients", "setClients", "useState", "spaceKey", "setSpaceKey", "testBuilder", "useRef", "TestBuilder", "timeout", "setTimeout", "Array", "map", "_", "Client", "services", "current", "createLocalClientServices", "Promise", "all", "client", "initialize", "halo", "space", "spaces", "create", "name", "faker", "commerce", "productName", "key", "slice", "flatMap", "performInvitation", "host", "guest", "clearTimeout", "length", "index", "ClientProvider", "id", "args", "React", "createContext", "useContext", "useEffect", "useRef", "useState", "ErrorBoundary", "NativeErrorBoundary", "Trigger", "performInvitation", "TestBuilder", "log", "initializeClient", "client", "createIdentity", "createSpace", "onSpaceCreated", "onIdentityCreated", "onInitialized", "context", "halo", "identity", "get", "space", "spaces", "create", "name", "withClientProvider", "props", "Story", "data", "setData", "useState", "handleInitialized", "React", "ErrorBoundary", "ClientProvider", "ClientStory", "Provider", "value", "MultiClientContext", "createContext", "id", "useMultiClient", "useContext", "withMultiClientProvider", "numClients", "builder", "useRef", "TestBuilder", "hostRef", "spaceReady", "Trigger", "index", "log", "info", "current", "wake", "wait", "Promise", "all", "performInvitation", "host", "guest", "Array", "from", "length", "map", "_", "key", "services", "createLocalClientServices", "children", "error", "setError", "useEffect", "handleError", "event", "reason", "window", "addEventListener", "removeEventListener", "ErrorFallback", "resetErrorBoundary", "undefined", "NativeErrorBoundary", "FallbackComponent", "message", "stack", "Error", "String", "div", "role", "className", "h1", "pre"]
}
