import { createRequire } from 'node:module';const require = createRequire(import.meta.url);
import {
  ClientProvider
} from "../chunk-NBTZZNQ5.mjs";

// packages/sdk/react-client/src/testing/index.ts
export * from "@dxos/client/testing";

// packages/sdk/react-client/src/testing/context.tsx
import { createContext, useContext } from "react";
import { raise } from "@dxos/debug";
var ClientStory = /* @__PURE__ */ createContext(void 0);
var useClientProvider = () => {
  return useContext(ClientStory) ?? raise(new Error("Missing ClientStory"));
};

// packages/sdk/react-client/src/testing/ClientRepeater.tsx
import React, { useState, useEffect, useRef } from "react";
import { Client } from "@dxos/client";
import { TestBuilder, performInvitation } from "@dxos/client/testing";
import { registerSignalsRuntime } from "@dxos/echo-signals/react";
import { faker } from "@dxos/random";
var ClientRepeater = (props) => {
  const { component: Component, controls: Controls, count = 1, types, createIdentity, createSpace, onSpaceCreated } = props;
  useEffect(() => {
    registerSignalsRuntime();
  }, []);
  const [clients, setClients] = useState(props.clients ?? []);
  const [spaceKey, setSpaceKey] = useState();
  const testBuilder = useRef(new TestBuilder());
  useEffect(() => {
    const timeout = setTimeout(async () => {
      const clients2 = [
        ...Array(count)
      ].map((_) => new Client({
        services: testBuilder.current.createLocalClientServices(),
        types
      }));
      await Promise.all(clients2.map((client) => client.initialize()));
      if (createIdentity || createSpace) {
        await Promise.all(clients2.map((client) => client.halo.createIdentity()));
      }
      if (createSpace) {
        const client = clients2[0];
        const space = await client.spaces.create({
          name: faker.commerce.productName()
        });
        setSpaceKey(space.key);
        await onSpaceCreated?.({
          client,
          space
        }, {});
        await Promise.all(clients2.slice(1).flatMap((client2) => performInvitation({
          host: space,
          guest: client2.spaces
        })));
      }
      setClients(clients2);
    });
    return () => clearTimeout(timeout);
  }, []);
  if (clients.length === 0) {
    return null;
  }
  return /* @__PURE__ */ React.createElement(React.Fragment, null, Controls && /* @__PURE__ */ React.createElement(Controls, {
    clients
  }), clients.map((client, index) => /* @__PURE__ */ React.createElement(ClientProvider, {
    key: index,
    client
  }, /* @__PURE__ */ React.createElement(Component, {
    id: index,
    count: clients.length,
    spaceKey,
    ...props.args
  }))));
};

// packages/sdk/react-client/src/testing/withClientProvider.tsx
import React2, { createContext as createContext2, useContext as useContext2, useEffect as useEffect2, useRef as useRef2, useState as useState2 } from "react";
import { ErrorBoundary as NativeErrorBoundary } from "react-error-boundary";
import { Trigger } from "@dxos/async";
import { performInvitation as performInvitation2, TestBuilder as TestBuilder2 } from "@dxos/client/testing";
import { log } from "@dxos/log";
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/sdk/react-client/src/testing/withClientProvider.tsx";
var initializeClient = async (client, { createIdentity, createSpace, onSpaceCreated, onIdentityCreated, onInitialized }, context) => {
  await onInitialized?.(client);
  if (createIdentity || createSpace) {
    if (!client.halo.identity.get()) {
      await client.halo.createIdentity();
      await onIdentityCreated?.({
        client
      });
    }
  }
  let space;
  if (createSpace) {
    space = await client.spaces.create({
      name: "Test Space"
    });
    await onSpaceCreated?.({
      client,
      space
    }, context);
  }
  return {
    space
  };
};
var withClientProvider = ({ createIdentity, createSpace, onSpaceCreated, onIdentityCreated, onInitialized, ...props } = {}) => {
  return (Story, context) => {
    const [data, setData] = useState2({});
    const handleInitialized = async (client) => {
      const data2 = await initializeClient(client, {
        createIdentity,
        createSpace,
        onSpaceCreated,
        onIdentityCreated,
        onInitialized
      }, context);
      setData(data2);
    };
    return /* @__PURE__ */ React2.createElement(ErrorBoundary, null, /* @__PURE__ */ React2.createElement(ClientProvider, {
      onInitialized: handleInitialized,
      ...props
    }, /* @__PURE__ */ React2.createElement(ClientStory.Provider, {
      value: data
    }, /* @__PURE__ */ React2.createElement(Story, null))));
  };
};
var MultiClientContext = /* @__PURE__ */ createContext2({
  id: 0
});
var useMultiClient = () => useContext2(MultiClientContext);
var withMultiClientProvider = ({ numClients = 2, createIdentity, createSpace, onSpaceCreated, onIdentityCreated, onInitialized, ...props }) => {
  return (Story, context) => {
    const builder = useRef2(new TestBuilder2());
    const hostRef = useRef2();
    const spaceReady = useRef2(new Trigger());
    const handleInitialized = async (client, index) => {
      log.info("initialized", {
        index
      }, {
        F: __dxlog_file,
        L: 129,
        S: void 0,
        C: (f, a) => f(...a)
      });
      if (createSpace) {
        if (!hostRef.current) {
          hostRef.current = client;
          const { space } = await initializeClient(client, {
            createIdentity,
            createSpace,
            onSpaceCreated,
            onIdentityCreated,
            onInitialized
          }, context);
          spaceReady.current.wake(space);
          log.info("inviting", {
            index
          }, {
            F: __dxlog_file,
            L: 146,
            S: void 0,
            C: (f, a) => f(...a)
          });
        } else {
          await initializeClient(client, {
            createIdentity,
            onInitialized
          }, context);
          const space = await spaceReady.current.wait();
          if (space) {
            log.info("joining", {
              index
            }, {
              F: __dxlog_file,
              L: 151,
              S: void 0,
              C: (f, a) => f(...a)
            });
            await Promise.all(performInvitation2({
              host: space,
              guest: client.spaces
            }));
          }
        }
      }
    };
    return /* @__PURE__ */ React2.createElement(ErrorBoundary, null, Array.from({
      length: numClients
    }).map((_, index) => /* @__PURE__ */ React2.createElement(MultiClientContext.Provider, {
      key: index,
      value: {
        id: index
      }
    }, /* @__PURE__ */ React2.createElement(ClientProvider, {
      services: builder.current.createLocalClientServices(),
      onInitialized: (client) => handleInitialized(client, index),
      ...props
    }, /* @__PURE__ */ React2.createElement(Story, null)))));
  };
};
var ErrorBoundary = ({ children }) => {
  const [error, setError] = useState2();
  useEffect2(() => {
    const handleError = (event) => {
      setError(event.reason);
    };
    window.addEventListener("unhandledrejection", handleError);
    return () => window.removeEventListener("unhandledrejection", handleError);
  }, []);
  if (error) {
    return /* @__PURE__ */ React2.createElement(ErrorFallback, {
      error,
      resetErrorBoundary: () => setError(void 0)
    });
  }
  return /* @__PURE__ */ React2.createElement(NativeErrorBoundary, {
    FallbackComponent: ErrorFallback
  }, children);
};
var ErrorFallback = ({ error }) => {
  const { name, message, stack } = error instanceof Error ? error : {
    name: "Error",
    message: String(error),
    stack: void 0
  };
  return /* @__PURE__ */ React2.createElement("div", {
    role: "alert",
    className: "flex flex-col p-4 gap-4 overflow-auto"
  }, /* @__PURE__ */ React2.createElement("h1", {
    className: "text-xl text-red-500"
  }, name), /* @__PURE__ */ React2.createElement("div", {
    className: "text-lg"
  }, message), stack && /* @__PURE__ */ React2.createElement("pre", {
    className: "whitespace-pre-wrap text-sm text-subdued"
  }, stack));
};
export {
  ClientRepeater,
  ClientStory,
  useClientProvider,
  useMultiClient,
  withClientProvider,
  withMultiClientProvider
};
//# sourceMappingURL=index.mjs.map
