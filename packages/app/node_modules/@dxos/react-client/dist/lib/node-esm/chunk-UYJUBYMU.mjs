import { createRequire } from 'node:module';const require = createRequire(import.meta.url);

// packages/sdk/react-client/src/invitations/index.ts
import { AuthenticatingInvitationObservable, CancellableInvitationObservable, InvitationEncoder as InvitationEncoder2, Invitation as Invitation2, InvitationsProxy } from "@dxos/client/invitations";

// packages/sdk/react-client/src/invitations/useInvitationStatus.ts
import { useReducer, useMemo, useCallback, useEffect } from "react";
import { Invitation, InvitationEncoder } from "@dxos/client/invitations";
import { log } from "@dxos/log";
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/sdk/react-client/src/invitations/useInvitationStatus.ts";
var isShareableInvitation = (invitation) => invitation.authMethod !== Invitation.AuthMethod.KNOWN_PUBLIC_KEY || invitation.guestKeypair?.privateKey;
var useInvitationStatus = (observable) => {
  const [state, dispatch] = useReducer((prev, action) => {
    log("useInvitationStatus", {
      action
    }, {
      F: __dxlog_file,
      L: 90,
      S: void 0,
      C: (f, a) => f(...a)
    });
    const invitationProps = "invitation" in action ? {
      id: action.invitation.invitationId,
      multiUse: action.invitation.multiUse,
      invitationCode: InvitationEncoder.encode(action.invitation),
      authCode: action.invitation.authCode,
      authMethod: action.invitation.authMethod,
      shareable: isShareableInvitation(action.invitation),
      type: action.invitation.type
    } : {};
    return {
      ...prev,
      ...invitationProps,
      // TODO(burdon): State.
      status: action.status,
      // `invitationObservable`, `secret`, and `result` is persisted between the status-actions that set them.
      result: action.status === Invitation.State.SUCCESS ? action.result : prev.result,
      // `error` gets set each time we enter the error state
      ...action.status === Invitation.State.ERROR && {
        error: action.error
      },
      // `haltedAt` gets set on only the first error/cancelled/timeout action and reset on any others.
      ...(action.status === Invitation.State.ERROR || action.status === Invitation.State.CANCELLED || action.status === Invitation.State.TIMEOUT) && {
        haltedAt: typeof prev.haltedAt === "undefined" ? action.haltedAt : prev.haltedAt
      }
    };
  }, null, (_arg) => {
    const invitation = observable?.get();
    return {
      status: Invitation.State.INIT,
      result: {
        spaceKey: null,
        identityKey: null,
        swarmKey: null,
        target: null
      },
      id: invitation?.invitationId,
      multiUse: invitation?.multiUse,
      invitationCode: invitation ? InvitationEncoder.encode(invitation) : void 0,
      authCode: invitation?.authCode,
      authMethod: invitation?.authMethod,
      shareable: invitation ? isShareableInvitation(invitation) : false,
      type: invitation?.type
    };
  });
  useEffect(() => {
    const update = (invitation) => {
      switch (invitation.state) {
        case Invitation.State.INIT:
        case Invitation.State.CONNECTED:
        case Invitation.State.READY_FOR_AUTHENTICATION:
        case Invitation.State.AUTHENTICATING: {
          dispatch({
            invitation,
            status: invitation.state
          });
          break;
        }
        case Invitation.State.SUCCESS: {
          dispatch({
            invitation,
            status: invitation.state,
            result: {
              spaceKey: invitation.spaceKey || null,
              identityKey: invitation.identityKey || null,
              swarmKey: invitation.swarmKey || null,
              target: invitation.target || null
            }
          });
          break;
        }
        case Invitation.State.CANCELLED:
        case Invitation.State.TIMEOUT: {
          dispatch({
            invitation,
            status: invitation.state,
            haltedAt: state.status
          });
          break;
        }
      }
    };
    const subscription = observable?.subscribe(update, (err) => {
      dispatch({
        status: Invitation.State.ERROR,
        error: err,
        haltedAt: state.status
      });
    });
    const currentState = observable?.get();
    if (currentState) {
      update(currentState);
    }
    return () => subscription?.unsubscribe();
  }, [
    observable,
    state.status
  ]);
  const connect = useCallback((observable2) => {
    dispatch({
      invitation: observable2.get(),
      status: Invitation.State.CONNECTING,
      observable: observable2
    });
  }, []);
  const authenticate = useCallback((authCode) => {
    log("authenticating...", {
      authCode
    }, {
      F: __dxlog_file,
      L: 195,
      S: void 0,
      C: (f, a) => f(...a)
    });
    return observable.authenticate(authCode);
  }, [
    observable
  ]);
  const cancel = useCallback(async () => observable?.cancel(), [
    observable
  ]);
  return useMemo(() => {
    return {
      ...state,
      cancel,
      connect,
      authenticate
    };
  }, [
    state,
    cancel,
    connect,
    authenticate
  ]);
};

export {
  useInvitationStatus,
  AuthenticatingInvitationObservable,
  CancellableInvitationObservable,
  InvitationEncoder2 as InvitationEncoder,
  Invitation2 as Invitation,
  InvitationsProxy
};
//# sourceMappingURL=chunk-UYJUBYMU.mjs.map
