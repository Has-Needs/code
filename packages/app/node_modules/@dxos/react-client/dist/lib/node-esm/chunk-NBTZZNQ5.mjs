import { createRequire } from 'node:module';const require = createRequire(import.meta.url);

// packages/sdk/react-client/src/client/AgentHostingProvider.tsx
import React2, { createContext as createContext2, useContext as useContext4, useState as useState4 } from "react";
import { AgentManagerClient, FakeAgentHostingProvider } from "@dxos/client";
import { log as log2 } from "@dxos/log";

// packages/sdk/react-client/src/client/ClientProvider.tsx
import React, { forwardRef, useEffect, useImperativeHandle, useState } from "react";
import { Client, SystemStatus } from "@dxos/client";
import { registerSignalsRuntime } from "@dxos/echo-signals/react";
import { log } from "@dxos/log";
import { useControlledState } from "@dxos/react-hooks";
import { getAsyncProviderValue } from "@dxos/util";

// packages/sdk/react-client/src/client/context.ts
import { createContext } from "react";
var ClientContext = createContext(void 0);

// packages/sdk/react-client/src/banner.ts
var BANNER = (client) => {
  const commitHash = client.config.get("runtime.app.build.commitHash");
  const hash = commitHash ? ` App Commit ${commitHash} 
` : "";
  return `
_/\\/\\/\\/\\/\\____/\\/\\____/\\/\\____/\\/\\/\\/\\______/\\/\\/\\/\\/\\_
_/\\/\\____/\\/\\____/\\/\\/\\/\\____/\\/\\____/\\/\\__/\\/\\_________
_/\\/\\____/\\/\\______/\\/\\______/\\/\\____/\\/\\____/\\/\\/\\/\\___
_/\\/\\____/\\/\\____/\\/\\/\\/\\____/\\/\\____/\\/\\__________/\\/\\_
_/\\/\\/\\/\\/\\____/\\/\\____/\\/\\____/\\/\\/\\/\\____/\\/\\/\\/\\/\\___

 DXOS Client ${client.version} 
${hash}`;
};
var bannerPrinted = false;
var printBanner = (client) => {
  if (bannerPrinted || window.location.hostname === "localhost") {
    return;
  }
  bannerPrinted = true;
  console.log(`%c${BANNER(client)}`, "font-family: monospace;");
};

// packages/sdk/react-client/src/client/ClientProvider.tsx
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/sdk/react-client/src/client/ClientProvider.tsx";
var ClientProvider = /* @__PURE__ */ forwardRef(({ children, config: configProvider, client: clientProvider, services: servicesProvider, status: controlledStatus, fallback: Fallback = () => null, signalsRuntime = true, noBanner, onInitialized, ...options }, forwardedRef) => {
  useEffect(() => {
    signalsRuntime && registerSignalsRuntime();
  }, []);
  const [error, setError] = useState();
  if (error) {
    throw error;
  }
  const [client, setClient] = useState(clientProvider instanceof Client ? clientProvider : void 0);
  useImperativeHandle(forwardedRef, () => client, [
    client
  ]);
  const [status, setStatus] = useControlledState(controlledStatus);
  useEffect(() => {
    if (!client) {
      return;
    }
    const subscription = client.status.subscribe((status2) => setStatus(status2));
    return () => subscription.unsubscribe();
  }, [
    client
  ]);
  useEffect(() => {
    let disposed = false;
    const initialize = async (client3) => {
      if (!client3.initialized) {
        await client3.initialize().catch((err) => {
          if (!disposed) {
            setError(err);
          }
        });
        log("client ready", void 0, {
          F: __dxlog_file,
          L: 137,
          S: void 0,
          C: (f, a) => f(...a)
        });
        await onInitialized?.(client3);
        log("initialization complete", void 0, {
          F: __dxlog_file,
          L: 139,
          S: void 0,
          C: (f, a) => f(...a)
        });
      }
      setClient(client3);
      if (!noBanner) {
        printBanner(client3);
      }
    };
    let client2;
    const t = setTimeout(async () => {
      try {
        if (clientProvider) {
          client2 = await getAsyncProviderValue(clientProvider);
          await initialize(client2);
        } else {
          const config = await getAsyncProviderValue(configProvider);
          log("resolved config", {
            config
          }, {
            F: __dxlog_file,
            L: 159,
            S: void 0,
            C: (f, a) => f(...a)
          });
          const services = await getAsyncProviderValue(servicesProvider, config);
          log("created services", {
            services
          }, {
            F: __dxlog_file,
            L: 161,
            S: void 0,
            C: (f, a) => f(...a)
          });
          client2 = new Client({
            config,
            services,
            ...options
          });
          log("created client", void 0, {
            F: __dxlog_file,
            L: 163,
            S: void 0,
            C: (f, a) => f(...a)
          });
          await initialize(client2);
        }
      } catch (err) {
        if (!disposed) {
          log.catch(err, void 0, {
            F: __dxlog_file,
            L: 168,
            S: void 0,
            C: (f, a) => f(...a)
          });
        }
      }
    });
    return () => {
      log("clean up", void 0, {
        F: __dxlog_file,
        L: 174,
        S: void 0,
        C: (f, a) => f(...a)
      });
      disposed = true;
      clearTimeout(t);
      if (!clientProvider) {
        void client2?.destroy().then(() => {
          log("destroyed", void 0, {
            F: __dxlog_file,
            L: 182,
            S: void 0,
            C: (f, a) => f(...a)
          });
        }).catch((err) => log.catch(err, void 0, {
          F: __dxlog_file,
          L: 184,
          S: void 0,
          C: (f, a) => f(...a)
        }));
      }
    };
  }, [
    configProvider,
    clientProvider,
    servicesProvider,
    noBanner
  ]);
  if (!client?.initialized || status !== SystemStatus.ACTIVE) {
    return /* @__PURE__ */ React.createElement(Fallback, {
      client,
      status
    });
  }
  return /* @__PURE__ */ React.createElement(ClientContext.Provider, {
    value: {
      client,
      status
    }
  }, children);
});

// packages/sdk/react-client/src/client/useClient.ts
import { useContext } from "react";
import { raise } from "@dxos/debug";
var useClient = () => {
  const { client } = useContext(ClientContext) ?? raise(new Error("Missing ClientContext."));
  return client;
};

// packages/sdk/react-client/src/client/useClientStatus.ts
import { useEffect as useEffect2, useState as useState2 } from "react";
var useClientStatus = (client) => {
  const [status, setStatus] = useState2();
  useEffect2(() => {
    if (!client) {
      return;
    }
    const subscription = client.status.subscribe((status2) => setStatus(status2));
    return () => subscription.unsubscribe();
  }, [
    client,
    setStatus
  ]);
  return status;
};

// packages/sdk/react-client/src/client/useConfig.ts
import { useContext as useContext2 } from "react";
import { raise as raise2 } from "@dxos/debug";
var useConfig = () => {
  const { client } = useContext2(ClientContext) ?? raise2(new Error("Missing ClientContext."));
  return client.config;
};

// packages/sdk/react-client/src/client/useShell.ts
import { useEffect as useEffect3, useState as useState3 } from "react";
var useShell = () => {
  const client = useClient();
  return client.shell;
};
var useShellDisplay = () => {
  const client = useClient();
  const [display, setDisplay] = useState3(client.shell.display);
  useEffect3(() => client.shell.onDisplayChange(setDisplay), [
    client
  ]);
  return display;
};

// packages/sdk/react-client/src/client/useStatus.ts
import { useContext as useContext3 } from "react";
import { raise as raise3 } from "@dxos/debug";
var useStatus = () => {
  const { status } = useContext3(ClientContext) ?? raise3(new Error("Missing ClientContext."));
  return status;
};

// packages/sdk/react-client/src/client/AgentHostingProvider.tsx
var __dxlog_file2 = "/home/runner/work/dxos/dxos/packages/sdk/react-client/src/client/AgentHostingProvider.tsx";
var AgentHostingContext = /* @__PURE__ */ createContext2(null);
var AgentHostingProvider = (props) => {
  const client = useClient();
  const [agentHostingProviderClient] = useState4(makeClient(client));
  return /* @__PURE__ */ React2.createElement(AgentHostingContext.Provider, {
    value: agentHostingProviderClient
  }, " ", props.children);
};
var useAgentHostingClient = () => {
  return useContext4(AgentHostingContext);
};
var makeClient = ({ config, halo }) => {
  const agentHostingConfig = config.get("runtime.services.agentHosting");
  if (!agentHostingConfig) {
    log2("no agent hosting configured", void 0, {
      F: __dxlog_file2,
      L: 39,
      S: void 0,
      C: (f, a) => f(...a)
    });
    return null;
  }
  let agentHostingProviderClient = null;
  switch (agentHostingConfig.type) {
    case "LOCAL_TESTING": {
      log2("using FakeAgentHostingProvider", void 0, {
        F: __dxlog_file2,
        L: 47,
        S: void 0,
        C: (f, a) => f(...a)
      });
      return new FakeAgentHostingProvider();
    }
    case "AGENTHOSTING_API": {
      agentHostingProviderClient = new AgentManagerClient(config, halo);
      if (agentHostingProviderClient.init()) {
        return agentHostingProviderClient;
      } else {
        return null;
      }
    }
    default: {
      log2.error("Unknown agent hosting provider type: " + agentHostingConfig.type, void 0, {
        F: __dxlog_file2,
        L: 62,
        S: void 0,
        C: (f, a) => f(...a)
      });
      return null;
    }
  }
};

export {
  AgentHostingContext,
  AgentHostingProvider,
  useAgentHostingClient,
  ClientContext,
  ClientProvider,
  useClient,
  useClientStatus,
  useConfig,
  useShell,
  useShellDisplay,
  useStatus
};
//# sourceMappingURL=chunk-NBTZZNQ5.mjs.map
