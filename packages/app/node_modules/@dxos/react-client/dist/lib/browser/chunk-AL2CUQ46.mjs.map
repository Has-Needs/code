{
  "version": 3,
  "sources": ["../../../src/invitations/index.ts", "../../../src/invitations/useInvitationStatus.ts"],
  "sourcesContent": ["//\n// Copyright 2020 DXOS.org\n//\n\n// NOTE: Export * fails here.\nexport {\n  AuthenticatingInvitationObservable,\n  CancellableInvitationObservable,\n  InvitationEncoder,\n  Invitation,\n  type Invitations,\n  InvitationsProxy,\n} from '@dxos/client/invitations';\n\nexport * from './useInvitationStatus';\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { useReducer, type Reducer, useMemo, useCallback, useEffect } from 'react';\n\nimport { type PublicKey } from '@dxos/client';\nimport {\n  type AuthenticatingInvitationObservable,\n  type CancellableInvitationObservable,\n  Invitation,\n  InvitationEncoder,\n} from '@dxos/client/invitations';\nimport { log } from '@dxos/log';\n\nexport type InvitationResult = {\n  spaceKey: PublicKey | null;\n  identityKey: PublicKey | null;\n  swarmKey: PublicKey | null;\n  target: string | null;\n};\n\ninterface InvitationReducerState {\n  status: Invitation.State; // TODO(burdon): Rename state.\n  haltedAt?: Invitation.State;\n  result: InvitationResult;\n  error?: number;\n  id?: string;\n  multiUse?: boolean;\n  invitationCode?: string;\n  authCode?: string;\n  authMethod?: Invitation.AuthMethod;\n  type?: Invitation.Type;\n}\n\ntype InvitationPayload = { invitation: Invitation };\n\nexport type InvitationAction =\n  | ({\n      status:\n        | Invitation.State.INIT\n        | Invitation.State.CONNECTED\n        | Invitation.State.READY_FOR_AUTHENTICATION\n        | Invitation.State.AUTHENTICATING;\n    } & InvitationPayload)\n  | ({\n      status: Invitation.State.CONNECTING;\n      observable: CancellableInvitationObservable;\n    } & InvitationPayload)\n  | ({\n      status: Invitation.State.SUCCESS;\n      result: InvitationResult;\n    } & InvitationPayload)\n  | ({\n      status: Invitation.State.CANCELLED | Invitation.State.TIMEOUT;\n      haltedAt: Invitation.State;\n    } & InvitationPayload)\n  | {\n      status: Invitation.State.ERROR;\n      error?: Error;\n      haltedAt: Invitation.State;\n    };\n\nexport type InvitationStatus = {\n  id?: string;\n  invitationCode?: string;\n  authCode?: string;\n  authMethod?: Invitation.AuthMethod;\n  type?: Invitation.Type;\n  status: Invitation.State;\n  haltedAt?: Invitation.State;\n  multiUse?: boolean;\n  shareable?: boolean;\n  result: InvitationResult;\n  error?: number;\n  cancel(): void;\n  // TODO(wittjosiah): Remove?\n  connect(observable: CancellableInvitationObservable): void;\n  authenticate(authCode: string): Promise<void>;\n};\n\n// Without private key, the invitation code cannot be created.\n// These invitations are only available to be accepted but not shared.\nconst isShareableInvitation = (invitation: Invitation) =>\n  invitation.authMethod !== Invitation.AuthMethod.KNOWN_PUBLIC_KEY || invitation.guestKeypair?.privateKey;\n\nexport const useInvitationStatus = (observable?: CancellableInvitationObservable): InvitationStatus => {\n  const [state, dispatch] = useReducer<Reducer<InvitationReducerState, InvitationAction>, null>(\n    (prev, action) => {\n      log('useInvitationStatus', { action });\n      const invitationProps =\n        'invitation' in action\n          ? {\n              id: action.invitation.invitationId,\n              multiUse: action.invitation.multiUse,\n              invitationCode: InvitationEncoder.encode(action.invitation),\n              authCode: action.invitation.authCode,\n              authMethod: action.invitation.authMethod,\n              shareable: isShareableInvitation(action.invitation),\n              type: action.invitation.type,\n            }\n          : {};\n      return {\n        ...prev,\n        ...invitationProps,\n        // TODO(burdon): State.\n        status: action.status,\n        // `invitationObservable`, `secret`, and `result` is persisted between the status-actions that set them.\n        result: action.status === Invitation.State.SUCCESS ? action.result : prev.result,\n        // `error` gets set each time we enter the error state\n        ...(action.status === Invitation.State.ERROR && { error: action.error }),\n        // `haltedAt` gets set on only the first error/cancelled/timeout action and reset on any others.\n        ...((action.status === Invitation.State.ERROR ||\n          action.status === Invitation.State.CANCELLED ||\n          action.status === Invitation.State.TIMEOUT) && {\n          haltedAt: typeof prev.haltedAt === 'undefined' ? action.haltedAt : prev.haltedAt,\n        }),\n      } as InvitationReducerState;\n    },\n    null,\n    (_arg: null) => {\n      const invitation = observable?.get();\n      return {\n        status: Invitation.State.INIT,\n        result: { spaceKey: null, identityKey: null, swarmKey: null, target: null },\n        id: invitation?.invitationId,\n        multiUse: invitation?.multiUse,\n        invitationCode: invitation ? InvitationEncoder.encode(invitation) : undefined,\n        authCode: invitation?.authCode,\n        authMethod: invitation?.authMethod,\n        shareable: invitation ? isShareableInvitation(invitation) : false,\n        type: invitation?.type,\n      };\n    },\n  );\n\n  // Handle unmount.\n\n  useEffect(() => {\n    const update = (invitation: Invitation) => {\n      switch (invitation.state) {\n        case Invitation.State.INIT:\n        case Invitation.State.CONNECTED:\n        case Invitation.State.READY_FOR_AUTHENTICATION:\n        case Invitation.State.AUTHENTICATING: {\n          dispatch({\n            invitation,\n            status: invitation.state,\n          });\n          break;\n        }\n\n        case Invitation.State.SUCCESS: {\n          dispatch({\n            invitation,\n            status: invitation.state,\n            result: {\n              spaceKey: invitation.spaceKey || null,\n              identityKey: invitation.identityKey || null,\n              swarmKey: invitation.swarmKey || null,\n              target: invitation.target || null,\n            },\n          });\n          break;\n        }\n\n        case Invitation.State.CANCELLED:\n        case Invitation.State.TIMEOUT: {\n          dispatch({ invitation, status: invitation.state, haltedAt: state.status });\n          break;\n        }\n      }\n    };\n\n    const subscription = observable?.subscribe(update, (err: Error) => {\n      dispatch({ status: Invitation.State.ERROR, error: err, haltedAt: state.status });\n    });\n\n    const currentState = observable?.get();\n    if (currentState) {\n      update(currentState);\n    }\n\n    return () => subscription?.unsubscribe();\n  }, [observable, state.status]);\n\n  // Return memoized callbacks & values.\n\n  const connect = useCallback((observable: CancellableInvitationObservable) => {\n    dispatch({ invitation: observable.get(), status: Invitation.State.CONNECTING, observable });\n  }, []);\n\n  const authenticate = useCallback(\n    (authCode: string) => {\n      log('authenticating...', { authCode });\n      return (observable as AuthenticatingInvitationObservable).authenticate(authCode);\n    },\n    [observable],\n  );\n\n  const cancel = useCallback(async () => observable?.cancel(), [observable]);\n\n  return useMemo(() => {\n    return {\n      ...state,\n      cancel,\n      connect,\n      authenticate,\n    };\n  }, [state, cancel, connect, authenticate]);\n};\n"],
  "mappings": "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",
  "names": ["AuthenticatingInvitationObservable", "CancellableInvitationObservable", "InvitationEncoder", "Invitation", "InvitationsProxy", "useReducer", "useMemo", "useCallback", "useEffect", "Invitation", "InvitationEncoder", "log", "isShareableInvitation", "invitation", "authMethod", "AuthMethod", "KNOWN_PUBLIC_KEY", "guestKeypair", "privateKey", "useInvitationStatus", "observable", "state", "dispatch", "prev", "action", "invitationProps", "id", "invitationId", "multiUse", "invitationCode", "encode", "authCode", "shareable", "type", "status", "result", "State", "SUCCESS", "ERROR", "error", "CANCELLED", "TIMEOUT", "haltedAt", "_arg", "get", "INIT", "spaceKey", "identityKey", "swarmKey", "target", "undefined", "update", "CONNECTED", "READY_FOR_AUTHENTICATION", "AUTHENTICATING", "subscription", "subscribe", "err", "currentState", "unsubscribe", "connect", "CONNECTING", "authenticate", "cancel"]
}
