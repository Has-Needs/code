import { type PublicKey } from '@dxos/client';
import { type CancellableInvitationObservable, Invitation } from '@dxos/client/invitations';
export type InvitationResult = {
    spaceKey: PublicKey | null;
    identityKey: PublicKey | null;
    swarmKey: PublicKey | null;
    target: string | null;
};
type InvitationPayload = {
    invitation: Invitation;
};
export type InvitationAction = ({
    status: Invitation.State.INIT | Invitation.State.CONNECTED | Invitation.State.READY_FOR_AUTHENTICATION | Invitation.State.AUTHENTICATING;
} & InvitationPayload) | ({
    status: Invitation.State.CONNECTING;
    observable: CancellableInvitationObservable;
} & InvitationPayload) | ({
    status: Invitation.State.SUCCESS;
    result: InvitationResult;
} & InvitationPayload) | ({
    status: Invitation.State.CANCELLED | Invitation.State.TIMEOUT;
    haltedAt: Invitation.State;
} & InvitationPayload) | {
    status: Invitation.State.ERROR;
    error?: Error;
    haltedAt: Invitation.State;
};
export type InvitationStatus = {
    id?: string;
    invitationCode?: string;
    authCode?: string;
    authMethod?: Invitation.AuthMethod;
    type?: Invitation.Type;
    status: Invitation.State;
    haltedAt?: Invitation.State;
    multiUse?: boolean;
    shareable?: boolean;
    result: InvitationResult;
    error?: number;
    cancel(): void;
    connect(observable: CancellableInvitationObservable): void;
    authenticate(authCode: string): Promise<void>;
};
export declare const useInvitationStatus: (observable?: CancellableInvitationObservable) => InvitationStatus;
export {};
//# sourceMappingURL=useInvitationStatus.d.ts.map