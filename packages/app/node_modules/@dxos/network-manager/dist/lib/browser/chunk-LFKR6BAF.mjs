import "@dxos/node-std/globals";

// packages/core/mesh/network-manager/src/swarm/connection.ts
import { DeferredTask, Event, sleep, scheduleTask, scheduleTaskInterval, synchronized, Trigger } from "@dxos/async";
import { Context, cancelWithContext, ContextDisposedError } from "@dxos/context";
import { ErrorStream } from "@dxos/debug";
import { invariant } from "@dxos/invariant";
import { PublicKey } from "@dxos/keys";
import { log, logInfo } from "@dxos/log";
import { CancelledError, ProtocolError, ConnectionResetError, ConnectivityError, TimeoutError, trace } from "@dxos/protocols";
function _ts_decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/core/mesh/network-manager/src/swarm/connection.ts";
var STARTING_SIGNALLING_DELAY = 10;
var TRANSPORT_CONNECTION_TIMEOUT = 1e4;
var TRANSPORT_STATS_INTERVAL = 5e3;
var MAX_SIGNALLING_DELAY = 300;
var ConnectionState = /* @__PURE__ */ function(ConnectionState5) {
  ConnectionState5["CREATED"] = "CREATED";
  ConnectionState5["INITIAL"] = "INITIAL";
  ConnectionState5["CONNECTING"] = "CONNECTING";
  ConnectionState5["CONNECTED"] = "CONNECTED";
  ConnectionState5["CLOSING"] = "CLOSING";
  ConnectionState5["CLOSED"] = "CLOSED";
  ConnectionState5["ABORTING"] = "ABORTING";
  ConnectionState5["ABORTED"] = "ABORTED";
  return ConnectionState5;
}({});
var Connection = class {
  constructor(topic, localInfo, remoteInfo, sessionId, initiator, _signalMessaging, _protocol, _transportFactory, _callbacks) {
    this.topic = topic;
    this.localInfo = localInfo;
    this.remoteInfo = remoteInfo;
    this.sessionId = sessionId;
    this.initiator = initiator;
    this._signalMessaging = _signalMessaging;
    this._protocol = _protocol;
    this._transportFactory = _transportFactory;
    this._callbacks = _callbacks;
    this._ctx = new Context(void 0, {
      F: __dxlog_file,
      L: 100
    });
    this.connectedTimeoutContext = new Context(void 0, {
      F: __dxlog_file,
      L: 101
    });
    this._protocolClosed = new Trigger();
    this._transportClosed = new Trigger();
    this._state = "CREATED";
    this._incomingSignalBuffer = [];
    this._outgoingSignalBuffer = [];
    this.stateChanged = new Event();
    this.errors = new ErrorStream();
    this._instanceId = PublicKey.random().toHex();
    this.transportStats = new Event();
    this._signalSendTask = new DeferredTask(this._ctx, async () => {
      await this._flushSignalBuffer();
    });
    this._signallingDelay = STARTING_SIGNALLING_DELAY;
    log.trace("dxos.mesh.connection.construct", {
      sessionId: this.sessionId,
      topic: this.topic,
      localPeer: this.localInfo,
      remotePeer: this.remoteInfo,
      initiator: this.initiator
    }, {
      F: __dxlog_file,
      L: 137,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  get sessionIdString() {
    return this.sessionId.truncate();
  }
  get state() {
    return this._state;
  }
  get transport() {
    return this._transport;
  }
  get protocol() {
    return this._protocol;
  }
  /**
  * Create an underlying transport and prepares it for the connection.
  */
  async openConnection() {
    invariant(this._state === "INITIAL", "Invalid state.", {
      F: __dxlog_file,
      L: 167,
      S: this,
      A: [
        "this._state === ConnectionState.INITIAL",
        "'Invalid state.'"
      ]
    });
    log.trace("dxos.mesh.connection.open-connection", trace.begin({
      id: this._instanceId
    }), {
      F: __dxlog_file,
      L: 168,
      S: this,
      C: (f, a) => f(...a)
    });
    log.trace("dxos.mesh.connection.open", {
      sessionId: this.sessionId,
      topic: this.topic,
      localPeerId: this.localInfo,
      remotePeerId: this.remoteInfo,
      initiator: this.initiator
    }, {
      F: __dxlog_file,
      L: 169,
      S: this,
      C: (f, a) => f(...a)
    });
    this._changeState("CONNECTING");
    this._protocol.open(this.sessionId).catch((err) => {
      this.errors.raise(err);
    });
    this._protocol.stream.on("close", () => {
      log("protocol stream closed", void 0, {
        F: __dxlog_file,
        L: 186,
        S: this,
        C: (f, a) => f(...a)
      });
      this._protocolClosed.wake();
      this.close({
        error: new ProtocolError("protocol stream closed")
      }).catch((err) => this.errors.raise(err));
    });
    scheduleTask(this.connectedTimeoutContext, async () => {
      log.info(`timeout waiting ${TRANSPORT_CONNECTION_TIMEOUT / 1e3}s for transport to connect, aborting`, void 0, {
        F: __dxlog_file,
        L: 194,
        S: this,
        C: (f, a) => f(...a)
      });
      await this.abort(new TimeoutError(`${TRANSPORT_CONNECTION_TIMEOUT / 1e3}s for transport to connect`)).catch((err) => this.errors.raise(err));
    }, TRANSPORT_CONNECTION_TIMEOUT);
    invariant(!this._transport, void 0, {
      F: __dxlog_file,
      L: 202,
      S: this,
      A: [
        "!this._transport",
        ""
      ]
    });
    this._transport = this._transportFactory.createTransport({
      ownPeerKey: this.localInfo.peerKey,
      remotePeerKey: this.remoteInfo.peerKey,
      topic: this.topic.toHex(),
      initiator: this.initiator,
      stream: this._protocol.stream,
      sendSignal: async (signal) => this._sendSignal(signal),
      sessionId: this.sessionId
    });
    this._transport.connected.once(async () => {
      this._changeState("CONNECTED");
      await this.connectedTimeoutContext.dispose();
      this._callbacks?.onConnected?.();
      scheduleTaskInterval(this._ctx, async () => this._emitTransportStats(), TRANSPORT_STATS_INTERVAL);
    });
    this._transport.closed.once(() => {
      this._transport = void 0;
      this._transportClosed.wake();
      log("abort triggered by transport close", void 0, {
        F: __dxlog_file,
        L: 224,
        S: this,
        C: (f, a) => f(...a)
      });
      this.abort().catch((err) => this.errors.raise(err));
    });
    this._transport.errors.handle(async (err) => {
      log("transport error:", {
        err
      }, {
        F: __dxlog_file,
        L: 229,
        S: this,
        C: (f, a) => f(...a)
      });
      if (!this.closeReason) {
        this.closeReason = err?.message;
      }
      if (err instanceof ConnectionResetError) {
        log.info("aborting due to transport ConnectionResetError", void 0, {
          F: __dxlog_file,
          L: 236,
          S: this,
          C: (f, a) => f(...a)
        });
        this.abort(err).catch((err2) => this.errors.raise(err2));
      } else if (err instanceof ConnectivityError) {
        log.info("aborting due to transport ConnectivityError", void 0, {
          F: __dxlog_file,
          L: 239,
          S: this,
          C: (f, a) => f(...a)
        });
        this.abort(err).catch((err2) => this.errors.raise(err2));
      }
      if (this._state !== "CLOSED" && this._state !== "CLOSING") {
        await this.connectedTimeoutContext.dispose();
        this.errors.raise(err);
      }
    });
    await this._transport.open();
    for (const signal of this._incomingSignalBuffer) {
      void this._transport.onSignal(signal);
    }
    this._incomingSignalBuffer = [];
    log.trace("dxos.mesh.connection.open-connection", trace.end({
      id: this._instanceId
    }), {
      F: __dxlog_file,
      L: 258,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  async abort(err) {
    log("abort", {
      err
    }, {
      F: __dxlog_file,
      L: 265,
      S: this,
      C: (f, a) => f(...a)
    });
    if (this._state === "CLOSED" || this._state === "ABORTED") {
      log(`abort ignored: already ${this._state}`, this.closeReason, {
        F: __dxlog_file,
        L: 267,
        S: this,
        C: (f, a) => f(...a)
      });
      return;
    }
    await this.connectedTimeoutContext.dispose();
    this._changeState("ABORTING");
    if (!this.closeReason) {
      this.closeReason = err?.message;
    }
    await this._ctx.dispose();
    log("aborting...", {
      peerId: this.localInfo,
      err
    }, {
      F: __dxlog_file,
      L: 279,
      S: this,
      C: (f, a) => f(...a)
    });
    try {
      await this._closeProtocol({
        abort: true
      });
    } catch (err2) {
      log.catch(err2, void 0, {
        F: __dxlog_file,
        L: 285,
        S: this,
        C: (f, a) => f(...a)
      });
    }
    try {
      await this._closeTransport();
    } catch (err2) {
      log.catch(err2, void 0, {
        F: __dxlog_file,
        L: 292,
        S: this,
        C: (f, a) => f(...a)
      });
    }
    try {
      this._callbacks?.onClosed?.(err);
    } catch (err2) {
      log.catch(err2, void 0, {
        F: __dxlog_file,
        L: 298,
        S: this,
        C: (f, a) => f(...a)
      });
    }
    this._changeState("ABORTED");
  }
  async close({ error, reason } = {}) {
    log("close", {
      error
    }, {
      F: __dxlog_file,
      L: 305,
      S: this,
      C: (f, a) => f(...a)
    });
    if (!this.closeReason) {
      this.closeReason = reason ?? error?.message;
    } else {
      this.closeReason += `; ${reason ?? error?.message}`;
    }
    if (this._state === "CLOSED" || this._state === "ABORTING" || this._state === "ABORTED") {
      log("close ignored: already in progress", {
        state: this._state,
        error
      }, {
        F: __dxlog_file,
        L: 316,
        S: this,
        C: (f, a) => f(...a)
      });
      return;
    }
    const lastState = this._state;
    this._changeState("CLOSING");
    await this.connectedTimeoutContext.dispose();
    await this._ctx.dispose();
    let abortProtocol = false;
    if (lastState !== "CONNECTED" || error != null) {
      log(`graceful close requested when we were in ${lastState} state? aborting`, void 0, {
        F: __dxlog_file,
        L: 327,
        S: this,
        C: (f, a) => f(...a)
      });
      abortProtocol = true;
    }
    log("closing...", {
      peerId: this.localInfo,
      abortProtocol,
      error
    }, {
      F: __dxlog_file,
      L: 331,
      S: this,
      C: (f, a) => f(...a)
    });
    try {
      await this._closeProtocol({
        abort: abortProtocol
      });
    } catch (err) {
      log.catch(err, void 0, {
        F: __dxlog_file,
        L: 336,
        S: this,
        C: (f, a) => f(...a)
      });
    }
    try {
      await this._closeTransport();
    } catch (err) {
      log.catch(err, void 0, {
        F: __dxlog_file,
        L: 342,
        S: this,
        C: (f, a) => f(...a)
      });
    }
    log("closed", {
      peerId: this.localInfo
    }, {
      F: __dxlog_file,
      L: 345,
      S: this,
      C: (f, a) => f(...a)
    });
    this._changeState("CLOSED");
    this._callbacks?.onClosed?.(error);
  }
  async _closeProtocol(options) {
    log("closing protocol", options, {
      F: __dxlog_file,
      L: 351,
      S: this,
      C: (f, a) => f(...a)
    });
    await Promise.race([
      options?.abort ? this._protocol.abort() : this._protocol.close(),
      this._protocolClosed.wait()
    ]);
    log("protocol closed", options, {
      F: __dxlog_file,
      L: 353,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  async _closeTransport() {
    log("closing transport", void 0, {
      F: __dxlog_file,
      L: 357,
      S: this,
      C: (f, a) => f(...a)
    });
    await Promise.race([
      this._transport?.close(),
      this._transportClosed.wait()
    ]);
    log("transport closed", void 0, {
      F: __dxlog_file,
      L: 359,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  _sendSignal(signal) {
    this._outgoingSignalBuffer.push(signal);
    this._signalSendTask.schedule();
  }
  async _flushSignalBuffer() {
    if (this._outgoingSignalBuffer.length === 0) {
      return;
    }
    try {
      if (true) {
        await cancelWithContext(this._ctx, sleep(this._signallingDelay));
        this._signallingDelay = Math.min(this._signallingDelay * 2, MAX_SIGNALLING_DELAY);
      }
      const signals = [
        ...this._outgoingSignalBuffer
      ];
      this._outgoingSignalBuffer.length = 0;
      await this._signalMessaging.signal({
        author: this.localInfo,
        recipient: this.remoteInfo,
        sessionId: this.sessionId,
        topic: this.topic,
        data: {
          signalBatch: {
            signals
          }
        }
      });
    } catch (err) {
      if (err instanceof CancelledError || err instanceof ContextDisposedError || err instanceof Error && err.message?.includes("CANCELLED")) {
        return;
      }
      log.info("signal message failed to deliver", {
        err
      }, {
        F: __dxlog_file,
        L: 399,
        S: this,
        C: (f, a) => f(...a)
      });
      await this.close({
        error: new ConnectivityError("signal message failed to deliver", err)
      });
    }
  }
  /**
  * Receive a signal from the remote peer.
  */
  async signal(msg) {
    invariant(msg.sessionId, void 0, {
      F: __dxlog_file,
      L: 408,
      S: this,
      A: [
        "msg.sessionId",
        ""
      ]
    });
    if (!msg.sessionId.equals(this.sessionId)) {
      log("dropping signal for incorrect session id", void 0, {
        F: __dxlog_file,
        L: 410,
        S: this,
        C: (f, a) => f(...a)
      });
      return;
    }
    invariant(msg.data.signal || msg.data.signalBatch, void 0, {
      F: __dxlog_file,
      L: 413,
      S: this,
      A: [
        "msg.data.signal || msg.data.signalBatch",
        ""
      ]
    });
    invariant(msg.author.peerKey === this.remoteInfo.peerKey, void 0, {
      F: __dxlog_file,
      L: 414,
      S: this,
      A: [
        "msg.author.peerKey === this.remoteInfo.peerKey",
        ""
      ]
    });
    invariant(msg.recipient.peerKey === this.localInfo.peerKey, void 0, {
      F: __dxlog_file,
      L: 415,
      S: this,
      A: [
        "msg.recipient.peerKey === this.localInfo.peerKey",
        ""
      ]
    });
    const signals = msg.data.signalBatch ? msg.data.signalBatch.signals ?? [] : [
      msg.data.signal
    ];
    for (const signal of signals) {
      if (!signal) {
        continue;
      }
      if ([
        "CREATED",
        "INITIAL"
      ].includes(this.state)) {
        log("buffered signal", {
          peerId: this.localInfo,
          remoteId: this.remoteInfo,
          msg: msg.data
        }, {
          F: __dxlog_file,
          L: 424,
          S: this,
          C: (f, a) => f(...a)
        });
        this._incomingSignalBuffer.push(signal);
      } else {
        invariant(this._transport, "Connection not ready to accept signals.", {
          F: __dxlog_file,
          L: 427,
          S: this,
          A: [
            "this._transport",
            "'Connection not ready to accept signals.'"
          ]
        });
        log("received signal", {
          peerId: this.localInfo,
          remoteId: this.remoteInfo,
          msg: msg.data
        }, {
          F: __dxlog_file,
          L: 428,
          S: this,
          C: (f, a) => f(...a)
        });
        await this._transport.onSignal(signal);
      }
    }
  }
  initiate() {
    this._changeState("INITIAL");
  }
  _changeState(state) {
    log("stateChanged", {
      from: this._state,
      to: state,
      peerId: this.localInfo
    }, {
      F: __dxlog_file,
      L: 439,
      S: this,
      C: (f, a) => f(...a)
    });
    invariant(state !== this._state, "Already in this state.", {
      F: __dxlog_file,
      L: 440,
      S: this,
      A: [
        "state !== this._state",
        "'Already in this state.'"
      ]
    });
    this._state = state;
    this.stateChanged.emit(state);
  }
  async _emitTransportStats() {
    const stats = await this.transport?.getStats();
    if (stats) {
      this.transportStats.emit(stats);
    }
  }
};
_ts_decorate([
  logInfo
], Connection.prototype, "sessionIdString", null);
_ts_decorate([
  synchronized
], Connection.prototype, "abort", null);
_ts_decorate([
  synchronized
], Connection.prototype, "close", null);

// packages/core/mesh/network-manager/src/signal/ice.ts
import { asyncTimeout } from "@dxos/async";
import { log as log2 } from "@dxos/log";
import { isNonNullable } from "@dxos/util";
var __dxlog_file2 = "/home/runner/work/dxos/dxos/packages/core/mesh/network-manager/src/signal/ice.ts";
var createIceProvider = (iceProviders) => {
  let cachedIceServers;
  return {
    getIceServers: async () => {
      if (cachedIceServers) {
        return cachedIceServers;
      }
      cachedIceServers = (await Promise.all(iceProviders.map(({ urls }) => asyncTimeout(fetch(urls, {
        method: "GET"
      }), 1e4).then((response) => response.json()).catch((err) => {
        const isDev = typeof window !== "undefined" && window.location.href.includes("localhost");
        if (!isDev) {
          log2.error("Failed to fetch ICE servers from provider", {
            urls,
            err
          }, {
            F: __dxlog_file2,
            L: 30,
            S: void 0,
            C: (f, a) => f(...a)
          });
        }
      })))).filter(isNonNullable).map(({ iceServers }) => iceServers).flat();
      return cachedIceServers;
    }
  };
};

// packages/core/mesh/network-manager/src/signal/swarm-messenger.ts
import { Context as Context2 } from "@dxos/context";
import { invariant as invariant2 } from "@dxos/invariant";
import { PublicKey as PublicKey2 } from "@dxos/keys";
import { log as log3 } from "@dxos/log";
import { TimeoutError as TimeoutError2 } from "@dxos/protocols";
import { schema } from "@dxos/protocols/proto";
import { ComplexMap } from "@dxos/util";
var __dxlog_file3 = "/home/runner/work/dxos/dxos/packages/core/mesh/network-manager/src/signal/swarm-messenger.ts";
var SwarmMessage = schema.getCodecForType("dxos.mesh.swarm.SwarmMessage");
var SwarmMessenger = class {
  constructor({ sendMessage, onSignal, onOffer, topic }) {
    this._ctx = new Context2(void 0, {
      F: __dxlog_file3,
      L: 35
    });
    this._offerRecords = new ComplexMap((key) => key.toHex());
    this._sendMessage = sendMessage;
    this._onSignal = onSignal;
    this._onOffer = onOffer;
    this._topic = topic;
  }
  async receiveMessage({ author, recipient, payload }) {
    if (payload.type_url !== "dxos.mesh.swarm.SwarmMessage") {
      return;
    }
    const message = SwarmMessage.decode(payload.value);
    if (!this._topic.equals(message.topic)) {
      return;
    }
    log3("received", {
      from: author,
      to: recipient,
      msg: message
    }, {
      F: __dxlog_file3,
      L: 71,
      S: this,
      C: (f, a) => f(...a)
    });
    if (message.data?.offer) {
      await this._handleOffer({
        author,
        recipient,
        message
      });
    } else if (message.data?.answer) {
      await this._resolveAnswers(message);
    } else if (message.data?.signal) {
      await this._handleSignal({
        author,
        recipient,
        message
      });
    } else if (message.data?.signalBatch) {
      await this._handleSignal({
        author,
        recipient,
        message
      });
    } else {
      log3.warn("unknown message", {
        message
      }, {
        F: __dxlog_file3,
        L: 82,
        S: this,
        C: (f, a) => f(...a)
      });
    }
  }
  async signal(message) {
    invariant2(message.data?.signal || message.data?.signalBatch, "Invalid message", {
      F: __dxlog_file3,
      L: 87,
      S: this,
      A: [
        "message.data?.signal || message.data?.signalBatch",
        "'Invalid message'"
      ]
    });
    await this._sendReliableMessage({
      author: message.author,
      recipient: message.recipient,
      message
    });
  }
  async offer(message) {
    const networkMessage = {
      ...message,
      messageId: PublicKey2.random()
    };
    return new Promise((resolve, reject) => {
      this._offerRecords.set(networkMessage.messageId, {
        resolve
      });
      this._sendReliableMessage({
        author: message.author,
        recipient: message.recipient,
        message: networkMessage
      }).catch((err) => reject(err));
    });
  }
  async _sendReliableMessage({ author, recipient, message }) {
    const networkMessage = {
      ...message,
      // Setting unique message_id if it not specified yet.
      messageId: message.messageId ?? PublicKey2.random()
    };
    log3("sending", {
      from: author,
      to: recipient,
      msg: networkMessage
    }, {
      F: __dxlog_file3,
      L: 125,
      S: this,
      C: (f, a) => f(...a)
    });
    await this._sendMessage({
      author,
      recipient,
      payload: {
        type_url: "dxos.mesh.swarm.SwarmMessage",
        value: SwarmMessage.encode(networkMessage)
      }
    });
  }
  async _resolveAnswers(message) {
    invariant2(message.data?.answer?.offerMessageId, "No offerMessageId", {
      F: __dxlog_file3,
      L: 137,
      S: this,
      A: [
        "message.data?.answer?.offerMessageId",
        "'No offerMessageId'"
      ]
    });
    const offerRecord = this._offerRecords.get(message.data.answer.offerMessageId);
    if (offerRecord) {
      this._offerRecords.delete(message.data.answer.offerMessageId);
      invariant2(message.data?.answer, "No answer", {
        F: __dxlog_file3,
        L: 141,
        S: this,
        A: [
          "message.data?.answer",
          "'No answer'"
        ]
      });
      log3("resolving", {
        answer: message.data.answer
      }, {
        F: __dxlog_file3,
        L: 142,
        S: this,
        C: (f, a) => f(...a)
      });
      offerRecord.resolve(message.data.answer);
    }
  }
  async _handleOffer({ author, recipient, message }) {
    invariant2(message.data.offer, "No offer", {
      F: __dxlog_file3,
      L: 156,
      S: this,
      A: [
        "message.data.offer",
        "'No offer'"
      ]
    });
    const offerMessage = {
      author,
      recipient,
      ...message,
      data: {
        offer: message.data.offer
      }
    };
    const answer = await this._onOffer(offerMessage);
    answer.offerMessageId = message.messageId;
    try {
      await this._sendReliableMessage({
        author: recipient,
        recipient: author,
        message: {
          topic: message.topic,
          sessionId: message.sessionId,
          data: {
            answer
          }
        }
      });
    } catch (err) {
      if (err instanceof TimeoutError2) {
        log3.info("timeout sending answer to offer", {
          err
        }, {
          F: __dxlog_file3,
          L: 177,
          S: this,
          C: (f, a) => f(...a)
        });
      } else {
        log3.info("error sending answer to offer", {
          err
        }, {
          F: __dxlog_file3,
          L: 179,
          S: this,
          C: (f, a) => f(...a)
        });
      }
    }
  }
  async _handleSignal({ author, recipient, message }) {
    invariant2(message.messageId, void 0, {
      F: __dxlog_file3,
      L: 193,
      S: this,
      A: [
        "message.messageId",
        ""
      ]
    });
    invariant2(message.data.signal || message.data.signalBatch, "Invalid message", {
      F: __dxlog_file3,
      L: 194,
      S: this,
      A: [
        "message.data.signal || message.data.signalBatch",
        "'Invalid message'"
      ]
    });
    const signalMessage = {
      author,
      recipient,
      ...message,
      data: {
        signal: message.data.signal,
        signalBatch: message.data.signalBatch
      }
    };
    await this._onSignal(signalMessage);
  }
};

// packages/core/mesh/network-manager/src/swarm/swarm.ts
import { Event as Event3, scheduleTask as scheduleTask3, sleep as sleep2, synchronized as synchronized3 } from "@dxos/async";
import { Context as Context4 } from "@dxos/context";
import { ErrorStream as ErrorStream2 } from "@dxos/debug";
import { invariant as invariant4 } from "@dxos/invariant";
import { PublicKey as PublicKey4 } from "@dxos/keys";
import { log as log5, logInfo as logInfo2 } from "@dxos/log";
import { PeerInfoHash } from "@dxos/messaging";
import { trace as trace2 } from "@dxos/protocols";
import { ComplexMap as ComplexMap2, isNonNullable as isNonNullable2 } from "@dxos/util";

// packages/core/mesh/network-manager/src/swarm/peer.ts
import { Event as Event2, scheduleTask as scheduleTask2, synchronized as synchronized2 } from "@dxos/async";
import { Context as Context3 } from "@dxos/context";
import { invariant as invariant3 } from "@dxos/invariant";
import { PublicKey as PublicKey3 } from "@dxos/keys";
import { log as log4 } from "@dxos/log";
import { CancelledError as CancelledError2, SystemError } from "@dxos/protocols";
function _ts_decorate2(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file4 = "/home/runner/work/dxos/dxos/packages/core/mesh/network-manager/src/swarm/peer.ts";
var ConnectionDisplacedError = class extends SystemError {
  constructor() {
    super("Connection displaced by remote initiator.");
  }
};
var CONNECTION_COUNTS_STABLE_AFTER = 5e3;
var Peer = class {
  constructor(remoteInfo, topic, localInfo, _signalMessaging, _protocolProvider, _transportFactory, _connectionLimiter, _callbacks) {
    this.remoteInfo = remoteInfo;
    this.topic = topic;
    this.localInfo = localInfo;
    this._signalMessaging = _signalMessaging;
    this._protocolProvider = _protocolProvider;
    this._transportFactory = _transportFactory;
    this._connectionLimiter = _connectionLimiter;
    this._callbacks = _callbacks;
    this._availableAfter = 0;
    this.availableToConnect = true;
    this._ctx = new Context3(void 0, {
      F: __dxlog_file4,
      L: 80
    });
    this.advertizing = false;
    this.initiating = false;
    this.connectionDisplaced = new Event2();
  }
  /**
  * Respond to remote offer.
  */
  async onOffer(message) {
    const remote = message.author;
    if (this.connection && ![
      ConnectionState.CREATED,
      ConnectionState.INITIAL,
      ConnectionState.CONNECTING
    ].includes(this.connection.state)) {
      log4.info(`received offer when connection already in ${this.connection.state} state`, void 0, {
        F: __dxlog_file4,
        L: 115,
        S: this,
        C: (f, a) => f(...a)
      });
      return {
        accept: false
      };
    }
    if (this.connection || this.initiating) {
      if (remote.peerKey < this.localInfo.peerKey) {
        log4("close local connection", {
          localPeer: this.localInfo,
          topic: this.topic,
          remotePeer: this.remoteInfo,
          sessionId: this.connection?.sessionId
        }, {
          F: __dxlog_file4,
          L: 124,
          S: this,
          C: (f, a) => f(...a)
        });
        if (this.connection) {
          await this.closeConnection(new ConnectionDisplacedError());
        }
      } else {
        return {
          accept: false
        };
      }
    }
    if (await this._callbacks.onOffer(remote)) {
      if (!this.connection) {
        invariant3(message.sessionId, void 0, {
          F: __dxlog_file4,
          L: 144,
          S: this,
          A: [
            "message.sessionId",
            ""
          ]
        });
        const connection = this._createConnection(false, message.sessionId);
        try {
          await this._connectionLimiter.connecting(message.sessionId);
          connection.initiate();
          await connection.openConnection();
        } catch (err) {
          if (!(err instanceof CancelledError2)) {
            log4.info("connection error", {
              topic: this.topic,
              peerId: this.localInfo,
              remoteId: this.remoteInfo,
              err
            }, {
              F: __dxlog_file4,
              L: 154,
              S: this,
              C: (f, a) => f(...a)
            });
          }
          await this.closeConnection(err);
        }
        return {
          accept: true
        };
      }
    }
    return {
      accept: false
    };
  }
  /**
  * Initiate a connection to the remote peer.
  */
  async initiateConnection() {
    invariant3(!this.initiating, "Initiation in progress.", {
      F: __dxlog_file4,
      L: 171,
      S: this,
      A: [
        "!this.initiating",
        "'Initiation in progress.'"
      ]
    });
    invariant3(!this.connection, "Already connected.", {
      F: __dxlog_file4,
      L: 172,
      S: this,
      A: [
        "!this.connection",
        "'Already connected.'"
      ]
    });
    const sessionId = PublicKey3.random();
    log4("initiating...", {
      local: this.localInfo,
      topic: this.topic,
      remote: this.remoteInfo,
      sessionId
    }, {
      F: __dxlog_file4,
      L: 174,
      S: this,
      C: (f, a) => f(...a)
    });
    const connection = this._createConnection(true, sessionId);
    this.initiating = true;
    let answer;
    try {
      await this._connectionLimiter.connecting(sessionId);
      connection.initiate();
      answer = await this._signalMessaging.offer({
        author: this.localInfo,
        recipient: this.remoteInfo,
        sessionId,
        topic: this.topic,
        data: {
          offer: {}
        }
      });
      log4("received", {
        answer,
        topic: this.topic,
        local: this.localInfo,
        remote: this.remoteInfo
      }, {
        F: __dxlog_file4,
        L: 191,
        S: this,
        C: (f, a) => f(...a)
      });
      if (connection.state !== ConnectionState.INITIAL) {
        log4("ignoring response", void 0, {
          F: __dxlog_file4,
          L: 193,
          S: this,
          C: (f, a) => f(...a)
        });
        return;
      }
    } catch (err) {
      log4("initiation error: send offer", {
        err,
        topic: this.topic,
        local: this.localInfo,
        remote: this.remoteInfo
      }, {
        F: __dxlog_file4,
        L: 197,
        S: this,
        C: (f, a) => f(...a)
      });
      await connection.abort(err);
      throw err;
    } finally {
      this.initiating = false;
    }
    try {
      if (!answer.accept) {
        this._callbacks.onRejected();
        return;
      }
    } catch (err) {
      log4("initiation error: accept answer", {
        err,
        topic: this.topic,
        local: this.localInfo,
        remote: this.remoteInfo
      }, {
        F: __dxlog_file4,
        L: 210,
        S: this,
        C: (f, a) => f(...a)
      });
      await connection.abort(err);
      throw err;
    } finally {
      this.initiating = false;
    }
    try {
      log4("opening connection as initiator", void 0, {
        F: __dxlog_file4,
        L: 223,
        S: this,
        C: (f, a) => f(...a)
      });
      await connection.openConnection();
      this._callbacks.onAccepted();
    } catch (err) {
      log4("initiation error: open connection", {
        err,
        topic: this.topic,
        local: this.localInfo,
        remote: this.remoteInfo
      }, {
        F: __dxlog_file4,
        L: 227,
        S: this,
        C: (f, a) => f(...a)
      });
      log4.warn("closing connection due to unhandled error on openConnection", {
        err
      }, {
        F: __dxlog_file4,
        L: 234,
        S: this,
        C: (f, a) => f(...a)
      });
      await this.closeConnection(err);
      throw err;
    } finally {
      this.initiating = false;
    }
  }
  /**
  * Create new connection.
  * Either we're initiating a connection or creating one in response to an offer from the other peer.
  */
  _createConnection(initiator, sessionId) {
    log4("creating connection", {
      topic: this.topic,
      peerId: this.localInfo,
      remoteId: this.remoteInfo,
      initiator,
      sessionId
    }, {
      F: __dxlog_file4,
      L: 248,
      S: this,
      C: (f, a) => f(...a)
    });
    invariant3(!this.connection, "Already connected.", {
      F: __dxlog_file4,
      L: 255,
      S: this,
      A: [
        "!this.connection",
        "'Already connected.'"
      ]
    });
    const connection = new Connection(
      this.topic,
      this.localInfo,
      this.remoteInfo,
      sessionId,
      initiator,
      this._signalMessaging,
      // TODO(dmaretskyi): Init only when connection is established.
      this._protocolProvider({
        initiator,
        localPeerId: PublicKey3.from(this.localInfo.peerKey),
        remotePeerId: PublicKey3.from(this.remoteInfo.peerKey),
        topic: this.topic
      }),
      this._transportFactory,
      {
        onConnected: () => {
          this.availableToConnect = true;
          this._lastConnectionTime = Date.now();
          this._callbacks.onConnected();
          this._connectionLimiter.doneConnecting(sessionId);
          log4.trace("dxos.mesh.connection.connected", {
            topic: this.topic,
            localPeerId: this.localInfo,
            remotePeerId: this.remoteInfo,
            sessionId,
            initiator
          }, {
            F: __dxlog_file4,
            L: 279,
            S: this,
            C: (f, a) => f(...a)
          });
        },
        onClosed: (err) => {
          const logMeta = {
            topic: this.topic,
            peerId: this.localInfo,
            remoteId: this.remoteInfo,
            initiator
          };
          log4("connection closed", logMeta, {
            F: __dxlog_file4,
            L: 289,
            S: this,
            C: (f, a) => f(...a)
          });
          this._connectionLimiter.doneConnecting(sessionId);
          invariant3(this.connection === connection, "Connection mismatch (race condition).", {
            F: __dxlog_file4,
            L: 294,
            S: this,
            A: [
              "this.connection === connection",
              "'Connection mismatch (race condition).'"
            ]
          });
          log4.trace("dxos.mesh.connection.closed", {
            topic: this.topic,
            localPeerId: this.localInfo,
            remotePeerId: this.remoteInfo,
            sessionId,
            initiator
          }, {
            F: __dxlog_file4,
            L: 296,
            S: this,
            C: (f, a) => f(...a)
          });
          if (err instanceof ConnectionDisplacedError) {
            this.connectionDisplaced.emit(this.connection);
          } else {
            if (this._lastConnectionTime && this._lastConnectionTime + CONNECTION_COUNTS_STABLE_AFTER < Date.now()) {
              this._availableAfter = 0;
            } else {
              this.availableToConnect = false;
              this._availableAfter = increaseInterval(this._availableAfter);
            }
            this._callbacks.onDisconnected();
            scheduleTask2(this._connectionCtx, () => {
              log4("peer became available", logMeta, {
                F: __dxlog_file4,
                L: 320,
                S: this,
                C: (f, a) => f(...a)
              });
              this.availableToConnect = true;
              this._callbacks.onPeerAvailable();
            }, this._availableAfter);
          }
          this.connection = void 0;
        }
      }
    );
    this._callbacks.onInitiated(connection);
    void this._connectionCtx?.dispose();
    this._connectionCtx = this._ctx.derive();
    connection.errors.handle((err) => {
      log4.info("connection error, closing", {
        topic: this.topic,
        peerId: this.localInfo,
        remoteId: this.remoteInfo,
        initiator,
        err
      }, {
        F: __dxlog_file4,
        L: 338,
        S: this,
        C: (f, a) => f(...a)
      });
      log4.trace("dxos.mesh.connection.error", {
        topic: this.topic,
        localPeerId: this.localInfo,
        remotePeerId: this.remoteInfo,
        sessionId,
        initiator,
        err
      }, {
        F: __dxlog_file4,
        L: 345,
        S: this,
        C: (f, a) => f(...a)
      });
      void this.closeConnection(err);
    });
    this.connection = connection;
    return connection;
  }
  async closeConnection(err) {
    if (!this.connection) {
      return;
    }
    const connection = this.connection;
    log4("closing...", {
      peerId: this.remoteInfo,
      sessionId: connection.sessionId
    }, {
      F: __dxlog_file4,
      L: 370,
      S: this,
      C: (f, a) => f(...a)
    });
    await connection.close({
      error: err
    });
    log4("closed", {
      peerId: this.remoteInfo,
      sessionId: connection.sessionId
    }, {
      F: __dxlog_file4,
      L: 376,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  async onSignal(message) {
    if (!this.connection) {
      log4("dropping signal message for non-existent connection", {
        message
      }, {
        F: __dxlog_file4,
        L: 381,
        S: this,
        C: (f, a) => f(...a)
      });
      return;
    }
    await this.connection.signal(message);
  }
  async safeDestroy(reason) {
    await this._ctx.dispose();
    log4("Destroying peer", {
      peerId: this.remoteInfo,
      topic: this.topic
    }, {
      F: __dxlog_file4,
      L: 391,
      S: this,
      C: (f, a) => f(...a)
    });
    await this?.connection?.close({
      reason
    });
  }
};
_ts_decorate2([
  synchronized2
], Peer.prototype, "safeDestroy", null);
var increaseInterval = (interval) => {
  if (interval === 0) {
    return 50;
  } else if (interval < 500) {
    return 500;
  } else if (interval < 1e3) {
    return 1e3;
  } else if (interval < 5e3) {
    return 5e3;
  }
  return 1e4;
};

// packages/core/mesh/network-manager/src/swarm/swarm.ts
function _ts_decorate3(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file5 = "/home/runner/work/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm.ts";
var INITIATION_DELAY = 100;
var getClassName = (obj) => Object.getPrototypeOf(obj).constructor.name;
var Swarm = class {
  // TODO(burdon): Swarm => Peer.create/destroy =< Connection.open/close
  // TODO(burdon): Pass in object.
  constructor(_topic, _ownPeer, _topology, _protocolProvider, _messenger, _transportFactory, _label, _connectionLimiter, _initiationDelay = INITIATION_DELAY) {
    this._topic = _topic;
    this._ownPeer = _ownPeer;
    this._topology = _topology;
    this._protocolProvider = _protocolProvider;
    this._messenger = _messenger;
    this._transportFactory = _transportFactory;
    this._label = _label;
    this._connectionLimiter = _connectionLimiter;
    this._initiationDelay = _initiationDelay;
    this._ctx = new Context4(void 0, {
      F: __dxlog_file5,
      L: 38
    });
    this._listeningHandle = void 0;
    this._peers = new ComplexMap2(PeerInfoHash);
    this._instanceId = PublicKey4.random().toHex();
    this.connectionAdded = new Event3();
    this.disconnected = new Event3();
    this.connected = new Event3();
    this.errors = new ErrorStream2();
    log5.trace("dxos.mesh.swarm.constructor", trace2.begin({
      id: this._instanceId,
      data: {
        topic: this._topic.toHex(),
        peer: this._ownPeer
      }
    }), {
      F: __dxlog_file5,
      L: 88,
      S: this,
      C: (f, a) => f(...a)
    });
    log5("creating swarm", {
      peerId: _ownPeer
    }, {
      F: __dxlog_file5,
      L: 92,
      S: this,
      C: (f, a) => f(...a)
    });
    _topology.init(this._getSwarmController());
    this._swarmMessenger = new SwarmMessenger({
      sendMessage: async (msg) => await this._messenger.sendMessage(msg),
      onSignal: async (msg) => await this.onSignal(msg),
      onOffer: async (msg) => await this.onOffer(msg),
      topic: this._topic
    });
    log5.trace("dxos.mesh.swarm.constructor", trace2.end({
      id: this._instanceId
    }), {
      F: __dxlog_file5,
      L: 101,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  get connections() {
    return Array.from(this._peers.values()).map((peer) => peer.connection).filter(isNonNullable2);
  }
  get ownPeerId() {
    return PublicKey4.from(this._ownPeer.peerKey);
  }
  get ownPeer() {
    return this._ownPeer;
  }
  /**
  * Custom label assigned to this swarm. Used in devtools to display human-readable names for swarms.
  */
  get label() {
    return this._label;
  }
  get topic() {
    return this._topic;
  }
  async open() {
    invariant4(!this._listeningHandle, void 0, {
      F: __dxlog_file5,
      L: 132,
      S: this,
      A: [
        "!this._listeningHandle",
        ""
      ]
    });
    this._listeningHandle = await this._messenger.listen({
      peer: this._ownPeer,
      payloadType: "dxos.mesh.swarm.SwarmMessage",
      onMessage: async (message) => {
        await this._swarmMessenger.receiveMessage(message).catch((err) => log5.info("Error while receiving message", {
          err
        }, {
          F: __dxlog_file5,
          L: 140,
          S: this,
          C: (f, a) => f(...a)
        }));
      }
    });
  }
  async destroy() {
    log5("destroying...", void 0, {
      F: __dxlog_file5,
      L: 146,
      S: this,
      C: (f, a) => f(...a)
    });
    await this._listeningHandle?.unsubscribe();
    this._listeningHandle = void 0;
    await this._ctx.dispose();
    await this._topology.destroy();
    await Promise.all(Array.from(this._peers.keys()).map((key) => this._destroyPeer(key, "swarm destroyed")));
    log5("destroyed", void 0, {
      F: __dxlog_file5,
      L: 153,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  async setTopology(topology) {
    invariant4(!this._ctx.disposed, "Swarm is offline", {
      F: __dxlog_file5,
      L: 157,
      S: this,
      A: [
        "!this._ctx.disposed",
        "'Swarm is offline'"
      ]
    });
    if (topology === this._topology) {
      return;
    }
    log5("setting topology", {
      previous: getClassName(this._topology),
      topology: getClassName(topology)
    }, {
      F: __dxlog_file5,
      L: 161,
      S: this,
      C: (f, a) => f(...a)
    });
    await this._topology.destroy();
    this._topology = topology;
    this._topology.init(this._getSwarmController());
    this._topology.update();
  }
  async onSwarmEvent(swarmEvent) {
    log5("swarm event", {
      swarmEvent
    }, {
      F: __dxlog_file5,
      L: 174,
      S: this,
      C: (f, a) => f(...a)
    });
    if (this._ctx.disposed) {
      log5("swarm event ignored for disposed swarm", void 0, {
        F: __dxlog_file5,
        L: 177,
        S: this,
        C: (f, a) => f(...a)
      });
      return;
    }
    if (swarmEvent.peerAvailable) {
      const peerId = swarmEvent.peerAvailable.peer.peerKey;
      if (peerId !== this._ownPeer.peerKey) {
        log5("new peer", {
          peerId
        }, {
          F: __dxlog_file5,
          L: 184,
          S: this,
          C: (f, a) => f(...a)
        });
        const peer = this._getOrCreatePeer(swarmEvent.peerAvailable.peer);
        peer.advertizing = true;
      }
    } else if (swarmEvent.peerLeft) {
      const peer = this._peers.get(swarmEvent.peerLeft.peer);
      if (peer) {
        peer.advertizing = false;
        if (this._isConnectionEstablishmentInProgress(peer)) {
          log5(`destroying peer, state: ${peer.connection?.state}`, void 0, {
            F: __dxlog_file5,
            L: 195,
            S: this,
            C: (f, a) => f(...a)
          });
          void this._destroyPeer(swarmEvent.peerLeft.peer, "peer left").catch((err) => log5.catch(err, void 0, {
            F: __dxlog_file5,
            L: 196,
            S: this,
            C: (f, a) => f(...a)
          }));
        }
      } else {
        log5("received peerLeft but no peer found", {
          peer: swarmEvent.peerLeft.peer.peerKey
        }, {
          F: __dxlog_file5,
          L: 199,
          S: this,
          C: (f, a) => f(...a)
        });
      }
    }
    this._topology.update();
  }
  async onOffer(message) {
    log5("offer", {
      message
    }, {
      F: __dxlog_file5,
      L: 208,
      S: this,
      C: (f, a) => f(...a)
    });
    if (this._ctx.disposed) {
      log5("ignored for disposed swarm", void 0, {
        F: __dxlog_file5,
        L: 210,
        S: this,
        C: (f, a) => f(...a)
      });
      return {
        accept: false
      };
    }
    invariant4(message.author, void 0, {
      F: __dxlog_file5,
      L: 215,
      S: this,
      A: [
        "message.author",
        ""
      ]
    });
    if (message.recipient.peerKey !== this._ownPeer.peerKey) {
      log5("rejecting offer with incorrect peerId", {
        message
      }, {
        F: __dxlog_file5,
        L: 217,
        S: this,
        C: (f, a) => f(...a)
      });
      return {
        accept: false
      };
    }
    if (!message.topic?.equals(this._topic)) {
      log5("rejecting offer with incorrect topic", {
        message
      }, {
        F: __dxlog_file5,
        L: 221,
        S: this,
        C: (f, a) => f(...a)
      });
      return {
        accept: false
      };
    }
    const peer = this._getOfferSenderPeer(message.author);
    const answer = await peer.onOffer(message);
    this._topology.update();
    return answer;
  }
  _getOfferSenderPeer(senderInfo) {
    const peer = this._getOrCreatePeer(senderInfo);
    const connectionState = peer.connection?.state;
    if (connectionState === ConnectionState.CLOSING || connectionState === ConnectionState.ABORTING) {
      this._peers.delete(peer.remoteInfo);
      this.disconnected.emit(peer.remoteInfo);
      return this._getOrCreatePeer(peer.remoteInfo);
    }
    return peer;
  }
  async onSignal(message) {
    log5("signal", {
      message
    }, {
      F: __dxlog_file5,
      L: 246,
      S: this,
      C: (f, a) => f(...a)
    });
    if (this._ctx.disposed) {
      log5.info("ignored for offline swarm", void 0, {
        F: __dxlog_file5,
        L: 248,
        S: this,
        C: (f, a) => f(...a)
      });
      return;
    }
    invariant4(message.recipient.peerKey === this._ownPeer.peerKey, `Invalid signal peer id expected=${this.ownPeerId}, actual=${message.recipient}`, {
      F: __dxlog_file5,
      L: 251,
      S: this,
      A: [
        "message.recipient.peerKey === this._ownPeer.peerKey",
        "`Invalid signal peer id expected=${this.ownPeerId}, actual=${message.recipient}`"
      ]
    });
    invariant4(message.topic?.equals(this._topic), void 0, {
      F: __dxlog_file5,
      L: 255,
      S: this,
      A: [
        "message.topic?.equals(this._topic)",
        ""
      ]
    });
    invariant4(message.author, void 0, {
      F: __dxlog_file5,
      L: 256,
      S: this,
      A: [
        "message.author",
        ""
      ]
    });
    const peer = this._getOrCreatePeer(message.author);
    await peer.onSignal(message);
  }
  // For debug purposes
  async goOffline() {
    await this._ctx.dispose();
    await Promise.all([
      ...this._peers.keys()
    ].map((peerId) => this._destroyPeer(peerId, "goOffline")));
  }
  // For debug purposes
  async goOnline() {
    this._ctx = new Context4(void 0, {
      F: __dxlog_file5,
      L: 272
    });
  }
  _getOrCreatePeer(peerInfo) {
    invariant4(peerInfo.peerKey, "PeerInfo.peerKey is required", {
      F: __dxlog_file5,
      L: 276,
      S: this,
      A: [
        "peerInfo.peerKey",
        "'PeerInfo.peerKey is required'"
      ]
    });
    let peer = this._peers.get(peerInfo);
    if (!peer) {
      peer = new Peer(peerInfo, this._topic, this._ownPeer, this._swarmMessenger, this._protocolProvider, this._transportFactory, this._connectionLimiter, {
        onInitiated: (connection) => {
          this.connectionAdded.emit(connection);
        },
        onConnected: () => {
          this.connected.emit(peerInfo);
        },
        onDisconnected: async () => {
          if (this._isUnregistered(peer)) {
            log5.verbose("ignored onDisconnected for unregistered peer", void 0, {
              F: __dxlog_file5,
              L: 296,
              S: this,
              C: (f, a) => f(...a)
            });
            return;
          }
          if (!peer.advertizing) {
            await this._destroyPeer(peerInfo, "peer disconnected");
          }
          this.disconnected.emit(peerInfo);
          this._topology.update();
        },
        onRejected: () => {
          if (!this._isUnregistered(peer)) {
            log5("peer rejected connection", {
              peerInfo
            }, {
              F: __dxlog_file5,
              L: 310,
              S: this,
              C: (f, a) => f(...a)
            });
            void this._destroyPeer(peerInfo, "peer rejected connection");
          }
        },
        onAccepted: () => {
          this._topology.update();
        },
        onOffer: (remoteId) => {
          return this._topology.onOffer(PublicKey4.from(remoteId.peerKey));
        },
        onPeerAvailable: () => {
          this._topology.update();
        }
      });
      this._peers.set(peerInfo, peer);
    }
    return peer;
  }
  async _destroyPeer(peerInfo, reason) {
    log5("destroy peer", {
      peerKey: peerInfo.peerKey,
      reason
    }, {
      F: __dxlog_file5,
      L: 332,
      S: this,
      C: (f, a) => f(...a)
    });
    const peer = this._peers.get(peerInfo);
    invariant4(peer, void 0, {
      F: __dxlog_file5,
      L: 334,
      S: this,
      A: [
        "peer",
        ""
      ]
    });
    this._peers.delete(peerInfo);
    await peer.safeDestroy(reason);
  }
  _getSwarmController() {
    return {
      getState: () => ({
        ownPeerId: PublicKey4.from(this._ownPeer.peerKey),
        connected: Array.from(this._peers.entries()).filter(([_, peer]) => peer.connection).map(([info]) => PublicKey4.from(info.peerKey)),
        candidates: Array.from(this._peers.entries()).filter(([_, peer]) => !peer.connection && peer.advertizing && peer.availableToConnect).map(([info]) => PublicKey4.from(info.peerKey)),
        allPeers: Array.from(this._peers.keys()).map((info) => PublicKey4.from(info.peerKey))
      }),
      connect: (peer) => {
        if (this._ctx.disposed) {
          return;
        }
        scheduleTask3(this._ctx, async () => {
          try {
            await this._initiateConnection({
              peerKey: peer.toHex()
            });
          } catch (err) {
            log5("initiation error", err, {
              F: __dxlog_file5,
              L: 361,
              S: this,
              C: (f, a) => f(...a)
            });
          }
        });
      },
      disconnect: async (peer) => {
        if (this._ctx.disposed) {
          return;
        }
        scheduleTask3(this._ctx, async () => {
          await this._closeConnection({
            peerKey: peer.toHex()
          });
          this._topology.update();
        });
      }
    };
  }
  /**
  * Creates a connection then sends message over signal network.
  */
  async _initiateConnection(remotePeer) {
    const ctx = this._ctx;
    const peer = this._getOrCreatePeer(remotePeer);
    if (remotePeer.peerKey < this._ownPeer.peerKey) {
      log5("initiation delay", {
        remotePeer
      }, {
        F: __dxlog_file5,
        L: 389,
        S: this,
        C: (f, a) => f(...a)
      });
      await sleep2(this._initiationDelay);
    }
    if (ctx.disposed) {
      return;
    }
    if (this._isUnregistered(peer)) {
      throw new Error("Peer left during initiation delay");
    }
    if (peer.connection) {
      return;
    }
    log5("initiating connection...", {
      remotePeer
    }, {
      F: __dxlog_file5,
      L: 405,
      S: this,
      C: (f, a) => f(...a)
    });
    await peer.initiateConnection();
    this._topology.update();
    log5("initiated", {
      remotePeer
    }, {
      F: __dxlog_file5,
      L: 408,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  async _closeConnection(peerInfo) {
    const peer = this._peers.get(peerInfo);
    if (!peer) {
      return;
    }
    await peer.closeConnection();
  }
  _isConnectionEstablishmentInProgress(peer) {
    if (!peer.connection) {
      return true;
    }
    return [
      ConnectionState.INITIAL,
      ConnectionState.CREATED,
      ConnectionState.CONNECTING
    ].includes(peer.connection.state);
  }
  _isUnregistered(peer) {
    return !peer || this._peers.get(peer.remoteInfo) !== peer;
  }
};
_ts_decorate3([
  logInfo2
], Swarm.prototype, "_instanceId", void 0);
_ts_decorate3([
  logInfo2
], Swarm.prototype, "ownPeer", null);
_ts_decorate3([
  logInfo2
], Swarm.prototype, "topic", null);
_ts_decorate3([
  synchronized3
], Swarm.prototype, "onSwarmEvent", null);
_ts_decorate3([
  synchronized3
], Swarm.prototype, "onOffer", null);
_ts_decorate3([
  synchronized3
], Swarm.prototype, "goOffline", null);
_ts_decorate3([
  synchronized3
], Swarm.prototype, "goOnline", null);

// packages/core/mesh/network-manager/src/swarm/swarm-mapper.ts
import { Event as Event4, SubscriptionList } from "@dxos/async";
import { PublicKey as PublicKey5 } from "@dxos/keys";
import { log as log6 } from "@dxos/log";
import { PeerInfoHash as PeerInfoHash2 } from "@dxos/messaging";
import { ComplexMap as ComplexMap3 } from "@dxos/util";
var __dxlog_file6 = "/home/runner/work/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm-mapper.ts";
var SwarmMapper = class {
  get peers() {
    return Array.from(this._peers.values());
  }
  constructor(_swarm) {
    this._swarm = _swarm;
    this._subscriptions = new SubscriptionList();
    this._connectionSubscriptions = new ComplexMap3(PeerInfoHash2);
    this._peers = new ComplexMap3(PeerInfoHash2);
    this.mapUpdated = new Event4();
    this._subscriptions.add(_swarm.connectionAdded.on((connection) => {
      this._update();
      this._connectionSubscriptions.set(connection.remoteInfo, connection.stateChanged.on(() => {
        this._update();
      }));
    }));
    this._subscriptions.add(_swarm.disconnected.on((peerId) => {
      this._connectionSubscriptions.get(peerId)?.();
      this._connectionSubscriptions.delete(peerId);
      this._update();
    }));
    this._update();
  }
  _update() {
    log6("updating swarm", void 0, {
      F: __dxlog_file6,
      L: 71,
      S: this,
      C: (f, a) => f(...a)
    });
    this._peers.clear();
    this._peers.set(this._swarm.ownPeer, {
      id: this._swarm.ownPeerId,
      state: "ME",
      connections: []
    });
    for (const connection of this._swarm.connections) {
      this._peers.set(connection.remoteInfo, {
        id: PublicKey5.from(connection.remoteInfo.peerKey),
        state: connection.state,
        connections: [
          this._swarm.ownPeerId
        ]
      });
    }
    log6("graph changed", {
      directConnections: this._swarm.connections.length,
      totalPeersInSwarm: this._peers.size
    }, {
      F: __dxlog_file6,
      L: 112,
      S: this,
      C: (f, a) => f(...a)
    });
    this.mapUpdated.emit(Array.from(this._peers.values()));
  }
  // TODO(burdon): Async open/close.
  destroy() {
    Array.from(this._connectionSubscriptions.values()).forEach((cb) => cb());
    this._connectionSubscriptions.clear();
    this._subscriptions.clear();
  }
};

// packages/core/mesh/network-manager/src/swarm/connection-limiter.ts
import { DeferredTask as DeferredTask2 } from "@dxos/async";
import { Context as Context5 } from "@dxos/context";
import { invariant as invariant5 } from "@dxos/invariant";
import { PublicKey as PublicKey6 } from "@dxos/keys";
import { log as log7 } from "@dxos/log";
import { CancelledError as CancelledError3 } from "@dxos/protocols";
import { ComplexMap as ComplexMap4 } from "@dxos/util";
var __dxlog_file7 = "/home/runner/work/dxos/dxos/packages/core/mesh/network-manager/src/swarm/connection-limiter.ts";
var MAX_CONCURRENT_INITIATING_CONNECTIONS = 50;
var ConnectionLimiter = class {
  constructor({ maxConcurrentInitConnections = MAX_CONCURRENT_INITIATING_CONNECTIONS } = {}) {
    this._ctx = new Context5(void 0, {
      F: __dxlog_file7,
      L: 23
    });
    /**
    * Queue of promises to resolve when initiating connections amount is below the limit.
    */
    this._waitingPromises = new ComplexMap4(PublicKey6.hash);
    this.resolveWaitingPromises = new DeferredTask2(this._ctx, async () => {
      Array.from(this._waitingPromises.values()).slice(0, this._maxConcurrentInitConnections).forEach(({ resolve }) => {
        resolve();
      });
    });
    this._maxConcurrentInitConnections = maxConcurrentInitConnections;
  }
  /**
  * @returns Promise that resolves in queue when connections amount with 'CONNECTING' state is below the limit.
  */
  async connecting(sessionId) {
    invariant5(!this._waitingPromises.has(sessionId), "Peer is already waiting for connection", {
      F: __dxlog_file7,
      L: 48,
      S: this,
      A: [
        "!this._waitingPromises.has(sessionId)",
        "'Peer is already waiting for connection'"
      ]
    });
    log7("waiting", {
      sessionId
    }, {
      F: __dxlog_file7,
      L: 49,
      S: this,
      C: (f, a) => f(...a)
    });
    await new Promise((resolve, reject) => {
      this._waitingPromises.set(sessionId, {
        resolve,
        reject
      });
      this.resolveWaitingPromises.schedule();
    });
    log7("allow", {
      sessionId
    }, {
      F: __dxlog_file7,
      L: 57,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  /**
  * Rejects promise returned by `connecting` method.
  */
  doneConnecting(sessionId) {
    log7("done", {
      sessionId
    }, {
      F: __dxlog_file7,
      L: 64,
      S: this,
      C: (f, a) => f(...a)
    });
    if (!this._waitingPromises.has(sessionId)) {
      return;
    }
    this._waitingPromises.get(sessionId).reject(new CancelledError3());
    this._waitingPromises.delete(sessionId);
    this.resolveWaitingPromises.schedule();
  }
};

// packages/core/mesh/network-manager/src/connection-log.ts
import { Event as Event5 } from "@dxos/async";
import { raise } from "@dxos/debug";
import { PublicKey as PublicKey7 } from "@dxos/keys";
import { ComplexMap as ComplexMap5 } from "@dxos/util";
var CONNECTION_GC_THRESHOLD = 1e3 * 60 * 15;
var EventType = /* @__PURE__ */ function(EventType2) {
  EventType2["CONNECTION_STATE_CHANGED"] = "CONNECTION_STATE_CHANGED";
  EventType2["PROTOCOL_ERROR"] = "PROTOCOL_ERROR";
  EventType2["PROTOCOL_EXTENSIONS_INITIALIZED"] = "PROTOCOL_EXTENSIONS_INITIALIZED";
  EventType2["PROTOCOL_EXTENSIONS_HANDSHAKE"] = "PROTOCOL_EXTENSIONS_HANDSHAKE";
  EventType2["PROTOCOL_HANDSHAKE"] = "PROTOCOL_HANDSHAKE";
  return EventType2;
}({});
var ConnectionLog = class {
  constructor() {
    /**
    * SwarmId => info
    */
    this._swarms = new ComplexMap5(PublicKey7.hash);
    this.update = new Event5();
  }
  getSwarmInfo(swarmId) {
    return this._swarms.get(swarmId) ?? raise(new Error(`Swarm not found: ${swarmId}`));
  }
  get swarms() {
    return Array.from(this._swarms.values());
  }
  joinedSwarm(swarm) {
    const info = {
      id: PublicKey7.from(swarm._instanceId),
      topic: swarm.topic,
      isActive: true,
      label: swarm.label,
      connections: []
    };
    this._swarms.set(PublicKey7.from(swarm._instanceId), info);
    this.update.emit();
    swarm.connectionAdded.on((connection) => {
      const connectionInfo = {
        state: ConnectionState.CREATED,
        closeReason: connection.closeReason,
        remotePeerId: PublicKey7.from(connection.remoteInfo.peerKey),
        sessionId: connection.sessionId,
        transport: connection.transport && Object.getPrototypeOf(connection.transport).constructor.name,
        protocolExtensions: [],
        events: [],
        lastUpdate: /* @__PURE__ */ new Date()
      };
      info.connections.push(connectionInfo);
      this.update.emit();
      connection.stateChanged.on(async (state) => {
        connectionInfo.state = state;
        connectionInfo.closeReason = connection.closeReason;
        connectionInfo.lastUpdate = /* @__PURE__ */ new Date();
        connectionInfo.events.push({
          type: "CONNECTION_STATE_CHANGED",
          newState: state
        });
        if (state === ConnectionState.CONNECTED) {
          const details = await connection.transport?.getDetails();
          connectionInfo.transportDetails = details;
        }
        this.update.emit();
      });
      connection.protocol?.stats?.on((stats) => {
        connectionInfo.readBufferSize = stats.readBufferSize;
        connectionInfo.writeBufferSize = stats.writeBufferSize;
        connectionInfo.streams = stats.channels;
        connectionInfo.lastUpdate = /* @__PURE__ */ new Date();
        this.update.emit();
      });
      connection.transportStats?.on((stats) => {
        connectionInfo.transportBytesSent = stats.bytesSent;
        connectionInfo.transportBytesReceived = stats.bytesReceived;
        connectionInfo.transportPacketsSent = stats.packetsSent;
        connectionInfo.transportPacketsReceived = stats.packetsReceived;
      });
      gcSwarm(info);
    });
  }
  leftSwarm(swarm) {
    this.getSwarmInfo(PublicKey7.from(swarm._instanceId)).isActive = false;
    this.update.emit();
  }
};
var gcSwarm = (swarm) => {
  swarm.connections = swarm.connections?.filter((connection) => {
    return connection.lastUpdate ? Date.now() - connection.lastUpdate.getTime() < CONNECTION_GC_THRESHOLD : true;
  });
};

// packages/core/mesh/network-manager/src/network-manager.ts
import { Event as Event6, synchronized as synchronized4 } from "@dxos/async";
import { invariant as invariant6 } from "@dxos/invariant";
import { PublicKey as PublicKey8 } from "@dxos/keys";
import { log as log8 } from "@dxos/log";
import { Messenger } from "@dxos/messaging";
import { trace as trace3 } from "@dxos/protocols";
import { ConnectionState as ConnectionState2 } from "@dxos/protocols/proto/dxos/client/services";
import { ComplexMap as ComplexMap6 } from "@dxos/util";
function _ts_decorate4(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file8 = "/home/runner/work/dxos/dxos/packages/core/mesh/network-manager/src/network-manager.ts";
var SwarmNetworkManager = class {
  constructor({ transportFactory, signalManager, enableDevtoolsLogging, peerInfo }) {
    /**
    * @internal
    */
    this._swarms = new ComplexMap6(PublicKey8.hash);
    this._mappers = new ComplexMap6(PublicKey8.hash);
    this._instanceId = PublicKey8.random().toHex();
    this._peerInfo = void 0;
    this._connectionState = ConnectionState2.ONLINE;
    this.connectionStateChanged = new Event6();
    this.topicsUpdated = new Event6();
    this._transportFactory = transportFactory;
    this._signalManager = signalManager;
    this._signalManager.swarmEvent.on((event) => this._swarms.get(event.topic)?.onSwarmEvent(event));
    this._messenger = new Messenger({
      signalManager: this._signalManager
    });
    this._signalConnection = {
      join: (opts) => this._signalManager.join(opts),
      leave: (opts) => this._signalManager.leave(opts)
    };
    this._peerInfo = peerInfo;
    this._connectionLimiter = new ConnectionLimiter();
    if (enableDevtoolsLogging) {
      this._connectionLog = new ConnectionLog();
    }
  }
  // TODO(burdon): Remove access (Devtools only).
  get connectionLog() {
    return this._connectionLog;
  }
  get connectionState() {
    return this._connectionState;
  }
  // TODO(burdon): Reconcile with "discovery_key".
  get topics() {
    return Array.from(this._swarms.keys());
  }
  getSwarmMap(topic) {
    return this._mappers.get(topic);
  }
  getSwarm(topic) {
    return this._swarms.get(topic);
  }
  setPeerInfo(peerInfo) {
    this._peerInfo = peerInfo;
  }
  async open() {
    log8.trace("dxos.mesh.network-manager.open", trace3.begin({
      id: this._instanceId
    }), {
      F: __dxlog_file8,
      L: 133,
      S: this,
      C: (f, a) => f(...a)
    });
    await this._messenger.open();
    await this._signalManager.open();
    log8.trace("dxos.mesh.network-manager.open", trace3.end({
      id: this._instanceId
    }), {
      F: __dxlog_file8,
      L: 136,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  async close() {
    for (const topic of this._swarms.keys()) {
      await this.leaveSwarm(topic).catch((err) => {
        log8(err, void 0, {
          F: __dxlog_file8,
          L: 142,
          S: this,
          C: (f, a) => f(...a)
        });
      });
    }
    await this._messenger.close();
    await this._signalManager.close();
  }
  /**
  * Join the swarm.
  */
  async joinSwarm({ topic, topology, protocolProvider: protocol, label }) {
    invariant6(PublicKey8.isPublicKey(topic), void 0, {
      F: __dxlog_file8,
      L: 160,
      S: this,
      A: [
        "PublicKey.isPublicKey(topic)",
        ""
      ]
    });
    invariant6(topology, void 0, {
      F: __dxlog_file8,
      L: 161,
      S: this,
      A: [
        "topology",
        ""
      ]
    });
    invariant6(this._peerInfo, void 0, {
      F: __dxlog_file8,
      L: 162,
      S: this,
      A: [
        "this._peerInfo",
        ""
      ]
    });
    invariant6(typeof protocol === "function", void 0, {
      F: __dxlog_file8,
      L: 163,
      S: this,
      A: [
        "typeof protocol === 'function'",
        ""
      ]
    });
    if (this._swarms.has(topic)) {
      throw new Error(`Already connected to swarm: ${PublicKey8.from(topic)}`);
    }
    log8("joining", {
      topic: PublicKey8.from(topic),
      peerInfo: this._peerInfo,
      topology: topology.toString()
    }, {
      F: __dxlog_file8,
      L: 168,
      S: this,
      C: (f, a) => f(...a)
    });
    const swarm = new Swarm(topic, this._peerInfo, topology, protocol, this._messenger, this._transportFactory, label, this._connectionLimiter);
    swarm.errors.handle((error) => {
      log8("swarm error", {
        error
      }, {
        F: __dxlog_file8,
        L: 181,
        S: this,
        C: (f, a) => f(...a)
      });
    });
    this._swarms.set(topic, swarm);
    this._mappers.set(topic, new SwarmMapper(swarm));
    await swarm.open();
    this._signalConnection.join({
      topic,
      peer: this._peerInfo
    }).catch((error) => log8.catch(error, void 0, {
      F: __dxlog_file8,
      L: 190,
      S: this,
      C: (f, a) => f(...a)
    }));
    this.topicsUpdated.emit();
    this._connectionLog?.joinedSwarm(swarm);
    log8("joined", {
      topic: PublicKey8.from(topic),
      count: this._swarms.size
    }, {
      F: __dxlog_file8,
      L: 194,
      S: this,
      C: (f, a) => f(...a)
    });
    return {
      close: () => this.leaveSwarm(topic)
    };
  }
  /**
  * Close the connection.
  */
  async leaveSwarm(topic) {
    if (!this._swarms.has(topic)) {
      return;
    }
    log8("leaving", {
      topic: PublicKey8.from(topic)
    }, {
      F: __dxlog_file8,
      L: 211,
      S: this,
      C: (f, a) => f(...a)
    });
    const swarm = this._swarms.get(topic);
    await this._signalConnection.leave({
      topic,
      peer: swarm.ownPeer
    });
    const map = this._mappers.get(topic);
    map.destroy();
    this._mappers.delete(topic);
    this._connectionLog?.leftSwarm(swarm);
    await swarm.destroy();
    this._swarms.delete(topic);
    this.topicsUpdated.emit();
    log8("left", {
      topic: PublicKey8.from(topic),
      count: this._swarms.size
    }, {
      F: __dxlog_file8,
      L: 225,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  async setConnectionState(state) {
    if (state === this._connectionState) {
      return;
    }
    switch (state) {
      case ConnectionState2.OFFLINE: {
        this._connectionState = state;
        await Promise.all([
          ...this._swarms.values()
        ].map((swarm) => swarm.goOffline()));
        await this._messenger.close();
        await this._signalManager.close();
        break;
      }
      case ConnectionState2.ONLINE: {
        this._connectionState = state;
        this._messenger.open();
        await Promise.all([
          ...this._swarms.values()
        ].map((swarm) => swarm.goOnline()));
        await this._signalManager.open();
        break;
      }
    }
    this.connectionStateChanged.emit(this._connectionState);
  }
};
_ts_decorate4([
  synchronized4
], SwarmNetworkManager.prototype, "joinSwarm", null);
_ts_decorate4([
  synchronized4
], SwarmNetworkManager.prototype, "leaveSwarm", null);

// packages/core/mesh/network-manager/src/topology/fully-connected-topology.ts
import { invariant as invariant7 } from "@dxos/invariant";
var __dxlog_file9 = "/home/runner/work/dxos/dxos/packages/core/mesh/network-manager/src/topology/fully-connected-topology.ts";
var FullyConnectedTopology = class {
  toString() {
    return "FullyConnectedTopology";
  }
  init(controller) {
    invariant7(!this._controller, "Already initialized", {
      F: __dxlog_file9,
      L: 18,
      S: this,
      A: [
        "!this._controller",
        "'Already initialized'"
      ]
    });
    this._controller = controller;
  }
  update() {
    invariant7(this._controller, "Not initialized", {
      F: __dxlog_file9,
      L: 23,
      S: this,
      A: [
        "this._controller",
        "'Not initialized'"
      ]
    });
    const { candidates: discovered } = this._controller.getState();
    for (const peer of discovered) {
      this._controller.connect(peer);
    }
  }
  async onOffer(peer) {
    return true;
  }
  async destroy() {
  }
};

// packages/core/mesh/network-manager/src/topology/mmst-topology.ts
import { invariant as invariant8 } from "@dxos/invariant";
import { log as log9 } from "@dxos/log";
var __dxlog_file10 = "/home/runner/work/dxos/dxos/packages/core/mesh/network-manager/src/topology/mmst-topology.ts";
var MIN_UPDATE_INTERVAL = 1e3 * 10;
var MAX_CHANGES_PER_UPDATE = 1;
var MMSTTopology = class {
  constructor({ originateConnections = 2, maxPeers = 4, sampleSize = 10 } = {}) {
    this._sampleCollected = false;
    this._lastAction = /* @__PURE__ */ new Date(0);
    this._originateConnections = originateConnections;
    this._maxPeers = maxPeers;
    this._sampleSize = sampleSize;
  }
  init(controller) {
    invariant8(!this._controller, "Already initialized", {
      F: __dxlog_file10,
      L: 49,
      S: this,
      A: [
        "!this._controller",
        "'Already initialized'"
      ]
    });
    this._controller = controller;
  }
  update() {
    invariant8(this._controller, "Not initialized", {
      F: __dxlog_file10,
      L: 54,
      S: this,
      A: [
        "this._controller",
        "'Not initialized'"
      ]
    });
    const { connected, candidates } = this._controller.getState();
    if (this._sampleCollected || connected.length > this._maxPeers || candidates.length > 0) {
      log9("Running the algorithm.", void 0, {
        F: __dxlog_file10,
        L: 58,
        S: this,
        C: (f, a) => f(...a)
      });
      this._sampleCollected = true;
      this._runAlgorithm();
    }
  }
  forceUpdate() {
    this._lastAction = /* @__PURE__ */ new Date(0);
    this.update();
  }
  async onOffer(peer) {
    invariant8(this._controller, "Not initialized", {
      F: __dxlog_file10,
      L: 70,
      S: this,
      A: [
        "this._controller",
        "'Not initialized'"
      ]
    });
    const { connected } = this._controller.getState();
    const accept = connected.length < this._maxPeers;
    log9(`Offer ${peer} accept=${accept}`, void 0, {
      F: __dxlog_file10,
      L: 73,
      S: this,
      C: (f, a) => f(...a)
    });
    return accept;
  }
  async destroy() {
  }
  _runAlgorithm() {
    invariant8(this._controller, "Not initialized", {
      F: __dxlog_file10,
      L: 82,
      S: this,
      A: [
        "this._controller",
        "'Not initialized'"
      ]
    });
    const { connected, candidates, ownPeerId } = this._controller.getState();
    if (connected.length > this._maxPeers) {
      log9(`disconnect ${connected.length - this._maxPeers} peers.`, void 0, {
        F: __dxlog_file10,
        L: 88,
        S: this,
        C: (f, a) => f(...a)
      });
      const sorted = sortByXorDistance(connected, ownPeerId).reverse().slice(0, this._maxPeers - connected.length);
      invariant8(sorted.length === 0, void 0, {
        F: __dxlog_file10,
        L: 92,
        S: this,
        A: [
          "sorted.length === 0",
          ""
        ]
      });
      if (sorted.length > MAX_CHANGES_PER_UPDATE) {
        log9(`want to disconnect ${sorted.length} peers but limited to ${MAX_CHANGES_PER_UPDATE}`, void 0, {
          F: __dxlog_file10,
          L: 95,
          S: this,
          C: (f, a) => f(...a)
        });
      }
      if (Date.now() - this._lastAction.getTime() > MIN_UPDATE_INTERVAL) {
        for (const peer of sorted.slice(0, MAX_CHANGES_PER_UPDATE)) {
          log9(`Disconnect ${peer}.`, void 0, {
            F: __dxlog_file10,
            L: 100,
            S: this,
            C: (f, a) => f(...a)
          });
          this._controller.disconnect(peer);
        }
        this._lastAction = /* @__PURE__ */ new Date();
      } else {
        log9("rate limited disconnect", void 0, {
          F: __dxlog_file10,
          L: 105,
          S: this,
          C: (f, a) => f(...a)
        });
      }
    } else if (connected.length < this._originateConnections) {
      log9(`connect ${this._originateConnections - connected.length} peers.`, void 0, {
        F: __dxlog_file10,
        L: 109,
        S: this,
        C: (f, a) => f(...a)
      });
      const sample = candidates.sort(() => Math.random() - 0.5).slice(0, this._sampleSize);
      const sorted = sortByXorDistance(sample, ownPeerId).slice(0, this._originateConnections - connected.length);
      if (sorted.length > MAX_CHANGES_PER_UPDATE) {
        log9(`want to connect ${sorted.length} peers but limited to ${MAX_CHANGES_PER_UPDATE}`, void 0, {
          F: __dxlog_file10,
          L: 114,
          S: this,
          C: (f, a) => f(...a)
        });
      }
      if (Date.now() - this._lastAction.getTime() > MIN_UPDATE_INTERVAL) {
        for (const peer of sorted.slice(0, MAX_CHANGES_PER_UPDATE)) {
          log9(`Connect ${peer}.`, void 0, {
            F: __dxlog_file10,
            L: 118,
            S: this,
            C: (f, a) => f(...a)
          });
          this._controller.connect(peer);
        }
        this._lastAction = /* @__PURE__ */ new Date();
      } else {
        log9("rate limited connect", void 0, {
          F: __dxlog_file10,
          L: 123,
          S: this,
          C: (f, a) => f(...a)
        });
      }
    }
  }
  toString() {
    return "MMSTTopology";
  }
};
var sortByXorDistance = (keys, reference) => {
  const sorted = keys.sort((a, b) => {
    return compareXor(distXor(a.asBuffer(), reference.asBuffer()), distXor(b.asBuffer(), reference.asBuffer()));
  });
  log9("Sorted keys", {
    keys,
    reference,
    sorted
  }, {
    F: __dxlog_file10,
    L: 137,
    S: void 0,
    C: (f, a) => f(...a)
  });
  return sorted;
};
var distXor = (a, b) => {
  const maxLength = Math.max(a.length, b.length);
  const result = Buffer.allocUnsafe(maxLength);
  for (let i = 0; i < maxLength; i++) {
    result[i] = (a[i] || 0) ^ (b[i] || 0);
  }
  return result;
};
var compareXor = (a, b) => {
  const maxLength = Math.max(a.length, b.length);
  for (let i = 0; i < maxLength; i++) {
    if ((a[i] || 0) === (b[i] || 0)) {
      continue;
    }
    return (a[i] || 0) < (b[i] || 0) ? -1 : 1;
  }
  return 0;
};

// packages/core/mesh/network-manager/src/topology/star-topology.ts
import { invariant as invariant9 } from "@dxos/invariant";
import { log as log10 } from "@dxos/log";
var __dxlog_file11 = "/home/runner/work/dxos/dxos/packages/core/mesh/network-manager/src/topology/star-topology.ts";
var StarTopology = class {
  constructor(_centralPeer) {
    this._centralPeer = _centralPeer;
  }
  toString() {
    return `StarTopology(${this._centralPeer.truncate()})`;
  }
  init(controller) {
    invariant9(!this._controller, "Already initialized.", {
      F: __dxlog_file11,
      L: 21,
      S: this,
      A: [
        "!this._controller",
        "'Already initialized.'"
      ]
    });
    this._controller = controller;
  }
  update() {
    invariant9(this._controller, "Not initialized.", {
      F: __dxlog_file11,
      L: 26,
      S: this,
      A: [
        "this._controller",
        "'Not initialized.'"
      ]
    });
    const { candidates, connected, ownPeerId } = this._controller.getState();
    if (!ownPeerId.equals(this._centralPeer)) {
      log10("leaf peer dropping all connections apart from central peer.", void 0, {
        F: __dxlog_file11,
        L: 29,
        S: this,
        C: (f, a) => f(...a)
      });
      for (const peer of connected) {
        if (!peer.equals(this._centralPeer)) {
          log10("dropping connection", {
            peer
          }, {
            F: __dxlog_file11,
            L: 34,
            S: this,
            C: (f, a) => f(...a)
          });
          this._controller.disconnect(peer);
        }
      }
    }
    for (const peer of candidates) {
      if (peer.equals(this._centralPeer) || ownPeerId.equals(this._centralPeer)) {
        log10("connecting to peer", {
          peer
        }, {
          F: __dxlog_file11,
          L: 43,
          S: this,
          C: (f, a) => f(...a)
        });
        this._controller.connect(peer);
      }
    }
  }
  async onOffer(peer) {
    invariant9(this._controller, "Not initialized.", {
      F: __dxlog_file11,
      L: 50,
      S: this,
      A: [
        "this._controller",
        "'Not initialized.'"
      ]
    });
    const { ownPeerId } = this._controller.getState();
    log10("offer", {
      peer,
      isCentral: peer.equals(this._centralPeer),
      isSelfCentral: ownPeerId.equals(this._centralPeer)
    }, {
      F: __dxlog_file11,
      L: 52,
      S: this,
      C: (f, a) => f(...a)
    });
    return ownPeerId.equals(this._centralPeer) || peer.equals(this._centralPeer);
  }
  async destroy() {
  }
};

// packages/core/mesh/network-manager/src/transport/memory-transport.ts
import { Transform } from "@dxos/node-std/stream";
import { Event as Event7, Trigger as Trigger2 } from "@dxos/async";
import { ErrorStream as ErrorStream3 } from "@dxos/debug";
import { invariant as invariant10 } from "@dxos/invariant";
import { PublicKey as PublicKey9 } from "@dxos/keys";
import { log as log11, logInfo as logInfo3 } from "@dxos/log";
import { ComplexMap as ComplexMap7 } from "@dxos/util";
function _ts_decorate5(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file12 = "/home/runner/work/dxos/dxos/packages/core/mesh/network-manager/src/transport/memory-transport.ts";
var MEMORY_TRANSPORT_DELAY = 1;
var createStreamDelay = (delay) => {
  return new Transform({
    objectMode: true,
    transform: (chunk, _, cb) => {
      setTimeout(() => cb(null, chunk), delay);
    }
  });
};
var MemoryTransportFactory = {
  createTransport: (options) => new MemoryTransport(options)
};
var MemoryTransport = class _MemoryTransport {
  static {
    // TODO(burdon): Remove static properties (inject context into constructor).
    this._connections = new ComplexMap7(PublicKey9.hash);
  }
  constructor(_options) {
    this._options = _options;
    this._instanceId = PublicKey9.random();
    this._remote = new Trigger2();
    this._outgoingDelay = createStreamDelay(MEMORY_TRANSPORT_DELAY);
    this._incomingDelay = createStreamDelay(MEMORY_TRANSPORT_DELAY);
    this._closed = false;
    this.closed = new Event7();
    this.connected = new Event7();
    this.errors = new ErrorStream3();
    invariant10(!_MemoryTransport._connections.has(this._instanceId), "Duplicate memory connection", {
      F: __dxlog_file12,
      L: 64,
      S: this,
      A: [
        "!MemoryTransport._connections.has(this._instanceId)",
        "'Duplicate memory connection'"
      ]
    });
    _MemoryTransport._connections.set(this._instanceId, this);
  }
  get isOpen() {
    return !this._closed;
  }
  async open() {
    log11("opening...", void 0, {
      F: __dxlog_file12,
      L: 74,
      S: this,
      C: (f, a) => f(...a)
    });
    if (this._options.initiator) {
      log11("sending signal", void 0, {
        F: __dxlog_file12,
        L: 78,
        S: this,
        C: (f, a) => f(...a)
      });
      try {
        await this._options.sendSignal({
          payload: {
            transportId: this._instanceId.toHex()
          }
        });
      } catch (err) {
        if (!this._closed) {
          this.errors.raise(toError(err));
        }
      }
    } else {
      this._remote.wait({
        timeout: this._options.timeout ?? 1e3
      }).then((remoteId) => {
        if (this._closed) {
          return;
        }
        this._remoteInstanceId = remoteId;
        this._remoteConnection = _MemoryTransport._connections.get(this._remoteInstanceId);
        if (!this._remoteConnection) {
          this._closed = true;
          this.closed.emit();
          return;
        }
        invariant10(!this._remoteConnection._remoteConnection, `Remote already connected: ${this._remoteInstanceId}`, {
          F: __dxlog_file12,
          L: 104,
          S: this,
          A: [
            "!this._remoteConnection._remoteConnection",
            "`Remote already connected: ${this._remoteInstanceId}`"
          ]
        });
        this._remoteConnection._remoteConnection = this;
        this._remoteConnection._remoteInstanceId = this._instanceId;
        log11("connected", void 0, {
          F: __dxlog_file12,
          L: 108,
          S: this,
          C: (f, a) => f(...a)
        });
        this._options.stream.pipe(this._outgoingDelay).pipe(this._remoteConnection._options.stream).pipe(this._incomingDelay).pipe(this._options.stream);
        this.connected.emit();
        this._remoteConnection.connected.emit();
      }).catch((err) => {
        if (this._closed) {
          return;
        }
        this.errors.raise(err);
      });
    }
    return this;
  }
  async close() {
    log11("closing...", void 0, {
      F: __dxlog_file12,
      L: 130,
      S: this,
      C: (f, a) => f(...a)
    });
    this._closed = true;
    _MemoryTransport._connections.delete(this._instanceId);
    if (this._remoteConnection) {
      this._remoteConnection._closed = true;
      _MemoryTransport._connections.delete(this._remoteInstanceId);
      this._options.stream.unpipe(this._incomingDelay);
      this._incomingDelay.unpipe(this._remoteConnection._options.stream);
      this._remoteConnection._options.stream.unpipe(this._outgoingDelay);
      this._outgoingDelay.unpipe(this._options.stream);
      this._options.stream.unpipe(this._outgoingDelay);
      this._remoteConnection.closed.emit();
      this._remoteConnection._remoteConnection = void 0;
      this._remoteConnection = void 0;
    }
    this.closed.emit();
    log11("closed", void 0, {
      F: __dxlog_file12,
      L: 158,
      S: this,
      C: (f, a) => f(...a)
    });
    return this;
  }
  async onSignal({ payload }) {
    log11("received signal", {
      payload
    }, {
      F: __dxlog_file12,
      L: 163,
      S: this,
      C: (f, a) => f(...a)
    });
    if (!payload?.transportId) {
      return;
    }
    const transportId = payload.transportId;
    if (transportId) {
      const remoteId = PublicKey9.fromHex(transportId);
      this._remote.wake(remoteId);
    }
  }
  async getDetails() {
    return this._instanceId.toHex();
  }
  async getStats() {
    return {
      bytesSent: 0,
      bytesReceived: 0,
      packetsSent: 0,
      packetsReceived: 0
    };
  }
};
_ts_decorate5([
  logInfo3
], MemoryTransport.prototype, "_instanceId", void 0);
_ts_decorate5([
  logInfo3
], MemoryTransport.prototype, "_remoteInstanceId", void 0);
var toError = (err) => err instanceof Error ? err : new Error(String(err));

// packages/core/mesh/network-manager/src/transport/transport.ts
var TransportKind = /* @__PURE__ */ function(TransportKind2) {
  TransportKind2["WEB_RTC"] = "WEB-RTC";
  TransportKind2["WEB_RTC_PROXY"] = "WEB-RTC_PROXY";
  TransportKind2["MEMORY"] = "MEMORY";
  TransportKind2["TCP"] = "TCP";
  return TransportKind2;
}({});

// packages/core/mesh/network-manager/src/transport/webrtc/rtc-connection-factory.ts
import { Mutex } from "@dxos/async";
var BrowserRtcConnectionFactory = class {
  async initialize() {
  }
  async onConnectionDestroyed() {
  }
  async createConnection(config) {
    return new RTCPeerConnection(config);
  }
  async initConnection(connection, info) {
  }
};
var NodeRtcConnectionFactory = class _NodeRtcConnectionFactory {
  static {
    this._createdConnections = 0;
  }
  static {
    this._cleanupMutex = new Mutex();
  }
  // This should be inside the function to avoid triggering `eval` in the global scope.
  // eslint-disable-next-line no-new-func
  // TODO(burdon): Do imports here?
  async initialize() {
  }
  async onConnectionDestroyed() {
    return _NodeRtcConnectionFactory._cleanupMutex.executeSynchronized(async () => {
      if (--_NodeRtcConnectionFactory._createdConnections === 0) {
        (await import("#node-datachannel")).cleanup();
      }
    });
  }
  async createConnection(config) {
    return _NodeRtcConnectionFactory._cleanupMutex.executeSynchronized(async () => {
      const { RTCPeerConnection: RTCPeerConnection1 } = await import("#node-datachannel/polyfill");
      _NodeRtcConnectionFactory._createdConnections++;
      return new RTCPeerConnection1(config);
    });
  }
  async initConnection(connection, info) {
    if (info.initiator) {
      connection.onnegotiationneeded?.(null);
    }
  }
};
var getRtcConnectionFactory = () => {
  return typeof globalThis.RTCPeerConnection === "undefined" ? new NodeRtcConnectionFactory() : new BrowserRtcConnectionFactory();
};

// packages/core/mesh/network-manager/src/transport/webrtc/rtc-peer-connection.ts
import { synchronized as synchronized5, Trigger as Trigger3, Mutex as Mutex2 } from "@dxos/async";
import { invariant as invariant12 } from "@dxos/invariant";
import { log as log13, logInfo as logInfo4 } from "@dxos/log";
import { ConnectivityError as ConnectivityError3 } from "@dxos/protocols";
import { trace as trace4 } from "@dxos/tracing";

// packages/core/mesh/network-manager/src/transport/webrtc/rtc-transport-channel.ts
import { Duplex } from "@dxos/node-std/stream";
import { Event as AsyncEvent } from "@dxos/async";
import { Resource } from "@dxos/context";
import { ErrorStream as ErrorStream4 } from "@dxos/debug";
import { invariant as invariant11 } from "@dxos/invariant";
import { log as log12 } from "@dxos/log";
import { ConnectivityError as ConnectivityError2 } from "@dxos/protocols";

// packages/core/mesh/network-manager/src/transport/webrtc/rtc-transport-stats.ts
var describeSelectedRemoteCandidate = async (connection) => {
  const stats = connection && await getRtcConnectionStats(connection);
  const rc = stats?.remoteCandidate;
  if (!rc) {
    return "unavailable";
  }
  if (rc.candidateType === "relay") {
    return `${rc.ip}:${rc.port} relay for ${rc.relatedAddress}:${rc.relatedPort}`;
  }
  return `${rc.ip}:${rc.port} ${rc.candidateType}`;
};
var createRtcTransportStats = async (connection, topic) => {
  const stats = connection && await getRtcConnectionStats(connection, topic);
  if (!stats) {
    return {
      bytesSent: 0,
      bytesReceived: 0,
      packetsSent: 0,
      packetsReceived: 0,
      rawStats: {}
    };
  }
  return {
    bytesSent: stats.dataChannel?.bytesSent,
    bytesReceived: stats.dataChannel?.bytesReceived,
    packetsSent: 0,
    packetsReceived: 0,
    rawStats: stats.raw
  };
};
var getRtcConnectionStats = async (connection, channelTopic) => {
  const stats = await connection.getStats();
  const statsEntries = Array.from(stats.entries());
  const transport = statsEntries.find(([_, entry]) => entry.type === "transport")?.[1];
  const selectedCandidatePair = transport && statsEntries.find(([entryId]) => entryId === transport.selectedCandidatePairId)?.[1];
  const remoteCandidate = selectedCandidatePair && statsEntries.find(([entryId]) => entryId === selectedCandidatePair.remoteCandidateId)?.[1];
  const dataChannel = channelTopic && statsEntries.find(([_, entry]) => entry.type === "data-channel" && entry.label === channelTopic)?.[1];
  return {
    transport,
    selectedCandidatePair,
    dataChannel,
    remoteCandidate,
    raw: Object.fromEntries(stats)
  };
};

// packages/core/mesh/network-manager/src/transport/webrtc/rtc-transport-channel.ts
var __dxlog_file13 = "/home/runner/work/dxos/dxos/packages/core/mesh/network-manager/src/transport/webrtc/rtc-transport-channel.ts";
var MAX_MESSAGE_SIZE = 64 * 1024;
var MAX_BUFFERED_AMOUNT = 64 * 1024;
var RtcTransportChannel = class extends Resource {
  constructor(_connection, _options) {
    super(), this._connection = _connection, this._options = _options, this.closed = new AsyncEvent(), this.connected = new AsyncEvent(), this.errors = new ErrorStream4(), this._streamDataFlushedCallback = null, this._isChannelCreationInProgress = false;
  }
  get isRtcChannelCreationInProgress() {
    return this._isChannelCreationInProgress;
  }
  onConnectionError(error) {
    if (this.isOpen) {
      this.errors.raise(error);
    }
  }
  async _open() {
    invariant11(!this._isChannelCreationInProgress, void 0, {
      F: __dxlog_file13,
      L: 56,
      S: this,
      A: [
        "!this._isChannelCreationInProgress",
        ""
      ]
    });
    this._isChannelCreationInProgress = true;
    this._connection.createDataChannel(this._options.topic).then((channel) => {
      if (this.isOpen) {
        this._channel = channel;
        this._initChannel(this._channel);
      } else {
        this._safeCloseChannel(channel);
      }
    }).catch((err) => {
      if (this.isOpen) {
        const error = err instanceof Error ? err : new ConnectivityError2(`Failed to create a channel: ${JSON.stringify(err?.message)}`);
        this.errors.raise(error);
      } else {
        log12.verbose("connection establishment failed after transport was closed", {
          err
        }, {
          F: __dxlog_file13,
          L: 76,
          S: this,
          C: (f, a) => f(...a)
        });
      }
    }).finally(() => {
      this._isChannelCreationInProgress = false;
    });
  }
  async _close() {
    if (this._channel) {
      this._safeCloseChannel(this._channel);
      this._channel = void 0;
      this._stream = void 0;
    }
    this.closed.emit();
    log12("closed", void 0, {
      F: __dxlog_file13,
      L: 92,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  _initChannel(channel) {
    Object.assign(channel, {
      onopen: () => {
        if (!this.isOpen) {
          log12.warn("channel opened in a closed transport", {
            topic: this._options.topic
          }, {
            F: __dxlog_file13,
            L: 99,
            S: this,
            C: (f, a) => f(...a)
          });
          this._safeCloseChannel(channel);
          return;
        }
        log12("onopen", void 0, {
          F: __dxlog_file13,
          L: 104,
          S: this,
          C: (f, a) => f(...a)
        });
        const duplex = new Duplex({
          read: () => {
          },
          write: (chunk, encoding, callback) => {
            return this._handleChannelWrite(chunk, callback);
          }
        });
        duplex.pipe(this._options.stream).pipe(duplex);
        this._stream = duplex;
        this.connected.emit();
      },
      onclose: async () => {
        log12("onclose", void 0, {
          F: __dxlog_file13,
          L: 117,
          S: this,
          C: (f, a) => f(...a)
        });
        await this.close();
      },
      onmessage: async (event) => {
        if (!this._stream) {
          log12.warn("ignoring message on a closed channel", void 0, {
            F: __dxlog_file13,
            L: 123,
            S: this,
            C: (f, a) => f(...a)
          });
          return;
        }
        let data = event.data;
        if (data instanceof ArrayBuffer) {
          data = Buffer.from(data);
        } else if (data instanceof Blob) {
          data = Buffer.from(await data.arrayBuffer());
        }
        this._stream.push(data);
      },
      onerror: (event) => {
        if (this.isOpen) {
          const err = event.error instanceof Error ? event.error : new Error(`Datachannel error: ${event.type}.`);
          this.errors.raise(err);
        }
      },
      onbufferedamountlow: () => {
        const cb = this._streamDataFlushedCallback;
        this._streamDataFlushedCallback = null;
        cb?.();
      }
    });
  }
  async _handleChannelWrite(chunk, callback) {
    if (!this._channel) {
      log12.warn("writing to a channel after a connection was closed", void 0, {
        F: __dxlog_file13,
        L: 153,
        S: this,
        C: (f, a) => f(...a)
      });
      return;
    }
    if (chunk.length > MAX_MESSAGE_SIZE) {
      const error = new Error(`Message too large: ${chunk.length} > ${MAX_MESSAGE_SIZE}.`);
      this.errors.raise(error);
      callback();
      return;
    }
    try {
      this._channel.send(chunk);
    } catch (err) {
      this.errors.raise(err);
      callback();
      return;
    }
    if (this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {
      if (this._streamDataFlushedCallback !== null) {
        log12.error("consumer trying to write before we are ready for more data", void 0, {
          F: __dxlog_file13,
          L: 174,
          S: this,
          C: (f, a) => f(...a)
        });
      }
      this._streamDataFlushedCallback = callback;
    } else {
      callback();
    }
  }
  _safeCloseChannel(channel) {
    try {
      channel.close();
    } catch (error) {
      log12.catch(error, void 0, {
        F: __dxlog_file13,
        L: 186,
        S: this,
        C: (f, a) => f(...a)
      });
    }
  }
  onSignal(signal) {
    return this._connection.onSignal(signal);
  }
  async getDetails() {
    return describeSelectedRemoteCandidate(this._connection.currentConnection);
  }
  async getStats() {
    return createRtcTransportStats(this._connection.currentConnection, this._options.topic);
  }
};

// packages/core/mesh/network-manager/src/transport/webrtc/utils.ts
var chooseInitiatorPeer = (peer1Key, peer2Key) => peer1Key < peer2Key ? peer1Key : peer2Key;
var areSdpEqual = (sdp1, sdp2) => {
  const sdp1Lines = deduplicatedSdpLines(sdp1);
  const sdp2Lines = deduplicatedSdpLines(sdp2);
  if (sdp1Lines.length !== sdp2Lines.length) {
    return false;
  }
  return sdp1Lines.every((line, idx) => line === sdp2Lines[idx]);
};
var deduplicatedSdpLines = (sdp) => {
  const deduplicatedLines = [];
  const seenLines = [];
  for (const line of sdp.split("\r\n")) {
    if (line.startsWith("m")) {
      seenLines.length = 0;
    }
    if (seenLines.includes(line)) {
      continue;
    }
    seenLines.push(line);
    deduplicatedLines.push(line);
  }
  return deduplicatedLines;
};

// packages/core/mesh/network-manager/src/transport/webrtc/rtc-peer-connection.ts
function _ts_decorate6(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file14 = "/home/runner/work/dxos/dxos/packages/core/mesh/network-manager/src/transport/webrtc/rtc-peer-connection.ts";
var RtcPeerConnection = class {
  constructor(_factory, _options) {
    this._factory = _factory;
    this._options = _options;
    this._channelCreatedCallbacks = /* @__PURE__ */ new Map();
    this._transportChannels = /* @__PURE__ */ new Map();
    this._dataChannels = /* @__PURE__ */ new Map();
    this._readyForCandidates = new Trigger3();
    this._offerProcessingMutex = new Mutex2();
    this._initiator = chooseInitiatorPeer(_options.ownPeerKey, _options.remotePeerKey) === _options.ownPeerKey;
  }
  get transportChannelCount() {
    return this._transportChannels.size;
  }
  get currentConnection() {
    return this._connection;
  }
  async createDataChannel(topic) {
    const connection = await this._openConnection();
    if (!this._transportChannels.has(topic)) {
      if (!this._transportChannels.size) {
        void this._lockAndCloseConnection();
      }
      throw new Error("Transport closed while connection was being open");
    }
    if (this._initiator) {
      const channel = connection.createDataChannel(topic);
      this._dataChannels.set(topic, channel);
      return channel;
    } else {
      const existingChannel = this._dataChannels.get(topic);
      if (existingChannel) {
        return existingChannel;
      }
      log13("waiting for initiator-peer to open a data channel", void 0, {
        F: __dxlog_file14,
        L: 95,
        S: this,
        C: (f, a) => f(...a)
      });
      return new Promise((resolve, reject) => {
        this._channelCreatedCallbacks.set(topic, {
          resolve,
          reject
        });
      });
    }
  }
  createTransportChannel(options) {
    const channel = new RtcTransportChannel(this, options);
    this._transportChannels.set(options.topic, channel);
    channel.closed.on(() => {
      this._transportChannels.delete(options.topic);
      if (this._transportChannels.size === 0) {
        void this._lockAndCloseConnection();
      }
    });
    return channel;
  }
  async _openConnection() {
    if (this._connection) {
      return this._connection;
    }
    log13("initializing connection...", () => ({
      remotePeer: this._options.remotePeerKey
    }), {
      F: __dxlog_file14,
      L: 120,
      S: this,
      C: (f, a) => f(...a)
    });
    const config = await this._loadConnectionConfig();
    const connection = await this._factory.createConnection(config);
    const iceCandidateErrors = [];
    Object.assign(connection, {
      onnegotiationneeded: async () => {
        invariant12(this._initiator, void 0, {
          F: __dxlog_file14,
          L: 135,
          S: this,
          A: [
            "this._initiator",
            ""
          ]
        });
        if (connection !== this._connection) {
          this._onConnectionCallbackAfterClose("onnegotiationneeded", connection);
          return;
        }
        log13("onnegotiationneeded", void 0, {
          F: __dxlog_file14,
          L: 142,
          S: this,
          C: (f, a) => f(...a)
        });
        try {
          const offer = await connection.createOffer();
          await connection.setLocalDescription(offer);
          await this._sendDescription(connection, offer);
        } catch (err) {
          void this._lockAndAbort(connection, err);
        }
      },
      // When ICE candidate identified (should be sent to remote peer) and when ICE gathering finalized.
      // https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/icecandidate_event
      onicecandidate: async (event) => {
        if (connection !== this._connection) {
          this._onConnectionCallbackAfterClose("onicecandidate", connection);
          return;
        }
        if (event.candidate) {
          log13("onicecandidate", {
            candidate: event.candidate.candidate
          }, {
            F: __dxlog_file14,
            L: 161,
            S: this,
            C: (f, a) => f(...a)
          });
          await this._sendIceCandidate(event.candidate);
        } else {
          log13("onicecandidate gathering complete", void 0, {
            F: __dxlog_file14,
            L: 164,
            S: this,
            C: (f, a) => f(...a)
          });
        }
      },
      // When error occurs while performing ICE negotiations through a STUN or TURN server.
      // It's ok for some candidates to fail if a working pair is eventually found.
      // https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/icecandidateerror_event
      onicecandidateerror: (event) => {
        const { url, errorCode, errorText } = event;
        iceCandidateErrors.push({
          url,
          errorCode,
          errorText
        });
      },
      // When possible error during ICE gathering.
      // https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/iceconnectionstatechange_event
      oniceconnectionstatechange: () => {
        if (connection !== this._connection) {
          this._onConnectionCallbackAfterClose("oniceconnectionstatechange", connection);
          return;
        }
        log13("oniceconnectionstatechange", {
          state: connection.iceConnectionState
        }, {
          F: __dxlog_file14,
          L: 184,
          S: this,
          C: (f, a) => f(...a)
        });
        if (connection.iceConnectionState === "failed") {
          void this._lockAndAbort(connection, createIceFailureError(iceCandidateErrors));
        }
      },
      // When new track (or channel) is added.
      // State: { new, connecting, connected, disconnected, failed, closed }
      // https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/connectionstatechange_event
      onconnectionstatechange: () => {
        if (connection !== this._connection) {
          if (connection.connectionState !== "closed" && connection.connectionState !== "failed") {
            this._onConnectionCallbackAfterClose("onconnectionstatechange", connection);
          }
          return;
        }
        log13("onconnectionstatechange", {
          state: connection.connectionState
        }, {
          F: __dxlog_file14,
          L: 201,
          S: this,
          C: (f, a) => f(...a)
        });
        if (connection.connectionState === "failed") {
          void this._lockAndAbort(connection, new Error("Connection failed."));
        }
      },
      onsignalingstatechange: () => {
        log13("onsignalingstatechange", {
          state: connection.signalingState
        }, {
          F: __dxlog_file14,
          L: 208,
          S: this,
          C: (f, a) => f(...a)
        });
      },
      // When channel is added to connection.
      // https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/datachannel_event
      ondatachannel: (event) => {
        invariant12(!this._initiator, "Initiator is expected to create data channels.", {
          F: __dxlog_file14,
          L: 214,
          S: this,
          A: [
            "!this._initiator",
            "'Initiator is expected to create data channels.'"
          ]
        });
        if (connection !== this._connection) {
          this._onConnectionCallbackAfterClose("ondatachannel", connection);
          return;
        }
        log13("ondatachannel", {
          label: event.channel.label
        }, {
          F: __dxlog_file14,
          L: 221,
          S: this,
          C: (f, a) => f(...a)
        });
        this._dataChannels.set(event.channel.label, event.channel);
        const pendingCallback = this._channelCreatedCallbacks.get(event.channel.label);
        if (pendingCallback) {
          this._channelCreatedCallbacks.delete(event.channel.label);
          pendingCallback.resolve(event.channel);
        }
      }
    });
    this._connection = connection;
    this._readyForCandidates.reset();
    await this._factory.initConnection(connection, {
      initiator: this._initiator
    });
    return this._connection;
  }
  async _lockAndAbort(connection, error) {
    this._abortConnection(connection, error);
  }
  _abortConnection(connection, error) {
    if (connection !== this._connection) {
      log13.error("attempted to abort an inactive connection", {
        error
      }, {
        F: __dxlog_file14,
        L: 246,
        S: this,
        C: (f, a) => f(...a)
      });
      this._safeCloseConnection(connection);
      return;
    }
    for (const [topic, pendingCallback] of this._channelCreatedCallbacks.entries()) {
      pendingCallback.reject(error);
      this._transportChannels.delete(topic);
    }
    this._channelCreatedCallbacks.clear();
    for (const channel of this._transportChannels.values()) {
      channel.onConnectionError(error);
    }
    this._transportChannels.clear();
    this._safeCloseConnection();
    log13("connection aborted", {
      reason: error.message
    }, {
      F: __dxlog_file14,
      L: 260,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  async _lockAndCloseConnection() {
    invariant12(this._transportChannels.size === 0, void 0, {
      F: __dxlog_file14,
      L: 265,
      S: this,
      A: [
        "this._transportChannels.size === 0",
        ""
      ]
    });
    if (this._connection) {
      this._safeCloseConnection();
      log13("connection closed", void 0, {
        F: __dxlog_file14,
        L: 268,
        S: this,
        C: (f, a) => f(...a)
      });
    }
  }
  async onSignal(signal) {
    const connection = this._connection;
    if (!connection) {
      log13.warn("a signal ignored because the connection was closed", {
        type: signal.payload.data.type
      }, {
        F: __dxlog_file14,
        L: 276,
        S: this,
        C: (f, a) => f(...a)
      });
      return;
    }
    const data = signal.payload.data;
    switch (data.type) {
      case "offer": {
        await this._offerProcessingMutex.executeSynchronized(async () => {
          if (isRemoteDescriptionSet(connection, data)) {
            return;
          }
          if (connection.connectionState !== "new") {
            this._abortConnection(connection, new Error(`Received an offer in ${connection.connectionState}.`));
            return;
          }
          try {
            await connection.setRemoteDescription({
              type: data.type,
              sdp: data.sdp
            });
            const answer = await connection.createAnswer();
            await connection.setLocalDescription(answer);
            await this._sendDescription(connection, answer);
            this._onSessionNegotiated(connection);
          } catch (err) {
            this._abortConnection(connection, new Error("Error handling a remote offer.", {
              cause: err
            }));
          }
        });
        break;
      }
      case "answer":
        await this._offerProcessingMutex.executeSynchronized(async () => {
          try {
            if (isRemoteDescriptionSet(connection, data)) {
              return;
            }
            if (connection.signalingState !== "have-local-offer") {
              this._abortConnection(connection, new Error(`Unexpected answer from remote peer, signalingState was ${connection.signalingState}.`));
              return;
            }
            await connection.setRemoteDescription({
              type: data.type,
              sdp: data.sdp
            });
            this._onSessionNegotiated(connection);
          } catch (err) {
            this._abortConnection(connection, new Error("Error handling a remote answer.", {
              cause: err
            }));
          }
        });
        break;
      case "candidate":
        void this._processIceCandidate(connection, data.candidate);
        break;
      default:
        this._abortConnection(connection, new Error(`Unknown signal type ${data.type}.`));
        break;
    }
    log13("signal processed", {
      type: data.type
    }, {
      F: __dxlog_file14,
      L: 335,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  async _processIceCandidate(connection, candidate) {
    try {
      await this._readyForCandidates.wait();
      if (connection === this._connection) {
        log13("adding ice candidate", {
          candidate
        }, {
          F: __dxlog_file14,
          L: 343,
          S: this,
          C: (f, a) => f(...a)
        });
        await connection.addIceCandidate(candidate);
      }
    } catch (err) {
      log13.catch(err, void 0, {
        F: __dxlog_file14,
        L: 347,
        S: this,
        C: (f, a) => f(...a)
      });
    }
  }
  _onSessionNegotiated(connection) {
    if (connection === this._connection) {
      log13("ready to process ice candidates", void 0, {
        F: __dxlog_file14,
        L: 353,
        S: this,
        C: (f, a) => f(...a)
      });
      this._readyForCandidates.wake();
    } else {
      log13.warn("session was negotiated after connection became inactive", void 0, {
        F: __dxlog_file14,
        L: 356,
        S: this,
        C: (f, a) => f(...a)
      });
    }
  }
  _onConnectionCallbackAfterClose(callback, connection) {
    log13.warn("callback invoked after a connection was destroyed, this is probably a bug", {
      callback,
      state: connection.connectionState
    }, {
      F: __dxlog_file14,
      L: 361,
      S: this,
      C: (f, a) => f(...a)
    });
    this._safeCloseConnection(connection);
  }
  _safeCloseConnection(connection = this._connection) {
    const resetFields = this._connection && connection === this._connection;
    try {
      connection?.close();
    } catch (err) {
      log13.catch(err, void 0, {
        F: __dxlog_file14,
        L: 373,
        S: this,
        C: (f, a) => f(...a)
      });
    }
    if (resetFields) {
      this._connection = void 0;
      this._dataChannels.clear();
      this._readyForCandidates.wake();
      void this._factory.onConnectionDestroyed().catch((err) => log13.catch(err, void 0, {
        F: __dxlog_file14,
        L: 379,
        S: this,
        C: (f, a) => f(...a)
      }));
      for (const [_, pendingCallback] of this._channelCreatedCallbacks.entries()) {
        pendingCallback.reject("Connection closed.");
      }
      this._channelCreatedCallbacks.clear();
    }
  }
  async _loadConnectionConfig() {
    const config = {
      ...this._options.webrtcConfig
    };
    try {
      const providedIceServers = await this._options.iceProvider?.getIceServers() ?? [];
      if (providedIceServers.length > 0) {
        config.iceServers = [
          ...config.iceServers ?? [],
          ...providedIceServers
        ];
      }
    } catch (error) {
      log13.catch(error, void 0, {
        F: __dxlog_file14,
        L: 395,
        S: this,
        C: (f, a) => f(...a)
      });
    }
    return config;
  }
  async _sendIceCandidate(candidate) {
    try {
      await this._options.sendSignal({
        payload: {
          data: {
            type: "candidate",
            candidate: {
              candidate: candidate.candidate,
              // These fields never seem to be not null, but connecting to Chrome doesn't work if they are.
              sdpMLineIndex: candidate.sdpMLineIndex ?? "0",
              sdpMid: candidate.sdpMid ?? "0"
            }
          }
        }
      });
    } catch (err) {
      log13.warn("signaling error", {
        err
      }, {
        F: __dxlog_file14,
        L: 416,
        S: this,
        C: (f, a) => f(...a)
      });
    }
  }
  async _sendDescription(connection, description) {
    if (connection !== this._connection) {
      return;
    }
    const data = {
      type: description.type,
      sdp: description.sdp
    };
    await this._options.sendSignal({
      payload: {
        data
      }
    });
  }
  get _connectionInfo() {
    const connectionInfo = this._connection && {
      connectionState: this._connection.connectionState,
      iceConnectionState: this._connection.iceConnectionState,
      iceGatheringState: this._connection.iceGatheringState,
      signalingState: this._connection.signalingState,
      remoteDescription: this._connection.remoteDescription,
      localDescription: this._connection.localDescription
    };
    return {
      ...connectionInfo,
      ts: Date.now(),
      remotePeerKey: this._options.remotePeerKey,
      channels: [
        ...this._transportChannels.keys()
      ].map((topic) => topic),
      config: this._connection?.getConfiguration()
    };
  }
  get _loggerContext() {
    return {
      ownPeerKey: this._options.ownPeerKey,
      remotePeerKey: this._options.remotePeerKey,
      initiator: this._initiator,
      channels: this._transportChannels.size
    };
  }
};
_ts_decorate6([
  synchronized5
], RtcPeerConnection.prototype, "_openConnection", null);
_ts_decorate6([
  synchronized5
], RtcPeerConnection.prototype, "_lockAndAbort", null);
_ts_decorate6([
  synchronized5
], RtcPeerConnection.prototype, "_lockAndCloseConnection", null);
_ts_decorate6([
  synchronized5
], RtcPeerConnection.prototype, "onSignal", null);
_ts_decorate6([
  trace4.info()
], RtcPeerConnection.prototype, "_connectionInfo", null);
_ts_decorate6([
  logInfo4
], RtcPeerConnection.prototype, "_loggerContext", null);
RtcPeerConnection = _ts_decorate6([
  trace4.resource()
], RtcPeerConnection);
var isRemoteDescriptionSet = (connection, data) => {
  if (!connection.remoteDescription?.type || connection.remoteDescription?.type !== data.type) {
    return false;
  }
  return areSdpEqual(connection.remoteDescription.sdp, data.sdp);
};
var createIceFailureError = (details) => {
  const candidateErrors = details.map(({ url, errorCode, errorText }) => `${errorCode} ${url}: ${errorText}`);
  return new ConnectivityError3(`ICE failed:
${candidateErrors.join("\n")}`);
};

// packages/core/mesh/network-manager/src/transport/webrtc/rtc-transport-factory.ts
var createRtcTransportFactory = (webrtcConfig, iceProvider) => {
  const connectionFactory = getRtcConnectionFactory();
  return {
    createTransport: (options) => {
      const connection = new RtcPeerConnection(connectionFactory, {
        ownPeerKey: options.ownPeerKey,
        remotePeerKey: options.remotePeerKey,
        sendSignal: options.sendSignal,
        legacyInitiator: options.initiator,
        webrtcConfig,
        iceProvider
      });
      return connection.createTransportChannel(options);
    }
  };
};

// packages/core/mesh/network-manager/src/transport/webrtc/rtc-transport-proxy.ts
import { Writable } from "@dxos/node-std/stream";
import { Event as Event8, scheduleTask as scheduleTask4 } from "@dxos/async";
import { Resource as Resource2 } from "@dxos/context";
import { ErrorStream as ErrorStream5 } from "@dxos/debug";
import { invariant as invariant13 } from "@dxos/invariant";
import { PublicKey as PublicKey10 } from "@dxos/keys";
import { log as log14 } from "@dxos/log";
import { ConnectionResetError as ConnectionResetError2, ConnectivityError as ConnectivityError4, TimeoutError as TimeoutError3 } from "@dxos/protocols";
import { ConnectionState as ConnectionState3 } from "@dxos/protocols/proto/dxos/mesh/bridge";
import { arrayToBuffer } from "@dxos/util";
var __dxlog_file15 = "/home/runner/work/dxos/dxos/packages/core/mesh/network-manager/src/transport/webrtc/rtc-transport-proxy.ts";
var RPC_TIMEOUT = 1e4;
var CLOSE_RPC_TIMEOUT = 3e3;
var RESP_MIN_THRESHOLD = 500;
var RtcTransportProxy = class extends Resource2 {
  constructor(_options) {
    super(), this._options = _options, this._proxyId = PublicKey10.random(), this.closed = new Event8(), this.connected = new Event8(), this.errors = new ErrorStream5();
  }
  async _open() {
    let stream;
    try {
      stream = this._options.bridgeService.open({
        proxyId: this._proxyId,
        remotePeerKey: this._options.remotePeerKey,
        ownPeerKey: this._options.ownPeerKey,
        topic: this._options.topic,
        initiator: this._options.initiator ?? false
      }, {
        timeout: RPC_TIMEOUT
      });
    } catch (error) {
      this.errors.raise(error);
      return;
    }
    this._serviceStream = stream;
    stream.waitUntilReady().then(() => {
      stream.subscribe(async (event) => {
        log14("rtc transport proxy event", event, {
          F: __dxlog_file15,
          L: 66,
          S: this,
          C: (f, a) => f(...a)
        });
        if (event.connection) {
          await this._handleConnection(event.connection);
        } else if (event.data) {
          this._handleData(event.data);
        } else if (event.signal) {
          await this._handleSignal(event.signal);
        }
      }, (err) => {
        log14("rtc bridge stream closed", {
          err
        }, {
          F: __dxlog_file15,
          L: 76,
          S: this,
          C: (f, a) => f(...a)
        });
        if (err) {
          this._raiseIfOpen(err);
        } else {
          void this.close();
        }
      });
      const connectorStream = new Writable({
        write: (chunk, _, callback) => {
          const sendStartMs = Date.now();
          this._options.bridgeService.sendData({
            proxyId: this._proxyId,
            payload: chunk
          }, {
            timeout: RPC_TIMEOUT
          }).then(() => {
            if (Date.now() - sendStartMs > RESP_MIN_THRESHOLD) {
              log14("slow response, delaying callback", void 0, {
                F: __dxlog_file15,
                L: 93,
                S: this,
                C: (f, a) => f(...a)
              });
              scheduleTask4(this._ctx, () => callback(), RESP_MIN_THRESHOLD);
            } else {
              callback();
            }
          }, (err) => {
            callback();
            this._raiseIfOpen(err);
          });
        }
      });
      connectorStream.on("error", (err) => {
        this._raiseIfOpen(err);
      });
      this._options.stream.pipe(connectorStream);
    }, (error) => {
      if (error) {
        this._raiseIfOpen(error);
      } else {
        void this.close();
      }
    });
  }
  async _close() {
    try {
      await this._serviceStream?.close();
      this._serviceStream = void 0;
    } catch (err) {
      log14.catch(err, void 0, {
        F: __dxlog_file15,
        L: 128,
        S: this,
        C: (f, a) => f(...a)
      });
    }
    try {
      await this._options.bridgeService.close({
        proxyId: this._proxyId
      }, {
        timeout: CLOSE_RPC_TIMEOUT
      });
    } catch (err) {
      log14.catch(err, void 0, {
        F: __dxlog_file15,
        L: 134,
        S: this,
        C: (f, a) => f(...a)
      });
    }
    this.closed.emit();
  }
  async onSignal(signal) {
    this._options.bridgeService.sendSignal({
      proxyId: this._proxyId,
      signal
    }, {
      timeout: RPC_TIMEOUT
    }).catch((err) => this._raiseIfOpen(decodeError(err)));
  }
  async _handleConnection(connectionEvent) {
    if (connectionEvent.error) {
      this.errors.raise(decodeError(connectionEvent.error));
      return;
    }
    switch (connectionEvent.state) {
      case ConnectionState3.CONNECTED: {
        this.connected.emit();
        break;
      }
      case ConnectionState3.CLOSED: {
        await this.close();
        break;
      }
    }
  }
  _handleData(dataEvent) {
    try {
      this._options.stream.write(arrayToBuffer(dataEvent.payload));
    } catch (error) {
      this._raiseIfOpen(error);
    }
  }
  async _handleSignal(signalEvent) {
    try {
      await this._options.sendSignal(signalEvent.payload);
    } catch (error) {
      const type = signalEvent.payload.payload.data?.type;
      if (type === "offer" || type === "answer") {
        this._raiseIfOpen(new ConnectivityError4(`Session establishment failed: ${type} couldn't be sent.`));
      }
    }
  }
  async getDetails() {
    try {
      const response = await this._options.bridgeService.getDetails({
        proxyId: this._proxyId
      }, {
        timeout: RPC_TIMEOUT
      });
      return response.details;
    } catch (err) {
      return "bridge-svc unreachable";
    }
  }
  async getStats() {
    try {
      const response = await this._options.bridgeService.getStats({
        proxyId: this._proxyId
      }, {
        timeout: RPC_TIMEOUT
      });
      return response.stats;
    } catch (err) {
      return {
        bytesSent: 0,
        bytesReceived: 0,
        packetsSent: 0,
        packetsReceived: 0,
        rawStats: "bridge-svc unreachable"
      };
    }
  }
  _raiseIfOpen(error) {
    if (this.isOpen) {
      this.errors.raise(error);
    } else {
      log14.info("error swallowed because transport was closed", {
        message: error.message
      }, {
        F: __dxlog_file15,
        L: 215,
        S: this,
        C: (f, a) => f(...a)
      });
    }
  }
  /**
  * Called when underlying proxy service becomes unavailable.
  */
  forceClose() {
    void this._serviceStream?.close();
    this.closed.emit();
  }
};
var RtcTransportProxyFactory = class {
  constructor() {
    this._connections = /* @__PURE__ */ new Set();
  }
  /**
  * Sets the current BridgeService to be used to open connections.
  * Calling this method will close any existing connections.
  */
  setBridgeService(bridgeService) {
    this._bridgeService = bridgeService;
    for (const connection of this._connections) {
      connection.forceClose();
    }
    return this;
  }
  createTransport(options) {
    invariant13(this._bridgeService, "RtcTransportProxyFactory is not ready to open connections", {
      F: __dxlog_file15,
      L: 245,
      S: this,
      A: [
        "this._bridgeService",
        "'RtcTransportProxyFactory is not ready to open connections'"
      ]
    });
    const transport = new RtcTransportProxy({
      ...options,
      bridgeService: this._bridgeService
    });
    this._connections.add(transport);
    transport.closed.on(() => {
      this._connections.delete(transport);
    });
    return transport;
  }
};
var decodeError = (err) => {
  const message = typeof err === "string" ? err : err.message;
  if (message.includes("CONNECTION_RESET")) {
    return new ConnectionResetError2(message);
  } else if (message.includes("TIMEOUT")) {
    return new TimeoutError3(message);
  } else if (message.includes("CONNECTIVITY_ERROR")) {
    return new ConnectivityError4(message);
  } else {
    return typeof err === "string" ? new Error(err) : err;
  }
};

// packages/core/mesh/network-manager/src/transport/webrtc/rtc-transport-service.ts
import { Duplex as Duplex2 } from "@dxos/node-std/stream";
import { Stream } from "@dxos/codec-protobuf/stream";
import { invariant as invariant14 } from "@dxos/invariant";
import { PublicKey as PublicKey11 } from "@dxos/keys";
import { log as log15 } from "@dxos/log";
import { ConnectionState as ConnectionState4 } from "@dxos/protocols/proto/dxos/mesh/bridge";
import { ComplexMap as ComplexMap8 } from "@dxos/util";
var __dxlog_file16 = "/home/runner/work/dxos/dxos/packages/core/mesh/network-manager/src/transport/webrtc/rtc-transport-service.ts";
var RtcTransportService = class {
  constructor(webrtcConfig, iceProvider, _transportFactory = createRtcTransportFactory(webrtcConfig, iceProvider)) {
    this._transportFactory = _transportFactory;
    this._openTransports = new ComplexMap8(PublicKey11.hash);
  }
  hasOpenTransports() {
    return this._openTransports.size > 0;
  }
  open(request) {
    const existingTransport = this._openTransports.get(request.proxyId);
    if (existingTransport) {
      log15.error("requesting a new transport bridge for an existing proxy", void 0, {
        F: __dxlog_file16,
        L: 53,
        S: this,
        C: (f, a) => f(...a)
      });
      void this._safeCloseTransport(existingTransport);
      this._openTransports.delete(request.proxyId);
    }
    return new Stream(({ ready, next, close }) => {
      const pushNewState = createStateUpdater(next);
      const transportStream = new Duplex2({
        read: () => {
          const callbacks = [
            ...transportState.writeProcessedCallbacks
          ];
          transportState.writeProcessedCallbacks.length = 0;
          callbacks.forEach((cb) => cb());
        },
        write: function(chunk, _, callback) {
          next({
            data: {
              payload: chunk
            }
          });
          callback();
        }
      });
      const transport = this._transportFactory.createTransport({
        initiator: request.initiator,
        topic: request.topic,
        ownPeerKey: request.ownPeerKey,
        remotePeerKey: request.remotePeerKey,
        stream: transportStream,
        sendSignal: async (signal) => {
          next({
            signal: {
              payload: signal
            }
          });
        }
      });
      const transportState = {
        proxyId: request.proxyId,
        transport,
        connectorStream: transportStream,
        writeProcessedCallbacks: []
      };
      transport.connected.on(() => pushNewState(ConnectionState4.CONNECTED));
      transport.errors.handle(async (err) => {
        pushNewState(ConnectionState4.CLOSED, err);
        void this._safeCloseTransport(transportState);
        close(err);
      });
      transport.closed.on(async () => {
        pushNewState(ConnectionState4.CLOSED);
        void this._safeCloseTransport(transportState);
        close();
      });
      this._openTransports.set(request.proxyId, transportState);
      transport.open().catch(async (err) => {
        pushNewState(ConnectionState4.CLOSED, err);
        void this._safeCloseTransport(transportState);
        close(err);
      });
      ready();
      log15("stream ready", void 0, {
        F: __dxlog_file16,
        L: 115,
        S: this,
        C: (f, a) => f(...a)
      });
      pushNewState(ConnectionState4.CONNECTING);
    });
  }
  async sendSignal({ proxyId, signal }) {
    const transport = this._openTransports.get(proxyId);
    invariant14(transport, void 0, {
      F: __dxlog_file16,
      L: 123,
      S: this,
      A: [
        "transport",
        ""
      ]
    });
    await transport.transport.onSignal(signal);
  }
  async getDetails({ proxyId }) {
    const transport = this._openTransports.get(proxyId);
    invariant14(transport, void 0, {
      F: __dxlog_file16,
      L: 130,
      S: this,
      A: [
        "transport",
        ""
      ]
    });
    return {
      details: await transport.transport.getDetails()
    };
  }
  async getStats({ proxyId }) {
    const transport = this._openTransports.get(proxyId);
    invariant14(transport, void 0, {
      F: __dxlog_file16,
      L: 137,
      S: this,
      A: [
        "transport",
        ""
      ]
    });
    return {
      stats: await transport.transport.getStats()
    };
  }
  async sendData({ proxyId, payload }) {
    const transport = this._openTransports.get(proxyId);
    invariant14(transport, void 0, {
      F: __dxlog_file16,
      L: 144,
      S: this,
      A: [
        "transport",
        ""
      ]
    });
    const bufferHasSpace = transport.connectorStream.push(payload);
    if (!bufferHasSpace) {
      await new Promise((resolve) => {
        transport.writeProcessedCallbacks.push(resolve);
      });
    }
  }
  async close({ proxyId }) {
    const transport = this._openTransports.get(proxyId);
    if (!transport) {
      return;
    }
    this._openTransports.delete(proxyId);
    await this._safeCloseTransport(transport);
  }
  async _safeCloseTransport(transport) {
    if (this._openTransports.get(transport.proxyId) === transport) {
      this._openTransports.delete(transport.proxyId);
    }
    transport.writeProcessedCallbacks.forEach((cb) => cb());
    try {
      await transport.transport.close();
    } catch (error) {
      log15.warn("transport close error", {
        message: error?.message
      }, {
        F: __dxlog_file16,
        L: 174,
        S: this,
        C: (f, a) => f(...a)
      });
    }
    try {
      transport.connectorStream.end();
    } catch (error) {
      log15.warn("connectorStream close error", {
        message: error?.message
      }, {
        F: __dxlog_file16,
        L: 179,
        S: this,
        C: (f, a) => f(...a)
      });
    }
    log15("closed", void 0, {
      F: __dxlog_file16,
      L: 181,
      S: this,
      C: (f, a) => f(...a)
    });
  }
};
var createStateUpdater = (next) => {
  return (state, err) => {
    next({
      connection: {
        state,
        ...err ? {
          error: err.message
        } : void 0
      }
    });
  };
};

// packages/core/mesh/network-manager/src/wire-protocol.ts
import { Teleport } from "@dxos/teleport";
var createTeleportProtocolFactory = (onConnection, defaultParams) => {
  return (params) => {
    const teleport = new Teleport({
      ...defaultParams,
      ...params
    });
    return {
      stream: teleport.stream,
      open: async (sessionId) => {
        await teleport.open(sessionId);
        await onConnection(teleport);
      },
      close: async () => {
        await teleport.close();
      },
      abort: async () => {
        await teleport.abort();
      }
    };
  };
};

export {
  ConnectionState,
  Connection,
  createIceProvider,
  SwarmMessenger,
  Swarm,
  SwarmMapper,
  MAX_CONCURRENT_INITIATING_CONNECTIONS,
  ConnectionLimiter,
  EventType,
  ConnectionLog,
  SwarmNetworkManager,
  FullyConnectedTopology,
  MMSTTopology,
  StarTopology,
  MemoryTransportFactory,
  MemoryTransport,
  TransportKind,
  createRtcTransportFactory,
  RtcTransportProxy,
  RtcTransportProxyFactory,
  RtcTransportService,
  createTeleportProtocolFactory
};
//# sourceMappingURL=chunk-LFKR6BAF.mjs.map
