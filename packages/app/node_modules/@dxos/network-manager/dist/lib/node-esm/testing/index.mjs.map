{
  "version": 3,
  "sources": ["../../../../src/testing/test-builder.ts", "../../../../src/testing/test-wire-protocol.ts"],
  "sourcesContent": ["//\n// Copyright 2022 DXOS.org\n//\n\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport {\n  MemorySignalManager,\n  MemorySignalManagerContext,\n  type SignalManager,\n  WebsocketSignalManager,\n} from '@dxos/messaging';\nimport { schema } from '@dxos/protocols/proto';\nimport { ConnectionState } from '@dxos/protocols/proto/dxos/client/services';\nimport { type Runtime } from '@dxos/protocols/proto/dxos/config';\nimport { createLinkedPorts, createProtoRpcPeer, type ProtoRpcPeer } from '@dxos/rpc';\nimport { ComplexMap } from '@dxos/util';\n\nimport { TcpTransportFactory } from '#tcp-transport';\nimport { type TestTeleportExtensionFactory, TestWireProtocol } from './test-wire-protocol';\nimport { SwarmNetworkManager } from '../network-manager';\nimport { FullyConnectedTopology } from '../topology';\nimport { MemoryTransportFactory, type TransportFactory, TransportKind } from '../transport';\nimport { createRtcTransportFactory, RtcTransportProxyFactory, RtcTransportService } from '../transport';\n\n// Signal server will be started by the setup script.\nconst port = process.env.SIGNAL_PORT ?? 4000;\nexport const TEST_SIGNAL_HOSTS: Runtime.Services.Signal[] = [\n  { server: `ws://localhost:${port}/.well-known/dx/signal` },\n];\n\nexport type TestBuilderOptions = {\n  signalHosts?: Runtime.Services.Signal[];\n  bridge?: boolean;\n  transport?: TransportKind;\n};\n\n/**\n * Builder used to construct networks and peers.\n */\nexport class TestBuilder {\n  private _signalContext = new MemorySignalManagerContext();\n\n  constructor(public readonly options: TestBuilderOptions = {}) {}\n\n  createSignalManager(): WebsocketSignalManager | MemorySignalManager {\n    if (this.options.signalHosts) {\n      return new WebsocketSignalManager(this.options.signalHosts);\n    }\n\n    return new MemorySignalManager(this._signalContext);\n  }\n\n  createPeer(peerId: PublicKey = PublicKey.random()): TestPeer {\n    return new TestPeer(this, peerId, this.options.transport);\n  }\n}\n\n/**\n * Testing network peer.\n */\nexport class TestPeer {\n  private readonly _swarms = new ComplexMap<PublicKey, TestSwarmConnection>(PublicKey.hash);\n\n  /**\n   * @internal\n   */\n  readonly _signalManager: SignalManager;\n\n  /**\n   * @internal\n   */\n  readonly _networkManager: SwarmNetworkManager;\n\n  private _proxy?: ProtoRpcPeer<any>;\n  private _service?: ProtoRpcPeer<any>;\n\n  constructor(\n    private readonly testBuilder: TestBuilder,\n    public readonly peerId: PublicKey,\n    public readonly transport: TransportKind = testBuilder.options.signalHosts\n      ? TransportKind.WEB_RTC\n      : TransportKind.MEMORY,\n  ) {\n    this._signalManager = this.testBuilder.createSignalManager();\n    this._networkManager = this.createNetworkManager(this.transport);\n    this._networkManager.setPeerInfo({ identityKey: peerId.toHex(), peerKey: peerId.toHex() });\n  }\n\n  // TODO(burdon): Move to TestBuilder.\n  createNetworkManager(transport: TransportKind): SwarmNetworkManager {\n    let transportFactory: TransportFactory;\n    if (this.testBuilder.options.signalHosts) {\n      log.info(`using ${transport} transport with signal server.`);\n      switch (transport) {\n        case TransportKind.MEMORY:\n          throw new Error('Memory transport not supported with signal server.');\n        case TransportKind.TCP:\n          transportFactory = TcpTransportFactory;\n          break;\n        case TransportKind.WEB_RTC:\n          transportFactory = createRtcTransportFactory();\n          break;\n        case TransportKind.WEB_RTC_PROXY:\n          {\n            // Simulates bridge to shared worker.\n            const [proxyPort, servicePort] = createLinkedPorts();\n\n            this._proxy = createProtoRpcPeer({\n              port: proxyPort,\n              requested: {\n                BridgeService: schema.getService('dxos.mesh.bridge.BridgeService'),\n              },\n              noHandshake: true,\n              encodingOptions: {\n                preserveAny: true,\n              },\n            });\n\n            this._service = createProtoRpcPeer({\n              port: servicePort,\n              exposed: {\n                BridgeService: schema.getService('dxos.mesh.bridge.BridgeService'),\n              },\n              handlers: { BridgeService: new RtcTransportService() },\n              noHandshake: true,\n              encodingOptions: {\n                preserveAny: true,\n              },\n            });\n\n            transportFactory = new RtcTransportProxyFactory().setBridgeService(this._proxy.rpc.BridgeService);\n          }\n          break;\n        default:\n          throw new Error(`Unsupported transport: ${transport}`);\n      }\n    } else {\n      if (transport !== TransportKind.MEMORY && transport !== TransportKind.TCP) {\n        log.warn(`specified transport ${transport} but no signalling configured, using memory transport instead`);\n      }\n      log.info(`using ${transport} transport without signal server.`);\n      transportFactory = MemoryTransportFactory;\n    }\n\n    return new SwarmNetworkManager({\n      signalManager: this._signalManager,\n      transportFactory,\n    });\n  }\n\n  async open(): Promise<void> {\n    await this._networkManager.open();\n    await this._proxy?.open();\n    await this._service?.open();\n  }\n\n  async close(): Promise<void> {\n    await Promise.all(Array.from(this._swarms.values()).map((swarm) => swarm.leave()));\n    this._swarms.clear();\n\n    await this._proxy?.close();\n    await this._service?.close();\n    await this._networkManager.close();\n  }\n\n  getSwarm(topic: PublicKey): TestSwarmConnection {\n    const swarm = this._swarms.get(topic);\n    if (!swarm) {\n      throw new Error(`Swarm not found for topic: ${topic}`);\n    }\n\n    return swarm;\n  }\n\n  createSwarm(topic: PublicKey, extensionFactory: TestTeleportExtensionFactory = () => []): TestSwarmConnection {\n    // TODO(burdon): Multiple.\n    // if (this._swarms.get(topic)) {\n    //   throw new Error(`Swarm already exists for topic: ${topic.truncate()}`);\n    // }\n\n    const swarm = new TestSwarmConnection(this, topic, extensionFactory);\n    this._swarms.set(topic, swarm);\n    return swarm;\n  }\n\n  async goOffline(): Promise<void> {\n    await this._networkManager.setConnectionState(ConnectionState.OFFLINE);\n  }\n\n  async goOnline(): Promise<void> {\n    await this._networkManager.setConnectionState(ConnectionState.ONLINE);\n  }\n}\n\n// TODO(burdon): Reconcile with new Swarm concept.\nexport class TestSwarmConnection {\n  protocol: TestWireProtocol;\n\n  constructor(\n    readonly peer: TestPeer,\n    readonly topic: PublicKey,\n    readonly extensionFactory: TestTeleportExtensionFactory,\n  ) {\n    // TODO(burdon): Configure plugins.\n    // TODO(burdon): Prevent reuse?\n    this.protocol = new TestWireProtocol(this.extensionFactory);\n  }\n\n  // TODO(burdon): Need to create new plugin instance per swarm?\n  //  If so, then perhaps joinSwarm should return swarm object with access to plugins.\n  async join(topology = new FullyConnectedTopology()): Promise<this> {\n    await this.peer._networkManager.joinSwarm({\n      topic: this.topic,\n      peerInfo: { peerKey: this.peer.peerId.toHex(), identityKey: this.peer.peerId.toHex() },\n      protocolProvider: this.protocol.factory,\n      topology,\n    });\n\n    return this;\n  }\n\n  async leave(): Promise<this> {\n    await this.peer._networkManager.leaveSwarm(this.topic);\n    return this;\n  }\n}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { asyncTimeout, Event } from '@dxos/async';\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { TestExtension, TestExtensionWithStreams } from '@dxos/teleport';\nimport type { TestStreamStats, TeleportExtension } from '@dxos/teleport';\nimport { ComplexMap } from '@dxos/util';\n\nimport { createTeleportProtocolFactory } from '../wire-protocol';\n\nexport type TestTeleportExtension = {\n  name: string;\n  extension: TeleportExtension;\n};\n\nexport type TestTeleportExtensionFactory = () => TestTeleportExtension[];\n\nexport class TestWireProtocol {\n  public readonly connections = new ComplexMap<PublicKey, TestExtension>(PublicKey.hash);\n  public readonly streamConnections = new ComplexMap<PublicKey, TestExtensionWithStreams>(PublicKey.hash);\n\n  public readonly connected = new Event<PublicKey>();\n  public readonly disconnected = new Event<PublicKey>();\n\n  public readonly otherConnections = new ComplexMap<{ remotePeerId: PublicKey; extension: string }, TeleportExtension>(\n    ({ remotePeerId, extension }) => remotePeerId.toHex() + extension,\n  );\n\n  constructor(private readonly _extensionFactory: TestTeleportExtensionFactory = () => []) {}\n\n  readonly factory = createTeleportProtocolFactory(async (teleport) => {\n    log('create', { remotePeerId: teleport.remotePeerId });\n    const handleDisconnect = () => {\n      this.connections.delete(teleport.remotePeerId);\n      this.disconnected.emit(teleport.remotePeerId);\n    };\n    const extension = new TestExtension({\n      onClose: async () => handleDisconnect(),\n      onAbort: async () => handleDisconnect(),\n    });\n    this.connections.set(teleport.remotePeerId, extension);\n    teleport.addExtension('test', extension);\n    this.connected.emit(teleport.remotePeerId);\n\n    const streamExtension = new TestExtensionWithStreams({\n      onClose: async () => {\n        this.streamConnections.delete(teleport.remotePeerId);\n      },\n    });\n    this.streamConnections.set(teleport.remotePeerId, streamExtension);\n    teleport.addExtension('test-stream', streamExtension);\n\n    for (const { name, extension } of this._extensionFactory()) {\n      this.otherConnections.set({ remotePeerId: teleport.remotePeerId, extension: name }, extension);\n      teleport.addExtension(name, extension);\n    }\n  });\n\n  async waitForConnection(peerId: PublicKey): Promise<TestExtension> {\n    if (this.connections.has(peerId)) {\n      return this.connections.get(peerId)!;\n    }\n    log('waitForConnection', { peerId });\n    await asyncTimeout(\n      this.connected.waitFor((connectedId) => connectedId.equals(peerId)),\n      // TODO(nf): Make this configurable.\n      10_000,\n    );\n    return this.connections.get(peerId)!;\n  }\n\n  async testConnection(peerId: PublicKey, message?: string): Promise<void> {\n    const connection = await this.waitForConnection(peerId);\n    await connection.test(message);\n  }\n\n  async openStream(\n    peerId: PublicKey,\n    streamTag: string,\n    streamLoadInterval: number,\n    streamLoadChunkSize: number,\n  ): Promise<string> {\n    if (!this.streamConnections.has(peerId)) {\n      throw new Error('Connection does not exist.');\n    }\n    const connection = this.streamConnections.get(peerId)!;\n    return connection.addNewStream(streamLoadInterval, streamLoadChunkSize, streamTag);\n  }\n\n  async closeStream(peerId: PublicKey, streamTag: string): Promise<TestStreamStats> {\n    if (!this.streamConnections.has(peerId)) {\n      throw new Error('Connection does not exist.');\n    }\n    const connection = this.streamConnections.get(peerId)!;\n    return connection.closeStream(streamTag);\n  }\n}\n"],
  "mappings": "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",
  "names": ["PublicKey", "log", "MemorySignalManager", "MemorySignalManagerContext", "WebsocketSignalManager", "schema", "ConnectionState", "createLinkedPorts", "createProtoRpcPeer", "ComplexMap", "TcpTransportFactory", "asyncTimeout", "Event", "PublicKey", "log", "TestExtension", "TestExtensionWithStreams", "ComplexMap", "TestWireProtocol", "_extensionFactory", "connections", "ComplexMap", "PublicKey", "hash", "streamConnections", "connected", "Event", "disconnected", "otherConnections", "remotePeerId", "extension", "toHex", "factory", "createTeleportProtocolFactory", "teleport", "log", "handleDisconnect", "delete", "emit", "TestExtension", "onClose", "onAbort", "set", "addExtension", "streamExtension", "TestExtensionWithStreams", "name", "waitForConnection", "peerId", "has", "get", "asyncTimeout", "waitFor", "connectedId", "equals", "testConnection", "message", "connection", "test", "openStream", "streamTag", "streamLoadInterval", "streamLoadChunkSize", "Error", "addNewStream", "closeStream", "port", "process", "env", "SIGNAL_PORT", "TEST_SIGNAL_HOSTS", "server", "TestBuilder", "options", "_signalContext", "MemorySignalManagerContext", "createSignalManager", "signalHosts", "WebsocketSignalManager", "MemorySignalManager", "createPeer", "peerId", "PublicKey", "random", "TestPeer", "transport", "testBuilder", "TransportKind", "WEB_RTC", "MEMORY", "_swarms", "ComplexMap", "hash", "_signalManager", "_networkManager", "createNetworkManager", "setPeerInfo", "identityKey", "toHex", "peerKey", "transportFactory", "log", "info", "Error", "TCP", "TcpTransportFactory", "createRtcTransportFactory", "WEB_RTC_PROXY", "proxyPort", "servicePort", "createLinkedPorts", "_proxy", "createProtoRpcPeer", "requested", "BridgeService", "schema", "getService", "noHandshake", "encodingOptions", "preserveAny", "_service", "exposed", "handlers", "RtcTransportService", "RtcTransportProxyFactory", "setBridgeService", "rpc", "warn", "MemoryTransportFactory", "SwarmNetworkManager", "signalManager", "open", "close", "Promise", "all", "Array", "from", "values", "map", "swarm", "leave", "clear", "getSwarm", "topic", "get", "createSwarm", "extensionFactory", "TestSwarmConnection", "set", "goOffline", "setConnectionState", "ConnectionState", "OFFLINE", "goOnline", "ONLINE", "peer", "protocol", "TestWireProtocol", "join", "topology", "FullyConnectedTopology", "joinSwarm", "peerInfo", "protocolProvider", "factory", "leaveSwarm"]
}
