import { createRequire } from 'node:module';const require = createRequire(import.meta.url);

// packages/core/mesh/network-manager/src/transport/tcp/tcp-transport.ts
import { Socket } from "node:net";
import { Event } from "@dxos/async";
import { ErrorStream } from "@dxos/debug";
import { log } from "@dxos/log";
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/core/mesh/network-manager/src/transport/tcp/tcp-transport.ts";
var TcpTransportFactory = {
  createTransport: (options) => new TcpTransport(options)
};
var TcpTransport = class {
  constructor(options) {
    this.options = options;
    this._server = void 0;
    this._socket = void 0;
    this._connected = false;
    this._closed = false;
    this.closed = new Event();
    this.connected = new Event();
    this.errors = new ErrorStream();
  }
  get isOpen() {
    return this._connected && !this._closed;
  }
  async open() {
    log("opening", void 0, {
      F: __dxlog_file,
      L: 39,
      S: this,
      C: (f, a) => f(...a)
    });
    if (this.options.initiator) {
      setTimeout(async () => {
        const { Server } = await import("node:net");
        this._server = new Server((socket) => {
          log("new connection", void 0, {
            F: __dxlog_file,
            L: 47,
            S: this,
            C: (f, a) => f(...a)
          });
          if (this._connected) {
            socket.destroy();
          }
          this._handleSocket(socket);
        });
        this._server.on("listening", () => {
          const { port } = this._server.address();
          log("listening", {
            port
          }, {
            F: __dxlog_file,
            L: 56,
            S: this,
            C: (f, a) => f(...a)
          });
          void this.options.sendSignal({
            payload: {
              port
            }
          }).catch((err) => {
            if (!this._closed) {
              this.errors.raise(err);
            }
          });
        });
        this._server.on("error", (err) => {
          this.errors.raise(err);
        });
        this._server.listen(0);
      });
    }
    return this;
  }
  async close() {
    log("closing", void 0, {
      F: __dxlog_file,
      L: 79,
      S: this,
      C: (f, a) => f(...a)
    });
    this._socket?.destroy();
    this._server?.close();
    this._closed = true;
    return this;
  }
  async onSignal({ payload }) {
    log("received signal", {
      payload
    }, {
      F: __dxlog_file,
      L: 87,
      S: this,
      C: (f, a) => f(...a)
    });
    if (this.options.initiator || this._connected) {
      return;
    }
    const socket = new Socket();
    this._handleSocket(socket);
    socket.connect({
      port: payload.port,
      host: "localhost"
    });
  }
  async getDetails() {
    if (this.options.initiator) {
      const { port: port2, address: address2 } = this._server?.address();
      return `LISTEN ${address2}:${port2}`;
    }
    const { port, address } = this._socket?.address();
    return `ACCEPT ${address}:${port}`;
  }
  async getStats() {
    return {
      bytesSent: 0,
      bytesReceived: 0,
      packetsSent: 0,
      packetsReceived: 0
    };
  }
  _handleSocket(socket) {
    log("handling socket", {
      remotePort: socket.remotePort,
      localPort: socket.localPort
    }, {
      F: __dxlog_file,
      L: 117,
      S: this,
      C: (f, a) => f(...a)
    });
    this._socket = socket;
    this._socket.on("connect", () => {
      log("connected to", {
        port: this._socket?.remotePort
      }, {
        F: __dxlog_file,
        L: 121,
        S: this,
        C: (f, a) => f(...a)
      });
      this._connected = true;
    });
    this._socket.on("error", (err) => {
      this.errors.raise(err);
    });
    this._socket.on("close", () => {
      this.closed.emit();
    });
    this.connected.emit();
    this.options.stream.pipe(this._socket).pipe(this.options.stream);
  }
};
export {
  TcpTransport,
  TcpTransportFactory
};
//# sourceMappingURL=index.mjs.map
