{
  "version": 3,
  "sources": ["../../../../../src/transport/tcp/tcp-transport.ts"],
  "sourcesContent": ["//\n// Copyright 2020 DXOS.org\n//\n\nimport { type AddressInfo, Socket, type Server } from 'node:net';\n\nimport { Event } from '@dxos/async';\nimport { ErrorStream } from '@dxos/debug';\nimport { log } from '@dxos/log';\nimport { type Signal } from '@dxos/protocols/proto/dxos/mesh/swarm';\n\nimport { type Transport, type TransportFactory, type TransportOptions, type TransportStats } from '../transport';\n\nexport const TcpTransportFactory: TransportFactory = {\n  createTransport: (options) => new TcpTransport(options),\n};\n\n/**\n * Fake transport.\n */\nexport class TcpTransport implements Transport {\n  private _server?: Server = undefined;\n  private _socket?: Socket = undefined;\n\n  private _connected = false;\n  private _closed = false;\n\n  public readonly closed = new Event<void>();\n  public readonly connected = new Event<void>();\n  public readonly errors = new ErrorStream();\n\n  constructor(private readonly options: TransportOptions) {}\n\n  get isOpen() {\n    return this._connected && !this._closed;\n  }\n\n  async open(): Promise<this> {\n    log('opening');\n\n    // Initiator will send a signal, the receiver will receive the unique ID and connect the streams.\n    if (this.options.initiator) {\n      // TODO(burdon): Why timeout?\n      setTimeout(async () => {\n        const { Server } = await import('node:net');\n        this._server = new Server((socket) => {\n          log('new connection');\n          if (this._connected) {\n            socket.destroy();\n          }\n          this._handleSocket(socket);\n        });\n\n        this._server.on('listening', () => {\n          const { port } = this._server!.address() as AddressInfo;\n          log('listening', { port });\n          void this.options\n            .sendSignal({\n              payload: { port },\n            })\n            .catch((err) => {\n              if (!this._closed) {\n                this.errors.raise(err);\n              }\n            });\n        });\n\n        this._server.on('error', (err) => {\n          this.errors.raise(err);\n        });\n\n        this._server.listen(0);\n      });\n    }\n    return this;\n  }\n\n  async close(): Promise<this> {\n    log('closing');\n    this._socket?.destroy();\n    this._server?.close();\n    this._closed = true;\n    return this;\n  }\n\n  async onSignal({ payload }: Signal): Promise<void> {\n    log('received signal', { payload });\n    if (this.options.initiator || this._connected) {\n      return;\n    }\n\n    const socket = new Socket();\n    this._handleSocket(socket);\n    socket.connect({ port: payload.port, host: 'localhost' });\n  }\n\n  async getDetails(): Promise<string> {\n    if (this.options.initiator) {\n      const { port, address } = this._server?.address() as AddressInfo;\n      return `LISTEN ${address}:${port}`;\n    }\n\n    const { port, address } = this._socket?.address() as AddressInfo;\n    return `ACCEPT ${address}:${port}`;\n  }\n\n  async getStats(): Promise<TransportStats> {\n    return {\n      bytesSent: 0,\n      bytesReceived: 0,\n      packetsSent: 0,\n      packetsReceived: 0,\n    };\n  }\n\n  private _handleSocket(socket: Socket): void {\n    log('handling socket', { remotePort: socket.remotePort, localPort: socket.localPort });\n    this._socket = socket;\n\n    this._socket.on('connect', () => {\n      log('connected to', { port: this._socket?.remotePort });\n      this._connected = true;\n    });\n\n    this._socket.on('error', (err) => {\n      this.errors.raise(err);\n    });\n\n    this._socket.on('close', () => {\n      this.closed.emit();\n    });\n\n    this.connected.emit();\n    this.options.stream.pipe(this._socket!).pipe(this.options.stream);\n  }\n}\n"],
  "mappings": "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",
  "names": ["Socket", "Event", "ErrorStream", "log", "TcpTransportFactory", "createTransport", "options", "TcpTransport", "_server", "undefined", "_socket", "_connected", "_closed", "closed", "connected", "errors", "isOpen", "open", "initiator", "setTimeout", "Server", "socket", "destroy", "_handleSocket", "on", "port", "address", "sendSignal", "payload", "catch", "err", "raise", "listen", "close", "onSignal", "connect", "host", "getDetails", "getStats", "bytesSent", "bytesReceived", "packetsSent", "packetsReceived", "remotePort", "localPort", "emit", "stream", "pipe"]
}
