"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var tcp_exports = {};
__export(tcp_exports, {
  TcpTransport: () => TcpTransport,
  TcpTransportFactory: () => TcpTransportFactory
});
module.exports = __toCommonJS(tcp_exports);
var import_node_net = require("node:net");
var import_async = require("@dxos/async");
var import_debug = require("@dxos/debug");
var import_log = require("@dxos/log");
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/core/mesh/network-manager/src/transport/tcp/tcp-transport.ts";
var TcpTransportFactory = {
  createTransport: (options) => new TcpTransport(options)
};
var TcpTransport = class {
  constructor(options) {
    this.options = options;
    this._server = void 0;
    this._socket = void 0;
    this._connected = false;
    this._closed = false;
    this.closed = new import_async.Event();
    this.connected = new import_async.Event();
    this.errors = new import_debug.ErrorStream();
  }
  get isOpen() {
    return this._connected && !this._closed;
  }
  async open() {
    (0, import_log.log)("opening", void 0, {
      F: __dxlog_file,
      L: 39,
      S: this,
      C: (f, a) => f(...a)
    });
    if (this.options.initiator) {
      setTimeout(async () => {
        const { Server } = await import("node:net");
        this._server = new Server((socket) => {
          (0, import_log.log)("new connection", void 0, {
            F: __dxlog_file,
            L: 47,
            S: this,
            C: (f, a) => f(...a)
          });
          if (this._connected) {
            socket.destroy();
          }
          this._handleSocket(socket);
        });
        this._server.on("listening", () => {
          const { port } = this._server.address();
          (0, import_log.log)("listening", {
            port
          }, {
            F: __dxlog_file,
            L: 56,
            S: this,
            C: (f, a) => f(...a)
          });
          void this.options.sendSignal({
            payload: {
              port
            }
          }).catch((err) => {
            if (!this._closed) {
              this.errors.raise(err);
            }
          });
        });
        this._server.on("error", (err) => {
          this.errors.raise(err);
        });
        this._server.listen(0);
      });
    }
    return this;
  }
  async close() {
    (0, import_log.log)("closing", void 0, {
      F: __dxlog_file,
      L: 79,
      S: this,
      C: (f, a) => f(...a)
    });
    this._socket?.destroy();
    this._server?.close();
    this._closed = true;
    return this;
  }
  async onSignal({ payload }) {
    (0, import_log.log)("received signal", {
      payload
    }, {
      F: __dxlog_file,
      L: 87,
      S: this,
      C: (f, a) => f(...a)
    });
    if (this.options.initiator || this._connected) {
      return;
    }
    const socket = new import_node_net.Socket();
    this._handleSocket(socket);
    socket.connect({
      port: payload.port,
      host: "localhost"
    });
  }
  async getDetails() {
    if (this.options.initiator) {
      const { port: port2, address: address2 } = this._server?.address();
      return `LISTEN ${address2}:${port2}`;
    }
    const { port, address } = this._socket?.address();
    return `ACCEPT ${address}:${port}`;
  }
  async getStats() {
    return {
      bytesSent: 0,
      bytesReceived: 0,
      packetsSent: 0,
      packetsReceived: 0
    };
  }
  _handleSocket(socket) {
    (0, import_log.log)("handling socket", {
      remotePort: socket.remotePort,
      localPort: socket.localPort
    }, {
      F: __dxlog_file,
      L: 117,
      S: this,
      C: (f, a) => f(...a)
    });
    this._socket = socket;
    this._socket.on("connect", () => {
      (0, import_log.log)("connected to", {
        port: this._socket?.remotePort
      }, {
        F: __dxlog_file,
        L: 121,
        S: this,
        C: (f, a) => f(...a)
      });
      this._connected = true;
    });
    this._socket.on("error", (err) => {
      this.errors.raise(err);
    });
    this._socket.on("close", () => {
      this.closed.emit();
    });
    this.connected.emit();
    this.options.stream.pipe(this._socket).pipe(this.options.stream);
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  TcpTransport,
  TcpTransportFactory
});
//# sourceMappingURL=index.cjs.map
