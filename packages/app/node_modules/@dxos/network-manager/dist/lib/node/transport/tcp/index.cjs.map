{
  "version": 3,
  "sources": ["../../../../../src/transport/tcp/tcp-transport.ts"],
  "sourcesContent": ["//\n// Copyright 2020 DXOS.org\n//\n\nimport { type AddressInfo, Socket, type Server } from 'node:net';\n\nimport { Event } from '@dxos/async';\nimport { ErrorStream } from '@dxos/debug';\nimport { log } from '@dxos/log';\nimport { type Signal } from '@dxos/protocols/proto/dxos/mesh/swarm';\n\nimport { type Transport, type TransportFactory, type TransportOptions, type TransportStats } from '../transport';\n\nexport const TcpTransportFactory: TransportFactory = {\n  createTransport: (options) => new TcpTransport(options),\n};\n\n/**\n * Fake transport.\n */\nexport class TcpTransport implements Transport {\n  private _server?: Server = undefined;\n  private _socket?: Socket = undefined;\n\n  private _connected = false;\n  private _closed = false;\n\n  public readonly closed = new Event<void>();\n  public readonly connected = new Event<void>();\n  public readonly errors = new ErrorStream();\n\n  constructor(private readonly options: TransportOptions) {}\n\n  get isOpen() {\n    return this._connected && !this._closed;\n  }\n\n  async open(): Promise<this> {\n    log('opening');\n\n    // Initiator will send a signal, the receiver will receive the unique ID and connect the streams.\n    if (this.options.initiator) {\n      // TODO(burdon): Why timeout?\n      setTimeout(async () => {\n        const { Server } = await import('node:net');\n        this._server = new Server((socket) => {\n          log('new connection');\n          if (this._connected) {\n            socket.destroy();\n          }\n          this._handleSocket(socket);\n        });\n\n        this._server.on('listening', () => {\n          const { port } = this._server!.address() as AddressInfo;\n          log('listening', { port });\n          void this.options\n            .sendSignal({\n              payload: { port },\n            })\n            .catch((err) => {\n              if (!this._closed) {\n                this.errors.raise(err);\n              }\n            });\n        });\n\n        this._server.on('error', (err) => {\n          this.errors.raise(err);\n        });\n\n        this._server.listen(0);\n      });\n    }\n    return this;\n  }\n\n  async close(): Promise<this> {\n    log('closing');\n    this._socket?.destroy();\n    this._server?.close();\n    this._closed = true;\n    return this;\n  }\n\n  async onSignal({ payload }: Signal): Promise<void> {\n    log('received signal', { payload });\n    if (this.options.initiator || this._connected) {\n      return;\n    }\n\n    const socket = new Socket();\n    this._handleSocket(socket);\n    socket.connect({ port: payload.port, host: 'localhost' });\n  }\n\n  async getDetails(): Promise<string> {\n    if (this.options.initiator) {\n      const { port, address } = this._server?.address() as AddressInfo;\n      return `LISTEN ${address}:${port}`;\n    }\n\n    const { port, address } = this._socket?.address() as AddressInfo;\n    return `ACCEPT ${address}:${port}`;\n  }\n\n  async getStats(): Promise<TransportStats> {\n    return {\n      bytesSent: 0,\n      bytesReceived: 0,\n      packetsSent: 0,\n      packetsReceived: 0,\n    };\n  }\n\n  private _handleSocket(socket: Socket): void {\n    log('handling socket', { remotePort: socket.remotePort, localPort: socket.localPort });\n    this._socket = socket;\n\n    this._socket.on('connect', () => {\n      log('connected to', { port: this._socket?.remotePort });\n      this._connected = true;\n    });\n\n    this._socket.on('error', (err) => {\n      this.errors.raise(err);\n    });\n\n    this._socket.on('close', () => {\n      this.closed.emit();\n    });\n\n    this.connected.emit();\n    this.options.stream.pipe(this._socket!).pipe(this.options.stream);\n  }\n}\n"],
  "mappings": "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",
  "names": ["TcpTransportFactory", "createTransport", "options", "TcpTransport", "_server", "undefined", "_socket", "_connected", "_closed", "closed", "Event", "connected", "errors", "ErrorStream", "isOpen", "open", "log", "initiator", "setTimeout", "Server", "socket", "destroy", "_handleSocket", "on", "port", "address", "sendSignal", "payload", "catch", "err", "raise", "listen", "close", "onSignal", "Socket", "connect", "host", "getDetails", "getStats", "bytesSent", "bytesReceived", "packetsSent", "packetsReceived", "remotePort", "localPort", "emit", "stream", "pipe"]
}
