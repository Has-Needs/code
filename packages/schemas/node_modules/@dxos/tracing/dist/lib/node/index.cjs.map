{
  "version": 3,
  "sources": ["../../../src/api.ts", "../../../src/symbols.ts", "../../../src/trace-processor.ts", "../../../src/diagnostic.ts", "../../../src/util.ts", "../../../src/diagnostics-channel.ts", "../../../src/remote/metrics.ts", "../../../src/remote/tracing.ts", "../../../src/trace-sender.ts", "../../../src/weak-ref.ts", "../../../src/metrics/base.ts", "../../../src/metrics/unary-counter.ts", "../../../src/metrics/time-series-counter.ts", "../../../src/metrics/time-usage-counter.ts", "../../../src/metrics/map-counter.ts", "../../../src/metrics/custom-counter.ts", "../../../src/index.ts"],
  "sourcesContent": ["//\n// Copyright 2023 DXOS.org\n//\n\nimport { Context } from '@dxos/context';\nimport { type MaybePromise } from '@dxos/util';\n\nimport { getTracingContext } from './symbols';\nimport { TRACE_PROCESSOR, type TraceSpanParams, type TracingSpan } from './trace-processor';\n\n/**\n * Annotates a class as a tracked resource.\n */\nconst resource =\n  (options?: { annotation?: symbol }) =>\n  <T extends { new (...args: any[]): {} }>(constructor: T) => {\n    // Wrapping class declaration into an IIFE so it doesn't capture the `klass` class name.\n    const klass = (() =>\n      class extends constructor {\n        constructor(...rest: any[]) {\n          super(...rest);\n          TRACE_PROCESSOR.createTraceResource({ constructor, annotation: options?.annotation, instance: this });\n        }\n      })();\n    Object.defineProperty(klass, 'name', { value: constructor.name });\n    return klass;\n  };\n\nexport interface TimeAware {\n  tick(timeMs: number): void;\n}\n\nexport type InfoOptions = {\n  /**\n   * Value is of enum type and should be converted to string.\n   *\n   * Example:\n   *\n   * ```ts\n   * @trace.info({ enum: SpaceState })\n   * get state(): SpaceState { ... }\n   * ```\n   */\n  enum?: Record<string, any>;\n\n  /**\n   * Max depth of the object to be included in the resource info section.\n   *\n   * null means no limit (a limit of 8 nested objects is still imposed).\n   *\n   * Default: 0 - objects will be stringified with toString.\n   */\n  depth?: number | null;\n};\n\n/**\n * Marks a property or a method to be included in the resource info section.\n */\nconst info =\n  (opts: InfoOptions = {}) =>\n  (target: any, propertyKey: string, descriptor?: PropertyDescriptor) => {\n    getTracingContext(target).infoProperties[propertyKey] = { options: opts };\n  };\n\nconst mark = (name: string) => {\n  performance.mark(name);\n};\n\nexport type SpanOptions = {\n  showInBrowserTimeline?: boolean;\n  op?: string;\n  attributes?: Record<string, any>;\n};\n\n/**\n * Decorator that creates a span for the execution duration of the decorated method.\n */\nconst span =\n  ({ showInBrowserTimeline = false, op, attributes }: SpanOptions = {}) =>\n  (target: any, propertyKey: string, descriptor: TypedPropertyDescriptor<(...args: any) => any>) => {\n    const method = descriptor.value!;\n\n    descriptor.value = async function (this: any, ...args: any) {\n      const parentCtx = args[0] instanceof Context ? args[0] : null;\n      const span = TRACE_PROCESSOR.traceSpan({\n        parentCtx,\n        methodName: propertyKey,\n        instance: this,\n        showInBrowserTimeline,\n        op,\n        attributes,\n      });\n\n      const callArgs = span.ctx ? [span.ctx, ...args.slice(1)] : args;\n      try {\n        return await method.apply(this, callArgs);\n      } catch (err) {\n        span.markError(err);\n        throw err;\n      } finally {\n        span.markSuccess();\n      }\n    };\n  };\n\nconst spans = new Map<string, TracingSpan>();\n\n/**\n * Creates a span that must be ended manually.\n */\nconst spanStart = (params: TraceSpanParams & { id: string }) => {\n  if (spans.has(params.id)) {\n    return;\n  }\n\n  const span = TRACE_PROCESSOR.traceSpan(params);\n  spans.set(params.id, span);\n};\n\n/**\n * Ends a span that was started manually.\n */\nconst spanEnd = (id: string) => {\n  const span = spans.get(id);\n  if (span) {\n    span.markSuccess();\n    spans.delete(id);\n  }\n};\n\n/**\n * Attaches metrics counter to the resource.\n */\nconst metricsCounter = () => (target: any, propertyKey: string, descriptor?: PropertyDescriptor) => {\n  getTracingContext(target).metricsProperties[propertyKey] = {};\n};\n\nexport type AddLinkOptions = {};\n\nconst addLink = (parent: any, child: any, opts: AddLinkOptions = {}) => {\n  TRACE_PROCESSOR.addLink(parent, child, opts);\n};\n\nexport type TraceDiagnosticParams<T> = {\n  /**\n   * Unique ID.\n   */\n  id: string;\n\n  /**\n   * Human-readable name.\n   * @defaults Defaults to `id`\n   */\n  name?: string;\n\n  /**\n   * Function that will be called to fetch the diagnostic data.\n   */\n  fetch: () => MaybePromise<T>;\n};\n\nexport interface TraceDiagnostic {\n  id: string;\n  unregister(): void;\n}\n\n/**\n * Register a diagnostic that could be queried.\n */\nconst diagnostic = <T>(params: TraceDiagnosticParams<T>): TraceDiagnostic => {\n  return TRACE_PROCESSOR.diagnostics.registerDiagnostic(params);\n};\n\nexport const trace = {\n  addLink,\n  diagnostic,\n  info,\n  mark,\n  metricsCounter,\n  resource,\n  span,\n  spanStart,\n  spanEnd,\n  metrics: TRACE_PROCESSOR.remoteMetrics,\n};\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { type InfoOptions } from './api';\n\nexport const symbolTracingContext = Symbol('dxos.tracing.context');\n\nexport type TracingContext = {\n  infoProperties: Record<\n    string,\n    {\n      options: InfoOptions;\n    }\n  >;\n  metricsProperties: Record<string, {}>;\n};\n\nexport const getTracingContext = (target: any): TracingContext => {\n  return ((target[symbolTracingContext] as TracingContext | undefined) ??= {\n    infoProperties: {},\n    metricsProperties: {},\n  });\n};\n\nexport const TRACE_SPAN_ATTRIBUTE = 'dxos.trace-span';\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { unrefTimeout } from '@dxos/async';\nimport { type Context } from '@dxos/context';\nimport { LogLevel, type LogProcessor, getContextFromEntry, log } from '@dxos/log';\nimport { type LogEntry } from '@dxos/protocols/proto/dxos/client/services';\nimport { type Error as SerializedError } from '@dxos/protocols/proto/dxos/error';\nimport { type Metric, type Resource, type Span } from '@dxos/protocols/proto/dxos/tracing';\nimport { getPrototypeSpecificInstanceId } from '@dxos/util';\n\nimport type { AddLinkOptions, TimeAware } from './api';\nimport { DiagnosticsManager } from './diagnostic';\nimport { DiagnosticsChannel } from './diagnostics-channel';\nimport { type BaseCounter } from './metrics';\nimport { RemoteMetrics, RemoteTracing } from './remote';\nimport { TRACE_SPAN_ATTRIBUTE, getTracingContext } from './symbols';\nimport { TraceSender } from './trace-sender';\nimport { WeakRef } from './weak-ref';\n\nexport type Diagnostics = {\n  resources: Record<string, Resource>;\n  spans: Span[];\n  logs: LogEntry[];\n};\n\nexport type TraceResourceConstructorParams = {\n  constructor: { new (...args: any[]): {} };\n  instance: any;\n  annotation?: symbol;\n};\n\nexport type TraceSpanParams = {\n  instance: any;\n  // TODO(wittjosiah): Rename to `name`.\n  methodName: string;\n  parentCtx: Context | null;\n  showInBrowserTimeline: boolean;\n  op?: string;\n  attributes?: Record<string, any>;\n};\n\nexport class ResourceEntry {\n  /**\n   * Sometimes bundlers mangle class names: WebFile -> WebFile2.\n   *\n   * We use a heuristic to remove the suffix.\n   */\n  public readonly sanitizedClassName: string;\n\n  constructor(\n    public readonly data: Resource,\n    public readonly instance: WeakRef<any>,\n    public readonly annotation?: symbol,\n  ) {\n    this.sanitizedClassName = sanitizeClassName(data.className);\n  }\n\n  getMetric(name: string): Metric | undefined {\n    return this.data.metrics?.find((metric) => metric.name === name);\n  }\n}\n\nexport type TraceSubscription = {\n  flush: () => void;\n\n  dirtyResources: Set<number>;\n  dirtySpans: Set<number>;\n  newLogs: LogEntry[];\n};\n\nconst MAX_RESOURCE_RECORDS = 2_000;\nconst MAX_SPAN_RECORDS = 1_000;\nconst MAX_LOG_RECORDS = 1_000;\n\nconst REFRESH_INTERVAL = 1_000;\n\nconst MAX_INFO_OBJECT_DEPTH = 8;\n\nconst IS_CLOUDFLARE_WORKERS = !!globalThis?.navigator?.userAgent?.includes('Cloudflare-Workers');\n\nexport class TraceProcessor {\n  public readonly diagnostics = new DiagnosticsManager();\n  public readonly diagnosticsChannel = new DiagnosticsChannel();\n  public readonly remoteMetrics = new RemoteMetrics();\n  public readonly remoteTracing = new RemoteTracing();\n\n  readonly subscriptions: Set<TraceSubscription> = new Set();\n\n  readonly resources = new Map<number, ResourceEntry>();\n  readonly resourceInstanceIndex = new WeakMap<any, ResourceEntry>();\n  readonly resourceIdList: number[] = [];\n\n  readonly spans = new Map<number, Span>();\n  readonly spanIdList: number[] = [];\n\n  readonly logs: LogEntry[] = [];\n\n  private _instanceTag: string | null = null;\n\n  constructor() {\n    log.addProcessor(this._logProcessor.bind(this));\n\n    if (!IS_CLOUDFLARE_WORKERS) {\n      const refreshInterval = setInterval(this.refresh.bind(this), REFRESH_INTERVAL);\n      unrefTimeout(refreshInterval);\n    }\n\n    if (DiagnosticsChannel.supported) {\n      this.diagnosticsChannel.serve(this.diagnostics);\n    }\n    this.diagnosticsChannel.unref();\n  }\n\n  setInstanceTag(tag: string): void {\n    this._instanceTag = tag;\n    this.diagnostics.setInstanceTag(tag);\n  }\n\n  /**\n   * @internal\n   */\n  // TODO(burdon): Comment.\n  createTraceResource(params: TraceResourceConstructorParams): void {\n    const id = this.resources.size;\n\n    // Init metrics counters.\n    const tracingContext = getTracingContext(Object.getPrototypeOf(params.instance));\n    for (const key of Object.keys(tracingContext.metricsProperties)) {\n      (params.instance[key] as BaseCounter)._assign(params.instance, key);\n    }\n\n    const entry = new ResourceEntry(\n      {\n        id,\n        className: params.constructor.name,\n        instanceId: getPrototypeSpecificInstanceId(params.instance),\n        info: this.getResourceInfo(params.instance),\n        links: [],\n        metrics: this.getResourceMetrics(params.instance),\n      },\n      new WeakRef(params.instance),\n      params.annotation,\n    );\n\n    this.resources.set(id, entry);\n    this.resourceInstanceIndex.set(params.instance, entry);\n    this.resourceIdList.push(id);\n    if (this.resourceIdList.length > MAX_RESOURCE_RECORDS) {\n      this._clearResources();\n    }\n\n    this._markResourceDirty(id);\n  }\n\n  createTraceSender(): TraceSender {\n    return new TraceSender(this);\n  }\n\n  traceSpan(params: TraceSpanParams): TracingSpan {\n    const span = new TracingSpan(this, params);\n    this._flushSpan(span);\n    return span;\n  }\n\n  // TODO(burdon): Not implemented.\n  addLink(parent: any, child: any, opts: AddLinkOptions): void {}\n\n  //\n  // Getters\n  //\n\n  // TODO(burdon): Define type.\n  // TODO(burdon): Reconcile with system service.\n  getDiagnostics(): Diagnostics {\n    this.refresh();\n\n    return {\n      resources: Object.fromEntries(\n        Array.from(this.resources.entries()).map(([id, entry]) => [\n          `${entry.sanitizedClassName}#${entry.data.instanceId}`,\n          entry.data,\n        ]),\n      ),\n      spans: Array.from(this.spans.values()),\n      logs: this.logs.filter((log) => log.level >= LogLevel.INFO),\n    };\n  }\n\n  getResourceInfo(instance: any): Record<string, any> {\n    const res: Record<string, any> = {};\n    const tracingContext = getTracingContext(Object.getPrototypeOf(instance));\n    for (const [key, { options }] of Object.entries(tracingContext.infoProperties)) {\n      try {\n        const value = typeof instance[key] === 'function' ? instance[key]() : instance[key];\n        if (options.enum) {\n          res[key] = options.enum[value];\n        } else {\n          res[key] = sanitizeValue(\n            value,\n            options.depth === undefined ? 1 : options.depth ?? MAX_INFO_OBJECT_DEPTH,\n            this,\n          );\n        }\n      } catch (err: any) {\n        res[key] = err.message;\n      }\n    }\n\n    return res;\n  }\n\n  getResourceMetrics(instance: any): Metric[] {\n    const res: Metric[] = [];\n    const tracingContext = getTracingContext(Object.getPrototypeOf(instance));\n    for (const [key, _opts] of Object.entries(tracingContext.metricsProperties)) {\n      res.push(instance[key].getData());\n    }\n\n    return res;\n  }\n\n  getResourceId(instance: any): number | null {\n    const entry = this.resourceInstanceIndex.get(instance);\n    return entry ? entry.data.id : null;\n  }\n\n  findResourcesByClassName(className: string): ResourceEntry[] {\n    return [...this.resources.values()].filter(\n      (res) => res.data.className === className || res.sanitizedClassName === className,\n    );\n  }\n\n  findResourcesByAnnotation(annotation: symbol): ResourceEntry[] {\n    return [...this.resources.values()].filter((res) => res.annotation === annotation);\n  }\n\n  refresh(): void {\n    for (const resource of this.resources.values()) {\n      const instance = resource.instance.deref();\n      if (!instance) {\n        continue;\n      }\n\n      const tracingContext = getTracingContext(Object.getPrototypeOf(instance));\n      const time = performance.now();\n      (instance as TimeAware).tick?.(time);\n      for (const key of Object.keys(tracingContext.metricsProperties)) {\n        (instance[key] as BaseCounter)._tick?.(time);\n      }\n\n      let _changed = false;\n\n      const oldInfo = resource.data.info;\n      resource.data.info = this.getResourceInfo(instance);\n      _changed ||= !areEqualShallow(oldInfo, resource.data.info);\n\n      const oldMetrics = resource.data.metrics;\n      resource.data.metrics = this.getResourceMetrics(instance);\n      _changed ||= !areEqualShallow(oldMetrics, resource.data.metrics);\n\n      // TODO(dmaretskyi): Test if works and enable.\n      // if (changed) {\n      this._markResourceDirty(resource.data.id);\n      // }\n    }\n\n    for (const subscription of this.subscriptions) {\n      subscription.flush();\n    }\n  }\n\n  //\n  // Implementation\n  //\n\n  /**\n   * @internal\n   */\n  _flushSpan(runtimeSpan: TracingSpan): void {\n    const span = runtimeSpan.serialize();\n    this.spans.set(span.id, span);\n    this.spanIdList.push(span.id);\n    if (this.spanIdList.length > MAX_SPAN_RECORDS) {\n      this._clearSpans();\n    }\n    this._markSpanDirty(span.id);\n    this.remoteTracing.flushSpan(runtimeSpan);\n  }\n\n  private _markResourceDirty(id: number): void {\n    for (const subscription of this.subscriptions) {\n      subscription.dirtyResources.add(id);\n    }\n  }\n\n  private _markSpanDirty(id: number): void {\n    for (const subscription of this.subscriptions) {\n      subscription.dirtySpans.add(id);\n    }\n  }\n\n  private _clearResources(): void {\n    // TODO(dmaretskyi): Use FinalizationRegistry to delete finalized resources first.\n    while (this.resourceIdList.length > MAX_RESOURCE_RECORDS) {\n      const id = this.resourceIdList.shift()!;\n      this.resources.delete(id);\n    }\n  }\n\n  private _clearSpans(): void {\n    while (this.spanIdList.length > MAX_SPAN_RECORDS) {\n      const id = this.spanIdList.shift()!;\n      this.spans.delete(id);\n    }\n  }\n\n  private _pushLog(log: LogEntry): void {\n    this.logs.push(log);\n    if (this.logs.length > MAX_LOG_RECORDS) {\n      this.logs.shift();\n    }\n\n    for (const subscription of this.subscriptions) {\n      subscription.newLogs.push(log);\n    }\n  }\n\n  private _logProcessor: LogProcessor = (config, entry) => {\n    switch (entry.level) {\n      case LogLevel.ERROR:\n      case LogLevel.WARN:\n      case LogLevel.TRACE: {\n        const scope = entry.meta?.S;\n        const resource = this.resourceInstanceIndex.get(scope);\n        if (!resource) {\n          return;\n        }\n\n        const context = getContextFromEntry(entry) ?? {};\n        for (const key of Object.keys(context)) {\n          context[key] = sanitizeValue(context[key], 0, this);\n        }\n\n        const entryToPush: LogEntry = {\n          level: entry.level,\n          message: entry.message,\n          context,\n          timestamp: new Date(),\n          meta: {\n            file: entry.meta?.F ?? '',\n            line: entry.meta?.L ?? 0,\n            resourceId: resource.data.id,\n          },\n        };\n        this._pushLog(entryToPush);\n        break;\n      }\n      default:\n    }\n  };\n}\n\n// TODO(burdon): Comment.\nexport class TracingSpan {\n  static nextId = 0;\n\n  readonly id: number;\n  readonly parentId: number | null = null;\n  readonly methodName: string;\n  readonly resourceId: number | null = null;\n  readonly op: string | undefined;\n  readonly attributes: Record<string, any>;\n  startTs: number;\n  endTs: number | null = null;\n  error: SerializedError | null = null;\n\n  private _showInBrowserTimeline: boolean;\n  private readonly _ctx: Context | null = null;\n\n  constructor(\n    private _traceProcessor: TraceProcessor,\n    params: TraceSpanParams,\n  ) {\n    this.id = TracingSpan.nextId++;\n    this.methodName = params.methodName;\n    this.resourceId = _traceProcessor.getResourceId(params.instance);\n    this.startTs = performance.now();\n    this._showInBrowserTimeline = params.showInBrowserTimeline;\n    this.op = params.op;\n    this.attributes = params.attributes ?? {};\n\n    if (params.parentCtx) {\n      this._ctx = params.parentCtx.derive({\n        attributes: {\n          [TRACE_SPAN_ATTRIBUTE]: this.id,\n        },\n      });\n      const parentId = params.parentCtx.getAttribute(TRACE_SPAN_ATTRIBUTE);\n      if (typeof parentId === 'number') {\n        this.parentId = parentId;\n      }\n    }\n  }\n\n  get name() {\n    const resource = this._traceProcessor.resources.get(this.resourceId!);\n    return resource ? `${resource.sanitizedClassName}#${resource.data.instanceId}.${this.methodName}` : this.methodName;\n  }\n\n  get ctx(): Context | null {\n    return this._ctx;\n  }\n\n  markSuccess(): void {\n    this.endTs = performance.now();\n    this._traceProcessor._flushSpan(this);\n\n    if (this._showInBrowserTimeline) {\n      this._markInBrowserTimeline();\n    }\n  }\n\n  markError(err: unknown): void {\n    this.endTs = performance.now();\n    this.error = serializeError(err);\n    this._traceProcessor._flushSpan(this);\n\n    if (this._showInBrowserTimeline) {\n      this._markInBrowserTimeline();\n    }\n  }\n\n  serialize(): Span {\n    return {\n      id: this.id,\n      resourceId: this.resourceId ?? undefined,\n      methodName: this.methodName,\n      parentId: this.parentId ?? undefined,\n      startTs: this.startTs.toFixed(3),\n      endTs: this.endTs?.toFixed(3) ?? undefined,\n      error: this.error ?? undefined,\n    };\n  }\n\n  private _markInBrowserTimeline(): void {\n    if (typeof globalThis?.performance?.measure === 'function') {\n      performance.measure(this.name, { start: this.startTs, end: this.endTs! });\n    }\n  }\n}\n\n// TODO(burdon): Log cause.\nconst serializeError = (err: unknown): SerializedError => {\n  if (err instanceof Error) {\n    return {\n      name: err.name,\n      message: err.message,\n    };\n  }\n\n  return {\n    message: String(err),\n  };\n};\n\n// TODO(burdon): Rename singleton and move out of package.\nexport const TRACE_PROCESSOR: TraceProcessor = ((globalThis as any).TRACE_PROCESSOR ??= new TraceProcessor());\n\nconst sanitizeValue = (value: any, depth: number, traceProcessor: TraceProcessor): any => {\n  switch (typeof value) {\n    case 'string':\n    case 'number':\n    case 'boolean':\n    case 'undefined':\n      return value;\n    case 'object':\n    case 'function':\n      if (value === null) {\n        return value;\n      }\n\n      {\n        const resourceEntry = traceProcessor.resourceInstanceIndex.get(value);\n        if (resourceEntry) {\n          return `${resourceEntry.sanitizedClassName}#${resourceEntry.data.instanceId}`;\n        }\n      }\n\n      if (typeof value.toJSON === 'function') {\n        // TODO(dmaretskyi): This has potential to cause infinite recursion.\n        return sanitizeValue(value.toJSON(), depth, traceProcessor);\n      }\n\n      if (depth > 0) {\n        if (isSetLike(value)) {\n          return Object.fromEntries(\n            Array.from(value.entries()).map((value) => sanitizeValue(value, depth - 1, traceProcessor)),\n          );\n        } else if (isMapLike(value)) {\n          return Object.fromEntries(\n            Array.from(value.entries()).map(([key, value]) => [key, sanitizeValue(value, depth - 1, traceProcessor)]),\n          );\n        } else if (Array.isArray(value)) {\n          return value.map((item: any) => sanitizeValue(item, depth - 1, traceProcessor));\n        } else if (typeof value === 'object') {\n          const res: any = {};\n          for (const key of Object.keys(value)) {\n            res[key] = sanitizeValue(value[key], depth - 1, traceProcessor);\n          }\n          return res;\n        }\n      }\n\n      // TODO(dmaretskyi): Expose trait.\n      if (typeof value.truncate === 'function') {\n        return value.truncate();\n      }\n\n      return value.toString();\n  }\n};\n\nconst areEqualShallow = (a: any, b: any) => {\n  for (const key in a) {\n    if (!(key in b) || a[key] !== b[key]) {\n      return false;\n    }\n  }\n  for (const key in b) {\n    if (!(key in a) || a[key] !== b[key]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nexport const sanitizeClassName = (className: string) => {\n  const SANITIZE_REGEX = /[^_](\\d+)$/;\n  const m = className.match(SANITIZE_REGEX);\n  if (!m) {\n    return className;\n  } else {\n    return className.slice(0, -m[1].length);\n  }\n};\n\nconst isSetLike = (value: any): value is Set<any> =>\n  value instanceof Set ||\n  (typeof value === 'object' && value !== null && Object.getPrototypeOf(value).constructor.name === 'ComplexSet');\n\nconst isMapLike = (value: any): value is Map<any, any> =>\n  value instanceof Map ||\n  (typeof value === 'object' && value !== null && Object.getPrototypeOf(value).constructor.name === 'ComplexMap');\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { asyncTimeout } from '@dxos/async';\nimport { invariant } from '@dxos/invariant';\n\nimport { type TraceDiagnosticParams, type TraceDiagnostic } from './api';\nimport { createId } from './util';\n\nexport const DIAGNOSTICS_TIMEOUT = 10_000;\n\nexport type DiagnosticMetadata = {\n  id: string;\n  instanceId: string;\n  instanceTag: string | null;\n  name: string;\n};\n\nexport type DiagnosticsRequest = {\n  id: string;\n  instanceId?: string;\n  instanceTag?: string | null;\n};\n\nexport type DiagnosticsData = {\n  id: string;\n  instanceId: string;\n  data: any;\n  error?: string;\n};\n\nexport class TraceDiagnosticImpl implements TraceDiagnostic {\n  constructor(\n    public id: string,\n    public fetch: () => any,\n    public name: string,\n    private readonly _onUnregister: () => void,\n  ) {}\n\n  unregister(): void {\n    this._onUnregister();\n  }\n}\n\nexport class DiagnosticsManager {\n  readonly instanceId = createId();\n\n  readonly registry = new Map<string, TraceDiagnosticImpl>();\n\n  private _instanceTag: string | null = null;\n\n  get instanceTag(): string | null {\n    return this._instanceTag;\n  }\n\n  setInstanceTag(tag: string): void {\n    this._instanceTag = tag;\n  }\n\n  registerDiagnostic(params: TraceDiagnosticParams<any>): TraceDiagnostic {\n    const impl = new TraceDiagnosticImpl(params.id, params.fetch, params.name ?? params.id, () => {\n      if (this.registry.get(params.id) === impl) {\n        this.registry.delete(params.id);\n      }\n    });\n    this.registry.set(params.id, impl);\n    return impl;\n  }\n\n  list(): DiagnosticMetadata[] {\n    return Array.from(this.registry.values()).map((diagnostic) => ({\n      id: diagnostic.id,\n      instanceId: this.instanceId,\n      instanceTag: this._instanceTag,\n      name: diagnostic.name,\n    }));\n  }\n\n  async fetch(request: DiagnosticsRequest): Promise<DiagnosticsData> {\n    if (request.instanceId != null) {\n      invariant(request.instanceId === this.instanceId, 'Invalid instance id');\n    }\n    const { id } = request;\n    const diagnostic = this.registry.get(id);\n    invariant(diagnostic, 'Diagnostic not found');\n    try {\n      const data = await asyncTimeout(diagnostic.fetch(), DIAGNOSTICS_TIMEOUT);\n      return {\n        id,\n        instanceId: this.instanceId,\n        data,\n      };\n    } catch (err: any) {\n      return {\n        id,\n        instanceId: this.instanceId,\n        data: null,\n        error: err.stack,\n      };\n    }\n  }\n}\n", "// TODO(dmaretskyi): Use UUID.\n//\n// Copyright 2024 DXOS.org\n//\n\nexport const createId = () => Math.random().toString(36).slice(2);\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { Trigger, sleep } from '@dxos/async';\nimport { Context } from '@dxos/context';\nimport { invariant } from '@dxos/invariant';\n\nimport {\n  DIAGNOSTICS_TIMEOUT,\n  type DiagnosticMetadata,\n  type DiagnosticsData,\n  type DiagnosticsManager,\n  type DiagnosticsRequest,\n} from './diagnostic';\nimport { createId } from './util';\n\nconst DEFAULT_CHANNEL_NAME = 'dxos-diagnostics';\n\nconst DISCOVER_TIME = 500;\n\nexport type DiagnosticChannelMessage =\n  | {\n      type: 'DIAGNOSTICS_DISCOVER';\n    }\n  | {\n      type: 'DIAGNOSTICS_ANNOUNCE';\n      diagnostics: DiagnosticMetadata[];\n    }\n  | {\n      type: 'DIAGNOSTICS_FETCH';\n      requestId: string;\n      request: DiagnosticsRequest;\n    }\n  | {\n      type: 'DIAGNOSTICS_RESPONSE';\n      requestId: string;\n      data: DiagnosticsData;\n    };\n\nexport class DiagnosticsChannel {\n  static get supported() {\n    return globalThis.BroadcastChannel != null;\n  }\n\n  private _ctx = new Context();\n\n  // Separate channels becauase the client and server may be in the same process.\n  private readonly _serveChannel?: BroadcastChannel = undefined;\n  private readonly _clientChannel?: BroadcastChannel = undefined;\n\n  constructor(private readonly _channelName: string = DEFAULT_CHANNEL_NAME) {\n    if (DiagnosticsChannel.supported) {\n      this._serveChannel = new BroadcastChannel(_channelName);\n      this._clientChannel = new BroadcastChannel(_channelName);\n    }\n  }\n\n  destroy(): void {\n    void this._ctx.dispose();\n    this._serveChannel?.close();\n    this._clientChannel?.close();\n  }\n\n  /**\n   * In node.js, the channel will keep the process alive.\n   * This method allows the process to exit.\n   * Noop in the browser.\n   */\n  unref(): void {\n    if (this._serveChannel && typeof (this._serveChannel as any).unref === 'function') {\n      (this._serveChannel as any).unref();\n      (this._clientChannel as any).unref();\n    }\n  }\n\n  serve(manager: DiagnosticsManager): void {\n    invariant(this._serveChannel);\n    const listener = async (event: MessageEvent) => {\n      switch (event.data.type) {\n        case 'DIAGNOSTICS_DISCOVER': {\n          const diagnostics = manager.list();\n          this._serveChannel!.postMessage({\n            type: 'DIAGNOSTICS_ANNOUNCE',\n            diagnostics,\n          } satisfies DiagnosticChannelMessage);\n          break;\n        }\n        case 'DIAGNOSTICS_FETCH': {\n          const { requestId, request } = event.data;\n\n          if (request.instanceId != null && request.instanceId !== manager.instanceId) {\n            break;\n          } else if (request.instanceTag != null && request.instanceTag !== manager.instanceTag) {\n            break;\n          }\n\n          const data = await manager.fetch(request);\n          this._serveChannel!.postMessage({\n            type: 'DIAGNOSTICS_RESPONSE',\n            requestId,\n            data,\n          } satisfies DiagnosticChannelMessage);\n          break;\n        }\n      }\n    };\n\n    this._serveChannel.addEventListener('message', listener);\n    this._ctx.onDispose(() => this._serveChannel!.removeEventListener('message', listener));\n  }\n\n  async discover(): Promise<DiagnosticMetadata[]> {\n    invariant(this._clientChannel);\n    const diagnostics: DiagnosticMetadata[] = [];\n\n    const collector = (event: MessageEvent) => {\n      const data = event.data as DiagnosticChannelMessage;\n      switch (data.type) {\n        case 'DIAGNOSTICS_ANNOUNCE':\n          diagnostics.push(...data.diagnostics);\n          break;\n      }\n    };\n\n    try {\n      this._clientChannel.addEventListener('message', collector);\n      this._clientChannel.postMessage({ type: 'DIAGNOSTICS_DISCOVER' } satisfies DiagnosticChannelMessage);\n\n      await sleep(DISCOVER_TIME);\n\n      // Dedup.\n      const result: DiagnosticMetadata[] = [];\n      for (const diagnostic of diagnostics) {\n        if (!result.some((d) => d.id === diagnostic.id && d.instanceId === diagnostic.instanceId)) {\n          result.push(diagnostic);\n        }\n      }\n\n      return diagnostics;\n    } finally {\n      this._clientChannel.removeEventListener('message', collector);\n    }\n  }\n\n  async fetch(request: DiagnosticsRequest): Promise<DiagnosticsData> {\n    invariant(this._clientChannel);\n    const requestId = createId();\n\n    const trigger = new Trigger<DiagnosticsData>();\n    const listener = (event: MessageEvent) => {\n      const data = event.data as DiagnosticChannelMessage;\n      if (data.type === 'DIAGNOSTICS_RESPONSE' && data.requestId === requestId) {\n        trigger.wake(data.data);\n      }\n    };\n\n    try {\n      this._clientChannel.addEventListener('message', listener);\n      this._clientChannel.postMessage({\n        type: 'DIAGNOSTICS_FETCH',\n        requestId,\n        request,\n      } satisfies DiagnosticChannelMessage);\n\n      // NOTE: Must have await keyword in this block.\n      const result = await trigger.wait({ timeout: DIAGNOSTICS_TIMEOUT });\n\n      return result;\n    } finally {\n      this._clientChannel.removeEventListener('message', listener);\n    }\n  }\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\ntype TagType = number | string | boolean | null | undefined;\n\nexport interface MetricData {\n  unit?: string;\n  tags?: Record<string, TagType>;\n  timestamp?: number;\n}\n\ninterface MetricsMethods {\n  /**\n   * Adds a value to a counter metric\n   */\n  increment(name: string, value?: number, data?: MetricData): void;\n  /**\n   * Adds a value to a distribution metric\n   */\n  distribution(name: string, value: number, data?: MetricData): void;\n  /**\n   * Adds a value to a set metric. Value must be a string or integer.\n   */\n  set(name: string, value: number | string, data?: MetricData): void;\n  /**\n   * Adds a value to a gauge metric\n   */\n  gauge(name: string, value: number, data?: MetricData): void;\n}\n\n/**\n * Allows metrics to be recorded within SDK code without requiring specific consumers.\n */\nexport class RemoteMetrics implements MetricsMethods {\n  private _metrics = new Set<MetricsMethods>();\n\n  registerProcessor(processor: MetricsMethods): void {\n    this._metrics.add(processor);\n  }\n\n  increment(name: string, value?: number, data?: MetricData): void[] {\n    return Array.from(this._metrics.values()).map((processor) => processor.increment(name, value, data));\n  }\n\n  distribution(name: string, value: number, data?: MetricData): void[] {\n    return Array.from(this._metrics.values()).map((processor) => processor.distribution(name, value, data));\n  }\n\n  set(name: string, value: number | string, data?: MetricData): void[] {\n    return Array.from(this._metrics.values()).map((processor) => processor.set(name, value, data));\n  }\n\n  gauge(name: string, value: number, data?: MetricData): void[] {\n    return Array.from(this._metrics.values()).map((processor) => processor.gauge(name, value, data));\n  }\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { type TracingSpan } from '../trace-processor';\n\ntype RemoteSpan = {\n  end: () => void;\n};\n\nexport type StartSpanOptions = {\n  name: string;\n  op?: string;\n  attributes?: Record<string, any>;\n};\n\ninterface TracingMethods {\n  startSpan: (options: StartSpanOptions) => RemoteSpan;\n}\n\n/**\n * Allows traces to be recorded within SDK code without requiring specific consumers.\n */\n// TODO(wittjosiah): Should probably just use otel. Use `any` for now to not depend on Sentry directly.\nexport class RemoteTracing {\n  private _tracing: TracingMethods | undefined;\n  private _spanMap = new Map<TracingSpan, RemoteSpan>();\n\n  registerProcessor(processor: TracingMethods): void {\n    this._tracing = processor;\n  }\n\n  flushSpan(span: TracingSpan): void {\n    if (!this._tracing) {\n      return;\n    }\n\n    if (!span.endTs) {\n      const remoteSpan = this._tracing.startSpan({\n        name: span.methodName,\n        op: span.op ?? 'function',\n        attributes: span.attributes,\n      });\n      this._spanMap.set(span, remoteSpan);\n    } else {\n      const remoteSpan = this._spanMap.get(span);\n      if (remoteSpan) {\n        remoteSpan.end();\n        this._spanMap.delete(span);\n      }\n    }\n  }\n}\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { Stream } from '@dxos/codec-protobuf/stream';\nimport { type LogEntry } from '@dxos/protocols/proto/dxos/client/services';\nimport { type StreamTraceEvent, type TracingService } from '@dxos/protocols/proto/dxos/tracing';\n\nimport { type TraceProcessor, type TraceSubscription } from './trace-processor';\n\nexport class TraceSender implements TracingService {\n  constructor(private _traceProcessor: TraceProcessor) {}\n\n  streamTrace(request: void): Stream<StreamTraceEvent> {\n    return new Stream(({ ctx, next }) => {\n      const flushEvents = (resources: Set<number> | null, spans: Set<number> | null, logs: LogEntry[] | null) => {\n        const event: StreamTraceEvent = {\n          resourceAdded: [],\n          resourceRemoved: [],\n          spanAdded: [],\n          logAdded: [],\n        };\n\n        if (resources) {\n          for (const id of resources) {\n            const entry = this._traceProcessor.resources.get(id);\n            if (entry) {\n              event.resourceAdded!.push({ resource: entry.data });\n            } else {\n              event.resourceRemoved!.push({ id });\n            }\n          }\n        } else {\n          for (const entry of this._traceProcessor.resources.values()) {\n            event.resourceAdded!.push({ resource: entry.data });\n          }\n        }\n\n        if (spans) {\n          for (const id of spans) {\n            const span = this._traceProcessor.spans.get(id);\n            if (span) {\n              event.spanAdded!.push({ span });\n            }\n          }\n        } else {\n          for (const span of this._traceProcessor.spans.values()) {\n            event.spanAdded!.push({ span });\n          }\n        }\n\n        if (logs) {\n          for (const log of logs) {\n            event.logAdded!.push({ log });\n          }\n        } else {\n          for (const log of this._traceProcessor.logs) {\n            event.logAdded!.push({ log });\n          }\n        }\n\n        if (event.resourceAdded!.length > 0 || event.resourceRemoved!.length > 0 || event.spanAdded!.length > 0) {\n          next(event);\n        }\n      };\n\n      const flush = () => {\n        flushEvents(subscription.dirtyResources, subscription.dirtySpans, subscription.newLogs);\n        subscription.dirtyResources.clear();\n        subscription.dirtySpans.clear();\n        subscription.newLogs.length = 0;\n      };\n\n      const subscription: TraceSubscription = {\n        flush,\n        dirtyResources: new Set(),\n        dirtySpans: new Set(),\n        newLogs: [],\n      };\n      this._traceProcessor.subscriptions.add(subscription);\n      ctx.onDispose(() => {\n        this._traceProcessor.subscriptions.delete(subscription);\n      });\n\n      flushEvents(null, null, null);\n    });\n  }\n}\n", "// Workerd does not support WeakRef\n\n//\n// Copyright 2024 DXOS.org\n//\n\nclass WeakRefMock<T> {\n  // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n  constructor(target: T) {\n    // do nothing\n  }\n\n  deref(): T | undefined {\n    return undefined;\n  }\n}\n\nexport const WeakRef = globalThis.WeakRef ?? WeakRefMock;\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { type Metric } from '@dxos/protocols/proto/dxos/tracing';\n\nexport abstract class BaseCounter {\n  /**\n   * @internal\n   */\n  _instance: any;\n\n  name?: string;\n\n  /**\n   * @internal\n   */\n  _assign(instance: any, name: string): void {\n    this._instance = instance;\n    this.name = name;\n  }\n\n  abstract getData(): Metric;\n\n  _tick(time: number): void {}\n}\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { type Metric } from '@dxos/protocols/proto/dxos/tracing';\n\nimport { BaseCounter } from './base';\n\nexport class UnaryCounter extends BaseCounter {\n  value = 0;\n  units?: string;\n\n  constructor({ units }: { units?: string } = {}) {\n    super();\n    this.units = units;\n  }\n\n  inc(by = 1): void {\n    this.value += by;\n  }\n\n  getData(): Metric {\n    return {\n      name: this.name!,\n      counter: {\n        value: this.value,\n        units: this.units,\n      },\n    };\n  }\n}\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { type Metric } from '@dxos/protocols/proto/dxos/tracing';\n\nimport { BaseCounter } from './base';\n\nconst MAX_BUCKETS = 60;\n\nexport class TimeSeriesCounter extends BaseCounter {\n  private _currentValue = 0;\n  private _totalValue = 0;\n  private _buckets: number[] = [];\n  units?: string;\n\n  constructor({ units }: { units?: string } = {}) {\n    super();\n    this.units = units;\n  }\n\n  inc(by = 1): void {\n    this._currentValue += by;\n    this._totalValue += by;\n  }\n\n  override _tick(time: number): void {\n    this._buckets.push(this._currentValue);\n    if (this._buckets.length > MAX_BUCKETS) {\n      this._buckets.shift();\n    }\n    this._currentValue = 0;\n  }\n\n  override getData(): Metric {\n    return {\n      name: this.name!,\n      timeSeries: {\n        tracks: [\n          {\n            name: this.name!,\n            units: this.units,\n            points: this._buckets.map((value, index) => ({\n              value,\n            })),\n            total: this._totalValue,\n          },\n        ],\n      },\n    };\n  }\n}\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { type Metric } from '@dxos/protocols/proto/dxos/tracing';\n\nimport { BaseCounter } from './base';\n\nconst MAX_BUCKETS = 60;\n\nexport class TimeUsageCounter extends BaseCounter {\n  private _currentValue = 0;\n  private _totalValue = 0;\n  private _buckets: number[] = [];\n\n  private _lastTickTime = performance.now();\n\n  record(time: number): void {\n    this._currentValue += time;\n    this._totalValue += time;\n  }\n\n  beginRecording(): { end: () => void } {\n    const start = performance.now();\n    return {\n      end: () => {\n        const end = performance.now();\n        this.record(end - start);\n      },\n    };\n  }\n\n  override _tick(time: number): void {\n    const delta = time - this._lastTickTime;\n    this._lastTickTime = time;\n\n    const percentage = (this._currentValue / delta) * 100;\n    this._buckets.push(percentage);\n    if (this._buckets.length > MAX_BUCKETS) {\n      this._buckets.shift();\n    }\n    this._currentValue = 0;\n  }\n\n  override getData(): Metric {\n    return {\n      name: this.name!,\n      timeSeries: {\n        tracks: [\n          {\n            name: this.name!,\n            units: '%',\n            points: this._buckets.map((value, index) => ({\n              value,\n            })),\n            total: this._totalValue,\n          },\n        ],\n      },\n    };\n  }\n}\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { type Metric } from '@dxos/protocols/proto/dxos/tracing';\n\nimport { BaseCounter } from './base';\n\nexport class MapCounter extends BaseCounter {\n  values = new Map<string, number>();\n  units?: string;\n\n  constructor({ units }: { units?: string } = {}) {\n    super();\n    this.units = units;\n  }\n\n  inc(key: string, by = 1): void {\n    const prev = this.values.get(key) ?? 0;\n    this.values.set(key, prev + by);\n  }\n\n  getData(): Metric {\n    return {\n      name: this.name!,\n      multiCounter: {\n        records: Array.from(this.values.entries()).map(([key, value]) => ({\n          key,\n          value,\n        })),\n        units: this.units,\n      },\n    };\n  }\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { type Metric } from '@dxos/protocols/proto/dxos/tracing';\n\nimport { BaseCounter } from './base';\n\nexport class CustomCounter extends BaseCounter {\n  constructor(private readonly _getData: () => object) {\n    super();\n  }\n\n  override getData(): Metric {\n    return {\n      name: this.name!,\n      custom: {\n        payload: this._getData(),\n      },\n    };\n  }\n}\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { trace } from './api';\n\nexport * from './api';\nexport * from './symbols';\nexport * from './trace-processor';\nexport * from './trace-sender';\nexport * from './metrics';\nexport * from './diagnostic';\nexport * from './diagnostics-channel';\nexport * from './remote/tracing';\nexport * from './remote/metrics';\n\ntrace.diagnostic({\n  id: 'process-info',\n  name: 'Process Info',\n  fetch: async () => {\n    return {\n      platform: globalThis.process?.platform,\n      arch: globalThis.process?.arch,\n      versions: globalThis.process?.versions,\n      href: globalThis.location?.href,\n    };\n  },\n});\n"],
  "mappings": "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",
  "names": ["import_async", "import_context", "import_invariant", "symbolTracingContext", "Symbol", "getTracingContext", "target", "infoProperties", "metricsProperties", "TRACE_SPAN_ATTRIBUTE", "createId", "Math", "random", "toString", "slice", "DIAGNOSTICS_TIMEOUT", "TraceDiagnosticImpl", "id", "fetch", "name", "_onUnregister", "unregister", "DiagnosticsManager", "instanceId", "registry", "Map", "_instanceTag", "instanceTag", "setInstanceTag", "tag", "registerDiagnostic", "params", "impl", "get", "delete", "set", "list", "Array", "from", "values", "map", "diagnostic", "request", "invariant", "data", "asyncTimeout", "err", "error", "stack", "DEFAULT_CHANNEL_NAME", "DISCOVER_TIME", "DiagnosticsChannel", "supported", "globalThis", "BroadcastChannel", "_channelName", "_ctx", "Context", "_serveChannel", "undefined", "_clientChannel", "destroy", "dispose", "close", "unref", "serve", "manager", "listener", "event", "type", "diagnostics", "postMessage", "requestId", "addEventListener", "onDispose", "removeEventListener", "discover", "collector", "push", "sleep", "result", "some", "d", "trigger", "Trigger", "wake", "wait", "timeout", "RemoteMetrics", "_metrics", "Set", "registerProcessor", "processor", "add", "increment", "value", "distribution", "gauge", "RemoteTracing", "_spanMap", "_tracing", "flushSpan", "span", "endTs", "remoteSpan", "startSpan", "methodName", "op", "attributes", "end", "TraceSender", "_traceProcessor", "streamTrace", "Stream", "ctx", "next", "flushEvents", "resources", "spans", "logs", "resourceAdded", "resourceRemoved", "spanAdded", "logAdded", "entry", "resource", "log", "length", "flush", "subscription", "dirtyResources", "dirtySpans", "newLogs", "clear", "subscriptions", "WeakRefMock", "deref", "WeakRef", "ResourceEntry", "instance", "annotation", "sanitizedClassName", "sanitizeClassName", "className", "getMetric", "metrics", "find", "metric", "MAX_RESOURCE_RECORDS", "MAX_SPAN_RECORDS", "MAX_LOG_RECORDS", "REFRESH_INTERVAL", "MAX_INFO_OBJECT_DEPTH", "IS_CLOUDFLARE_WORKERS", "navigator", "userAgent", "includes", "TraceProcessor", "diagnosticsChannel", "remoteMetrics", "remoteTracing", "resourceInstanceIndex", "WeakMap", "resourceIdList", "spanIdList", "_logProcessor", "config", "level", "LogLevel", "ERROR", "WARN", "TRACE", "scope", "meta", "S", "context", "getContextFromEntry", "key", "Object", "keys", "sanitizeValue", "entryToPush", "message", "timestamp", "Date", "file", "F", "line", "L", "resourceId", "_pushLog", "addProcessor", "bind", "refreshInterval", "setInterval", "refresh", "unrefTimeout", "createTraceResource", "size", "tracingContext", "getPrototypeOf", "_assign", "getPrototypeSpecificInstanceId", "info", "getResourceInfo", "links", "getResourceMetrics", "_clearResources", "_markResourceDirty", "createTraceSender", "traceSpan", "TracingSpan", "_flushSpan", "addLink", "parent", "child", "opts", "getDiagnostics", "fromEntries", "entries", "filter", "INFO", "res", "options", "enum", "depth", "_opts", "getData", "getResourceId", "findResourcesByClassName", "findResourcesByAnnotation", "time", "performance", "now", "tick", "_tick", "_changed", "oldInfo", "areEqualShallow", "oldMetrics", "runtimeSpan", "serialize", "_clearSpans", "_markSpanDirty", "shift", "nextId", "parentId", "startTs", "_showInBrowserTimeline", "showInBrowserTimeline", "parentCtx", "derive", "getAttribute", "markSuccess", "_markInBrowserTimeline", "markError", "serializeError", "toFixed", "measure", "start", "Error", "String", "TRACE_PROCESSOR", "traceProcessor", "resourceEntry", "toJSON", "isSetLike", "isMapLike", "isArray", "item", "truncate", "a", "b", "SANITIZE_REGEX", "m", "match", "constructor", "klass", "rest", "defineProperty", "propertyKey", "descriptor", "mark", "method", "args", "callArgs", "apply", "spanStart", "has", "spanEnd", "metricsCounter", "trace", "BaseCounter", "_instance", "UnaryCounter", "units", "inc", "by", "counter", "MAX_BUCKETS", "TimeSeriesCounter", "_currentValue", "_totalValue", "_buckets", "timeSeries", "tracks", "points", "index", "total", "TimeUsageCounter", "_lastTickTime", "record", "beginRecording", "delta", "percentage", "MapCounter", "prev", "multiCounter", "records", "CustomCounter", "_getData", "custom", "payload", "platform", "process", "arch", "versions", "href", "location"]
}
