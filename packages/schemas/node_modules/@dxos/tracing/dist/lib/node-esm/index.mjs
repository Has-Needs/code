import { createRequire } from 'node:module';const require = createRequire(import.meta.url);

// packages/common/tracing/src/api.ts
import { Context as Context2 } from "@dxos/context";

// packages/common/tracing/src/symbols.ts
var symbolTracingContext = Symbol("dxos.tracing.context");
var getTracingContext = (target) => {
  return target[symbolTracingContext] ??= {
    infoProperties: {},
    metricsProperties: {}
  };
};
var TRACE_SPAN_ATTRIBUTE = "dxos.trace-span";

// packages/common/tracing/src/trace-processor.ts
import { unrefTimeout } from "@dxos/async";
import { LogLevel, getContextFromEntry, log } from "@dxos/log";
import { getPrototypeSpecificInstanceId } from "@dxos/util";

// packages/common/tracing/src/diagnostic.ts
import { asyncTimeout } from "@dxos/async";
import { invariant } from "@dxos/invariant";

// packages/common/tracing/src/util.ts
var createId = () => Math.random().toString(36).slice(2);

// packages/common/tracing/src/diagnostic.ts
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/common/tracing/src/diagnostic.ts";
var DIAGNOSTICS_TIMEOUT = 1e4;
var TraceDiagnosticImpl = class {
  constructor(id, fetch, name, _onUnregister) {
    this.id = id;
    this.fetch = fetch;
    this.name = name;
    this._onUnregister = _onUnregister;
  }
  unregister() {
    this._onUnregister();
  }
};
var DiagnosticsManager = class {
  constructor() {
    this.instanceId = createId();
    this.registry = /* @__PURE__ */ new Map();
    this._instanceTag = null;
  }
  get instanceTag() {
    return this._instanceTag;
  }
  setInstanceTag(tag) {
    this._instanceTag = tag;
  }
  registerDiagnostic(params) {
    const impl = new TraceDiagnosticImpl(params.id, params.fetch, params.name ?? params.id, () => {
      if (this.registry.get(params.id) === impl) {
        this.registry.delete(params.id);
      }
    });
    this.registry.set(params.id, impl);
    return impl;
  }
  list() {
    return Array.from(this.registry.values()).map((diagnostic2) => ({
      id: diagnostic2.id,
      instanceId: this.instanceId,
      instanceTag: this._instanceTag,
      name: diagnostic2.name
    }));
  }
  async fetch(request) {
    if (request.instanceId != null) {
      invariant(request.instanceId === this.instanceId, "Invalid instance id", {
        F: __dxlog_file,
        L: 82,
        S: this,
        A: [
          "request.instanceId === this.instanceId",
          "'Invalid instance id'"
        ]
      });
    }
    const { id } = request;
    const diagnostic2 = this.registry.get(id);
    invariant(diagnostic2, "Diagnostic not found", {
      F: __dxlog_file,
      L: 86,
      S: this,
      A: [
        "diagnostic",
        "'Diagnostic not found'"
      ]
    });
    try {
      const data = await asyncTimeout(diagnostic2.fetch(), DIAGNOSTICS_TIMEOUT);
      return {
        id,
        instanceId: this.instanceId,
        data
      };
    } catch (err) {
      return {
        id,
        instanceId: this.instanceId,
        data: null,
        error: err.stack
      };
    }
  }
};

// packages/common/tracing/src/diagnostics-channel.ts
import { Trigger, sleep } from "@dxos/async";
import { Context } from "@dxos/context";
import { invariant as invariant2 } from "@dxos/invariant";
var __dxlog_file2 = "/home/runner/work/dxos/dxos/packages/common/tracing/src/diagnostics-channel.ts";
var DEFAULT_CHANNEL_NAME = "dxos-diagnostics";
var DISCOVER_TIME = 500;
var DiagnosticsChannel = class _DiagnosticsChannel {
  static get supported() {
    return globalThis.BroadcastChannel != null;
  }
  constructor(_channelName = DEFAULT_CHANNEL_NAME) {
    this._channelName = _channelName;
    this._ctx = new Context(void 0, {
      F: __dxlog_file2,
      L: 46
    });
    this._serveChannel = void 0;
    this._clientChannel = void 0;
    if (_DiagnosticsChannel.supported) {
      this._serveChannel = new BroadcastChannel(_channelName);
      this._clientChannel = new BroadcastChannel(_channelName);
    }
  }
  destroy() {
    void this._ctx.dispose();
    this._serveChannel?.close();
    this._clientChannel?.close();
  }
  /**
  * In node.js, the channel will keep the process alive.
  * This method allows the process to exit.
  * Noop in the browser.
  */
  unref() {
    if (this._serveChannel && typeof this._serveChannel.unref === "function") {
      this._serveChannel.unref();
      this._clientChannel.unref();
    }
  }
  serve(manager) {
    invariant2(this._serveChannel, void 0, {
      F: __dxlog_file2,
      L: 78,
      S: this,
      A: [
        "this._serveChannel",
        ""
      ]
    });
    const listener = async (event) => {
      switch (event.data.type) {
        case "DIAGNOSTICS_DISCOVER": {
          const diagnostics = manager.list();
          this._serveChannel.postMessage({
            type: "DIAGNOSTICS_ANNOUNCE",
            diagnostics
          });
          break;
        }
        case "DIAGNOSTICS_FETCH": {
          const { requestId, request } = event.data;
          if (request.instanceId != null && request.instanceId !== manager.instanceId) {
            break;
          } else if (request.instanceTag != null && request.instanceTag !== manager.instanceTag) {
            break;
          }
          const data = await manager.fetch(request);
          this._serveChannel.postMessage({
            type: "DIAGNOSTICS_RESPONSE",
            requestId,
            data
          });
          break;
        }
      }
    };
    this._serveChannel.addEventListener("message", listener);
    this._ctx.onDispose(() => this._serveChannel.removeEventListener("message", listener));
  }
  async discover() {
    invariant2(this._clientChannel, void 0, {
      F: __dxlog_file2,
      L: 114,
      S: this,
      A: [
        "this._clientChannel",
        ""
      ]
    });
    const diagnostics = [];
    const collector = (event) => {
      const data = event.data;
      switch (data.type) {
        case "DIAGNOSTICS_ANNOUNCE":
          diagnostics.push(...data.diagnostics);
          break;
      }
    };
    try {
      this._clientChannel.addEventListener("message", collector);
      this._clientChannel.postMessage({
        type: "DIAGNOSTICS_DISCOVER"
      });
      await sleep(DISCOVER_TIME);
      const result = [];
      for (const diagnostic2 of diagnostics) {
        if (!result.some((d) => d.id === diagnostic2.id && d.instanceId === diagnostic2.instanceId)) {
          result.push(diagnostic2);
        }
      }
      return diagnostics;
    } finally {
      this._clientChannel.removeEventListener("message", collector);
    }
  }
  async fetch(request) {
    invariant2(this._clientChannel, void 0, {
      F: __dxlog_file2,
      L: 147,
      S: this,
      A: [
        "this._clientChannel",
        ""
      ]
    });
    const requestId = createId();
    const trigger = new Trigger();
    const listener = (event) => {
      const data = event.data;
      if (data.type === "DIAGNOSTICS_RESPONSE" && data.requestId === requestId) {
        trigger.wake(data.data);
      }
    };
    try {
      this._clientChannel.addEventListener("message", listener);
      this._clientChannel.postMessage({
        type: "DIAGNOSTICS_FETCH",
        requestId,
        request
      });
      const result = await trigger.wait({
        timeout: DIAGNOSTICS_TIMEOUT
      });
      return result;
    } finally {
      this._clientChannel.removeEventListener("message", listener);
    }
  }
};

// packages/common/tracing/src/remote/metrics.ts
var RemoteMetrics = class {
  constructor() {
    this._metrics = /* @__PURE__ */ new Set();
  }
  registerProcessor(processor) {
    this._metrics.add(processor);
  }
  increment(name, value, data) {
    return Array.from(this._metrics.values()).map((processor) => processor.increment(name, value, data));
  }
  distribution(name, value, data) {
    return Array.from(this._metrics.values()).map((processor) => processor.distribution(name, value, data));
  }
  set(name, value, data) {
    return Array.from(this._metrics.values()).map((processor) => processor.set(name, value, data));
  }
  gauge(name, value, data) {
    return Array.from(this._metrics.values()).map((processor) => processor.gauge(name, value, data));
  }
};

// packages/common/tracing/src/remote/tracing.ts
var RemoteTracing = class {
  constructor() {
    this._spanMap = /* @__PURE__ */ new Map();
  }
  registerProcessor(processor) {
    this._tracing = processor;
  }
  flushSpan(span2) {
    if (!this._tracing) {
      return;
    }
    if (!span2.endTs) {
      const remoteSpan = this._tracing.startSpan({
        name: span2.methodName,
        op: span2.op ?? "function",
        attributes: span2.attributes
      });
      this._spanMap.set(span2, remoteSpan);
    } else {
      const remoteSpan = this._spanMap.get(span2);
      if (remoteSpan) {
        remoteSpan.end();
        this._spanMap.delete(span2);
      }
    }
  }
};

// packages/common/tracing/src/trace-sender.ts
import { Stream } from "@dxos/codec-protobuf/stream";
var TraceSender = class {
  constructor(_traceProcessor) {
    this._traceProcessor = _traceProcessor;
  }
  streamTrace(request) {
    return new Stream(({ ctx, next }) => {
      const flushEvents = (resources, spans2, logs) => {
        const event = {
          resourceAdded: [],
          resourceRemoved: [],
          spanAdded: [],
          logAdded: []
        };
        if (resources) {
          for (const id of resources) {
            const entry = this._traceProcessor.resources.get(id);
            if (entry) {
              event.resourceAdded.push({
                resource: entry.data
              });
            } else {
              event.resourceRemoved.push({
                id
              });
            }
          }
        } else {
          for (const entry of this._traceProcessor.resources.values()) {
            event.resourceAdded.push({
              resource: entry.data
            });
          }
        }
        if (spans2) {
          for (const id of spans2) {
            const span2 = this._traceProcessor.spans.get(id);
            if (span2) {
              event.spanAdded.push({
                span: span2
              });
            }
          }
        } else {
          for (const span2 of this._traceProcessor.spans.values()) {
            event.spanAdded.push({
              span: span2
            });
          }
        }
        if (logs) {
          for (const log2 of logs) {
            event.logAdded.push({
              log: log2
            });
          }
        } else {
          for (const log2 of this._traceProcessor.logs) {
            event.logAdded.push({
              log: log2
            });
          }
        }
        if (event.resourceAdded.length > 0 || event.resourceRemoved.length > 0 || event.spanAdded.length > 0) {
          next(event);
        }
      };
      const flush = () => {
        flushEvents(subscription.dirtyResources, subscription.dirtySpans, subscription.newLogs);
        subscription.dirtyResources.clear();
        subscription.dirtySpans.clear();
        subscription.newLogs.length = 0;
      };
      const subscription = {
        flush,
        dirtyResources: /* @__PURE__ */ new Set(),
        dirtySpans: /* @__PURE__ */ new Set(),
        newLogs: []
      };
      this._traceProcessor.subscriptions.add(subscription);
      ctx.onDispose(() => {
        this._traceProcessor.subscriptions.delete(subscription);
      });
      flushEvents(null, null, null);
    });
  }
};

// packages/common/tracing/src/weak-ref.ts
var WeakRefMock = class {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor(target) {
  }
  deref() {
    return void 0;
  }
};
var WeakRef = globalThis.WeakRef ?? WeakRefMock;

// packages/common/tracing/src/trace-processor.ts
var __dxlog_file3 = "/home/runner/work/dxos/dxos/packages/common/tracing/src/trace-processor.ts";
var ResourceEntry = class {
  constructor(data, instance, annotation) {
    this.data = data;
    this.instance = instance;
    this.annotation = annotation;
    this.sanitizedClassName = sanitizeClassName(data.className);
  }
  getMetric(name) {
    return this.data.metrics?.find((metric) => metric.name === name);
  }
};
var MAX_RESOURCE_RECORDS = 2e3;
var MAX_SPAN_RECORDS = 1e3;
var MAX_LOG_RECORDS = 1e3;
var REFRESH_INTERVAL = 1e3;
var MAX_INFO_OBJECT_DEPTH = 8;
var IS_CLOUDFLARE_WORKERS = !!globalThis?.navigator?.userAgent?.includes("Cloudflare-Workers");
var TraceProcessor = class {
  constructor() {
    this.diagnostics = new DiagnosticsManager();
    this.diagnosticsChannel = new DiagnosticsChannel();
    this.remoteMetrics = new RemoteMetrics();
    this.remoteTracing = new RemoteTracing();
    this.subscriptions = /* @__PURE__ */ new Set();
    this.resources = /* @__PURE__ */ new Map();
    this.resourceInstanceIndex = /* @__PURE__ */ new WeakMap();
    this.resourceIdList = [];
    this.spans = /* @__PURE__ */ new Map();
    this.spanIdList = [];
    this.logs = [];
    this._instanceTag = null;
    this._logProcessor = (config, entry) => {
      switch (entry.level) {
        case LogLevel.ERROR:
        case LogLevel.WARN:
        case LogLevel.TRACE: {
          const scope = entry.meta?.S;
          const resource2 = this.resourceInstanceIndex.get(scope);
          if (!resource2) {
            return;
          }
          const context = getContextFromEntry(entry) ?? {};
          for (const key of Object.keys(context)) {
            context[key] = sanitizeValue(context[key], 0, this);
          }
          const entryToPush = {
            level: entry.level,
            message: entry.message,
            context,
            timestamp: /* @__PURE__ */ new Date(),
            meta: {
              file: entry.meta?.F ?? "",
              line: entry.meta?.L ?? 0,
              resourceId: resource2.data.id
            }
          };
          this._pushLog(entryToPush);
          break;
        }
        default:
      }
    };
    log.addProcessor(this._logProcessor.bind(this), void 0, {
      F: __dxlog_file3,
      L: 103,
      S: this,
      C: (f, a) => f(...a)
    });
    if (!IS_CLOUDFLARE_WORKERS) {
      const refreshInterval = setInterval(this.refresh.bind(this), REFRESH_INTERVAL);
      unrefTimeout(refreshInterval);
    }
    if (DiagnosticsChannel.supported) {
      this.diagnosticsChannel.serve(this.diagnostics);
    }
    this.diagnosticsChannel.unref();
  }
  setInstanceTag(tag) {
    this._instanceTag = tag;
    this.diagnostics.setInstanceTag(tag);
  }
  /**
  * @internal
  */
  // TODO(burdon): Comment.
  createTraceResource(params) {
    const id = this.resources.size;
    const tracingContext = getTracingContext(Object.getPrototypeOf(params.instance));
    for (const key of Object.keys(tracingContext.metricsProperties)) {
      params.instance[key]._assign(params.instance, key);
    }
    const entry = new ResourceEntry({
      id,
      className: params.constructor.name,
      instanceId: getPrototypeSpecificInstanceId(params.instance),
      info: this.getResourceInfo(params.instance),
      links: [],
      metrics: this.getResourceMetrics(params.instance)
    }, new WeakRef(params.instance), params.annotation);
    this.resources.set(id, entry);
    this.resourceInstanceIndex.set(params.instance, entry);
    this.resourceIdList.push(id);
    if (this.resourceIdList.length > MAX_RESOURCE_RECORDS) {
      this._clearResources();
    }
    this._markResourceDirty(id);
  }
  createTraceSender() {
    return new TraceSender(this);
  }
  traceSpan(params) {
    const span2 = new TracingSpan(this, params);
    this._flushSpan(span2);
    return span2;
  }
  // TODO(burdon): Not implemented.
  addLink(parent, child, opts) {
  }
  //
  // Getters
  //
  // TODO(burdon): Define type.
  // TODO(burdon): Reconcile with system service.
  getDiagnostics() {
    this.refresh();
    return {
      resources: Object.fromEntries(Array.from(this.resources.entries()).map(([id, entry]) => [
        `${entry.sanitizedClassName}#${entry.data.instanceId}`,
        entry.data
      ])),
      spans: Array.from(this.spans.values()),
      logs: this.logs.filter((log2) => log2.level >= LogLevel.INFO)
    };
  }
  getResourceInfo(instance) {
    const res = {};
    const tracingContext = getTracingContext(Object.getPrototypeOf(instance));
    for (const [key, { options }] of Object.entries(tracingContext.infoProperties)) {
      try {
        const value = typeof instance[key] === "function" ? instance[key]() : instance[key];
        if (options.enum) {
          res[key] = options.enum[value];
        } else {
          res[key] = sanitizeValue(value, options.depth === void 0 ? 1 : options.depth ?? MAX_INFO_OBJECT_DEPTH, this);
        }
      } catch (err) {
        res[key] = err.message;
      }
    }
    return res;
  }
  getResourceMetrics(instance) {
    const res = [];
    const tracingContext = getTracingContext(Object.getPrototypeOf(instance));
    for (const [key, _opts] of Object.entries(tracingContext.metricsProperties)) {
      res.push(instance[key].getData());
    }
    return res;
  }
  getResourceId(instance) {
    const entry = this.resourceInstanceIndex.get(instance);
    return entry ? entry.data.id : null;
  }
  findResourcesByClassName(className) {
    return [
      ...this.resources.values()
    ].filter((res) => res.data.className === className || res.sanitizedClassName === className);
  }
  findResourcesByAnnotation(annotation) {
    return [
      ...this.resources.values()
    ].filter((res) => res.annotation === annotation);
  }
  refresh() {
    for (const resource2 of this.resources.values()) {
      const instance = resource2.instance.deref();
      if (!instance) {
        continue;
      }
      const tracingContext = getTracingContext(Object.getPrototypeOf(instance));
      const time = performance.now();
      instance.tick?.(time);
      for (const key of Object.keys(tracingContext.metricsProperties)) {
        instance[key]._tick?.(time);
      }
      let _changed = false;
      const oldInfo = resource2.data.info;
      resource2.data.info = this.getResourceInfo(instance);
      _changed ||= !areEqualShallow(oldInfo, resource2.data.info);
      const oldMetrics = resource2.data.metrics;
      resource2.data.metrics = this.getResourceMetrics(instance);
      _changed ||= !areEqualShallow(oldMetrics, resource2.data.metrics);
      this._markResourceDirty(resource2.data.id);
    }
    for (const subscription of this.subscriptions) {
      subscription.flush();
    }
  }
  //
  // Implementation
  //
  /**
  * @internal
  */
  _flushSpan(runtimeSpan) {
    const span2 = runtimeSpan.serialize();
    this.spans.set(span2.id, span2);
    this.spanIdList.push(span2.id);
    if (this.spanIdList.length > MAX_SPAN_RECORDS) {
      this._clearSpans();
    }
    this._markSpanDirty(span2.id);
    this.remoteTracing.flushSpan(runtimeSpan);
  }
  _markResourceDirty(id) {
    for (const subscription of this.subscriptions) {
      subscription.dirtyResources.add(id);
    }
  }
  _markSpanDirty(id) {
    for (const subscription of this.subscriptions) {
      subscription.dirtySpans.add(id);
    }
  }
  _clearResources() {
    while (this.resourceIdList.length > MAX_RESOURCE_RECORDS) {
      const id = this.resourceIdList.shift();
      this.resources.delete(id);
    }
  }
  _clearSpans() {
    while (this.spanIdList.length > MAX_SPAN_RECORDS) {
      const id = this.spanIdList.shift();
      this.spans.delete(id);
    }
  }
  _pushLog(log2) {
    this.logs.push(log2);
    if (this.logs.length > MAX_LOG_RECORDS) {
      this.logs.shift();
    }
    for (const subscription of this.subscriptions) {
      subscription.newLogs.push(log2);
    }
  }
};
var TracingSpan = class _TracingSpan {
  static {
    this.nextId = 0;
  }
  constructor(_traceProcessor, params) {
    this._traceProcessor = _traceProcessor;
    this.parentId = null;
    this.resourceId = null;
    this.endTs = null;
    this.error = null;
    this._ctx = null;
    this.id = _TracingSpan.nextId++;
    this.methodName = params.methodName;
    this.resourceId = _traceProcessor.getResourceId(params.instance);
    this.startTs = performance.now();
    this._showInBrowserTimeline = params.showInBrowserTimeline;
    this.op = params.op;
    this.attributes = params.attributes ?? {};
    if (params.parentCtx) {
      this._ctx = params.parentCtx.derive({
        attributes: {
          [TRACE_SPAN_ATTRIBUTE]: this.id
        }
      });
      const parentId = params.parentCtx.getAttribute(TRACE_SPAN_ATTRIBUTE);
      if (typeof parentId === "number") {
        this.parentId = parentId;
      }
    }
  }
  get name() {
    const resource2 = this._traceProcessor.resources.get(this.resourceId);
    return resource2 ? `${resource2.sanitizedClassName}#${resource2.data.instanceId}.${this.methodName}` : this.methodName;
  }
  get ctx() {
    return this._ctx;
  }
  markSuccess() {
    this.endTs = performance.now();
    this._traceProcessor._flushSpan(this);
    if (this._showInBrowserTimeline) {
      this._markInBrowserTimeline();
    }
  }
  markError(err) {
    this.endTs = performance.now();
    this.error = serializeError(err);
    this._traceProcessor._flushSpan(this);
    if (this._showInBrowserTimeline) {
      this._markInBrowserTimeline();
    }
  }
  serialize() {
    return {
      id: this.id,
      resourceId: this.resourceId ?? void 0,
      methodName: this.methodName,
      parentId: this.parentId ?? void 0,
      startTs: this.startTs.toFixed(3),
      endTs: this.endTs?.toFixed(3) ?? void 0,
      error: this.error ?? void 0
    };
  }
  _markInBrowserTimeline() {
    if (typeof globalThis?.performance?.measure === "function") {
      performance.measure(this.name, {
        start: this.startTs,
        end: this.endTs
      });
    }
  }
};
var serializeError = (err) => {
  if (err instanceof Error) {
    return {
      name: err.name,
      message: err.message
    };
  }
  return {
    message: String(err)
  };
};
var TRACE_PROCESSOR = globalThis.TRACE_PROCESSOR ??= new TraceProcessor();
var sanitizeValue = (value, depth, traceProcessor) => {
  switch (typeof value) {
    case "string":
    case "number":
    case "boolean":
    case "undefined":
      return value;
    case "object":
    case "function":
      if (value === null) {
        return value;
      }
      {
        const resourceEntry = traceProcessor.resourceInstanceIndex.get(value);
        if (resourceEntry) {
          return `${resourceEntry.sanitizedClassName}#${resourceEntry.data.instanceId}`;
        }
      }
      if (typeof value.toJSON === "function") {
        return sanitizeValue(value.toJSON(), depth, traceProcessor);
      }
      if (depth > 0) {
        if (isSetLike(value)) {
          return Object.fromEntries(Array.from(value.entries()).map((value2) => sanitizeValue(value2, depth - 1, traceProcessor)));
        } else if (isMapLike(value)) {
          return Object.fromEntries(Array.from(value.entries()).map(([key, value2]) => [
            key,
            sanitizeValue(value2, depth - 1, traceProcessor)
          ]));
        } else if (Array.isArray(value)) {
          return value.map((item) => sanitizeValue(item, depth - 1, traceProcessor));
        } else if (typeof value === "object") {
          const res = {};
          for (const key of Object.keys(value)) {
            res[key] = sanitizeValue(value[key], depth - 1, traceProcessor);
          }
          return res;
        }
      }
      if (typeof value.truncate === "function") {
        return value.truncate();
      }
      return value.toString();
  }
};
var areEqualShallow = (a, b) => {
  for (const key in a) {
    if (!(key in b) || a[key] !== b[key]) {
      return false;
    }
  }
  for (const key in b) {
    if (!(key in a) || a[key] !== b[key]) {
      return false;
    }
  }
  return true;
};
var sanitizeClassName = (className) => {
  const SANITIZE_REGEX = /[^_](\d+)$/;
  const m = className.match(SANITIZE_REGEX);
  if (!m) {
    return className;
  } else {
    return className.slice(0, -m[1].length);
  }
};
var isSetLike = (value) => value instanceof Set || typeof value === "object" && value !== null && Object.getPrototypeOf(value).constructor.name === "ComplexSet";
var isMapLike = (value) => value instanceof Map || typeof value === "object" && value !== null && Object.getPrototypeOf(value).constructor.name === "ComplexMap";

// packages/common/tracing/src/api.ts
var resource = (options) => (constructor) => {
  const klass = /* @__PURE__ */ (() => class extends constructor {
    constructor(...rest) {
      super(...rest);
      TRACE_PROCESSOR.createTraceResource({
        constructor,
        annotation: options?.annotation,
        instance: this
      });
    }
  })();
  Object.defineProperty(klass, "name", {
    value: constructor.name
  });
  return klass;
};
var info = (opts = {}) => (target, propertyKey, descriptor) => {
  getTracingContext(target).infoProperties[propertyKey] = {
    options: opts
  };
};
var mark = (name) => {
  performance.mark(name);
};
var span = ({ showInBrowserTimeline = false, op, attributes } = {}) => (target, propertyKey, descriptor) => {
  const method = descriptor.value;
  descriptor.value = async function(...args) {
    const parentCtx = args[0] instanceof Context2 ? args[0] : null;
    const span2 = TRACE_PROCESSOR.traceSpan({
      parentCtx,
      methodName: propertyKey,
      instance: this,
      showInBrowserTimeline,
      op,
      attributes
    });
    const callArgs = span2.ctx ? [
      span2.ctx,
      ...args.slice(1)
    ] : args;
    try {
      return await method.apply(this, callArgs);
    } catch (err) {
      span2.markError(err);
      throw err;
    } finally {
      span2.markSuccess();
    }
  };
};
var spans = /* @__PURE__ */ new Map();
var spanStart = (params) => {
  if (spans.has(params.id)) {
    return;
  }
  const span2 = TRACE_PROCESSOR.traceSpan(params);
  spans.set(params.id, span2);
};
var spanEnd = (id) => {
  const span2 = spans.get(id);
  if (span2) {
    span2.markSuccess();
    spans.delete(id);
  }
};
var metricsCounter = () => (target, propertyKey, descriptor) => {
  getTracingContext(target).metricsProperties[propertyKey] = {};
};
var addLink = (parent, child, opts = {}) => {
  TRACE_PROCESSOR.addLink(parent, child, opts);
};
var diagnostic = (params) => {
  return TRACE_PROCESSOR.diagnostics.registerDiagnostic(params);
};
var trace = {
  addLink,
  diagnostic,
  info,
  mark,
  metricsCounter,
  resource,
  span,
  spanStart,
  spanEnd,
  metrics: TRACE_PROCESSOR.remoteMetrics
};

// packages/common/tracing/src/metrics/base.ts
var BaseCounter = class {
  /**
  * @internal
  */
  _assign(instance, name) {
    this._instance = instance;
    this.name = name;
  }
  _tick(time) {
  }
};

// packages/common/tracing/src/metrics/unary-counter.ts
var UnaryCounter = class extends BaseCounter {
  constructor({ units } = {}) {
    super();
    this.value = 0;
    this.units = units;
  }
  inc(by = 1) {
    this.value += by;
  }
  getData() {
    return {
      name: this.name,
      counter: {
        value: this.value,
        units: this.units
      }
    };
  }
};

// packages/common/tracing/src/metrics/time-series-counter.ts
var MAX_BUCKETS = 60;
var TimeSeriesCounter = class extends BaseCounter {
  constructor({ units } = {}) {
    super();
    this._currentValue = 0;
    this._totalValue = 0;
    this._buckets = [];
    this.units = units;
  }
  inc(by = 1) {
    this._currentValue += by;
    this._totalValue += by;
  }
  _tick(time) {
    this._buckets.push(this._currentValue);
    if (this._buckets.length > MAX_BUCKETS) {
      this._buckets.shift();
    }
    this._currentValue = 0;
  }
  getData() {
    return {
      name: this.name,
      timeSeries: {
        tracks: [
          {
            name: this.name,
            units: this.units,
            points: this._buckets.map((value, index) => ({
              value
            })),
            total: this._totalValue
          }
        ]
      }
    };
  }
};

// packages/common/tracing/src/metrics/time-usage-counter.ts
var MAX_BUCKETS2 = 60;
var TimeUsageCounter = class extends BaseCounter {
  constructor() {
    super(...arguments);
    this._currentValue = 0;
    this._totalValue = 0;
    this._buckets = [];
    this._lastTickTime = performance.now();
  }
  record(time) {
    this._currentValue += time;
    this._totalValue += time;
  }
  beginRecording() {
    const start = performance.now();
    return {
      end: () => {
        const end = performance.now();
        this.record(end - start);
      }
    };
  }
  _tick(time) {
    const delta = time - this._lastTickTime;
    this._lastTickTime = time;
    const percentage = this._currentValue / delta * 100;
    this._buckets.push(percentage);
    if (this._buckets.length > MAX_BUCKETS2) {
      this._buckets.shift();
    }
    this._currentValue = 0;
  }
  getData() {
    return {
      name: this.name,
      timeSeries: {
        tracks: [
          {
            name: this.name,
            units: "%",
            points: this._buckets.map((value, index) => ({
              value
            })),
            total: this._totalValue
          }
        ]
      }
    };
  }
};

// packages/common/tracing/src/metrics/map-counter.ts
var MapCounter = class extends BaseCounter {
  constructor({ units } = {}) {
    super();
    this.values = /* @__PURE__ */ new Map();
    this.units = units;
  }
  inc(key, by = 1) {
    const prev = this.values.get(key) ?? 0;
    this.values.set(key, prev + by);
  }
  getData() {
    return {
      name: this.name,
      multiCounter: {
        records: Array.from(this.values.entries()).map(([key, value]) => ({
          key,
          value
        })),
        units: this.units
      }
    };
  }
};

// packages/common/tracing/src/metrics/custom-counter.ts
var CustomCounter = class extends BaseCounter {
  constructor(_getData) {
    super(), this._getData = _getData;
  }
  getData() {
    return {
      name: this.name,
      custom: {
        payload: this._getData()
      }
    };
  }
};

// packages/common/tracing/src/index.ts
trace.diagnostic({
  id: "process-info",
  name: "Process Info",
  fetch: async () => {
    return {
      platform: globalThis.process?.platform,
      arch: globalThis.process?.arch,
      versions: globalThis.process?.versions,
      href: globalThis.location?.href
    };
  }
});
export {
  BaseCounter,
  CustomCounter,
  DIAGNOSTICS_TIMEOUT,
  DiagnosticsChannel,
  DiagnosticsManager,
  MapCounter,
  RemoteMetrics,
  RemoteTracing,
  ResourceEntry,
  TRACE_PROCESSOR,
  TRACE_SPAN_ATTRIBUTE,
  TimeSeriesCounter,
  TimeUsageCounter,
  TraceDiagnosticImpl,
  TraceProcessor,
  TraceSender,
  TracingSpan,
  UnaryCounter,
  getTracingContext,
  sanitizeClassName,
  symbolTracingContext,
  trace
};
//# sourceMappingURL=index.mjs.map
