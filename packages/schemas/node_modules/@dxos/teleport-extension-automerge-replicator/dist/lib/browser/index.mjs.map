{
  "version": 3,
  "sources": ["../../../src/automerge-replicator.ts"],
  "sourcesContent": ["//\n// Copyright 2023 DXOS.org\n//\n\nimport { Trigger, sleep } from '@dxos/async';\nimport { invariant } from '@dxos/invariant';\nimport { type PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { RpcClosedError } from '@dxos/protocols';\nimport { schema } from '@dxos/protocols/proto';\nimport {\n  type PeerInfo,\n  type AutomergeReplicatorService,\n  type SyncMessage,\n} from '@dxos/protocols/proto/dxos/mesh/teleport/automerge';\nimport { createProtoRpcPeer, type ProtoRpcPeer } from '@dxos/rpc';\nimport { type ExtensionContext, type TeleportExtension } from '@dxos/teleport';\n\nexport type AutomergeReplicatorParams = {\n  /**\n   * The peerId of local automerge repo.\n   */\n  peerId: string;\n  sendSyncRetryPolicy?: {\n    retriesBeforeBackoff: number;\n    retryBackoff: number;\n    maxRetries: number;\n  };\n};\n\nexport type AutomergeReplicatorCallbacks = {\n  /**\n   * Callback to be called when remote peer starts replication.\n   */\n  onStartReplication?: (info: PeerInfo, remotePeerId: PublicKey) => Promise<void>;\n\n  /**\n   * Callback to be called when a sync message is received.\n   */\n  onSyncMessage?: (message: SyncMessage) => Promise<void>;\n\n  /**\n   * Callback to be called when the extension is closed.\n   */\n  onClose?: (err?: Error) => Promise<void>;\n};\n\nconst RPC_TIMEOUT = 10_000;\n\nconst DEFAULT_RETRY_POLICY: NonNullable<AutomergeReplicatorParams['sendSyncRetryPolicy']> = {\n  retriesBeforeBackoff: 3,\n  retryBackoff: 1_000,\n  maxRetries: 10,\n};\n\nexport type AutomergeReplicatorFactory = (\n  params: ConstructorParameters<typeof AutomergeReplicator>,\n) => AutomergeReplicator;\n\n/**\n * Sends automerge messages between two peers for a single teleport session.\n */\nexport class AutomergeReplicator implements TeleportExtension {\n  private readonly _opened = new Trigger();\n  private _rpc?: ProtoRpcPeer<ServiceBundle>;\n\n  private _destroyed: boolean = false;\n  private _extensionContext?: ExtensionContext;\n\n  constructor(\n    private readonly _params: AutomergeReplicatorParams,\n    private readonly _callbacks: AutomergeReplicatorCallbacks = {},\n  ) {}\n\n  async onOpen(context: ExtensionContext): Promise<void> {\n    log('onOpen', { localPeerId: context.localPeerId, remotePeerId: context.remotePeerId });\n    this._extensionContext = context;\n    this._rpc = createProtoRpcPeer<ServiceBundle, ServiceBundle>({\n      timeout: RPC_TIMEOUT,\n      requested: {\n        AutomergeReplicatorService: schema.getService('dxos.mesh.teleport.automerge.AutomergeReplicatorService'),\n      },\n      exposed: {\n        AutomergeReplicatorService: schema.getService('dxos.mesh.teleport.automerge.AutomergeReplicatorService'),\n      },\n      handlers: {\n        AutomergeReplicatorService: {\n          startReplication: async (info: PeerInfo): Promise<void> => {\n            log('startReplication', { localPeerId: context.localPeerId, remotePeerId: context.remotePeerId, info });\n            await this._callbacks.onStartReplication?.(info, context.remotePeerId);\n          },\n          sendSyncMessage: async (message: SyncMessage): Promise<void> => {\n            await this._callbacks.onSyncMessage?.(message);\n          },\n        },\n      },\n      port: await context.createPort('rpc', {\n        contentType: 'application/x-protobuf; messageType=\"dxos.rpc.Message\"',\n      }),\n    });\n    await this._rpc.open();\n    // Announce to remote peer that we are ready to start replication.\n    await this._rpc.rpc.AutomergeReplicatorService.startReplication({ id: this._params.peerId });\n    this._opened.wake();\n  }\n\n  async onClose(err?: Error): Promise<void> {\n    await this._rpc?.close();\n    await this._destroy(err);\n  }\n\n  async onAbort(err?: Error): Promise<void> {\n    log('abort', { err });\n    await this._rpc?.abort();\n    await this._destroy(err);\n  }\n\n  private async _destroy(err?: Error): Promise<void> {\n    this._destroyed = true;\n    this._rpc = undefined;\n    this._extensionContext = undefined;\n    await this._callbacks.onClose?.(err);\n  }\n\n  async sendSyncMessage(message: SyncMessage): Promise<void> {\n    invariant(!this._destroyed);\n    await this._opened.wait();\n    invariant(this._rpc, 'RPC not initialized');\n\n    const retryPolicy = this._params.sendSyncRetryPolicy ?? DEFAULT_RETRY_POLICY;\n    let retries = 0;\n    while (true) {\n      try {\n        await this._rpc.rpc.AutomergeReplicatorService.sendSyncMessage(message);\n        break;\n      } catch (err) {\n        if (err instanceof RpcClosedError) {\n          return;\n        }\n\n        log('sendSyncMessage error', { err });\n\n        retries++;\n        if (retries >= retryPolicy.maxRetries) {\n          const numberOfRetriesExceededError = new Error(\n            `Failed to send sync message after ${retryPolicy.maxRetries} retries. Last attempt failed with error: ${err}`,\n          );\n          this._extensionContext?.close(numberOfRetriesExceededError);\n          throw numberOfRetriesExceededError;\n        }\n        if (retries % retryPolicy.retriesBeforeBackoff === 0) {\n          await sleep(retryPolicy.retryBackoff);\n        }\n      }\n    }\n  }\n}\n\ntype ServiceBundle = {\n  AutomergeReplicatorService: AutomergeReplicatorService;\n};\n"],
  "mappings": "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",
  "names": ["Trigger", "sleep", "invariant", "log", "RpcClosedError", "schema", "createProtoRpcPeer", "RPC_TIMEOUT", "DEFAULT_RETRY_POLICY", "retriesBeforeBackoff", "retryBackoff", "maxRetries", "AutomergeReplicator", "_params", "_callbacks", "_opened", "_destroyed", "onOpen", "context", "localPeerId", "remotePeerId", "_extensionContext", "_rpc", "timeout", "requested", "AutomergeReplicatorService", "getService", "exposed", "handlers", "startReplication", "info", "onStartReplication", "sendSyncMessage", "message", "onSyncMessage", "port", "createPort", "contentType", "open", "rpc", "id", "peerId", "wake", "onClose", "err", "close", "_destroy", "onAbort", "abort", "undefined", "wait", "retryPolicy", "sendSyncRetryPolicy", "retries", "numberOfRetriesExceededError", "Error"]
}
