"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var node_exports = {};
__export(node_exports, {
  AutomergeReplicator: () => AutomergeReplicator
});
module.exports = __toCommonJS(node_exports);
var import_async = require("@dxos/async");
var import_invariant = require("@dxos/invariant");
var import_log = require("@dxos/log");
var import_protocols = require("@dxos/protocols");
var import_proto = require("@dxos/protocols/proto");
var import_rpc = require("@dxos/rpc");
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/core/mesh/teleport-extension-automerge-replicator/src/automerge-replicator.ts";
var RPC_TIMEOUT = 1e4;
var DEFAULT_RETRY_POLICY = {
  retriesBeforeBackoff: 3,
  retryBackoff: 1e3,
  maxRetries: 10
};
var AutomergeReplicator = class {
  constructor(_params, _callbacks = {}) {
    this._params = _params;
    this._callbacks = _callbacks;
    this._opened = new import_async.Trigger();
    this._destroyed = false;
  }
  async onOpen(context) {
    (0, import_log.log)("onOpen", {
      localPeerId: context.localPeerId,
      remotePeerId: context.remotePeerId
    }, {
      F: __dxlog_file,
      L: 76,
      S: this,
      C: (f, a) => f(...a)
    });
    this._extensionContext = context;
    this._rpc = (0, import_rpc.createProtoRpcPeer)({
      timeout: RPC_TIMEOUT,
      requested: {
        AutomergeReplicatorService: import_proto.schema.getService("dxos.mesh.teleport.automerge.AutomergeReplicatorService")
      },
      exposed: {
        AutomergeReplicatorService: import_proto.schema.getService("dxos.mesh.teleport.automerge.AutomergeReplicatorService")
      },
      handlers: {
        AutomergeReplicatorService: {
          startReplication: async (info) => {
            (0, import_log.log)("startReplication", {
              localPeerId: context.localPeerId,
              remotePeerId: context.remotePeerId,
              info
            }, {
              F: __dxlog_file,
              L: 89,
              S: this,
              C: (f, a) => f(...a)
            });
            await this._callbacks.onStartReplication?.(info, context.remotePeerId);
          },
          sendSyncMessage: async (message) => {
            await this._callbacks.onSyncMessage?.(message);
          }
        }
      },
      port: await context.createPort("rpc", {
        contentType: 'application/x-protobuf; messageType="dxos.rpc.Message"'
      })
    });
    await this._rpc.open();
    await this._rpc.rpc.AutomergeReplicatorService.startReplication({
      id: this._params.peerId
    });
    this._opened.wake();
  }
  async onClose(err) {
    await this._rpc?.close();
    await this._destroy(err);
  }
  async onAbort(err) {
    (0, import_log.log)("abort", {
      err
    }, {
      F: __dxlog_file,
      L: 113,
      S: this,
      C: (f, a) => f(...a)
    });
    await this._rpc?.abort();
    await this._destroy(err);
  }
  async _destroy(err) {
    this._destroyed = true;
    this._rpc = void 0;
    this._extensionContext = void 0;
    await this._callbacks.onClose?.(err);
  }
  async sendSyncMessage(message) {
    (0, import_invariant.invariant)(!this._destroyed, void 0, {
      F: __dxlog_file,
      L: 126,
      S: this,
      A: [
        "!this._destroyed",
        ""
      ]
    });
    await this._opened.wait();
    (0, import_invariant.invariant)(this._rpc, "RPC not initialized", {
      F: __dxlog_file,
      L: 128,
      S: this,
      A: [
        "this._rpc",
        "'RPC not initialized'"
      ]
    });
    const retryPolicy = this._params.sendSyncRetryPolicy ?? DEFAULT_RETRY_POLICY;
    let retries = 0;
    while (true) {
      try {
        await this._rpc.rpc.AutomergeReplicatorService.sendSyncMessage(message);
        break;
      } catch (err) {
        if (err instanceof import_protocols.RpcClosedError) {
          return;
        }
        (0, import_log.log)("sendSyncMessage error", {
          err
        }, {
          F: __dxlog_file,
          L: 141,
          S: this,
          C: (f, a) => f(...a)
        });
        retries++;
        if (retries >= retryPolicy.maxRetries) {
          const numberOfRetriesExceededError = new Error(`Failed to send sync message after ${retryPolicy.maxRetries} retries. Last attempt failed with error: ${err}`);
          this._extensionContext?.close(numberOfRetriesExceededError);
          throw numberOfRetriesExceededError;
        }
        if (retries % retryPolicy.retriesBeforeBackoff === 0) {
          await (0, import_async.sleep)(retryPolicy.retryBackoff);
        }
      }
    }
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AutomergeReplicator
});
//# sourceMappingURL=index.cjs.map
