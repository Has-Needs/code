{
  "version": 3,
  "sources": ["../../../../src/testing/test-builder.ts", "../../../../src/testing/test-wire-protocol.ts"],
  "sourcesContent": ["//\n// Copyright 2022 DXOS.org\n//\n\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport {\n  MemorySignalManager,\n  MemorySignalManagerContext,\n  type SignalManager,\n  WebsocketSignalManager,\n} from '@dxos/messaging';\nimport { schema } from '@dxos/protocols/proto';\nimport { ConnectionState } from '@dxos/protocols/proto/dxos/client/services';\nimport { type Runtime } from '@dxos/protocols/proto/dxos/config';\nimport { createLinkedPorts, createProtoRpcPeer, type ProtoRpcPeer } from '@dxos/rpc';\nimport { ComplexMap } from '@dxos/util';\n\nimport { TcpTransportFactory } from '#tcp-transport';\nimport { type TestTeleportExtensionFactory, TestWireProtocol } from './test-wire-protocol';\nimport { SwarmNetworkManager } from '../network-manager';\nimport { FullyConnectedTopology } from '../topology';\nimport { MemoryTransportFactory, type TransportFactory, TransportKind } from '../transport';\nimport { createRtcTransportFactory, RtcTransportProxyFactory, RtcTransportService } from '../transport';\n\n// Signal server will be started by the setup script.\nconst port = process.env.SIGNAL_PORT ?? 4000;\nexport const TEST_SIGNAL_HOSTS: Runtime.Services.Signal[] = [\n  { server: `ws://localhost:${port}/.well-known/dx/signal` },\n];\n\nexport type TestBuilderOptions = {\n  signalHosts?: Runtime.Services.Signal[];\n  bridge?: boolean;\n  transport?: TransportKind;\n};\n\n/**\n * Builder used to construct networks and peers.\n */\nexport class TestBuilder {\n  private _signalContext = new MemorySignalManagerContext();\n\n  constructor(public readonly options: TestBuilderOptions = {}) {}\n\n  createSignalManager(): WebsocketSignalManager | MemorySignalManager {\n    if (this.options.signalHosts) {\n      return new WebsocketSignalManager(this.options.signalHosts);\n    }\n\n    return new MemorySignalManager(this._signalContext);\n  }\n\n  createPeer(peerId: PublicKey = PublicKey.random()): TestPeer {\n    return new TestPeer(this, peerId, this.options.transport);\n  }\n}\n\n/**\n * Testing network peer.\n */\nexport class TestPeer {\n  private readonly _swarms = new ComplexMap<PublicKey, TestSwarmConnection>(PublicKey.hash);\n\n  /**\n   * @internal\n   */\n  readonly _signalManager: SignalManager;\n\n  /**\n   * @internal\n   */\n  readonly _networkManager: SwarmNetworkManager;\n\n  private _proxy?: ProtoRpcPeer<any>;\n  private _service?: ProtoRpcPeer<any>;\n\n  constructor(\n    private readonly testBuilder: TestBuilder,\n    public readonly peerId: PublicKey,\n    public readonly transport: TransportKind = testBuilder.options.signalHosts\n      ? TransportKind.WEB_RTC\n      : TransportKind.MEMORY,\n  ) {\n    this._signalManager = this.testBuilder.createSignalManager();\n    this._networkManager = this.createNetworkManager(this.transport);\n    this._networkManager.setPeerInfo({ identityKey: peerId.toHex(), peerKey: peerId.toHex() });\n  }\n\n  // TODO(burdon): Move to TestBuilder.\n  createNetworkManager(transport: TransportKind): SwarmNetworkManager {\n    let transportFactory: TransportFactory;\n    if (this.testBuilder.options.signalHosts) {\n      log.info(`using ${transport} transport with signal server.`);\n      switch (transport) {\n        case TransportKind.MEMORY:\n          throw new Error('Memory transport not supported with signal server.');\n        case TransportKind.TCP:\n          transportFactory = TcpTransportFactory;\n          break;\n        case TransportKind.WEB_RTC:\n          transportFactory = createRtcTransportFactory();\n          break;\n        case TransportKind.WEB_RTC_PROXY:\n          {\n            // Simulates bridge to shared worker.\n            const [proxyPort, servicePort] = createLinkedPorts();\n\n            this._proxy = createProtoRpcPeer({\n              port: proxyPort,\n              requested: {\n                BridgeService: schema.getService('dxos.mesh.bridge.BridgeService'),\n              },\n              noHandshake: true,\n              encodingOptions: {\n                preserveAny: true,\n              },\n            });\n\n            this._service = createProtoRpcPeer({\n              port: servicePort,\n              exposed: {\n                BridgeService: schema.getService('dxos.mesh.bridge.BridgeService'),\n              },\n              handlers: { BridgeService: new RtcTransportService() },\n              noHandshake: true,\n              encodingOptions: {\n                preserveAny: true,\n              },\n            });\n\n            transportFactory = new RtcTransportProxyFactory().setBridgeService(this._proxy.rpc.BridgeService);\n          }\n          break;\n        default:\n          throw new Error(`Unsupported transport: ${transport}`);\n      }\n    } else {\n      if (transport !== TransportKind.MEMORY && transport !== TransportKind.TCP) {\n        log.warn(`specified transport ${transport} but no signalling configured, using memory transport instead`);\n      }\n      log.info(`using ${transport} transport without signal server.`);\n      transportFactory = MemoryTransportFactory;\n    }\n\n    return new SwarmNetworkManager({\n      signalManager: this._signalManager,\n      transportFactory,\n    });\n  }\n\n  async open(): Promise<void> {\n    await this._networkManager.open();\n    await this._proxy?.open();\n    await this._service?.open();\n  }\n\n  async close(): Promise<void> {\n    await Promise.all(Array.from(this._swarms.values()).map((swarm) => swarm.leave()));\n    this._swarms.clear();\n\n    await this._proxy?.close();\n    await this._service?.close();\n    await this._networkManager.close();\n  }\n\n  getSwarm(topic: PublicKey): TestSwarmConnection {\n    const swarm = this._swarms.get(topic);\n    if (!swarm) {\n      throw new Error(`Swarm not found for topic: ${topic}`);\n    }\n\n    return swarm;\n  }\n\n  createSwarm(topic: PublicKey, extensionFactory: TestTeleportExtensionFactory = () => []): TestSwarmConnection {\n    // TODO(burdon): Multiple.\n    // if (this._swarms.get(topic)) {\n    //   throw new Error(`Swarm already exists for topic: ${topic.truncate()}`);\n    // }\n\n    const swarm = new TestSwarmConnection(this, topic, extensionFactory);\n    this._swarms.set(topic, swarm);\n    return swarm;\n  }\n\n  async goOffline(): Promise<void> {\n    await this._networkManager.setConnectionState(ConnectionState.OFFLINE);\n  }\n\n  async goOnline(): Promise<void> {\n    await this._networkManager.setConnectionState(ConnectionState.ONLINE);\n  }\n}\n\n// TODO(burdon): Reconcile with new Swarm concept.\nexport class TestSwarmConnection {\n  protocol: TestWireProtocol;\n\n  constructor(\n    readonly peer: TestPeer,\n    readonly topic: PublicKey,\n    readonly extensionFactory: TestTeleportExtensionFactory,\n  ) {\n    // TODO(burdon): Configure plugins.\n    // TODO(burdon): Prevent reuse?\n    this.protocol = new TestWireProtocol(this.extensionFactory);\n  }\n\n  // TODO(burdon): Need to create new plugin instance per swarm?\n  //  If so, then perhaps joinSwarm should return swarm object with access to plugins.\n  async join(topology = new FullyConnectedTopology()): Promise<this> {\n    await this.peer._networkManager.joinSwarm({\n      topic: this.topic,\n      peerInfo: { peerKey: this.peer.peerId.toHex(), identityKey: this.peer.peerId.toHex() },\n      protocolProvider: this.protocol.factory,\n      topology,\n    });\n\n    return this;\n  }\n\n  async leave(): Promise<this> {\n    await this.peer._networkManager.leaveSwarm(this.topic);\n    return this;\n  }\n}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { asyncTimeout, Event } from '@dxos/async';\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { TestExtension, TestExtensionWithStreams } from '@dxos/teleport';\nimport type { TestStreamStats, TeleportExtension } from '@dxos/teleport';\nimport { ComplexMap } from '@dxos/util';\n\nimport { createTeleportProtocolFactory } from '../wire-protocol';\n\nexport type TestTeleportExtension = {\n  name: string;\n  extension: TeleportExtension;\n};\n\nexport type TestTeleportExtensionFactory = () => TestTeleportExtension[];\n\nexport class TestWireProtocol {\n  public readonly connections = new ComplexMap<PublicKey, TestExtension>(PublicKey.hash);\n  public readonly streamConnections = new ComplexMap<PublicKey, TestExtensionWithStreams>(PublicKey.hash);\n\n  public readonly connected = new Event<PublicKey>();\n  public readonly disconnected = new Event<PublicKey>();\n\n  public readonly otherConnections = new ComplexMap<{ remotePeerId: PublicKey; extension: string }, TeleportExtension>(\n    ({ remotePeerId, extension }) => remotePeerId.toHex() + extension,\n  );\n\n  constructor(private readonly _extensionFactory: TestTeleportExtensionFactory = () => []) {}\n\n  readonly factory = createTeleportProtocolFactory(async (teleport) => {\n    log('create', { remotePeerId: teleport.remotePeerId });\n    const handleDisconnect = () => {\n      this.connections.delete(teleport.remotePeerId);\n      this.disconnected.emit(teleport.remotePeerId);\n    };\n    const extension = new TestExtension({\n      onClose: async () => handleDisconnect(),\n      onAbort: async () => handleDisconnect(),\n    });\n    this.connections.set(teleport.remotePeerId, extension);\n    teleport.addExtension('test', extension);\n    this.connected.emit(teleport.remotePeerId);\n\n    const streamExtension = new TestExtensionWithStreams({\n      onClose: async () => {\n        this.streamConnections.delete(teleport.remotePeerId);\n      },\n    });\n    this.streamConnections.set(teleport.remotePeerId, streamExtension);\n    teleport.addExtension('test-stream', streamExtension);\n\n    for (const { name, extension } of this._extensionFactory()) {\n      this.otherConnections.set({ remotePeerId: teleport.remotePeerId, extension: name }, extension);\n      teleport.addExtension(name, extension);\n    }\n  });\n\n  async waitForConnection(peerId: PublicKey): Promise<TestExtension> {\n    if (this.connections.has(peerId)) {\n      return this.connections.get(peerId)!;\n    }\n    log('waitForConnection', { peerId });\n    await asyncTimeout(\n      this.connected.waitFor((connectedId) => connectedId.equals(peerId)),\n      // TODO(nf): Make this configurable.\n      10_000,\n    );\n    return this.connections.get(peerId)!;\n  }\n\n  async testConnection(peerId: PublicKey, message?: string): Promise<void> {\n    const connection = await this.waitForConnection(peerId);\n    await connection.test(message);\n  }\n\n  async openStream(\n    peerId: PublicKey,\n    streamTag: string,\n    streamLoadInterval: number,\n    streamLoadChunkSize: number,\n  ): Promise<string> {\n    if (!this.streamConnections.has(peerId)) {\n      throw new Error('Connection does not exist.');\n    }\n    const connection = this.streamConnections.get(peerId)!;\n    return connection.addNewStream(streamLoadInterval, streamLoadChunkSize, streamTag);\n  }\n\n  async closeStream(peerId: PublicKey, streamTag: string): Promise<TestStreamStats> {\n    if (!this.streamConnections.has(peerId)) {\n      throw new Error('Connection does not exist.');\n    }\n    const connection = this.streamConnections.get(peerId)!;\n    return connection.closeStream(streamTag);\n  }\n}\n"],
  "mappings": "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",
  "names": ["import_keys", "import_log", "import_util", "TestWireProtocol", "_extensionFactory", "connections", "ComplexMap", "PublicKey", "hash", "streamConnections", "connected", "Event", "disconnected", "otherConnections", "remotePeerId", "extension", "toHex", "factory", "createTeleportProtocolFactory", "teleport", "log", "handleDisconnect", "delete", "emit", "TestExtension", "onClose", "onAbort", "set", "addExtension", "streamExtension", "TestExtensionWithStreams", "name", "waitForConnection", "peerId", "has", "get", "asyncTimeout", "waitFor", "connectedId", "equals", "testConnection", "message", "connection", "test", "openStream", "streamTag", "streamLoadInterval", "streamLoadChunkSize", "Error", "addNewStream", "closeStream", "port", "process", "env", "SIGNAL_PORT", "TEST_SIGNAL_HOSTS", "server", "TestBuilder", "options", "_signalContext", "MemorySignalManagerContext", "createSignalManager", "signalHosts", "WebsocketSignalManager", "MemorySignalManager", "createPeer", "random", "TestPeer", "transport", "testBuilder", "TransportKind", "WEB_RTC", "MEMORY", "_swarms", "_signalManager", "_networkManager", "createNetworkManager", "setPeerInfo", "identityKey", "peerKey", "transportFactory", "info", "TCP", "TcpTransportFactory", "createRtcTransportFactory", "WEB_RTC_PROXY", "proxyPort", "servicePort", "createLinkedPorts", "_proxy", "createProtoRpcPeer", "requested", "BridgeService", "schema", "getService", "noHandshake", "encodingOptions", "preserveAny", "_service", "exposed", "handlers", "RtcTransportService", "RtcTransportProxyFactory", "setBridgeService", "rpc", "warn", "MemoryTransportFactory", "SwarmNetworkManager", "signalManager", "open", "close", "Promise", "all", "Array", "from", "values", "map", "swarm", "leave", "clear", "getSwarm", "topic", "createSwarm", "extensionFactory", "TestSwarmConnection", "goOffline", "setConnectionState", "ConnectionState", "OFFLINE", "goOnline", "ONLINE", "peer", "protocol", "join", "topology", "FullyConnectedTopology", "joinSwarm", "peerInfo", "protocolProvider", "leaveSwarm"]
}
