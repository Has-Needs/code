import { Event } from '@dxos/async';
import { PublicKey } from '@dxos/keys';
import { type PeerInfo } from '@dxos/messaging';
import { SystemError } from '@dxos/protocols';
import { type Answer } from '@dxos/protocols/proto/dxos/mesh/swarm';
import { Connection } from './connection';
import { type ConnectionLimiter } from './connection-limiter';
import { type OfferMessage, type SignalMessage, type SignalMessenger } from '../signal';
import { type TransportFactory } from '../transport';
import { type WireProtocolProvider } from '../wire-protocol';
export declare class ConnectionDisplacedError extends SystemError {
    constructor();
}
interface PeerCallbacks {
    /**
     * Connection attempt initiated.
     */
    onInitiated: (connection: Connection) => void;
    /**
     * Connection opened.
     */
    onConnected: () => void;
    /**
     * Connection closed.
     */
    onDisconnected: () => void;
    /**
     * Peer accepted our offer to connect.
     */
    onAccepted: () => void;
    /**
     * Peer rejected our offer to connect.
     */
    onRejected: () => void;
    /**
     * Returns true if the remote peer's offer should be accepted.
     */
    onOffer: (remote: PeerInfo) => Promise<boolean>;
    /**
     * Peer is available to connect.
     */
    onPeerAvailable: () => void;
}
/**
 * State of remote peer during the lifetime of a swarm connection.
 * Can open and close multiple connections to the remote peer.
 */
export declare class Peer {
    readonly remoteInfo: PeerInfo;
    readonly topic: PublicKey;
    readonly localInfo: PeerInfo;
    private readonly _signalMessaging;
    private readonly _protocolProvider;
    private readonly _transportFactory;
    private readonly _connectionLimiter;
    private readonly _callbacks;
    /**
     * Will be available to connect after this time.
     */
    private _availableAfter;
    availableToConnect: boolean;
    private _lastConnectionTime?;
    private readonly _ctx;
    private _connectionCtx?;
    connection?: Connection;
    /**
     * Whether the peer is currently advertizing itself on the signal-network.
     */
    advertizing: boolean;
    initiating: boolean;
    readonly connectionDisplaced: Event<Connection>;
    constructor(remoteInfo: PeerInfo, topic: PublicKey, localInfo: PeerInfo, _signalMessaging: SignalMessenger, _protocolProvider: WireProtocolProvider, _transportFactory: TransportFactory, _connectionLimiter: ConnectionLimiter, _callbacks: PeerCallbacks);
    /**
     * Respond to remote offer.
     */
    onOffer(message: OfferMessage): Promise<Answer>;
    /**
     * Initiate a connection to the remote peer.
     */
    initiateConnection(): Promise<void>;
    /**
     * Create new connection.
     * Either we're initiating a connection or creating one in response to an offer from the other peer.
     */
    private _createConnection;
    closeConnection(err?: Error): Promise<void>;
    onSignal(message: SignalMessage): Promise<void>;
    safeDestroy(reason?: string): Promise<void>;
}
export {};
//# sourceMappingURL=peer.d.ts.map