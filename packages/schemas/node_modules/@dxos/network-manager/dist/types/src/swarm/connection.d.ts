import { Event } from '@dxos/async';
import { ErrorStream } from '@dxos/debug';
import { PublicKey } from '@dxos/keys';
import { type PeerInfo } from '@dxos/messaging';
import { type SignalMessage, type SignalMessenger } from '../signal';
import { type Transport, type TransportFactory, type TransportStats } from '../transport';
import { type WireProtocol } from '../wire-protocol';
interface ConnectionCallbacks {
    /**
     * Connection opened.
     */
    onConnected?: () => void;
    /**
     * Connection closed.
     */
    onClosed?: (err?: Error) => void;
}
/**
 * State machine for each connection.
 */
export declare enum ConnectionState {
    /**
     *  Connection is created, but not yet passed through the connection limiter.
     */
    CREATED = "CREATED",
    /**
     * Initial state. Connection is registered but no attempt to connect to the remote peer has been performed.
     * Might mean that we are waiting for the answer signal from the remote peer.
     */
    INITIAL = "INITIAL",
    /**
     * Trying to establish connection.
     */
    CONNECTING = "CONNECTING",
    /**
     * Connection is established.
     */
    CONNECTED = "CONNECTED",
    /**
     * Connection is being closed.
     */
    CLOSING = "CLOSING",
    /**
     * Connection closed.
     */
    CLOSED = "CLOSED",
    ABORTING = "ABORTING",
    ABORTED = "ABORTED"
}
/**
 * Represents a connection to a remote peer.
 * Owns a transport paired together with a wire-protocol.
 */
export declare class Connection {
    readonly topic: PublicKey;
    readonly localInfo: PeerInfo;
    readonly remoteInfo: PeerInfo;
    readonly sessionId: PublicKey;
    readonly initiator: boolean;
    private readonly _signalMessaging;
    private readonly _protocol;
    private readonly _transportFactory;
    private readonly _callbacks?;
    private readonly _ctx;
    private connectedTimeoutContext;
    private _protocolClosed;
    private _transportClosed;
    private _state;
    private _transport;
    closeReason?: string;
    private _incomingSignalBuffer;
    private _outgoingSignalBuffer;
    readonly stateChanged: Event<ConnectionState>;
    readonly errors: ErrorStream;
    _instanceId: string;
    readonly transportStats: Event<TransportStats>;
    private readonly _signalSendTask;
    private _signallingDelay;
    constructor(topic: PublicKey, localInfo: PeerInfo, remoteInfo: PeerInfo, sessionId: PublicKey, initiator: boolean, _signalMessaging: SignalMessenger, _protocol: WireProtocol, _transportFactory: TransportFactory, _callbacks?: ConnectionCallbacks | undefined);
    get sessionIdString(): string;
    get state(): ConnectionState;
    get transport(): Transport | undefined;
    get protocol(): WireProtocol;
    /**
     * Create an underlying transport and prepares it for the connection.
     */
    openConnection(): Promise<void>;
    abort(err?: Error): Promise<void>;
    close({ error, reason }?: {
        error?: Error;
        reason?: string;
    }): Promise<void>;
    private _closeProtocol;
    private _closeTransport;
    private _sendSignal;
    private _flushSignalBuffer;
    /**
     * Receive a signal from the remote peer.
     */
    signal(msg: SignalMessage): Promise<void>;
    initiate(): void;
    private _changeState;
    private _emitTransportStats;
}
export {};
//# sourceMappingURL=connection.d.ts.map