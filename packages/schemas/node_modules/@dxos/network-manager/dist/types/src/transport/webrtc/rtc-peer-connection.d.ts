import { type Signal } from '@dxos/protocols/proto/dxos/mesh/swarm';
import { type RtcConnectionFactory } from './rtc-connection-factory';
import { RtcTransportChannel } from './rtc-transport-channel';
import type { IceProvider } from '../../signal';
import { type TransportOptions } from '../transport';
export type RtcPeerChannelFactoryOptions = {
    ownPeerKey: string;
    remotePeerKey: string;
    /**
     * Sends signal message to remote peer.
     */
    sendSignal: (signal: Signal) => Promise<void>;
    webrtcConfig?: RTCConfiguration;
    iceProvider?: IceProvider;
    /**
     * TODO: remove after the new rtc code rollout. Used for staging interop with older version running in prod.
     */
    legacyInitiator?: boolean;
};
/**
 * A factory for rtc Transport implementations for a particular peer.
 * Contains WebRTC connection establishment logic.
 * When the first Transport is opened a connection is established and kept until all the transports are closed.
 */
export declare class RtcPeerConnection {
    private readonly _factory;
    private readonly _options;
    private readonly _channelCreatedCallbacks;
    private readonly _transportChannels;
    private readonly _dataChannels;
    private readonly _readyForCandidates;
    private readonly _offerProcessingMutex;
    /**
     * Can't use peer.connection.initiator, because if two connections to the same peer are created in
     * different swarms, we might be the initiator of the first one, but not of the other one.
     * Use a stable peer keypair property (key ordering) to decide who's acting as the initiator of
     * transport connection establishment and data channel creation.
     */
    private readonly _initiator;
    private _connection?;
    constructor(_factory: RtcConnectionFactory, _options: RtcPeerChannelFactoryOptions);
    get transportChannelCount(): number;
    get currentConnection(): RTCPeerConnection | undefined;
    createDataChannel(topic: string): Promise<RTCDataChannel>;
    createTransportChannel(options: TransportOptions): RtcTransportChannel;
    private _openConnection;
    private _lockAndAbort;
    private _abortConnection;
    private _lockAndCloseConnection;
    onSignal(signal: Signal): Promise<void>;
    private _processIceCandidate;
    private _onSessionNegotiated;
    private _onConnectionCallbackAfterClose;
    private _safeCloseConnection;
    private _loadConnectionConfig;
    private _sendIceCandidate;
    private _sendDescription;
    protected get _connectionInfo(): {
        ts: number;
        remotePeerKey: string;
        channels: string[];
        config: RTCConfiguration | undefined;
        connectionState?: RTCPeerConnectionState | undefined;
        iceConnectionState?: RTCIceConnectionState | undefined;
        iceGatheringState?: RTCIceGatheringState | undefined;
        signalingState?: RTCSignalingState | undefined;
        remoteDescription?: RTCSessionDescription | null | undefined;
        localDescription?: RTCSessionDescription | null | undefined;
    };
    private get _loggerContext();
}
//# sourceMappingURL=rtc-peer-connection.d.ts.map