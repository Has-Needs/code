import { createRequire } from 'node:module';const require = createRequire(import.meta.url);

// packages/common/log/src/index.ts
import omit from "lodash.omit";
import { pick } from "@dxos/util";

// packages/common/log/src/config.ts
var LogLevel = /* @__PURE__ */ function(LogLevel2) {
  LogLevel2[LogLevel2["TRACE"] = 5] = "TRACE";
  LogLevel2[LogLevel2["DEBUG"] = 10] = "DEBUG";
  LogLevel2[LogLevel2["VERBOSE"] = 11] = "VERBOSE";
  LogLevel2[LogLevel2["INFO"] = 12] = "INFO";
  LogLevel2[LogLevel2["WARN"] = 13] = "WARN";
  LogLevel2[LogLevel2["ERROR"] = 14] = "ERROR";
  return LogLevel2;
}({});
var levels = {
  trace: 5,
  debug: 10,
  verbose: 11,
  info: 12,
  warn: 13,
  error: 14
};
var shortLevelName = {
  [5]: "T",
  [10]: "D",
  [11]: "V",
  [12]: "I",
  [13]: "W",
  [14]: "E"
};
var LogProcessorType = /* @__PURE__ */ function(LogProcessorType2) {
  LogProcessorType2["CONSOLE"] = "console";
  LogProcessorType2["BROWSER"] = "browser";
  LogProcessorType2["DEBUG"] = "debug";
  return LogProcessorType2;
}({});

// packages/common/log/src/scope.ts
var logInfoProperties = Symbol("logInfoProperties");
var logInfo = (target, propertyKey, descriptor) => {
  (target[logInfoProperties] ??= []).push(propertyKey);
};
var gatherLogInfoFromScope = (scope) => {
  if (!scope) {
    return {};
  }
  const res = {};
  const prototype = Object.getPrototypeOf(scope);
  const infoProps = prototype[logInfoProperties] ?? [];
  for (const prop of infoProps) {
    try {
      res[prop] = typeof scope[prop] === "function" ? scope[prop]() : scope[prop];
    } catch (err) {
      res[prop] = err.message;
    }
  }
  return res;
};

// packages/common/log/src/context.ts
var matchFilter = (filter, level, path) => {
  return level >= filter.level && (!filter.pattern || path.includes(filter.pattern));
};
var shouldLog = (entry, filters) => {
  if (filters === void 0) {
    return true;
  } else {
    return filters.some((filter) => matchFilter(filter, entry.level, entry.meta?.F ?? ""));
  }
};
var getContextFromEntry = (entry) => {
  let context;
  if (entry.meta) {
    const scopeInfo = gatherLogInfoFromScope(entry.meta.S);
    if (Object.keys(scopeInfo).length > 0) {
      context = Object.assign(context ?? {}, scopeInfo);
    }
  }
  const entryContext = typeof entry.context === "function" ? entry.context() : entry.context;
  if (entryContext) {
    if (entryContext instanceof Error) {
      const c = entryContext.context;
      context = Object.assign(context ?? {}, {
        error: entryContext.stack,
        ...c
      });
    } else if (typeof entryContext === "object") {
      context = Object.assign(context ?? {}, entryContext);
    }
  }
  if (entry.error) {
    const errorContext = entry.error.context;
    context = Object.assign(context ?? {}, {
      error: entry.error,
      ...errorContext
    });
  }
  return context && Object.keys(context).length > 0 ? context : void 0;
};

// packages/common/log/src/decorators.ts
import chalk from "chalk";
import { inspect } from "node:util";
var nextPromiseId = 0;
var createMethodLogDecorator = (log2) => (arg0, arg1, meta) => (target, propertyKey, descriptor) => {
  const method = descriptor.value;
  const methodName = propertyKey;
  descriptor.value = function(...args) {
    const combinedMeta = {
      F: "",
      L: 0,
      ...meta ?? {},
      S: this
    };
    const formattedArgs = args.map((arg) => inspect(arg, false, 1, true)).join(", ");
    try {
      const startTime = performance.now();
      const result = method.apply(this, args);
      if (isThenable(result)) {
        const id = nextPromiseId++;
        logAsyncBegin(log2, methodName, formattedArgs, id, combinedMeta);
        result.then((resolvedValue) => {
          logAsyncResolved(log2, methodName, resolvedValue, id, startTime, combinedMeta);
        }, (err) => {
          logAsyncRejected(log2, methodName, err, id, startTime, combinedMeta);
        });
      } else {
        logSyncCall(log2, methodName, formattedArgs, result, combinedMeta);
      }
      return result;
    } catch (err) {
      logSyncError(log2, methodName, formattedArgs, err, combinedMeta);
      throw err;
    }
  };
  Object.defineProperty(descriptor.value, "name", {
    value: methodName + "$log"
  });
};
var createFunctionLogDecorator = (log2) => (name, fn, opts = {}) => {
  const decoratedFn = function(...args) {
    const combinedMeta = {
      F: "",
      L: 0
    };
    const formattedArgs = args.map((arg) => inspect(arg, false, 1, true)).join(", ");
    try {
      const startTime = performance.now();
      const result = fn.apply(this, args);
      let transformedResult = result;
      if (opts.transformOutput) {
        if (isThenable(result)) {
          transformedResult = result.then(opts.transformOutput);
        } else {
          transformedResult = opts.transformOutput(result);
        }
      }
      if (isThenable(transformedResult)) {
        const id = nextPromiseId++;
        logAsyncBegin(log2, name, formattedArgs, id, combinedMeta);
        transformedResult.then((resolvedValue) => {
          logAsyncResolved(log2, name, resolvedValue, id, startTime, combinedMeta);
        }, (err) => {
          logAsyncRejected(log2, name, err, id, startTime, combinedMeta);
        });
      } else {
        logSyncCall(log2, name, formattedArgs, transformedResult, combinedMeta);
      }
      return result;
    } catch (err) {
      logSyncError(log2, name, formattedArgs, err, combinedMeta);
      throw err;
    }
  };
  Object.defineProperty(decoratedFn, "name", {
    value: name + "$log"
  });
  return decoratedFn;
};
var isThenable = (obj) => obj && typeof obj.then === "function";
var logSyncCall = (log2, methodName, formattedArgs, result, combinedMeta) => {
  log2.info(`.${formatFunction(methodName)} (${formattedArgs}) ${chalk.gray("=>")} ${inspect(result, false, 1, true)}`, {}, combinedMeta);
};
var logSyncError = (log2, methodName, formattedArgs, err, combinedMeta) => {
  log2.error(`.${formatFunction(methodName)} (${formattedArgs}) \u{1F525} ${err}`, {}, combinedMeta);
};
var logAsyncBegin = (log2, methodName, formattedArgs, promiseId, combinedMeta) => {
  log2.info(`.${formatFunction(methodName)} \u21B4 (${formattedArgs}) ${chalk.gray("=>")} ${formatPromise(promiseId)}`, {}, combinedMeta);
};
var logAsyncResolved = (log2, methodName, resolvedValue, promiseId, startTime, combinedMeta) => {
  if (resolvedValue !== void 0) {
    log2.info(`.${formatFunction(methodName)} \u21B2 ${greenCheck} ${chalk.gray("resolve")} ${formatPromise(promiseId)} ${formatTimeElapsed(startTime)} ${chalk.gray("=>")} ${inspect(resolvedValue, false, 1, true)}`, {}, combinedMeta);
  } else {
    log2.info(`.${formatFunction(methodName)} \u21B2 ${greenCheck} ${chalk.gray("resolve")} ${formatPromise(promiseId)} ${formatTimeElapsed(startTime)}`, {}, combinedMeta);
  }
};
var logAsyncRejected = (log2, methodName, err, promiseId, startTime, combinedMeta) => {
  log2.info(`.${formatFunction(methodName)} \u21B2 \u{1F525} ${chalk.gray("reject")} ${formatPromise(promiseId)} ${formatTimeElapsed(startTime)} ${chalk.gray("=>")} ${err}`, {}, combinedMeta);
};
var greenCheck = typeof chalk.green === "function" ? chalk.green("\u2714") : "\u2714";
var formatTimeElapsed = (startTime) => chalk.gray(`${(performance.now() - startTime).toFixed(0)}ms`);
var COLOR_FUNCTION = [
  220,
  220,
  170
];
var formatFunction = (name) => chalk.bold(chalk.rgb(...COLOR_FUNCTION)(name));
var formatPromise = (id) => chalk.blue(`Promise#${id}`);

// packages/common/log/src/options.ts
import defaultsDeep from "lodash.defaultsdeep";

// packages/common/log/src/platform/node/index.ts
import yaml from "js-yaml";
import fs from "node:fs";
var loadOptions = (filepath) => {
  if (filepath) {
    try {
      const text = fs.readFileSync(filepath, "utf-8");
      if (text) {
        return yaml.load(text);
      }
    } catch (err) {
      console.warn(`Invalid log file: ${filepath}`);
    }
  }
};

// packages/common/log/src/processors/console-processor.ts
import chalk2 from "chalk";
import { inspect as inspect2 } from "node:util";
import { getPrototypeSpecificInstanceId, pickBy } from "@dxos/util";

// packages/common/log/src/processors/common.ts
var getRelativeFilename = (filename) => {
  const match = filename.match(/.+\/(packages\/.+\/.+)/);
  if (match) {
    const [, filePath] = match;
    return filePath;
  }
  return filename;
};

// packages/common/log/src/processors/console-processor.ts
var LEVEL_COLORS = {
  [LogLevel.TRACE]: "gray",
  [LogLevel.DEBUG]: "gray",
  [LogLevel.VERBOSE]: "gray",
  [LogLevel.INFO]: "white",
  [LogLevel.WARN]: "yellow",
  [LogLevel.ERROR]: "red"
};
var truncate = (text, length = 0, right = false) => {
  const str = text && length ? right ? text.slice(-length) : text.substring(0, length) : text ?? "";
  return right ? str.padStart(length, " ") : str.padEnd(length, " ");
};
var DEFAULT_FORMATTER = (config, { path, line, level, message, context, error, scope }) => {
  const column = config.options?.formatter?.column;
  const filepath = path !== void 0 && line !== void 0 ? chalk2.grey(`${path}:${line}`) : void 0;
  let instance;
  if (scope) {
    const prototype = Object.getPrototypeOf(scope);
    const id = getPrototypeSpecificInstanceId(scope);
    instance = chalk2.magentaBright(`${prototype.constructor.name}#${id}`);
  }
  const formattedTimestamp = config.options?.formatter?.timestamp ? (/* @__PURE__ */ new Date()).toISOString() : void 0;
  const formattedLevel = chalk2[LEVEL_COLORS[level]](column ? shortLevelName[level] : LogLevel[level]);
  const padding = column && filepath ? "".padStart(column - filepath.length) : void 0;
  return config.options?.formatter?.timestampFirst ? [
    formattedTimestamp,
    filepath,
    padding,
    formattedLevel,
    instance,
    message,
    context,
    error
  ] : [
    // NOTE: File path must come fist for console hyperlinks.
    // Must not truncate for terminal output.
    filepath,
    padding,
    formattedTimestamp,
    formattedLevel,
    instance,
    message,
    context,
    error
  ];
};
var SHORT_FORMATTER = (config, { path, level, message }) => {
  return [
    chalk2.grey(truncate(path, 16, true)),
    chalk2[LEVEL_COLORS[level]](shortLevelName[level]),
    message
  ];
};
var formatter = DEFAULT_FORMATTER;
var CONSOLE_PROCESSOR = (config, entry) => {
  const { level, message, meta, error } = entry;
  if (!shouldLog(entry, config.filters)) {
    return;
  }
  const parts = {
    level,
    message,
    error,
    path: void 0,
    line: void 0,
    scope: void 0,
    context: void 0
  };
  if (meta) {
    parts.path = getRelativeFilename(meta.F);
    parts.line = meta.L;
    parts.scope = meta.S;
  }
  const context = getContextFromEntry(entry);
  if (context) {
    parts.context = inspect2(pickBy(context, (value) => value !== void 0), {
      depth: config.options.depth,
      colors: true,
      maxArrayLength: 8,
      sorted: false
    });
  }
  const line = formatter(config, parts).filter(Boolean).join(" ");
  console.log(line);
};

// packages/common/log/src/processors/debug-processor.ts
import { inspect as inspect3 } from "node:util";
var DEBUG_PROCESSOR = (config, entry) => {
  console.log(inspect3(entry, false, null, true));
};

// packages/common/log/src/processors/browser-processor.ts
import { getDebugName, safariCheck } from "@dxos/util";
var getRelativeFilename2 = (filename) => {
  const match = filename.match(/.+\/(packages\/.+\/.+)/);
  if (match) {
    const [, filePath] = match;
    return filePath;
  }
  return filename;
};
var CONFIG = {
  useTestProcessor: false,
  printFileLinks: false
};
var APP_BROWSER_PROCESSOR = (config, entry) => {
  if (!shouldLog(entry, config.filters)) {
    return;
  }
  const LOG_BROWSER_PREFIX = config.prefix ?? "https://vscode.dev/github.com/dxos/dxos/blob/main/";
  const LOG_BROWSER_CSS = [];
  let link = "";
  if (entry.meta) {
    const filename = getRelativeFilename2(entry.meta.F);
    const filepath = `${LOG_BROWSER_PREFIX.replace(/\/$/, "")}/${filename}`;
    link = `${filepath}#L${entry.meta.L}`;
  }
  let args = [];
  if (entry.meta?.S) {
    const scope = entry.meta?.S;
    const scopeName = scope.name || getDebugName(scope);
    const processPrefix = entry.meta.S?.hostSessionId ? "[worker] " : "";
    args.push(`%c${processPrefix}${scopeName}`, "color:#C026D3;font-weight:bold");
  }
  args.push(entry.message);
  const context = getContextFromEntry(entry);
  if (context) {
    if (Object.keys(context).length === 1 && "error" in context) {
      args.push(context.error);
    } else {
      args.push(context);
    }
  }
  const levels2 = {
    [LogLevel.ERROR]: console.error.bind(console),
    [LogLevel.WARN]: console.warn.bind(console),
    [LogLevel.DEBUG]: console.log.bind(console)
  };
  if (CONFIG.printFileLinks || safariCheck()) {
    if (LOG_BROWSER_CSS?.length) {
      args = [
        `%c${link}
%c${args.join(" ")}`,
        ...LOG_BROWSER_CSS
      ];
    } else {
      args = [
        link + "\n",
        ...args
      ];
    }
  }
  const level = levels2[entry.level] ?? console.log.bind(console);
  if (typeof entry.meta?.C === "function") {
    entry.meta.C(level, args);
  } else {
    level(...args);
  }
};
var TEST_BROWSER_PROCESSOR = (config, entry) => {
  if (!shouldLog(entry, config.filters)) {
    return;
  }
  let path = "";
  if (entry.meta) {
    path = `${getRelativeFilename2(entry.meta.F)}:${entry.meta.L}`;
  }
  let args = [];
  const processPrefix = entry.meta?.S?.hostSessionId ? "[worker] " : "";
  args.push(`${processPrefix}${entry.message}`);
  const context = getContextFromEntry(entry);
  if (context) {
    args.push(context);
  }
  const levels2 = {
    [LogLevel.ERROR]: console.error,
    [LogLevel.WARN]: console.warn,
    [LogLevel.DEBUG]: console.log
  };
  if (CONFIG.printFileLinks) {
    args = [
      path,
      ...args
    ];
  }
  const level = levels2[entry.level] ?? console.log;
  if (typeof entry.meta?.C === "function") {
    entry.meta.C(level, args);
  } else {
    level(...args);
  }
};
var BROWSER_PROCESSOR = CONFIG.useTestProcessor ? TEST_BROWSER_PROCESSOR : APP_BROWSER_PROCESSOR;

// packages/common/log/src/processors/file-processor.ts
import { appendFileSync, mkdirSync, openSync } from "node:fs";
import { dirname } from "node:path";
import { jsonlogify } from "@dxos/util";
var EAGAIN_MAX_DURATION = 1e3;
var createFileProcessor = ({ pathOrFd, levels: levels2, filters }) => {
  let fd;
  return (config, entry) => {
    if (levels2.length > 0 && !levels2.includes(entry.level)) {
      return;
    }
    if (!shouldLog(entry, filters)) {
      return;
    }
    if (typeof pathOrFd === "number") {
      fd = pathOrFd;
    } else {
      try {
        mkdirSync(dirname(pathOrFd));
      } catch {
      }
      fd = openSync(pathOrFd, "a");
    }
    const record = {
      ...entry,
      timestamp: Date.now(),
      ...entry.meta ? {
        meta: {
          file: getRelativeFilename(entry.meta.F),
          line: entry.meta.L
        }
      } : {},
      context: jsonlogify(getContextFromEntry(entry))
    };
    let retryTS = 0;
    while (true) {
      try {
        return appendFileSync(fd, JSON.stringify(record) + "\n");
      } catch (err) {
        if (err.code !== "EAGAIN") {
          throw err;
        }
        if (retryTS === 0) {
          retryTS = performance.now();
        } else {
          if (performance.now() - retryTS > EAGAIN_MAX_DURATION) {
            console.log(`could not write after ${EAGAIN_MAX_DURATION}ms of EAGAIN failures, giving up`);
            throw err;
          }
        }
      }
    }
  };
};
var logFilePath;
var getLogFilePath = () => {
  logFilePath ??= process.env.LOG_FILE ?? (process.env.HOME ? `${process.env.HOME}/.dxlog/${(/* @__PURE__ */ new Date()).toISOString()}.log` : void 0);
  return logFilePath;
};
var FILE_PROCESSOR = createFileProcessor({
  pathOrFd: getLogFilePath(),
  levels: [
    LogLevel.ERROR,
    LogLevel.WARN,
    LogLevel.INFO,
    LogLevel.TRACE
  ]
});

// packages/common/log/src/options.ts
var processors = {
  [LogProcessorType.CONSOLE]: CONSOLE_PROCESSOR,
  [LogProcessorType.BROWSER]: BROWSER_PROCESSOR,
  [LogProcessorType.DEBUG]: DEBUG_PROCESSOR
};
var IS_BROWSER = typeof window !== "undefined" || typeof navigator !== "undefined";
var DEFAULT_PROCESSORS = [
  IS_BROWSER ? BROWSER_PROCESSOR : CONSOLE_PROCESSOR
];
var parseFilter = (filter) => {
  if (typeof filter === "number") {
    return [
      {
        level: filter
      }
    ];
  }
  const parseLogLevel = (level, defValue = LogLevel.WARN) => levels[level.toLowerCase()] ?? defValue;
  const lines = typeof filter === "string" ? filter.split(/,\s*/) : filter;
  return lines.map((filter2) => {
    const [pattern, level] = filter2.split(":");
    return level ? {
      level: parseLogLevel(level),
      pattern
    } : {
      level: parseLogLevel(pattern)
    };
  });
};
var getConfig = (options) => {
  const nodeOptions = "process" in globalThis ? {
    file: process.env.LOG_CONFIG,
    filter: process.env.LOG_FILTER,
    processor: process.env.LOG_PROCESSOR
  } : void 0;
  const mergedOptions = defaultsDeep({}, loadOptions(nodeOptions?.file), nodeOptions, options);
  return {
    options: mergedOptions,
    filters: parseFilter(mergedOptions.filter ?? LogLevel.INFO),
    captureFilters: parseFilter(mergedOptions.captureFilter ?? LogLevel.WARN),
    processors: mergedOptions.processor ? [
      processors[mergedOptions.processor]
    ] : DEFAULT_PROCESSORS,
    prefix: mergedOptions.prefix
  };
};

// packages/common/log/src/log.ts
var createLog = () => {
  const log2 = (...params) => processLog(LogLevel.DEBUG, ...params);
  log2._config = getConfig();
  Object.defineProperty(log2, "runtimeConfig", {
    get: () => log2._config
  });
  log2.addProcessor = (processor) => {
    if (DEFAULT_PROCESSORS.filter((p) => p === processor).length === 0) {
      DEFAULT_PROCESSORS.push(processor);
    }
    if (log2._config.processors.filter((p) => p === processor).length === 0) {
      log2._config.processors.push(processor);
    }
  };
  log2.config = (options) => {
    log2._config = getConfig(options);
  };
  log2.trace = (...params) => processLog(LogLevel.TRACE, ...params);
  log2.debug = (...params) => processLog(LogLevel.DEBUG, ...params);
  log2.verbose = (...params) => processLog(LogLevel.VERBOSE, ...params);
  log2.info = (...params) => processLog(LogLevel.INFO, ...params);
  log2.warn = (...params) => processLog(LogLevel.WARN, ...params);
  log2.error = (...params) => processLog(LogLevel.ERROR, ...params);
  log2.catch = (error, context, meta) => processLog(LogLevel.ERROR, error?.message ?? String(error), context, meta, error);
  log2.break = () => log2.info("\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014");
  log2.stack = (message, context, meta) => processLog(LogLevel.INFO, `${message ?? "Stack Dump"}
${getFormattedStackTrace()}`, context, meta);
  log2.method = createMethodLogDecorator(log2);
  log2.func = createFunctionLogDecorator(log2);
  const processLog = (level, message, context = {}, meta, error) => {
    log2._config.processors.forEach((processor) => processor(log2._config, {
      level,
      message,
      context,
      meta,
      error
    }));
  };
  return log2;
};
var log = globalThis.dx_log ??= createLog();
var start = Date.now();
var last = start;
var debug = (label, args) => {
  const now = Date.now();
  const err = new Error();
  console.group(`DEBUG[${label}]`, JSON.stringify({
    t: Number(now - start).toLocaleString(),
    dt: Number(now - last).toLocaleString(),
    ...args
  }));
  console.warn(err.stack);
  console.groupEnd();
  last = Date.now();
};
var getFormattedStackTrace = () => new Error().stack.split("\n").slice(3).join("\n");

// packages/common/log/src/experimental/ownership.ts
import { inspect as inspect4 } from "node:util";
var kOwnershipScope = Symbol("kOwnershipScope");
var kCurrentOwnershipScope = Symbol("kCurrentOwnershipScope");
var kDebugInfoProperties = Symbol("kDebugInfoProperties");
var OwnershipScope = class {
  constructor(constr, parent) {
    this.constr = constr;
    this.parent = parent;
  }
  getInfo() {
    if (!this.instance) {
      return {};
    }
    const props = this.constr.prototype[kDebugInfoProperties] ?? [];
    const info = {};
    for (const prop of props) {
      info[prop] = this.instance[prop];
    }
    return info;
  }
  [inspect4.custom]() {
    return {
      className: this.constr.name,
      info: this.getInfo(),
      parent: this.parent
    };
  }
};
var getCurrentOwnershipScope = (thisRef) => thisRef;
export {
  BROWSER_PROCESSOR,
  CONSOLE_PROCESSOR,
  DEBUG_PROCESSOR,
  DEFAULT_FORMATTER,
  FILE_PROCESSOR,
  LogLevel,
  LogProcessorType,
  SHORT_FORMATTER,
  createFileProcessor,
  debug,
  gatherLogInfoFromScope,
  getContextFromEntry,
  getCurrentOwnershipScope,
  getRelativeFilename,
  levels,
  log,
  logInfo,
  omit,
  parseFilter,
  pick,
  shortLevelName,
  shouldLog,
  truncate
};
//# sourceMappingURL=index.mjs.map
