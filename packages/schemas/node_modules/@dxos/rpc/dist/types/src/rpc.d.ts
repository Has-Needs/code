import { type Any, Stream, type RequestOptions } from '@dxos/codec-protobuf';
type MaybePromise<T> = Promise<T> | T;
export interface RpcPeerOptions {
    port: RpcPort;
    /**
     * Time to wait for a response to an RPC call.
     */
    timeout?: number;
    callHandler: (method: string, request: Any, options?: RequestOptions) => MaybePromise<Any>;
    streamHandler?: (method: string, request: Any, options?: RequestOptions) => Stream<Any>;
    /**
     * Do not require or send handshake messages.
     */
    noHandshake?: boolean;
    /**
     * What options get passed to the `callHandler` and `streamHandler`.
     */
    handlerRpcOptions?: RequestOptions;
}
/**
 * Interface for a transport-agnostic port to send/receive binary messages.
 */
export interface RpcPort {
    send: (msg: Uint8Array, timeout?: number) => MaybePromise<void>;
    subscribe: (cb: (msg: Uint8Array) => void) => (() => void) | void;
}
export type CloseOptions = {
    /**
     * Time to wait for the other side to confirm close.
     */
    timeout?: number;
};
/**
 * A remote procedure call peer.
 *
 * Provides a away to make RPC calls and get a response back as a promise.
 * Does not handle encoding/decoding and only works with byte buffers.
 * For type safe approach see `createRpcClient` and `createRpcServer`.
 *
 * Must be connected with another instance on the other side via `send`/`receive` methods.
 * Both sides must be opened before making any RPC calls.
 *
 * Errors inside the handler get serialized and sent to the other side.
 *
 * Inspired by JSON-RPC 2.0 https://www.jsonrpc.org/specification.
 */
export declare class RpcPeer {
    private readonly _params;
    private readonly _outgoingRequests;
    private readonly _localStreams;
    private readonly _remoteOpenTrigger;
    /**
     * Triggered when the peer starts closing.
     */
    private readonly _closingTrigger;
    /**
     * Triggered when peer receives a bye message.
     */
    private readonly _byeTrigger;
    private _nextId;
    private _state;
    private _unsubscribeFromPort;
    private _clearOpenInterval;
    constructor(params: RpcPeerOptions);
    /**
     * Open the peer. Required before making any calls.
     *
     * Will block before the other peer calls `open`.
     */
    open(): Promise<void>;
    /**
     * Close the peer.
     * Stop taking or making requests.
     * Will wait for confirmation from the other side.
     * Any responses for RPC calls made before close will be delivered.
     */
    close({ timeout }?: CloseOptions): Promise<void>;
    /**
     * Dispose the connection without waiting for the other side.
     */
    abort(): Promise<void>;
    private _abortRequests;
    private _disposeAndClose;
    /**
     * Handle incoming message. Should be called as the result of other peer's `send` callback.
     */
    private _receive;
    /**
     * Make RPC call. Will trigger a handler on the other side.
     * Peer should be open before making this call.
     */
    call(method: string, request: Any, options?: RequestOptions): Promise<Any>;
    /**
     * Make RPC call with a streaming response.
     * Will trigger a handler on the other side.
     * Peer should be open before making this call.
     */
    callStream(method: string, request: Any, options?: RequestOptions): Stream<Any>;
    private _sendMessage;
    private _callHandler;
    private _callStreamHandler;
}
export {};
//# sourceMappingURL=rpc.d.ts.map