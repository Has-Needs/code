{
  "version": 3,
  "sources": ["../../../src/rpc.ts", "../../../src/errors.ts", "../../../src/service.ts", "../../../src/testing.ts", "../../../src/trace.ts"],
  "sourcesContent": ["//\n// Copyright 2021 DXOS.org\n//\n\nimport { asyncTimeout, synchronized, Trigger } from '@dxos/async';\nimport { type Any, Stream, type RequestOptions, type ProtoCodec } from '@dxos/codec-protobuf';\nimport { StackTrace } from '@dxos/debug';\nimport { invariant } from '@dxos/invariant';\nimport { log } from '@dxos/log';\nimport { encodeError, RpcClosedError, RpcNotOpenError } from '@dxos/protocols';\nimport { schema } from '@dxos/protocols/proto';\nimport { type Request, type Response, type RpcMessage } from '@dxos/protocols/proto/dxos/rpc';\nimport { exponentialBackoffInterval } from '@dxos/util';\n\nimport { decodeRpcError } from './errors';\n\nconst DEFAULT_TIMEOUT = 3_000;\nconst BYE_SEND_TIMEOUT = 2_000;\n\nconst DEBUG_CALLS = true;\n\ntype MaybePromise<T> = Promise<T> | T;\n\nexport interface RpcPeerOptions {\n  port: RpcPort;\n\n  /**\n   * Time to wait for a response to an RPC call.\n   */\n  timeout?: number;\n\n  callHandler: (method: string, request: Any, options?: RequestOptions) => MaybePromise<Any>;\n  streamHandler?: (method: string, request: Any, options?: RequestOptions) => Stream<Any>;\n\n  /**\n   * Do not require or send handshake messages.\n   */\n  noHandshake?: boolean;\n\n  /**\n   * What options get passed to the `callHandler` and `streamHandler`.\n   */\n  handlerRpcOptions?: RequestOptions;\n}\n\n/**\n * Interface for a transport-agnostic port to send/receive binary messages.\n */\nexport interface RpcPort {\n  send: (msg: Uint8Array, timeout?: number) => MaybePromise<void>;\n  subscribe: (cb: (msg: Uint8Array) => void) => (() => void) | void;\n}\n\nconst CLOSE_TIMEOUT = 3_000;\n\nexport type CloseOptions = {\n  /**\n   * Time to wait for the other side to confirm close.\n   */\n  timeout?: number;\n};\n\nclass PendingRpcRequest {\n  constructor(\n    public readonly resolve: (response: Response) => void,\n    public readonly reject: (error?: Error) => void,\n    public readonly stream: boolean,\n  ) {}\n}\n\n// NOTE: Lazy so that code that doesn't use indexing doesn't need to load the codec (breaks in workerd).\nlet RpcMessageCodec!: ProtoCodec<RpcMessage>;\nconst getRpcMessageCodec = () => (RpcMessageCodec ??= schema.getCodecForType('dxos.rpc.RpcMessage'));\n\nenum RpcState {\n  INITIAL = 'INITIAL',\n\n  OPENING = 'OPENING',\n\n  OPENED = 'OPENED',\n\n  /**\n   * Bye message sent, waiting for the other side to close.\n   * Not possible to send requests.\n   * All pending requests will be rejected.\n   */\n  CLOSING = 'CLOSING',\n\n  /**\n   * Connection fully closed.\n   * The underlying transport can be disposed.\n   */\n  CLOSED = 'CLOSED',\n}\n\n/**\n * A remote procedure call peer.\n *\n * Provides a away to make RPC calls and get a response back as a promise.\n * Does not handle encoding/decoding and only works with byte buffers.\n * For type safe approach see `createRpcClient` and `createRpcServer`.\n *\n * Must be connected with another instance on the other side via `send`/`receive` methods.\n * Both sides must be opened before making any RPC calls.\n *\n * Errors inside the handler get serialized and sent to the other side.\n *\n * Inspired by JSON-RPC 2.0 https://www.jsonrpc.org/specification.\n */\nexport class RpcPeer {\n  private readonly _params: RpcPeerOptions;\n\n  private readonly _outgoingRequests = new Map<number, PendingRpcRequest>();\n  private readonly _localStreams = new Map<number, Stream<any>>();\n  private readonly _remoteOpenTrigger = new Trigger();\n\n  /**\n   * Triggered when the peer starts closing.\n   */\n  private readonly _closingTrigger = new Trigger();\n\n  /**\n   * Triggered when peer receives a bye message.\n   */\n  private readonly _byeTrigger = new Trigger();\n\n  private _nextId = 0;\n  private _state: RpcState = RpcState.INITIAL;\n  private _unsubscribeFromPort: (() => void) | undefined = undefined;\n  private _clearOpenInterval: (() => void) | undefined = undefined;\n\n  constructor(params: RpcPeerOptions) {\n    this._params = {\n      timeout: undefined,\n      streamHandler: undefined,\n      noHandshake: false,\n      ...params,\n    };\n  }\n\n  /**\n   * Open the peer. Required before making any calls.\n   *\n   * Will block before the other peer calls `open`.\n   */\n  @synchronized\n  async open(): Promise<void> {\n    if (this._state !== RpcState.INITIAL) {\n      return;\n    }\n\n    this._unsubscribeFromPort = this._params.port.subscribe(async (msg) => {\n      try {\n        await this._receive(msg);\n      } catch (err: any) {\n        log.catch(err);\n      }\n    }) as any;\n\n    this._state = RpcState.OPENING;\n\n    if (this._params.noHandshake) {\n      this._state = RpcState.OPENED;\n      this._remoteOpenTrigger.wake();\n      return;\n    }\n\n    log('sending open message', { state: this._state });\n    await this._sendMessage({ open: true });\n\n    if (this._state !== RpcState.OPENING) {\n      return;\n    }\n\n    // Retry sending.\n    this._clearOpenInterval = exponentialBackoffInterval(() => {\n      void this._sendMessage({ open: true }).catch((err) => log.warn(err));\n    }, 50);\n\n    await Promise.race([this._remoteOpenTrigger.wait(), this._closingTrigger.wait()]);\n\n    this._clearOpenInterval?.();\n\n    if ((this._state as RpcState) !== RpcState.OPENED) {\n      // Closed while opening.\n      return; // TODO(dmaretskyi): Throw error?\n    }\n\n    // TODO(burdon): This seems error prone.\n    // Send an \"open\" message in case the other peer has missed our first \"open\" message and is still waiting.\n    log('resending open message', { state: this._state });\n    await this._sendMessage({ openAck: true });\n  }\n\n  /**\n   * Close the peer.\n   * Stop taking or making requests.\n   * Will wait for confirmation from the other side.\n   * Any responses for RPC calls made before close will be delivered.\n   */\n  async close({ timeout = CLOSE_TIMEOUT }: CloseOptions = {}): Promise<void> {\n    if (this._state === RpcState.CLOSED) {\n      return;\n    }\n\n    this._abortRequests();\n\n    if (this._state === RpcState.OPENED && !this._params.noHandshake) {\n      try {\n        this._state = RpcState.CLOSING;\n        await this._sendMessage({ bye: {} }, BYE_SEND_TIMEOUT);\n      } catch (err: any) {\n        log('error closing peer, sending bye', { err });\n      }\n      try {\n        log('closing waiting on bye');\n        await this._byeTrigger.wait({ timeout });\n      } catch (err: any) {\n        log('error closing peer', { err });\n        return;\n      }\n    }\n\n    this._disposeAndClose();\n  }\n\n  /**\n   * Dispose the connection without waiting for the other side.\n   */\n  async abort(): Promise<void> {\n    if (this._state === RpcState.CLOSED) {\n      return;\n    }\n\n    this._abortRequests();\n    this._disposeAndClose();\n  }\n\n  private _abortRequests(): void {\n    // Abort open\n    this._clearOpenInterval?.();\n    this._closingTrigger.wake();\n\n    // Abort pending requests\n    for (const req of this._outgoingRequests.values()) {\n      req.reject(new RpcClosedError());\n    }\n    this._outgoingRequests.clear();\n  }\n\n  private _disposeAndClose(): void {\n    this._unsubscribeFromPort?.();\n    this._unsubscribeFromPort = undefined;\n    this._clearOpenInterval?.();\n    this._state = RpcState.CLOSED;\n  }\n\n  /**\n   * Handle incoming message. Should be called as the result of other peer's `send` callback.\n   */\n  private async _receive(msg: Uint8Array): Promise<void> {\n    const decoded = getRpcMessageCodec().decode(msg, { preserveAny: true });\n    DEBUG_CALLS && log('received message', { type: Object.keys(decoded)[0] });\n\n    if (decoded.request) {\n      if (this._state !== RpcState.OPENED && this._state !== RpcState.OPENING) {\n        log('received request while closed');\n        await this._sendMessage({\n          response: {\n            id: decoded.request.id,\n            error: encodeError(new RpcClosedError()),\n          },\n        });\n        return;\n      }\n\n      const req = decoded.request;\n      if (req.stream) {\n        log('stream request', { method: req.method });\n        this._callStreamHandler(req, (response) => {\n          log('sending stream response', {\n            method: req.method,\n            response: response.payload?.type_url,\n            error: response.error,\n            close: response.close,\n          });\n\n          void this._sendMessage({ response }).catch((err) => {\n            log.warn('failed during close', err);\n          });\n        });\n      } else {\n        DEBUG_CALLS && log('requesting...', { method: req.method });\n        const response = await this._callHandler(req);\n        DEBUG_CALLS &&\n          log('sending response', {\n            method: req.method,\n            response: response.payload?.type_url,\n            error: response.error,\n          });\n        await this._sendMessage({ response });\n      }\n    } else if (decoded.response) {\n      if (this._state !== RpcState.OPENED) {\n        log('received response while closed');\n        return; // Ignore when not open.\n      }\n\n      const responseId = decoded.response.id;\n      invariant(typeof responseId === 'number');\n      if (!this._outgoingRequests.has(responseId)) {\n        log('received response with invalid id', { responseId });\n        return; // Ignore requests with incorrect id.\n      }\n\n      const item = this._outgoingRequests.get(responseId)!;\n      // Delete the request record if no more responses are expected.\n      if (!item.stream) {\n        this._outgoingRequests.delete(responseId);\n      }\n\n      DEBUG_CALLS && log('response', { type_url: decoded.response.payload?.type_url });\n      item.resolve(decoded.response);\n    } else if (decoded.open) {\n      log('received open message', { state: this._state });\n      if (this._params.noHandshake) {\n        return;\n      }\n\n      await this._sendMessage({ openAck: true });\n    } else if (decoded.openAck) {\n      log('received openAck message', { state: this._state });\n      if (this._params.noHandshake) {\n        return;\n      }\n\n      this._state = RpcState.OPENED;\n      this._remoteOpenTrigger.wake();\n    } else if (decoded.streamClose) {\n      if (this._state !== RpcState.OPENED) {\n        log('received stream close while closed');\n        return; // Ignore when not open.\n      }\n\n      log('received stream close', { id: decoded.streamClose.id });\n      invariant(typeof decoded.streamClose.id === 'number');\n      const stream = this._localStreams.get(decoded.streamClose.id);\n      if (!stream) {\n        log('no local stream', { id: decoded.streamClose.id });\n        return; // Ignore requests with incorrect id.\n      }\n\n      this._localStreams.delete(decoded.streamClose.id);\n      await stream.close();\n    } else if (decoded.bye) {\n      this._byeTrigger.wake();\n      // If we haven't already started closing, close now.\n      if (this._state !== RpcState.CLOSING && this._state !== RpcState.CLOSED) {\n        log('replying to bye');\n        this._state = RpcState.CLOSING;\n        await this._sendMessage({ bye: {} });\n\n        this._abortRequests();\n        this._disposeAndClose();\n      }\n    } else {\n      log.error('received malformed message', { msg });\n      throw new Error('Malformed message.');\n    }\n  }\n\n  /**\n   * Make RPC call. Will trigger a handler on the other side.\n   * Peer should be open before making this call.\n   */\n  async call(method: string, request: Any, options?: RequestOptions): Promise<Any> {\n    DEBUG_CALLS && log('calling...', { method });\n    throwIfNotOpen(this._state);\n\n    let response: Response;\n    try {\n      // Set-up response listener.\n      const id = this._nextId++;\n      const responseReceived = new Promise<Response>((resolve, reject) => {\n        this._outgoingRequests.set(id, new PendingRpcRequest(resolve, reject, false));\n      });\n\n      // Send request call.\n      const sending = this._sendMessage({\n        request: {\n          id,\n          method,\n          payload: request,\n          stream: false,\n        },\n      });\n\n      // Wait until send completes or throws an error (or response throws a timeout), the resume waiting.\n      const timeout = options?.timeout ?? this._params.timeout;\n      const waiting =\n        timeout === 0 ? responseReceived : asyncTimeout<any>(responseReceived, timeout ?? DEFAULT_TIMEOUT);\n\n      await Promise.race([sending, waiting]);\n      response = await waiting;\n      invariant(response.id === id);\n    } catch (err) {\n      if (err instanceof RpcClosedError) {\n        // Rethrow the error here to have the correct stack-trace.\n        const error = new RpcClosedError();\n        error.stack += `\\n\\n info: RPC client was closed at:\\n${err.stack?.split('\\n').slice(1).join('\\n')}`;\n        throw error;\n      }\n\n      throw err;\n    }\n\n    if (response.payload) {\n      return response.payload;\n    } else if (response.error) {\n      throw decodeRpcError(response.error, method);\n    } else {\n      throw new Error('Malformed response.');\n    }\n  }\n\n  /**\n   * Make RPC call with a streaming response.\n   * Will trigger a handler on the other side.\n   * Peer should be open before making this call.\n   */\n  callStream(method: string, request: Any, options?: RequestOptions): Stream<Any> {\n    throwIfNotOpen(this._state);\n    const id = this._nextId++;\n\n    return new Stream(({ ready, next, close }) => {\n      const onResponse = (response: Response) => {\n        if (response.streamReady) {\n          ready();\n        } else if (response.close) {\n          close();\n        } else if (response.error) {\n          // TODO(dmaretskyi): Stack trace might be lost because the stream producer function is called asynchronously.\n          close(decodeRpcError(response.error, method));\n        } else if (response.payload) {\n          next(response.payload);\n        } else {\n          throw new Error('Malformed response.');\n        }\n      };\n\n      const stack = new StackTrace();\n      const closeStream = (err?: Error) => {\n        if (!err) {\n          close();\n        } else {\n          err.stack += `\\n\\nError happened in the stream at:\\n${stack.getStack()}`;\n          close(err);\n        }\n      };\n\n      this._outgoingRequests.set(id, new PendingRpcRequest(onResponse, closeStream, true));\n\n      this._sendMessage({\n        request: {\n          id,\n          method,\n          payload: request,\n          stream: true,\n        },\n      }).catch((err) => {\n        close(err);\n      });\n\n      return () => {\n        this._sendMessage({\n          streamClose: { id },\n        }).catch((err) => {\n          log.catch(err);\n        });\n        this._outgoingRequests.delete(id);\n      };\n    });\n  }\n\n  private async _sendMessage(message: RpcMessage, timeout?: number): Promise<void> {\n    DEBUG_CALLS && log('sending message', { type: Object.keys(message)[0] });\n    await this._params.port.send(getRpcMessageCodec().encode(message, { preserveAny: true }), timeout);\n  }\n\n  private async _callHandler(req: Request): Promise<Response> {\n    try {\n      invariant(typeof req.id === 'number');\n      invariant(req.payload);\n      invariant(req.method);\n\n      const response = await this._params.callHandler(req.method, req.payload, this._params.handlerRpcOptions);\n      return {\n        id: req.id,\n        payload: response,\n      };\n    } catch (err) {\n      return {\n        id: req.id,\n        error: encodeError(err),\n      };\n    }\n  }\n\n  private _callStreamHandler(req: Request, callback: (response: Response) => void): void {\n    try {\n      invariant(this._params.streamHandler, 'Requests with streaming responses are not supported.');\n      invariant(typeof req.id === 'number');\n      invariant(req.payload);\n      invariant(req.method);\n\n      const responseStream = this._params.streamHandler(req.method, req.payload, this._params.handlerRpcOptions);\n      responseStream.onReady(() => {\n        callback({\n          id: req.id,\n          streamReady: true,\n        });\n      });\n\n      responseStream.subscribe(\n        (msg) => {\n          callback({\n            id: req.id,\n            payload: msg,\n          });\n        },\n        (error) => {\n          if (error) {\n            callback({\n              id: req.id,\n              error: encodeError(error),\n            });\n          } else {\n            callback({\n              id: req.id,\n              close: true,\n            });\n          }\n        },\n      );\n\n      this._localStreams.set(req.id, responseStream);\n    } catch (err: any) {\n      callback({\n        id: req.id,\n        error: encodeError(err),\n      });\n    }\n  }\n}\n\nconst throwIfNotOpen = (state: RpcState) => {\n  switch (state) {\n    case RpcState.OPENED: {\n      return;\n    }\n    case RpcState.INITIAL: {\n      throw new RpcNotOpenError();\n    }\n    case RpcState.CLOSED: {\n      throw new RpcClosedError();\n    }\n  }\n};\n", "//\n// Copyright 2021 DXOS.org\n//\n\nimport { StackTrace } from '@dxos/debug';\nimport { decodeError } from '@dxos/protocols';\nimport { type Error as ErrorResponse } from '@dxos/protocols/proto/dxos/error';\n\nexport const decodeRpcError = (err: ErrorResponse, rpcMethod: string): Error =>\n  decodeError(err, {\n    appendStack: `\\n    at RPC ${rpcMethod} \\n` + new StackTrace().getStack(1),\n  });\n", "//\n// Copyright 2021 DXOS.org\n//\n\nimport {\n  type EncodingOptions,\n  type ServiceDescriptor,\n  type ServiceHandler,\n  type ServiceProvider,\n} from '@dxos/codec-protobuf';\nimport { invariant } from '@dxos/invariant';\n\nimport { RpcPeer, type RpcPeerOptions } from './rpc';\n\n/**\n * Map of service definitions.\n */\n// TODO(burdon): Rename ServiceMap.\nexport type ServiceBundle<Services> = { [Key in keyof Services]: ServiceDescriptor<Services[Key]> };\n\nexport type ServiceHandlers<Services> = { [ServiceName in keyof Services]: ServiceProvider<Services[ServiceName]> };\n\nexport type ServiceTypesOf<Bundle extends ServiceBundle<any>> =\n  Bundle extends ServiceBundle<infer Services> ? Services : never;\n\n/**\n * Groups multiple services together to be served by a single RPC peer.\n */\nexport const createServiceBundle = <Service>(services: ServiceBundle<Service>): ServiceBundle<Service> => services;\n\n/**\n * Type-safe RPC peer.\n */\nexport class ProtoRpcPeer<Service> {\n  constructor(\n    public readonly rpc: Service,\n    private readonly _peer: RpcPeer,\n  ) {}\n\n  async open(): Promise<void> {\n    await this._peer.open();\n  }\n\n  async close(): Promise<void> {\n    await this._peer.close();\n  }\n\n  async abort(): Promise<void> {\n    await this._peer.abort();\n  }\n}\n\nexport interface ProtoRpcPeerOptions<Client, Server> extends Omit<RpcPeerOptions, 'callHandler' | 'streamHandler'> {\n  /**\n   * Services that are expected to be implemented by the counter-space.\n   */\n  // TODO(burdon): Rename proxy.\n  requested?: ServiceBundle<Client>;\n\n  /**\n   * Services exposed to the counter-space.\n   */\n  // TODO(burdon): Rename service.\n  exposed?: ServiceBundle<Server>;\n\n  /**\n   * Handlers for the exposed services\n   */\n  handlers?: ServiceHandlers<Server>;\n\n  /**\n   * Encoding options passed to the underlying proto codec.\n   */\n  encodingOptions?: EncodingOptions;\n}\n\n/**\n * Create type-safe RPC peer from a service bundle.\n * Can both handle and issue requests.\n */\n// TODO(burdon): Currently assumes that the proto service name is unique.\n//  Support multiple instances services definitions (e.g., halo/space invitations).\nexport const createProtoRpcPeer = <Client = {}, Server = {}>({\n  requested,\n  exposed,\n  handlers,\n  encodingOptions,\n  ...rest\n}: ProtoRpcPeerOptions<Client, Server>): ProtoRpcPeer<Client> => {\n  // Create map of RPCs.\n  const exposedRpcs: Record<string, ServiceHandler<any>> = {};\n  if (exposed) {\n    invariant(handlers);\n    for (const serviceName of Object.keys(exposed) as (keyof Server)[]) {\n      // Get full service name with the package name without '.' at the beginning.\n      const serviceFqn = exposed[serviceName].serviceProto.fullName.slice(1);\n      const serviceProvider = handlers[serviceName];\n      exposedRpcs[serviceFqn] = exposed[serviceName].createServer(serviceProvider, encodingOptions);\n    }\n  }\n\n  // Create peer.\n  const peer = new RpcPeer({\n    ...rest,\n\n    callHandler: (method, request, options) => {\n      const [serviceName, methodName] = parseMethodName(method);\n      if (!exposedRpcs[serviceName]) {\n        throw new Error(`Service not supported: ${serviceName}`);\n      }\n\n      return exposedRpcs[serviceName].call(methodName, request, options);\n    },\n\n    streamHandler: (method, request, options) => {\n      const [serviceName, methodName] = parseMethodName(method);\n      if (!exposedRpcs[serviceName]) {\n        throw new Error(`Service not supported: ${serviceName}`);\n      }\n\n      return exposedRpcs[serviceName].callStream(methodName, request, options);\n    },\n  });\n\n  const requestedRpcs: Client = {} as Client;\n  if (requested) {\n    for (const serviceName of Object.keys(requested) as (keyof Client)[]) {\n      // Get full service name with the package name without '.' at the beginning.\n      const serviceFqn = requested[serviceName].serviceProto.fullName.slice(1);\n\n      requestedRpcs[serviceName] = requested[serviceName].createClient(\n        {\n          call: (method, req, options) => peer.call(`${serviceFqn}.${method}`, req, options),\n          callStream: (method, req, options) => peer.callStream(`${serviceFqn}.${method}`, req, options),\n        },\n        encodingOptions,\n      );\n    }\n  }\n\n  return new ProtoRpcPeer(requestedRpcs, peer);\n};\n\nexport const parseMethodName = (method: string): [serviceName: string, methodName: string] => {\n  const separator = method.lastIndexOf('.');\n  const serviceName = method.slice(0, separator);\n  const methodName = method.slice(separator + 1);\n  if (serviceName.length === 0 || methodName.length === 0) {\n    throw new Error(`Invalid method: ${method}`);\n  }\n\n  return [serviceName, methodName];\n};\n\n//\n// TODO(burdon): Remove deprecated (only bot factory).\n//\n\n/**\n * Create a type-safe RPC client.\n * @deprecated Use createProtoRpcPeer instead.\n */\nexport const createRpcClient = <S>(\n  serviceDef: ServiceDescriptor<S>,\n  options: Omit<RpcPeerOptions, 'callHandler'>,\n): ProtoRpcPeer<S> => {\n  const peer = new RpcPeer({\n    ...options,\n    callHandler: () => {\n      throw new Error('Requests to client are not supported.');\n    },\n  });\n\n  const client = serviceDef.createClient({\n    call: peer.call.bind(peer),\n    callStream: peer.callStream.bind(peer),\n  });\n\n  return new ProtoRpcPeer(client, peer);\n};\n\n/**\n * @deprecated\n */\nexport interface RpcServerOptions<S> extends Omit<RpcPeerOptions, 'callHandler'> {\n  service: ServiceDescriptor<S>;\n  handlers: S;\n}\n\n/**\n * Create a type-safe RPC server.\n * @deprecated Use createProtoRpcPeer instead.\n */\nexport const createRpcServer = <S>({ service, handlers, ...rest }: RpcServerOptions<S>): RpcPeer => {\n  const server = service.createServer(handlers);\n  return new RpcPeer({\n    ...rest,\n    callHandler: server.call.bind(server),\n    streamHandler: server.callStream.bind(server),\n  });\n};\n\n/**\n * Create type-safe RPC client from a service bundle.\n * @deprecated Use createProtoRpcPeer instead.\n */\nexport const createBundledRpcClient = <S>(\n  descriptors: ServiceBundle<S>,\n  options: Omit<RpcPeerOptions, 'callHandler' | 'streamHandler'>,\n): ProtoRpcPeer<S> => {\n  return createProtoRpcPeer({\n    requested: descriptors,\n    ...options,\n  });\n};\n\n/**\n * @deprecated\n */\nexport interface RpcBundledServerOptions<S> extends Omit<RpcPeerOptions, 'callHandler'> {\n  services: ServiceBundle<S>;\n  handlers: S;\n}\n\n/**\n * Create type-safe RPC server from a service bundle.\n * @deprecated Use createProtoRpcPeer instead.\n */\n// TODO(burdon): Support late-binding via providers.\nexport const createBundledRpcServer = <S>({ services, handlers, ...rest }: RpcBundledServerOptions<S>): RpcPeer => {\n  const rpc: Record<string, ServiceHandler<any>> = {};\n  for (const serviceName of Object.keys(services) as (keyof S)[]) {\n    // Get full service name with the package name without '.' at the beginning.\n    const serviceFqn = services[serviceName].serviceProto.fullName.slice(1);\n    rpc[serviceFqn] = services[serviceName].createServer(handlers[serviceName] as any);\n  }\n\n  return new RpcPeer({\n    ...rest,\n\n    callHandler: (method, request) => {\n      const [serviceName, methodName] = parseMethodName(method);\n      if (!rpc[serviceName]) {\n        throw new Error(`Service not supported: ${serviceName}`);\n      }\n\n      return rpc[serviceName].call(methodName, request);\n    },\n\n    streamHandler: (method, request) => {\n      const [serviceName, methodName] = parseMethodName(method);\n      if (!rpc[serviceName]) {\n        throw new Error(`Service not supported: ${serviceName}`);\n      }\n\n      return rpc[serviceName].callStream(methodName, request);\n    },\n  });\n};\n", "//\n// Copyright 2021 DXOS.org\n//\n\nimport { isNode } from '@dxos/util';\n\nimport { type RpcPort } from './rpc';\n\nexport type CreateLinkedPortsOptions = {\n  delay?: number;\n};\n\n/**\n * Create bi-directionally linked ports.\n */\nexport const createLinkedPorts = ({ delay }: CreateLinkedPortsOptions = {}): [RpcPort, RpcPort] => {\n  let port1Received: RpcPort['send'] | undefined;\n  let port2Received: RpcPort['send'] | undefined;\n\n  const send = (handler: RpcPort['send'] | undefined, msg: Uint8Array) => {\n    if (delay) {\n      setTimeout(() => handler?.(msg), delay);\n    } else {\n      void handler?.(msg);\n    }\n  };\n\n  const port1: RpcPort = {\n    send: (msg) => send(port2Received, msg),\n    subscribe: (cb) => {\n      port1Received = cb;\n    },\n  };\n\n  const port2: RpcPort = {\n    send: (msg) => send(port1Received, msg),\n    subscribe: (cb) => {\n      port2Received = cb;\n    },\n  };\n\n  return [port1, port2];\n};\n\nexport const encodeMessage = (msg: string): Uint8Array => (isNode() ? Buffer.from(msg) : new TextEncoder().encode(msg));\n", "//\n// Copyright 2021 DXOS.org\n//\n\nimport { Event } from '@dxos/async';\nimport { MessageTrace } from '@dxos/protocols/proto/dxos/rpc';\n\nimport { type RpcPort } from './rpc';\n\nexport class PortTracer {\n  readonly message = new Event<MessageTrace>();\n\n  private readonly _port: RpcPort;\n\n  constructor(private readonly _wrappedPort: RpcPort) {\n    this._port = {\n      send: (msg: Uint8Array) => {\n        this.message.emit({\n          direction: MessageTrace.Direction.OUTGOING,\n          data: msg,\n        });\n\n        return this._wrappedPort.send(msg);\n      },\n      subscribe: (cb: (msg: Uint8Array) => void) => {\n        return this._wrappedPort.subscribe((msg) => {\n          this.message.emit({\n            direction: MessageTrace.Direction.INCOMING,\n            data: msg,\n          });\n          cb(msg);\n        });\n      },\n    };\n  }\n\n  public get port() {\n    return this._port;\n  }\n}\n"],
  "mappings": "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",
  "names": ["asyncTimeout", "synchronized", "Trigger", "Stream", "StackTrace", "invariant", "log", "encodeError", "RpcClosedError", "RpcNotOpenError", "schema", "exponentialBackoffInterval", "StackTrace", "decodeError", "decodeRpcError", "err", "rpcMethod", "decodeError", "appendStack", "StackTrace", "getStack", "DEFAULT_TIMEOUT", "BYE_SEND_TIMEOUT", "DEBUG_CALLS", "CLOSE_TIMEOUT", "PendingRpcRequest", "resolve", "reject", "stream", "RpcMessageCodec", "getRpcMessageCodec", "schema", "getCodecForType", "RpcPeer", "params", "_outgoingRequests", "Map", "_localStreams", "_remoteOpenTrigger", "Trigger", "_closingTrigger", "_byeTrigger", "_nextId", "_state", "_unsubscribeFromPort", "undefined", "_clearOpenInterval", "_params", "timeout", "streamHandler", "noHandshake", "open", "port", "subscribe", "msg", "_receive", "err", "log", "catch", "wake", "state", "_sendMessage", "exponentialBackoffInterval", "warn", "Promise", "race", "wait", "openAck", "close", "CLOSE_TIMEOUT", "_abortRequests", "bye", "BYE_SEND_TIMEOUT", "_disposeAndClose", "abort", "req", "values", "reject", "RpcClosedError", "clear", "decoded", "getRpcMessageCodec", "decode", "preserveAny", "DEBUG_CALLS", "type", "Object", "keys", "request", "response", "id", "error", "encodeError", "stream", "method", "_callStreamHandler", "payload", "type_url", "_callHandler", "responseId", "invariant", "has", "item", "get", "delete", "resolve", "streamClose", "Error", "call", "options", "throwIfNotOpen", "responseReceived", "set", "PendingRpcRequest", "sending", "waiting", "asyncTimeout", "DEFAULT_TIMEOUT", "stack", "split", "slice", "join", "decodeRpcError", "callStream", "Stream", "ready", "next", "onResponse", "streamReady", "StackTrace", "closeStream", "getStack", "message", "send", "encode", "callHandler", "handlerRpcOptions", "callback", "responseStream", "onReady", "RpcNotOpenError", "invariant", "createServiceBundle", "services", "ProtoRpcPeer", "rpc", "_peer", "open", "close", "abort", "createProtoRpcPeer", "requested", "exposed", "handlers", "encodingOptions", "rest", "exposedRpcs", "invariant", "serviceName", "Object", "keys", "serviceFqn", "serviceProto", "fullName", "slice", "serviceProvider", "createServer", "peer", "RpcPeer", "callHandler", "method", "request", "options", "methodName", "parseMethodName", "Error", "call", "streamHandler", "callStream", "requestedRpcs", "createClient", "req", "separator", "lastIndexOf", "length", "createRpcClient", "serviceDef", "client", "bind", "createRpcServer", "service", "server", "createBundledRpcClient", "descriptors", "createBundledRpcServer", "isNode", "createLinkedPorts", "delay", "port1Received", "port2Received", "send", "handler", "msg", "setTimeout", "port1", "subscribe", "cb", "port2", "encodeMessage", "isNode", "Buffer", "from", "TextEncoder", "encode", "Event", "MessageTrace", "PortTracer", "_wrappedPort", "message", "Event", "_port", "send", "msg", "emit", "direction", "MessageTrace", "Direction", "OUTGOING", "data", "subscribe", "cb", "INCOMING", "port"]
}
