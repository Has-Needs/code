import { Schema } from 'effect';
import { JsonPath, type JsonProp } from '@dxos/effect';
/**
 * Go under the `annotations` property.
 */
export declare const JsonSchemaEchoAnnotations: Schema.mutable<Schema.Struct<{
    /**
     * Label for this schema.
     * Mapped from {@link LabelAnnotationId}.
     */
    labelProp: Schema.optional<Schema.Union<[Schema.Schema<JsonPath, JsonPath, never>, Schema.Array$<Schema.Schema<JsonPath, JsonPath, never>>]>>;
    /**
     * Generator function for this schema.
     * Mapped from {@link GeneratorAnnotationId}.
     */
    generator: Schema.optional<Schema.Union<[typeof Schema.String, Schema.Tuple2<typeof Schema.String, typeof Schema.Number>]>>;
    /**
     * {@link PropertyMeta} annotations get serialized here.
     */
    meta: Schema.optional<Schema.mutable<Schema.Record$<typeof Schema.String, typeof Schema.Any>>>;
    /**
     * @deprecated
     */
    type: Schema.optional<Schema.mutable<Schema.Struct<{
        typename: typeof Schema.String;
        version: typeof Schema.String;
        schemaId: Schema.optional<typeof Schema.String>;
    }>>>;
    /**
     * @deprecated Superseded by `meta`.
     */
    annotations: Schema.optional<Schema.mutable<Schema.Record$<typeof Schema.String, typeof Schema.Any>>>;
}>>;
export type JsonSchemaEchoAnnotations = Schema.Schema.Type<typeof JsonSchemaEchoAnnotations>;
/**
 * Describes a schema for the JSON-schema objects stored in ECHO.
 * Contains extensions for ECHO (e.g., references).
 * Ref: https://json-schema.org/draft-07/schema
 */
declare const _JsonSchemaType: Schema.Struct<{
    /**
     * Identifier for this schema.
     * This schema might be referenced by $ref clause in other schemas.
     */
    $id: Schema.optional<typeof Schema.String>;
    /**
     * Schema of this schema.
     * Set to "https://json-schema.org/draft-07/schema".
     */
    $schema: Schema.optional<typeof Schema.String>;
    /**
     * Reference to another schema.
     */
    $ref: Schema.optional<typeof Schema.String>;
    /**
     * Comments are ignored when interpreting the schema.
     */
    $comment: Schema.optional<typeof Schema.String>;
    /**
     * Defines whether this schema is an object schema or a relation schema.
     */
    entityKind: Schema.optional<Schema.Enums<typeof import("..").EntityKind>>;
    /**
     * Typename of this schema.
     * Only on schema representing an ECHO object.
     *
     * @example 'example.com/type/MyType'
     */
    typename: Schema.optional<typeof Schema.String>;
    /**
     * Version of this schema.
     * Custom dialect for ECHO.
     */
    version: Schema.optional<typeof Schema.String>;
    /**
     * Target of this relation.
     * Only for relation schemas.
     * The referenced schema must be an object schema.
     */
    relationTarget: Schema.optional<Schema.suspend<JsonSchemaType, JsonSchemaType, never>>;
    /**
     * Source of this relation.
     * Only for relation schemas.
     * The referenced schema must be an object schema.
     */
    relationSource: Schema.optional<Schema.suspend<JsonSchemaType, JsonSchemaType, never>>;
    /**
     * Title of this schema.
     */
    title: Schema.optional<typeof Schema.String>;
    /**
     * Description of this schema.
     */
    description: Schema.optional<typeof Schema.String>;
    /**
     * Whether this schema is read-only.
     */
    readOnly: Schema.optional<typeof Schema.Boolean>;
    /**
     * Whether this schema is write-only.
     */
    writeOnly: Schema.optional<typeof Schema.Boolean>;
    /**
     * Examples of instances of this schema.
     */
    examples: Schema.optional<Schema.Array$<typeof Schema.Any>>;
    /**
     * Default value for this schema.
     */
    default: Schema.optional<typeof Schema.Any>;
    /**
     * This schema only matches values that are equal to this value.
     */
    const: Schema.optional<typeof Schema.Any>;
    /**
     * This schema only matches one of the values in this array.
     */
    enum: Schema.optional<Schema.Array$<typeof Schema.Any>>;
    /**
     * Base type of the schema.
     */
    type: Schema.optional<Schema.Union<[Schema.Literal<["array", "boolean", "integer", "null", "number", "object", "string"]>, Schema.Array$<Schema.Literal<["array", "boolean", "integer", "null", "number", "object", "string"]>>]>>;
    multipleOf: Schema.optional<Schema.filter<typeof Schema.Number>>;
    maximum: Schema.optional<typeof Schema.Number>;
    exclusiveMaximum: Schema.optional<typeof Schema.Number>;
    minimum: Schema.optional<typeof Schema.Number>;
    exclusiveMinimum: Schema.optional<typeof Schema.Number>;
    maxLength: Schema.optional<Schema.filter<typeof Schema.Number>>;
    /**
     * Regex pattern for strings.
     */
    pattern: Schema.optional<typeof Schema.String>;
    /**
     * Serialized from {@link FormatAnnotationId}.
     */
    format: Schema.optional<typeof Schema.String>;
    minLength: Schema.optional<Schema.filter<typeof Schema.Number>>;
    items: Schema.optional<Schema.Union<[Schema.suspend<JsonSchemaType, JsonSchemaType, never>, Schema.Array$<Schema.suspend<JsonSchemaType, JsonSchemaType, never>>]>>;
    additionalItems: Schema.optional<Schema.Union<[Schema.suspend<JsonSchemaType, JsonSchemaType, never>, typeof Schema.Boolean]>>;
    maxItems: Schema.optional<Schema.filter<typeof Schema.Number>>;
    minItems: Schema.optional<Schema.filter<typeof Schema.Number>>;
    uniqueItems: Schema.optional<typeof Schema.Boolean>;
    contains: Schema.optional<Schema.suspend<JsonSchemaType, JsonSchemaType, never>>;
    maxProperties: Schema.optional<Schema.filter<typeof Schema.Number>>;
    minProperties: Schema.optional<Schema.filter<typeof Schema.Number>>;
    required: Schema.optional<Schema.mutable<Schema.Array$<typeof Schema.String>>>;
    /**
     * Non-standard JSON Schema extension.
     * Defines the order of properties in the object.
     * The unmentioned properties are placed at the end.
     *
     * Related: https://github.com/json-schema/json-schema/issues/119
     */
    propertyOrder: Schema.optional<Schema.mutable<Schema.Array$<typeof Schema.String>>>;
    additionalProperties: Schema.optional<Schema.Union<[Schema.suspend<JsonSchemaType, JsonSchemaType, never>, typeof Schema.Boolean]>>;
    properties: Schema.optional<Schema.mutable<Schema.Record$<typeof Schema.String, Schema.suspend<JsonSchemaType, JsonSchemaType, never>>>>;
    patternProperties: Schema.optional<Schema.mutable<Schema.Record$<typeof Schema.String, Schema.suspend<JsonSchemaType, JsonSchemaType, never>>>>;
    propertyNames: Schema.optional<Schema.suspend<JsonSchemaType, JsonSchemaType, never>>;
    definitions: Schema.optional<Schema.mutable<Schema.Record$<typeof Schema.String, Schema.suspend<JsonSchemaType, JsonSchemaType, never>>>>;
    dependencies: Schema.optional<Schema.Record$<typeof Schema.String, Schema.suspend<string | string[] | JsonSchemaType, string | string[] | JsonSchemaType, never>>>;
    contentMediaType: Schema.optional<typeof Schema.String>;
    contentEncoding: Schema.optional<typeof Schema.String>;
    if: Schema.optional<Schema.suspend<JsonSchemaType, JsonSchemaType, never>>;
    then: Schema.optional<Schema.suspend<JsonSchemaType, JsonSchemaType, never>>;
    else: Schema.optional<Schema.suspend<JsonSchemaType, JsonSchemaType, never>>;
    allOf: Schema.optional<Schema.Array$<Schema.suspend<JsonSchemaType, JsonSchemaType, never>>>;
    anyOf: Schema.optional<Schema.Array$<Schema.suspend<JsonSchemaType, JsonSchemaType, never>>>;
    oneOf: Schema.optional<Schema.Array$<Schema.suspend<JsonSchemaType, JsonSchemaType, never>>>;
    not: Schema.optional<Schema.suspend<JsonSchemaType, JsonSchemaType, never>>;
    $defs: Schema.optional<Schema.mutable<Schema.Record$<typeof Schema.String, Schema.suspend<JsonSchemaType, JsonSchemaType, never>>>>;
    currency: Schema.optional<typeof Schema.String>;
    reference: Schema.optional<Schema.mutable<Schema.Struct<{
        schema: Schema.suspend<JsonSchemaType, JsonSchemaType, never>;
        schemaVersion: Schema.optional<typeof Schema.String>;
        schemaObject: Schema.optional<typeof Schema.String>;
    }>>>;
    /**
     * ECHO-specific annotations.
     */
    annotations: Schema.optional<Schema.mutable<Schema.mutable<Schema.Struct<{
        /**
         * Label for this schema.
         * Mapped from {@link LabelAnnotationId}.
         */
        labelProp: Schema.optional<Schema.Union<[Schema.Schema<JsonPath, JsonPath, never>, Schema.Array$<Schema.Schema<JsonPath, JsonPath, never>>]>>;
        /**
         * Generator function for this schema.
         * Mapped from {@link GeneratorAnnotationId}.
         */
        generator: Schema.optional<Schema.Union<[typeof Schema.String, Schema.Tuple2<typeof Schema.String, typeof Schema.Number>]>>;
        /**
         * {@link PropertyMeta} annotations get serialized here.
         */
        meta: Schema.optional<Schema.mutable<Schema.Record$<typeof Schema.String, typeof Schema.Any>>>;
        /**
         * @deprecated
         */
        type: Schema.optional<Schema.mutable<Schema.Struct<{
            typename: typeof Schema.String;
            version: typeof Schema.String;
            schemaId: Schema.optional<typeof Schema.String>;
        }>>>;
        /**
         * @deprecated Superseded by `meta`.
         */
        annotations: Schema.optional<Schema.mutable<Schema.Record$<typeof Schema.String, typeof Schema.Any>>>;
    }>>>>;
    /**
     * @deprecated Use `annotations` instead.
     */
    echo: Schema.optional<Schema.mutable<Schema.mutable<Schema.Struct<{
        /**
         * Label for this schema.
         * Mapped from {@link LabelAnnotationId}.
         */
        labelProp: Schema.optional<Schema.Union<[Schema.Schema<JsonPath, JsonPath, never>, Schema.Array$<Schema.Schema<JsonPath, JsonPath, never>>]>>;
        /**
         * Generator function for this schema.
         * Mapped from {@link GeneratorAnnotationId}.
         */
        generator: Schema.optional<Schema.Union<[typeof Schema.String, Schema.Tuple2<typeof Schema.String, typeof Schema.Number>]>>;
        /**
         * {@link PropertyMeta} annotations get serialized here.
         */
        meta: Schema.optional<Schema.mutable<Schema.Record$<typeof Schema.String, typeof Schema.Any>>>;
        /**
         * @deprecated
         */
        type: Schema.optional<Schema.mutable<Schema.Struct<{
            typename: typeof Schema.String;
            version: typeof Schema.String;
            schemaId: Schema.optional<typeof Schema.String>;
        }>>>;
        /**
         * @deprecated Superseded by `meta`.
         */
        annotations: Schema.optional<Schema.mutable<Schema.Record$<typeof Schema.String, typeof Schema.Any>>>;
    }>>>>;
}>;
export declare const JsonSchemaFields: string[];
/**
 * https://json-schema.org/draft-07/schema
 */
export interface JsonSchemaType extends Schema.Schema.Type<Schema.mutable<typeof _JsonSchemaType>> {
}
export declare const JsonSchemaType: Schema.Schema<JsonSchemaType>;
export declare const getSchemaProperty: (schema: JsonSchemaType, property: JsonProp) => JsonSchemaType | undefined;
export declare const setSchemaProperty: (schema: JsonSchemaType, property: JsonProp, value: JsonSchemaType) => JsonSchemaType;
export {};
//# sourceMappingURL=json-schema-type.d.ts.map