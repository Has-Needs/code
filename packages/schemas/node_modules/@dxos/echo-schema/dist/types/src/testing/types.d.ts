import { Schema } from 'effect';
import { Expando } from '../object';
import { Ref, type Ref$ } from '../ref';
export declare namespace Testing {
    const TestNestedSchema: Schema.mutable<Schema.Struct<{
        field: typeof Schema.String;
    }>>;
    export type TestNestedSchema = Schema.Schema.Type<typeof TestNestedSchema>;
    export const TestNestedType: import("..").EchoTypeSchema<Schema.mutable<Schema.Struct<{
        field: typeof Schema.String;
    }>>, {}>;
    const EmptySchemaType_base: import("..").TypedObjectPrototype<import("..").TypedObjectFields<{}, import("..").TypedObjectOptions>, Schema.Struct.Encoded<{}>>;
    export class EmptySchemaType extends EmptySchemaType_base {
    }
    export const TestSchema: Schema.mutable<Schema.SchemaClass<{
        readonly string?: string | undefined;
        readonly number?: number | undefined;
        readonly boolean?: boolean | undefined;
        readonly undefined?: undefined;
        readonly object?: {
            field: string;
        } | undefined;
        readonly null?: null | undefined;
        readonly other?: any;
        readonly nested?: Ref<{
            readonly id: string;
            field: string;
        }> | undefined;
        readonly nullableShapeArray?: ({
            readonly type: "circle";
            readonly radius: number;
        } | {
            readonly type: "square";
            readonly side: number;
        } | null)[] | undefined;
        readonly stringArray?: string[] | undefined;
        readonly twoDimNumberArray?: number[][] | undefined;
        readonly objectArray?: {
            field: string;
        }[] | undefined;
    }, {
        readonly string?: string | undefined;
        readonly number?: number | undefined;
        readonly boolean?: boolean | undefined;
        readonly undefined?: undefined;
        readonly object?: {
            field: string;
        } | undefined;
        readonly null?: null | undefined;
        readonly other?: any;
        readonly nullableShapeArray?: ({
            readonly type: "circle";
            readonly radius: number;
        } | {
            readonly type: "square";
            readonly side: number;
        } | null)[] | undefined;
        readonly stringArray?: string[] | undefined;
        readonly twoDimNumberArray?: number[][] | undefined;
        readonly objectArray?: {
            field: string;
        }[] | undefined;
        readonly nested?: import("@dxos/echo-protocol").EncodedReference | undefined;
    }, never>>;
    export type TestSchema = Schema.Schema.Type<typeof TestSchema>;
    const TestSchemaType_base: import("..").TypedObjectPrototype<import("..").TypedObjectFields<{
        string: typeof Schema.String;
        number: typeof Schema.Number;
        nullableShapeArray: Schema.mutable<Schema.Array$<Schema.Union<[Schema.Union<[Schema.Struct<{
            type: Schema.Literal<["circle"]>;
            radius: typeof Schema.Number;
        }>, Schema.Struct<{
            type: Schema.Literal<["square"]>;
            side: typeof Schema.Number;
        }>]>, typeof Schema.Null]>>>;
        boolean: typeof Schema.Boolean;
        null: typeof Schema.Null;
        undefined: typeof Schema.Undefined;
        stringArray: Schema.mutable<Schema.Array$<typeof Schema.String>>;
        twoDimNumberArray: Schema.mutable<Schema.Array$<Schema.mutable<Schema.Array$<typeof Schema.Number>>>>;
        object: Schema.mutable<Schema.Struct<{
            field: typeof Schema.String;
        }>>;
        objectArray: Schema.mutable<Schema.Array$<Schema.mutable<Schema.Struct<{
            field: typeof Schema.String;
        }>>>>;
        nested: Schema.optional<Ref$<{
            readonly id: string;
            field: string;
        }>>;
        other: typeof Schema.Any;
    }, {
        partial: true;
    }>, Schema.Struct.Encoded<{
        string: typeof Schema.String;
        number: typeof Schema.Number;
        nullableShapeArray: Schema.mutable<Schema.Array$<Schema.Union<[Schema.Union<[Schema.Struct<{
            type: Schema.Literal<["circle"]>;
            radius: typeof Schema.Number;
        }>, Schema.Struct<{
            type: Schema.Literal<["square"]>;
            side: typeof Schema.Number;
        }>]>, typeof Schema.Null]>>>;
        boolean: typeof Schema.Boolean;
        null: typeof Schema.Null;
        undefined: typeof Schema.Undefined;
        stringArray: Schema.mutable<Schema.Array$<typeof Schema.String>>;
        twoDimNumberArray: Schema.mutable<Schema.Array$<Schema.mutable<Schema.Array$<typeof Schema.Number>>>>;
        object: Schema.mutable<Schema.Struct<{
            field: typeof Schema.String;
        }>>;
        objectArray: Schema.mutable<Schema.Array$<Schema.mutable<Schema.Struct<{
            field: typeof Schema.String;
        }>>>>;
        nested: Schema.optional<Ref$<{
            readonly id: string;
            field: string;
        }>>;
        other: typeof Schema.Any;
    }>>;
    export class TestSchemaType extends TestSchemaType_base {
    }
    export const TestType: import("..").EchoTypeSchema<Schema.mutable<Schema.SchemaClass<{
        readonly string?: string | undefined;
        readonly number?: number | undefined;
        readonly boolean?: boolean | undefined;
        readonly undefined?: undefined;
        readonly object?: {
            field: string;
        } | undefined;
        readonly null?: null | undefined;
        readonly other?: any;
        readonly nested?: Ref<{
            readonly id: string;
            field: string;
        }> | undefined;
        readonly nullableShapeArray?: ({
            readonly type: "circle";
            readonly radius: number;
        } | {
            readonly type: "square";
            readonly side: number;
        } | null)[] | undefined;
        readonly stringArray?: string[] | undefined;
        readonly twoDimNumberArray?: number[][] | undefined;
        readonly objectArray?: {
            field: string;
        }[] | undefined;
    }, {
        readonly string?: string | undefined;
        readonly number?: number | undefined;
        readonly boolean?: boolean | undefined;
        readonly undefined?: undefined;
        readonly object?: {
            field: string;
        } | undefined;
        readonly null?: null | undefined;
        readonly other?: any;
        readonly nullableShapeArray?: ({
            readonly type: "circle";
            readonly radius: number;
        } | {
            readonly type: "square";
            readonly side: number;
        } | null)[] | undefined;
        readonly stringArray?: string[] | undefined;
        readonly twoDimNumberArray?: number[][] | undefined;
        readonly objectArray?: {
            field: string;
        }[] | undefined;
        readonly nested?: import("@dxos/echo-protocol").EncodedReference | undefined;
    }, never>>, {}>;
    export class TestClass {
        field: string;
        toJSON(): {
            field: string;
        };
    }
    export const TestSchemaWithClass: Schema.mutable<Schema.extend<Schema.mutable<Schema.SchemaClass<{
        readonly string?: string | undefined;
        readonly number?: number | undefined;
        readonly boolean?: boolean | undefined;
        readonly undefined?: undefined;
        readonly object?: {
            field: string;
        } | undefined;
        readonly null?: null | undefined;
        readonly other?: any;
        readonly nested?: Ref<{
            readonly id: string;
            field: string;
        }> | undefined;
        readonly nullableShapeArray?: ({
            readonly type: "circle";
            readonly radius: number;
        } | {
            readonly type: "square";
            readonly side: number;
        } | null)[] | undefined;
        readonly stringArray?: string[] | undefined;
        readonly twoDimNumberArray?: number[][] | undefined;
        readonly objectArray?: {
            field: string;
        }[] | undefined;
    }, {
        readonly string?: string | undefined;
        readonly number?: number | undefined;
        readonly boolean?: boolean | undefined;
        readonly undefined?: undefined;
        readonly object?: {
            field: string;
        } | undefined;
        readonly null?: null | undefined;
        readonly other?: any;
        readonly nullableShapeArray?: ({
            readonly type: "circle";
            readonly radius: number;
        } | {
            readonly type: "square";
            readonly side: number;
        } | null)[] | undefined;
        readonly stringArray?: string[] | undefined;
        readonly twoDimNumberArray?: number[][] | undefined;
        readonly objectArray?: {
            field: string;
        }[] | undefined;
        readonly nested?: import("@dxos/echo-protocol").EncodedReference | undefined;
    }, never>>, Schema.mutable<Schema.Struct<{
        classInstance: Schema.optional<Schema.instanceOf<TestClass>>;
    }>>>>;
    export type TestSchemaWithClass = Schema.Schema.Type<typeof TestSchemaWithClass>;
    const Contact_base: import("..").TypedObjectPrototype<import("..").TypedObjectFields<{
        name: typeof Schema.String;
        username: typeof Schema.String;
        email: typeof Schema.String;
        tasks: Schema.suspend<Ref<Task>[], import("@dxos/echo-protocol").EncodedReference[], never>;
        address: Schema.Struct<{
            city: Schema.optional<typeof Schema.String>;
            state: Schema.optional<typeof Schema.String>;
            zip: Schema.optional<typeof Schema.String>;
            coordinates: Schema.Struct<{
                lat: Schema.optional<typeof Schema.Number>;
                lng: Schema.optional<typeof Schema.Number>;
            }>;
        }>;
    }, {
        partial: true;
    }>, Schema.Struct.Encoded<{
        name: typeof Schema.String;
        username: typeof Schema.String;
        email: typeof Schema.String;
        tasks: Schema.suspend<Ref<Task>[], import("@dxos/echo-protocol").EncodedReference[], never>;
        address: Schema.Struct<{
            city: Schema.optional<typeof Schema.String>;
            state: Schema.optional<typeof Schema.String>;
            zip: Schema.optional<typeof Schema.String>;
            coordinates: Schema.Struct<{
                lat: Schema.optional<typeof Schema.Number>;
                lng: Schema.optional<typeof Schema.Number>;
            }>;
        }>;
    }>>;
    export class Contact extends Contact_base {
    }
    const Task_base: import("..").TypedObjectPrototype<import("..").TypedObjectFields<{
        title: Schema.optional<typeof Schema.String>;
        completed: Schema.optional<typeof Schema.Boolean>;
        assignee: Schema.optional<Ref$<import("..").TypedObjectFields<{
            name: typeof Schema.String;
            username: typeof Schema.String;
            email: typeof Schema.String;
            tasks: Schema.suspend<Ref<Task>[], import("@dxos/echo-protocol").EncodedReference[], never>;
            address: Schema.Struct<{
                city: Schema.optional<typeof Schema.String>;
                state: Schema.optional<typeof Schema.String>;
                zip: Schema.optional<typeof Schema.String>;
                coordinates: Schema.Struct<{
                    lat: Schema.optional<typeof Schema.Number>;
                    lng: Schema.optional<typeof Schema.Number>;
                }>;
            }>;
        }, {
            partial: true;
        }>>>;
        previous: Schema.optional<Schema.suspend<Ref<Task>, import("@dxos/echo-protocol").EncodedReference, never>>;
        subTasks: Schema.optional<Schema.mutable<Schema.Array$<Schema.suspend<Ref<Task>, import("@dxos/echo-protocol").EncodedReference, never>>>>;
        description: Schema.optional<typeof Schema.String>;
    }, {
        partial: true;
    }>, Schema.Struct.Encoded<{
        title: Schema.optional<typeof Schema.String>;
        completed: Schema.optional<typeof Schema.Boolean>;
        assignee: Schema.optional<Ref$<import("..").TypedObjectFields<{
            name: typeof Schema.String;
            username: typeof Schema.String;
            email: typeof Schema.String;
            tasks: Schema.suspend<Ref<Task>[], import("@dxos/echo-protocol").EncodedReference[], never>;
            address: Schema.Struct<{
                city: Schema.optional<typeof Schema.String>;
                state: Schema.optional<typeof Schema.String>;
                zip: Schema.optional<typeof Schema.String>;
                coordinates: Schema.Struct<{
                    lat: Schema.optional<typeof Schema.Number>;
                    lng: Schema.optional<typeof Schema.Number>;
                }>;
            }>;
        }, {
            partial: true;
        }>>>;
        previous: Schema.optional<Schema.suspend<Ref<Task>, import("@dxos/echo-protocol").EncodedReference, never>>;
        subTasks: Schema.optional<Schema.mutable<Schema.Array$<Schema.suspend<Ref<Task>, import("@dxos/echo-protocol").EncodedReference, never>>>>;
        description: Schema.optional<typeof Schema.String>;
    }>>;
    export class Task extends Task_base {
    }
    export enum RecordType {
        UNDEFINED = 0,
        PERSONAL = 1,
        WORK = 2
    }
    const Container_base: import("..").TypedObjectPrototype<import("..").TypedObjectFields<{
        objects: Schema.mutable<Schema.Array$<Ref$<Expando>>>;
        records: Schema.mutable<Schema.Array$<Schema.SchemaClass<{
            readonly title?: string | undefined;
            readonly description?: string | undefined;
            readonly type?: RecordType | undefined;
            readonly contacts?: Ref<import("..").TypedObjectFields<{
                name: typeof Schema.String;
                username: typeof Schema.String;
                email: typeof Schema.String;
                tasks: Schema.suspend<Ref<Task>[], import("@dxos/echo-protocol").EncodedReference[], never>;
                address: Schema.Struct<{
                    city: Schema.optional<typeof Schema.String>;
                    state: Schema.optional<typeof Schema.String>;
                    zip: Schema.optional<typeof Schema.String>;
                    coordinates: Schema.Struct<{
                        lat: Schema.optional<typeof Schema.Number>;
                        lng: Schema.optional<typeof Schema.Number>;
                    }>;
                }>;
            }, {
                partial: true;
            }>>[] | undefined;
        }, {
            readonly title?: string | undefined;
            readonly description?: string | undefined;
            readonly type?: RecordType | undefined;
            readonly contacts?: import("@dxos/echo-protocol").EncodedReference[] | undefined;
        }, never>>>;
    }, {
        partial: true;
    }>, Schema.Struct.Encoded<{
        objects: Schema.mutable<Schema.Array$<Ref$<Expando>>>;
        records: Schema.mutable<Schema.Array$<Schema.SchemaClass<{
            readonly title?: string | undefined;
            readonly description?: string | undefined;
            readonly type?: RecordType | undefined;
            readonly contacts?: Ref<import("..").TypedObjectFields<{
                name: typeof Schema.String;
                username: typeof Schema.String;
                email: typeof Schema.String;
                tasks: Schema.suspend<Ref<Task>[], import("@dxos/echo-protocol").EncodedReference[], never>;
                address: Schema.Struct<{
                    city: Schema.optional<typeof Schema.String>;
                    state: Schema.optional<typeof Schema.String>;
                    zip: Schema.optional<typeof Schema.String>;
                    coordinates: Schema.Struct<{
                        lat: Schema.optional<typeof Schema.Number>;
                        lng: Schema.optional<typeof Schema.Number>;
                    }>;
                }>;
            }, {
                partial: true;
            }>>[] | undefined;
        }, {
            readonly title?: string | undefined;
            readonly description?: string | undefined;
            readonly type?: RecordType | undefined;
            readonly contacts?: import("@dxos/echo-protocol").EncodedReference[] | undefined;
        }, never>>>;
    }>>;
    export class Container extends Container_base {
    }
    export const HasManager: import("..").EchoTypeSchema<Schema.Struct<{
        since: Schema.optional<typeof Schema.String>;
    }>, import("..").RelationSourceTargetRefs<import("..").TypedObjectFields<{
        name: typeof Schema.String;
        username: typeof Schema.String;
        email: typeof Schema.String;
        tasks: Schema.suspend<Ref<Task>[], import("@dxos/echo-protocol").EncodedReference[], never>;
        address: Schema.Struct<{
            city: Schema.optional<typeof Schema.String>;
            state: Schema.optional<typeof Schema.String>;
            zip: Schema.optional<typeof Schema.String>;
            coordinates: Schema.Struct<{
                lat: Schema.optional<typeof Schema.Number>;
                lng: Schema.optional<typeof Schema.Number>;
            }>;
        }>;
    }, {
        partial: true;
    }>, import("..").TypedObjectFields<{
        name: typeof Schema.String;
        username: typeof Schema.String;
        email: typeof Schema.String;
        tasks: Schema.suspend<Ref<Task>[], import("@dxos/echo-protocol").EncodedReference[], never>;
        address: Schema.Struct<{
            city: Schema.optional<typeof Schema.String>;
            state: Schema.optional<typeof Schema.String>;
            zip: Schema.optional<typeof Schema.String>;
            coordinates: Schema.Struct<{
                lat: Schema.optional<typeof Schema.Number>;
                lng: Schema.optional<typeof Schema.Number>;
            }>;
        }>;
    }, {
        partial: true;
    }>>>;
    export interface HasManager extends Schema.Schema.Type<typeof HasManager> {
    }
    export {};
}
//# sourceMappingURL=types.d.ts.map