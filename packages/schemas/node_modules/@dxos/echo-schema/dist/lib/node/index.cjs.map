{
  "version": 3,
  "sources": ["../../../src/index.ts", "../../../src/formats/number.ts", "../../../src/formats/types.ts", "../../../src/formats/object.ts", "../../../src/formats/format.ts", "../../../src/formats/date.ts", "../../../src/formats/string.ts", "../../../src/formats/select.ts", "../../../src/json/json-schema.ts", "../../../src/json/annotations.ts", "../../../src/json-schema/json-schema-type.ts", "../../../src/json-schema/json-schema-normalize.ts", "../../../src/query/query.ts", "../../../src/types/types.ts", "../../../src/projection/compose.ts", "../../../src/schema/echo-schema.ts", "../../../src/schema/manipulation.ts", "../../../src/schema/snapshot.ts", "../../../src/schema/stored-schema.ts", "../../../src/schema/runtime-schema-registry.ts"],
  "sourcesContent": ["//\n// Copyright 2024 DXOS.org\n//\n\nexport { JsonPath, splitJsonPath, JsonProp } from '@dxos/effect';\n\n// TODO(dmaretskyi): Remove.\nexport { ObjectId } from '@dxos/keys';\nexport { ForeignKey } from '@dxos/echo-protocol';\n\nexport * from './ast';\nexport * from './formats';\nexport * from './json';\nexport * from './json-schema';\nexport * from './object';\nexport * from './query';\nexport * from './types';\nexport * from './utils';\nexport * from './ref';\nexport * from './projection';\nexport * from './schema';\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { Schema } from 'effect';\n\nimport { FormatAnnotation, FormatEnum } from './types';\n\nconst encodeMultipleOf = (divisor: number) => 1 / Math.pow(10, divisor);\n\nconst encodeMultiple =\n  <A extends number>(divisor?: number) =>\n  <I, R>(self: Schema.Schema<A, I, R>) =>\n    divisor === undefined || divisor === 0 ? self : self.pipe(Schema.multipleOf(encodeMultipleOf(divisor)));\n\n/**\n * Convert number of digits to multipleOf annotation.\n */\nexport const DecimalPrecision = Schema.transform(Schema.Number, Schema.Number, {\n  strict: true,\n  encode: (value) => encodeMultipleOf(value),\n  decode: (value) => Math.log10(1 / value),\n}).annotations({\n  title: 'Number of digits',\n});\n\nexport const CurrencyAnnotationId = Symbol.for('@dxos/schema/annotation/Currency');\n\nexport type CurrencyAnnotation = {\n  decimals?: number;\n  code?: string;\n};\n\n/**\n * ISO 4217 currency code.\n */\nexport const Currency = ({ decimals, code }: CurrencyAnnotation = { decimals: 2 }) =>\n  Schema.Number.pipe(\n    encodeMultiple(decimals),\n    FormatAnnotation.set(FormatEnum.Currency),\n    Schema.annotations({\n      title: 'Currency',\n      description: 'Currency value',\n      ...(code ? { [CurrencyAnnotationId]: code.toUpperCase() } : {}),\n    }),\n  );\n\nexport type PercentAnnotation = {\n  decimals?: number;\n};\n\n/**\n * Integer.\n */\nexport const Integer = () =>\n  Schema.Number.pipe(\n    Schema.int(),\n    FormatAnnotation.set(FormatEnum.Integer),\n    Schema.annotations({\n      title: 'Integer',\n      description: 'Integer value',\n    }),\n  );\n\n/**\n * Percent.\n */\n// TODO(burdon): Define min/max (e.g., 0, 1).\nexport const Percent = ({ decimals }: PercentAnnotation = { decimals: 2 }) =>\n  Schema.Number.pipe(\n    encodeMultiple(decimals),\n    FormatAnnotation.set(FormatEnum.Percent),\n    Schema.annotations({\n      title: 'Percent',\n      description: 'Percentage value',\n    }),\n  );\n\n/**\n * Unix timestamp.\n * https://en.wikipedia.org/wiki/Unix_time\n */\nexport const Timestamp = Schema.Number.pipe(\n  FormatAnnotation.set(FormatEnum.Timestamp),\n  Schema.annotations({\n    title: 'Timestamp',\n    description: 'Unix timestamp',\n  }),\n);\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { Option, SchemaAST, type JSONSchema, pipe } from 'effect';\n\nimport { createAnnotationHelper } from '../ast';\nimport { type JsonSchemaType } from '../json-schema';\n\n// TODO(burdon): Rename PropertyType.\nexport type ScalarType =\n  | JSONSchema.JsonSchema7Object\n  | JSONSchema.JsonSchema7String\n  | JSONSchema.JsonSchema7Number\n  | JSONSchema.JsonSchema7Boolean\n  | JSONSchema.JsonSchema7Ref;\n\n// TODO(burdon): Rename ValueType and change to disciminated union.\n// export type ValueType = 'array' | 'object' | 'string' | 'number' | 'boolean' | 'ref';\nexport enum TypeEnum {\n  Array = 'array', // TODO(burdon): Remove?\n  Object = 'object',\n  String = 'string',\n  Number = 'number',\n  Boolean = 'boolean',\n  Ref = 'ref',\n}\n\n// TODO(burdon): Ref?\nexport const getTypeEnum = (property: JsonSchemaType): TypeEnum | undefined => {\n  switch (property.type) {\n    case 'array':\n      return TypeEnum.Array;\n    case 'object':\n      return TypeEnum.Object;\n    case 'string':\n      return TypeEnum.String;\n    case 'number':\n      return TypeEnum.Number;\n    case 'boolean':\n      return TypeEnum.Boolean;\n    default:\n      return undefined;\n  }\n};\n\n/**\n * https://json-schema.org/understanding-json-schema/reference/schema\n * https://json-schema.org/understanding-json-schema/reference/string#built-in-formats\n */\nexport const FormatAnnotationId = Symbol.for('@dxos/schema/annotation/Format');\n\nexport const FormatAnnotation = createAnnotationHelper<FormatEnum>(FormatAnnotationId);\n\nexport const getFormatAnnotation = (node: SchemaAST.AST): FormatEnum | undefined =>\n  pipe(SchemaAST.getAnnotation<FormatEnum>(FormatAnnotationId)(node), Option.getOrUndefined);\n\n// TODO(burdon): Rename to FormatType and change to discriminated union.\nexport enum FormatEnum {\n  None = 'none',\n  String = 'string',\n  Number = 'number',\n  Boolean = 'boolean',\n  Ref = 'ref',\n\n  //\n  // { type: 'string' }\n  //\n\n  DID = 'did', // Users, etc.\n  DXN = 'dxn',\n  Email = 'email',\n  Formula = 'formula', // Spreadsheet formula.\n  Hostname = 'hostname',\n  JSON = 'json',\n  Markdown = 'markdown',\n  Regex = 'regex',\n  SingleSelect = 'single-select',\n  MultiSelect = 'multi-select',\n  URL = 'url',\n  UUID = 'uuid',\n\n  //\n  // { type: 'number' }\n  //\n\n  Currency = 'currency',\n  Integer = 'integer',\n  Percent = 'percent',\n  Timestamp = 'timestamp',\n\n  //\n  // { type: 'date' }\n  //\n\n  DateTime = 'date-time',\n  Date = 'date',\n  Time = 'time',\n  Duration = 'duration',\n\n  //\n  // { type: 'object' }\n  //\n\n  GeoPoint = 'latlng',\n}\n\nexport const FormatEnums = Object.values(FormatEnum).sort();\n\nexport const PropertyKind = {\n  type: TypeEnum,\n  format: FormatEnum,\n};\n\n/**\n * Default formats\n */\nexport const typeToFormat: Partial<Record<TypeEnum, FormatEnum>> = {\n  [TypeEnum.String]: FormatEnum.String,\n  [TypeEnum.Number]: FormatEnum.Number,\n  [TypeEnum.Boolean]: FormatEnum.Boolean,\n};\n\n/**\n * Map of format to type.\n */\nexport const formatToType: Record<FormatEnum, TypeEnum> = {\n  [FormatEnum.None]: undefined as any,\n  [FormatEnum.String]: TypeEnum.String,\n  [FormatEnum.Number]: TypeEnum.Number,\n  [FormatEnum.Boolean]: TypeEnum.Boolean,\n  [FormatEnum.Ref]: TypeEnum.Ref,\n\n  // Strings\n  [FormatEnum.DID]: TypeEnum.String,\n  [FormatEnum.DXN]: TypeEnum.String,\n  [FormatEnum.Email]: TypeEnum.String,\n  [FormatEnum.Formula]: TypeEnum.String,\n  [FormatEnum.Hostname]: TypeEnum.String,\n  [FormatEnum.JSON]: TypeEnum.String,\n  [FormatEnum.Markdown]: TypeEnum.String,\n  [FormatEnum.Regex]: TypeEnum.String,\n  [FormatEnum.URL]: TypeEnum.String,\n  [FormatEnum.UUID]: TypeEnum.String,\n  [FormatEnum.SingleSelect]: TypeEnum.String,\n  [FormatEnum.MultiSelect]: TypeEnum.Object,\n\n  // Dates\n  [FormatEnum.Date]: TypeEnum.String,\n  [FormatEnum.DateTime]: TypeEnum.String,\n  [FormatEnum.Duration]: TypeEnum.String,\n  [FormatEnum.Time]: TypeEnum.String,\n\n  // Numbers\n  [FormatEnum.Currency]: TypeEnum.Number,\n  [FormatEnum.Integer]: TypeEnum.Number,\n  [FormatEnum.Percent]: TypeEnum.Number,\n  [FormatEnum.Timestamp]: TypeEnum.Number,\n\n  // Objects\n  [FormatEnum.GeoPoint]: TypeEnum.Object,\n};\n\n/**\n * Allowed value options for select.\n */\nexport const OptionsAnnotationId = Symbol.for('@dxos/schema/annotation/Options');\n\nexport const getOptionsAnnotation = (node: SchemaAST.AST): OptionsAnnotationType[] | undefined =>\n  pipe(SchemaAST.getAnnotation<OptionsAnnotationType[]>(OptionsAnnotationId)(node), Option.getOrUndefined);\n\nexport type OptionsAnnotationType = string | number;\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { Schema } from 'effect';\n\nimport { clamp } from '@dxos/util';\n\nimport { FormatAnnotation, FormatEnum } from './types';\n\n/**\n * GeoJSON Format\n * https://datatracker.ietf.org/doc/html/rfc7946\n * https://datatracker.ietf.org/doc/html/rfc7946#section-3.1.1\n * https://en.wikipedia.org/wiki/Geographic_coordinate_system\n * https://geojson.org\n * {\n *   \"type\": \"Point\",\n *   \"coordinates\": [0, 51.47] // [longitude, latitude]\n * }\n * Note: optional third element for altitude.\n */\nexport const GeoPoint = Schema.Tuple(\n  Schema.Number.pipe(Schema.clamp(-180, 180), Schema.multipleOf(0.00001)).annotations({\n    title: 'Longitude',\n  }),\n  Schema.Number.pipe(Schema.clamp(-90, 90), Schema.multipleOf(0.00001)).annotations({\n    title: 'Latitude',\n  }),\n  Schema.optionalElement(Schema.Number).annotations({\n    title: 'Height ASL (m)',\n  }),\n).pipe(\n  FormatAnnotation.set(FormatEnum.GeoPoint),\n  Schema.annotations({\n    title: 'GeoPoint',\n    description: 'GeoJSON Position',\n  }),\n);\n\nexport type GeoPoint = Schema.Schema.Type<typeof GeoPoint>;\n\nexport type GeoLocation = {\n  longitude: number;\n  latitude: number;\n  height?: number;\n};\n\n/**\n * Geolocation utilities for working with GeoPoint format.\n */\nexport namespace GeoLocation {\n  /**\n   * Convert latitude and longitude to GeoPoint (GeoJSON format [longitude, latitude, height?]).\n   * Clamps values to valid ranges: latitude [-90, 90], longitude [-180, 180].\n   */\n  export const toGeoPoint = ({ longitude, latitude, height }: GeoLocation): GeoPoint => {\n    // TODO(ZaymonFC): Use schema validation instead of doing this manually.\n    const clampedLongitude = clamp(longitude, -180, 180);\n    const clampedLatitude = clamp(latitude, -90, 90);\n    return height !== undefined ? [clampedLongitude, clampedLatitude, height] : [clampedLongitude, clampedLatitude];\n  };\n\n  /**\n   * Extract latitude and longitude from GeoPoint (GeoJSON format [longitude, latitude, height?]).\n   */\n  export const fromGeoPoint = (geoPoint: GeoPoint | undefined): GeoLocation => {\n    if (!geoPoint) {\n      return { longitude: 0, latitude: 0 };\n    }\n\n    const result: GeoLocation = {\n      longitude: geoPoint[0],\n      latitude: geoPoint[1],\n    };\n\n    // Add height if defined.\n    if (geoPoint[2] !== undefined) {\n      result.height = geoPoint[2];\n    }\n\n    return result;\n  };\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { Schema } from 'effect';\n\nimport * as Keys from '@dxos/keys';\n\nimport * as DateUtil from './date';\nimport * as NumberUtil from './number';\nimport * as ObjectUtil from './object';\nimport * as StringUtil from './string';\n\n// TODO(burdon): Consider factoring out to separate `@dxos/json-schema`\n// TODO(burdon): Media encoding.\n//  - https://json-schema.org/understanding-json-schema/reference/non_json_data\n\n/**\n * Formats.\n * https://json-schema.org/understanding-json-schema/reference/string#built-in-formats\n * NOTE: A JSON Schema validator will ignore any format type that it does not understand.\n */\n// TODO(burdon): Add fields for `examples`, `message`, etc.\nexport namespace Format {\n  // Strings\n  export const DXN = Keys.DXN;\n  export const Email = StringUtil.Email;\n  export const Formula = StringUtil.Formula;\n  export const Hostname = StringUtil.Hostname;\n  export const JSON = StringUtil.JSON;\n  export const Markdown = StringUtil.Markdown;\n  export const Regex = StringUtil.Regex;\n  export const URL = StringUtil.URL;\n  export const UUID = Schema.UUID;\n\n  // Numbers\n  // TODO(burdon): BigInt.\n  export const Currency = NumberUtil.Currency;\n  export const Integer = NumberUtil.Integer;\n  export const Percent = NumberUtil.Percent;\n  export const Timestamp = NumberUtil.Timestamp;\n\n  // Dates and times\n  export const DateTime = DateUtil.DateTime;\n  export const Date = DateUtil.DateOnly;\n  export const Time = DateUtil.TimeOnly;\n  export const Duration = DateUtil.Duration;\n\n  // Objects\n  export const GeoPoint = ObjectUtil.GeoPoint;\n  export type GeoPoint = ObjectUtil.GeoPoint;\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { Schema, SchemaAST } from 'effect';\n\nimport { FormatAnnotation, FormatEnum } from './types';\n\n/**\n * Datetime values should be stored as ISO strings or unix numbers (ms) in UTC.\n *\n * NOTE: HyperFormula uses Excel's time format (null date 1900/01/01)\n * It can be configured to use a different parser via `parseDateTime`.\n * https://hyperformula.handsontable.com/guide/date-and-time-handling.html#date-and-time-handling\n * https://github.com/handsontable/hyperformula/blob/master/src/DateTimeHelper.ts\n */\n\n// TODO(burdon): Annotations not present in JSON.\n// TODO(burdon): Timezone.\n// TODO(burdon): Format for timestamp (Unix UTC or ISO 8601)?\n// TODO(burdon): Refs\n//  - https://www.npmjs.com/package/numfmt\n//  - https://date-fns.org/docs/Getting-Started\n//  - https://github.com/date-fns/tz\n\n/**\n * Simple date compatible with HF.\n */\nexport const SimpleDate = Schema.Struct({\n  year: Schema.Number.pipe(Schema.between(1900, 9999)),\n  month: Schema.Number.pipe(Schema.between(1, 12)),\n  day: Schema.Number.pipe(Schema.between(1, 31)),\n});\n\nexport type SimpleDate = Schema.Schema.Type<typeof SimpleDate>;\n\nexport const toSimpleDate = (date: Date): SimpleDate => ({\n  year: date.getUTCFullYear(),\n  month: date.getUTCMonth() + 1,\n  day: date.getUTCDate(),\n});\n\n/**\n * Simple time compatible with HF.\n */\nexport const SimpleTime = Schema.Struct({\n  hours: Schema.Number.pipe(Schema.between(0, 23)),\n  minutes: Schema.Number.pipe(Schema.between(0, 59)),\n  seconds: Schema.Number.pipe(Schema.between(0, 59)),\n});\n\nexport type SimpleTime = Schema.Schema.Type<typeof SimpleTime>;\n\nexport const toSimpleTime = (date: Date): SimpleTime => ({\n  hours: date.getUTCHours(),\n  minutes: date.getUTCSeconds(),\n  seconds: date.getUTCSeconds(),\n});\n\n/**\n * Simple date-time compatible with HF.\n */\nexport const SimpleDateTime = Schema.extend(SimpleDate, SimpleTime);\n\nexport type SimpleDateTime = Schema.Schema.Type<typeof SimpleDateTime>;\n\nexport const toSimpleDateTime = (date: Date): SimpleDateTime => ({\n  ...toSimpleDate(date),\n  ...toSimpleTime(date),\n});\n\n/**\n * https://effect.website/docs/guides/schema/transformations#date-transformations\n */\n\n// TODO(burdon): Consider if transformations should be supported with Automerge.\n\n/**\n * Format: 2018-11-13\n */\nexport const DateOnly = /* Schema.transformOrFail(Schema.String, SimpleDate, {\n  strict: true,\n  decode: (str, _, ast) => {\n    if (!isValidDateFormat(str)) {\n      return ParseResult.fail(new ParseResult.Type(ast, str, 'Expected YYYY-MM-DD format'));\n    }\n    if (!isValidDate(str)) {\n      return ParseResult.fail(new ParseResult.Type(ast, str, 'Invalid date'));\n    }\n\n    const [year, month, day] = str.split('-').map(Number);\n    return ParseResult.succeed({ year, month, day });\n  },\n  encode: (date) => {\n    return ParseResult.succeed(\n      [\n        date.year.toString().padStart(4, '0'),\n        date.month.toString().padStart(2, '0'),\n        date.day.toString().padStart(2, '0'),\n      ].join('-'),\n    );\n  },\n}) */ Schema.String.pipe(\n  FormatAnnotation.set(FormatEnum.Date),\n  Schema.annotations({\n    title: 'Date',\n    description: 'Valid date in ISO format',\n  }),\n);\n\n/**\n * Format: 20:20:39+00:00\n */\nexport const TimeOnly = /* Schema.transformOrFail(Schema.String, SimpleTime, {\n  strict: true,\n  decode: (str, _, ast) => {\n    if (!isValidTimeFormat(str)) {\n      return ParseResult.fail(new ParseResult.Type(ast, str, 'Expected HH:mm:ss format'));\n    }\n\n    const [hours, minutes, seconds] = str.split(':').map(Number);\n    return ParseResult.succeed({ hours, minutes, seconds });\n  },\n  encode: (time) => {\n    return ParseResult.succeed(\n      [\n        time.hours.toString().padStart(2, '0'),\n        time.minutes.toString().padStart(2, '0'),\n        time.seconds.toString().padStart(2, '0'),\n      ].join(':'),\n    );\n  },\n}) */ Schema.String.pipe(\n  FormatAnnotation.set(FormatEnum.Time),\n  Schema.annotations({\n    title: 'Time',\n    description: 'Valid time in ISO format',\n  }),\n);\n\n/**\n * Format: 2018-11-13T20:20:39+00:00\n */\nexport const DateTime = /* Schema.transformOrFail(Schema.String, SimpleDateTime, {\n  strict: false,\n  decode: (str, _, ast) => {\n    const [date, time] = str.split('T');\n    if (!isValidDateFormat(date)) {\n      return ParseResult.fail(new ParseResult.Type(ast, date, 'Expected YYYY-MM-DD format'));\n    }\n    if (!isValidDate(date)) {\n      return ParseResult.fail(new ParseResult.Type(ast, date, 'Invalid date'));\n    }\n    if (!isValidTimeFormat(time)) {\n      return ParseResult.fail(new ParseResult.Type(ast, str, 'Expected HH:mm:ss format'));\n    }\n\n    const [year, month, day] = date.split('-').map(Number);\n    const [hours, minutes, seconds] = time.split(':').map(Number);\n    return ParseResult.succeed({ year, month, day, hours, minutes, seconds });\n  },\n  encode: (datetime) => {\n    return ParseResult.succeed(\n      [\n        [\n          datetime.year.toString().padStart(4, '0'),\n          datetime.month.toString().padStart(2, '0'),\n          datetime.day.toString().padStart(2, '0'),\n        ].join('-'),\n        [\n          datetime.hours.toString().padStart(2, '0'),\n          datetime.minutes.toString().padStart(2, '0'),\n          datetime.seconds.toString().padStart(2, '0'),\n        ].join(':'),\n      ].join('T'),\n    );\n  },\n}) */ Schema.String.pipe(\n  FormatAnnotation.set(FormatEnum.DateTime),\n  Schema.annotations({\n    title: 'DateTime',\n    description: 'Valid date and time in ISO format',\n  }),\n);\n\n/**\n * https://datatracker.ietf.org/doc/html/rfc3339#appendix-A\n */\n// TODO(burdon): Define duration type.\nexport const Duration = Schema.String.pipe(\n  FormatAnnotation.set(FormatEnum.Duration),\n  Schema.annotations({\n    title: 'Duration',\n    description: 'Duration in ISO 8601 format',\n    [SchemaAST.ExamplesAnnotationId]: ['1h', '3D'],\n  }),\n);\n\n//\n// Utils\n//\n\n// YYYY-MM-DD\nconst DATE_REGEX = /^\\d{4}-\\d{2}-\\d{2}$/;\n\nconst _isValidDateFormat = (str: string) => DATE_REGEX.test(str);\n\nconst _isValidDate = (str: string) => {\n  const date = new Date(str);\n  return !isNaN(date.getTime()) && date.toISOString().startsWith(str);\n};\n\n// HH:mm:ss\nconst TIME_REGEX = /^([01]\\d|2[0-3]):([0-5]\\d):([0-5]\\d)$/;\n\nconst _isValidTimeFormat = (str: string) => TIME_REGEX.test(str);\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { SchemaAST, Schema } from 'effect';\n\nimport { FormatAnnotation, FormatEnum } from './types';\n\n/**\n * Email address (RFC 5321)\n * https://datatracker.ietf.org/doc/html/rfc5321#section-4.1.2\n */\nexport const Email = Schema.String.pipe(\n  Schema.pattern(/^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/),\n  FormatAnnotation.set(FormatEnum.Email),\n  Schema.annotations({\n    title: 'Email',\n    description: 'Email address',\n  }),\n);\n\n/**\n *\n */\n// TODO(burdon): Implement.\nexport const Formula = Schema.String.pipe(FormatAnnotation.set(FormatEnum.Formula));\n\n/**\n *\n */\n// TODO(burdon): Implement.\nexport const Hostname = Schema.String.pipe(FormatAnnotation.set(FormatEnum.Hostname));\n\n/**\n *\n */\n// TODO(burdon): Implement.\nexport const JSON = Schema.String.pipe(FormatAnnotation.set(FormatEnum.JSON));\n\n/**\n *\n */\n// TODO(burdon): Implement.\nexport const Markdown = Schema.String.pipe(FormatAnnotation.set(FormatEnum.Markdown));\n\n/**\n * Regex\n * https://json-schema.org/understanding-json-schema/reference/regular_expressions\n * https://ecma-international.org/publications-and-standards/standards/ecma-262\n */\n// TODO(burdon): Implement.\nexport const Regex = Schema.String.pipe(FormatAnnotation.set(FormatEnum.Regex));\n\n/**\n * https://datatracker.ietf.org/doc/html/rfc3986#section-1.1.3\n */\nexport const URL = Schema.String.pipe(\n  Schema.pattern(/^(\\w+?:\\/\\/)?([\\da-z.-]+)\\.([a-z.]{2,6})([/\\w .-]*)*\\/?$/i),\n  FormatAnnotation.set(FormatEnum.URL),\n  Schema.annotations({\n    title: 'URL',\n    description: 'URL',\n  }),\n);\n\n/**\n * UUID (RFC 4122)\n * https://datatracker.ietf.org/doc/html/rfc4122\n */\nexport const UUID = Schema.UUID.pipe(\n  FormatAnnotation.set(FormatEnum.UUID),\n  Schema.annotations({\n    [SchemaAST.ExamplesAnnotationId]: ['3e4666bf-d5e5-4aa7-b8ce-cefe41c7568a'],\n  }),\n);\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { Schema } from 'effect';\n\n/** Schema for a single select option. Used to define choices in a {single|multi}-select field. */\nexport const SelectOptionSchema = Schema.Struct({\n  /** Stable identifier for the option. */\n  id: Schema.NonEmptyString,\n  title: Schema.String,\n  /** Color palette used for visual styling. */\n  color: Schema.String,\n}).pipe(Schema.mutable);\n\nexport type SelectOption = Schema.Schema.Type<typeof SelectOptionSchema>;\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { JSONSchema, Option, Schema, SchemaAST, type Types } from 'effect';\nimport type { Mutable } from 'effect/Types';\n\nimport { raise } from '@dxos/debug';\nimport { mapAst } from '@dxos/effect';\nimport { invariant } from '@dxos/invariant';\nimport { DXN, ObjectId } from '@dxos/keys';\nimport { clearUndefined, orderKeys, removeProperties } from '@dxos/util';\n\nimport { CustomAnnotations, DecodedAnnotations, EchoAnnotations } from './annotations';\nimport {\n  getTypeAnnotation,\n  getTypeIdentifierAnnotation,\n  type TypeAnnotation,\n  TypeAnnotationId,\n  TypeIdentifierAnnotationId,\n} from '../ast';\nimport { EntityKind, EntityKindSchema } from '../ast';\nimport {\n  ECHO_ANNOTATIONS_NS_DEPRECATED_KEY,\n  ECHO_ANNOTATIONS_NS_KEY,\n  getNormalizedEchoAnnotations,\n  type JsonSchemaEchoAnnotations,\n  type JsonSchemaType,\n} from '../json-schema';\nimport { Expando } from '../object';\nimport { createEchoReferenceSchema, Ref, type JsonSchemaReferenceInfo } from '../ref';\n\n/**\n * Create object jsonSchema.\n */\nexport const createJsonSchema = (schema: Schema.Struct<any> = Schema.Struct({})): JsonSchemaType => {\n  const jsonSchema = _toJsonSchema(schema);\n\n  // TODO(dmaretskyi): Fix those in the serializer.\n  jsonSchema.type = 'object';\n  delete jsonSchema.anyOf;\n  return jsonSchema;\n};\n\n// TODO(burdon): Are these values stored (can they be changed?)\nexport enum PropType {\n  NONE = 0,\n  STRING = 1, // TODO(burdon): vs TEXT?\n  NUMBER = 2,\n  BOOLEAN = 3,\n  DATE = 4,\n  REF = 5,\n  RECORD = 6,\n  ENUM = 7,\n}\n\n// TODO(burdon): Reconcile with @dxos/schema.\nexport const toPropType = (type?: PropType): string => {\n  switch (type) {\n    case PropType.STRING:\n      return 'string';\n    case PropType.NUMBER:\n      return 'number';\n    case PropType.BOOLEAN:\n      return 'boolean';\n    case PropType.DATE:\n      return 'date';\n    case PropType.REF:\n      return 'ref';\n    case PropType.RECORD:\n      return 'object';\n    default:\n      throw new Error(`Invalid type: ${type}`);\n  }\n};\n\nconst JSON_SCHEMA_URL = 'http://json-schema.org/draft-07/schema#';\n\nexport type JsonSchemaOptions = {\n  strict?: boolean;\n};\n\n/**\n * Convert effect schema to JSON Schema.\n * @param schema\n */\nexport const toJsonSchema = (schema: Schema.Schema.All, options: JsonSchemaOptions = {}): JsonSchemaType => {\n  let jsonSchema = _toJsonSchema(schema);\n  if (options.strict) {\n    // TOOD(burdon): Workaround to ensure JSON schema is valid (for agv parsing).\n    jsonSchema = removeProperties(jsonSchema, (key, value) => {\n      if (key === '$id' && value === '/schemas/any') {\n        return true;\n      }\n      if (key === '$ref' && value === '#/$defs/dependency') {\n        return true;\n      }\n      if (key === '$ref' && value === '#/$defs/jsonSchema') {\n        return true;\n      }\n\n      return false;\n    });\n  }\n\n  return jsonSchema;\n};\n\nconst _toJsonSchema = (schema: Schema.Schema.All): JsonSchemaType => {\n  invariant(schema);\n  const withRefinements = withEchoRefinements(schema.ast, '#');\n  let jsonSchema = JSONSchema.fromAST(withRefinements, {\n    definitions: {},\n  }) as JsonSchemaType;\n\n  jsonSchema.$schema = JSON_SCHEMA_URL;\n\n  if (jsonSchema.properties && 'id' in jsonSchema.properties) {\n    jsonSchema.properties = orderKeys(jsonSchema.properties, ['id']); // Put id first.\n  }\n\n  const echoIdentifier = getTypeIdentifierAnnotation(schema);\n  if (echoIdentifier) {\n    jsonSchema.$id = echoIdentifier;\n  }\n\n  const objectAnnotation = getTypeAnnotation(schema);\n  if (objectAnnotation) {\n    // EchoIdentifier annotation takes precedence but the id can also be defined by the typename.\n    if (!jsonSchema.$id) {\n      // TODO(dmaretskyi): Should this include the version?\n      jsonSchema.$id = DXN.fromTypename(objectAnnotation.typename).toString();\n    }\n    jsonSchema.entityKind = objectAnnotation.kind;\n    jsonSchema.version = objectAnnotation.version;\n    jsonSchema.typename = objectAnnotation.typename;\n    if (jsonSchema.entityKind === EntityKind.Relation) {\n      jsonSchema.relationTarget = {\n        $ref: objectAnnotation.sourceSchema,\n      };\n      jsonSchema.relationSource = {\n        $ref: objectAnnotation.targetSchema,\n      };\n    }\n  }\n\n  // Fix field order.\n  // TODO(dmaretskyi): Makes sure undefined is not left on optional fields for the resulting object.\n  // TODO(dmaretskyi): `orderFields` util.\n  jsonSchema = orderKeys(jsonSchema, [\n    '$schema',\n    '$id',\n\n    'entityKind',\n    'typename',\n    'version',\n    'relationTarget',\n    'relationSource',\n\n    'type',\n    'enum',\n\n    'properties',\n    'required',\n    'propertyOrder', // Custom.\n    'items',\n    'additionalProperties',\n\n    'anyOf',\n    'oneOf',\n  ]);\n\n  return jsonSchema;\n};\n\nconst withEchoRefinements = (\n  ast: SchemaAST.AST,\n  path: string | undefined,\n  suspendCache = new Map<SchemaAST.AST, string>(),\n): SchemaAST.AST => {\n  if (path) {\n    suspendCache.set(ast, path);\n  }\n\n  let recursiveResult: SchemaAST.AST;\n  if (SchemaAST.isSuspend(ast)) {\n    // Precompute JSON schema for suspended AST since effect serializer does not support it.\n    const suspendedAst = ast.f();\n    const cachedPath = suspendCache.get(suspendedAst);\n    if (cachedPath) {\n      recursiveResult = new SchemaAST.Suspend(() => withEchoRefinements(suspendedAst, path, suspendCache), {\n        [SchemaAST.JSONSchemaAnnotationId]: {\n          $ref: cachedPath,\n        },\n      });\n    } else {\n      const jsonSchema = _toJsonSchema(Schema.make(suspendedAst));\n      recursiveResult = new SchemaAST.Suspend(() => withEchoRefinements(suspendedAst, path, suspendCache), {\n        [SchemaAST.JSONSchemaAnnotationId]: jsonSchema,\n      });\n    }\n  } else if (SchemaAST.isTypeLiteral(ast)) {\n    // Add property order annotations\n    recursiveResult = mapAst(ast, (ast, key) =>\n      withEchoRefinements(ast, path && typeof key === 'string' ? `${path}/${key}` : undefined, suspendCache),\n    );\n    recursiveResult = addJsonSchemaFields(recursiveResult, {\n      propertyOrder: [...ast.propertySignatures.map((p) => p.name)] as string[],\n    });\n  } else if (SchemaAST.isUndefinedKeyword(ast)) {\n    // Ignore undefined keyword that appears in the optional fields.\n    return ast;\n  } else {\n    recursiveResult = mapAst(ast, (ast, key) =>\n      withEchoRefinements(\n        ast,\n        path && (typeof key === 'string' || typeof key === 'number') ? `${path}/${key}` : undefined,\n        suspendCache,\n      ),\n    );\n  }\n\n  const annotationFields = annotations_toJsonSchemaFields(ast.annotations);\n  if (Object.keys(annotationFields).length === 0) {\n    return recursiveResult;\n  } else {\n    return addJsonSchemaFields(recursiveResult, annotationFields);\n  }\n};\n\n/**\n * Convert JSON schema to effect schema.\n * @param root\n * @param definitions\n */\nexport const toEffectSchema = (root: JsonSchemaType, _defs?: JsonSchemaType['$defs']): Schema.Schema.AnyNoContext => {\n  const defs = root.$defs ? { ..._defs, ...root.$defs } : _defs ?? {};\n  if ('type' in root && root.type === 'object') {\n    return objectToEffectSchema(root, defs);\n  }\n\n  let result: Schema.Schema.AnyNoContext = Schema.Unknown;\n  if ('$id' in root) {\n    switch (root.$id as string) {\n      case '/schemas/any': {\n        result = anyToEffectSchema(root as JSONSchema.JsonSchema7Any);\n        break;\n      }\n      case '/schemas/unknown': {\n        result = Schema.Unknown;\n        break;\n      }\n      case '/schemas/{}':\n      case '/schemas/object': {\n        result = Schema.Object;\n        break;\n      }\n      // Custom ECHO object reference.\n      case '/schemas/echo/ref': {\n        result = refToEffectSchema(root);\n      }\n    }\n  } else if ('enum' in root) {\n    result = Schema.Union(...root.enum!.map((e) => Schema.Literal(e)));\n  } else if ('oneOf' in root) {\n    result = Schema.Union(...root.oneOf!.map((v) => toEffectSchema(v, defs)));\n  } else if ('anyOf' in root) {\n    result = Schema.Union(...root.anyOf!.map((v) => toEffectSchema(v, defs)));\n  } else if ('type' in root) {\n    switch (root.type) {\n      case 'string': {\n        result = Schema.String;\n        if (root.pattern) {\n          result = result.pipe(Schema.pattern(new RegExp(root.pattern)));\n        }\n        break;\n      }\n      case 'number': {\n        result = Schema.Number;\n        break;\n      }\n      case 'integer': {\n        result = Schema.Number.pipe(Schema.int());\n        break;\n      }\n      case 'boolean': {\n        result = Schema.Boolean;\n        break;\n      }\n      case 'array': {\n        if (Array.isArray(root.items)) {\n          result = Schema.Tuple(...root.items.map((v) => toEffectSchema(v, defs)));\n        } else {\n          invariant(root.items);\n          const items = root.items;\n          result = Array.isArray(items)\n            ? Schema.Tuple(...items.map((v) => toEffectSchema(v, defs)))\n            : Schema.Array(toEffectSchema(items as JsonSchemaType, defs));\n        }\n        break;\n      }\n      case 'null': {\n        result = Schema.Null;\n        break;\n      }\n    }\n  } else if ('$ref' in root) {\n    const refSegments = root.$ref!.split('/');\n    const jsonSchema = defs[refSegments[refSegments.length - 1]];\n    invariant(jsonSchema, `missing definition for ${root.$ref}`);\n    result = toEffectSchema(jsonSchema, defs).pipe(\n      Schema.annotations({ identifier: refSegments[refSegments.length - 1] }),\n    );\n  }\n\n  const annotations = jsonSchemaFieldsToAnnotations(root);\n\n  // log.info('toEffectSchema', { root, annotations });\n  result = result.annotations(annotations);\n\n  return result;\n};\n\nconst objectToEffectSchema = (root: JsonSchemaType, defs: JsonSchemaType['$defs']): Schema.Schema.AnyNoContext => {\n  invariant('type' in root && root.type === 'object', `not an object: ${root}`);\n\n  const echoRefinement: JsonSchemaEchoAnnotations = (root as any)[ECHO_ANNOTATIONS_NS_DEPRECATED_KEY];\n  const isEchoObject =\n    echoRefinement != null || ('$id' in root && typeof root.$id === 'string' && root.$id.startsWith('dxn:'));\n\n  let fields: Schema.Struct.Fields = {};\n  const propertyList = Object.entries(root.properties ?? {});\n  let immutableIdField: Schema.Schema.AnyNoContext | undefined;\n  for (const [key, value] of propertyList) {\n    if (isEchoObject && key === 'id') {\n      immutableIdField = toEffectSchema(value, defs);\n    } else {\n      // TODO(burdon): Mutable cast.\n      (fields as any)[key] = root.required?.includes(key)\n        ? toEffectSchema(value, defs)\n        : Schema.optional(toEffectSchema(value, defs));\n    }\n  }\n\n  if (root.propertyOrder) {\n    fields = orderKeys(fields, root.propertyOrder as any);\n  }\n\n  let schema: Schema.Schema<any, any, unknown>;\n  if (root.patternProperties) {\n    invariant(propertyList.length === 0, 'pattern properties mixed with regular properties are not supported');\n    invariant(\n      Object.keys(root.patternProperties).length === 1 && Object.keys(root.patternProperties)[0] === '',\n      'only one pattern property is supported',\n    );\n\n    schema = Schema.Record({ key: Schema.String, value: toEffectSchema(root.patternProperties[''], defs) });\n  } else if (typeof root.additionalProperties !== 'object') {\n    schema = Schema.Struct(fields);\n  } else {\n    const indexValue = toEffectSchema(root.additionalProperties, defs);\n    if (propertyList.length > 0) {\n      schema = Schema.Struct(fields, { key: Schema.String, value: indexValue });\n    } else {\n      schema = Schema.Record({ key: Schema.String, value: indexValue });\n    }\n  }\n\n  if (immutableIdField) {\n    schema = Schema.extend(Schema.mutable(schema), Schema.Struct({ id: immutableIdField }));\n  }\n\n  const annotations = jsonSchemaFieldsToAnnotations(root);\n  return schema.annotations(annotations) as any;\n};\n\nconst anyToEffectSchema = (root: JSONSchema.JsonSchema7Any): Schema.Schema.AnyNoContext => {\n  const echoRefinement: JsonSchemaEchoAnnotations = (root as any)[ECHO_ANNOTATIONS_NS_DEPRECATED_KEY];\n  // TODO(dmaretskyi): Is this branch still taken?\n  if ((echoRefinement as any)?.reference != null) {\n    const echoId = root.$id.startsWith('dxn:echo:') ? root.$id : undefined;\n    return createEchoReferenceSchema(\n      echoId,\n      (echoRefinement as any).reference.typename,\n      (echoRefinement as any).reference.version,\n    );\n  }\n\n  return Schema.Any;\n};\n\n// TODO(dmaretskyi): Types.\nconst refToEffectSchema = (root: any): Schema.Schema.AnyNoContext => {\n  if (!('reference' in root)) {\n    return Ref(Expando);\n  }\n  const reference: JsonSchemaReferenceInfo = root.reference;\n  if (typeof reference !== 'object') {\n    throw new Error('Invalid reference field in ref schema');\n  }\n\n  const targetSchemaDXN = DXN.parse(reference.schema.$ref);\n  invariant(targetSchemaDXN.kind === DXN.kind.TYPE);\n\n  return createEchoReferenceSchema(\n    targetSchemaDXN.toString(),\n    targetSchemaDXN.kind === DXN.kind.TYPE ? targetSchemaDXN.parts[0] : undefined,\n    reference.schemaVersion,\n  );\n};\n\n//\n// Annotations\n//\n\nconst annotations_toJsonSchemaFields = (annotations: SchemaAST.Annotations): Record<symbol, any> => {\n  const schemaFields: Record<string, any> = {};\n\n  const echoAnnotations: JsonSchemaEchoAnnotations = {};\n  for (const [key, annotationId] of Object.entries(EchoAnnotations)) {\n    if (annotations[annotationId] != null) {\n      echoAnnotations[key as keyof JsonSchemaEchoAnnotations] = annotations[annotationId] as any;\n    }\n  }\n  if (Object.keys(echoAnnotations).length > 0) {\n    // TODO(dmaretskyi): use new namespace.\n    schemaFields[ECHO_ANNOTATIONS_NS_KEY] = echoAnnotations;\n  }\n\n  const echoIdentifier = annotations[TypeIdentifierAnnotationId];\n  if (echoIdentifier) {\n    schemaFields[ECHO_ANNOTATIONS_NS_KEY] ??= {};\n    schemaFields[ECHO_ANNOTATIONS_NS_KEY].schemaId = echoIdentifier;\n  }\n\n  // Custom (at end).\n  for (const [key, annotationId] of Object.entries(CustomAnnotations)) {\n    const value = annotations[annotationId];\n    if (value != null) {\n      schemaFields[key] = value;\n    }\n  }\n\n  return schemaFields;\n};\n\nconst decodeTypeIdentifierAnnotation = (schema: JsonSchemaType): string | undefined => {\n  // Limit to dxn:echo: URIs.\n  if (schema.$id && schema.$id.startsWith('dxn:echo:')) {\n    return schema.$id;\n  } else if (schema.$id && schema.$id.startsWith('dxn:type:') && schema?.echo?.type?.schemaId) {\n    const id = schema?.echo?.type?.schemaId;\n    if (ObjectId.isValid(id)) {\n      return DXN.fromLocalObjectId(id).toString();\n    }\n  }\n  return undefined;\n};\n\nconst decodeTypeAnnotation = (schema: JsonSchemaType): TypeAnnotation | undefined => {\n  if (schema.typename) {\n    const annotation: Mutable<TypeAnnotation> = {\n      // TODO(dmaretskyi): Decoding default.\n      kind: schema.entityKind ? Schema.decodeSync(EntityKindSchema)(schema.entityKind) : EntityKind.Object,\n      typename: schema.typename,\n      version: schema.version ?? '0.1.0',\n    };\n\n    if (annotation.kind === EntityKind.Relation) {\n      const source = schema.relationSource?.$ref ?? raise(new Error('Relation source not set'));\n      const target = schema.relationTarget?.$ref ?? raise(new Error('Relation target not set'));\n      annotation.sourceSchema = DXN.parse(source).toString();\n      annotation.targetSchema = DXN.parse(target).toString();\n    }\n\n    return annotation;\n  }\n\n  // Decode legacy schema.\n  if (!schema.typename && schema?.echo?.type) {\n    return {\n      kind: EntityKind.Object,\n      typename: schema.echo.type.typename,\n      version: schema.echo.type.version,\n    };\n  }\n\n  return undefined;\n};\n\nconst jsonSchemaFieldsToAnnotations = (schema: JsonSchemaType): SchemaAST.Annotations => {\n  const annotations: Types.Mutable<Schema.Annotations.Schema<any>> = {};\n\n  const echoAnnotations: JsonSchemaEchoAnnotations = getNormalizedEchoAnnotations(schema) ?? {};\n  if (echoAnnotations) {\n    for (const [key, annotationId] of Object.entries(EchoAnnotations)) {\n      if (echoAnnotations[key as keyof JsonSchemaEchoAnnotations]) {\n        annotations[annotationId] = echoAnnotations[key as keyof JsonSchemaEchoAnnotations];\n      }\n    }\n  }\n\n  annotations[TypeIdentifierAnnotationId] = decodeTypeIdentifierAnnotation(schema);\n  annotations[TypeAnnotationId] = decodeTypeAnnotation(schema);\n\n  // Custom (at end).\n  for (const [key, annotationId] of Object.entries({ ...CustomAnnotations, ...DecodedAnnotations })) {\n    if (key in schema) {\n      annotations[annotationId] = (schema as any)[key];\n    }\n  }\n\n  return clearUndefined(annotations);\n};\n\nconst makeAnnotatedRefinement = (ast: SchemaAST.AST, annotations: SchemaAST.Annotations): SchemaAST.Refinement => {\n  return new SchemaAST.Refinement(ast, () => Option.none(), annotations);\n};\n\nconst addJsonSchemaFields = (ast: SchemaAST.AST, schema: JsonSchemaType): SchemaAST.AST =>\n  makeAnnotatedRefinement(ast, { [SchemaAST.JSONSchemaAnnotationId]: schema });\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { SchemaAST } from 'effect';\n\nimport { GeneratorAnnotationId, LabelAnnotationId, PropertyMetaAnnotationId } from '../ast';\nimport { FormatAnnotationId, CurrencyAnnotationId } from '../formats';\nimport { type JsonSchemaEchoAnnotations, type JsonSchemaType } from '../json-schema';\n\n//\n// This file configures annotations for JSON encoding/decoding.\n//\n\n// Go on the root level.\ntype RootJsonSchemaProperty = keyof JsonSchemaType;\n\n// Go on the namespaced `annotations` property.\ntype NamespacedJsonSchemaProperty = keyof JsonSchemaEchoAnnotations;\n\n/**\n * List of annotations for JSON encoding/decoding.\n * Omits default effect-schema annotations since they are encoded with default serializer.\n */\n// TODO(burdon): Reconcile with `EchoAnnotations`.\nexport const CustomAnnotations: Partial<Record<RootJsonSchemaProperty, symbol>> = {\n  format: FormatAnnotationId,\n  currency: CurrencyAnnotationId,\n};\n\n/**\n * List of annotations for JSON decoding only.\n * Includes default effect annotations.\n */\nexport const DecodedAnnotations: Partial<Record<RootJsonSchemaProperty, symbol>> = {\n  title: SchemaAST.TitleAnnotationId,\n  description: SchemaAST.DescriptionAnnotationId,\n};\n\n/**\n * Annotations that go into ECHO namespace in json-schema.\n */\n// TODO(dmaretskyi): Consider removing ECHO namespace and putting them at the top level.\n// TODO(dmaretskyi): Move to format.ts when circular imports are solved\nexport const EchoAnnotations: Partial<Record<NamespacedJsonSchemaProperty, symbol>> = {\n  // TODO(dmaretskyi): `FieldLookupAnnotationId` might go here, but lets remove it entirely and use LabelAnnotation instead.\n  meta: PropertyMetaAnnotationId,\n  generator: GeneratorAnnotationId,\n  labelProp: LabelAnnotationId,\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { Schema } from 'effect';\n\nimport { JsonPath, type JsonProp } from '@dxos/effect';\n\nimport { EntityKindSchema } from '../ast';\nimport { FormatAnnotation, FormatEnum } from '../formats';\n\n//\n// JSON Schema\n//\n\n// TODO(burdon): Reuse/reconcile with ScalarTypeEnum (handle arrays).\nconst SimpleTypes = Schema.Literal('array', 'boolean', 'integer', 'null', 'number', 'object', 'string');\n\nconst NonNegativeInteger = Schema.Number.pipe(Schema.greaterThanOrEqualTo(0));\n\nconst StringArray = Schema.Array(Schema.String).pipe(Schema.mutable);\n\nconst JsonSchemaOrBoolean = Schema.Union(\n  Schema.suspend(() => JsonSchemaType),\n  Schema.Boolean,\n);\n\n/**\n * Go under the `annotations` property.\n */\nexport const JsonSchemaEchoAnnotations = Schema.Struct({\n  /**\n   * Label for this schema.\n   * Mapped from {@link LabelAnnotationId}.\n   */\n  labelProp: Schema.optional(Schema.Union(JsonPath, Schema.Array(JsonPath))),\n\n  /**\n   * Generator function for this schema.\n   * Mapped from {@link GeneratorAnnotationId}.\n   */\n  generator: Schema.optional(Schema.Union(Schema.String, Schema.Tuple(Schema.String, Schema.Number))),\n\n  /**\n   * {@link PropertyMeta} annotations get serialized here.\n   */\n  meta: Schema.optional(\n    Schema.Record({\n      key: Schema.String,\n      value: Schema.Any,\n    }).pipe(Schema.mutable),\n  ),\n\n  /**\n   * @deprecated\n   */\n  // TODO(dmaretskyi): We risk old schema not passing validation due to the extra fields. Remove when we are sure this is safe\n  type: Schema.optional(\n    Schema.Struct({\n      typename: Schema.String,\n      version: Schema.String,\n\n      // Not used.\n      schemaId: Schema.optional(Schema.String),\n    }).pipe(Schema.mutable),\n  ),\n\n  /**\n   * @deprecated Superseded by `meta`.\n   */\n  annotations: Schema.optional(\n    Schema.Record({\n      key: Schema.String,\n      value: Schema.Any,\n    }).pipe(Schema.mutable),\n  ),\n}).pipe(Schema.mutable);\nexport type JsonSchemaEchoAnnotations = Schema.Schema.Type<typeof JsonSchemaEchoAnnotations>;\n\n/**\n * Describes a schema for the JSON-schema objects stored in ECHO.\n * Contains extensions for ECHO (e.g., references).\n * Ref: https://json-schema.org/draft-07/schema\n */\n// TODO(burdon): Integrate with Effect Serializable?\n// TODO(dmaretskyi): Update to latest draft: https://json-schema.org/draft/2020-12\nconst _JsonSchemaType = Schema.Struct({\n  /**\n   * Identifier for this schema.\n   * This schema might be referenced by $ref clause in other schemas.\n   */\n  // TODO(dmaretskyi): Specify how the ids are generated.\n  // TODO(dmaretskyi): For type dxns, should this include the version?\n  $id: Schema.optional(Schema.String),\n\n  /**\n   * Schema of this schema.\n   * Set to \"https://json-schema.org/draft-07/schema\".\n   */\n  $schema: Schema.optional(Schema.String),\n\n  /**\n   * Reference to another schema.\n   */\n  $ref: Schema.optional(Schema.String),\n\n  /**\n   * Comments are ignored when interpreting the schema.\n   */\n  $comment: Schema.optional(Schema.String),\n\n  /**\n   * Defines whether this schema is an object schema or a relation schema.\n   */\n  entityKind: Schema.optional(EntityKindSchema),\n\n  /**\n   * Typename of this schema.\n   * Only on schema representing an ECHO object.\n   *\n   * @example 'example.com/type/MyType'\n   */\n  typename: Schema.optional(Schema.String),\n\n  /**\n   * Version of this schema.\n   * Custom dialect for ECHO.\n   */\n  version: Schema.optional(Schema.String),\n\n  /**\n   * Target of this relation.\n   * Only for relation schemas.\n   * The referenced schema must be an object schema.\n   */\n  relationTarget: Schema.optional(Schema.suspend(() => JsonSchemaType)),\n\n  /**\n   * Source of this relation.\n   * Only for relation schemas.\n   * The referenced schema must be an object schema.\n   */\n  relationSource: Schema.optional(Schema.suspend(() => JsonSchemaType)),\n\n  /**\n   * Title of this schema.\n   */\n  title: Schema.optional(Schema.String),\n\n  /**\n   * Description of this schema.\n   */\n  description: Schema.optional(Schema.String),\n\n  /**\n   * Whether this schema is read-only.\n   */\n  readOnly: Schema.optional(Schema.Boolean),\n\n  /**\n   * Whether this schema is write-only.\n   */\n  writeOnly: Schema.optional(Schema.Boolean),\n\n  /**\n   * Examples of instances of this schema.\n   */\n  examples: Schema.optional(Schema.Array(Schema.Any)),\n\n  /**\n   * Default value for this schema.\n   */\n  default: Schema.optional(Schema.Any),\n\n  /**\n   * This schema only matches values that are equal to this value.\n   */\n  const: Schema.optional(Schema.Any),\n\n  /**\n   * This schema only matches one of the values in this array.\n   */\n  enum: Schema.optional(Schema.Array(Schema.Any)),\n\n  /**\n   * Base type of the schema.\n   */\n  type: Schema.optional(Schema.Union(SimpleTypes, Schema.Array(SimpleTypes))),\n\n  //\n  // Numbers.\n  //\n\n  multipleOf: Schema.optional(Schema.Number.pipe(Schema.greaterThan(0))),\n  maximum: Schema.optional(Schema.Number),\n  exclusiveMaximum: Schema.optional(Schema.Number),\n  minimum: Schema.optional(Schema.Number),\n  exclusiveMinimum: Schema.optional(Schema.Number),\n\n  //\n  // Strings.\n  //\n\n  maxLength: Schema.optional(NonNegativeInteger),\n\n  /**\n   * Regex pattern for strings.\n   */\n  pattern: Schema.optional(Schema.String.pipe(FormatAnnotation.set(FormatEnum.Regex))),\n\n  /**\n   * Serialized from {@link FormatAnnotationId}.\n   */\n  format: Schema.optional(Schema.String),\n\n  //\n  // Arrays\n  //\n\n  minLength: Schema.optional(NonNegativeInteger),\n  items: Schema.optional(\n    Schema.Union(\n      Schema.suspend(() => JsonSchemaType),\n      Schema.Array(Schema.suspend(() => JsonSchemaType)),\n    ),\n  ),\n  additionalItems: Schema.optional(\n    Schema.Union(\n      Schema.suspend(() => JsonSchemaType),\n      Schema.Boolean,\n    ),\n  ),\n  maxItems: Schema.optional(NonNegativeInteger),\n  minItems: Schema.optional(NonNegativeInteger),\n  uniqueItems: Schema.optional(Schema.Boolean),\n  contains: Schema.optional(Schema.suspend(() => JsonSchemaType)),\n\n  //\n  // Objects\n  //\n\n  maxProperties: Schema.optional(NonNegativeInteger),\n  minProperties: Schema.optional(NonNegativeInteger),\n  required: Schema.optional(StringArray),\n\n  /**\n   * Non-standard JSON Schema extension.\n   * Defines the order of properties in the object.\n   * The unmentioned properties are placed at the end.\n   *\n   * Related: https://github.com/json-schema/json-schema/issues/119\n   */\n  propertyOrder: Schema.optional(StringArray),\n\n  additionalProperties: Schema.optional(JsonSchemaOrBoolean),\n  properties: Schema.optional(\n    Schema.Record({\n      key: Schema.String,\n      value: Schema.suspend(() => JsonSchemaType),\n    }).pipe(Schema.mutable),\n  ),\n  patternProperties: Schema.optional(\n    Schema.Record({\n      key: Schema.String,\n      value: Schema.suspend(() => JsonSchemaType),\n    }).pipe(Schema.mutable),\n  ),\n  propertyNames: Schema.optional(Schema.suspend(() => JsonSchemaType)),\n\n  definitions: Schema.optional(\n    Schema.mutable(\n      Schema.Record({\n        key: Schema.String,\n        value: Schema.suspend(() => JsonSchemaType),\n      }),\n    ),\n  ),\n  dependencies: Schema.optional(\n    Schema.Record({\n      key: Schema.String,\n      value: Schema.suspend(() => Schema.Union(Schema.String, StringArray, JsonSchemaType)).annotations({\n        identifier: 'dependency',\n        description: 'Dependency',\n      }),\n    }),\n  ),\n\n  contentMediaType: Schema.optional(Schema.String),\n  contentEncoding: Schema.optional(Schema.String),\n\n  if: Schema.optional(Schema.suspend(() => JsonSchemaType)),\n  then: Schema.optional(Schema.suspend(() => JsonSchemaType)),\n  else: Schema.optional(Schema.suspend(() => JsonSchemaType)),\n  allOf: Schema.optional(Schema.Array(Schema.suspend(() => JsonSchemaType))),\n  anyOf: Schema.optional(Schema.Array(Schema.suspend(() => JsonSchemaType))),\n  oneOf: Schema.optional(Schema.Array(Schema.suspend(() => JsonSchemaType))),\n  not: Schema.optional(Schema.suspend(() => JsonSchemaType)),\n  $defs: Schema.optional(\n    Schema.mutable(\n      Schema.Record({\n        key: Schema.String,\n        value: Schema.suspend(() => JsonSchemaType),\n      }),\n    ),\n  ),\n\n  //\n  // ECHO extensions.\n  //\n\n  currency: Schema.optional(Schema.String),\n\n  reference: Schema.optional(\n    Schema.mutable(\n      Schema.Struct({\n        schema: Schema.suspend(() => JsonSchemaType),\n        schemaVersion: Schema.optional(Schema.String),\n        schemaObject: Schema.optional(Schema.String),\n      }),\n    ),\n  ),\n\n  /**\n   * ECHO-specific annotations.\n   */\n  // TODO(dmaretskyi): Since we are adding a lot of new extensions to the JSON Schema, it is safer to namespace them here.\n  annotations: Schema.optional(Schema.mutable(JsonSchemaEchoAnnotations)),\n\n  /**\n   * @deprecated Use `annotations` instead.\n   */\n  echo: Schema.optional(Schema.mutable(JsonSchemaEchoAnnotations)),\n}).annotations({ identifier: 'jsonSchema', description: 'JSON Schema' });\n\nexport const JsonSchemaFields = Object.keys(_JsonSchemaType.fields);\n\n/**\n * https://json-schema.org/draft-07/schema\n */\nexport interface JsonSchemaType extends Schema.Schema.Type<Schema.mutable<typeof _JsonSchemaType>> {}\n\nexport const JsonSchemaType: Schema.Schema<JsonSchemaType> = _JsonSchemaType.pipe(Schema.mutable);\n\n// TODO(burdon): Factor out JSON schema utils.\n\nexport const getSchemaProperty = (schema: JsonSchemaType, property: JsonProp): JsonSchemaType | undefined => {\n  return schema.properties?.[property];\n};\n\n// TODO(burdon): Properties should be ordered.\nexport const setSchemaProperty = (schema: JsonSchemaType, property: JsonProp, value: JsonSchemaType) => {\n  schema.properties ??= {};\n  schema.properties[property] = value;\n  return schema;\n};\n\n/**\n * @internal\n */\nexport const ECHO_ANNOTATIONS_NS_DEPRECATED_KEY: keyof JsonSchemaType = 'echo';\n\n/**\n * @internal\n */\nexport const ECHO_ANNOTATIONS_NS_KEY = 'annotations';\n\n/**\n * @internal\n * @returns ECHO annotations namespace object in its normalized form.\n *\n * `meta` holds PropertyMeta annotations.\n * `annotations` holds other annotations.\n */\nexport const getNormalizedEchoAnnotations = (obj: JsonSchemaType): JsonSchemaEchoAnnotations | undefined => {\n  if (obj[ECHO_ANNOTATIONS_NS_KEY] != null && obj[ECHO_ANNOTATIONS_NS_DEPRECATED_KEY] != null) {\n    return normalizeEchoAnnotations({\n      ...obj[ECHO_ANNOTATIONS_NS_DEPRECATED_KEY],\n      ...obj[ECHO_ANNOTATIONS_NS_KEY],\n    });\n  } else if (obj[ECHO_ANNOTATIONS_NS_KEY] != null) {\n    return normalizeEchoAnnotations(obj[ECHO_ANNOTATIONS_NS_KEY]!);\n  } else if (obj[ECHO_ANNOTATIONS_NS_DEPRECATED_KEY] != null) {\n    return normalizeEchoAnnotations(obj[ECHO_ANNOTATIONS_NS_DEPRECATED_KEY]!);\n  } else {\n    return undefined;\n  }\n};\n\nconst normalizeEchoAnnotations = (obj: JsonSchemaEchoAnnotations): JsonSchemaEchoAnnotations => {\n  if (!obj.annotations) {\n    return obj;\n  } else {\n    const res = {\n      ...obj,\n      meta: {\n        ...obj.annotations,\n        ...(obj.meta ?? {}),\n      },\n    };\n    delete res.annotations;\n    return res;\n  }\n};\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { JsonSchemaFields, type JsonSchemaType } from './json-schema-type';\n\n/**\n * Normalize schema to to draft-07 format.\n * Note: the input type does not necessarily match the {@link JsonSchemaType} type.\n */\nexport const normalizeSchema = (schema: JsonSchemaType): JsonSchemaType => {\n  const copy = structuredClone(schema);\n  go(copy);\n  return copy;\n};\n\nconst go = (schema: JsonSchemaType) => {\n  if (typeof schema !== 'object' || schema === null) {\n    return;\n  }\n\n  if ((schema as any).exclusiveMaximum === true) {\n    schema.exclusiveMaximum = schema.maximum;\n    delete (schema as any).exclusiveMaximum;\n  } else if ((schema as any).exclusiveMaximum === false) {\n    delete (schema as any).exclusiveMaximum;\n  }\n\n  if ((schema as any).exclusiveMinimum === true) {\n    schema.exclusiveMinimum = schema.minimum;\n    delete (schema as any).exclusiveMinimum;\n  } else if ((schema as any).exclusiveMinimum === false) {\n    delete (schema as any).exclusiveMinimum;\n  }\n\n  // Delete all properties that are not in the JsonSchemaFields.\n  for (const key of Object.keys(schema)) {\n    if (!JsonSchemaFields.includes(key)) {\n      delete (schema as any)[key];\n    }\n  }\n\n  // Recursively normalize the schema.\n  // Recursively normalize the schema.\n  if (schema.properties) {\n    goOnRecord(schema.properties);\n  }\n  if (schema.patternProperties) {\n    goOnRecord(schema.patternProperties);\n  }\n  if (schema.propertyNames) {\n    go(schema.propertyNames);\n  }\n  if (schema.definitions) {\n    goOnRecord(schema.definitions);\n  }\n  if (schema.items) {\n    maybeGoOnArray(schema.items);\n  }\n  if (schema.additionalItems) {\n    maybeGoOnArray(schema.additionalItems);\n  }\n  if (schema.contains) {\n    go(schema.contains);\n  }\n  if (schema.if) {\n    go(schema.if);\n  }\n  if (schema.then) {\n    go(schema.then);\n  }\n  if (schema.else) {\n    go(schema.else);\n  }\n  if (schema.allOf) {\n    maybeGoOnArray(schema.allOf);\n  }\n  if (schema.anyOf) {\n    maybeGoOnArray(schema.anyOf);\n  }\n  if (schema.oneOf) {\n    maybeGoOnArray(schema.oneOf);\n  }\n  if (schema.not) {\n    go(schema.not);\n  }\n  if (schema.$defs) {\n    goOnRecord(schema.$defs);\n  }\n  if (schema.reference) {\n    go(schema.reference.schema);\n  }\n};\n\nconst maybeGoOnArray = (value: any) => {\n  if (Array.isArray(value)) {\n    for (const item of value) {\n      go(item);\n    }\n  } else if (typeof value === 'object' && value !== null) {\n    go(value);\n  }\n};\n\nconst goOnRecord = (record: Record<string, any>) => {\n  for (const key of Object.keys(record)) {\n    go(record[key]);\n  }\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { Schema } from 'effect';\n\n// TODO(ZaymonFC): Where should this live?\nconst SortDirection = Schema.Union(Schema.Literal('asc'), Schema.Literal('desc'));\nexport type SortDirectionType = Schema.Schema.Type<typeof SortDirection>;\n\n// TODO(ZaymonFC): Struct vs pair?\nconst FieldSort = Schema.Struct({\n  fieldId: Schema.String,\n  direction: SortDirection,\n}).pipe(Schema.mutable);\n\nexport interface FieldSortType extends Schema.Schema.Type<typeof FieldSort> {}\n\nexport const FieldSortType: Schema.Schema<FieldSortType> = FieldSort;\n\n/**\n * ECHO query object.\n */\nconst QuerySchema = Schema.Struct({\n  typename: Schema.optional(Schema.String),\n  sort: Schema.optional(Schema.Array(FieldSort)),\n}).pipe(Schema.mutable);\n\nexport interface QueryType extends Schema.Schema.Type<typeof QuerySchema> {}\n\nexport const QueryType: Schema.Schema<QueryType> = QuerySchema;\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { SchemaAST, Schema } from 'effect';\n\nimport { Reference } from '@dxos/echo-protocol';\nimport { splitJsonPath, type JsonPath } from '@dxos/effect';\nimport { DXN } from '@dxos/keys';\nimport { getDeep, setDeep } from '@dxos/util';\n\nimport { getSchemaDXN } from '../ast';\nimport { getType, getTypename, type ObjectMeta, type EntityKindId } from '../object';\nimport { ATTR_META } from '../object/model';\n\n/**\n * Base type for all data objects (reactive, ECHO, and other raw objects).\n * NOTE: This describes the base type for all database objects.\n * It is stricter than `T extends {}` or `T extends object`.\n */\n// TODO(dmaretskyi): Rename AnyProperties.\nexport type BaseObject = Record<string, any>;\n\n/**\n * Marker interface for object with an `id`.\n */\nexport type HasId = {\n  readonly id: string;\n};\n\n// TODO(burdon): Reconcile with AnyLiveObject. This type is used in some places (e.g. Ref) to mean LiveObject? Do we need branded types?\nexport type WithId = BaseObject & HasId;\n\nexport type ExcludeId<T extends BaseObject> = Omit<T, 'id'>;\n\nexport type CreationProps<T extends BaseObject> = Omit<T, 'id' | typeof EntityKindId>;\n\nexport type PropertyKey<T extends BaseObject> = Extract<keyof ExcludeId<T>, string>;\n\nexport type WithMeta = { [ATTR_META]?: ObjectMeta };\n\n/**\n * The raw object should not include the ECHO id, but may include metadata.\n */\nexport const RawObject = <S extends Schema.Schema.AnyNoContext>(\n  schema: S,\n): Schema.Schema<ExcludeId<Schema.Schema.Type<S>> & WithMeta, Schema.Schema.Encoded<S>> => {\n  return Schema.make(SchemaAST.omit(schema.ast, ['id']));\n};\n\n//\n// Data\n//\n\n/**\n * @deprecated No longer used.\n */\nexport interface CommonObjectData {\n  id: string;\n  // TODO(dmaretskyi): Document cases when this can be null.\n  // TODO(dmaretskyi): Convert to @typename and @meta.\n  __typename: string | null;\n  __meta: ObjectMeta;\n}\n\n/**\n * @deprecated No longer used.\n */\nexport interface AnyObjectData extends CommonObjectData {\n  /**\n   * Fields of the object.\n   */\n  [key: string]: any;\n}\n\n/**\n * Object data type in JSON-encodable format.\n * References are encoded in the IPLD format.\n * `__typename` is the string DXN of the object type.\n * Meta is added under `__meta` key.\n * @deprecated No longer used.\n */\nexport type ObjectData<S> = Schema.Schema.Encoded<S> & CommonObjectData;\n\n//\n// Utils\n//\n\n/**\n * Utility to split meta property from raw object.\n * @deprecated Bad API.\n */\nexport const splitMeta = <T>(object: T & WithMeta): { object: T; meta?: ObjectMeta } => {\n  const meta = object[ATTR_META];\n  delete object[ATTR_META];\n  return { meta, object };\n};\n\n// TODO(burdon): Move to `@dxos/util`.\nexport const getValue = <T extends object>(obj: T, path: JsonPath): any => {\n  return getDeep(\n    obj,\n    splitJsonPath(path).map((p) => p.replace(/[[\\]]/g, '')),\n  );\n};\n\n// TODO(burdon): Move to `@dxos/util`.\nexport const setValue = <T extends object>(obj: T, path: JsonPath, value: any): T => {\n  return setDeep(\n    obj,\n    splitJsonPath(path).map((p) => p.replace(/[[\\]]/g, '')),\n    value,\n  );\n};\n\n/**\n * Returns a reference that will be used to point to a schema.\n * @deprecated Use {@link getSchemaDXN} instead.\n */\nexport const getTypeReference = (schema: Schema.Schema.All | undefined): Reference | undefined => {\n  if (!schema) {\n    return undefined;\n  }\n\n  const schemaDXN = getSchemaDXN(schema);\n  if (!schemaDXN) {\n    return undefined;\n  }\n  return Reference.fromDXN(schemaDXN);\n};\n\n/**\n * Returns a reference that will be used to point to a schema.\n * @throws If it is not possible to reference this schema.\n *\n * @deprecated Use {@link getSchemaDXN} instead.\n */\nexport const requireTypeReference = (schema: Schema.Schema.AnyNoContext): Reference => {\n  const typeReference = getTypeReference(schema);\n  if (typeReference == null) {\n    // TODO(burdon): Catalog user-facing errors (this is too verbose).\n    throw new Error('Schema must be defined via TypedObject.');\n  }\n\n  return typeReference;\n};\n\n// TODO(burdon): Can we use `Schema.is`?\n/**\n * Checks if the object is an instance of the schema.\n * Only typename is compared, the schema version is ignored.\n *\n * The following cases are considered to mean that the object is an instance of the schema:\n *  - Object was created with this exact schema.\n *  - Object was created with a different version of this schema.\n *  - Object was created with a different schema (maybe dynamic) that has the same typename.\n */\nexport const isInstanceOf = <Schema extends Schema.Schema.AnyNoContext>(\n  schema: Schema,\n  object: any,\n): object is Schema.Schema.Type<Schema> => {\n  if (object == null) {\n    return false;\n  }\n\n  const schemaDXN = getSchemaDXN(schema);\n  if (!schemaDXN) {\n    throw new Error('Schema must have an object annotation.');\n  }\n\n  const type = getType(object);\n  if (type && DXN.equals(type, schemaDXN)) {\n    return true;\n  }\n\n  const typename = getTypename(object);\n  if (!typename) {\n    return false;\n  }\n\n  const typeDXN = schemaDXN.asTypeDXN();\n  if (!typeDXN) {\n    return false;\n  }\n\n  return typeDXN.type === typename;\n};\n\n/**\n * Object that has an associated typename.\n * The typename is retrievable using {@link getTypename}.\n * The object can be used with {@link isInstanceOf} to check if it is an instance of a schema.\n */\nexport type HasTypename = {};\n\n/**\n * Canonical type for all ECHO objects.\n * @deprecated Use `AnyEchoObject` instead.\n */\nexport interface BaseEchoObject extends HasId, HasTypename {}\n\n// TODO(burdon): Reconcile with Type.Any.\nexport interface AnyEchoObject extends BaseEchoObject {}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { invariant } from '@dxos/invariant';\n\nimport { type JsonSchemaType } from '../json-schema';\nimport { getSnapshot } from '../schema';\n\n/**\n * Creates a composite schema from the source and projection schemas.\n */\n// TODO(burdon): Use effect schema projections.\n// TODO(burdon): Can avoid having to call this every time we modify any property on the view?\nexport const composeSchema = (source: JsonSchemaType, target: JsonSchemaType): JsonSchemaType => {\n  const result: JsonSchemaType = getSnapshot(target);\n  invariant('type' in result && result.type === 'object', 'source schema must be an object');\n  invariant('type' in source && source.type === 'object', 'target schema must be an object');\n\n  for (const prop in result.properties) {\n    const propSchema = source.properties![prop]; // TODO(dmaretskyi): Find by json-path instead.\n    const annotations = (propSchema as JsonSchemaType)?.annotations?.meta;\n    if (annotations) {\n      (result.properties[prop] as JsonSchemaType).annotations ??= {};\n      (result.properties[prop] as JsonSchemaType).annotations!.meta ??= {};\n      for (const key in annotations) {\n        (result.properties[prop] as JsonSchemaType).annotations!.meta![key] ??= {};\n        Object.assign((result.properties[prop] as JsonSchemaType).annotations!.meta![key], annotations[key], {\n          ...(result.properties[prop] as JsonSchemaType).annotations!.meta![key],\n        });\n      }\n    }\n  }\n\n  return result;\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { Schema, SchemaAST } from 'effect';\n\nimport { invariant } from '@dxos/invariant';\nimport { type ObjectId } from '@dxos/keys';\n\nimport {\n  addFieldsToSchema,\n  removeFieldsFromSchema,\n  setTypenameInSchema,\n  updateFieldNameInSchema,\n  updateFieldsInSchema,\n} from './manipulation';\nimport { getSnapshot } from './snapshot';\nimport { StoredSchema } from './stored-schema';\nimport { getTypeAnnotation, SchemaMetaSymbol, type SchemaMeta, type TypeAnnotation } from '../ast';\nimport { toEffectSchema, toJsonSchema } from '../json';\nimport { type JsonSchemaType } from '../json-schema';\nimport { type TypedObject, type TypedObjectPrototype } from '../object';\n\n/**\n * Base schema type.\n */\n// TODO(burdon): Merge with ImmutableSchema.\nexport interface BaseSchema<A = any, I = any> extends TypedObject<A, I> {\n  get readonly(): boolean;\n  // TODO(burdon): Change to external function.\n  get mutable(): EchoSchema<A, I>;\n  get snapshot(): Schema.Schema<A, I>;\n  get jsonSchema(): JsonSchemaType;\n}\n\n/**\n * Immutable schema type.\n * @deprecated Use `Schema.Schema.AnyNoContext` instead.\n */\n// TODO(burdon): Common abstract base class?\nexport class ImmutableSchema<A = any, I = any> implements BaseSchema<A, I> {\n  private readonly _objectAnnotation: TypeAnnotation;\n  constructor(private readonly _schema: Schema.Schema<A, I>) {\n    this._objectAnnotation = getTypeAnnotation(this._schema)!;\n    invariant(this._objectAnnotation);\n  }\n\n  //\n  // Effect Schema (push to abstract base class).\n  //\n\n  public get [Schema.TypeId]() {\n    return schemaVariance;\n  }\n\n  public get Type() {\n    return this._schema.Type;\n  }\n\n  public get Encoded() {\n    return this._schema.Encoded;\n  }\n\n  public get Context() {\n    return this._schema.Context;\n  }\n\n  public get ast(): SchemaAST.AST {\n    return this._schema.ast;\n  }\n\n  public get annotations() {\n    return this._schema.annotations;\n  }\n\n  public get pipe() {\n    return this._schema.pipe;\n  }\n\n  //\n  // TypedObject\n  //\n\n  get typename(): string {\n    return this._objectAnnotation.typename;\n  }\n\n  get version(): string {\n    return this._objectAnnotation.version;\n  }\n\n  //\n  // BaseSchema\n  //\n\n  get readonly(): boolean {\n    return true;\n  }\n\n  get snapshot(): Schema.Schema.AnyNoContext {\n    return this._schema;\n  }\n\n  // TODO(burdon): Change from getter since this is expensive.\n  get jsonSchema(): JsonSchemaType {\n    return toJsonSchema(this._schema);\n  }\n\n  get mutable(): EchoSchema {\n    throw new Error('Schema is readonly.');\n  }\n}\n\n/**\n * Defines an effect-schema for the `EchoSchema` type.\n *\n * This is here so that `EchoSchema` class can be used as a part of another schema definition (e.g., `ref(EchoSchema)`).\n */\nconst EchoSchemaConstructor = (): TypedObjectPrototype => {\n  /**\n   * Return class definition satisfying Schema.Schema.\n   */\n  return class {\n    private static get _schema() {\n      // The field is DynamicEchoSchema in runtime, but is serialized as StoredEchoSchema in automerge.\n      return Schema.Union(StoredSchema, Schema.instanceOf(EchoSchema)).annotations(StoredSchema.ast.annotations);\n    }\n\n    static readonly [Schema.TypeId] = schemaVariance;\n\n    static get ast() {\n      const schema = this._schema;\n      return schema.ast;\n    }\n\n    static get annotations() {\n      const schema = this._schema;\n      return schema.annotations.bind(schema);\n    }\n\n    static get pipe() {\n      const schema = this._schema;\n      return schema.pipe.bind(schema);\n    }\n  } as any;\n};\n\nexport const isMutable = (schema: Schema.Schema.AnyNoContext): schema is EchoSchema => {\n  return schema instanceof EchoSchema;\n};\n\n// NOTE: Keep in this file.\nconst schemaVariance = {\n  _A: (_: any) => _,\n  _I: (_: any) => _,\n  _R: (_: never) => _,\n};\n\n/**\n * Represents a schema that is stored in the ECHO database.\n * Schema can me mutable or readonly (specified by the {@link EchoSchema.readonly} field).\n *\n * Schema that can be modified at runtime via the API.\n * Is an instance of effect-schema (`Schema.Schema.AnyNoContext`) so it can be used in the same way as a regular schema.\n * IMPORTANT: The schema AST will change reactively when the schema is updated, including synced updates from remote peers.\n *\n * The class constructor is a schema instance itself, and can be used in the echo object definitions:\n *\n * @example\n * ```ts\n * export class TableType extends TypedObject({ typename: 'example.org/type/Table', version: '0.1.0' })({\n *   title: Schema.String,\n *   schema: Schema.optional(ref(EchoSchema)),\n *   props: Schema.mutable(S.Array(TablePropSchema)),\n * }) {}\n * ```\n *\n * The ECHO API will translate any references to StoredSchema objects to be resolved as EchoSchema objects.\n */\nexport class EchoSchema<A = any, I = any> extends EchoSchemaConstructor() implements BaseSchema<A, I> {\n  private _schema: Schema.Schema.AnyNoContext | undefined;\n  private _isDirty = true;\n\n  constructor(private readonly _storedSchema: StoredSchema) {\n    super();\n  }\n\n  //\n  // Effect Schema (push to abstract base class).\n  //\n\n  public get [Schema.TypeId]() {\n    return schemaVariance;\n  }\n\n  public get Type() {\n    return this._storedSchema as A;\n  }\n\n  public get Encoded() {\n    return this._storedSchema as I;\n  }\n\n  public get Context() {\n    const schema = this._getSchema();\n    return schema.Context;\n  }\n\n  public get ast() {\n    const schema = this._getSchema();\n    return schema.ast;\n  }\n\n  public get annotations() {\n    const schema = this._getSchema();\n    return schema.annotations.bind(schema);\n  }\n\n  public get pipe(): Schema.Schema.AnyNoContext['pipe'] {\n    const schema = this._getSchema();\n    return schema.pipe.bind(schema);\n  }\n\n  //\n  // BaseSchema\n  //\n\n  public get typename(): string {\n    return this._storedSchema.typename;\n  }\n\n  public get version(): string {\n    return this._storedSchema.version;\n  }\n\n  public get readonly(): boolean {\n    return false;\n  }\n\n  /**\n   * Returns an immutable schema snapshot of the current state of the schema.\n   */\n  public get snapshot(): Schema.Schema.AnyNoContext {\n    return this._getSchema();\n  }\n\n  /**\n   * @reactive\n   */\n  public get jsonSchema(): JsonSchemaType {\n    return this._storedSchema.jsonSchema;\n  }\n\n  /**\n   * Returns a mutable schema.\n   */\n  public get mutable(): EchoSchema {\n    invariant(!this.readonly, 'Schema is not mutable');\n    return this;\n  }\n\n  //\n  // Mutable Schema\n  //\n\n  /**\n   * Id of the ECHO object containing the schema.\n   */\n  public get id(): ObjectId {\n    return this._storedSchema.id;\n  }\n\n  public get [SchemaMetaSymbol](): SchemaMeta {\n    return { id: this.id, typename: this.typename, version: this._storedSchema.version };\n  }\n\n  /**\n   * Reference to the underlying stored schema object.\n   */\n  public get storedSchema(): StoredSchema {\n    return this._storedSchema;\n  }\n\n  public getProperties(): SchemaAST.PropertySignature[] {\n    const ast = this._getSchema().ast;\n    invariant(SchemaAST.isTypeLiteral(ast));\n    return [...ast.propertySignatures].filter((p) => p.name !== 'id').map(unwrapOptionality);\n  }\n\n  //\n  // Mutation methods.\n  // TODO(burdon): Create separate interface for dynamic schema.\n  // TODO(burdon): Deprecate direct manipulation? Use JSONSchema directly.\n  //\n\n  /**\n   * @throws Error if the schema is readonly.\n   */\n  public updateTypename(typename: string): void {\n    const updated = setTypenameInSchema(this._getSchema(), typename);\n    this._storedSchema.typename = typename;\n    this._storedSchema.jsonSchema = toJsonSchema(updated);\n  }\n\n  /**\n   * @throws Error if the schema is readonly.\n   */\n  public addFields(fields: Schema.Struct.Fields): void {\n    const extended = addFieldsToSchema(this._getSchema(), fields);\n    this._storedSchema.jsonSchema = toJsonSchema(extended);\n  }\n\n  /**\n   * @throws Error if the schema is readonly.\n   */\n  public updateFields(fields: Schema.Struct.Fields): void {\n    const updated = updateFieldsInSchema(this._getSchema(), fields);\n    this._storedSchema.jsonSchema = toJsonSchema(updated);\n  }\n\n  /**\n   * @throws Error if the schema is readonly.\n   */\n  public updateFieldPropertyName({ before, after }: { before: PropertyKey; after: PropertyKey }): void {\n    const renamed = updateFieldNameInSchema(this._getSchema(), { before, after });\n    this._storedSchema.jsonSchema = toJsonSchema(renamed);\n  }\n\n  /**\n   * @throws Error if the schema is readonly.\n   */\n  public removeFields(fieldNames: string[]): void {\n    const removed = removeFieldsFromSchema(this._getSchema(), fieldNames);\n    this._storedSchema.jsonSchema = toJsonSchema(removed);\n  }\n\n  //\n  // Internals\n  //\n\n  /**\n   * Called by EchoSchemaRegistry on update.\n   */\n  _invalidate(): void {\n    this._isDirty = true;\n  }\n\n  /**\n   * Rebuilds this schema if it is dirty.\n   */\n  _rebuild(): void {\n    if (this._isDirty || this._schema == null) {\n      this._schema = toEffectSchema(getSnapshot(this._storedSchema.jsonSchema));\n      this._isDirty = false;\n    }\n  }\n\n  private _getSchema(): Schema.Schema.AnyNoContext {\n    this._rebuild();\n    return this._schema!;\n  }\n}\n\n// TODO(burdon): Move to effect.\nconst unwrapOptionality = (property: SchemaAST.PropertySignature): SchemaAST.PropertySignature => {\n  if (!SchemaAST.isUnion(property.type)) {\n    return property;\n  }\n\n  return {\n    ...property,\n    type: property.type.types.find((type) => !SchemaAST.isUndefinedKeyword(type))!,\n  } as any;\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { SchemaAST, Schema } from 'effect';\n\nimport { invariant } from '@dxos/invariant';\n\nimport { type TypeAnnotation, TypeAnnotationId } from '../ast';\n\n// TODO(ZaymonFC): Do this one at a time. This might be dangerous.\nexport const addFieldsToSchema = (\n  schema: Schema.Schema.AnyNoContext,\n  fields: Schema.Struct.Fields,\n): Schema.Schema.AnyNoContext => {\n  const schemaExtension = Schema.partial(Schema.Struct(fields));\n  return Schema.extend(schema, schemaExtension).annotations(\n    schema.ast.annotations,\n  ) as any as Schema.Schema.AnyNoContext;\n};\n\nexport const updateFieldsInSchema = (\n  schema: Schema.Schema.AnyNoContext,\n  fields: Schema.Struct.Fields,\n): Schema.Schema.AnyNoContext => {\n  const ast = schema.ast as SchemaAST.TypeLiteral;\n  invariant(SchemaAST.isTypeLiteral(ast));\n\n  const updatedProperties = [...ast.propertySignatures];\n  const propertiesToUpdate = (Schema.partial(Schema.Struct(fields)).ast as SchemaAST.TypeLiteral).propertySignatures;\n  for (const property of propertiesToUpdate) {\n    const index = updatedProperties.findIndex((p) => p.name === property.name);\n    if (index !== -1) {\n      updatedProperties[index] = property;\n    } else {\n      updatedProperties.push(property);\n    }\n  }\n\n  return Schema.make(new SchemaAST.TypeLiteral(updatedProperties, ast.indexSignatures, ast.annotations));\n};\n\nexport const removeFieldsFromSchema = (\n  schema: Schema.Schema.AnyNoContext,\n  fieldNames: string[],\n): Schema.Schema.AnyNoContext => {\n  return Schema.make(SchemaAST.omit(schema.ast, fieldNames)).annotations(schema.ast.annotations);\n};\n\nexport const updateFieldNameInSchema = (\n  schema: Schema.Schema.AnyNoContext,\n  { before, after }: { before: PropertyKey; after: PropertyKey },\n): Schema.Schema.AnyNoContext => {\n  const ast = schema.ast as SchemaAST.TypeLiteral;\n  invariant(SchemaAST.isTypeLiteral(ast));\n\n  return Schema.make(\n    new SchemaAST.TypeLiteral(\n      ast.propertySignatures.map((p) =>\n        p.name === before\n          ? new SchemaAST.PropertySignature(after, p.type, p.isOptional, p.isReadonly, p.annotations)\n          : p,\n      ),\n      ast.indexSignatures,\n      ast.annotations,\n    ),\n  );\n};\n\nexport const setTypenameInSchema = (\n  schema: Schema.Schema.AnyNoContext,\n  typename: string,\n): Schema.Schema.AnyNoContext => {\n  const existingAnnotation = schema.ast.annotations[TypeAnnotationId] as TypeAnnotation;\n  invariant(existingAnnotation, `Missing ${String(TypeAnnotationId)}`);\n\n  return schema.annotations({\n    ...schema.ast.annotations,\n    [TypeAnnotationId]: {\n      kind: existingAnnotation.kind,\n      typename,\n      version: existingAnnotation.version,\n    } satisfies TypeAnnotation,\n  });\n};\n", "//\n// Copyright 2025 DXOS.org\n//\n\n/**\n * Returns a non-reactive snapshot of the given live object.\n */\n// TODO(wittjosiah): Types.\nexport const getSnapshot = (object: any): any => {\n  if (typeof object !== 'object') {\n    return object;\n  }\n\n  if (Array.isArray(object)) {\n    return object.map(getSnapshot);\n  }\n\n  const result: any = {};\n  for (const key in object) {\n    result[key] = getSnapshot(object[key]);\n  }\n\n  return result;\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { Schema } from 'effect';\n\nimport { Typename, Version } from '../ast';\nimport { JsonSchemaType } from '../json-schema';\nimport { EchoObject } from '../object';\n\n/**\n * Persistent representation of a schema.\n */\nexport const StoredSchema = Schema.Struct({\n  typename: Typename,\n  version: Version,\n  jsonSchema: JsonSchemaType,\n}).pipe(\n  EchoObject({\n    typename: 'dxos.org/type/Schema',\n    version: '0.1.0',\n  }),\n);\n\nexport type StoredSchema = Schema.Schema.Type<typeof StoredSchema>;\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { type Schema } from 'effect';\n\nimport { raise } from '@dxos/debug';\nimport { invariant } from '@dxos/invariant';\nimport { type DXN } from '@dxos/keys';\nimport { defaultMap } from '@dxos/util';\n\nimport { StoredSchema } from './stored-schema';\nimport { getSchemaTypename, getSchemaVersion } from '../ast';\n\n/**\n * Runtime registry of static schema objects (i.e., not Dynamic .\n */\n// TODO(burdon): Reconcile with EchoSchemaRegistry.\nexport class RuntimeSchemaRegistry {\n  private readonly _registry = new Map<string, Schema.Schema.AnyNoContext[]>();\n\n  constructor() {\n    this._registry.set(StoredSchema.typename, [StoredSchema]);\n  }\n\n  get schemas(): Schema.Schema.AnyNoContext[] {\n    return Array.from(this._registry.values()).flat();\n  }\n\n  hasSchema<S extends Schema.Schema.AnyNoContext>(schema: S): boolean {\n    const typename = getSchemaTypename(schema);\n    const version = getSchemaVersion(schema);\n    invariant(typename);\n    const schemas = this._registry.get(typename);\n    return schemas?.some((schema) => getSchemaVersion(schema) === version) ?? false;\n  }\n\n  getSchemaByDXN(dxn: DXN): Schema.Schema.AnyNoContext | undefined {\n    const components = dxn.asTypeDXN();\n    if (!components) {\n      return undefined;\n    }\n\n    const { type, version } = components;\n    const allSchemas = this._registry.get(type) ?? [];\n    if (version) {\n      return allSchemas.find((s) => getSchemaVersion(s) === version);\n    } else {\n      // If no version is specified, return the earliest version for backwards compatibility.\n      // TODO(dmaretskyi): Probably not correct to compare lexicographically, but it's good enough for now.\n      return allSchemas.sort((a, b) =>\n        (getSchemaVersion(a) ?? '0.0.0').localeCompare(getSchemaVersion(b) ?? '0.0.0'),\n      )[0];\n    }\n  }\n\n  /**\n   * @deprecated Use getSchemaByDXN.\n   */\n  getSchema(typename: string): Schema.Schema.AnyNoContext | undefined {\n    return this._registry.get(typename)?.[0];\n  }\n\n  addSchema(types: Schema.Schema.AnyNoContext[]): void {\n    types.forEach((schema) => {\n      const typename = getSchemaTypename(schema) ?? raise(new TypeError('Schema has no typename'));\n      const version = getSchemaVersion(schema) ?? raise(new TypeError('Schema has no version'));\n      const versions = defaultMap(this._registry, typename, () => []);\n      if (versions.some((schema) => getSchemaVersion(schema) === version)) {\n        throw new Error(`Schema version already registered: ${typename}:${version}`);\n      }\n\n      versions.push(schema);\n    });\n  }\n}\n"],
  "mappings": "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",
  "names": ["import_effect", "import_keys", "import_util", "import_echo_protocol", "import_invariant", "import_debug", "TypeEnum", "getTypeEnum", "property", "type", "undefined", "FormatAnnotationId", "Symbol", "for", "FormatAnnotation", "createAnnotationHelper", "getFormatAnnotation", "node", "pipe", "SchemaAST", "getAnnotation", "Option", "getOrUndefined", "FormatEnum", "FormatEnums", "Object", "values", "sort", "PropertyKind", "format", "typeToFormat", "formatToType", "OptionsAnnotationId", "getOptionsAnnotation", "encodeMultipleOf", "divisor", "Math", "pow", "encodeMultiple", "self", "Schema", "multipleOf", "DecimalPrecision", "transform", "Number", "strict", "encode", "value", "decode", "log10", "annotations", "title", "CurrencyAnnotationId", "Currency", "decimals", "code", "set", "description", "toUpperCase", "Integer", "int", "Percent", "Timestamp", "GeoPoint", "Tuple", "clamp", "optionalElement", "GeoLocation", "toGeoPoint", "longitude", "latitude", "height", "clampedLongitude", "clampedLatitude", "fromGeoPoint", "geoPoint", "result", "SimpleDate", "Struct", "year", "between", "month", "day", "SimpleTime", "hours", "minutes", "seconds", "SimpleDateTime", "extend", "DateOnly", "String", "Date", "TimeOnly", "Time", "DateTime", "Duration", "ExamplesAnnotationId", "Email", "pattern", "Formula", "Hostname", "JSON", "Markdown", "Regex", "URL", "UUID", "Format", "DXN", "SelectOptionSchema", "id", "NonEmptyString", "color", "mutable", "CustomAnnotations", "currency", "DecodedAnnotations", "TitleAnnotationId", "DescriptionAnnotationId", "EchoAnnotations", "meta", "PropertyMetaAnnotationId", "generator", "GeneratorAnnotationId", "labelProp", "LabelAnnotationId", "SimpleTypes", "Literal", "NonNegativeInteger", "greaterThanOrEqualTo", "StringArray", "Array", "JsonSchemaOrBoolean", "Union", "suspend", "JsonSchemaType", "Boolean", "JsonSchemaEchoAnnotations", "optional", "JsonPath", "Record", "key", "Any", "typename", "version", "schemaId", "_JsonSchemaType", "$id", "$schema", "$ref", "$comment", "entityKind", "EntityKindSchema", "relationTarget", "relationSource", "readOnly", "writeOnly", "examples", "default", "const", "enum", "greaterThan", "maximum", "exclusiveMaximum", "minimum", "exclusiveMinimum", "maxLength", "minLength", "items", "additionalItems", "maxItems", "minItems", "uniqueItems", "contains", "maxProperties", "minProperties", "required", "propertyOrder", "additionalProperties", "properties", "patternProperties", "propertyNames", "definitions", "dependencies", "identifier", "contentMediaType", "contentEncoding", "if", "then", "else", "allOf", "anyOf", "oneOf", "not", "$defs", "reference", "schema", "schemaVersion", "schemaObject", "echo", "JsonSchemaFields", "keys", "fields", "getSchemaProperty", "setSchemaProperty", "ECHO_ANNOTATIONS_NS_DEPRECATED_KEY", "ECHO_ANNOTATIONS_NS_KEY", "getNormalizedEchoAnnotations", "obj", "normalizeEchoAnnotations", "res", "normalizeSchema", "copy", "structuredClone", "go", "includes", "goOnRecord", "maybeGoOnArray", "isArray", "item", "record", "createJsonSchema", "jsonSchema", "_toJsonSchema", "PropType", "toPropType", "Error", "JSON_SCHEMA_URL", "toJsonSchema", "options", "removeProperties", "invariant", "withRefinements", "withEchoRefinements", "ast", "JSONSchema", "fromAST", "orderKeys", "echoIdentifier", "getTypeIdentifierAnnotation", "objectAnnotation", "getTypeAnnotation", "fromTypename", "toString", "kind", "EntityKind", "Relation", "sourceSchema", "targetSchema", "path", "suspendCache", "Map", "recursiveResult", "isSuspend", "suspendedAst", "f", "cachedPath", "get", "Suspend", "JSONSchemaAnnotationId", "make", "isTypeLiteral", "mapAst", "addJsonSchemaFields", "propertySignatures", "map", "p", "name", "isUndefinedKeyword", "annotationFields", "annotations_toJsonSchemaFields", "length", "toEffectSchema", "root", "_defs", "defs", "objectToEffectSchema", "Unknown", "anyToEffectSchema", "refToEffectSchema", "e", "v", "RegExp", "Null", "refSegments", "split", "jsonSchemaFieldsToAnnotations", "echoRefinement", "isEchoObject", "startsWith", "propertyList", "entries", "immutableIdField", "indexValue", "echoId", "createEchoReferenceSchema", "Ref", "Expando", "targetSchemaDXN", "parse", "TYPE", "parts", "schemaFields", "echoAnnotations", "annotationId", "TypeIdentifierAnnotationId", "decodeTypeIdentifierAnnotation", "ObjectId", "isValid", "fromLocalObjectId", "decodeTypeAnnotation", "annotation", "decodeSync", "source", "raise", "target", "TypeAnnotationId", "clearUndefined", "makeAnnotatedRefinement", "Refinement", "none", "SortDirection", "FieldSort", "fieldId", "direction", "FieldSortType", "QuerySchema", "QueryType", "RawObject", "omit", "splitMeta", "object", "ATTR_META", "getValue", "getDeep", "splitJsonPath", "replace", "setValue", "setDeep", "getTypeReference", "schemaDXN", "getSchemaDXN", "Reference", "fromDXN", "requireTypeReference", "typeReference", "isInstanceOf", "getType", "equals", "getTypename", "typeDXN", "asTypeDXN", "addFieldsToSchema", "schemaExtension", "partial", "updateFieldsInSchema", "updatedProperties", "propertiesToUpdate", "index", "findIndex", "push", "TypeLiteral", "indexSignatures", "removeFieldsFromSchema", "fieldNames", "updateFieldNameInSchema", "before", "after", "PropertySignature", "isOptional", "isReadonly", "setTypenameInSchema", "existingAnnotation", "getSnapshot", "StoredSchema", "Typename", "Version", "EchoObject", "ImmutableSchema", "_schema", "_objectAnnotation", "TypeId", "schemaVariance", "Type", "Encoded", "Context", "readonly", "snapshot", "EchoSchemaConstructor", "instanceOf", "EchoSchema", "bind", "isMutable", "_A", "_", "_I", "_R", "_storedSchema", "_isDirty", "_getSchema", "SchemaMetaSymbol", "storedSchema", "getProperties", "filter", "unwrapOptionality", "updateTypename", "updated", "addFields", "extended", "updateFields", "updateFieldPropertyName", "renamed", "removeFields", "removed", "_invalidate", "_rebuild", "isUnion", "types", "find", "RuntimeSchemaRegistry", "_registry", "schemas", "from", "flat", "hasSchema", "getSchemaTypename", "getSchemaVersion", "some", "getSchemaByDXN", "dxn", "components", "allSchemas", "s", "a", "b", "localeCompare", "getSchema", "addSchema", "forEach", "TypeError", "versions", "defaultMap", "composeSchema", "prop", "propSchema", "assign"]
}
