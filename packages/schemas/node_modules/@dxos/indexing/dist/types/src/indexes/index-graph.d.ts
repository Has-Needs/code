import { Event } from '@dxos/async';
import { Resource } from '@dxos/context';
import { ObjectStructure } from '@dxos/echo-protocol';
import { ObjectPointerEncoded } from '@dxos/protocols';
import { IndexKind } from '@dxos/protocols/proto/dxos/echo/indexing';
import { type FindResult, type Index, type IndexQuery, type LoadParams } from '../types';
/**
 * Indexes graph relationships between objects.
 * Includes incoming references for relations as well.
 */
export declare class IndexGraph extends Resource implements Index {
    private _identifier;
    readonly kind: IndexKind;
    readonly updated: Event<void>;
    /**
     * Tracks inbound references for each object.
     *
     * target object id -> prop name -> set of source object ids
     */
    private readonly _inboundReferences;
    /**
     * Tracks relation targets for each object.
     *
     * relation target object id -> set of relation ids
     */
    private readonly _relationTargets;
    /**
     * Tracks relation sources for each object.
     *
     * relation source object id -> set of relation ids
     */
    private readonly _relationSources;
    /**
     * Mapping from the object to the list of reference targets.
     * We need this because on index update we don't know what the previous version of the object was.
     * This mapping is used to remove the old relations on update.
     */
    private readonly _objectToTargets;
    get identifier(): string;
    update(id: ObjectPointerEncoded, object: ObjectStructure): Promise<boolean>;
    remove(id: ObjectPointerEncoded): Promise<void>;
    private _removeReferencesFrom;
    private _trackOutgoingReferences;
    find(filter: IndexQuery): Promise<FindResult[]>;
    serialize(): Promise<string>;
    static load({ serialized, identifier }: LoadParams): Promise<IndexGraph>;
    private _loadFrom;
}
//# sourceMappingURL=index-graph.d.ts.map