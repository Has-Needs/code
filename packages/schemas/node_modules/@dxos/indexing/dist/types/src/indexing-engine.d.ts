import { Resource, type Context } from '@dxos/context';
import type { LevelDB } from '@dxos/kv-store';
import { IndexKind } from '@dxos/protocols/proto/dxos/echo/indexing';
import type { IndexMetadataStore, IndexStore } from './store';
import type { IdToHeads, Index, ObjectSnapshot } from './types';
/**
 * Loads documents by their ID and version.
 */
interface DocumentLoader {
    loadDocuments: (ids: IdToHeads) => AsyncGenerator<ObjectSnapshot[]>;
}
export type IndexingEngineOptions = {
    db: LevelDB;
    metadataStore: IndexMetadataStore;
    indexStore: IndexStore;
    /**
     * Load documents by their pointers at specific hash.
     */
    documentLoader: DocumentLoader;
};
type IndexUpdatedObjectsOptions = {
    indexTimeBudget: number;
    indexUpdateBatchSize: number;
};
/**
 * Manages multiple asynchronous indexes.
 */
export declare class IndexingEngine extends Resource {
    private readonly _db;
    private readonly _metadataStore;
    private readonly _indexStore;
    private readonly _documentLoader;
    /**
     * Indexes that are kept in-sync with the documents and are serialized to disk.
     */
    private readonly _indexes;
    /**
     * Indexes that were recently created and might not be fully caught up with the documents.
     * They are not serialized to disk until they are promoted.
     *
     * This separation is needed because the tracking of processed documents is done globally and not per-index.
     * This means that all indexes will be updated with the same documents in lockstep.
     * This also means that newly created indexes cannot be saved to disk until they have processed all clean documents.
     */
    private readonly _newIndexes;
    constructor(options: IndexingEngineOptions);
    protected _open(ctx: Context): Promise<void>;
    protected _close(ctx: Context): Promise<void>;
    get indexKinds(): IndexKind[];
    get indexes(): Index[];
    get newIndexCount(): number;
    getIndex(kind: IndexKind): Index | undefined;
    deleteIndex(kind: IndexKind): void;
    addPersistentIndex(index: Index): Promise<void>;
    addNewIndex(index: Index): Promise<void>;
    loadIndexKindsFromDisk(): Promise<Map<string, IndexKind>>;
    loadIndexFromDisk(identifier: string): Promise<void>;
    removeIndexFromDisk(identifier: string): Promise<void>;
    /**
     * Promotes new indexes to the main indexes.
     */
    promoteNewIndexes(): Promise<void>;
    /**
     * Indexes updated objects.
     * @returns completed - whether the indexing was completed
     * @returns updated - whether the indexing updated any indexes
     */
    indexUpdatedObjects(options: IndexUpdatedObjectsOptions): Promise<{
        completed: boolean;
        updated: boolean;
    }>;
    private _updateIndexes;
    private _saveIndexes;
}
export {};
//# sourceMappingURL=indexing-engine.d.ts.map