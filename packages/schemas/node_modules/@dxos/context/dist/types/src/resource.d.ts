import { Context } from './context';
export declare enum LifecycleState {
    CLOSED = "CLOSED",
    OPEN = "OPEN",
    ERROR = "ERROR"
}
export interface Lifecycle {
    open?(ctx?: Context): Promise<any> | any;
    close?(): Promise<any> | any;
}
/**
 * Base class for resources that need to be opened and closed.
 */
export declare abstract class Resource implements Lifecycle {
    #private;
    get isOpen(): boolean;
    protected get _lifecycleState(): LifecycleState;
    protected get _ctx(): Context;
    /**
     * To be overridden by subclasses.
     */
    protected _open(ctx: Context): Promise<void>;
    /**
     * To be overridden by subclasses.
     */
    protected _close(ctx: Context): Promise<void>;
    /**
     * Error handler for errors that are caught by the context.
     * By default, errors are bubbled up to the parent context which is passed to the open method.
     */
    protected _catch(err: Error): Promise<void>;
    /**
     * Opens the resource.
     * If the resource is already open, it does nothing.
     * If the resource is in an error state, it throws an error.
     * If the resource is closed, it waits for it to close and then opens it.
     * @param ctx - Context to use for opening the resource. This context will receive errors that are not handled in `_catch`.
     */
    open(ctx?: Context): Promise<this>;
    /**
     * Closes the resource.
     * If the resource is already closed, it does nothing.
     */
    close(ctx?: Context): Promise<this>;
    /**
     * Waits until the resource is open.
     */
    waitUntilOpen(): Promise<void>;
    [Symbol.asyncDispose](): Promise<void>;
}
export declare const openInContext: <T extends Lifecycle>(ctx: Context, resource: T) => Promise<T>;
//# sourceMappingURL=resource.d.ts.map