{
  "version": 3,
  "sources": ["../../../src/invitations/index.ts", "../../../src/invitations/invitations-proxy.ts"],
  "sourcesContent": ["//\n// Copyright 2023 DXOS.org\n//\n\nexport {\n  AuthenticatingInvitation as AuthenticatingInvitationObservable,\n  CancellableInvitation as CancellableInvitationObservable,\n  InvitationEncoder,\n  type Invitations,\n} from '@dxos/client-protocol';\n\nexport { Invitation } from '@dxos/protocols/proto/dxos/client/services';\n\nexport { InvitationsProxy } from './invitations-proxy';\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { Event, MulticastObservable, type Observable, PushStream, Trigger } from '@dxos/async';\nimport {\n  AuthenticatingInvitation,\n  CancellableInvitation,\n  InvitationEncoder,\n  type Invitations,\n} from '@dxos/client-protocol';\nimport { type Stream } from '@dxos/codec-protobuf/stream';\nimport { Context } from '@dxos/context';\nimport { invariant } from '@dxos/invariant';\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport {\n  Invitation,\n  type IdentityService,\n  type InvitationsService,\n  QueryInvitationsResponse,\n} from '@dxos/protocols/proto/dxos/client/services';\nimport { type DeviceProfileDocument } from '@dxos/protocols/proto/dxos/halo/credentials';\n\nimport { RPC_TIMEOUT } from '../common';\n\n/**\n * Create an observable from an RPC stream.\n */\n// TODO(wittjosiah): Factor out.\nconst createObservable = <T>(rpcStream: Stream<T>): Observable<T> => {\n  const pushStream = new PushStream<T>();\n\n  rpcStream.subscribe(\n    (value: T) => {\n      pushStream.next(value);\n    },\n    (err?: Error) => {\n      if (err) {\n        pushStream.error(err);\n      } else {\n        pushStream.complete();\n      }\n    },\n  );\n\n  return pushStream.observable;\n};\n\nexport class InvitationsProxy implements Invitations {\n  private _ctx!: Context;\n  private _createdUpdate = new Event<CancellableInvitation[]>();\n  private _acceptedUpdate = new Event<AuthenticatingInvitation[]>();\n  private _savedUpdate = new Event<Invitation[]>();\n  private _created = MulticastObservable.from(this._createdUpdate, []);\n  private _accepted = MulticastObservable.from(this._acceptedUpdate, []);\n  private _saved = MulticastObservable.from(this._savedUpdate, []);\n  // Invitations originating from this proxy.\n  private _invitations = new Set<string>();\n  private _invitationsLoaded = new Trigger();\n\n  private _opened = false;\n\n  constructor(\n    private readonly _invitationsService: InvitationsService,\n    private readonly _identityService: IdentityService | undefined,\n    private readonly _getInvitationContext: () => Partial<Invitation> & Pick<Invitation, 'kind'>,\n  ) {}\n\n  get created(): MulticastObservable<CancellableInvitation[]> {\n    return this._created;\n  }\n\n  get accepted(): MulticastObservable<AuthenticatingInvitation[]> {\n    return this._accepted;\n  }\n\n  /**\n   * @test-only\n   */\n  get saved(): MulticastObservable<Invitation[]> {\n    return this._saved;\n  }\n\n  get isOpen(): boolean {\n    return this._opened;\n  }\n\n  async open(): Promise<void> {\n    if (this._opened) {\n      return;\n    }\n\n    log('opening...', this._getInvitationContext());\n    this._ctx = new Context();\n    const persistentLoaded = new Trigger();\n    const initialCreatedReceived = new Trigger();\n    // TODO(nf): actually needed?\n    const initialAcceptedReceived = new Trigger();\n\n    const stream = this._invitationsService.queryInvitations(undefined, { timeout: RPC_TIMEOUT });\n    stream.subscribe(({ action, type, invitations, existing }: QueryInvitationsResponse) => {\n      switch (action) {\n        case QueryInvitationsResponse.Action.ADDED: {\n          log('remote invitations added', { type, invitations });\n          invitations\n            ?.filter((invitation) => this._matchesInvitationContext(invitation))\n            .filter((invitation) => !this._invitations.has(invitation.invitationId))\n            .forEach((invitation) => {\n              type === QueryInvitationsResponse.Type.CREATED ? this.share(invitation) : this.join(invitation);\n            });\n          if (existing) {\n            type === QueryInvitationsResponse.Type.CREATED\n              ? initialCreatedReceived.wake()\n              : initialAcceptedReceived.wake();\n          }\n          break;\n        }\n        case QueryInvitationsResponse.Action.REMOVED: {\n          log('remote invitations removed', { type, invitations });\n          const cache = type === QueryInvitationsResponse.Type.CREATED ? this._created : this._accepted;\n          const cacheUpdate =\n            type === QueryInvitationsResponse.Type.CREATED ? this._createdUpdate : this._acceptedUpdate;\n          invitations?.forEach((removed) => {\n            const index = cache.get().findIndex((invitation) => invitation.get().invitationId === removed.invitationId);\n            void cache.get()[index]?.cancel();\n            index >= 0 &&\n              cacheUpdate.emit([\n                ...cache.get().slice(0, index),\n                ...cache.get().slice(index + 1),\n              ] as AuthenticatingInvitation[]);\n          });\n          existing && initialAcceptedReceived.wake();\n          break;\n        }\n        case QueryInvitationsResponse.Action.LOAD_COMPLETE: {\n          persistentLoaded.wake();\n          break;\n        }\n        case QueryInvitationsResponse.Action.SAVED: {\n          log('remote invitations saved', { invitations });\n          this._savedUpdate.emit(invitations ?? []);\n          break;\n        }\n      }\n    });\n\n    this._ctx.onDispose(() => stream.close());\n    await persistentLoaded.wait();\n    // wait until remote invitations are added and removed in case .created is called early.\n    await initialAcceptedReceived.wait();\n    await initialCreatedReceived.wait();\n    this._opened = true;\n    log('opened', this._getInvitationContext());\n  }\n\n  async close(): Promise<void> {\n    if (!this._opened) {\n      return;\n    }\n\n    log('closing...', this._getInvitationContext());\n    await this._ctx.dispose();\n    this._createdUpdate.emit([]);\n    this._acceptedUpdate.emit([]);\n    log('closed', this._getInvitationContext());\n  }\n\n  getInvitationOptions(): Invitation {\n    return {\n      invitationId: PublicKey.random().toHex(),\n      type: Invitation.Type.INTERACTIVE,\n      authMethod: Invitation.AuthMethod.SHARED_SECRET,\n      state: Invitation.State.INIT,\n      swarmKey: PublicKey.random(),\n      ...this._getInvitationContext(),\n    };\n  }\n\n  // TODO(nf): Some way to retrieve observables for resumed invitations?\n  share(options?: Partial<Invitation>): CancellableInvitation {\n    const invitation: Invitation = { ...this.getInvitationOptions(), ...options };\n    this._invitations.add(invitation.invitationId);\n\n    const existing = this._created.get().find((created) => created.get().invitationId === invitation.invitationId);\n    if (existing) {\n      return existing;\n    }\n\n    const observable = new CancellableInvitation({\n      initialInvitation: invitation,\n      subscriber: createObservable(this._invitationsService.createInvitation(invitation)),\n      onCancel: async () => {\n        const invitationId = observable.get().invitationId;\n        invariant(invitationId, 'Invitation missing identifier');\n        await this._invitationsService.cancelInvitation({ invitationId });\n      },\n    });\n    this._createdUpdate.emit([...this._created.get(), observable]);\n\n    return observable;\n  }\n\n  join(invitation: Invitation | string, deviceProfile?: DeviceProfileDocument): AuthenticatingInvitation {\n    if (typeof invitation === 'string') {\n      invitation = InvitationEncoder.decode(invitation);\n    }\n    invariant(invitation && invitation.swarmKey);\n    this._invitations.add(invitation.invitationId);\n\n    const id = invitation.invitationId;\n    const existing = this._accepted.get().find((accepted) => accepted.get().invitationId === id);\n    if (existing) {\n      return existing;\n    }\n\n    const observable = new AuthenticatingInvitation({\n      initialInvitation: invitation,\n      subscriber: createObservable(this._invitationsService.acceptInvitation({ invitation, deviceProfile })),\n      onCancel: async () => {\n        const invitationId = observable.get().invitationId;\n        invariant(invitationId, 'Invitation missing identifier');\n        await this._invitationsService.cancelInvitation({ invitationId });\n      },\n      onAuthenticate: async (authCode: string) => {\n        const invitationId = observable.get().invitationId;\n        invariant(invitationId, 'Invitation missing identifier');\n\n        await this._invitationsService.authenticate({ invitationId, authCode });\n      },\n    });\n    this._acceptedUpdate.emit([...this._accepted.get(), observable]);\n\n    return observable;\n  }\n\n  private _matchesInvitationContext(invitation: Invitation): boolean {\n    const context = this._getInvitationContext();\n    log('checking invitation context', { invitation, context });\n    return Object.entries(context).reduce((acc, [key, value]) => {\n      const invitationValue = (invitation as any)[key];\n      if (invitationValue instanceof PublicKey && value instanceof PublicKey) {\n        return acc && invitationValue.equals(value);\n      } else {\n        return acc && invitationValue === value;\n      }\n    }, true);\n  }\n}\n"],
  "mappings": "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",
  "names": ["AuthenticatingInvitationObservable", "AuthenticatingInvitation", "CancellableInvitationObservable", "CancellableInvitation", "InvitationEncoder", "Invitation", "Event", "MulticastObservable", "PushStream", "Trigger", "AuthenticatingInvitation", "CancellableInvitation", "InvitationEncoder", "Context", "invariant", "PublicKey", "log", "Invitation", "QueryInvitationsResponse", "createObservable", "rpcStream", "pushStream", "PushStream", "subscribe", "value", "next", "err", "error", "complete", "observable", "InvitationsProxy", "_invitationsService", "_identityService", "_getInvitationContext", "_createdUpdate", "Event", "_acceptedUpdate", "_savedUpdate", "_created", "MulticastObservable", "from", "_accepted", "_saved", "_invitations", "Set", "_invitationsLoaded", "Trigger", "_opened", "created", "accepted", "saved", "isOpen", "open", "log", "_ctx", "Context", "persistentLoaded", "initialCreatedReceived", "initialAcceptedReceived", "stream", "queryInvitations", "undefined", "timeout", "RPC_TIMEOUT", "action", "type", "invitations", "existing", "QueryInvitationsResponse", "Action", "ADDED", "filter", "invitation", "_matchesInvitationContext", "has", "invitationId", "forEach", "Type", "CREATED", "share", "join", "wake", "REMOVED", "cache", "cacheUpdate", "removed", "index", "get", "findIndex", "cancel", "emit", "slice", "LOAD_COMPLETE", "SAVED", "onDispose", "close", "wait", "dispose", "getInvitationOptions", "PublicKey", "random", "toHex", "Invitation", "INTERACTIVE", "authMethod", "AuthMethod", "SHARED_SECRET", "state", "State", "INIT", "swarmKey", "options", "add", "find", "CancellableInvitation", "initialInvitation", "subscriber", "createInvitation", "onCancel", "invariant", "cancelInvitation", "deviceProfile", "InvitationEncoder", "decode", "id", "AuthenticatingInvitation", "acceptInvitation", "onAuthenticate", "authCode", "authenticate", "context", "Object", "entries", "reduce", "acc", "key", "invitationValue", "equals"]
}
