{
  "version": 3,
  "sources": ["../../../src/halo/halo-proxy.ts"],
  "sourcesContent": ["//\n// Copyright 2021 DXOS.org\n//\n\nimport { inspect } from 'node:util';\n\nimport { asyncTimeout, Event, MulticastObservable, Trigger, SubscriptionList } from '@dxos/async';\nimport { AUTH_TIMEOUT, type ClientServicesProvider, type Halo } from '@dxos/client-protocol';\nimport type { Stream } from '@dxos/codec-protobuf/stream';\nimport { inspectObject } from '@dxos/debug';\nimport { invariant } from '@dxos/invariant';\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { ApiError, trace as Trace } from '@dxos/protocols';\nimport {\n  type Contact,\n  type Device,\n  DeviceKind,\n  type Identity,\n  Invitation,\n} from '@dxos/protocols/proto/dxos/client/services';\nimport {\n  type Credential,\n  type Presentation,\n  type ProfileDocument,\n  type DeviceProfileDocument,\n} from '@dxos/protocols/proto/dxos/halo/credentials';\nimport { trace } from '@dxos/tracing';\n\nimport { RPC_TIMEOUT } from '../common';\nimport { InvitationsProxy } from '../invitations';\n\n@trace.resource()\nexport class HaloProxy implements Halo {\n  private readonly _instanceId = PublicKey.random().toHex();\n\n  private readonly _subscriptions = new SubscriptionList();\n  private readonly _identityChanged = new Event<Identity | null>(); // TODO(burdon): Move into Identity object.\n  private readonly _devicesChanged = new Event<Device[]>();\n  private readonly _contactsChanged = new Event<Contact[]>();\n  private readonly _credentialsChanged = new Event<Credential[]>();\n\n  private readonly _identity = MulticastObservable.from(this._identityChanged, null);\n  private readonly _devices = MulticastObservable.from(this._devicesChanged, []);\n  private readonly _contacts = MulticastObservable.from(this._contactsChanged, []);\n  private readonly _credentials = MulticastObservable.from(this._credentialsChanged, []);\n  private _invitationProxy?: InvitationsProxy;\n\n  private _haloCredentialStream?: Stream<Credential>;\n\n  constructor(\n    private readonly _serviceProvider: ClientServicesProvider,\n    /**\n     * @internal\n     */\n    public _traceParent?: string,\n  ) {}\n\n  [inspect.custom](): string {\n    return inspectObject(this);\n  }\n\n  @trace.info({ depth: null })\n  toJSON(): { identityKey: string | undefined; deviceKey: string | undefined } {\n    return {\n      identityKey: this._identity.get()?.identityKey.truncate(),\n      deviceKey: this.device?.deviceKey.truncate(),\n    };\n  }\n\n  /**\n   * User identity info.\n   */\n  get identity() {\n    return this._identity;\n  }\n\n  get devices() {\n    return this._devices;\n  }\n\n  get device() {\n    return this._devices.get().find((device) => device.kind === DeviceKind.CURRENT);\n  }\n\n  get contacts() {\n    return this._contacts;\n  }\n\n  get credentials() {\n    return this._credentials;\n  }\n\n  get invitations() {\n    invariant(this._invitationProxy, 'HaloProxy not opened');\n    return this._invitationProxy.created;\n  }\n\n  // TODO(burdon): Standardize isOpen, etc.\n  @trace.info()\n  get opened() {\n    return this._invitationProxy !== undefined;\n  }\n\n  /**\n   * Allocate resources and set-up internal subscriptions.\n   *\n   * @internal\n   */\n  async _open(): Promise<void> {\n    log.trace('dxos.sdk.halo-proxy.open', Trace.begin({ id: this._instanceId, parentId: this._traceParent }));\n    const gotIdentity = this._identityChanged.waitForCount(1);\n    // const gotContacts = this._contactsChanged.waitForCount(1);\n\n    invariant(this._serviceProvider.services.InvitationsService, 'InvitationsService not available');\n    this._invitationProxy = new InvitationsProxy(\n      this._serviceProvider.services.InvitationsService,\n      this._serviceProvider.services.IdentityService,\n      () => ({\n        kind: Invitation.Kind.DEVICE,\n      }),\n    );\n    await this._invitationProxy.open();\n\n    this._identityChanged.on((identity) => {\n      if (identity && !this._haloCredentialStream) {\n        invariant(this._serviceProvider.services.SpacesService, 'SpacesService not available');\n        this._haloCredentialStream = this._serviceProvider.services.SpacesService.queryCredentials(\n          {\n            spaceKey: identity.spaceKey!,\n          },\n          { timeout: RPC_TIMEOUT },\n        );\n        this._haloCredentialStream.subscribe((data) => {\n          this._credentialsChanged.emit([...this._credentials.get(), data]);\n        });\n        this._subscriptions.add(() => this._haloCredentialStream?.close());\n      }\n    });\n\n    invariant(this._serviceProvider.services.IdentityService, 'IdentityService not available');\n    const identityStream = this._serviceProvider.services.IdentityService.queryIdentity(undefined, {\n      timeout: RPC_TIMEOUT,\n    });\n    identityStream.subscribe((data) => {\n      // Set tracing identity. For early stage debugging.\n      data.identity &&\n        log.trace('dxos.halo.identity', {\n          identityKey: data.identity.identityKey,\n          displayName: data.identity.profile?.displayName,\n        });\n      this._identityChanged.emit(data.identity ?? null);\n    });\n    this._subscriptions.add(() => identityStream.close());\n\n    const contactsStream = this._serviceProvider.services.ContactsService!.queryContacts(undefined, {\n      timeout: RPC_TIMEOUT,\n    });\n    contactsStream.subscribe((data) => {\n      this._contactsChanged.emit(data.contacts ?? []);\n    });\n    this._subscriptions.add(() => contactsStream.close());\n\n    invariant(this._serviceProvider.services.DevicesService, 'DevicesService not available');\n    const devicesStream = this._serviceProvider.services.DevicesService.queryDevices(undefined, {\n      timeout: RPC_TIMEOUT,\n    });\n    devicesStream.subscribe((data) => {\n      if (data.devices) {\n        this._devicesChanged.emit(data.devices);\n        const current = data.devices.find((device) => device.kind === DeviceKind.CURRENT);\n        log.trace('dxos.halo.device', {\n          deviceKey: current?.deviceKey,\n          profile: current?.profile,\n        });\n      }\n    });\n    this._subscriptions.add(() => devicesStream.close());\n\n    log.trace('dxos.sdk.halo-proxy.open', Trace.end({ id: this._instanceId }));\n    await Promise.all([gotIdentity]);\n  }\n\n  /**\n   * Destroy the instance and clean-up subscriptions.\n   *\n   * @internal\n   */\n  async _close(): Promise<void> {\n    await this._invitationProxy?.close();\n    this._invitationProxy = undefined;\n    this._subscriptions.clear();\n    this._identityChanged.emit(null);\n    this._devicesChanged.emit([]);\n    this._contactsChanged.emit([]);\n  }\n\n  /**\n   * @internal\n   */\n  // TODO(wittjosiah): Should `Observable` class support this?\n  _waitForIdentity(): Promise<void> {\n    return this._identityChanged.waitForCondition(() => !!this._identity.get());\n  }\n\n  /**\n   * Create Identity.\n   * Then initializes profile with given display name.\n   * @param profile - optional display name\n   * @param deviceProfile - optional device profile that will be merged with defaults\n   */\n  async createIdentity(profile: ProfileDocument = {}, deviceProfile?: DeviceProfileDocument): Promise<Identity> {\n    invariant(this._serviceProvider.services.IdentityService, 'IdentityService not available');\n    invariant(!this.identity.get(), 'Identity already exists');\n    const deviceProfileWithDefaults = {\n      ...deviceProfile,\n      ...(deviceProfile?.label ? { label: deviceProfile.label } : { label: 'initial identity device' }),\n    };\n    const identity = await this._serviceProvider.services.IdentityService.createIdentity(\n      {\n        profile,\n        deviceProfile: deviceProfileWithDefaults,\n      },\n      { timeout: RPC_TIMEOUT },\n    );\n    this._identityChanged.emit(identity);\n    return identity;\n  }\n\n  async recoverIdentity(args: { recoveryCode: string }): Promise<Identity> {\n    invariant(this._serviceProvider.services.IdentityService, 'IdentityService not available');\n    const identity = await this._serviceProvider.services.IdentityService.recoverIdentity(args, {\n      timeout: RPC_TIMEOUT,\n    });\n    this._identityChanged.emit(identity);\n    return identity;\n  }\n\n  async updateProfile(profile: ProfileDocument): Promise<Identity> {\n    invariant(this._serviceProvider.services.IdentityService, 'IdentityService not available');\n    const identity = await this._serviceProvider.services.IdentityService.updateProfile(profile, {\n      timeout: RPC_TIMEOUT,\n    });\n    this._identityChanged.emit(identity);\n    return identity;\n  }\n\n  /**\n   * Get Halo credentials for the current user.\n   * Note: Will return an empty result if called before all credentials have been loaded.\n   */\n  queryCredentials({ ids, type }: { ids?: PublicKey[]; type?: string } = {}): Credential[] {\n    return this._credentials.get().filter((credential) => {\n      if (ids && !ids.some((id) => id.equals(credential.id!))) {\n        return false;\n      }\n      if (type && credential.subject.assertion['@type'] !== type) {\n        return false;\n      }\n      return true;\n    });\n  }\n\n  /**\n   * Initiates device invitation.\n   */\n  share(options?: Partial<Invitation>) {\n    if (!this.opened) {\n      throw new ApiError('Client not open.');\n    }\n\n    log('create invitation', { options });\n    const invitation = this._invitationProxy!.share(options);\n    return invitation;\n  }\n\n  /**\n   * Initiates accepting invitation.\n   * @param invitation\n   * @param deviceProfile - optional device profile that will be merged with defaults\n   */\n  join(invitation: Invitation | string, deviceProfile?: DeviceProfileDocument) {\n    if (!this.opened) {\n      throw new ApiError('Client not open.');\n    }\n\n    const deviceProfileWithDefaults = {\n      ...deviceProfile,\n      ...(deviceProfile?.label ? { label: deviceProfile.label } : { label: 'additional device' }),\n    };\n    return this._invitationProxy!.join(invitation, deviceProfileWithDefaults);\n  }\n\n  /**\n   * Write credentials to halo profile.\n   */\n  async writeCredentials(credentials: Credential[]): Promise<void> {\n    const identity = this._identity.get();\n    if (!identity) {\n      throw new ApiError('Identity is not available.');\n    }\n    if (!this._serviceProvider.services.SpacesService) {\n      throw new ApiError('SpacesService is not available.');\n    }\n\n    return this._serviceProvider.services.SpacesService.writeCredentials(\n      {\n        spaceKey: identity.spaceKey!,\n        credentials,\n      },\n      { timeout: RPC_TIMEOUT },\n    );\n  }\n\n  /**\n   * Present Credentials.\n   */\n  // TODO(burdon): Rename createPresentation?\n  async presentCredentials({ ids, nonce }: { ids: PublicKey[]; nonce?: Uint8Array }): Promise<Presentation> {\n    if (!this._serviceProvider.services.IdentityService) {\n      throw new ApiError('IdentityService is not available.');\n    }\n    const trigger = new Trigger<Credential[]>();\n\n    this._credentials.subscribe((credentials) => {\n      const credentialsToPresent = credentials.filter((credential) => ids.some((id) => id.equals(credential.id!)));\n      if (credentialsToPresent.length === ids.length) {\n        trigger.wake(credentialsToPresent);\n      }\n    });\n\n    const credentials = await asyncTimeout(\n      trigger.wait(),\n      AUTH_TIMEOUT,\n      new ApiError('Timeout while waiting for credentials.'),\n    );\n    return this._serviceProvider.services.IdentityService.signPresentation(\n      {\n        presentation: {\n          credentials,\n        },\n        nonce,\n      },\n      { timeout: RPC_TIMEOUT },\n    );\n  }\n}\n"],
  "mappings": "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",
  "names": ["inspect", "asyncTimeout", "Event", "MulticastObservable", "Trigger", "SubscriptionList", "AUTH_TIMEOUT", "inspectObject", "invariant", "PublicKey", "log", "ApiError", "trace", "Trace", "DeviceKind", "Invitation", "HaloProxy", "_serviceProvider", "_traceParent", "_instanceId", "PublicKey", "random", "toHex", "_subscriptions", "SubscriptionList", "_identityChanged", "Event", "_devicesChanged", "_contactsChanged", "_credentialsChanged", "_identity", "MulticastObservable", "from", "_devices", "_contacts", "_credentials", "inspect", "custom", "inspectObject", "toJSON", "identityKey", "get", "truncate", "deviceKey", "device", "identity", "devices", "find", "kind", "DeviceKind", "CURRENT", "contacts", "credentials", "invitations", "invariant", "_invitationProxy", "created", "opened", "undefined", "_open", "log", "trace", "Trace", "begin", "id", "parentId", "gotIdentity", "waitForCount", "services", "InvitationsService", "InvitationsProxy", "IdentityService", "Invitation", "Kind", "DEVICE", "open", "on", "_haloCredentialStream", "SpacesService", "queryCredentials", "spaceKey", "timeout", "RPC_TIMEOUT", "subscribe", "data", "emit", "add", "close", "identityStream", "queryIdentity", "displayName", "profile", "contactsStream", "ContactsService", "queryContacts", "DevicesService", "devicesStream", "queryDevices", "current", "end", "Promise", "all", "_close", "clear", "_waitForIdentity", "waitForCondition", "createIdentity", "deviceProfile", "deviceProfileWithDefaults", "label", "recoverIdentity", "args", "updateProfile", "ids", "type", "filter", "credential", "some", "equals", "subject", "assertion", "share", "options", "ApiError", "invitation", "join", "writeCredentials", "presentCredentials", "nonce", "trigger", "Trigger", "credentialsToPresent", "length", "wake", "asyncTimeout", "wait", "AUTH_TIMEOUT", "signPresentation", "presentation", "info", "depth", "resource"]
}
