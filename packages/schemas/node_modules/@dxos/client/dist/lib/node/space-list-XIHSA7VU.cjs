"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var space_list_XIHSA7VU_exports = {};
__export(space_list_XIHSA7VU_exports, {
  SpaceList: () => SpaceList
});
module.exports = __toCommonJS(space_list_XIHSA7VU_exports);
var import_chunk_Y34HQJFZ = require("./chunk-Y34HQJFZ.cjs");
var import_chunk_MOPAUFKF = require("./chunk-MOPAUFKF.cjs");
var import_chunk_P7Y3AD6I = require("./chunk-P7Y3AD6I.cjs");
var import_node_util = require("node:util");
var import_async = require("@dxos/async");
var import_client_protocol = require("@dxos/client-protocol");
var import_context = require("@dxos/context");
var import_credentials = require("@dxos/credentials");
var import_debug = require("@dxos/debug");
var import_echo_db = require("@dxos/echo-db");
var import_invariant = require("@dxos/invariant");
var import_keys = require("@dxos/keys");
var import_live_object = require("@dxos/live-object");
var import_log = require("@dxos/log");
var import_protocols = require("@dxos/protocols");
var import_services = require("@dxos/protocols/proto/dxos/client/services");
var import_tracing = require("@dxos/tracing");
var import_async2 = require("@dxos/async");
var import_debug2 = require("@dxos/debug");
var import_invariant2 = require("@dxos/invariant");
var import_keys2 = require("@dxos/keys");
var import_log2 = require("@dxos/log");
var import_protocols2 = require("@dxos/protocols");
var import_query = require("@dxos/protocols/proto/dxos/echo/query");
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/sdk/client/src/echo/agent.ts";
var ERR_CLOSING = new Error();
var AgentQuerySourceProvider = class {
  /**
  * Constructor.
  * @param _space Space instance that will be used for messaging with the agent through the gossip protocol.
  */
  constructor(_space) {
    this._space = _space;
    this._responsePromises = /* @__PURE__ */ new Map();
    this._unsubscribe = void 0;
  }
  async open() {
    this._unsubscribe = this._space.listen(import_protocols2.QUERY_CHANNEL, (message) => this._handleMessage(message));
  }
  async close() {
    this._unsubscribe?.();
    this._responsePromises.forEach((promise) => promise.reject(ERR_CLOSING));
    this._responsePromises.clear();
  }
  // TODO(burdon): Make async?
  // TODO(burdon): Define return type.
  _sendRequest(query) {
    const request = {
      queryId: import_keys2.PublicKey.random().toHex(),
      query: JSON.stringify(query),
      reactivity: import_query.QueryReactivity.ONE_SHOT
    };
    this._space.postMessage(import_protocols2.QUERY_CHANNEL, {
      "@type": "dxos.agent.query.QueryRequest",
      ...request
    }).catch((error) => import_log2.log.catch(error, void 0, {
      F: __dxlog_file,
      L: 57,
      S: this,
      C: (f, a) => f(...a)
    }));
    let cancelRequest;
    return {
      response: new Promise((resolve, reject) => {
        (0, import_invariant2.invariant)(request.queryId, void 0, {
          F: __dxlog_file,
          L: 62,
          S: this,
          A: [
            "request.queryId",
            ""
          ]
        });
        this._responsePromises.set(request.queryId, {
          resolve,
          reject
        });
        cancelRequest = () => {
          reject(new Error("Request cancelled."));
          this._responsePromises.delete(request.queryId);
        };
      }),
      cancelRequest: () => {
        cancelRequest();
      }
    };
  }
  _handleMessage(message) {
    if (message.payload["@type"] !== "dxos.agent.query.QueryResponse") {
      return;
    }
    const response = message.payload;
    (0, import_invariant2.invariant)(response.queryId, "QueryId is undefined.", {
      F: __dxlog_file,
      L: 81,
      S: this,
      A: [
        "response.queryId",
        "'QueryId is undefined.'"
      ]
    });
    const responsePromise = this._responsePromises.get(response.queryId);
    if (!responsePromise) {
      (0, import_log2.log)("Request for this response was canceled.", {
        response
      }, {
        F: __dxlog_file,
        L: 84,
        S: this,
        C: (f, a) => f(...a)
      });
      return;
    }
    responsePromise.resolve(response);
    this._responsePromises.delete(response.queryId);
  }
  create() {
    return new AgentQuerySource({
      sendRequest: this._sendRequest.bind(this)
    });
  }
};
var AgentQuerySource = class {
  constructor(_params) {
    this._params = _params;
    this._cancelPreviousRequest = void 0;
    this.changed = new import_async2.Event();
  }
  open() {
  }
  close() {
  }
  getResults() {
    return this._results ?? [];
  }
  async run() {
    return this._results ?? [];
  }
  update(query) {
    this._results = void 0;
    this.changed.emit();
    if (this._cancelPreviousRequest) {
      this._cancelPreviousRequest();
    }
    const startTime = Date.now();
    const { response, cancelRequest } = this._params.sendRequest(query);
    this._cancelPreviousRequest = cancelRequest;
    response.then((response2) => {
      this._results = response2.results?.map((result) => {
        const objSnapshot = response2.objects?.find((obj) => obj.objectId === result.id);
        return {
          id: result.id,
          spaceKey: result.spaceKey,
          spaceId: result.spaceId,
          object: objSnapshot && getEchoObjectFromSnapshot(objSnapshot),
          match: {
            rank: result.rank
          },
          resolution: {
            source: "remote",
            time: Date.now() - startTime
          }
        };
      }) ?? [];
      this.changed.emit();
    }).catch((error) => error === ERR_CLOSING || import_log2.log.catch(error, void 0, {
      F: __dxlog_file,
      L: 164,
      S: this,
      C: (f, a) => f(...a)
    }));
  }
};
var getEchoObjectFromSnapshot = (objSnapshot) => {
  (0, import_invariant2.invariant)(objSnapshot.genesis, "Genesis is undefined.", {
    F: __dxlog_file,
    L: 169,
    S: void 0,
    A: [
      "objSnapshot.genesis",
      "'Genesis is undefined.'"
    ]
  });
  (0, import_invariant2.invariant)(objSnapshot.snapshot, "Genesis model type is undefined.", {
    F: __dxlog_file,
    L: 170,
    S: void 0,
    A: [
      "objSnapshot.snapshot",
      "'Genesis model type is undefined.'"
    ]
  });
  return (0, import_debug2.todo)();
};
function _ts_decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file2 = "/home/runner/work/dxos/dxos/packages/sdk/client/src/echo/space-list.ts";
var ENABLE_AGENT_QUERY_SOURCE = false;
var SpaceList = class extends import_async.MulticastObservable {
  get _isReadyState() {
    return this._isReady.get();
  }
  constructor(_config, _serviceProvider, _echoClient, _halo, _traceParent) {
    const spacesStream = new import_async.PushStream();
    super(spacesStream.observable, []), this._config = _config, this._serviceProvider = _serviceProvider, this._echoClient = _echoClient, this._halo = _halo, this._traceParent = _traceParent, this._defaultSpaceAvailable = new import_async.PushStream(), this._isReady = new import_async.MulticastObservable(this._defaultSpaceAvailable.observable, false), this._spaceCreated = new import_async.Event(), this._instanceId = import_keys.PublicKey.random().toHex();
    this._spacesStream = spacesStream;
  }
  [import_node_util.inspect.custom]() {
    return (0, import_debug.inspectObject)(this);
  }
  get echoClient() {
    return this._echoClient;
  }
  toJSON() {
    return {
      spaces: this._value?.length
    };
  }
  /**
  * @internal
  */
  async _open() {
    import_log.log.trace("dxos.sdk.echo-proxy.open", import_protocols.trace.begin({
      id: this._instanceId,
      parentId: this._traceParent
    }), {
      F: __dxlog_file2,
      L: 94,
      S: this,
      C: (f, a) => f(...a)
    });
    this._ctx = new import_context.Context({
      onError: (error) => {
        import_log.log.catch(error, void 0, {
          F: __dxlog_file2,
          L: 97,
          S: this,
          C: (f, a) => f(...a)
        });
      }
    }, {
      F: __dxlog_file2,
      L: 95
    });
    const credentialsSubscription = this._halo.credentials.subscribe(() => {
      if (this._updateAndOpenDefaultSpace()) {
        credentialsSubscription.unsubscribe();
      }
    });
    this._ctx.onDispose(() => credentialsSubscription.unsubscribe());
    (0, import_invariant.invariant)(this._serviceProvider.services.SpacesService, "SpacesService is not available.", {
      F: __dxlog_file2,
      L: 108,
      S: this,
      A: [
        "this._serviceProvider.services.SpacesService",
        "'SpacesService is not available.'"
      ]
    });
    (0, import_invariant.invariant)(this._serviceProvider.services.InvitationsService, "InvitationsService is not available.", {
      F: __dxlog_file2,
      L: 109,
      S: this,
      A: [
        "this._serviceProvider.services.InvitationsService",
        "'InvitationsService is not available.'"
      ]
    });
    this._invitationProxy = new import_chunk_MOPAUFKF.InvitationsProxy(this._serviceProvider.services.InvitationsService, this._serviceProvider.services.IdentityService, () => ({
      kind: import_services.Invitation.Kind.SPACE
    }));
    await this._invitationProxy.open();
    const gotInitialUpdate = new import_async.Trigger();
    const spacesStream = this._serviceProvider.services.SpacesService.querySpaces(void 0, {
      timeout: import_chunk_P7Y3AD6I.RPC_TIMEOUT
    });
    spacesStream.subscribe((data) => {
      let emitUpdate = false;
      const newSpaces = this.get();
      for (const space of data.spaces ?? []) {
        if (this._ctx.disposed) {
          return;
        }
        let spaceProxy = newSpaces.find(({ key }) => key.equals(space.spaceKey));
        if (!spaceProxy) {
          spaceProxy = new import_chunk_Y34HQJFZ.SpaceProxy(this._serviceProvider, space, this._echoClient);
          if (this._shouldOpenSpace(space)) {
            this._openSpaceAsync(spaceProxy);
          }
          spaceProxy._stateUpdate.on(this._ctx, () => {
            this._spacesStream.next([
              ...this.get()
            ]);
          });
          newSpaces.push(spaceProxy);
          this._spaceCreated.emit(spaceProxy.key);
          if (this._defaultSpaceId && spaceProxy.id === this._defaultSpaceId) {
            this._defaultSpaceAvailable.next(true);
          }
          emitUpdate = true;
        }
        (0, import_async.scheduleMicroTask)(this._ctx, async () => {
          await spaceProxy._processSpaceUpdate(space);
        });
      }
      gotInitialUpdate.wake();
      if (emitUpdate) {
        this._spacesStream.next([
          ...newSpaces
        ]);
      }
    });
    this._ctx.onDispose(() => spacesStream.close());
    if (ENABLE_AGENT_QUERY_SOURCE) {
      const subscription = this._isReady.subscribe(async (ready) => {
        if (!ready) {
          return;
        }
        const agentQuerySourceProvider = new AgentQuerySourceProvider(this.default);
        await agentQuerySourceProvider.open();
        this._echoClient.graph.registerQuerySourceProvider(agentQuerySourceProvider);
        this._ctx.onDispose(() => agentQuerySourceProvider.close());
        subscription.unsubscribe();
      });
      this._ctx.onDispose(() => subscription.unsubscribe());
    }
    await gotInitialUpdate.wait();
    import_log.log.trace("dxos.sdk.echo-proxy.open", import_protocols.trace.end({
      id: this._instanceId
    }), {
      F: __dxlog_file2,
      L: 188,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  _updateAndOpenDefaultSpace() {
    const defaultSpaceCredential = this._halo.queryCredentials({
      type: "dxos.halo.credentials.DefaultSpace"
    })[0];
    const defaultSpaceAssertion = defaultSpaceCredential && (0, import_credentials.getCredentialAssertion)(defaultSpaceCredential);
    if (defaultSpaceAssertion?.["@type"] !== "dxos.halo.credentials.DefaultSpace") {
      return false;
    }
    if (!import_keys.SpaceId.isValid(defaultSpaceAssertion.spaceId)) {
      return false;
    }
    this._defaultSpaceId = defaultSpaceAssertion.spaceId;
    const defaultSpace = this._spaces.find((space) => space.id === defaultSpaceAssertion.spaceId);
    (0, import_log.log)("defaultSpaceKey read from a credential", {
      spaceExists: defaultSpace != null,
      spaceOpen: defaultSpace?.isOpen,
      spaceId: this._defaultSpaceId
    }, {
      F: __dxlog_file2,
      L: 205,
      S: this,
      C: (f, a) => f(...a)
    });
    if (defaultSpace) {
      if (defaultSpace.state.get() === import_services.SpaceState.SPACE_CLOSED) {
        this._openSpaceAsync(defaultSpace);
      }
      this._defaultSpaceAvailable.next(true);
    }
    return true;
  }
  _openSpaceAsync(spaceProxy) {
    void spaceProxy.open().catch((err) => import_log.log.catch(err, void 0, {
      F: __dxlog_file2,
      L: 222,
      S: this,
      C: (f, a) => f(...a)
    }));
  }
  _shouldOpenSpace(space) {
    if (this._ctx.disposed || space.state === import_services.SpaceState.SPACE_INACTIVE) {
      return false;
    }
    if (!this._config?.values?.runtime?.client?.lazySpaceOpen) {
      return true;
    }
    return space.id === this._defaultSpaceId;
  }
  async setConfig(config) {
    await this._serviceProvider.services.QueryService?.setConfig(config, {
      timeout: 2e4
    });
  }
  /**
  * @internal
  */
  async _close() {
    await this._ctx.dispose();
    await Promise.all(this.get().map((space) => space._destroy()));
    this._spacesStream.next([]);
    await this._invitationProxy?.close();
    this._invitationProxy = void 0;
    this._defaultSpaceAvailable.next(false);
    this._defaultSpaceId = void 0;
  }
  get isReady() {
    return this._isReady;
  }
  async waitUntilReady() {
    return new Promise((resolve) => {
      const subscription = this._isReady.subscribe((isReady) => {
        if (isReady) {
          subscription.unsubscribe();
          resolve();
        }
      });
    });
  }
  get(spaceIdOrKey) {
    if (!spaceIdOrKey) {
      return this._value;
    }
    if (spaceIdOrKey instanceof import_keys.PublicKey) {
      return this._value?.find(({ key }) => key.equals(spaceIdOrKey));
    } else {
      if (!import_keys.SpaceId.isValid(spaceIdOrKey)) {
        throw new import_protocols.ApiError("Invalid space id.");
      }
      return this._value?.find(({ id }) => id === spaceIdOrKey);
    }
  }
  get _spaces() {
    return this.get();
  }
  get default() {
    (0, import_invariant.invariant)(this._defaultSpaceId, "Default space ID not set.", {
      F: __dxlog_file2,
      L: 293,
      S: this,
      A: [
        "this._defaultSpaceId",
        "'Default space ID not set.'"
      ]
    });
    const space = this.get().find((space2) => space2.id === this._defaultSpaceId);
    (0, import_invariant.invariant)(space, "Default space is not yet available. Use `client.spaces.isReady` to wait for the default space.", {
      F: __dxlog_file2,
      L: 295,
      S: this,
      A: [
        "space",
        "'Default space is not yet available. Use `client.spaces.isReady` to wait for the default space.'"
      ]
    });
    return space;
  }
  async create(meta) {
    (0, import_invariant.invariant)(this._serviceProvider.services.SpacesService, "SpacesService is not available.", {
      F: __dxlog_file2,
      L: 300,
      S: this,
      A: [
        "this._serviceProvider.services.SpacesService",
        "'SpacesService is not available.'"
      ]
    });
    const traceId = import_keys.PublicKey.random().toHex();
    import_log.log.trace("dxos.sdk.echo-proxy.create-space", import_protocols.trace.begin({
      id: traceId
    }), {
      F: __dxlog_file2,
      L: 302,
      S: this,
      C: (f, a) => f(...a)
    });
    const space = await this._serviceProvider.services.SpacesService.createSpace(void 0, {
      timeout: import_chunk_P7Y3AD6I.RPC_TIMEOUT
    });
    await this._spaceCreated.waitForCondition(() => {
      return this.get().some(({ key }) => key.equals(space.spaceKey));
    });
    const spaceProxy = this._findProxy(space);
    await spaceProxy._databaseInitialized.wait({
      timeout: import_client_protocol.CREATE_SPACE_TIMEOUT
    });
    spaceProxy.db.add((0, import_live_object.live)(import_client_protocol.PropertiesType, meta ?? {}), {
      placeIn: "root-doc"
    });
    await spaceProxy.db.flush();
    await spaceProxy._initializationComplete.wait();
    import_log.log.trace("dxos.sdk.echo-proxy.create-space", import_protocols.trace.end({
      id: traceId
    }), {
      F: __dxlog_file2,
      L: 315,
      S: this,
      C: (f, a) => f(...a)
    });
    return spaceProxy;
  }
  /**
  * @internal
  */
  async import(archive) {
    (0, import_invariant.invariant)(this._serviceProvider.services.SpacesService, "SpaceService is not available.", {
      F: __dxlog_file2,
      L: 323,
      S: this,
      A: [
        "this._serviceProvider.services.SpacesService",
        "'SpaceService is not available.'"
      ]
    });
    const { newSpaceId } = await this._serviceProvider.services.SpacesService.importSpace({
      archive
    }, {
      timeout: import_client_protocol.CREATE_SPACE_TIMEOUT
    });
    (0, import_invariant.invariant)(import_keys.SpaceId.isValid(newSpaceId), "Invalid space ID", {
      F: __dxlog_file2,
      L: 328,
      S: this,
      A: [
        "SpaceId.isValid(newSpaceId)",
        "'Invalid space ID'"
      ]
    });
    await this._spaceCreated.waitForCondition(() => {
      return this.get().some((space) => space.id === newSpaceId);
    });
    const spaceProxy = this.get(newSpaceId) ?? (0, import_invariant.failedInvariant)();
    await spaceProxy.waitUntilReady();
    return spaceProxy;
  }
  join(invitation) {
    if (!this._invitationProxy) {
      throw new import_protocols.ApiError("Client not open.");
    }
    (0, import_log.log)("accept invitation", invitation, {
      F: __dxlog_file2,
      L: 343,
      S: this,
      C: (f, a) => f(...a)
    });
    return this._invitationProxy.join(invitation);
  }
  async joinBySpaceKey(spaceKey) {
    const response = await this._serviceProvider.services.SpacesService.joinBySpaceKey({
      spaceKey
    });
    return this._findProxy(response.space);
  }
  static {
    this.prototype.query = this.prototype._query;
  }
  _query(query, options) {
    query = import_echo_db.Filter.is(query) ? import_echo_db.Query.select(query) : query;
    return this._echoClient.graph.query(query, options);
  }
  _findProxy(space) {
    return this.get().find(({ key }) => key.equals(space.spaceKey)) ?? (0, import_debug.failUndefined)();
  }
};
_ts_decorate([
  import_tracing.trace.info()
], SpaceList.prototype, "_isReadyState", null);
_ts_decorate([
  import_tracing.trace.info({
    depth: null
  })
], SpaceList.prototype, "toJSON", null);
_ts_decorate([
  import_tracing.trace.span()
], SpaceList.prototype, "_open", null);
_ts_decorate([
  import_tracing.trace.span()
], SpaceList.prototype, "_close", null);
_ts_decorate([
  import_tracing.trace.info()
], SpaceList.prototype, "_spaces", null);
SpaceList = _ts_decorate([
  import_tracing.trace.resource()
], SpaceList);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  SpaceList
});
//# sourceMappingURL=space-list-XIHSA7VU.cjs.map
