{
  "version": 3,
  "sources": ["../../../src/index.ts", "../../../src/util/helpers.ts"],
  "sourcesContent": ["//\n// Copyright 2020 DXOS.org\n//\n\nexport { type ClientServices, type ClientServicesProvider, type ShellRuntime } from '@dxos/client-protocol';\nexport { Config, Defaults, Dynamics, Envs, Local, Remote, Storage } from '@dxos/config';\nexport { PublicKey, type PublicKeyLike } from '@dxos/keys';\nexport {\n  AlreadyJoinedError,\n  ApiError,\n  CancelledError,\n  DataCorruptionError,\n  DatabaseError,\n  EntityNotFoundError,\n  InvalidConfigError,\n  InvalidInvitationError,\n  InvalidInvitationExtensionRoleError,\n  IdentityNotInitializedError,\n  InvalidStorageVersionError,\n  RemoteServiceConnectionError,\n  RemoteServiceConnectionTimeout,\n  RpcClosedError,\n  RpcNotOpenError,\n  SystemError,\n  UnknownModelError,\n} from '@dxos/protocols';\nexport { SystemStatus } from '@dxos/protocols/proto/dxos/client/services';\nexport {\n  type AppContextRequest,\n  type LayoutRequest,\n  type InvitationUrlRequest,\n  ShellDisplay,\n  ShellLayout,\n} from '@dxos/protocols/proto/dxos/iframe';\n\n// TODO(burdon): Use \"export *\" and @internal to restrict exports.\n// TODO(wittjosiah): Should all api errors be exported here?\n\n// For some reason the * re-export from ./client gets removed by TSC. Looks like a compiler bug.\nexport { type Client } from './client';\nexport * from './client';\nexport * from './services';\nexport * from './util';\nexport * from './version';\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport type { Obj, Relation } from '@dxos/echo';\nimport { invariant } from '@dxos/invariant';\nimport { type DXN } from '@dxos/keys';\n\nimport { type Client } from '../client';\nimport { type Space } from '../echo';\n\n// TODO(burdon): Type check?\n// TOOD(burdon): Move to client class?\n// TODO(dmaretskyi): Align with `graph.createRefResolver` API.\nexport const resolveRef = async <T extends Obj.Any | Relation.Any = Obj.Any | Relation.Any>(\n  client: Client,\n  dxn: DXN,\n  defaultSpace?: Space,\n): Promise<T | undefined> => {\n  const echoDxn = dxn?.asEchoDXN();\n  if (echoDxn) {\n    const space = echoDxn.spaceId ? client.spaces.get(echoDxn.spaceId) : defaultSpace;\n    if (!space) {\n      return undefined;\n    }\n\n    return space.db.getObjectById<T>(echoDxn.echoId);\n  }\n\n  const queueDxn = dxn?.asQueueDXN();\n  if (queueDxn) {\n    const { spaceId, objectId } = dxn.asQueueDXN()!;\n    invariant(objectId, 'objectId missing');\n    const queue = client.spaces.get(spaceId)?.queues.get<T>(dxn);\n    invariant(queue, 'queue missing');\n    return queue.objects.find((object) => object.id === objectId);\n  }\n\n  return undefined;\n};\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKA,oBAAyE;AACzE,kBAA8C;AAC9C,uBAkBO;AACP,sBAA6B;AAC7B,oBAMO;AC5BP,uBAA0B;;AASnB,IAAMA,aAAa,OACxBC,QACAC,KACAC,iBAAAA;AAEA,QAAMC,UAAUF,KAAKG,UAAAA;AACrB,MAAID,SAAS;AACX,UAAME,QAAQF,QAAQG,UAAUN,OAAOO,OAAOC,IAAIL,QAAQG,OAAO,IAAIJ;AACrE,QAAI,CAACG,OAAO;AACV,aAAOI;IACT;AAEA,WAAOJ,MAAMK,GAAGC,cAAiBR,QAAQS,MAAM;EACjD;AAEA,QAAMC,WAAWZ,KAAKa,WAAAA;AACtB,MAAID,UAAU;AACZ,UAAM,EAAEP,SAASS,SAAQ,IAAKd,IAAIa,WAAU;AAC5CE,oCAAUD,UAAU,oBAAA;;;;;;;;;AACpB,UAAME,QAAQjB,OAAOO,OAAOC,IAAIF,OAAAA,GAAUY,OAAOV,IAAOP,GAAAA;AACxDe,oCAAUC,OAAO,iBAAA;;;;;;;;;AACjB,WAAOA,MAAME,QAAQC,KAAK,CAACC,WAAWA,OAAOC,OAAOP,QAAAA;EACtD;AAEA,SAAON;AACT;",
  "names": ["resolveRef", "client", "dxn", "defaultSpace", "echoDxn", "asEchoDXN", "space", "spaceId", "spaces", "get", "undefined", "db", "getObjectById", "echoId", "queueDxn", "asQueueDXN", "objectId", "invariant", "queue", "queues", "objects", "find", "object", "id"]
}
