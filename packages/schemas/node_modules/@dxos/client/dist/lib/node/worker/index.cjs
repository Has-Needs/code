"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var worker_exports = {};
__export(worker_exports, {
  getWorkerServiceHost: () => getWorkerServiceHost,
  onconnect: () => onconnect
});
module.exports = __toCommonJS(worker_exports);
var import_chunk_YKGR2TP6 = require("../chunk-YKGR2TP6.cjs");
var import_chunk_HIRCX7XT = require("../chunk-HIRCX7XT.cjs");
var import_chunk_Y34HQJFZ = require("../chunk-Y34HQJFZ.cjs");
var import_chunk_MOPAUFKF = require("../chunk-MOPAUFKF.cjs");
var import_chunk_MVOI3MV3 = require("../chunk-MVOI3MV3.cjs");
var import_chunk_P7Y3AD6I = require("../chunk-P7Y3AD6I.cjs");
var import_async = require("@dxos/async");
var import_config = require("@dxos/config");
var import_log = require("@dxos/log");
var import_rpc_tunnel = require("@dxos/rpc-tunnel");
var import_tracing = require("@dxos/tracing");
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/sdk/client/src/worker/onconnect.ts";
import_tracing.TRACE_PROCESSOR.setInstanceTag("shared-worker");
var releaseLock;
var lockPromise = new Promise((resolve) => releaseLock = resolve);
var lockAcquired = new import_async.Trigger();
void navigator.locks.request(import_chunk_MVOI3MV3.LOCK_KEY, (lock) => {
  lockAcquired.wake();
  return lockPromise;
});
var setupRuntime = async () => {
  const { WorkerRuntime } = await import("@dxos/client-services");
  const workerRuntime = new WorkerRuntime({
    configProvider: async () => {
      const config = new import_config.Config(await (0, import_config.Storage)(), (0, import_config.Envs)(), (0, import_config.Local)(), (0, import_config.Defaults)());
      import_log.log.config({
        filter: config.get("runtime.client.log.filter"),
        prefix: config.get("runtime.client.log.prefix")
      }, void 0, {
        F: __dxlog_file,
        L: 30,
        S: void 0,
        C: (f, a) => f(...a)
      });
      return config;
    },
    acquireLock: () => lockAcquired.wait(),
    releaseLock: () => releaseLock(),
    onStop: async () => {
      self.close();
    }
  });
  (0, import_chunk_YKGR2TP6.mountDevtoolsHooks)({
    host: workerRuntime.host
  });
  return workerRuntime;
};
var workerRuntimePromise = setupRuntime();
var start = Date.now();
void workerRuntimePromise.then((workerRuntime) => workerRuntime.start()).then(() => {
  import_log.log.info("worker ready", {
    initTimeMs: Date.now() - start
  }, {
    F: __dxlog_file,
    L: 56,
    S: void 0,
    C: (f, a) => f(...a)
  });
}, (err) => {
  import_log.log.catch(err, void 0, {
    F: __dxlog_file,
    L: 59,
    S: void 0,
    C: (f, a) => f(...a)
  });
});
var onconnect = async (event) => {
  import_log.log.info("onconnect", {
    event
  }, {
    F: __dxlog_file,
    L: 64,
    S: void 0,
    C: (f, a) => f(...a)
  });
  const port = event.ports[0];
  const systemChannel = new MessageChannel();
  const appChannel = new MessageChannel();
  port.onmessage = (event2) => {
    globalThis.localStorage_dxlog = event2.data.dxlog;
  };
  port.postMessage({
    command: "init",
    payload: {
      systemPort: systemChannel.port1,
      appPort: appChannel.port1
    }
  }, [
    systemChannel.port1,
    appChannel.port1
  ]);
  const workerRuntime = await workerRuntimePromise;
  await workerRuntime.createSession({
    systemPort: (0, import_rpc_tunnel.createWorkerPort)({
      port: systemChannel.port2
    }),
    appPort: (0, import_rpc_tunnel.createWorkerPort)({
      port: appChannel.port2
    })
  });
};
var getWorkerServiceHost = async () => (await workerRuntimePromise).host;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  getWorkerServiceHost,
  onconnect
});
//# sourceMappingURL=index.cjs.map
