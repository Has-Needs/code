"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var halo_proxy_L4NPYTSH_exports = {};
__export(halo_proxy_L4NPYTSH_exports, {
  HaloProxy: () => HaloProxy
});
module.exports = __toCommonJS(halo_proxy_L4NPYTSH_exports);
var import_chunk_MOPAUFKF = require("./chunk-MOPAUFKF.cjs");
var import_chunk_P7Y3AD6I = require("./chunk-P7Y3AD6I.cjs");
var import_node_util = require("node:util");
var import_async = require("@dxos/async");
var import_client_protocol = require("@dxos/client-protocol");
var import_debug = require("@dxos/debug");
var import_invariant = require("@dxos/invariant");
var import_keys = require("@dxos/keys");
var import_log = require("@dxos/log");
var import_protocols = require("@dxos/protocols");
var import_services = require("@dxos/protocols/proto/dxos/client/services");
var import_tracing = require("@dxos/tracing");
function _ts_decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/sdk/client/src/halo/halo-proxy.ts";
var HaloProxy = class {
  constructor(_serviceProvider, _traceParent) {
    this._serviceProvider = _serviceProvider;
    this._traceParent = _traceParent;
    this._instanceId = import_keys.PublicKey.random().toHex();
    this._subscriptions = new import_async.SubscriptionList();
    this._identityChanged = new import_async.Event();
    this._devicesChanged = new import_async.Event();
    this._contactsChanged = new import_async.Event();
    this._credentialsChanged = new import_async.Event();
    this._identity = import_async.MulticastObservable.from(this._identityChanged, null);
    this._devices = import_async.MulticastObservable.from(this._devicesChanged, []);
    this._contacts = import_async.MulticastObservable.from(this._contactsChanged, []);
    this._credentials = import_async.MulticastObservable.from(this._credentialsChanged, []);
  }
  [import_node_util.inspect.custom]() {
    return (0, import_debug.inspectObject)(this);
  }
  toJSON() {
    return {
      identityKey: this._identity.get()?.identityKey.truncate(),
      deviceKey: this.device?.deviceKey.truncate()
    };
  }
  /**
  * User identity info.
  */
  get identity() {
    return this._identity;
  }
  get devices() {
    return this._devices;
  }
  get device() {
    return this._devices.get().find((device) => device.kind === import_services.DeviceKind.CURRENT);
  }
  get contacts() {
    return this._contacts;
  }
  get credentials() {
    return this._credentials;
  }
  get invitations() {
    (0, import_invariant.invariant)(this._invitationProxy, "HaloProxy not opened", {
      F: __dxlog_file,
      L: 95,
      S: this,
      A: [
        "this._invitationProxy",
        "'HaloProxy not opened'"
      ]
    });
    return this._invitationProxy.created;
  }
  // TODO(burdon): Standardize isOpen, etc.
  get opened() {
    return this._invitationProxy !== void 0;
  }
  /**
  * Allocate resources and set-up internal subscriptions.
  *
  * @internal
  */
  async _open() {
    import_log.log.trace("dxos.sdk.halo-proxy.open", import_protocols.trace.begin({
      id: this._instanceId,
      parentId: this._traceParent
    }), {
      F: __dxlog_file,
      L: 111,
      S: this,
      C: (f, a) => f(...a)
    });
    const gotIdentity = this._identityChanged.waitForCount(1);
    (0, import_invariant.invariant)(this._serviceProvider.services.InvitationsService, "InvitationsService not available", {
      F: __dxlog_file,
      L: 115,
      S: this,
      A: [
        "this._serviceProvider.services.InvitationsService",
        "'InvitationsService not available'"
      ]
    });
    this._invitationProxy = new import_chunk_MOPAUFKF.InvitationsProxy(this._serviceProvider.services.InvitationsService, this._serviceProvider.services.IdentityService, () => ({
      kind: import_services.Invitation.Kind.DEVICE
    }));
    await this._invitationProxy.open();
    this._identityChanged.on((identity) => {
      if (identity && !this._haloCredentialStream) {
        (0, import_invariant.invariant)(this._serviceProvider.services.SpacesService, "SpacesService not available", {
          F: __dxlog_file,
          L: 127,
          S: this,
          A: [
            "this._serviceProvider.services.SpacesService",
            "'SpacesService not available'"
          ]
        });
        this._haloCredentialStream = this._serviceProvider.services.SpacesService.queryCredentials({
          spaceKey: identity.spaceKey
        }, {
          timeout: import_chunk_P7Y3AD6I.RPC_TIMEOUT
        });
        this._haloCredentialStream.subscribe((data) => {
          this._credentialsChanged.emit([
            ...this._credentials.get(),
            data
          ]);
        });
        this._subscriptions.add(() => this._haloCredentialStream?.close());
      }
    });
    (0, import_invariant.invariant)(this._serviceProvider.services.IdentityService, "IdentityService not available", {
      F: __dxlog_file,
      L: 141,
      S: this,
      A: [
        "this._serviceProvider.services.IdentityService",
        "'IdentityService not available'"
      ]
    });
    const identityStream = this._serviceProvider.services.IdentityService.queryIdentity(void 0, {
      timeout: import_chunk_P7Y3AD6I.RPC_TIMEOUT
    });
    identityStream.subscribe((data) => {
      data.identity && import_log.log.trace("dxos.halo.identity", {
        identityKey: data.identity.identityKey,
        displayName: data.identity.profile?.displayName
      }, {
        F: __dxlog_file,
        L: 148,
        S: this,
        C: (f, a) => f(...a)
      });
      this._identityChanged.emit(data.identity ?? null);
    });
    this._subscriptions.add(() => identityStream.close());
    const contactsStream = this._serviceProvider.services.ContactsService.queryContacts(void 0, {
      timeout: import_chunk_P7Y3AD6I.RPC_TIMEOUT
    });
    contactsStream.subscribe((data) => {
      this._contactsChanged.emit(data.contacts ?? []);
    });
    this._subscriptions.add(() => contactsStream.close());
    (0, import_invariant.invariant)(this._serviceProvider.services.DevicesService, "DevicesService not available", {
      F: __dxlog_file,
      L: 164,
      S: this,
      A: [
        "this._serviceProvider.services.DevicesService",
        "'DevicesService not available'"
      ]
    });
    const devicesStream = this._serviceProvider.services.DevicesService.queryDevices(void 0, {
      timeout: import_chunk_P7Y3AD6I.RPC_TIMEOUT
    });
    devicesStream.subscribe((data) => {
      if (data.devices) {
        this._devicesChanged.emit(data.devices);
        const current = data.devices.find((device) => device.kind === import_services.DeviceKind.CURRENT);
        import_log.log.trace("dxos.halo.device", {
          deviceKey: current?.deviceKey,
          profile: current?.profile
        }, {
          F: __dxlog_file,
          L: 172,
          S: this,
          C: (f, a) => f(...a)
        });
      }
    });
    this._subscriptions.add(() => devicesStream.close());
    import_log.log.trace("dxos.sdk.halo-proxy.open", import_protocols.trace.end({
      id: this._instanceId
    }), {
      F: __dxlog_file,
      L: 180,
      S: this,
      C: (f, a) => f(...a)
    });
    await Promise.all([
      gotIdentity
    ]);
  }
  /**
  * Destroy the instance and clean-up subscriptions.
  *
  * @internal
  */
  async _close() {
    await this._invitationProxy?.close();
    this._invitationProxy = void 0;
    this._subscriptions.clear();
    this._identityChanged.emit(null);
    this._devicesChanged.emit([]);
    this._contactsChanged.emit([]);
  }
  /**
  * @internal
  */
  // TODO(wittjosiah): Should `Observable` class support this?
  _waitForIdentity() {
    return this._identityChanged.waitForCondition(() => !!this._identity.get());
  }
  /**
  * Create Identity.
  * Then initializes profile with given display name.
  * @param profile - optional display name
  * @param deviceProfile - optional device profile that will be merged with defaults
  */
  async createIdentity(profile = {}, deviceProfile) {
    (0, import_invariant.invariant)(this._serviceProvider.services.IdentityService, "IdentityService not available", {
      F: __dxlog_file,
      L: 213,
      S: this,
      A: [
        "this._serviceProvider.services.IdentityService",
        "'IdentityService not available'"
      ]
    });
    (0, import_invariant.invariant)(!this.identity.get(), "Identity already exists", {
      F: __dxlog_file,
      L: 214,
      S: this,
      A: [
        "!this.identity.get()",
        "'Identity already exists'"
      ]
    });
    const deviceProfileWithDefaults = {
      ...deviceProfile,
      ...deviceProfile?.label ? {
        label: deviceProfile.label
      } : {
        label: "initial identity device"
      }
    };
    const identity = await this._serviceProvider.services.IdentityService.createIdentity({
      profile,
      deviceProfile: deviceProfileWithDefaults
    }, {
      timeout: import_chunk_P7Y3AD6I.RPC_TIMEOUT
    });
    this._identityChanged.emit(identity);
    return identity;
  }
  async recoverIdentity(args) {
    (0, import_invariant.invariant)(this._serviceProvider.services.IdentityService, "IdentityService not available", {
      F: __dxlog_file,
      L: 231,
      S: this,
      A: [
        "this._serviceProvider.services.IdentityService",
        "'IdentityService not available'"
      ]
    });
    const identity = await this._serviceProvider.services.IdentityService.recoverIdentity(args, {
      timeout: import_chunk_P7Y3AD6I.RPC_TIMEOUT
    });
    this._identityChanged.emit(identity);
    return identity;
  }
  async updateProfile(profile) {
    (0, import_invariant.invariant)(this._serviceProvider.services.IdentityService, "IdentityService not available", {
      F: __dxlog_file,
      L: 240,
      S: this,
      A: [
        "this._serviceProvider.services.IdentityService",
        "'IdentityService not available'"
      ]
    });
    const identity = await this._serviceProvider.services.IdentityService.updateProfile(profile, {
      timeout: import_chunk_P7Y3AD6I.RPC_TIMEOUT
    });
    this._identityChanged.emit(identity);
    return identity;
  }
  /**
  * Get Halo credentials for the current user.
  * Note: Will return an empty result if called before all credentials have been loaded.
  */
  queryCredentials({ ids, type } = {}) {
    return this._credentials.get().filter((credential) => {
      if (ids && !ids.some((id) => id.equals(credential.id))) {
        return false;
      }
      if (type && credential.subject.assertion["@type"] !== type) {
        return false;
      }
      return true;
    });
  }
  /**
  * Initiates device invitation.
  */
  share(options) {
    if (!this.opened) {
      throw new import_protocols.ApiError("Client not open.");
    }
    (0, import_log.log)("create invitation", {
      options
    }, {
      F: __dxlog_file,
      L: 272,
      S: this,
      C: (f, a) => f(...a)
    });
    const invitation = this._invitationProxy.share(options);
    return invitation;
  }
  /**
  * Initiates accepting invitation.
  * @param invitation
  * @param deviceProfile - optional device profile that will be merged with defaults
  */
  join(invitation, deviceProfile) {
    if (!this.opened) {
      throw new import_protocols.ApiError("Client not open.");
    }
    const deviceProfileWithDefaults = {
      ...deviceProfile,
      ...deviceProfile?.label ? {
        label: deviceProfile.label
      } : {
        label: "additional device"
      }
    };
    return this._invitationProxy.join(invitation, deviceProfileWithDefaults);
  }
  /**
  * Write credentials to halo profile.
  */
  async writeCredentials(credentials) {
    const identity = this._identity.get();
    if (!identity) {
      throw new import_protocols.ApiError("Identity is not available.");
    }
    if (!this._serviceProvider.services.SpacesService) {
      throw new import_protocols.ApiError("SpacesService is not available.");
    }
    return this._serviceProvider.services.SpacesService.writeCredentials({
      spaceKey: identity.spaceKey,
      credentials
    }, {
      timeout: import_chunk_P7Y3AD6I.RPC_TIMEOUT
    });
  }
  /**
  * Present Credentials.
  */
  // TODO(burdon): Rename createPresentation?
  async presentCredentials({ ids, nonce }) {
    if (!this._serviceProvider.services.IdentityService) {
      throw new import_protocols.ApiError("IdentityService is not available.");
    }
    const trigger = new import_async.Trigger();
    this._credentials.subscribe((credentials2) => {
      const credentialsToPresent = credentials2.filter((credential) => ids.some((id) => id.equals(credential.id)));
      if (credentialsToPresent.length === ids.length) {
        trigger.wake(credentialsToPresent);
      }
    });
    const credentials = await (0, import_async.asyncTimeout)(trigger.wait(), import_client_protocol.AUTH_TIMEOUT, new import_protocols.ApiError("Timeout while waiting for credentials."));
    return this._serviceProvider.services.IdentityService.signPresentation({
      presentation: {
        credentials
      },
      nonce
    }, {
      timeout: import_chunk_P7Y3AD6I.RPC_TIMEOUT
    });
  }
};
_ts_decorate([
  import_tracing.trace.info({
    depth: null
  })
], HaloProxy.prototype, "toJSON", null);
_ts_decorate([
  import_tracing.trace.info()
], HaloProxy.prototype, "opened", null);
HaloProxy = _ts_decorate([
  import_tracing.trace.resource()
], HaloProxy);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  HaloProxy
});
//# sourceMappingURL=halo-proxy-L4NPYTSH.cjs.map
