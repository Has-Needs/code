{
  "version": 3,
  "sources": ["../../../src/services/agent.ts", "../../../src/services/client-services-factory.tsx", "../../../src/services/local-client-services.ts", "../../../src/services/socket.ts", "../../../src/services/worker-client-services.ts", "../../../src/services/service-proxy.ts", "../../../src/services/shared-worker-connection.ts", "../../../src/services/iframe-manager.ts", "../../../src/services/shell.ts", "../../../src/services/shell-manager.ts", "../../../src/services/agent-hosting-provider.ts", "../../../src/services/fake-agent-hosting-provider.ts"],
  "sourcesContent": ["//\n// Copyright 2023 DXOS.org\n//\n\nimport { Event } from '@dxos/async';\nimport {\n  DX_RUNTIME,\n  ENV_DX_PROFILE,\n  ENV_DX_PROFILE_DEFAULT,\n  type ClientServices,\n  type ClientServicesProvider,\n  clientServiceBundle,\n  getProfilePath,\n} from '@dxos/client-protocol';\nimport { ClientServicesProviderResource } from '@dxos/client-protocol';\nimport { log } from '@dxos/log';\nimport { type ServiceBundle } from '@dxos/rpc';\nimport { trace } from '@dxos/tracing';\nimport type { WebsocketRpcClient } from '@dxos/websocket-rpc';\n\nexport const getUnixSocket = (profile: string, protocol = 'unix') =>\n  `${protocol}://` + getProfilePath(DX_RUNTIME, profile, 'agent.sock');\n\nexport type FromAgentOptions = {\n  profile?: string;\n};\n\n/**\n * Connects to locally running CLI daemon.\n */\nexport const fromAgent = ({\n  profile = process.env[ENV_DX_PROFILE] ?? ENV_DX_PROFILE_DEFAULT,\n}: FromAgentOptions = {}): ClientServicesProvider => {\n  return new AgentClientServiceProvider(profile);\n};\n\n@trace.resource({ annotation: ClientServicesProviderResource })\nexport class AgentClientServiceProvider implements ClientServicesProvider {\n  // TODO(wittjosiah): Fire an event if the socket disconnects.\n  readonly closed = new Event<Error | undefined>();\n  private _client?: WebsocketRpcClient<ClientServices, {}>;\n\n  constructor(private readonly _profile: string) {}\n\n  get descriptors(): ServiceBundle<ClientServices> {\n    return clientServiceBundle;\n  }\n\n  get services(): Partial<ClientServices> {\n    return this._client!.rpc;\n  }\n\n  async open(): Promise<void> {\n    const { WebsocketRpcClient } = await import('@dxos/websocket-rpc');\n    this._client = new WebsocketRpcClient({\n      url: getUnixSocket(this._profile, 'ws+unix'),\n      requested: clientServiceBundle,\n      exposed: {},\n      handlers: {},\n    });\n\n    this._client.error.on((error) => {\n      this.closed.emit(error);\n    });\n    await this._client.open();\n  }\n\n  async close(): Promise<void> {\n    try {\n      await this._client?.close();\n    } catch (err) {\n      log.warn('Failed to close', err);\n    }\n  }\n}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { UAParser } from 'ua-parser-js';\n\nimport { type ClientServicesProvider } from '@dxos/client-protocol';\nimport { type Config } from '@dxos/config';\n\nimport { fromHost } from './local-client-services';\nimport { fromSocket } from './socket';\nimport { type WorkerClientServicesParams, fromWorker } from './worker-client-services';\n\n/**\n * Create services from config.\n * @param config\n * @param createWorker\n * @param observabilityGroup - Optional observability group that will be sent with Signaling metadata.\n * @param signalTelemetryEnabled - Optional flag to enable telemetry metadata sent with Signaling requests.\n */\nexport const createClientServices = (\n  config: Config,\n  createWorker?: WorkerClientServicesParams['createWorker'],\n  observabilityGroup?: string,\n  signalTelemetryEnabled?: boolean,\n): Promise<ClientServicesProvider> => {\n  const remote = config.values.runtime?.client?.remoteSource;\n  if (remote) {\n    const url = new URL(remote);\n    const protocol = url.protocol.slice(0, -1);\n    switch (protocol) {\n      case 'ws':\n      case 'wss': {\n        return fromSocket(remote, config.values.runtime?.client?.remoteSourceAuthenticationToken);\n      }\n\n      case 'http':\n      case 'https': {\n        throw new Error('IFrame services deprecated.');\n      }\n    }\n  }\n\n  let useWorker = false;\n  if (typeof navigator !== 'undefined' && navigator.userAgent) {\n    const parser = new UAParser(navigator.userAgent);\n\n    // TODO(wittjosiah): Ideally this should not need to do any user agent parsing.\n    //  However, while SharedWorker is supported by iOS, it is not fully working and there's no way to inspect it.\n    useWorker = typeof SharedWorker !== 'undefined' && parser.getOS().name !== 'iOS';\n  }\n\n  return createWorker && useWorker\n    ? fromWorker(config, { createWorker, observabilityGroup, signalTelemetryEnabled })\n    : fromHost(config, {}, observabilityGroup, signalTelemetryEnabled);\n};\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { Event, synchronized } from '@dxos/async';\nimport {\n  type ClientServices,\n  type ClientServicesProvider,\n  clientServiceBundle,\n  ClientServicesProviderResource,\n} from '@dxos/client-protocol';\nimport { type ClientServicesHost, type ClientServicesHostParams } from '@dxos/client-services';\nimport { Config } from '@dxos/config';\nimport { Context } from '@dxos/context';\nimport { log } from '@dxos/log';\nimport { type SignalManager } from '@dxos/messaging';\nimport { createIceProvider, type SwarmNetworkManagerOptions, type TransportFactory } from '@dxos/network-manager';\nimport { type ServiceBundle } from '@dxos/rpc';\nimport { trace } from '@dxos/tracing';\n\n/**\n * Creates stand-alone services without rpc.\n */\n// TODO(burdon): Rename createLocalServices?\nexport const fromHost = async (\n  config = new Config(),\n  params?: ClientServicesHostParams,\n  observabilityGroup?: string,\n  signalTelemetryEnabled?: boolean,\n): Promise<ClientServicesProvider> => {\n  const networking = await setupNetworking(config, {}, () =>\n    signalTelemetryEnabled\n      ? {\n          ...services.signalMetadataTags,\n          ...(observabilityGroup ? { group: observabilityGroup } : {}),\n        }\n      : {},\n  );\n\n  const services = new LocalClientServices({ config, ...networking, ...params });\n  return services;\n};\n\n/**\n * Creates signal manager and transport factory based on config.\n * These are used to create a WebRTC network manager connected to the specified signal server.\n */\nconst setupNetworking = async (\n  config: Config,\n  options: Partial<SwarmNetworkManagerOptions> = {},\n  signalMetadata?: () => void,\n): Promise<{\n  signalManager?: SignalManager;\n  transportFactory: TransportFactory;\n}> => {\n  const { MemorySignalManager, MemorySignalManagerContext, WebsocketSignalManager } = await import('@dxos/messaging');\n  const { createRtcTransportFactory, MemoryTransportFactory } = await import('@dxos/network-manager');\n\n  const signals = config.get('runtime.services.signaling');\n  const edgeFeatures = config.get('runtime.client.edgeFeatures');\n  if (signals || edgeFeatures?.signaling) {\n    const {\n      signalManager = edgeFeatures?.signaling || !signals\n        ? undefined // EdgeSignalManager needs EdgeConnection and will be created in service-host\n        : new WebsocketSignalManager(signals, signalMetadata),\n      transportFactory = createRtcTransportFactory(\n        { iceServers: config.get('runtime.services.ice') },\n        config.get('runtime.services.iceProviders') && createIceProvider(config.get('runtime.services.iceProviders')!),\n      ),\n    } = options;\n\n    return {\n      signalManager,\n      transportFactory,\n    };\n  }\n\n  // TODO(burdon): Should not provide a memory signal manager since no shared context.\n  //  Use TestClientBuilder for shared memory tests.\n  log('P2P network is not configured.');\n  const signalManager = new MemorySignalManager(new MemorySignalManagerContext());\n  const transportFactory = MemoryTransportFactory;\n  return {\n    signalManager,\n    transportFactory,\n  };\n};\n\n/**\n * Starts a local instance of the service host.\n */\n@trace.resource({ annotation: ClientServicesProviderResource })\nexport class LocalClientServices implements ClientServicesProvider {\n  readonly closed = new Event<Error | undefined>();\n  private readonly _ctx = new Context();\n  private readonly _params: ClientServicesHostParams;\n  private _host?: ClientServicesHost;\n  signalMetadataTags: any = {\n    runtime: 'local-client-services',\n  };\n\n  @trace.info()\n  private _isOpen = false;\n\n  constructor(params: ClientServicesHostParams) {\n    this._params = params;\n    // TODO(nf): extract\n    if (typeof window === 'undefined' || typeof window.location === 'undefined') {\n      // TODO(nf): collect ClientServices metadata as param?\n      this.signalMetadataTags.origin = 'undefined';\n    } else {\n      // SocketSupply native app\n      if ((globalThis as any).__args) {\n        this.signalMetadataTags.runtime = 'native';\n        this.signalMetadataTags.origin = window.location.origin;\n        // TODO(nf): access socket app metadata?\n      } else {\n        this.signalMetadataTags.origin = window.location.origin;\n      }\n    }\n  }\n\n  get descriptors(): ServiceBundle<ClientServices> {\n    return clientServiceBundle;\n  }\n\n  get services(): Partial<ClientServices> {\n    return this._host?.services ?? {};\n  }\n\n  get host(): ClientServicesHost | undefined {\n    return this._host;\n  }\n\n  @synchronized\n  async open(): Promise<void> {\n    if (this._isOpen) {\n      return;\n    }\n\n    const { ClientServicesHost } = await import('@dxos/client-services');\n    const { setIdentityTags } = await import('@dxos/messaging');\n\n    this._host = new ClientServicesHost({\n      ...this._params,\n      callbacks: {\n        ...this._params.callbacks,\n        onReset: async () => {\n          this.closed.emit(undefined);\n          await this._params.callbacks?.onReset?.();\n        },\n      },\n    });\n    await this._host.open(this._ctx);\n    this._isOpen = true;\n    setIdentityTags({\n      identityService: this._host.services.IdentityService!,\n      devicesService: this._host.services.DevicesService!,\n      setTag: (k: string, v: string) => {\n        this.signalMetadataTags[k] = v;\n      },\n    });\n  }\n\n  @synchronized\n  async close(): Promise<void> {\n    if (!this._isOpen) {\n      return;\n    }\n\n    await this._host?.close();\n    this._isOpen = false;\n  }\n}\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { Event } from '@dxos/async';\nimport { type ClientServices, type ClientServicesProvider, clientServiceBundle } from '@dxos/client-protocol';\nimport { log } from '@dxos/log';\nimport { ApiError } from '@dxos/protocols';\nimport type { WebsocketRpcClient } from '@dxos/websocket-rpc';\n\n/**\n * Access to remote client via a socket.\n */\nexport const fromSocket = async (url: string, authenticationToken?: string): Promise<ClientServicesProvider> => {\n  const closed = new Event<Error | undefined>();\n  let dxRpcClient!: WebsocketRpcClient<ClientServices, {}>;\n\n  return {\n    get closed() {\n      return closed;\n    },\n\n    get descriptors() {\n      return clientServiceBundle;\n    },\n\n    get services() {\n      return dxRpcClient.rpc;\n    },\n\n    open: async () => {\n      const { WebsocketRpcClient } = await import('@dxos/websocket-rpc');\n      dxRpcClient = new WebsocketRpcClient({\n        url,\n        authenticationToken,\n        requested: clientServiceBundle,\n        exposed: {},\n        handlers: {},\n      });\n\n      dxRpcClient.error.on(async (error) => {\n        log.warn('websocket rpc client error', { error });\n        // Browsers do not include the error message in the event object, so we cannot discern 401 errors from other errors.\n        if (error.message.includes('401')) {\n          log.warn('websocket authentication failed');\n        }\n        closed.emit(new ApiError('websocket error'));\n      });\n      await dxRpcClient.open();\n    },\n\n    close: async () => {\n      await dxRpcClient.close();\n    },\n  };\n};\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { Event, Trigger, synchronized } from '@dxos/async';\nimport { type ClientServices, type ClientServicesProvider, clientServiceBundle } from '@dxos/client-protocol';\nimport type { Stream } from '@dxos/codec-protobuf/stream';\nimport { Config } from '@dxos/config';\nimport type { PublicKey } from '@dxos/keys';\nimport { type LogFilter, parseFilter, log, type CallMetadata } from '@dxos/log';\nimport { type LogEntry, LogLevel } from '@dxos/protocols/proto/dxos/client/services';\nimport { type ServiceBundle } from '@dxos/rpc';\nimport { createWorkerPort } from '@dxos/rpc-tunnel';\nimport { trace } from '@dxos/tracing';\n\nimport { ClientServicesProxy } from './service-proxy';\nimport { SharedWorkerConnection } from './shared-worker-connection';\nimport { RPC_TIMEOUT } from '../common';\nimport { LOCK_KEY } from '../lock-key';\n\n/**\n * Creates services provider connected via worker.\n */\nexport const fromWorker = async (config: Config = new Config(), options: Omit<WorkerClientServicesParams, 'config'>) =>\n  new WorkerClientServices({ config, ...options });\n\nexport type WorkerClientServicesParams = {\n  config: Config;\n  createWorker: () => SharedWorker;\n  logFilter?: string;\n  observabilityGroup?: string;\n  signalTelemetryEnabled?: boolean;\n};\n\n/**\n * Proxy to host client service in worker.\n */\n@trace.resource()\nexport class WorkerClientServices implements ClientServicesProvider {\n  readonly closed = new Event<Error | undefined>();\n  readonly joinedSpace = new Event<PublicKey>();\n\n  @trace.info()\n  private _isOpen = false;\n\n  private readonly _config: Config;\n  private readonly _createWorker: () => SharedWorker;\n  private readonly _logFilter: LogFilter[];\n\n  private _runtime!: SharedWorkerConnection;\n  private _services!: ClientServicesProxy;\n  private _loggingStream?: Stream<LogEntry>;\n  private readonly _observabilityGroup?: string;\n  private readonly _signalTelemetryEnabled: boolean;\n\n  constructor({\n    config,\n    createWorker,\n    logFilter = 'error,warn',\n    observabilityGroup,\n    signalTelemetryEnabled,\n  }: WorkerClientServicesParams) {\n    this._config = config;\n    this._createWorker = createWorker;\n    this._logFilter = parseFilter(logFilter);\n    this._observabilityGroup = observabilityGroup;\n    this._signalTelemetryEnabled = signalTelemetryEnabled ?? false;\n  }\n\n  get descriptors(): ServiceBundle<ClientServices> {\n    return clientServiceBundle;\n  }\n\n  get services(): Partial<ClientServices> {\n    return this._services.services;\n  }\n\n  get runtime(): SharedWorkerConnection {\n    return this._runtime;\n  }\n\n  @synchronized\n  async open(): Promise<void> {\n    if (this._isOpen) {\n      return;\n    }\n\n    log('opening...');\n    const ports = new Trigger<{ systemPort: MessagePort; appPort: MessagePort }>();\n    const worker = this._createWorker();\n    worker.port.postMessage({ dxlog: localStorage.getItem('dxlog') });\n    worker.port.onmessage = (event) => {\n      const { command, payload } = event.data;\n      if (command === 'init') {\n        ports.wake(payload);\n      }\n    };\n    const { systemPort, appPort } = await ports.wait();\n\n    this._runtime = new SharedWorkerConnection({\n      config: this._config,\n      systemPort: createWorkerPort({ port: systemPort }),\n    });\n    await this._runtime.open({\n      origin: location.origin,\n      observabilityGroup: this._observabilityGroup,\n      signalTelemetryEnabled: this._signalTelemetryEnabled,\n    });\n\n    this._services = new ClientServicesProxy(createWorkerPort({ port: appPort }));\n    await this._services.open();\n    void navigator.locks.request(LOCK_KEY, () => {\n      log('terminated');\n      if (this._isOpen) {\n        this.closed.emit(new Error('Shared worker terminated.'));\n      }\n    });\n\n    this._loggingStream = this._services.services.LoggingService.queryLogs(\n      {\n        filters: this._logFilter,\n      },\n      { timeout: RPC_TIMEOUT },\n    );\n    this._loggingStream.subscribe((entry) => {\n      switch (entry.level) {\n        case LogLevel.DEBUG:\n          log.debug(entry.message, entry.context, mapLogMeta(entry.meta));\n          break;\n        case LogLevel.VERBOSE:\n          log.verbose(entry.message, entry.context, mapLogMeta(entry.meta));\n          break;\n        case LogLevel.INFO:\n          log.info(entry.message, entry.context, mapLogMeta(entry.meta));\n          break;\n        case LogLevel.WARN:\n          log.warn(entry.message, entry.context, mapLogMeta(entry.meta));\n          break;\n        case LogLevel.ERROR:\n          log.error(entry.message, entry.context, mapLogMeta(entry.meta));\n          break;\n      }\n    });\n\n    log('opened');\n    this._isOpen = true;\n  }\n\n  @synchronized\n  async close(): Promise<void> {\n    if (!this._isOpen) {\n      return;\n    }\n\n    log('closing...');\n    await this._loggingStream?.close();\n    await this._runtime.close();\n    await this._services.close();\n\n    log('closed');\n    this._isOpen = false;\n  }\n}\n\nconst mapLogMeta = (meta: LogEntry.Meta | undefined): CallMetadata | undefined => {\n  return (\n    meta && {\n      F: meta.file,\n      L: meta.line,\n      S: {\n        ...meta.scope,\n        remoteSessionId: meta.scope?.hostSessionId,\n        hostSessionId: undefined,\n      },\n    }\n  );\n};\n", "//\n// Copyright 2021 DXOS.org\n//\n\nimport { asyncTimeout, Event } from '@dxos/async';\nimport {\n  clientServiceBundle,\n  ClientServicesProviderResource,\n  type ClientServices,\n  type ClientServicesProvider,\n} from '@dxos/client-protocol';\nimport { invariant } from '@dxos/invariant';\nimport { RemoteServiceConnectionTimeout } from '@dxos/protocols';\nimport { createProtoRpcPeer, type ProtoRpcPeer, type RpcPort } from '@dxos/rpc';\nimport { trace } from '@dxos/tracing';\n\n/**\n * Implements services that are not local to the app.\n * For example, the services can be located in Wallet Extension.\n */\n@trace.resource({ annotation: ClientServicesProviderResource })\nexport class ClientServicesProxy implements ClientServicesProvider {\n  readonly closed = new Event<Error | undefined>();\n  private _proxy?: ProtoRpcPeer<ClientServices>;\n\n  constructor(\n    private readonly _port: RpcPort,\n    // NOTE: With lower timeout the shared worker does not have enough time to start.\n    // TODO(dmaretskyi): Find better ways to detected when the worker has finished loading. It might take a while on slow connections.\n    private readonly _timeout = 30_000,\n  ) {}\n\n  get proxy() {\n    invariant(this._proxy, 'Client services not open');\n    return this._proxy;\n  }\n\n  get descriptors() {\n    return clientServiceBundle;\n  }\n\n  get services() {\n    invariant(this._proxy, 'Client services not open');\n    return this._proxy.rpc;\n  }\n\n  async open(): Promise<void> {\n    if (this._proxy) {\n      return;\n    }\n\n    this._proxy = createProtoRpcPeer({\n      requested: clientServiceBundle,\n      exposed: {},\n      handlers: {},\n      port: this._port,\n      // TODO(wittjosiah): Specifying breaks the reset flows in Composer.\n      // timeout: this._timeout,\n    });\n\n    await asyncTimeout(\n      this._proxy.open(),\n      this._timeout,\n      new RemoteServiceConnectionTimeout('Failed to establish dxrpc connection', { timeout: this._timeout }),\n    );\n  }\n\n  async close(): Promise<void> {\n    if (!this._proxy) {\n      return;\n    }\n\n    await this._proxy.close();\n    this._proxy = undefined;\n  }\n}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { Trigger } from '@dxos/async';\nimport { iframeServiceBundle, workerServiceBundle, type WorkerServiceBundle } from '@dxos/client-protocol';\nimport { type Config } from '@dxos/config';\nimport { log } from '@dxos/log';\nimport { createIceProvider } from '@dxos/network-manager';\nimport { RemoteServiceConnectionError } from '@dxos/protocols';\nimport { type BridgeService } from '@dxos/protocols/proto/dxos/mesh/bridge';\nimport { createProtoRpcPeer, type ProtoRpcPeer, type RpcPort } from '@dxos/rpc';\nimport { getAsyncProviderValue, type MaybePromise, type Provider } from '@dxos/util';\n\n// NOTE: Keep as RpcPorts to avoid dependency on @dxos/rpc-tunnel so we don't depend on browser-specific apis.\nexport type SharedWorkerConnectionOptions = {\n  config: Config | Provider<MaybePromise<Config>>;\n  systemPort: RpcPort;\n  /**\n   * @deprecated Only used with iframes.\n   */\n  shellPort?: RpcPort;\n};\n\n/**\n * Manages the client connection to the shared worker.\n */\nexport class SharedWorkerConnection {\n  private readonly _id = String(Math.floor(Math.random() * 1000000));\n  private readonly _configProvider: SharedWorkerConnectionOptions['config'];\n  private readonly _systemPort: RpcPort;\n  private _release = new Trigger();\n  private _config!: Config;\n  private _transportService!: BridgeService;\n  private _systemRpc!: ProtoRpcPeer<WorkerServiceBundle>;\n\n  constructor({ config, systemPort }: SharedWorkerConnectionOptions) {\n    this._configProvider = config;\n    this._systemPort = systemPort;\n  }\n\n  async open(params: { origin: string; observabilityGroup?: string; signalTelemetryEnabled?: boolean }): Promise<void> {\n    const { RtcTransportService } = await import('@dxos/network-manager');\n\n    this._config = await getAsyncProviderValue(this._configProvider);\n\n    this._transportService = new RtcTransportService(\n      { iceServers: [...(this._config.get('runtime.services.ice') ?? [])] },\n      this._config.get('runtime.services.iceProviders') &&\n        createIceProvider(this._config.get('runtime.services.iceProviders')!),\n    );\n\n    this._systemRpc = createProtoRpcPeer({\n      requested: workerServiceBundle,\n      exposed: iframeServiceBundle,\n      handlers: {\n        BridgeService: this._transportService,\n      },\n      port: this._systemPort,\n      // TODO(wittjosiah): Make longer and factor out to constant.\n      // TODO(wittjosiah): If this is too long then it breaks the reset flows in Composer.\n      timeout: 200,\n    });\n\n    let lockKey: string | undefined;\n    if (typeof navigator !== 'undefined') {\n      lockKey = this._lockKey(params.origin);\n      this._release = new Trigger();\n      const ready = new Trigger();\n      void navigator.locks.request(lockKey, async () => {\n        ready.wake();\n        await this._release.wait();\n      });\n      await ready.wait();\n    }\n\n    try {\n      await this._systemRpc.open();\n      await this._systemRpc.rpc.WorkerService.start({ lockKey, ...params });\n    } catch (err) {\n      log.catch(err);\n      throw new RemoteServiceConnectionError('Failed to connect to worker');\n    }\n  }\n\n  async close(): Promise<void> {\n    this._release.wake();\n    try {\n      await this._systemRpc.rpc.WorkerService.stop();\n    } catch {\n      // If this fails, the worker is probably already gone.\n    }\n    await this._systemRpc.close();\n  }\n\n  private _lockKey(origin: string): string {\n    return `${origin}-${this._id}`;\n  }\n}\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { PublicKey } from '@dxos/keys';\nimport { createIFrame } from '@dxos/rpc-tunnel';\nimport { type MaybePromise } from '@dxos/util';\n\nexport class IFrameManager {\n  private _iframe?: HTMLIFrameElement;\n  private readonly _source: URL;\n  private readonly _onOpen?: () => MaybePromise<void>;\n  private readonly _onMessage?: (event: MessageEvent) => MaybePromise<void>;\n\n  constructor({\n    source,\n    onOpen,\n    onMessage,\n  }: {\n    source: URL;\n    onOpen?: () => MaybePromise<void>;\n    onMessage?: (event: MessageEvent) => MaybePromise<void>;\n  }) {\n    this._source = source;\n    this._onOpen = onOpen;\n    this._onMessage = onMessage;\n    this._messageHandler = this._messageHandler.bind(this);\n  }\n\n  get source() {\n    return this._source;\n  }\n\n  get iframe() {\n    return this._iframe;\n  }\n\n  async open(): Promise<void> {\n    if (this._iframe) {\n      return;\n    }\n\n    window.addEventListener('message', this._messageHandler);\n    const iframeId = `__DXOS_CLIENT_${PublicKey.random().toHex()}__`;\n    this._iframe = createIFrame(this._source.toString(), iframeId, { allow: 'clipboard-read; clipboard-write' });\n\n    await this._onOpen?.();\n  }\n\n  async close(): Promise<void> {\n    window.removeEventListener('message', this._messageHandler);\n    this._iframe?.remove();\n    this._iframe = undefined;\n  }\n\n  private async _messageHandler(event: MessageEvent): Promise<void> {\n    void this._onMessage?.(event);\n  }\n}\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport type { MulticastObservable } from '@dxos/async';\nimport { type PublicKey } from '@dxos/keys';\nimport { type LayoutRequest, ShellDisplay, ShellLayout } from '@dxos/protocols/proto/dxos/iframe';\nimport { ComplexSet } from '@dxos/util';\n\nimport type { ShellManager } from './shell-manager';\nimport type { Space, SpaceMember } from '../echo';\nimport type { Device, Identity } from '../halo';\n\ntype ShellResult = {\n  cancelled: boolean;\n  error?: Error;\n};\n\ntype InitializeIdentityResult = ShellResult & {\n  identity?: Identity;\n};\n\ntype ShareIdentityResult = ShellResult & {\n  device?: Device;\n};\n\ntype ShareSpaceResult = ShellResult & {\n  members?: SpaceMember[];\n};\n\ntype JoinSpaceResult = ShellResult & {\n  space?: Space;\n  target?: string;\n};\n\ntype ShellParams = {\n  shellManager: ShellManager;\n  identity: MulticastObservable<Identity | null>;\n  devices: MulticastObservable<Device[]>;\n  spaces: MulticastObservable<Space[]>;\n};\n\n/**\n * Interface for controlling the shell.\n */\nexport class Shell {\n  private readonly _shellManager: ShellManager;\n  private readonly _identity: MulticastObservable<Identity | null>;\n  private readonly _devices: MulticastObservable<Device[]>;\n  private readonly _spaces: MulticastObservable<Space[]>;\n\n  constructor({ shellManager, identity, devices, spaces }: ShellParams) {\n    this._shellManager = shellManager;\n    this._identity = identity;\n    this._devices = devices;\n    this._spaces = spaces;\n  }\n\n  async setInvitationUrl(request: {\n    invitationUrl: string;\n    deviceInvitationParam: string;\n    spaceInvitationParam: string;\n  }): Promise<void> {\n    await this._shellManager.setInvitationUrl(request);\n  }\n\n  /**\n   * Open the shell with the given layout.\n   */\n  async open(layout: ShellLayout = ShellLayout.IDENTITY, options: Omit<LayoutRequest, 'layout'> = {}): Promise<void> {\n    await this._shellManager.setLayout({ layout, ...options });\n  }\n\n  get display() {\n    return this._shellManager.display;\n  }\n\n  /**\n   * Listen for changes to the shell display.\n   */\n  onDisplayChange(cb: (display: ShellDisplay) => void) {\n    return this._shellManager.contextUpdate.on((data) => {\n      if ('display' in data) {\n        cb(data.display!);\n      }\n    });\n  }\n\n  /**\n   * Listen for reset event.\n   */\n  onReset(cb: (target?: string) => void) {\n    return this._shellManager.contextUpdate.on((data) => {\n      if ('reset' in data && data.reset) {\n        cb(data.target);\n      }\n    });\n  }\n\n  /**\n   * Create a new identity.\n   * Opens the shell and starts the identity creation flow.\n   *\n   * @returns Shell result with the new identity.\n   */\n  async createIdentity(): Promise<InitializeIdentityResult> {\n    await this._shellManager.setLayout({ layout: ShellLayout.INITIALIZE_IDENTITY });\n    return new Promise((resolve) => {\n      this._shellManager.contextUpdate.on((context) => {\n        if (context.display === ShellDisplay.NONE) {\n          resolve({ cancelled: true });\n        }\n      });\n\n      this._identity.subscribe((identity) => {\n        if (identity) {\n          resolve({ identity, cancelled: false });\n        }\n      });\n    });\n  }\n\n  /**\n   * Join an existing identity.\n   * Opens the shell and starts the device invitation flow based on the given options.\n   *\n   * @param options.invitationCode If provided, join an existing identity via device invitation.\n   *\n   * @returns Shell result with the new identity.\n   */\n  async joinIdentity({ invitationCode }: { invitationCode?: string } = {}): Promise<InitializeIdentityResult> {\n    await this._shellManager.setLayout({ layout: ShellLayout.INITIALIZE_IDENTITY_FROM_INVITATION, invitationCode });\n    return new Promise((resolve) => {\n      this._shellManager.contextUpdate.on((context) => {\n        if (context.display === ShellDisplay.NONE) {\n          resolve({ cancelled: true });\n        }\n      });\n\n      this._identity.subscribe((identity) => {\n        if (identity) {\n          resolve({ identity, cancelled: false });\n        }\n      });\n    });\n  }\n\n  /**\n   * Invite a new device to join the current identity.\n   * Opens the shell and presents a device invitation.\n   *\n   * @returns Shell result with the new device.\n   */\n  async shareIdentity(): Promise<ShareIdentityResult> {\n    if (!this._identity.get()) {\n      return { error: new Error('Identity does not exist'), cancelled: false };\n    }\n\n    const initialDevices = new ComplexSet<PublicKey>(\n      (key) => key.toHex(),\n      this._devices.get().map((device) => device.deviceKey),\n    );\n    await this._shellManager.setLayout({ layout: ShellLayout.SHARE_IDENTITY });\n    return new Promise((resolve) => {\n      this._shellManager.contextUpdate.on((context) => {\n        if (context.display === ShellDisplay.NONE) {\n          const device = this._devices.get().find((device) => !initialDevices.has(device.deviceKey));\n          resolve({ device, cancelled: !device });\n        }\n      });\n    });\n  }\n\n  /**\n   * Initialize a new device with an existing identity using a recovery code.\n   *\n   * @returns Shell result with the identity.\n   */\n  async recoverIdentity(): Promise<InitializeIdentityResult> {\n    await this._shellManager.setLayout({ layout: ShellLayout.INITIALIZE_IDENTITY_FROM_RECOVERY });\n    return new Promise((resolve) => {\n      this._shellManager.contextUpdate.on((context) => {\n        if (context.display === ShellDisplay.NONE) {\n          resolve({ cancelled: true });\n        }\n      });\n\n      this._identity.subscribe((identity) => {\n        if (identity) {\n          resolve({ identity, cancelled: false });\n        }\n      });\n    });\n  }\n\n  /**\n   * Invite new members to join the current space.\n   * Opens the shell to the specified space, showing current members and allowing new members to be invited.\n   *\n   * @param options.spaceKey The space to share. (Deprecated, use spaceId instead.)\n   * @param options.spaceId The space to share.\n   * @param options.target The target location to share with new members.\n   *\n   * @returns Shell result with any new members that join while the shell is open.\n   */\n  async shareSpace({\n    spaceKey,\n    spaceId,\n    target,\n  }: {\n    spaceKey?: PublicKey;\n    spaceId?: string;\n    target?: string;\n  }): Promise<ShareSpaceResult> {\n    if (!this._identity.get()) {\n      return { error: new Error('Identity does not exist'), cancelled: false };\n    }\n\n    const space = this._spaces.get().find((space) => spaceKey?.equals(space.key) || space.id === spaceId);\n    if (!space) {\n      return { error: new Error('Space does not exist'), cancelled: false };\n    }\n\n    const initialMembers = new ComplexSet<PublicKey>(\n      (key) => key.toHex(),\n      space.members.get().map((member) => member.identity.identityKey),\n    );\n    await this._shellManager.setLayout({ layout: ShellLayout.SPACE, spaceKey, spaceId, target });\n    return new Promise((resolve) => {\n      this._shellManager.contextUpdate.on((context) => {\n        if (context.display === ShellDisplay.NONE) {\n          const members = space.members.get().filter((member) => !initialMembers.has(member.identity.identityKey));\n          resolve({ members, cancelled: members.length === 0 });\n        }\n      });\n    });\n  }\n\n  /**\n   * Join an existing space.\n   * Opens the shell and starts the space join flow based on the given options.\n   *\n   * @param options.invitationCode If provided, redeem the invitation code to join the space.\n   *\n   * @returns The joined space.\n   * @throws {Error} If no identity exists.\n   */\n  async joinSpace({ invitationCode }: { invitationCode?: string } = {}): Promise<JoinSpaceResult> {\n    if (!this._identity.get()) {\n      return { error: new Error('Identity does not exist'), cancelled: false };\n    }\n\n    await this._shellManager.setLayout({ layout: ShellLayout.JOIN_SPACE, invitationCode });\n    return new Promise((resolve) => {\n      this._shellManager.contextUpdate.on((context) => {\n        const space = context.spaceKey && this._spaces.get().find((space) => context.spaceKey?.equals(space.key));\n        if (space) {\n          resolve({ space, target: context.target, cancelled: false });\n        }\n\n        if (context.display === ShellDisplay.NONE) {\n          resolve({ cancelled: true });\n        }\n      });\n    });\n  }\n}\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { Event } from '@dxos/async';\nimport {\n  DEFAULT_SHELL_CHANNEL,\n  type ShellServiceBundle,\n  appServiceBundle,\n  shellServiceBundle,\n} from '@dxos/client-protocol';\nimport { invariant } from '@dxos/invariant';\nimport { log } from '@dxos/log';\nimport {\n  type AppContextRequest,\n  type LayoutRequest,\n  ShellDisplay,\n  type InvitationUrlRequest,\n} from '@dxos/protocols/proto/dxos/iframe';\nimport { createProtoRpcPeer, type ProtoRpcPeer } from '@dxos/rpc';\nimport { createIFramePort } from '@dxos/rpc-tunnel';\n\nimport { type IFrameManager } from './iframe-manager';\nimport { RPC_TIMEOUT } from '../common';\n\nconst shellStyles = Object.entries({\n  display: 'none',\n  position: 'fixed',\n  top: 0,\n  left: 0,\n  width: '100vw',\n  height: '100vh',\n  border: 0,\n  'z-index': 60,\n}).reduce((acc, [key, value]) => `${acc}${key}: ${value};`, '');\n\n/**\n * Provide access to the shell via RPC connection.\n */\nexport class ShellManager {\n  readonly contextUpdate = new Event<AppContextRequest>();\n\n  private _shellRpc?: ProtoRpcPeer<ShellServiceBundle>;\n  private _display = ShellDisplay.NONE;\n\n  // prettier-ignore\n  constructor(\n    private readonly _iframeManager: IFrameManager,\n    private readonly _channel = DEFAULT_SHELL_CHANNEL,\n  ) {}\n\n  get display() {\n    return this._display;\n  }\n\n  async setLayout(request: LayoutRequest): Promise<void> {\n    invariant(this._shellRpc, 'ShellManager not open');\n    log('set layout', request);\n    this._display = ShellDisplay.FULLSCREEN;\n    this.contextUpdate.emit({ display: this._display });\n    await this._shellRpc.rpc.ShellService.setLayout(request, { timeout: RPC_TIMEOUT });\n    // Focus the first focusable element when the iframe has something to display so that keybindings global to the iframe (e.g. Escape) work as expected.\n    (\n      this._iframeManager.iframe?.contentDocument?.querySelector(\n        'a[href], button:not([disabled]), input:not([disabled]), textarea:not([disabled]), select:not([disabled]), [tabindex]:not([tabindex=\"-1\"])',\n      ) as HTMLElement | null | undefined\n    )?.focus();\n  }\n\n  async setInvitationUrl(request: InvitationUrlRequest): Promise<void> {\n    log('set invitation url', request);\n    await this._shellRpc?.rpc.ShellService.setInvitationUrl(request, { timeout: RPC_TIMEOUT });\n  }\n\n  async open(): Promise<void> {\n    if (this._shellRpc) {\n      return;\n    }\n\n    await this._iframeManager.open();\n\n    const iframe = this._iframeManager.iframe;\n    iframe!.setAttribute('style', shellStyles);\n    iframe!.setAttribute('name', 'dxos-shell');\n    iframe!.setAttribute('data-testid', 'dxos-shell');\n    this.contextUpdate.on(({ display }) => {\n      iframe!.style.display = display === ShellDisplay.NONE ? 'none' : '';\n      if (display === ShellDisplay.NONE) {\n        iframe!.blur();\n      }\n    });\n\n    // TODO(wittjosiah): Remove. Workaround for socket runtime bug.\n    //   https://github.com/socketsupply/socket/issues/893\n    const origin =\n      this._iframeManager.source.origin === 'null'\n        ? this._iframeManager.source.toString().split('/').slice(0, 3).join('/')\n        : this._iframeManager.source.origin;\n\n    const port = createIFramePort({\n      origin,\n      channel: this._channel,\n      iframe: this._iframeManager.iframe,\n    });\n\n    this._shellRpc = createProtoRpcPeer({\n      requested: shellServiceBundle,\n      exposed: appServiceBundle,\n      handlers: {\n        AppService: {\n          setContext: async (request) => {\n            log('set context', request);\n            if (request.display) {\n              this._display = request.display;\n            }\n            this.contextUpdate.emit(request);\n          },\n        },\n      },\n      port,\n    });\n\n    await this._shellRpc.open();\n  }\n\n  async close(): Promise<void> {\n    if (!this._shellRpc) {\n      return;\n    }\n\n    await this._shellRpc?.close();\n    this._shellRpc = undefined;\n  }\n}\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { jwtDecode } from 'jwt-decode';\n\nimport { synchronized } from '@dxos/async';\nimport { type Halo } from '@dxos/client-protocol';\nimport { type Config } from '@dxos/config';\nimport { invariant } from '@dxos/invariant';\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { schema } from '@dxos/protocols/proto';\nimport { type Credential } from '@dxos/protocols/proto/dxos/halo/credentials';\nimport { type AgentManager, InitAuthSequenceResponse } from '@dxos/protocols/proto/dxos/service/agentmanager';\nimport { type WebsocketRpcClient } from '@dxos/websocket-rpc';\n\nexport type AgentHostingProvider = {\n  name: string;\n  baseUrl: string;\n  username: string;\n  password?: string;\n};\n\n/**\n * Cannot communicate with, or decode response from hosting provider.\n */\nexport class ProviderApiError extends Error {}\n\n// TODO: Load from config or dynamically discover\nconst defaultConfig: AgentHostingProvider = {\n  name: 'default',\n  baseUrl: 'http://localhost:8082/v1alpha1/',\n  username: 'dxos',\n};\n\nexport interface AgentHostingProviderClient {\n  /**\n   * Initialize the client, potentially using the authToken to check authorization.\n   */\n\n  // TODO: will need to be async?\n  init(authToken?: any): boolean;\n  createAgent(invitationCode: string, identityKey: string): Promise<string>;\n  getAgent(agentID: string): Promise<string | null>;\n  destroyAgent(agentID: string): Promise<boolean>;\n}\n\n// Interface to REST API to manage agent deployments\n// TODO(nf): for now API just simply returns created k8s CRD objects, define backend-agnostic API\nconst COMPOSER_BETA_COOKIE_NAME = 'COMPOSER-BETA';\nconst HUB_SERVICE_ACCESS_CAPABILITY = 'agent:beta';\nconst HUB_SERVICE_ACCESS_MAGIC = 'HubServiceAccessCredential';\n\nexport type ComposerBetaJwt = {\n  access_token: string;\n  auth_app?: number;\n  auth_agent?: number;\n};\n\nexport class AgentManagerClient implements AgentHostingProviderClient {\n  private readonly _config: AgentHostingProvider;\n  private readonly DXRPC_PATH = 'dxrpc';\n  private readonly _wsDxrpcUrl: string;\n  private _rpc: WebsocketRpcClient<{ AgentManager: AgentManager }, {}> | undefined;\n  private _rpcState: 'connected' | 'disconnected' = 'disconnected';\n  private _authToken: string | null = null;\n\n  // TODO(nf): just accept Client instead?\n  constructor(\n    private readonly _clientConfig: Config,\n    private readonly _halo: Halo,\n  ) {\n    const runtimeAgentHostingConfig = this._clientConfig.get('runtime.services.agentHosting');\n    invariant(runtimeAgentHostingConfig, 'agentHosting config not found');\n    invariant(runtimeAgentHostingConfig.server, 'agentHosting server not found');\n    this._config = {\n      ...defaultConfig,\n      baseUrl: runtimeAgentHostingConfig.server,\n      password: this._clientConfig.get('runtime.app.env.DX_AGENTHOSTING_PASSWORD'),\n    };\n\n    // Ensure trailing slash to ensure proper path joining with URL() constructor.\n    if (!this._config.baseUrl.endsWith('/')) {\n      this._config.baseUrl += '/';\n    }\n    this._wsDxrpcUrl = new URL(this.DXRPC_PATH, this._config.baseUrl.replace('http', 'ws')).href;\n  }\n\n  init(authToken?: any): boolean {\n    if (!this._checkAuthorization(authToken)) {\n      return false;\n    }\n\n    // TODO: AgentHostingContext is currently called 4 times on startup.\n    // when this is reduced to one, preemptively open the Websocket connection to decrease the latency of the first RPC call.\n    // void this._openRpc();\n    return true;\n  }\n\n  /**\n   * Check auth token/credential from CF worker whether identity is allowed to create agent.\n   *\n   * Note: This will prevent the client from making unnecessary requests to the AgentHostingProvider API.\n   * The AgentHostingProvider will also validate the auth token/credential on its own.\n   */\n\n  _checkAuthorization(authToken?: any): boolean {\n    const validCookie = this._checkAuthCookie(authToken);\n    if (validCookie) {\n      log('beta JWT found');\n      return true;\n    }\n\n    const credential = this._getAuthorizationCredential();\n    if (credential) {\n      log('beta credential found', { credential });\n      return true;\n    }\n\n    log('neither JWT nor beta credential found');\n    return false;\n  }\n\n  _checkAuthCookie(authToken: any): boolean {\n    const cookies = Object.fromEntries(\n      document.cookie.split('; ').map((v) => v.split(/=(.*)/s).map(decodeURIComponent)),\n    );\n\n    if (cookies[COMPOSER_BETA_COOKIE_NAME] == null) {\n      return false;\n    }\n\n    const composerBetaJwt = this._decodeComposerBetaJwt();\n\n    // The AgentManager server will verify the JWT. This check is just to prevent unnecessary requests.\n    if (composerBetaJwt && composerBetaJwt.auth_agent) {\n      return true;\n    }\n    return false;\n  }\n\n  // TODO(nf): use asymmetric key to verify token?\n  _decodeComposerBetaJwt(): ComposerBetaJwt {\n    const decoded: ComposerBetaJwt = jwtDecode(this._getComposerBetaCookie());\n    return decoded;\n  }\n\n  _getComposerBetaCookie() {\n    const cookies = Object.fromEntries(\n      document.cookie.split('; ').map((v) => v.split(/=(.*)/s).map(decodeURIComponent)),\n    );\n\n    if (cookies[COMPOSER_BETA_COOKIE_NAME] == null) {\n      return null;\n    }\n    return cookies[COMPOSER_BETA_COOKIE_NAME];\n  }\n\n  _getAuthorizationCredential() {\n    // TODO: ensure we use the newest credential?\n    return this._halo\n      .queryCredentials()\n      .toSorted((a, b) => b.issuanceDate.getTime() - a.issuanceDate.getTime())\n      .find(matchServiceCredential([HUB_SERVICE_ACCESS_CAPABILITY]));\n  }\n\n  public requestInitWithCredentials(req: RequestInit): RequestInit {\n    return {\n      ...req,\n      headers: {\n        ...req.headers,\n        Authorization: 'Basic ' + Buffer.from(`${this._config.username}:${this._config.password}`).toString('base64'),\n      },\n    };\n  }\n\n  public requestInitWithAuthToken(req: RequestInit): RequestInit {\n    return {\n      ...req,\n      headers: {\n        ...req.headers,\n        Authorization: 'Bearer ' + this._authToken,\n      },\n    };\n  }\n\n  @synchronized\n  async _ensureAuthenticated(): Promise<void> {\n    if (this._validAuthToken()) {\n      return;\n    }\n    const { deviceKey } = this._halo.device!;\n\n    invariant(deviceKey, 'deviceKey not found');\n    const authDeviceCreds = await this._queryCredentials('dxos.halo.credentials.AuthorizedDevice', (cred) =>\n      PublicKey.equals(cred.subject.id, deviceKey),\n    );\n\n    invariant(authDeviceCreds.length === 1, 'Improper number of authorized devices');\n\n    const agentBetaCredential = this._getAuthorizationCredential();\n    await this._agentManagerAuth(authDeviceCreds[0], agentBetaCredential);\n  }\n\n  async _openRpc(): Promise<void> {\n    if (this._rpcState === 'connected') {\n      return;\n    }\n    const { WebsocketRpcClient } = await import('@dxos/websocket-rpc');\n    this._rpc = new WebsocketRpcClient({\n      url: this._wsDxrpcUrl,\n      requested: { AgentManager: schema.getService('dxos.service.agentmanager.AgentManager') },\n      noHandshake: true,\n    });\n\n    this._rpc.connected.on(() => {\n      this._rpcState = 'connected';\n    });\n\n    this._rpc.disconnected.on(() => {\n      this._rpcState = 'disconnected';\n    });\n\n    this._rpc.error.on((err) => {\n      log.info('rpc error', { err });\n      this._rpcState = 'disconnected';\n    });\n    try {\n      await this._rpc.open();\n    } catch (err) {\n      log.warn('failed to open rpc', { err });\n      throw new Error('Failed to open rpc');\n    }\n  }\n\n  // Authenticate to the agentmanager service using dxrpc and obtain a JWT token for subsequent HTTP requests.\n  async _agentManagerAuth(authDeviceCreds: Credential, agentAuthzCredential?: Credential): Promise<void> {\n    await this._openRpc();\n    invariant(this._rpc, 'RPC not initialized');\n    const { result, nonce, agentmanagerKey, initAuthResponseReason } =\n      await this._rpc.rpc.AgentManager.initAuthSequence({\n        authToken: agentAuthzCredential ? HUB_SERVICE_ACCESS_MAGIC : this._getComposerBetaCookie(),\n      });\n\n    if (result !== InitAuthSequenceResponse.InitAuthSequenceResult.SUCCESS || !nonce || !agentmanagerKey) {\n      log('auth init failed', { result, nonce, agentmanagerKey, initAuthResponseReason });\n      throw new Error('Failed to initialize auth sequence');\n    }\n    const agentmanagerAccessCreds = await this._queryCredentials('dxos.halo.credentials.ServiceAccess', (cred) =>\n      PublicKey.equals(cred.issuer, agentmanagerKey),\n    );\n    if (!agentmanagerAccessCreds.length) {\n      log.info('no access credentials - requesting...');\n    } else {\n      log.info('access credentials found - requesting session token..');\n    }\n\n    const credsToPresent = [authDeviceCreds.id, agentmanagerAccessCreds[0]?.id, agentAuthzCredential?.id].filter(\n      Boolean,\n    );\n    const presentation = await this._halo.presentCredentials({\n      ids: credsToPresent as PublicKey[],\n      nonce,\n    });\n\n    const { token, credential } = await this._rpc.rpc.AgentManager.authenticate({ presentation });\n    if (token) {\n      this._authToken = token;\n      if (!this._validAuthToken()) {\n        log('received invalid authToken', { token });\n        throw new ProviderApiError('Received invalid authToken');\n      }\n    } else {\n      invariant(credential, 'No credential or token received');\n      log('received credential, writing to HALO', { credential });\n      await this._halo.writeCredentials([credential]);\n      // re-do authentication now that we have a agentmanager serviceAccess credential.\n      await this._agentManagerAuth(authDeviceCreds, agentAuthzCredential);\n    }\n  }\n\n  _validAuthToken() {\n    if (!this._authToken) {\n      return null;\n    }\n    const decoded = jwtDecode(this._authToken);\n    if (!decoded.exp) {\n      log.warn('authToken missing expiry', { decoded });\n      return null;\n    }\n    if (decoded.exp * 1000 < Date.now()) {\n      log('authToken expired', { decoded });\n      return null;\n    }\n    return decoded;\n  }\n\n  public async _queryCredentials(type?: string, predicate?: (value: Credential) => boolean): Promise<Credential[]> {\n    // assumes all credentials are already loaded. should client.spaces.waitUntilReady()?\n    const haloCredentials = this._halo.credentials.get();\n\n    return haloCredentials.filter((cred) => {\n      if (type && cred.subject.assertion['@type'] !== type) {\n        return false;\n      }\n      if (predicate && !predicate(cred)) {\n        return false;\n      }\n      return true;\n    });\n  }\n\n  public async createAgent(invitationCode: string, identityKey: string) {\n    await this._ensureAuthenticated();\n    const res = await fetch(\n      new URL('agent', this._config.baseUrl),\n      this.requestInitWithAuthToken({\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          invitation: invitationCode,\n          identityKey,\n        }),\n      }),\n    );\n\n    try {\n      const agent = await res.json();\n      return agent.metadata.uid;\n    } catch (err) {\n      if (err instanceof TypeError) {\n        log.warn('failed to parse response from agent create', { res });\n        throw new ProviderApiError('failed to parse response from hosting provider');\n      }\n      log.warn('bad response from agent create', { res });\n      throw new ProviderApiError('bad response from hosting provider');\n    }\n  }\n\n  public async getAgent(agentID: string) {\n    await this._ensureAuthenticated();\n    const res = await fetch(\n      new URL('agent/' + agentID, this._config.baseUrl),\n      this.requestInitWithAuthToken({\n        method: 'GET',\n      }),\n    );\n    // TODO(nf): is Sentry logging this and causing the log message?\n    switch (res.status) {\n      // TODO(nf): other status codes?\n      case 200:\n        break;\n      case 404:\n        return null;\n      case 401:\n        throw new ProviderApiError('unauthorized');\n      case 403:\n        throw new ProviderApiError('forbidden');\n      case 500:\n        log.warn('request to agent get failed', { res });\n        throw new ProviderApiError('internal server error from hosting provider');\n      default:\n        log.warn('request to agent get failed', { res });\n        throw new ProviderApiError('unknown API error');\n    }\n\n    log.info('getAgent', { res });\n\n    try {\n      const agent = await res.json();\n      return agent.metadata.uid;\n    } catch (err) {\n      if (err instanceof TypeError) {\n        log.warn('failed to parse response from agent get', { err });\n        throw new ProviderApiError('failed to parse response from hosting provider');\n      }\n      log.warn('bad response from agent get', { res });\n      throw new ProviderApiError('bad response from hosting provider');\n    }\n  }\n\n  public async destroyAgent(agentID: string): Promise<boolean> {\n    await this._ensureAuthenticated();\n    const res = await fetch(\n      new URL('agent/' + agentID, this._config.baseUrl),\n      this.requestInitWithAuthToken({\n        method: 'DELETE',\n      }),\n    );\n\n    switch (res.status) {\n      // TODO(nf): other status codes?\n      case 204:\n        return true;\n      case 404:\n        log.warn('requested destroy on non-existent agent');\n        return false;\n      case 403:\n        throw new ProviderApiError('forbidden');\n      case 500:\n        log.warn('request to agent destroy failed', { res });\n        throw new ProviderApiError('internal server error from hosting provider');\n      default:\n        log.warn('request to agent destroy failed', { res });\n        throw new ProviderApiError('unknown API error');\n    }\n  }\n}\n\n// TODO: match serverName and serverKey\n\nexport const matchServiceCredential =\n  (capabilities: string[] = []) =>\n  (credential: Credential) => {\n    if (credential.subject.assertion['@type'] !== 'dxos.halo.credentials.ServiceAccess') {\n      return false;\n    }\n\n    const { capabilities: credentialCapabilities } = credential.subject.assertion;\n    return capabilities.every((capability) => credentialCapabilities.includes(capability));\n  };\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { sleep } from '@dxos/async';\n\nimport { type AgentHostingProviderClient } from './agent-hosting-provider';\n\nexport class FakeAgentHostingProvider implements AgentHostingProviderClient {\n  private _agents: Map<string, string> = new Map();\n  constructor(private _throw: boolean = false) {}\n\n  public async createAgent(invitationCode: string, identityKey: string): Promise<string> {\n    await sleep(3e3);\n    const agentID = crypto.randomUUID();\n    this._agents.set(identityKey, agentID);\n    return agentID;\n  }\n\n  public async getAgent(agentID: string): Promise<string | null> {\n    await sleep(3e3);\n    return this._agents.get(agentID) ?? null;\n  }\n\n  public async destroyAgent(agentID: string): Promise<boolean> {\n    await sleep(3e3);\n    return this._agents.delete(agentID);\n  }\n\n  public init(authToken: any): boolean {\n    return true;\n  }\n}\n"],
  "mappings": "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",
  "names": ["import_client_protocol", "import_async", "import_log", "import_tracing", "import_config", "import_protocols", "import_network_manager", "import_rpc", "import_rpc_tunnel", "import_util", "import_invariant", "import_iframe", "import_keys", "getUnixSocket", "profile", "protocol", "getProfilePath", "DX_RUNTIME", "fromAgent", "process", "env", "ENV_DX_PROFILE", "ENV_DX_PROFILE_DEFAULT", "AgentClientServiceProvider", "_profile", "closed", "Event", "descriptors", "clientServiceBundle", "services", "_client", "rpc", "open", "WebsocketRpcClient", "url", "requested", "exposed", "handlers", "error", "on", "emit", "close", "err", "log", "warn", "resource", "annotation", "ClientServicesProviderResource", "fromHost", "config", "Config", "params", "observabilityGroup", "signalTelemetryEnabled", "networking", "setupNetworking", "signalMetadataTags", "group", "LocalClientServices", "options", "signalMetadata", "MemorySignalManager", "MemorySignalManagerContext", "WebsocketSignalManager", "createRtcTransportFactory", "MemoryTransportFactory", "signals", "get", "edgeFeatures", "signaling", "signalManager", "undefined", "transportFactory", "iceServers", "createIceProvider", "_ctx", "Context", "runtime", "_isOpen", "_params", "window", "location", "origin", "globalThis", "__args", "_host", "host", "ClientServicesHost", "setIdentityTags", "callbacks", "onReset", "identityService", "IdentityService", "devicesService", "DevicesService", "setTag", "k", "v", "info", "fromSocket", "authenticationToken", "dxRpcClient", "message", "includes", "ApiError", "ClientServicesProxy", "_port", "_timeout", "proxy", "invariant", "_proxy", "createProtoRpcPeer", "port", "asyncTimeout", "RemoteServiceConnectionTimeout", "timeout", "SharedWorkerConnection", "systemPort", "_id", "String", "Math", "floor", "random", "_release", "Trigger", "_configProvider", "_systemPort", "RtcTransportService", "_config", "getAsyncProviderValue", "_transportService", "_systemRpc", "workerServiceBundle", "iframeServiceBundle", "BridgeService", "lockKey", "navigator", "_lockKey", "ready", "locks", "request", "wake", "wait", "WorkerService", "start", "catch", "RemoteServiceConnectionError", "stop", "fromWorker", "WorkerClientServices", "createWorker", "logFilter", "joinedSpace", "_createWorker", "_logFilter", "parseFilter", "_observabilityGroup", "_signalTelemetryEnabled", "_services", "_runtime", "ports", "worker", "postMessage", "dxlog", "localStorage", "getItem", "onmessage", "event", "command", "payload", "data", "appPort", "createWorkerPort", "LOCK_KEY", "Error", "_loggingStream", "LoggingService", "queryLogs", "filters", "RPC_TIMEOUT", "subscribe", "entry", "level", "LogLevel", "DEBUG", "debug", "context", "mapLogMeta", "meta", "VERBOSE", "verbose", "INFO", "WARN", "ERROR", "F", "file", "L", "line", "S", "scope", "remoteSessionId", "hostSessionId", "createClientServices", "remote", "values", "client", "remoteSource", "URL", "slice", "remoteSourceAuthenticationToken", "useWorker", "userAgent", "parser", "UAParser", "SharedWorker", "getOS", "name", "IFrameManager", "source", "onOpen", "onMessage", "_source", "_onOpen", "_onMessage", "_messageHandler", "bind", "iframe", "_iframe", "addEventListener", "iframeId", "PublicKey", "toHex", "createIFrame", "toString", "allow", "removeEventListener", "remove", "Shell", "shellManager", "identity", "devices", "spaces", "_shellManager", "_identity", "_devices", "_spaces", "setInvitationUrl", "layout", "ShellLayout", "IDENTITY", "setLayout", "display", "onDisplayChange", "cb", "contextUpdate", "reset", "target", "createIdentity", "INITIALIZE_IDENTITY", "Promise", "resolve", "ShellDisplay", "NONE", "cancelled", "joinIdentity", "invitationCode", "INITIALIZE_IDENTITY_FROM_INVITATION", "shareIdentity", "initialDevices", "ComplexSet", "key", "map", "device", "deviceKey", "SHARE_IDENTITY", "find", "has", "recoverIdentity", "INITIALIZE_IDENTITY_FROM_RECOVERY", "shareSpace", "spaceKey", "spaceId", "space", "equals", "id", "initialMembers", "members", "member", "identityKey", "SPACE", "filter", "length", "joinSpace", "JOIN_SPACE", "shellStyles", "Object", "entries", "position", "top", "left", "width", "height", "border", "reduce", "acc", "value", "ShellManager", "_iframeManager", "_channel", "DEFAULT_SHELL_CHANNEL", "_display", "_shellRpc", "FULLSCREEN", "ShellService", "contentDocument", "querySelector", "focus", "setAttribute", "style", "blur", "split", "join", "createIFramePort", "channel", "shellServiceBundle", "appServiceBundle", "AppService", "setContext", "ProviderApiError", "defaultConfig", "baseUrl", "username", "COMPOSER_BETA_COOKIE_NAME", "HUB_SERVICE_ACCESS_CAPABILITY", "HUB_SERVICE_ACCESS_MAGIC", "AgentManagerClient", "_clientConfig", "_halo", "DXRPC_PATH", "_rpcState", "_authToken", "runtimeAgentHostingConfig", "server", "password", "endsWith", "_wsDxrpcUrl", "replace", "href", "init", "authToken", "_checkAuthorization", "validCookie", "_checkAuthCookie", "credential", "_getAuthorizationCredential", "cookies", "fromEntries", "document", "cookie", "decodeURIComponent", "composerBetaJwt", "_decodeComposerBetaJwt", "auth_agent", "decoded", "jwtDecode", "_getComposerBetaCookie", "queryCredentials", "toSorted", "a", "b", "issuanceDate", "getTime", "matchServiceCredential", "requestInitWithCredentials", "req", "headers", "Authorization", "Buffer", "from", "requestInitWithAuthToken", "_ensureAuthenticated", "_validAuthToken", "authDeviceCreds", "_queryCredentials", "cred", "subject", "agentBetaCredential", "_agentManagerAuth", "_openRpc", "_rpc", "AgentManager", "schema", "getService", "noHandshake", "connected", "disconnected", "agentAuthzCredential", "result", "nonce", "agentmanagerKey", "initAuthResponseReason", "initAuthSequence", "InitAuthSequenceResponse", "InitAuthSequenceResult", "SUCCESS", "agentmanagerAccessCreds", "issuer", "credsToPresent", "Boolean", "presentation", "presentCredentials", "ids", "token", "authenticate", "writeCredentials", "exp", "Date", "now", "type", "predicate", "haloCredentials", "credentials", "assertion", "createAgent", "res", "fetch", "method", "body", "JSON", "stringify", "invitation", "agent", "json", "metadata", "uid", "TypeError", "getAgent", "agentID", "status", "destroyAgent", "capabilities", "credentialCapabilities", "every", "capability", "FakeAgentHostingProvider", "_throw", "_agents", "Map", "sleep", "crypto", "randomUUID", "set", "delete"]
}
