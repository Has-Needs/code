{
  "version": 3,
  "sources": ["../../../src/echo/space-list.ts", "../../../src/echo/agent.ts"],
  "sourcesContent": ["//\n// Copyright 2021 DXOS.org\n//\n\nimport { inspect } from 'node:util';\n\nimport { Event, MulticastObservable, PushStream, scheduleMicroTask, Trigger } from '@dxos/async';\nimport {\n  CREATE_SPACE_TIMEOUT,\n  PropertiesType,\n  type ClientServicesProvider,\n  type Echo,\n  type Space,\n} from '@dxos/client-protocol';\nimport { type Config } from '@dxos/config';\nimport { Context } from '@dxos/context';\nimport { getCredentialAssertion } from '@dxos/credentials';\nimport { failUndefined, inspectObject } from '@dxos/debug';\nimport { Filter, Query, type EchoClient, type QueryOptions, type QueryFn } from '@dxos/echo-db';\nimport { failedInvariant, invariant } from '@dxos/invariant';\nimport { PublicKey, SpaceId } from '@dxos/keys';\nimport { live } from '@dxos/live-object';\nimport { log } from '@dxos/log';\nimport { ApiError, trace as Trace } from '@dxos/protocols';\nimport {\n  Invitation,\n  SpaceState,\n  type Space as SerializedSpace,\n  type SpaceArchive,\n} from '@dxos/protocols/proto/dxos/client/services';\nimport { type IndexConfig } from '@dxos/protocols/proto/dxos/echo/indexing';\nimport { type Credential } from '@dxos/protocols/proto/dxos/halo/credentials';\nimport { trace } from '@dxos/tracing';\n\nimport { AgentQuerySourceProvider } from './agent';\nimport { SpaceProxy } from './space-proxy';\nimport { RPC_TIMEOUT } from '../common';\nimport { type HaloProxy } from '../halo/halo-proxy';\nimport { InvitationsProxy } from '../invitations';\n\nconst ENABLE_AGENT_QUERY_SOURCE = false;\n\n@trace.resource()\nexport class SpaceList extends MulticastObservable<Space[]> implements Echo {\n  private _ctx!: Context;\n  private _invitationProxy?: InvitationsProxy;\n  private _defaultSpaceId?: SpaceId;\n  private readonly _defaultSpaceAvailable = new PushStream<boolean>();\n  private readonly _isReady = new MulticastObservable(this._defaultSpaceAvailable.observable, false);\n  private readonly _spacesStream: PushStream<Space[]>;\n  private readonly _spaceCreated = new Event<PublicKey>();\n  private readonly _instanceId = PublicKey.random().toHex();\n\n  @trace.info()\n  private get _isReadyState() {\n    return this._isReady.get();\n  }\n\n  constructor(\n    private readonly _config: Config | undefined,\n    private readonly _serviceProvider: ClientServicesProvider,\n    private readonly _echoClient: EchoClient,\n    private readonly _halo: HaloProxy,\n    /**\n     * @internal\n     */\n    readonly _traceParent?: string,\n  ) {\n    const spacesStream = new PushStream<Space[]>();\n    super(spacesStream.observable, []);\n    this._spacesStream = spacesStream;\n  }\n\n  [inspect.custom](): string {\n    return inspectObject(this);\n  }\n\n  get echoClient() {\n    return this._echoClient;\n  }\n\n  @trace.info({ depth: null })\n  toJSON(): { spaces: number | undefined } {\n    return {\n      spaces: this._value?.length,\n    };\n  }\n\n  /**\n   * @internal\n   */\n  @trace.span()\n  async _open(): Promise<void> {\n    log.trace('dxos.sdk.echo-proxy.open', Trace.begin({ id: this._instanceId, parentId: this._traceParent }));\n    this._ctx = new Context({\n      onError: (error) => {\n        log.catch(error);\n      },\n    });\n\n    const credentialsSubscription = this._halo.credentials.subscribe(() => {\n      if (this._updateAndOpenDefaultSpace()) {\n        credentialsSubscription.unsubscribe();\n      }\n    });\n    this._ctx.onDispose(() => credentialsSubscription.unsubscribe());\n\n    invariant(this._serviceProvider.services.SpacesService, 'SpacesService is not available.');\n    invariant(this._serviceProvider.services.InvitationsService, 'InvitationsService is not available.');\n    this._invitationProxy = new InvitationsProxy(\n      this._serviceProvider.services.InvitationsService,\n      this._serviceProvider.services.IdentityService,\n      () => ({\n        kind: Invitation.Kind.SPACE,\n      }),\n    );\n    await this._invitationProxy.open();\n\n    // Subscribe to spaces and create proxies.\n\n    const gotInitialUpdate = new Trigger();\n\n    const spacesStream = this._serviceProvider.services.SpacesService.querySpaces(undefined, { timeout: RPC_TIMEOUT });\n    spacesStream.subscribe((data) => {\n      let emitUpdate = false;\n      const newSpaces = this.get() as SpaceProxy[];\n\n      for (const space of data.spaces ?? []) {\n        if (this._ctx.disposed) {\n          return;\n        }\n\n        let spaceProxy = newSpaces.find(({ key }) => key.equals(space.spaceKey)) as SpaceProxy | undefined;\n        if (!spaceProxy) {\n          spaceProxy = new SpaceProxy(this._serviceProvider, space, this._echoClient);\n\n          if (this._shouldOpenSpace(space)) {\n            this._openSpaceAsync(spaceProxy);\n          }\n\n          // Propagate space state updates to the space list observable.\n          spaceProxy._stateUpdate.on(this._ctx, () => {\n            this._spacesStream.next([...this.get()]);\n          });\n\n          newSpaces.push(spaceProxy);\n          this._spaceCreated.emit(spaceProxy.key);\n\n          if (this._defaultSpaceId && spaceProxy.id === this._defaultSpaceId) {\n            this._defaultSpaceAvailable.next(true);\n          }\n\n          emitUpdate = true;\n        }\n\n        // Process space update in a separate task, also initializing the space if necessary.\n        scheduleMicroTask(this._ctx, async () => {\n          await spaceProxy!._processSpaceUpdate(space);\n        });\n      }\n\n      gotInitialUpdate.wake();\n      if (emitUpdate) {\n        this._spacesStream.next([...newSpaces]);\n      }\n    });\n    this._ctx.onDispose(() => spacesStream.close());\n\n    if (ENABLE_AGENT_QUERY_SOURCE) {\n      const subscription = this._isReady.subscribe(async (ready) => {\n        if (!ready) {\n          return;\n        }\n\n        const agentQuerySourceProvider = new AgentQuerySourceProvider(this.default);\n        await agentQuerySourceProvider.open();\n        this._echoClient.graph.registerQuerySourceProvider(agentQuerySourceProvider);\n        this._ctx.onDispose(() => agentQuerySourceProvider.close());\n        subscription.unsubscribe();\n      });\n      this._ctx.onDispose(() => subscription.unsubscribe());\n    }\n\n    // TODO(nf): implement/verify works\n    // TODO(nf): trigger automatically? feedback on how many were resumed?\n\n    await gotInitialUpdate.wait();\n    log.trace('dxos.sdk.echo-proxy.open', Trace.end({ id: this._instanceId }));\n  }\n\n  private _updateAndOpenDefaultSpace(): boolean {\n    const defaultSpaceCredential: Credential | undefined = this._halo.queryCredentials({\n      type: 'dxos.halo.credentials.DefaultSpace',\n    })[0];\n    const defaultSpaceAssertion = defaultSpaceCredential && getCredentialAssertion(defaultSpaceCredential);\n    if (defaultSpaceAssertion?.['@type'] !== 'dxos.halo.credentials.DefaultSpace') {\n      return false;\n    }\n    if (!SpaceId.isValid(defaultSpaceAssertion.spaceId)) {\n      return false;\n    }\n\n    this._defaultSpaceId = defaultSpaceAssertion.spaceId;\n    const defaultSpace = this._spaces.find((space) => space.id === defaultSpaceAssertion.spaceId);\n    log('defaultSpaceKey read from a credential', {\n      spaceExists: defaultSpace != null,\n      spaceOpen: defaultSpace?.isOpen,\n      spaceId: this._defaultSpaceId,\n    });\n\n    if (defaultSpace) {\n      if (defaultSpace.state.get() === SpaceState.SPACE_CLOSED) {\n        this._openSpaceAsync(defaultSpace);\n      }\n      this._defaultSpaceAvailable.next(true);\n    }\n\n    return true;\n  }\n\n  private _openSpaceAsync(spaceProxy: Space): void {\n    void spaceProxy.open().catch((err) => log.catch(err));\n  }\n\n  private _shouldOpenSpace(space: SerializedSpace): boolean {\n    if (this._ctx.disposed || space.state === SpaceState.SPACE_INACTIVE) {\n      return false;\n    }\n    if (!this._config?.values?.runtime?.client?.lazySpaceOpen) {\n      return true;\n    }\n    // Only open the default space if lazySpaceOpen is set.\n    return space.id === this._defaultSpaceId;\n  }\n\n  async setConfig(config: IndexConfig): Promise<void> {\n    await this._serviceProvider.services.QueryService?.setConfig(config, { timeout: 20_000 }); // TODO(dmaretskyi): Set global timeout instead.\n  }\n\n  /**\n   * @internal\n   */\n  @trace.span()\n  async _close(): Promise<void> {\n    await this._ctx.dispose();\n    await Promise.all(this.get().map((space) => (space as SpaceProxy)._destroy()));\n    this._spacesStream.next([]);\n    await this._invitationProxy?.close();\n    this._invitationProxy = undefined;\n    this._defaultSpaceAvailable.next(false);\n    this._defaultSpaceId = undefined;\n  }\n\n  get isReady() {\n    return this._isReady;\n  }\n\n  async waitUntilReady(): Promise<void> {\n    return new Promise((resolve) => {\n      const subscription = this._isReady.subscribe((isReady) => {\n        if (isReady) {\n          subscription.unsubscribe();\n          resolve();\n        }\n      });\n    });\n  }\n\n  override get(): Space[];\n  override get(spaceIdOrKey: SpaceId | PublicKey): Space | undefined;\n  override get(spaceIdOrKey?: SpaceId | PublicKey): Space | Space[] | undefined {\n    if (!spaceIdOrKey) {\n      return this._value;\n    }\n\n    if (spaceIdOrKey instanceof PublicKey) {\n      return this._value?.find(({ key }) => key.equals(spaceIdOrKey));\n    } else {\n      if (!SpaceId.isValid(spaceIdOrKey)) {\n        throw new ApiError('Invalid space id.');\n      }\n\n      return this._value?.find(({ id }) => id === spaceIdOrKey);\n    }\n  }\n\n  @trace.info()\n  private get _spaces() {\n    return this.get();\n  }\n\n  get default(): Space {\n    invariant(this._defaultSpaceId, 'Default space ID not set.');\n    const space = this.get().find((space) => space.id === this._defaultSpaceId);\n    invariant(space, 'Default space is not yet available. Use `client.spaces.isReady` to wait for the default space.');\n    return space;\n  }\n\n  async create(meta?: PropertiesType): Promise<Space> {\n    invariant(this._serviceProvider.services.SpacesService, 'SpacesService is not available.');\n    const traceId = PublicKey.random().toHex();\n    log.trace('dxos.sdk.echo-proxy.create-space', Trace.begin({ id: traceId }));\n    const space = await this._serviceProvider.services.SpacesService.createSpace(undefined, { timeout: RPC_TIMEOUT });\n\n    await this._spaceCreated.waitForCondition(() => {\n      return this.get().some(({ key }) => key.equals(space.spaceKey));\n    });\n    const spaceProxy = this._findProxy(space);\n\n    await spaceProxy._databaseInitialized.wait({ timeout: CREATE_SPACE_TIMEOUT });\n    spaceProxy.db.add(live(PropertiesType, meta ?? {}), { placeIn: 'root-doc' });\n    await spaceProxy.db.flush();\n    await spaceProxy._initializationComplete.wait();\n\n    log.trace('dxos.sdk.echo-proxy.create-space', Trace.end({ id: traceId }));\n    return spaceProxy;\n  }\n\n  /**\n   * @internal\n   */\n  async import(archive: SpaceArchive): Promise<Space> {\n    invariant(this._serviceProvider.services.SpacesService, 'SpaceService is not available.');\n    const { newSpaceId } = await this._serviceProvider.services.SpacesService.importSpace(\n      { archive },\n      { timeout: CREATE_SPACE_TIMEOUT },\n    );\n    invariant(SpaceId.isValid(newSpaceId), 'Invalid space ID');\n    await this._spaceCreated.waitForCondition(() => {\n      return this.get().some((space) => space.id === newSpaceId);\n    });\n\n    const spaceProxy = this.get(newSpaceId) ?? failedInvariant();\n    await spaceProxy.waitUntilReady();\n    return spaceProxy;\n  }\n\n  join(invitation: Invitation | string) {\n    if (!this._invitationProxy) {\n      throw new ApiError('Client not open.');\n    }\n\n    log('accept invitation', invitation);\n    return this._invitationProxy.join(invitation);\n  }\n\n  async joinBySpaceKey(spaceKey: PublicKey): Promise<Space> {\n    const response = await this._serviceProvider.services.SpacesService!.joinBySpaceKey({ spaceKey });\n    return this._findProxy(response.space);\n  }\n\n  // Odd way to define methods types from a typedef.\n  /**\n   * Query all spaces.\n   */\n  declare query: QueryFn;\n  static {\n    this.prototype.query = this.prototype._query;\n  }\n\n  private _query(query: Query.Any | Filter.Any, options?: QueryOptions) {\n    query = Filter.is(query) ? Query.select(query) : query;\n    return this._echoClient.graph.query(query, options);\n  }\n\n  private _findProxy(space: SerializedSpace): SpaceProxy {\n    return (this.get().find(({ key }) => key.equals(space.spaceKey)) as SpaceProxy) ?? failUndefined();\n  }\n}\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { Event } from '@dxos/async';\nimport { type Space } from '@dxos/client-protocol';\nimport { todo } from '@dxos/debug';\nimport { type AnyLiveObject, type QueryResultEntry, type QuerySource, type QuerySourceProvider } from '@dxos/echo-db';\nimport type { QueryAST } from '@dxos/echo-protocol';\nimport { invariant } from '@dxos/invariant';\nimport { PublicKey, type SpaceId } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { QUERY_CHANNEL } from '@dxos/protocols';\nimport { type EchoObject as EchoObjectProto } from '@dxos/protocols/proto/dxos/echo/object';\nimport { QueryReactivity, type QueryRequest, type QueryResponse } from '@dxos/protocols/proto/dxos/echo/query';\nimport { type GossipMessage } from '@dxos/protocols/proto/dxos/mesh/teleport/gossip';\n\nconst ERR_CLOSING = new Error();\n\nexport class AgentQuerySourceProvider implements QuerySourceProvider {\n  private readonly _responsePromises = new Map<\n    string,\n    { resolve: (response: QueryResponse) => void; reject: (error: Error) => void }\n  >();\n\n  private _unsubscribe?: () => void = undefined;\n\n  /**\n   * Constructor.\n   * @param _space Space instance that will be used for messaging with the agent through the gossip protocol.\n   */\n  constructor(private readonly _space: Space) {}\n\n  async open(): Promise<void> {\n    this._unsubscribe = this._space.listen(QUERY_CHANNEL, (message) => this._handleMessage(message));\n  }\n\n  async close(): Promise<void> {\n    this._unsubscribe?.();\n    this._responsePromises.forEach((promise) => promise.reject(ERR_CLOSING));\n    this._responsePromises.clear();\n  }\n\n  // TODO(burdon): Make async?\n  // TODO(burdon): Define return type.\n  private _sendRequest(query: QueryAST.Query): { response: Promise<QueryResponse>; cancelRequest: () => void } {\n    const request: QueryRequest = {\n      queryId: PublicKey.random().toHex(),\n      query: JSON.stringify(query),\n      reactivity: QueryReactivity.ONE_SHOT,\n    };\n    this._space\n      .postMessage(QUERY_CHANNEL, {\n        '@type': 'dxos.agent.query.QueryRequest',\n        ...request,\n      })\n      .catch((error) => log.catch(error));\n\n    let cancelRequest: () => void;\n    return {\n      response: new Promise<QueryResponse>((resolve, reject) => {\n        invariant(request.queryId);\n        this._responsePromises.set(request.queryId, { resolve, reject });\n        cancelRequest = () => {\n          reject(new Error('Request cancelled.'));\n          this._responsePromises.delete(request.queryId!);\n        };\n      }),\n      cancelRequest: () => {\n        cancelRequest();\n      },\n    };\n  }\n\n  private _handleMessage(message: GossipMessage): void {\n    if (message.payload['@type'] !== 'dxos.agent.query.QueryResponse') {\n      return;\n    }\n\n    const response = message.payload as QueryResponse;\n    invariant(response.queryId, 'QueryId is undefined.');\n    const responsePromise = this._responsePromises.get(response.queryId);\n    if (!responsePromise) {\n      log('Request for this response was canceled.', { response });\n      return;\n    }\n\n    responsePromise.resolve(response);\n    this._responsePromises.delete(response.queryId);\n  }\n\n  create(): AgentQuerySource {\n    return new AgentQuerySource({ sendRequest: this._sendRequest.bind(this) });\n  }\n}\n\nexport class AgentQuerySource implements QuerySource {\n  private _results?: QueryResultEntry[];\n  private _cancelPreviousRequest?: () => void = undefined;\n\n  public readonly changed = new Event<void>();\n\n  constructor(\n    private readonly _params: {\n      sendRequest: (query: QueryAST.Query) => { response: Promise<QueryResponse>; cancelRequest: () => void };\n    },\n  ) {}\n\n  open(): void {\n    // No-op.\n  }\n\n  close(): void {\n    // No-op.\n  }\n\n  getResults(): QueryResultEntry[] {\n    return this._results ?? [];\n  }\n\n  async run(): Promise<QueryResultEntry[]> {\n    return this._results ?? [];\n  }\n\n  update(query: QueryAST.Query): void {\n    // if (query.options.dataLocation === undefined || query.options.dataLocation === QueryOptions.DataLocation.LOCAL) {\n    //   // Disabled by dataLocation filter.\n    //   return;\n    // }\n\n    this._results = undefined;\n    this.changed.emit();\n\n    if (this._cancelPreviousRequest) {\n      this._cancelPreviousRequest();\n    }\n\n    // TODO(burdon): Make async.\n    const startTime = Date.now();\n    const { response, cancelRequest } = this._params.sendRequest(query);\n    this._cancelPreviousRequest = cancelRequest;\n    response\n      .then((response) => {\n        this._results =\n          response.results?.map((result) => {\n            const objSnapshot = response.objects?.find((obj) => obj.objectId === result.id);\n            return {\n              id: result.id,\n              spaceKey: result.spaceKey!,\n              spaceId: result.spaceId as SpaceId,\n              object: objSnapshot && getEchoObjectFromSnapshot(objSnapshot),\n              match: {\n                rank: result.rank,\n              },\n              resolution: {\n                source: 'remote',\n                time: Date.now() - startTime,\n              },\n            };\n          }) ?? [];\n\n        this.changed.emit();\n      })\n      .catch((error) => error === ERR_CLOSING || log.catch(error));\n  }\n}\n\nconst getEchoObjectFromSnapshot = (objSnapshot: EchoObjectProto): AnyLiveObject<any> | undefined => {\n  invariant(objSnapshot.genesis, 'Genesis is undefined.');\n  invariant(objSnapshot.snapshot, 'Genesis model type is undefined.');\n\n  return todo();\n\n  // if (objSnapshot.genesis.modelType === DocumentModel.meta.type) {\n  //   const modelSnapshot: ObjectSnapshot = DocumentModel.meta.snapshotCodec!.decode(objSnapshot.snapshot.model.value);\n  //   const obj = new TypedObject(undefined, {\n  //     type: modelSnapshot.typeRef && Reference.fromValue(modelSnapshot.typeRef),\n  //     immutable: true,\n  //   });\n  //   setStateFromSnapshot(obj, modelSnapshot);\n  //   return obj;\n  // } else if (objSnapshot.genesis.modelType === TextModel.meta.type) {\n  //   return new TextObject();\n  // } else {\n  //   log.warn('Unknown model type', { type: objSnapshot.genesis.modelType });\n  //   return undefined;\n  // }\n};\n"],
  "mappings": "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",
  "names": ["inspect", "Event", "MulticastObservable", "PushStream", "scheduleMicroTask", "Trigger", "CREATE_SPACE_TIMEOUT", "PropertiesType", "Context", "getCredentialAssertion", "failUndefined", "inspectObject", "Filter", "Query", "failedInvariant", "invariant", "PublicKey", "SpaceId", "live", "log", "ApiError", "trace", "Trace", "Invitation", "SpaceState", "Event", "todo", "invariant", "PublicKey", "log", "QUERY_CHANNEL", "QueryReactivity", "ERR_CLOSING", "Error", "AgentQuerySourceProvider", "_space", "_responsePromises", "Map", "_unsubscribe", "undefined", "open", "listen", "message", "_handleMessage", "close", "forEach", "promise", "reject", "clear", "_sendRequest", "query", "request", "queryId", "random", "toHex", "JSON", "stringify", "reactivity", "ONE_SHOT", "postMessage", "catch", "error", "cancelRequest", "response", "Promise", "resolve", "set", "delete", "payload", "responsePromise", "get", "create", "AgentQuerySource", "sendRequest", "bind", "_params", "_cancelPreviousRequest", "changed", "getResults", "_results", "run", "update", "emit", "startTime", "Date", "now", "then", "results", "map", "result", "objSnapshot", "objects", "find", "obj", "objectId", "id", "spaceKey", "spaceId", "object", "getEchoObjectFromSnapshot", "match", "rank", "resolution", "source", "time", "genesis", "snapshot", "ENABLE_AGENT_QUERY_SOURCE", "SpaceList", "MulticastObservable", "_isReadyState", "_isReady", "get", "_config", "_serviceProvider", "_echoClient", "_halo", "_traceParent", "spacesStream", "PushStream", "observable", "_defaultSpaceAvailable", "_spaceCreated", "Event", "_instanceId", "PublicKey", "random", "toHex", "_spacesStream", "inspect", "custom", "inspectObject", "echoClient", "toJSON", "spaces", "_value", "length", "_open", "log", "trace", "Trace", "begin", "id", "parentId", "_ctx", "Context", "onError", "error", "catch", "credentialsSubscription", "credentials", "subscribe", "_updateAndOpenDefaultSpace", "unsubscribe", "onDispose", "invariant", "services", "SpacesService", "InvitationsService", "_invitationProxy", "InvitationsProxy", "IdentityService", "kind", "Invitation", "Kind", "SPACE", "open", "gotInitialUpdate", "Trigger", "querySpaces", "undefined", "timeout", "RPC_TIMEOUT", "data", "emitUpdate", "newSpaces", "space", "disposed", "spaceProxy", "find", "key", "equals", "spaceKey", "SpaceProxy", "_shouldOpenSpace", "_openSpaceAsync", "_stateUpdate", "on", "next", "push", "emit", "_defaultSpaceId", "scheduleMicroTask", "_processSpaceUpdate", "wake", "close", "subscription", "ready", "agentQuerySourceProvider", "AgentQuerySourceProvider", "default", "graph", "registerQuerySourceProvider", "wait", "end", "defaultSpaceCredential", "queryCredentials", "type", "defaultSpaceAssertion", "getCredentialAssertion", "SpaceId", "isValid", "spaceId", "defaultSpace", "_spaces", "spaceExists", "spaceOpen", "isOpen", "state", "SpaceState", "SPACE_CLOSED", "err", "SPACE_INACTIVE", "values", "runtime", "client", "lazySpaceOpen", "setConfig", "config", "QueryService", "_close", "dispose", "Promise", "all", "map", "_destroy", "isReady", "waitUntilReady", "resolve", "spaceIdOrKey", "ApiError", "create", "meta", "traceId", "createSpace", "waitForCondition", "some", "_findProxy", "_databaseInitialized", "CREATE_SPACE_TIMEOUT", "db", "add", "live", "PropertiesType", "placeIn", "flush", "_initializationComplete", "import", "archive", "newSpaceId", "importSpace", "failedInvariant", "join", "invitation", "joinBySpaceKey", "response", "prototype", "query", "_query", "options", "Filter", "is", "Query", "select", "failUndefined", "info", "depth", "span", "resource"]
}
