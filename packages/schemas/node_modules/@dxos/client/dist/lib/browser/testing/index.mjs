import {
  Client
} from "../chunk-EW4WDN4K.mjs";
import {
  ClientServicesProxy,
  LocalClientServices
} from "../chunk-Y7RETDEH.mjs";
import "../chunk-4LGJGFVR.mjs";
import "../chunk-UFEX2AOY.mjs";

// packages/sdk/client/src/testing/index.ts
import { performInvitation } from "@dxos/client-services/testing";

// packages/sdk/client/src/testing/data.ts
import { Schema } from "effect";
import { Expando, Ref, TypedObject } from "@dxos/echo-schema";
var TextV0Type = class extends TypedObject({
  typename: "dxos.org/TextV0",
  version: "0.1.0"
})({
  content: Schema.String
}) {
};
var DocumentType = class extends TypedObject({
  typename: "braneframe.com/Document",
  version: "0.1.0"
})({
  title: Schema.optional(Schema.String),
  content: Ref(TextV0Type)
}) {
};
var ContactType = class extends TypedObject({
  typename: "braneframe.com/Contact",
  version: "0.1.0"
})({
  name: Schema.optional(Schema.String),
  identifiers: Schema.mutable(Schema.Array(Schema.Struct({
    type: Schema.String,
    value: Schema.String
  })))
}) {
};
var BlockSchema = Schema.Struct({
  timestamp: Schema.String,
  content: Schema.optional(Ref(TextV0Type)),
  object: Schema.optional(Ref(Expando))
});
var BlockType = BlockSchema;
var MessageType = class extends TypedObject({
  typename: "braneframe.com/Message",
  version: "0.1.0"
})({
  type: Schema.optional(Schema.String),
  date: Schema.optional(Schema.String),
  subject: Schema.optional(Schema.String),
  blocks: Schema.mutable(Schema.Array(BlockSchema)),
  links: Schema.optional(Schema.Array(Ref(Expando))),
  read: Schema.optional(Schema.Boolean),
  context: Schema.optional(Schema.Struct({
    space: Schema.optional(Schema.String),
    schema: Schema.optional(Schema.String),
    object: Schema.optional(Schema.String)
  }))
}) {
};
var ThreadType = class extends TypedObject({
  typename: "braneframe.com/Thread",
  version: "0.1.0"
})({
  title: Schema.optional(Schema.String),
  messages: Schema.mutable(Schema.Array(Ref(MessageType))),
  context: Schema.optional(Schema.Struct({
    space: Schema.optional(Schema.String),
    schema: Schema.optional(Schema.String),
    object: Schema.optional(Schema.String)
  }))
}) {
};

// packages/sdk/client/src/testing/test-builder.ts
import { Trigger } from "@dxos/async";
import { ClientServicesHost } from "@dxos/client-services";
import { Config } from "@dxos/config";
import { Context } from "@dxos/context";
import { raise } from "@dxos/debug";
import { Filter } from "@dxos/echo";
import { Expando as Expando2 } from "@dxos/echo-schema";
import { invariant } from "@dxos/invariant";
import { live } from "@dxos/live-object";
import { log } from "@dxos/log";
import { MemorySignalManager, MemorySignalManagerContext, WebsocketSignalManager } from "@dxos/messaging";
import { createIceProvider, createRtcTransportFactory, MemoryTransportFactory, TransportKind } from "@dxos/network-manager";
import { TcpTransportFactory } from "@dxos/network-manager/transport/tcp";
import { Invitation } from "@dxos/protocols/proto/dxos/client/services";
import { createLinkedPorts, createProtoRpcPeer } from "@dxos/rpc";
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/sdk/client/src/testing/test-builder.ts";
var testConfigWithLocalSignal = new Config({
  version: 1,
  runtime: {
    services: {
      signaling: [
        {
          // TODO(burdon): Port numbers and global consts?
          server: `ws://localhost:${process.env.SIGNAL_PORT ?? 4e3}/.well-known/dx/signal`
        }
      ]
    }
  }
});
var TestBuilder = class {
  // TODO(burdon): Pass in params as object.
  constructor(config, signalManagerContext = new MemorySignalManagerContext(), transport = TransportKind.WEB_RTC) {
    this.signalManagerContext = signalManagerContext;
    this._ctx = new Context({
      name: "TestBuilder"
    }, {
      F: __dxlog_file,
      L: 57
    });
    this.config = config ?? new Config();
    this._transport = transport;
  }
  get ctx() {
    return this._ctx;
  }
  async destroy() {
    await this._ctx.dispose(false);
  }
  /**
  * Create backend service handlers.
  */
  createClientServicesHost(runtimeParams) {
    const services = new ClientServicesHost({
      config: this.config,
      storage: this?.storage?.(),
      level: this?.level?.(),
      runtimeParams,
      ...this.networking
    });
    this._ctx.onDispose(() => services.close());
    return services;
  }
  /**
  * Create local services host.
  * @param options - fastPeerPresenceUpdate: enable for faster space-member online/offline status changes.
  */
  createLocalClientServices(options) {
    const services = new LocalClientServices({
      config: this.config,
      storage: this?.storage?.(),
      level: this?.level?.(),
      runtimeParams: {
        ...options?.fastPeerPresenceUpdate ? {
          spaceMemberPresenceAnnounceInterval: 200,
          spaceMemberPresenceOfflineTimeout: 400
        } : {},
        invitationConnectionDefaultParams: {
          teleport: {
            controlHeartbeatInterval: 200
          }
        }
      },
      ...this.networking
    });
    this._ctx.onDispose(() => services.close());
    return services;
  }
  /**
  * Create client/server.
  */
  createClientServer(host = this.createClientServicesHost()) {
    const [proxyPort, hostPort] = createLinkedPorts();
    const client = new Client({
      config: this.config,
      services: new ClientServicesProxy(proxyPort)
    });
    const server = createProtoRpcPeer({
      exposed: host.descriptors,
      handlers: host.services,
      port: hostPort
    });
    this._ctx.onDispose(() => server.close());
    this._ctx.onDispose(() => client.destroy());
    return [
      client,
      server
    ];
  }
  /**
  * Get network manager using local shared memory or remote signal manager.
  */
  get networking() {
    const signals = this.config.get("runtime.services.signaling");
    if (signals) {
      log.info(`using transport ${this._transport}`, void 0, {
        F: __dxlog_file,
        L: 145,
        S: this,
        C: (f, a) => f(...a)
      });
      let transportFactory;
      switch (this._transport) {
        case TransportKind.WEB_RTC:
          transportFactory = createRtcTransportFactory({
            iceServers: this.config.get("runtime.services.ice")
          }, this.config.get("runtime.services.iceProviders") && createIceProvider(this.config.get("runtime.services.iceProviders")));
          break;
        case TransportKind.TCP:
          transportFactory = TcpTransportFactory;
          break;
        default:
          throw new Error(`Unsupported transport w/ signalling: ${this._transport}`);
      }
      return {
        signalManager: new WebsocketSignalManager(signals),
        transportFactory
      };
    }
    return {
      signalManager: new MemorySignalManager(this.signalManagerContext),
      transportFactory: MemoryTransportFactory
    };
  }
};
var testSpaceAutomerge = async (expect, createDb, checkDb = createDb) => {
  const object = live(Expando2, {});
  createDb.add(object);
  await expect.poll(() => checkDb.query(Filter.ids(object.id)).first({
    timeout: 1e3
  }));
  return {
    objectId: object.id
  };
};
var syncItemsAutomerge = async (expect, db1, db2) => {
  await testSpaceAutomerge(expect, db1, db2);
  await testSpaceAutomerge(expect, db2, db1);
};
var joinCommonSpace = async ([initialPeer, ...peers], spaceKey) => {
  const rootSpace = spaceKey ? initialPeer.spaces.get(spaceKey) : await initialPeer.spaces.create();
  invariant(rootSpace, "Space not found.", {
    F: __dxlog_file,
    L: 203,
    S: void 0,
    A: [
      "rootSpace",
      "'Space not found.'"
    ]
  });
  await Promise.all(peers.map(async (peer) => {
    const hostDone = new Trigger();
    const guestDone = new Trigger();
    const hostObservable = rootSpace.share({
      authMethod: Invitation.AuthMethod.NONE
    });
    log("invitation created", void 0, {
      F: __dxlog_file,
      L: 211,
      S: void 0,
      C: (f, a) => f(...a)
    });
    hostObservable.subscribe((hostInvitation) => {
      switch (hostInvitation.state) {
        case Invitation.State.CONNECTING: {
          const guestObservable = peer.spaces.join(hostInvitation);
          log("invitation accepted", void 0, {
            F: __dxlog_file,
            L: 217,
            S: void 0,
            C: (f, a) => f(...a)
          });
          guestObservable.subscribe((guestInvitation) => {
            switch (guestInvitation.state) {
              case Invitation.State.SUCCESS: {
                guestDone.wake(guestInvitation);
                log("invitation guestDone", void 0, {
                  F: __dxlog_file,
                  L: 224,
                  S: void 0,
                  C: (f, a) => f(...a)
                });
                break;
              }
            }
          }, (err) => raise(err));
          break;
        }
        case Invitation.State.SUCCESS: {
          hostDone.wake(hostInvitation);
          log("invitation hostDone", void 0, {
            F: __dxlog_file,
            L: 236,
            S: void 0,
            C: (f, a) => f(...a)
          });
        }
      }
    }, (err) => raise(err));
    await Promise.all([
      hostDone.wait(),
      guestDone.wait()
    ]);
  }));
  return rootSpace.key;
};

// packages/sdk/client/src/testing/utils.ts
import { Trigger as Trigger2 } from "@dxos/async";
import { createTestLevel } from "@dxos/kv-store/testing";
import { createStorage, StorageType } from "@dxos/random-access-storage";
import { range } from "@dxos/util";
var waitForSpace = async (client, spaceKey, { timeout = 500, ready } = {}) => {
  let space = client.spaces.get(spaceKey);
  if (!space) {
    const spaceTrigger = new Trigger2();
    const sub = client.spaces.subscribe(() => {
      const space2 = client.spaces.get(spaceKey);
      if (space2) {
        sub.unsubscribe();
        spaceTrigger.wake(space2);
      }
    });
    space = await spaceTrigger.wait({
      timeout
    });
  }
  if (ready) {
    await space.waitUntilReady();
  }
  return space;
};
var createInitializedClientsWithContext = async (ctx, count, options) => {
  const testBuilder = new TestBuilder(options?.config);
  testBuilder.storage = options?.storage ? () => createStorage({
    type: StorageType.RAM,
    root: String(Math.random())
  }) : void 0;
  testBuilder.level = options?.storage ? () => createTestLevel() : void 0;
  const clients = range(count, () => new Client({
    config: options?.config,
    services: testBuilder.createLocalClientServices(options?.serviceConfig)
  }));
  const initialized = await Promise.all(clients.map(async (client, index) => {
    await client.initialize();
    await client.halo.createIdentity({
      displayName: `Peer ${index}`
    });
    return client;
  }));
  ctx.onDispose(() => Promise.all(initialized.map((c) => c.destroy())));
  return initialized;
};
export {
  BlockType,
  ContactType,
  DocumentType,
  MessageType,
  TestBuilder,
  TextV0Type,
  ThreadType,
  createInitializedClientsWithContext,
  joinCommonSpace,
  performInvitation,
  syncItemsAutomerge,
  testConfigWithLocalSignal,
  testSpaceAutomerge,
  waitForSpace
};
//# sourceMappingURL=index.mjs.map
