import { type Halo } from '@dxos/client-protocol';
import { type Config } from '@dxos/config';
import { type Credential } from '@dxos/protocols/proto/dxos/halo/credentials';
export type AgentHostingProvider = {
    name: string;
    baseUrl: string;
    username: string;
    password?: string;
};
/**
 * Cannot communicate with, or decode response from hosting provider.
 */
export declare class ProviderApiError extends Error {
}
export interface AgentHostingProviderClient {
    /**
     * Initialize the client, potentially using the authToken to check authorization.
     */
    init(authToken?: any): boolean;
    createAgent(invitationCode: string, identityKey: string): Promise<string>;
    getAgent(agentID: string): Promise<string | null>;
    destroyAgent(agentID: string): Promise<boolean>;
}
export type ComposerBetaJwt = {
    access_token: string;
    auth_app?: number;
    auth_agent?: number;
};
export declare class AgentManagerClient implements AgentHostingProviderClient {
    private readonly _clientConfig;
    private readonly _halo;
    private readonly _config;
    private readonly DXRPC_PATH;
    private readonly _wsDxrpcUrl;
    private _rpc;
    private _rpcState;
    private _authToken;
    constructor(_clientConfig: Config, _halo: Halo);
    init(authToken?: any): boolean;
    /**
     * Check auth token/credential from CF worker whether identity is allowed to create agent.
     *
     * Note: This will prevent the client from making unnecessary requests to the AgentHostingProvider API.
     * The AgentHostingProvider will also validate the auth token/credential on its own.
     */
    _checkAuthorization(authToken?: any): boolean;
    _checkAuthCookie(authToken: any): boolean;
    _decodeComposerBetaJwt(): ComposerBetaJwt;
    _getComposerBetaCookie(): any;
    _getAuthorizationCredential(): Credential | undefined;
    requestInitWithCredentials(req: RequestInit): RequestInit;
    requestInitWithAuthToken(req: RequestInit): RequestInit;
    _ensureAuthenticated(): Promise<void>;
    _openRpc(): Promise<void>;
    _agentManagerAuth(authDeviceCreds: Credential, agentAuthzCredential?: Credential): Promise<void>;
    _validAuthToken(): import("jwt-decode").JwtPayload | null;
    _queryCredentials(type?: string, predicate?: (value: Credential) => boolean): Promise<Credential[]>;
    createAgent(invitationCode: string, identityKey: string): Promise<any>;
    getAgent(agentID: string): Promise<any>;
    destroyAgent(agentID: string): Promise<boolean>;
}
export declare const matchServiceCredential: (capabilities?: string[]) => (credential: Credential) => boolean;
//# sourceMappingURL=agent-hosting-provider.d.ts.map