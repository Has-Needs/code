{
  "version": 3,
  "sources": ["../../../src/gossip.ts", "../../../src/gossip-extension.ts", "../../../src/presence.ts"],
  "sourcesContent": ["//\n// Copyright 2023 DXOS.org\n//\n\nimport { scheduleTask, Event, scheduleTaskInterval } from '@dxos/async';\nimport { Context } from '@dxos/context';\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { RpcClosedError, TimeoutError } from '@dxos/protocols';\nimport { type GossipMessage } from '@dxos/protocols/proto/dxos/mesh/teleport/gossip';\nimport { ComplexMap, ComplexSet } from '@dxos/util';\n\nimport { GossipExtension } from './gossip-extension';\n\nexport type GossipParams = {\n  localPeerId: PublicKey;\n};\n\nconst RECEIVED_MESSAGES_GC_INTERVAL = 120_000;\n\nconst MAX_CTX_TASKS = 50;\n\n/**\n * Gossip extensions manager.\n * Keeps track of all peers that are connected to the local peer.\n * Routes received announces to all connected peers.\n * Exposes API send announce to everybody and subscribe to .\n */\nexport class Gossip {\n  private readonly _ctx = new Context({\n    onError: (err) => {\n      log.catch(err);\n    },\n  });\n\n  private readonly _listeners = new Map<string, Set<(message: GossipMessage) => void>>();\n\n  private readonly _receivedMessages = new ComplexSet<PublicKey>(PublicKey.hash);\n\n  /**\n   * Keys scheduled to be cleared from _receivedMessages on the next iteration.\n   */\n  private readonly _toClear = new ComplexSet<PublicKey>(PublicKey.hash);\n\n  // remotePeerId -> PresenceExtension\n  private readonly _connections = new ComplexMap<PublicKey, GossipExtension>(PublicKey.hash);\n\n  public readonly connectionClosed = new Event<PublicKey>();\n\n  constructor(private readonly _params: GossipParams) {}\n\n  get localPeerId() {\n    return this._params.localPeerId;\n  }\n\n  async open(): Promise<void> {\n    // Clear the map periodically.\n    scheduleTaskInterval(\n      this._ctx,\n      async () => {\n        this._performGc();\n      },\n      RECEIVED_MESSAGES_GC_INTERVAL,\n    );\n  }\n\n  async close(): Promise<void> {\n    await this._ctx.dispose();\n  }\n\n  getConnections() {\n    return Array.from(this._connections.keys());\n  }\n\n  createExtension({ remotePeerId }: { remotePeerId: PublicKey }): GossipExtension {\n    const extension = new GossipExtension({\n      onAnnounce: async (message) => {\n        if (this._receivedMessages.has(message.messageId)) {\n          return;\n        }\n        this._receivedMessages.add(message.messageId);\n        this._callListeners(message);\n        if (this._ctx.disposeCallbacksLength > MAX_CTX_TASKS) {\n          log(`skipping propagating gossip message due to exessive tasks (${MAX_CTX_TASKS})`);\n          return;\n        }\n        scheduleTask(this._ctx, async () => {\n          await this._propagateAnnounce(message);\n        });\n      },\n      onClose: async (err) => {\n        if (this._connections.has(remotePeerId)) {\n          this._connections.delete(remotePeerId);\n        }\n        this.connectionClosed.emit(remotePeerId);\n      },\n    });\n    this._connections.set(remotePeerId, extension);\n\n    return extension;\n  }\n\n  postMessage(channel: string, payload: any): void {\n    for (const extension of this._connections.values()) {\n      this._sendAnnounceWithTimeoutTracking(extension, {\n        peerId: this._params.localPeerId,\n        messageId: PublicKey.random(),\n        channelId: channel,\n        timestamp: new Date(),\n        payload,\n      }).catch(async (err) => {\n        if (err instanceof RpcClosedError) {\n          log('sendAnnounce failed because of RpcClosedError', { err });\n        } else if (\n          err instanceof TimeoutError ||\n          err.constructor.name === 'TimeoutError' ||\n          err.message.startsWith('Timeout')\n        ) {\n          log('sendAnnounce failed because of TimeoutError', { err });\n        } else {\n          log.catch(err);\n        }\n      });\n    }\n  }\n\n  listen(channel: string, callback: (message: GossipMessage) => void): { unsubscribe: () => void } {\n    if (!this._listeners.has(channel)) {\n      this._listeners.set(channel, new Set());\n    }\n    this._listeners.get(channel)!.add(callback);\n\n    return {\n      unsubscribe: () => {\n        this._listeners.get(channel)!.delete(callback);\n      },\n    };\n  }\n\n  private _callListeners(message: GossipMessage): void {\n    if (this._listeners.has(message.channelId)) {\n      this._listeners.get(message.channelId)!.forEach((callback) => {\n        callback(message);\n      });\n    }\n  }\n\n  private _propagateAnnounce(message: GossipMessage): Promise<void[]> {\n    return Promise.all(\n      [...this._connections.entries()].map(async ([remotePeerId, extension]) => {\n        if (this._params.localPeerId.equals(message.peerId) || remotePeerId.equals(message.peerId)) {\n          return;\n        }\n        return this._sendAnnounceWithTimeoutTracking(extension, message).catch((err) => log(err));\n      }),\n    );\n  }\n\n  private _performGc(): void {\n    const start = performance.now();\n\n    for (const key of this._toClear.keys()) {\n      this._receivedMessages.delete(key);\n    }\n    this._toClear.clear();\n    for (const key of this._receivedMessages.keys()) {\n      this._toClear.add(key);\n    }\n\n    const elapsed = performance.now() - start;\n    if (elapsed > 100) {\n      log.warn('GC took too long', { elapsed });\n    }\n  }\n\n  private _sendAnnounceWithTimeoutTracking(extension: GossipExtension, message: GossipMessage): Promise<void> {\n    return extension.sendAnnounce(message).catch((err) => {\n      // Noop?\n    });\n  }\n}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { Trigger } from '@dxos/async';\nimport { invariant } from '@dxos/invariant';\nimport { log } from '@dxos/log';\nimport { schema } from '@dxos/protocols/proto';\nimport { type GossipMessage, type GossipService } from '@dxos/protocols/proto/dxos/mesh/teleport/gossip';\nimport { createProtoRpcPeer, type ProtoRpcPeer } from '@dxos/rpc';\nimport { type ExtensionContext, type TeleportExtension } from '@dxos/teleport';\n\nexport type GossipCallbacks = {\n  /**\n   * Callback to be called when a new announce is received.\n   */\n  onAnnounce?: (message: GossipMessage) => Promise<void>;\n\n  /**\n   * Callback to be called when the extension is closed.\n   */\n  onClose?: (err?: Error) => Promise<void>;\n};\n\n/**\n * Sends announces between two peers for a single teleport session.\n */\nexport class GossipExtension implements TeleportExtension {\n  private readonly _opened = new Trigger();\n  private _closed = false;\n\n  private _rpc?: ProtoRpcPeer<ServiceBundle>;\n\n  constructor(private readonly _callbacks: GossipCallbacks = {}) {}\n\n  async onOpen(context: ExtensionContext): Promise<void> {\n    log('onOpen', { localPeerId: context.localPeerId, remotePeerId: context.remotePeerId });\n\n    this._rpc = createProtoRpcPeer<ServiceBundle, ServiceBundle>({\n      requested: {\n        GossipService: schema.getService('dxos.mesh.teleport.gossip.GossipService'),\n      },\n      exposed: {\n        GossipService: schema.getService('dxos.mesh.teleport.gossip.GossipService'),\n      },\n      handlers: {\n        GossipService: {\n          announce: async (message: GossipMessage) => {\n            log('received announce', { localPeerId: context.localPeerId, remotePeerId: context.remotePeerId, message });\n            await this._callbacks.onAnnounce?.(message);\n          },\n        },\n      },\n      port: await context.createPort('rpc', {\n        contentType: 'application/x-protobuf; messageType=\"dxos.rpc.Message\"',\n      }),\n    });\n    await this._rpc.open();\n    this._opened.wake();\n  }\n\n  async onClose(err?: Error): Promise<void> {\n    log('close', { err });\n    await this._rpc?.close();\n    await this._callbacks.onClose?.(err);\n    this._closed = true;\n  }\n\n  async onAbort(err?: Error): Promise<void> {\n    log('abort', { err });\n    try {\n      await this._rpc?.abort();\n    } catch (err) {\n      log.catch(err);\n    } finally {\n      await this._callbacks.onClose?.(err);\n    }\n    this._closed = true;\n  }\n\n  async sendAnnounce(message: GossipMessage): Promise<void> {\n    if (this._closed) {\n      return;\n    }\n    await this._opened.wait();\n    invariant(this._rpc, 'RPC not initialized');\n    await this._rpc.rpc.GossipService.announce(message);\n  }\n}\n\ntype ServiceBundle = {\n  GossipService: GossipService;\n};\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { Event, scheduleTaskInterval } from '@dxos/async';\nimport { type WithTypeUrl } from '@dxos/codec-protobuf';\nimport { Resource } from '@dxos/context';\nimport { invariant } from '@dxos/invariant';\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { type PeerState } from '@dxos/protocols/proto/dxos/mesh/presence';\nimport { type GossipMessage } from '@dxos/protocols/proto/dxos/mesh/teleport/gossip';\nimport { ComplexMap } from '@dxos/util';\n\nimport { type Gossip } from './gossip';\n\nexport type PresenceParams = {\n  /**\n   * Interval between presence announces.\n   */\n  announceInterval: number;\n  /**\n   * Timeout after which a peer is considered offline.\n   * Should be greater than announceInterval.\n   */\n  offlineTimeout: number;\n\n  /**\n   * Identity key of the local peer.\n   */\n  identityKey: PublicKey; // TODO(mykola): Remove once IdentityKey can be obtained from DeviceKey.\n\n  gossip: Gossip;\n};\n\nconst PRESENCE_CHANNEL_ID = 'dxos.mesh.presence.Presence';\n\n/**\n * Presence manager.\n * Keeps track of all peers that are connected to the local peer.\n * Routes received presence announces to all connected peers.\n * Exposes API to get the list of peers that are online.\n */\nexport class Presence extends Resource {\n  public readonly updated = new Event<void>();\n  public readonly newPeer = new Event<PeerState>();\n\n  private readonly _peerStates = new ComplexMap<PublicKey, GossipMessage>(PublicKey.hash);\n  private readonly _peersByIdentityKey = new ComplexMap<PublicKey, GossipMessage[]>(PublicKey.hash);\n\n  // remotePeerId -> PresenceExtension\n\n  constructor(private readonly _params: PresenceParams) {\n    super();\n    invariant(\n      this._params.announceInterval < this._params.offlineTimeout,\n      'Announce interval should be less than offline timeout.',\n    );\n\n    this._params.gossip.listen(PRESENCE_CHANNEL_ID, (message) => {\n      this._receiveAnnounces(message);\n    });\n  }\n\n  protected override async _open(): Promise<void> {\n    // Send announce to all connected peers.\n    scheduleTaskInterval(\n      this._ctx,\n      async () => {\n        const peerState: WithTypeUrl<PeerState> = {\n          '@type': 'dxos.mesh.presence.PeerState',\n          identityKey: this._params.identityKey,\n          connections: this._params.gossip.getConnections(),\n        };\n        this._params.gossip.postMessage(PRESENCE_CHANNEL_ID, peerState);\n      },\n      this._params.announceInterval,\n    );\n\n    // Emit updated event in case some peers went offline.\n    scheduleTaskInterval(\n      this._ctx,\n      async () => {\n        this.updated.emit();\n      },\n      this._params.offlineTimeout,\n    );\n\n    // Remove peer state when connection is closed.\n    this._params.gossip.connectionClosed.on(this._ctx, (peerId) => {\n      const peerState = this._peerStates.get(peerId);\n      if (peerState != null) {\n        this._peerStates.delete(peerId);\n        this._removePeerFromIdentityKeyIndex(peerState);\n        this.updated.emit();\n      }\n    });\n  }\n\n  protected override async _catch(err: Error): Promise<void> {\n    log.catch(err);\n  }\n\n  getPeers(): PeerState[] {\n    return Array.from(this._peerStates.values()).map((message) => message.payload);\n  }\n\n  getPeersByIdentityKey(key: PublicKey): PeerState[] {\n    return (this._peersByIdentityKey.get(key) ?? []).filter(this._isOnline).map((m) => m.payload);\n  }\n\n  getPeersOnline(): PeerState[] {\n    return Array.from(this._peerStates.values())\n      .filter(this._isOnline)\n      .map((message) => message.payload);\n  }\n\n  private _isOnline = (message: GossipMessage): boolean => {\n    return message.timestamp.getTime() > Date.now() - this._params.offlineTimeout;\n  };\n\n  getLocalState(): PeerState {\n    return {\n      identityKey: this._params.identityKey,\n      connections: this._params.gossip.getConnections(),\n      peerId: this._params.gossip.localPeerId,\n    };\n  }\n\n  private _receiveAnnounces(message: GossipMessage): void {\n    invariant(message.channelId === PRESENCE_CHANNEL_ID, `Invalid channel ID: ${message.channelId}`);\n    const oldPeerState = this._peerStates.get(message.peerId);\n    if (!oldPeerState || oldPeerState.timestamp.getTime() < message.timestamp.getTime()) {\n      // Assign peer id to payload.\n      (message.payload as PeerState).peerId = message.peerId;\n\n      this._peerStates.set(message.peerId, message);\n      this._updatePeerInIdentityKeyIndex(message);\n      this.updated.emit();\n    }\n  }\n\n  private _removePeerFromIdentityKeyIndex(peerState: GossipMessage): void {\n    const identityPeerList = this._peersByIdentityKey.get((peerState.payload as PeerState).identityKey) ?? [];\n    const peerIdIndex = identityPeerList.findIndex((id) => id.peerId?.equals(peerState.peerId));\n    if (peerIdIndex >= 0) {\n      identityPeerList.splice(peerIdIndex, 1);\n    }\n  }\n\n  private _updatePeerInIdentityKeyIndex(newState: GossipMessage): void {\n    const identityKey = (newState.payload as PeerState).identityKey;\n    const identityKeyPeers = this._peersByIdentityKey.get(identityKey) ?? [];\n    const existingIndex = identityKeyPeers.findIndex((p) => p.peerId && newState.peerId?.equals(p.peerId));\n    if (existingIndex >= 0) {\n      const oldState = identityKeyPeers.splice(existingIndex, 1, newState)[0];\n      if (!this._isOnline(oldState)) {\n        this.newPeer.emit(newState.payload);\n      }\n    } else {\n      this._peersByIdentityKey.set(identityKey, identityKeyPeers);\n      identityKeyPeers.push(newState);\n      this.newPeer.emit(newState.payload);\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": ["import_async", "import_log", "import_context", "import_invariant", "import_keys", "import_util", "GossipExtension", "_callbacks", "_opened", "Trigger", "_closed", "onOpen", "context", "log", "localPeerId", "remotePeerId", "_rpc", "createProtoRpcPeer", "requested", "GossipService", "schema", "getService", "exposed", "handlers", "announce", "message", "onAnnounce", "port", "createPort", "contentType", "open", "wake", "onClose", "err", "close", "onAbort", "abort", "catch", "sendAnnounce", "wait", "invariant", "rpc", "RECEIVED_MESSAGES_GC_INTERVAL", "MAX_CTX_TASKS", "Gossip", "_params", "_ctx", "Context", "onError", "_listeners", "Map", "_receivedMessages", "ComplexSet", "PublicKey", "hash", "_toClear", "_connections", "ComplexMap", "connectionClosed", "Event", "scheduleTaskInterval", "_performGc", "dispose", "getConnections", "Array", "from", "keys", "createExtension", "extension", "has", "messageId", "add", "_callListeners", "disposeCallbacksLength", "scheduleTask", "_propagateAnnounce", "delete", "emit", "set", "postMessage", "channel", "payload", "values", "_sendAnnounceWithTimeoutTracking", "peerId", "random", "channelId", "timestamp", "Date", "RpcClosedError", "TimeoutError", "name", "startsWith", "listen", "callback", "Set", "get", "unsubscribe", "forEach", "Promise", "all", "entries", "map", "equals", "start", "performance", "now", "key", "clear", "elapsed", "warn", "PRESENCE_CHANNEL_ID", "Presence", "Resource", "updated", "newPeer", "_peerStates", "_peersByIdentityKey", "_isOnline", "getTime", "offlineTimeout", "announceInterval", "gossip", "_receiveAnnounces", "_open", "peerState", "identityKey", "connections", "on", "_removePeerFromIdentityKeyIndex", "_catch", "getPeers", "getPeersByIdentityKey", "filter", "m", "getPeersOnline", "getLocalState", "oldPeerState", "_updatePeerInIdentityKeyIndex", "identityPeerList", "peerIdIndex", "findIndex", "id", "splice", "newState", "identityKeyPeers", "existingIndex", "p", "oldState", "push"]
}
