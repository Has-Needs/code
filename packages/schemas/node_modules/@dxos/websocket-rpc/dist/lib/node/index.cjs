"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var node_exports = {};
__export(node_exports, {
  WebSocketWithTokenAuth: () => WebSocketWithTokenAuth,
  WebsocketRpcClient: () => WebsocketRpcClient,
  WebsocketRpcServer: () => WebsocketRpcServer,
  authenticateRequestWithTokenAuth: () => authenticateRequestWithTokenAuth
});
module.exports = __toCommonJS(node_exports);
var import_isomorphic_ws = __toESM(require("isomorphic-ws"));
var import_async = require("@dxos/async");
var import_log = require("@dxos/log");
var import_rpc = require("@dxos/rpc");
var import_isomorphic_ws2 = __toESM(require("isomorphic-ws"));
var import_log2 = require("@dxos/log");
var import_isomorphic_ws3 = __toESM(require("isomorphic-ws"));
var import_log3 = require("@dxos/log");
var import_rpc2 = require("@dxos/rpc");
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/core/mesh/websocket-rpc/src/token-auth.ts";
var PROTOCOL_TOKEN_PREFIX = "base64url.bearer.authorization.dxos.org";
var authenticateRequestWithTokenAuth = (request, socket, upgradeHead, token, cb) => {
  const protocolHeader = request.headers["sec-websocket-protocol"];
  if (!protocolHeader) {
    (0, import_log2.log)("upgrade unauthorized, header missing", {
      header: request.headers["sec-websocket-protocol"]
    }, {
      F: __dxlog_file,
      L: 28,
      S: void 0,
      C: (f, a) => f(...a)
    });
    socket.write("HTTP/1.1 401 Unauthorized\r\n\r\n");
    socket.destroy();
    return;
  }
  const tokenHeader = protocolHeader.replace(new RegExp(`^${PROTOCOL_TOKEN_PREFIX}.`), "");
  const encodedToken = Buffer.from(token).toString("base64").replace(/=*$/, "");
  if (tokenHeader !== encodedToken) {
    (0, import_log2.log)("upgrade unauthorized", {
      token,
      foo: encodedToken
    }, {
      F: __dxlog_file,
      L: 40,
      S: void 0,
      C: (f, a) => f(...a)
    });
    socket.write("HTTP/1.1 401 Unauthorized\r\n\r\n");
    socket.destroy();
    return;
  }
  cb(request, socket, upgradeHead);
};
var WebSocketWithTokenAuth = class extends import_isomorphic_ws2.default {
  constructor(url, token) {
    const encodedToken = Buffer.from(token).toString("base64").replace(/=*$/, "");
    const wsProtocols = [
      `base64url.bearer.authorization.dxos.org.${encodedToken}`
    ];
    super(url, wsProtocols);
    (0, import_log2.log)("encodedToken", {
      encodedToken
    }, {
      F: __dxlog_file,
      L: 55,
      S: this,
      C: (f, a) => f(...a)
    });
  }
};
function _ts_decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file2 = "/home/runner/work/dxos/dxos/packages/core/mesh/websocket-rpc/src/client.ts";
var WebsocketRpcClient = class {
  constructor(_params) {
    this._params = _params;
    this._connectTrigger = new import_async.Trigger();
    this.connected = new import_async.Event();
    this.disconnected = new import_async.Event();
    this.error = new import_async.Event();
    this._rpc = (0, import_rpc.createProtoRpcPeer)({
      requested: this._params.requested,
      exposed: this._params.exposed,
      handlers: this._params.handlers,
      noHandshake: this._params.noHandshake,
      port: {
        send: (msg) => {
          this._socket.send(msg);
        },
        subscribe: (cb) => {
          this._socket.onmessage = async (msg) => {
            if (typeof Blob !== "undefined" && msg.data instanceof Blob) {
              cb(Buffer.from(await msg.data.arrayBuffer()));
            } else {
              cb(msg.data);
            }
          };
        }
      }
    });
  }
  get url() {
    return this._params.url;
  }
  async open() {
    if (this._params.authenticationToken) {
      this._socket = new WebSocketWithTokenAuth(this._params.url, this._params.authenticationToken);
    } else {
      this._socket = new import_isomorphic_ws.default(this._params.url);
    }
    this._socket.onopen = async () => {
      (0, import_log.log)("Socket open", void 0, {
        F: __dxlog_file2,
        L: 62,
        S: this,
        C: (f, a) => f(...a)
      });
      try {
        await this._rpc.open();
        (0, import_log.log)(`RPC open ${this._params.url}`, void 0, {
          F: __dxlog_file2,
          L: 65,
          S: this,
          C: (f, a) => f(...a)
        });
        this.connected.emit();
        this._connectTrigger.wake();
      } catch (err) {
        this.error.emit(err);
      }
    };
    this._socket.onclose = async () => {
      (0, import_log.log)(`Disconnected ${this._params.url}`, void 0, {
        F: __dxlog_file2,
        L: 74,
        S: this,
        C: (f, a) => f(...a)
      });
      this.disconnected.emit();
      await this.close();
    };
    this._socket.onerror = (event) => {
      import_log.log.error(event.message ?? "Socket error", {
        url: this._params.url
      }, {
        F: __dxlog_file2,
        L: 81,
        S: this,
        C: (f, a) => f(...a)
      });
      const error = event.error ?? new Error(event.message);
      this.error.emit(error);
      this._connectTrigger.throw(error);
    };
    await this._connectTrigger.wait();
  }
  async close() {
    try {
      await this._rpc?.close();
    } catch (err) {
      import_log.log.catch(err, void 0, {
        F: __dxlog_file2,
        L: 94,
        S: this,
        C: (f, a) => f(...a)
      });
    }
    this._socket?.close();
  }
  get rpc() {
    return this._rpc.rpc;
  }
};
_ts_decorate([
  import_log.logInfo
], WebsocketRpcClient.prototype, "url", null);
var __dxlog_file3 = "/home/runner/work/dxos/dxos/packages/core/mesh/websocket-rpc/src/server.ts";
var WebsocketRpcServer = class {
  constructor(_params) {
    this._params = _params;
  }
  handleUpgrade(request, socket, head) {
    this._server?.handleUpgrade(request, socket, head, (ws) => {
      this._server?.emit("connection", ws, request);
    });
  }
  async open() {
    this._server = new import_isomorphic_ws3.default.Server({
      ...this._params
    });
    this._server.on("connection", async (socket, request) => {
      (0, import_log3.log)("connection", {
        url: request.url,
        headers: request.headers
      }, {
        F: __dxlog_file3,
        L: 40,
        S: this,
        C: (f, a) => f(...a)
      });
      const info = {
        request
      };
      const { onOpen, onClose, ...options } = await this._params.onConnection(info);
      const rpc = (0, import_rpc2.createProtoRpcPeer)({
        ...options,
        port: {
          send: (msg) => {
            socket.send(msg);
          },
          subscribe: (cb) => {
            socket.onmessage = async (msg) => {
              if (typeof Blob !== "undefined" && msg.data instanceof Blob) {
                cb(Buffer.from(await msg.data.arrayBuffer()));
              } else {
                cb(msg.data);
              }
            };
          }
        }
      });
      await rpc.open();
      await onOpen?.(rpc);
      socket.onclose = async () => {
        await onClose?.(rpc);
        await rpc.close();
      };
    });
  }
  async close() {
    this._server?.close();
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  WebSocketWithTokenAuth,
  WebsocketRpcClient,
  WebsocketRpcServer,
  authenticateRequestWithTokenAuth
});
//# sourceMappingURL=index.cjs.map
