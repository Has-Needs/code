import type * as A from '@automerge/automerge';
import { type ObjectStructure } from '@dxos/echo-protocol';
import { type BaseObject, type BaseEchoObject } from '@dxos/echo-schema';
import { type Live } from '@dxos/live-object';
import { type ProxyTarget } from './echo-proxy-target';
import { type KeyPath, ObjectCore } from '../core-db';
export declare const throwIfCustomClass: (prop: KeyPath[number], value: any) => void;
export declare const getObjectCore: <T extends BaseObject>(obj: Live<T>) => ObjectCore;
/**
 * @returns Automerge document (or a part of it) that backs the object.
 * Mostly used for debugging.
 */
export declare const getObjectDocument: (obj: AnyLiveObject<any>) => A.Doc<ObjectStructure>;
export declare const isRootDataObject: (target: ProxyTarget) => boolean;
/** @deprecated Use {@link @dxos/echo#AnyLiveObject} instead. */
export type AnyLiveObject<T extends BaseObject = any> = Live<T> & BaseEchoObject;
/**
 * @returns True if `value` is a reactive object with an EchoHandler backend.
 */
export declare const isEchoObject: (value: any) => value is AnyLiveObject<any>;
/**
 * Used to determine if the value should be placed at the root of a separate ECHO object.
 *
 * @returns True if `value` is a reactive object with an EchoHandler backend or a schema that has an `Object` annotation.
 */
export declare const isTypedObjectProxy: (value: any) => value is Live<any>;
//# sourceMappingURL=echo-handler.d.ts.map