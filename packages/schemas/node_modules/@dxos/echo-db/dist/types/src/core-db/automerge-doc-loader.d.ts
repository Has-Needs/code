import { type AutomergeUrl } from '@automerge/automerge-repo';
import { Event } from '@dxos/async';
import { type Context } from '@dxos/context';
import { type SpaceState, DatabaseDirectory } from '@dxos/echo-protocol';
import { type ObjectId, type PublicKey, type SpaceId } from '@dxos/keys';
import { type RepoProxy, type DocHandleProxy } from '../automerge';
type SpaceDocumentLinks = DatabaseDirectory['links'];
export interface AutomergeDocumentLoader {
    onObjectDocumentLoaded: Event<ObjectDocumentLoaded>;
    get hasRootHandle(): boolean;
    getAllHandles(): DocHandleProxy<DatabaseDirectory>[];
    /**
     * @returns Handles linked from the space root handle.
     */
    getLinkedDocHandles(): DocHandleProxy<DatabaseDirectory>[];
    objectPresent(id: ObjectId): boolean;
    loadSpaceRootDocHandle(ctx: Context, spaceState: SpaceState): Promise<void>;
    loadObjectDocument(objectId: string | string[]): void;
    getObjectDocumentId(objectId: string): string | undefined;
    getSpaceRootDocHandle(): DocHandleProxy<DatabaseDirectory>;
    createDocumentForObject(objectId: string): DocHandleProxy<DatabaseDirectory>;
    onObjectLinksUpdated(links: SpaceDocumentLinks): void;
    onObjectBoundToDocument(handle: DocHandleProxy<DatabaseDirectory>, objectId: string): void;
    /**
     * @returns objectIds for which we had document handles or were loading one.
     */
    clearHandleReferences(): string[];
}
/**
 * Manages object <-> docHandle binding and automerge document loading.
 */
export declare class AutomergeDocumentLoaderImpl implements AutomergeDocumentLoader {
    private readonly _repo;
    private readonly _spaceId;
    /** Legacy Id */
    private readonly _spaceKey;
    private _spaceRootDocHandle;
    /**
     * An object id pointer to a handle of the document where the object is stored inline.
     */
    private readonly _objectDocumentHandles;
    /**
     * If object was requested via loadObjectDocument but root document links weren't updated yet
     * loading will be triggered in onObjectLinksUpdated callback.
     */
    private readonly _objectsPendingDocumentLoad;
    /**
     * Keeps track of objects that are currently being loaded.
     * Prevents multiple concurrent loads of the same document.
     * This can happen on SpaceRootHandle switch because we don't cancel the previous load.
     */
    private readonly _currentlyLoadingObjects;
    readonly onObjectDocumentLoaded: Event<ObjectDocumentLoaded>;
    constructor(_repo: RepoProxy, _spaceId: SpaceId, 
    /** Legacy Id */
    _spaceKey: PublicKey);
    get hasRootHandle(): boolean;
    getAllHandles(): DocHandleProxy<DatabaseDirectory>[];
    getLinkedDocHandles(): DocHandleProxy<DatabaseDirectory>[];
    loadSpaceRootDocHandle(ctx: Context, spaceState: SpaceState): Promise<void>;
    objectPresent(id: ObjectId): boolean;
    loadObjectDocument(objectIdOrMany: string | string[]): void;
    getObjectDocumentId(objectId: string): string | undefined;
    onObjectLinksUpdated(links: SpaceDocumentLinks): void;
    getSpaceRootDocHandle(): DocHandleProxy<DatabaseDirectory>;
    createDocumentForObject(objectId: string): DocHandleProxy<DatabaseDirectory>;
    onObjectBoundToDocument(handle: DocHandleProxy<DatabaseDirectory>, objectId: string): void;
    clearHandleReferences(): string[];
    private _getLinkedDocumentUrl;
    private _loadLinkedObjects;
    private _initDocHandle;
    private _initDocAccess;
    private _loadHandleForObject;
}
export interface ObjectDocumentLoaded {
    handle: DocHandleProxy<DatabaseDirectory>;
    objectId: string;
}
export interface DocumentChanges {
    createdObjectIds: string[];
    updatedObjectIds: string[];
    objectsToRebind: string[];
    linkedDocuments: {
        [echoId: string]: AutomergeUrl;
    };
}
export {};
//# sourceMappingURL=automerge-doc-loader.d.ts.map