import { type Obj, type Relation } from '@dxos/echo';
import { ObjectId, type BaseEchoObject } from '@dxos/echo-schema';
import { DXN, SpaceId } from '@dxos/keys';
import { type Queue } from './types';
export type MemoryQueueOptions<T extends BaseEchoObject = BaseEchoObject> = {
    spaceId?: SpaceId;
    queueId?: string;
    dxn?: DXN;
    objects?: T[];
};
/**
 * In-memory queue.
 * @deprecated Use the actual queue with a mock service.
 */
export declare class MemoryQueue<T extends Obj.Any | Relation.Any = Obj.Any | Relation.Any> implements Queue<T> {
    private readonly _dxn;
    static make<T extends Obj.Any | Relation.Any = Obj.Any | Relation.Any>({ spaceId, queueId, dxn, objects, }: MemoryQueueOptions<T>): MemoryQueue<T>;
    private readonly _signal;
    private _objects;
    constructor(_dxn: DXN);
    toJSON(): {
        dxn: DXN.String;
        objects: number;
    };
    get dxn(): DXN;
    get isLoading(): boolean;
    get error(): Error | null;
    get objects(): T[];
    /**
     * Insert into queue with optimistic update.
     */
    append(objects: T[]): Promise<void>;
    queryObjects(): Promise<T[]>;
    getObjectsById(ids: ObjectId[]): Promise<(T | null)[]>;
    delete(ids: ObjectId[]): Promise<void>;
    refresh(): Promise<void>;
}
//# sourceMappingURL=memory-queue.d.ts.map