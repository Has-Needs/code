import { type ChangeFn, type ChangeOptions, type Doc, type Heads, next as A } from '@automerge/automerge';
import { type DocHandleChangePayload } from '@automerge/automerge-repo';
import type { InspectOptionsStylized, inspect } from 'util';
import { Event } from '@dxos/async';
import { inspectCustom } from '@dxos/debug';
import { type ObjectStructure, Reference, type DatabaseDirectory } from '@dxos/echo-protocol';
import { EntityKind, type CommonObjectData, type ObjectMeta } from '@dxos/echo-schema';
import { DXN } from '@dxos/keys';
import { type CoreDatabase } from './core-database';
import { type DocAccessor, type DecodedAutomergePrimaryValue, type KeyPath } from './types';
import { type DocHandleProxy } from '../automerge';
export declare const META_NAMESPACE = "meta";
export type ObjectCoreOptions = {
    type?: Reference;
    meta?: ObjectMeta;
    immutable?: boolean;
};
/**
 *
 */
export declare class ObjectCore {
    /**
     * Id of the ECHO object.
     */
    id: string;
    /**
     * Set if when the object is bound to a database.
     */
    database?: CoreDatabase | undefined;
    /**
     * Set if when the object is not bound to a database.
     */
    doc?: Doc<ObjectStructure> | undefined;
    /**
     * Set if when the object is bound to a database.
     */
    docHandle?: DocHandleProxy<DatabaseDirectory>;
    /**
     * Key path at where we are mounted in the `doc` or `docHandle`.
     * The value at path must be of type `ObjectStructure`.
     */
    mountPath: KeyPath;
    /**
     * Handles link resolution as well as manual changes.
     */
    readonly updates: Event<void>;
    toString(): string;
    [inspectCustom](depth: number, options: InspectOptionsStylized, inspectFn: typeof inspect): string;
    /**
     * Create local doc with initial state from this object.
     */
    initNewObject(initialProps?: unknown, opts?: ObjectCoreOptions): void;
    bind(options: BindOptions): void;
    getDoc(): Doc<unknown>;
    getObjectStructure(): ObjectStructure;
    /**
     * Do not take into account mountPath.
     */
    change(changeFn: ChangeFn<any>, options?: A.ChangeOptions<any>): void;
    /**
     * Do not take into account mountPath.
     */
    changeAt(heads: Heads, callback: ChangeFn<any>, options?: ChangeOptions<any>): Heads | undefined;
    getDocAccessor(path?: KeyPath): DocAccessor;
    /**
     * Fire a synchronous update notification via signal and event subscriptions.
     * Called after local changes and link resolution.
     * This function can be used unbound.
     */
    readonly notifyUpdate: () => void;
    /**
     * Encode a value to be stored in the Automerge document.
     */
    encode(value: DecodedAutomergePrimaryValue): any;
    /**
     * Decode a value from the Automerge document.
     */
    decode(value: any): DecodedAutomergePrimaryValue;
    arrayPush(path: KeyPath, items: DecodedAutomergePrimaryValue[]): number;
    private _getRaw;
    private _setRaw;
    getDecoded(path: KeyPath): DecodedAutomergePrimaryValue;
    setDecoded(path: KeyPath, value: DecodedAutomergePrimaryValue): void;
    /**
     * Deletes key at path.
     */
    delete(path: KeyPath): void;
    getKind(): EntityKind;
    setKind(kind: EntityKind): void;
    getSource(): Reference | undefined;
    setSource(ref: Reference): void;
    getTarget(): Reference | undefined;
    setTarget(ref: Reference): void;
    getType(): Reference | undefined;
    setType(reference: Reference): void;
    getMeta(): ObjectMeta;
    setMeta(meta: ObjectMeta): void;
    isDeleted(): boolean;
    setDeleted(value: boolean): void;
    /**
     * @deprecated
     */
    toPlainObject(): CommonObjectData & Record<string, any>;
    /**
     * DXNs of objects that this object strongly depends on.
     * Strong references are loaded together with the source object.
     * Currently this is the schema reference and the source and target for relations
     */
    getStrongDependencies(): DXN[];
}
export type BindOptions = {
    db: CoreDatabase;
    docHandle: DocHandleProxy<DatabaseDirectory>;
    path: KeyPath;
    /**
     * Assign the state from the local doc into the shared structure for the database.
     */
    assignFromLocalState?: boolean;
};
export declare const objectIsUpdated: (objId: string, event: DocHandleChangePayload<DatabaseDirectory>) => boolean;
//# sourceMappingURL=object-core.d.ts.map