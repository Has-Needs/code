import { type Schema } from 'effect';
import type { Type } from '@dxos/echo';
import { type DXN } from '@dxos/keys';
import type { EchoDatabase } from './database';
import type { AnyLiveObject } from '../echo-handler';
type DefineObjectMigrationOptions<From extends Schema.Schema.AnyNoContext, To extends Schema.Schema.AnyNoContext> = {
    from: From;
    to: To;
    /**
     * Pure function that converts the old object data to the new object data.
     */
    transform: (from: Schema.Schema.Type<From>, context: ObjectMigrationContext) => Promise<Omit<Schema.Schema.Type<To>, 'id' | Type.KindId>>;
    /**
     * Callback that is called after the object is migrated. Called for every object that is migrated.
     *
     * NOTE: Database mutations performed in this callback are not guaranteed to be idempotent.
     *       If multiple peers run the migration separately, the effects may be applied multiple times.
     */
    onMigration: (params: OnMigrateParams<From, To>) => Promise<void>;
};
type ObjectMigrationContext = {};
type OnMigrateParams<From extends Schema.Schema.AnyNoContext, To extends Schema.Schema.AnyNoContext> = {
    before: Schema.Schema.Type<From>;
    object: AnyLiveObject<Schema.Schema.Type<To>>;
    db: EchoDatabase;
};
export type ObjectMigration = {
    fromType: DXN;
    toType: DXN;
    fromSchema: Schema.Schema.AnyNoContext;
    toSchema: Schema.Schema.AnyNoContext;
    transform: (from: unknown, context: ObjectMigrationContext) => Promise<unknown>;
    onMigration: (params: OnMigrateParams<any, any>) => Promise<void>;
};
export declare const defineObjectMigration: <From extends Schema.Schema.AnyNoContext, To extends Schema.Schema.AnyNoContext>(options: DefineObjectMigrationOptions<From, To>) => ObjectMigration;
export {};
//# sourceMappingURL=object-migration.d.ts.map