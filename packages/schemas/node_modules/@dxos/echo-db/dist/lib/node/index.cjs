"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var node_exports = {};
__export(node_exports, {
  CoreDatabase: () => import_chunk_WEFFA7O3.CoreDatabase,
  DocAccessor: () => import_chunk_WEFFA7O3.DocAccessor,
  DocHandleProxy: () => import_chunk_WEFFA7O3.DocHandleProxy,
  EchoClient: () => import_chunk_WEFFA7O3.EchoClient,
  EchoDatabaseImpl: () => import_chunk_WEFFA7O3.EchoDatabaseImpl,
  EchoReactiveHandler: () => import_chunk_WEFFA7O3.EchoReactiveHandler,
  EchoSchemaRegistry: () => import_chunk_WEFFA7O3.EchoSchemaRegistry,
  Filter: () => import_chunk_WEFFA7O3.Filter,
  GraphQueryContext: () => import_chunk_WEFFA7O3.GraphQueryContext,
  Hypergraph: () => import_chunk_WEFFA7O3.Hypergraph,
  META_NAMESPACE: () => import_chunk_WEFFA7O3.META_NAMESPACE,
  MemoryQueue: () => import_chunk_WEFFA7O3.MemoryQueue,
  MockQueueService: () => import_chunk_WEFFA7O3.MockQueueService,
  OBJECT_DIAGNOSTICS: () => import_chunk_WEFFA7O3.OBJECT_DIAGNOSTICS,
  ObjectCore: () => import_chunk_WEFFA7O3.ObjectCore,
  ObjectVersion: () => import_chunk_WEFFA7O3.ObjectVersion,
  Query: () => import_chunk_WEFFA7O3.Query,
  QueryResult: () => import_chunk_WEFFA7O3.QueryResult,
  Queue: () => import_chunk_WEFFA7O3.Queue,
  QueueFactory: () => import_chunk_WEFFA7O3.QueueFactory,
  QueueImpl: () => import_chunk_WEFFA7O3.QueueImpl,
  QueueServiceImpl: () => import_chunk_WEFFA7O3.QueueServiceImpl,
  QueueServiceStub: () => import_chunk_WEFFA7O3.QueueServiceStub,
  RepoProxy: () => import_chunk_WEFFA7O3.RepoProxy,
  ResultFormat: () => import_chunk_WEFFA7O3.ResultFormat,
  Serializer: () => Serializer,
  SpaceQuerySource: () => import_chunk_WEFFA7O3.SpaceQuerySource,
  checkoutVersion: () => import_chunk_WEFFA7O3.checkoutVersion,
  clone: () => import_chunk_WEFFA7O3.clone,
  createDocAccessor: () => import_chunk_WEFFA7O3.createDocAccessor,
  createObject: () => import_chunk_WEFFA7O3.createObject,
  createSubscription: () => import_chunk_WEFFA7O3.createSubscription,
  decodeReferenceJSON: () => decodeReferenceJSON,
  defineObjectMigration: () => import_chunk_WEFFA7O3.defineObjectMigration,
  findObjectWithForeignKey: () => import_chunk_WEFFA7O3.findObjectWithForeignKey,
  fromCursor: () => fromCursor,
  getBody: () => getBody,
  getDatabaseFromObject: () => import_chunk_WEFFA7O3.getDatabaseFromObject,
  getEditHistory: () => import_chunk_WEFFA7O3.getEditHistory,
  getHeader: () => getHeader,
  getObjectCore: () => import_chunk_WEFFA7O3.getObjectCore,
  getRangeFromCursor: () => getRangeFromCursor,
  getReferenceWithSpaceKey: () => import_chunk_WEFFA7O3.getReferenceWithSpaceKey,
  getSource: () => import_chunk_WEFFA7O3.getSource,
  getTarget: () => import_chunk_WEFFA7O3.getTarget,
  getTargetSpacesForQuery: () => import_chunk_WEFFA7O3.getTargetSpacesForQuery,
  getTextInRange: () => getTextInRange,
  getVersion: () => import_chunk_WEFFA7O3.getVersion,
  initEchoReactiveObjectRootProxy: () => import_chunk_WEFFA7O3.initEchoReactiveObjectRootProxy,
  isEchoObject: () => import_chunk_WEFFA7O3.isEchoObject,
  isRelation: () => import_chunk_WEFFA7O3.isRelation,
  isSimpleSelectionQuery: () => import_chunk_WEFFA7O3.isSimpleSelectionQuery,
  isValidKeyPath: () => import_chunk_WEFFA7O3.isValidKeyPath,
  loadObject: () => import_chunk_WEFFA7O3.loadObject,
  loadObjectReferences: () => import_chunk_WEFFA7O3.loadObjectReferences,
  matchKeys: () => import_chunk_WEFFA7O3.matchKeys,
  migrateDocument: () => migrateDocument,
  normalizeQuery: () => import_chunk_WEFFA7O3.normalizeQuery,
  normalizeSerializedObjectData: () => normalizeSerializedObjectData,
  objectIsUpdated: () => import_chunk_WEFFA7O3.objectIsUpdated,
  optionsToProto: () => import_chunk_WEFFA7O3.optionsToProto,
  prohibitSignalActions: () => import_chunk_WEFFA7O3.prohibitSignalActions,
  toCursor: () => toCursor,
  toCursorRange: () => toCursorRange,
  updateText: () => updateText
});
module.exports = __toCommonJS(node_exports);
var import_chunk_WEFFA7O3 = require("./chunk-WEFFA7O3.cjs");
var import_echo = require("@dxos/echo");
var import_echo_protocol = require("@dxos/echo-protocol");
var import_invariant = require("@dxos/invariant");
var import_util = require("@dxos/util");
var import_util2 = require("@dxos/util");
var import_automerge = require("@automerge/automerge");
var import_invariant2 = require("@dxos/invariant");
var import_live_object = require("@dxos/live-object");
var import_util3 = require("@dxos/util");
var import_live_object2 = require("@dxos/live-object");
var import_automerge2 = require("@automerge/automerge");
var import_invariant3 = require("@dxos/invariant");
var import_log = require("@dxos/log");
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/core/echo/echo-db/src/serializer.ts";
var MAX_LOAD_OBJECT_CHUNK_SIZE = 30;
var LEGACY_REFERENCE_TYPE_TAG = "dxos.echo.model.document.Reference";
var Serializer = class _Serializer {
  static {
    this.version = 1;
  }
  async export(database) {
    const ids = database.coreDatabase.getAllObjectIds();
    const loadedObjects = [];
    for (const chunk of chunkArray(ids, MAX_LOAD_OBJECT_CHUNK_SIZE)) {
      const { objects } = await database.query(import_echo.Filter.ids(...chunk)).run({
        timeout: 6e4
      });
      loadedObjects.push(...objects);
    }
    const data = {
      objects: loadedObjects.filter(import_util.isNonNullable).map((object) => {
        return this.exportObject(object);
      }),
      version: _Serializer.version,
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      spaceKey: database.spaceKey.toHex()
    };
    return data;
  }
  async import(database, data, opts) {
    (0, import_invariant.invariant)(data.version === _Serializer.version, `Invalid version: ${data.version}`, {
      F: __dxlog_file,
      L: 56,
      S: this,
      A: [
        "data.version === Serializer.version",
        "`Invalid version: ${data.version}`"
      ]
    });
    const { objects } = data;
    for (const object of objects) {
      const shouldImport = opts?.onObject ? await opts.onObject(object) : true;
      if (shouldImport) {
        this._importObject(database, object);
      }
    }
    await database.flush();
  }
  exportObject(object) {
    const core = (0, import_chunk_WEFFA7O3.getObjectCore)(object);
    const typeRef = core.getType();
    const data = serializeEchoData(core.getDecoded([
      "data"
    ]));
    const meta = serializeEchoData(core.getDecoded([
      "meta"
    ]));
    return (0, import_util.stripUndefined)({
      "@id": core.id,
      "@type": typeRef ? (0, import_echo_protocol.encodeReference)(typeRef) : void 0,
      ...data,
      "@version": _Serializer.version,
      "@meta": meta,
      "@timestamp": (/* @__PURE__ */ new Date()).toISOString()
    });
  }
  _importObject(database, object) {
    const { "@id": id, "@type": type, "@deleted": deleted, "@meta": meta, ...data } = object;
    const dataProperties = Object.fromEntries(Object.entries(data).filter(([key]) => !key.startsWith("@")));
    const decodedData = (0, import_util.deepMapValues)(dataProperties, (value, recurse) => {
      if (isEncodedReferenceJSON(value)) {
        return decodeReferenceJSON(value);
      } else {
        return recurse(value);
      }
    });
    const core = new import_chunk_WEFFA7O3.ObjectCore();
    core.id = id;
    core.initNewObject(decodedData, {
      meta
    });
    core.setType(decodeReferenceJSON(type));
    if (deleted) {
      core.setDeleted(deleted);
    }
    database.coreDatabase.addCore(core);
  }
};
var isEncodedReferenceJSON = (value) => typeof value === "object" && value !== null && ("/" in value || value["@type"] === LEGACY_REFERENCE_TYPE_TAG);
var decodeReferenceJSON = (encoded) => {
  if (typeof encoded === "object" && encoded !== null && "/" in encoded) {
    return (0, import_echo_protocol.decodeReference)(encoded);
  } else if (typeof encoded === "string") {
    return import_echo_protocol.Reference.fromLegacyTypename(encoded);
  }
};
var chunkArray = (arr, chunkSize) => {
  if (arr.length === 0 || chunkSize < 1) {
    return [];
  }
  let index = 0;
  let resIndex = 0;
  const result = new Array(Math.ceil(arr.length / chunkSize));
  while (index < arr.length) {
    result[resIndex++] = arr.slice(index, index += chunkSize);
  }
  return result;
};
var serializeEchoData = (data) => (0, import_util.deepMapValues)(data, (value, recurse) => {
  if (value instanceof import_echo_protocol.Reference) {
    return (0, import_echo_protocol.encodeReference)(value);
  }
  return recurse(value);
});
var normalizeSerializedObjectData = async (data) => {
  data = await (0, import_util2.deepMapValuesAsync)(data, async (value, recurse) => {
    return recurse(value);
  });
  if (data["@timestamp"]) {
    data["@timestamp"] = new Date(data["@timestamp"]).toISOString();
  }
  return data;
};
var __dxlog_file2 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-db/src/text.ts";
var toCursor = (accessor, pos, assoc = 0) => {
  const doc = accessor.handle.doc();
  if (!doc) {
    return "";
  }
  const value = (0, import_util3.get)(doc, accessor.path);
  if (typeof value === "string" && value.length <= pos) {
    return "end";
  }
  return import_automerge.next.getCursor(doc, accessor.path.slice(), pos);
};
var toCursorRange = (accessor, start, end) => {
  return `${toCursor(accessor, start)}:${toCursor(accessor, end)}`;
};
var fromCursor = (accessor, cursor) => {
  if (cursor === "") {
    return 0;
  }
  const doc = accessor.handle.doc();
  if (!doc) {
    return 0;
  }
  if (cursor === "end") {
    const value = (0, import_util3.get)(doc, accessor.path);
    if (typeof value === "string") {
      return value.length;
    } else {
      return 0;
    }
  }
  return import_automerge.next.getCursorPosition(doc, accessor.path.slice(), cursor);
};
var getTextInRange = (accessor, start, end) => {
  const doc = accessor.handle.doc();
  const value = (0, import_util3.get)(doc, accessor.path);
  if (typeof value === "string") {
    const beginIdx = fromCursor(accessor, start);
    const endIdx = fromCursor(accessor, end);
    if (beginIdx <= value.length) {
      return value.slice(beginIdx, endIdx);
    }
  }
};
var getRangeFromCursor = (accessor, cursor) => {
  const [start, end] = cursor.split(":");
  if (start === void 0 || end === void 0) {
    return void 0;
  }
  return {
    start: fromCursor(accessor, start),
    end: fromCursor(accessor, end)
  };
};
var updateText = (obj, path, newText) => {
  (0, import_invariant2.invariant)((0, import_live_object.isLiveObject)(obj), void 0, {
    F: __dxlog_file2,
    L: 94,
    S: void 0,
    A: [
      "isLiveObject(obj)",
      ""
    ]
  });
  (0, import_invariant2.invariant)(path === void 0 || (0, import_chunk_WEFFA7O3.isValidKeyPath)(path), void 0, {
    F: __dxlog_file2,
    L: 95,
    S: void 0,
    A: [
      "path === undefined || isValidKeyPath(path)",
      ""
    ]
  });
  const accessor = (0, import_chunk_WEFFA7O3.createDocAccessor)(obj, path);
  accessor.handle.change((doc) => {
    import_automerge.next.updateText(doc, accessor.path.slice(), newText);
  });
  return obj;
};
var idStyle = {
  style: "color: #777"
};
var listStyle = {
  style: "list-style-type: none; padding: 0; margin: 0 0 0 12px; font-style: normal; position: relative"
};
var liStyle = {
  style: "min-height: 16px;"
};
var nestedObjectContainerStyle = {
  style: "margin: -2px 0 0; display: inline-flex"
};
var keyStyle = {
  style: "color: #881391"
};
var defaultValueKeyStyle = {
  style: "color: #777"
};
var alteredValueKeyStyle = {
  style: "color: #881391; font-weight: bolder"
};
var nullStyle = {
  style: "color: #777"
};
var defaultKeys = [
  "id",
  "__typename",
  "__schema",
  "meta"
];
var getHeader = (obj, config) => {
  return [
    "span",
    {
      style: (config?.nested ? "padding: 2px 0 0;" : "") + "\n height: 18px;"
    },
    `${obj[Symbol.toStringTag]}`,
    [
      "span",
      idStyle,
      `#${obj.id}`
    ]
  ];
};
var formatValue = (object, config) => {
  if (typeof object === "undefined") {
    return [
      "span",
      nullStyle,
      "undefined"
    ];
  } else if (object === "null") {
    return [
      "span",
      nullStyle,
      "null"
    ];
  } else {
    return [
      "span",
      nestedObjectContainerStyle,
      [
        "object",
        {
          object,
          config
        }
      ]
    ];
  }
};
var getBody = (obj) => {
  const objData = obj[import_live_object2.objectData];
  return [
    "ol",
    listStyle,
    ...Object.keys(objData).map((key) => [
      "li",
      liStyle,
      [
        "span",
        defaultKeys.includes(key) ? keyStyle : key.startsWith("[[") ? defaultValueKeyStyle : alteredValueKeyStyle,
        key
      ],
      [
        "span",
        {},
        ": "
      ],
      formatValue(objData[key], {
        nested: true
      })
    ])
  ];
};
var __dxlog_file3 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-db/src/util/migrate-document.ts";
var migrateDocument = (source, targetData) => {
  (0, import_log.log)("begin migration", {
    source,
    targetData
  }, {
    F: __dxlog_file3,
    L: 14,
    S: void 0,
    C: (f, a) => f(...a)
  });
  const clonedDoc = import_automerge2.next.clone(source);
  const changedDoc = import_automerge2.next.change(clonedDoc, (applyTo) => {
    const coalesce = (applyTo2, targetData2) => {
      (0, import_invariant3.invariant)(typeof applyTo2 === "object" && applyTo2 !== null, void 0, {
        F: __dxlog_file3,
        L: 20,
        S: void 0,
        A: [
          "typeof applyTo === 'object' && applyTo !== null",
          ""
        ]
      });
      (0, import_invariant3.invariant)(typeof targetData2 === "object" && targetData2 !== null, void 0, {
        F: __dxlog_file3,
        L: 21,
        S: void 0,
        A: [
          "typeof targetData === 'object' && targetData !== null",
          ""
        ]
      });
      for (const key in targetData2) {
        if (targetData2[key] !== applyTo2[key]) {
          if (typeof targetData2[key] === "object" && targetData2[key] !== null) {
            if (Array.isArray(targetData2[key]) && !Array.isArray(applyTo2[key])) {
              applyTo2[key] = [];
            } else if (typeof applyTo2[key] !== "object" || applyTo2[key] === null) {
              applyTo2[key] = {};
            }
            coalesce(applyTo2[key], targetData2[key]);
          } else {
            applyTo2[key] = targetData2[key];
          }
        }
      }
      for (const key in applyTo2) {
        if (!(key in targetData2)) {
          delete applyTo2[key];
        }
      }
    };
    coalesce(applyTo, targetData);
  });
  (0, import_log.log)("end migration", {
    changedDoc
  }, {
    F: __dxlog_file3,
    L: 51,
    S: void 0,
    C: (f, a) => f(...a)
  });
  return changedDoc;
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  CoreDatabase,
  DocAccessor,
  DocHandleProxy,
  EchoClient,
  EchoDatabaseImpl,
  EchoReactiveHandler,
  EchoSchemaRegistry,
  Filter,
  GraphQueryContext,
  Hypergraph,
  META_NAMESPACE,
  MemoryQueue,
  MockQueueService,
  OBJECT_DIAGNOSTICS,
  ObjectCore,
  ObjectVersion,
  Query,
  QueryResult,
  Queue,
  QueueFactory,
  QueueImpl,
  QueueServiceImpl,
  QueueServiceStub,
  RepoProxy,
  ResultFormat,
  Serializer,
  SpaceQuerySource,
  checkoutVersion,
  clone,
  createDocAccessor,
  createObject,
  createSubscription,
  decodeReferenceJSON,
  defineObjectMigration,
  findObjectWithForeignKey,
  fromCursor,
  getBody,
  getDatabaseFromObject,
  getEditHistory,
  getHeader,
  getObjectCore,
  getRangeFromCursor,
  getReferenceWithSpaceKey,
  getSource,
  getTarget,
  getTargetSpacesForQuery,
  getTextInRange,
  getVersion,
  initEchoReactiveObjectRootProxy,
  isEchoObject,
  isRelation,
  isSimpleSelectionQuery,
  isValidKeyPath,
  loadObject,
  loadObjectReferences,
  matchKeys,
  migrateDocument,
  normalizeQuery,
  normalizeSerializedObjectData,
  objectIsUpdated,
  optionsToProto,
  prohibitSignalActions,
  toCursor,
  toCursorRange,
  updateText
});
//# sourceMappingURL=index.cjs.map
