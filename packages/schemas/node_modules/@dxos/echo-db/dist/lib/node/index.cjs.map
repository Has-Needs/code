{
  "version": 3,
  "sources": ["../../../src/serializer.ts", "../../../src/serialized-space.ts", "../../../src/text.ts", "../../../src/util/devtools-formatter.ts", "../../../src/util/migrate-document.ts"],
  "sourcesContent": ["//\n// Copyright 2023 DXOS.org\n//\n\nimport { Filter } from '@dxos/echo';\nimport { decodeReference, type EncodedReference, encodeReference, Reference } from '@dxos/echo-protocol';\nimport { invariant } from '@dxos/invariant';\nimport { deepMapValues, isNonNullable, stripUndefined } from '@dxos/util';\n\nimport { ObjectCore } from './core-db';\nimport { getObjectCore, type AnyLiveObject } from './echo-handler';\nimport { type EchoDatabase } from './proxy-db';\nimport type { SerializedObject, SerializedSpace } from './serialized-space';\n\nconst MAX_LOAD_OBJECT_CHUNK_SIZE = 30;\n\nconst LEGACY_REFERENCE_TYPE_TAG = 'dxos.echo.model.document.Reference';\n\nexport type ImportOptions = {\n  /**\n   * Called for each object before importing.\n   * @returns true to import the object, false to skip.\n   */\n  onObject?: (object: SerializedObject) => Promise<boolean>;\n};\n\n// TODO(burdon): Schema not present when reloaded from persistent store.\n// TODO(burdon): Option to decode JSON/protobuf.\n// TODO(burdon): Sort JSON keys (npm canonical serialize util).\nexport class Serializer {\n  static version = 1;\n\n  async export(database: EchoDatabase): Promise<SerializedSpace> {\n    const ids = database.coreDatabase.getAllObjectIds();\n\n    const loadedObjects: Array<AnyLiveObject<any> | undefined> = [];\n    for (const chunk of chunkArray(ids, MAX_LOAD_OBJECT_CHUNK_SIZE)) {\n      const { objects } = await database.query(Filter.ids(...chunk)).run({ timeout: 60_000 });\n      loadedObjects.push(...objects);\n    }\n\n    const data = {\n      objects: loadedObjects.filter(isNonNullable).map((object) => {\n        return this.exportObject(object as any);\n      }),\n\n      version: Serializer.version,\n      timestamp: new Date().toISOString(),\n      spaceKey: database.spaceKey.toHex(),\n    };\n\n    return data;\n  }\n\n  async import(database: EchoDatabase, data: SerializedSpace, opts?: ImportOptions): Promise<void> {\n    invariant(data.version === Serializer.version, `Invalid version: ${data.version}`);\n\n    const { objects } = data;\n    for (const object of objects) {\n      const shouldImport = opts?.onObject ? await opts.onObject(object) : true;\n\n      if (shouldImport) {\n        this._importObject(database, object);\n      }\n    }\n    await database.flush();\n  }\n\n  exportObject(object: AnyLiveObject<any>): SerializedObject {\n    const core = getObjectCore(object);\n\n    // TODO(dmaretskyi): Unify JSONinfication with echo-handler.\n    const typeRef = core.getType();\n\n    const data = serializeEchoData(core.getDecoded(['data']));\n    const meta = serializeEchoData(core.getDecoded(['meta']));\n\n    return stripUndefined({\n      '@id': core.id,\n      '@type': typeRef ? encodeReference(typeRef) : undefined,\n      ...data,\n      '@version': Serializer.version,\n      '@meta': meta,\n      '@timestamp': new Date().toISOString(),\n    });\n  }\n\n  private _importObject(database: EchoDatabase, object: SerializedObject): void {\n    const { '@id': id, '@type': type, '@deleted': deleted, '@meta': meta, ...data } = object;\n    const dataProperties = Object.fromEntries(Object.entries(data).filter(([key]) => !key.startsWith('@')));\n    const decodedData = deepMapValues(dataProperties, (value, recurse) => {\n      if (isEncodedReferenceJSON(value)) {\n        return decodeReferenceJSON(value);\n      } else {\n        return recurse(value);\n      }\n    });\n\n    const core = new ObjectCore();\n    core.id = id;\n    // TODO(dmaretskyi): Can't pass type in opts.\n    core.initNewObject(decodedData, {\n      meta,\n    });\n    core.setType(decodeReferenceJSON(type)!);\n    if (deleted) {\n      core.setDeleted(deleted);\n    }\n\n    database.coreDatabase.addCore(core);\n  }\n}\n\nconst isEncodedReferenceJSON = (value: any): boolean =>\n  typeof value === 'object' && value !== null && ('/' in value || value['@type'] === LEGACY_REFERENCE_TYPE_TAG);\n\nexport const decodeReferenceJSON = (encoded?: EncodedReference | string): Reference | undefined => {\n  if (typeof encoded === 'object' && encoded !== null && '/' in encoded) {\n    return decodeReference(encoded);\n  } else if (typeof encoded === 'string') {\n    // TODO(mykola): Never reached?\n    return Reference.fromLegacyTypename(encoded);\n  }\n};\n\nconst chunkArray = <T>(arr: T[], chunkSize: number): T[][] => {\n  if (arr.length === 0 || chunkSize < 1) {\n    return [];\n  }\n\n  let index = 0;\n  let resIndex = 0;\n  const result = new Array(Math.ceil(arr.length / chunkSize));\n  while (index < arr.length) {\n    result[resIndex++] = arr.slice(index, (index += chunkSize));\n  }\n\n  return result;\n};\n\nconst serializeEchoData = (data: any): any =>\n  deepMapValues(data, (value, recurse) => {\n    if (value instanceof Reference) {\n      return encodeReference(value);\n    }\n    return recurse(value);\n  });\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { type EncodedReference } from '@dxos/echo-protocol';\nimport { deepMapValuesAsync } from '@dxos/util';\n\n/**\n * Archive of echo objects.\n *\n * ## Encoding and file format\n *\n * The data is serialized to JSON.\n * Preferred file extensions are `.dx.json`.\n * The file might be compressed with gzip (`.dx.json.gz`).\n */\nexport type SerializedSpace = {\n  /**\n   * Format version number.\n   *\n   * Current version: 1.\n   */\n  version: number;\n\n  /**\n   * Human-readable date of creation.\n   */\n  timestamp?: string;\n\n  /**\n   * Space key.\n   */\n  // TODO(mykola): Maybe remove this?\n  spaceKey?: string;\n\n  /**\n   * List of objects included in the archive.\n   */\n  objects: SerializedObject[];\n};\n\nexport type SerializedObject = {\n  /**\n   * Format version number.\n   *\n   * Current version: 1.\n   */\n  '@version': number;\n\n  /**\n   * Human-readable date of creation.\n   */\n  '@timestamp'?: string;\n\n  /**\n   * Unique object identifier.\n   */\n  '@id': string;\n\n  /**\n   * Reference to a type.\n   */\n  '@type'?: EncodedReference | string;\n\n  /**\n   * Flag to indicate soft-deleted objects.\n   */\n  '@deleted'?: boolean;\n\n  /**\n   * @deprecated\n   *\n   * Model name for the objects backed by a legacy ECHO model.\n   */\n  '@model'?: string;\n} & Record<string, any>;\n\n/**\n * Updates the serialized object data to the latest version.\n */\nexport const normalizeSerializedObjectData = async (data: SerializedObject): Promise<SerializedObject> => {\n  data = await deepMapValuesAsync(data, async (value, recurse) => {\n    return recurse(value);\n  });\n\n  if (data['@timestamp']) {\n    data['@timestamp'] = new Date(data['@timestamp']).toISOString();\n  }\n\n  return data;\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { next as A } from '@automerge/automerge';\n\nimport { type BaseObject } from '@dxos/echo-schema';\nimport { invariant } from '@dxos/invariant';\nimport { isLiveObject } from '@dxos/live-object';\nimport { get } from '@dxos/util';\n\nimport { type KeyPath, type DocAccessor, isValidKeyPath } from './core-db';\nimport { type AnyLiveObject, createDocAccessor } from './echo-handler';\n\n// TODO(burdon): Handle assoc to associate with a previous character.\nexport const toCursor = (accessor: DocAccessor, pos: number, assoc = 0): A.Cursor => {\n  const doc = accessor.handle.doc();\n  if (!doc) {\n    return '';\n  }\n\n  const value = get(doc, accessor.path);\n  if (typeof value === 'string' && value.length <= pos) {\n    return 'end';\n  }\n\n  // NOTE: Slice is needed because getCursor mutates the array.\n  return A.getCursor(doc, accessor.path.slice(), pos);\n};\n\nexport const toCursorRange = (accessor: DocAccessor, start: number, end: number) => {\n  return `${toCursor(accessor, start)}:${toCursor(accessor, end)}`;\n};\n\nexport const fromCursor = (accessor: DocAccessor, cursor: A.Cursor): number => {\n  if (cursor === '') {\n    return 0;\n  }\n\n  const doc = accessor.handle.doc();\n  if (!doc) {\n    return 0;\n  }\n\n  if (cursor === 'end') {\n    const value = get(doc, accessor.path);\n    if (typeof value === 'string') {\n      return value.length;\n    } else {\n      return 0;\n    }\n  }\n\n  // NOTE: Slice is needed because getCursor mutates the array.\n  return A.getCursorPosition(doc, accessor.path.slice(), cursor);\n};\n\n/**\n * Return the text value between two cursor positions.\n */\nexport const getTextInRange = (accessor: DocAccessor, start: string, end: string): string | undefined => {\n  const doc = accessor.handle.doc();\n  const value = get(doc, accessor.path);\n  if (typeof value === 'string') {\n    const beginIdx = fromCursor(accessor, start);\n    const endIdx = fromCursor(accessor, end);\n    if (beginIdx <= value.length) {\n      return value.slice(beginIdx, endIdx);\n    }\n  }\n};\n\nexport const getRangeFromCursor = (accessor: DocAccessor, cursor: string) => {\n  const [start, end] = cursor.split(':');\n  if (start === undefined || end === undefined) {\n    return undefined;\n  }\n\n  return { start: fromCursor(accessor, start), end: fromCursor(accessor, end) };\n};\n\n/**\n * Helper that updates the text value at the given path. Caller must ensure the path is valid.\n * @param obj - The object to update.\n * @param path - The path to the text value to update.\n * @param newText - The new text value.\n * @returns The updated object.\n */\nexport const updateText = <T extends BaseObject>(\n  obj: AnyLiveObject<T>,\n  path: KeyPath,\n  newText: string,\n): AnyLiveObject<T> => {\n  invariant(isLiveObject(obj));\n  invariant(path === undefined || isValidKeyPath(path));\n  const accessor = createDocAccessor(obj, path);\n  accessor.handle.change((doc) => {\n    A.updateText(doc, accessor.path.slice(), newText);\n  });\n  return obj;\n};\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { type JsonML } from '@dxos/debug';\nimport { objectData } from '@dxos/live-object';\n\n// TODO(dmaretskyi): Fix those to work with the new reactive API.\n\nconst idStyle = { style: 'color: #777' };\nconst listStyle = {\n  style: 'list-style-type: none; padding: 0; margin: 0 0 0 12px; font-style: normal; position: relative',\n};\nconst liStyle = { style: 'min-height: 16px;' };\nconst nestedObjectContainerStyle = { style: 'margin: -2px 0 0; display: inline-flex' };\nconst keyStyle = { style: 'color: #881391' };\nconst defaultValueKeyStyle = { style: 'color: #777' };\nconst alteredValueKeyStyle = { style: 'color: #881391; font-weight: bolder' };\nconst nullStyle = { style: 'color: #777' };\n\nconst defaultKeys = ['id', '__typename', '__schema', 'meta'];\n\nexport const getHeader = (obj: any /* TypedObject */, config?: any): JsonML => {\n  return [\n    'span',\n    {\n      style: (config?.nested ? 'padding: 2px 0 0;' : '') + '\\n height: 18px;',\n    },\n    `${obj[Symbol.toStringTag]}`,\n    ['span', idStyle, `#${obj.id}`],\n  ];\n};\n\nconst formatValue = (object: any, config?: any): JsonML => {\n  if (typeof object === 'undefined') {\n    return ['span', nullStyle, 'undefined'];\n  } else if (object === 'null') {\n    return ['span', nullStyle, 'null'];\n  } else {\n    return ['span', nestedObjectContainerStyle, ['object', { object, config }]];\n  }\n};\n\nexport const getBody = (obj: any /* TypedObject */): JsonML => {\n  const objData = obj[objectData];\n  return [\n    'ol',\n    listStyle,\n    ...Object.keys(objData).map(\n      (key): JsonML => [\n        'li',\n        liStyle,\n        [\n          'span',\n          defaultKeys.includes(key) ? keyStyle : key.startsWith('[[') ? defaultValueKeyStyle : alteredValueKeyStyle,\n          key,\n        ],\n        ['span', {}, ': '],\n        formatValue(objData[key], { nested: true }),\n      ],\n    ),\n  ];\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { type Doc, next as am } from '@automerge/automerge';\n\nimport { invariant } from '@dxos/invariant';\nimport { log } from '@dxos/log';\n\n/**\n * This function will clone the source document while preserving history and then patch it in one change so it matches the target data.\n */\nexport const migrateDocument = <T>(source: Doc<any>, targetData: T): Doc<T> => {\n  log('begin migration', { source, targetData });\n\n  const clonedDoc = am.clone(source);\n\n  const changedDoc = am.change(clonedDoc, (applyTo) => {\n    const coalesce = (applyTo: any, targetData: any) => {\n      invariant(typeof applyTo === 'object' && applyTo !== null);\n      invariant(typeof targetData === 'object' && targetData !== null);\n\n      // Recursively coalesce objects\n      for (const key in targetData) {\n        if (targetData[key] !== applyTo[key]) {\n          if (typeof targetData[key] === 'object' && targetData[key] !== null) {\n            if (Array.isArray(targetData[key]) && !Array.isArray(applyTo[key])) {\n              applyTo[key] = [];\n            } else if (typeof applyTo[key] !== 'object' || applyTo[key] === null) {\n              applyTo[key] = {};\n            }\n            coalesce(applyTo[key], targetData[key]);\n          } else {\n            // TODO(dmaretskyi): It's possible to provide a special case for string migrations with `am.updateText`.\n            applyTo[key] = targetData[key];\n          }\n        }\n      }\n\n      // Delete extra keys\n      for (const key in applyTo) {\n        if (!(key in targetData)) {\n          delete applyTo[key];\n        }\n      }\n    };\n\n    coalesce(applyTo, targetData);\n  });\n\n  log('end migration', { changedDoc });\n\n  return changedDoc;\n};\n"],
  "mappings": "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",
  "names": ["import_util", "import_invariant", "import_live_object", "import_automerge", "MAX_LOAD_OBJECT_CHUNK_SIZE", "LEGACY_REFERENCE_TYPE_TAG", "Serializer", "version", "export", "database", "ids", "coreDatabase", "getAllObjectIds", "loadedObjects", "chunk", "chunkArray", "objects", "query", "Filter", "run", "timeout", "push", "data", "filter", "isNonNullable", "map", "object", "exportObject", "timestamp", "Date", "toISOString", "spaceKey", "toHex", "import", "opts", "invariant", "shouldImport", "onObject", "_importObject", "flush", "core", "getObjectCore", "typeRef", "getType", "serializeEchoData", "getDecoded", "meta", "stripUndefined", "id", "encodeReference", "undefined", "type", "deleted", "dataProperties", "Object", "fromEntries", "entries", "key", "startsWith", "decodedData", "deepMapValues", "value", "recurse", "isEncodedReferenceJSON", "decodeReferenceJSON", "ObjectCore", "initNewObject", "setType", "setDeleted", "addCore", "encoded", "decodeReference", "Reference", "fromLegacyTypename", "arr", "chunkSize", "length", "index", "resIndex", "result", "Array", "Math", "ceil", "slice", "normalizeSerializedObjectData", "deepMapValuesAsync", "toCursor", "accessor", "pos", "assoc", "doc", "handle", "get", "path", "A", "getCursor", "toCursorRange", "start", "end", "fromCursor", "cursor", "getCursorPosition", "getTextInRange", "beginIdx", "endIdx", "getRangeFromCursor", "split", "updateText", "obj", "newText", "isLiveObject", "isValidKeyPath", "createDocAccessor", "change", "idStyle", "style", "listStyle", "liStyle", "nestedObjectContainerStyle", "keyStyle", "defaultValueKeyStyle", "alteredValueKeyStyle", "nullStyle", "defaultKeys", "getHeader", "config", "nested", "Symbol", "toStringTag", "formatValue", "getBody", "objData", "objectData", "keys", "includes", "migrateDocument", "source", "targetData", "log", "clonedDoc", "am", "clone", "changedDoc", "applyTo", "coalesce", "isArray"]
}
