import "@dxos/node-std/globals";
import import$sodium_universal from 'sodium-universal';
import import$_dxos_node_std_events from '@dxos/node-std/events';
import * as import$sodium_universal_memory from 'sodium-universal/memory';
import * as import$sodium_universal_crypto_aead from 'sodium-universal/crypto_aead';
import * as import$sodium_universal_helpers from 'sodium-universal/helpers';
import * as import$sodium_universal_crypto_generichash from 'sodium-universal/crypto_generichash';
import * as import$sodium_universal_crypto_kx from 'sodium-universal/crypto_kx';
import * as import$sodium_universal_crypto_scalarmult from 'sodium-universal/crypto_scalarmult';
import * as import$streamx from 'streamx';
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/.pnpm/last-one-wins@1.0.4/node_modules/last-one-wins/index.js
var require_last_one_wins = __commonJS({
  "node_modules/.pnpm/last-one-wins@1.0.4/node_modules/last-one-wins/index.js"(exports, module) {
    module.exports = function(work) {
      var pending = null;
      var callback = null;
      var callbacks = null;
      var next = null;
      return function(val2, cb) {
        next = val2;
        update(cb || noop);
      };
      function update(cb) {
        if (callback) {
          if (!pending) pending = [];
          pending.push(cb);
          return;
        }
        var val2 = next;
        next = null;
        callback = cb;
        work(val2, done);
      }
      function done(err) {
        var cb = callback;
        var cbs = callbacks;
        callbacks = null;
        callback = null;
        if (pending) {
          callbacks = pending;
          pending = null;
          update(noop);
        }
        if (cbs) {
          for (var i = 0; i < cbs.length; i++) cbs[i](err);
        }
        cb(err);
      }
    };
    function noop(_) {
    }
  }
});

// node_modules/.pnpm/unordered-array-remove@1.0.2/node_modules/unordered-array-remove/index.js
var require_unordered_array_remove = __commonJS({
  "node_modules/.pnpm/unordered-array-remove@1.0.2/node_modules/unordered-array-remove/index.js"(exports, module) {
    module.exports = remove;
    function remove(arr, i) {
      if (i >= arr.length || i < 0) return;
      var last = arr.pop();
      if (i < arr.length) {
        var tmp = arr[i];
        arr[i] = last;
        return tmp;
      }
      return last;
    }
  }
});

// node_modules/.pnpm/unordered-set@2.0.1/node_modules/unordered-set/index.js
var require_unordered_set = __commonJS({
  "node_modules/.pnpm/unordered-set@2.0.1/node_modules/unordered-set/index.js"(exports) {
    exports.add = add;
    exports.has = has;
    exports.remove = remove;
    exports.swap = swap;
    function add(list, item) {
      if (has(list, item)) return item;
      item._index = list.length;
      list.push(item);
      return item;
    }
    function has(list, item) {
      return item._index < list.length && list[item._index] === item;
    }
    function remove(list, item) {
      if (!has(list, item)) return null;
      var last = list.pop();
      if (last !== item) {
        list[item._index] = last;
        last._index = item._index;
      }
      return item;
    }
    function swap(list, a, b) {
      if (!has(list, a) || !has(list, b)) return;
      var tmp = a._index;
      a._index = b._index;
      list[a._index] = a;
      b._index = tmp;
      list[b._index] = b;
    }
  }
});

// node_modules/.pnpm/flat-tree@1.9.0/node_modules/flat-tree/index.js
var require_flat_tree = __commonJS({
  "node_modules/.pnpm/flat-tree@1.9.0/node_modules/flat-tree/index.js"(exports) {
    exports.fullRoots = function(index, result) {
      if (index & 1) throw new Error("You can only look up roots for depth(0) blocks");
      if (!result) result = [];
      index /= 2;
      var offset = 0;
      var factor = 1;
      while (true) {
        if (!index) return result;
        while (factor * 2 <= index) factor *= 2;
        result.push(offset + factor - 1);
        offset = offset + 2 * factor;
        index -= factor;
        factor = 1;
      }
    };
    exports.depth = function(index) {
      var depth = 0;
      index += 1;
      while (!(index & 1)) {
        depth++;
        index = rightShift(index);
      }
      return depth;
    };
    exports.sibling = function(index, depth) {
      if (!depth) depth = exports.depth(index);
      var offset = exports.offset(index, depth);
      return exports.index(depth, offset & 1 ? offset - 1 : offset + 1);
    };
    exports.parent = function(index, depth) {
      if (!depth) depth = exports.depth(index);
      var offset = exports.offset(index, depth);
      return exports.index(depth + 1, rightShift(offset));
    };
    exports.leftChild = function(index, depth) {
      if (!(index & 1)) return -1;
      if (!depth) depth = exports.depth(index);
      return exports.index(depth - 1, exports.offset(index, depth) * 2);
    };
    exports.rightChild = function(index, depth) {
      if (!(index & 1)) return -1;
      if (!depth) depth = exports.depth(index);
      return exports.index(depth - 1, 1 + exports.offset(index, depth) * 2);
    };
    exports.children = function(index, depth) {
      if (!(index & 1)) return null;
      if (!depth) depth = exports.depth(index);
      var offset = exports.offset(index, depth) * 2;
      return [
        exports.index(depth - 1, offset),
        exports.index(depth - 1, offset + 1)
      ];
    };
    exports.leftSpan = function(index, depth) {
      if (!(index & 1)) return index;
      if (!depth) depth = exports.depth(index);
      return exports.offset(index, depth) * twoPow(depth + 1);
    };
    exports.rightSpan = function(index, depth) {
      if (!(index & 1)) return index;
      if (!depth) depth = exports.depth(index);
      return (exports.offset(index, depth) + 1) * twoPow(depth + 1) - 2;
    };
    exports.count = function(index, depth) {
      if (!(index & 1)) return 1;
      if (!depth) depth = exports.depth(index);
      return twoPow(depth + 1) - 1;
    };
    exports.countLeaves = function(index) {
      return (exports.count(index) + 1) / 2;
    };
    exports.spans = function(index, depth) {
      if (!(index & 1)) return [index, index];
      if (!depth) depth = exports.depth(index);
      var offset = exports.offset(index, depth);
      var width = twoPow(depth + 1);
      return [offset * width, (offset + 1) * width - 2];
    };
    exports.index = function(depth, offset) {
      return (1 + 2 * offset) * twoPow(depth) - 1;
    };
    exports.offset = function(index, depth) {
      if (!(index & 1)) return index / 2;
      if (!depth) depth = exports.depth(index);
      return ((index + 1) / twoPow(depth) - 1) / 2;
    };
    exports.iterator = function(index) {
      var ite = new Iterator();
      ite.seek(index || 0);
      return ite;
    };
    function twoPow(n) {
      return n < 31 ? 1 << n : (1 << 30) * (1 << n - 30);
    }
    function rightShift(n) {
      return (n - (n & 1)) / 2;
    }
    function Iterator() {
      this.index = 0;
      this.offset = 0;
      this.factor = 0;
    }
    Iterator.prototype.seek = function(index) {
      this.index = index;
      if (this.index & 1) {
        this.offset = exports.offset(index);
        this.factor = twoPow(exports.depth(index) + 1);
      } else {
        this.offset = index / 2;
        this.factor = 2;
      }
    };
    Iterator.prototype.isLeft = function() {
      return (this.offset & 1) === 0;
    };
    Iterator.prototype.isRight = function() {
      return (this.offset & 1) === 1;
    };
    Iterator.prototype.contains = function(index) {
      return index > this.index ? index < this.index + this.factor / 2 : index < this.index ? index > this.index - this.factor / 2 : true;
    };
    Iterator.prototype.prev = function() {
      if (!this.offset) return this.index;
      this.offset--;
      this.index -= this.factor;
      return this.index;
    };
    Iterator.prototype.next = function() {
      this.offset++;
      this.index += this.factor;
      return this.index;
    };
    Iterator.prototype.count = function() {
      if (!(this.index & 1)) return 1;
      return this.factor - 1;
    };
    Iterator.prototype.countLeaves = function() {
      return (this.count() + 1) / 2;
    };
    Iterator.prototype.sibling = function() {
      return this.isLeft() ? this.next() : this.prev();
    };
    Iterator.prototype.parent = function() {
      if (this.offset & 1) {
        this.index -= this.factor / 2;
        this.offset = (this.offset - 1) / 2;
      } else {
        this.index += this.factor / 2;
        this.offset /= 2;
      }
      this.factor *= 2;
      return this.index;
    };
    Iterator.prototype.leftSpan = function() {
      this.index = this.index - this.factor / 2 + 1;
      this.offset = this.index / 2;
      this.factor = 2;
      return this.index;
    };
    Iterator.prototype.rightSpan = function() {
      this.index = this.index + this.factor / 2 - 1;
      this.offset = this.index / 2;
      this.factor = 2;
      return this.index;
    };
    Iterator.prototype.leftChild = function() {
      if (this.factor === 2) return this.index;
      this.factor /= 2;
      this.index -= this.factor / 2;
      this.offset *= 2;
      return this.index;
    };
    Iterator.prototype.rightChild = function() {
      if (this.factor === 2) return this.index;
      this.factor /= 2;
      this.index += this.factor / 2;
      this.offset = 2 * this.offset + 1;
      return this.index;
    };
    Iterator.prototype.nextTree = function() {
      this.index = this.index + this.factor / 2 + 1;
      this.offset = this.index / 2;
      this.factor = 2;
      return this.index;
    };
    Iterator.prototype.prevTree = function() {
      if (!this.offset) {
        this.index = 0;
        this.factor = 2;
      } else {
        this.index = this.index - this.factor / 2 - 1;
        this.offset = this.index / 2;
        this.factor = 2;
      }
      return this.index;
    };
    Iterator.prototype.fullRoot = function(index) {
      if (index <= this.index || (this.index & 1) > 0) return false;
      while (index > this.index + this.factor + this.factor / 2) {
        this.index += this.factor / 2;
        this.factor *= 2;
        this.offset /= 2;
      }
      return true;
    };
  }
});

// node_modules/.pnpm/merkle-tree-stream@4.0.0/node_modules/merkle-tree-stream/generator.js
var require_generator = __commonJS({
  "node_modules/.pnpm/merkle-tree-stream@4.0.0/node_modules/merkle-tree-stream/generator.js"(exports, module) {
    var flat = require_flat_tree();
    module.exports = class MerkleGenerator {
      constructor(opts, roots) {
        if (!opts || !opts.leaf || !opts.parent) throw new Error("opts.leaf and opts.parent required");
        this.roots = roots || opts.roots || [];
        this.blocks = this.roots.length ? 1 + flat.rightSpan(this.roots[this.roots.length - 1].index) / 2 : 0;
        for (var i = 0; i < this.roots.length; i++) {
          var r = this.roots[i];
          if (r && !r.parent) r.parent = flat.parent(r.index);
        }
        this._leaf = opts.leaf;
        this._parent = opts.parent;
      }
      next(data, nodes) {
        if (!Buffer.isBuffer(data)) data = Buffer.from(data);
        if (!nodes) nodes = [];
        var index = 2 * this.blocks++;
        var leaf = {
          index,
          parent: flat.parent(index),
          hash: null,
          size: data.length,
          data
        };
        leaf.hash = this._leaf(leaf, this.roots);
        this.roots.push(leaf);
        nodes.push(leaf);
        while (this.roots.length > 1) {
          var left = this.roots[this.roots.length - 2];
          var right = this.roots[this.roots.length - 1];
          if (left.parent !== right.parent) break;
          this.roots.pop();
          this.roots[this.roots.length - 1] = leaf = {
            index: left.parent,
            parent: flat.parent(left.parent),
            hash: this._parent(left, right),
            size: left.size + right.size,
            data: null
          };
          nodes.push(leaf);
        }
        return nodes;
      }
    };
  }
});

// node_modules/.pnpm/codecs@2.2.0/node_modules/codecs/index.js
var require_codecs = __commonJS({
  "node_modules/.pnpm/codecs@2.2.0/node_modules/codecs/index.js"(exports, module) {
    module.exports = codecs;
    codecs.ascii = createString("ascii");
    codecs.utf8 = createString("utf-8");
    codecs.hex = createString("hex");
    codecs.base64 = createString("base64");
    codecs.ucs2 = createString("ucs2");
    codecs.utf16le = createString("utf16le");
    codecs.ndjson = createJSON(true);
    codecs.json = createJSON(false);
    codecs.binary = {
      name: "binary",
      encode: function encodeBinary(obj) {
        return typeof obj === "string" ? Buffer.from(obj, "utf-8") : Buffer.isBuffer(obj) ? obj : Buffer.from(obj.buffer, obj.byteOffset, obj.byteLength);
      },
      decode: function decodeBinary(buf) {
        return Buffer.isBuffer(buf) ? buf : Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
      }
    };
    function codecs(fmt, fallback) {
      if (typeof fmt === "object" && fmt && fmt.encode && fmt.decode) return fmt;
      switch (fmt) {
        case "ndjson":
          return codecs.ndjson;
        case "json":
          return codecs.json;
        case "ascii":
          return codecs.ascii;
        case "utf-8":
        case "utf8":
          return codecs.utf8;
        case "hex":
          return codecs.hex;
        case "base64":
          return codecs.base64;
        case "ucs-2":
        case "ucs2":
          return codecs.ucs2;
        case "utf16-le":
        case "utf16le":
          return codecs.utf16le;
      }
      return fallback !== void 0 ? fallback : codecs.binary;
    }
    function createJSON(newline) {
      return {
        name: newline ? "ndjson" : "json",
        encode: newline ? encodeNDJSON : encodeJSON,
        decode: function decodeJSON(buf) {
          return JSON.parse(buf.toString());
        }
      };
      function encodeJSON(val2) {
        return Buffer.from(JSON.stringify(val2));
      }
      function encodeNDJSON(val2) {
        return Buffer.from(JSON.stringify(val2) + "\n");
      }
    }
    function createString(type) {
      return {
        name: type,
        encode: function encodeString(val2) {
          if (typeof val2 !== "string") val2 = val2.toString();
          return Buffer.from(val2, type);
        },
        decode: function decodeString(buf) {
          return buf.toString(type);
        }
      };
    }
  }
});

// node_modules/.pnpm/atomic-batcher@1.0.2/node_modules/atomic-batcher/index.js
var require_atomic_batcher = __commonJS({
  "node_modules/.pnpm/atomic-batcher@1.0.2/node_modules/atomic-batcher/index.js"(exports, module) {
    module.exports = batcher;
    function batcher(run) {
      var running = false;
      var pendingBatch = null;
      var pendingCallbacks = null;
      var callbacks = null;
      return append;
      function done(err) {
        if (callbacks) callAll(callbacks, err);
        running = false;
        callbacks = pendingCallbacks;
        var nextBatch = pendingBatch;
        pendingBatch = null;
        pendingCallbacks = null;
        if (!nextBatch || !nextBatch.length) {
          if (!callbacks || !callbacks.length) {
            callbacks = null;
            return;
          }
          if (!nextBatch) nextBatch = [];
        }
        running = true;
        run(nextBatch, done);
      }
      function append(val2, cb) {
        if (running) {
          if (!pendingBatch) {
            pendingBatch = [];
            pendingCallbacks = [];
          }
          pushAll(pendingBatch, val2);
          if (cb) pendingCallbacks.push(cb);
        } else {
          if (cb) callbacks = [cb];
          running = true;
          run(Array.isArray(val2) ? val2 : [val2], done);
        }
      }
    }
    function pushAll(list, val2) {
      if (Array.isArray(val2)) pushArray(list, val2);
      else list.push(val2);
    }
    function pushArray(list, val2) {
      for (var i = 0; i < val2.length; i++) list.push(val2[i]);
    }
    function callAll(list, err) {
      for (var i = 0; i < list.length; i++) list[i](err);
    }
  }
});

// node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js"(exports, module) {
    if (typeof Object.create === "function") {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/.pnpm/varint@4.0.1/node_modules/varint/encode.js
var require_encode = __commonJS({
  "node_modules/.pnpm/varint@4.0.1/node_modules/varint/encode.js"(exports, module) {
    module.exports = encode;
    var MSB = 128;
    var REST = 127;
    var MSBALL = ~REST;
    var INT = Math.pow(2, 31);
    function encode(num, out, offset) {
      out = out || [];
      offset = offset || 0;
      var oldOffset = offset;
      while (num >= INT) {
        out[offset++] = num & 255 | MSB;
        num /= 128;
      }
      while (num & MSBALL) {
        out[offset++] = num & 255 | MSB;
        num >>>= 7;
      }
      out[offset] = num | 0;
      encode.bytes = offset - oldOffset + 1;
      return out;
    }
  }
});

// node_modules/.pnpm/varint@4.0.1/node_modules/varint/decode.js
var require_decode = __commonJS({
  "node_modules/.pnpm/varint@4.0.1/node_modules/varint/decode.js"(exports, module) {
    module.exports = read;
    var MSB = 128;
    var REST = 127;
    function read(buf, offset) {
      var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
      do {
        if (counter >= l) {
          read.bytes = 0;
          read.bytesRead = 0;
          return void 0;
        }
        b = buf[counter++];
        res += shift < 28 ? (b & REST) << shift : (b & REST) * Math.pow(2, shift);
        shift += 7;
      } while (b >= MSB);
      read.bytes = counter - offset;
      return res;
    }
  }
});

// node_modules/.pnpm/varint@4.0.1/node_modules/varint/length.js
var require_length = __commonJS({
  "node_modules/.pnpm/varint@4.0.1/node_modules/varint/length.js"(exports, module) {
    var N1 = Math.pow(2, 7);
    var N2 = Math.pow(2, 14);
    var N3 = Math.pow(2, 21);
    var N4 = Math.pow(2, 28);
    var N5 = Math.pow(2, 35);
    var N6 = Math.pow(2, 42);
    var N7 = Math.pow(2, 49);
    var N8 = Math.pow(2, 56);
    var N9 = Math.pow(2, 63);
    module.exports = function(value) {
      return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
    };
  }
});

// node_modules/.pnpm/varint@4.0.1/node_modules/varint/index.js
var require_varint = __commonJS({
  "node_modules/.pnpm/varint@4.0.1/node_modules/varint/index.js"(exports, module) {
    module.exports = {
      encode: require_encode(),
      decode: require_decode(),
      encodingLength: require_length()
    };
  }
});

// node_modules/.pnpm/buffer-alloc-unsafe@1.1.0/node_modules/buffer-alloc-unsafe/index.js
var require_buffer_alloc_unsafe = __commonJS({
  "node_modules/.pnpm/buffer-alloc-unsafe@1.1.0/node_modules/buffer-alloc-unsafe/index.js"(exports, module) {
    function allocUnsafe(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be a number');
      }
      if (size < 0) {
        throw new RangeError('"size" argument must not be negative');
      }
      if (Buffer.allocUnsafe) {
        return Buffer.allocUnsafe(size);
      } else {
        return new Buffer(size);
      }
    }
    module.exports = allocUnsafe;
  }
});

// node_modules/.pnpm/bitfield-rle@2.2.1/node_modules/bitfield-rle/index.js
var require_bitfield_rle = __commonJS({
  "node_modules/.pnpm/bitfield-rle@2.2.1/node_modules/bitfield-rle/index.js"(exports, module) {
    var varint = require_varint();
    var alloc = require_buffer_alloc_unsafe();
    module.exports = align(1);
    function align(n) {
      var exports2 = {};
      exports2.align = align;
      exports2.encode = encode;
      exports2.encode.bytes = 0;
      exports2.encodingLength = encodingLength;
      exports2.decode = decode;
      exports2.decode.bytes = 0;
      exports2.decodingLength = decodingLength;
      return exports2;
      function State(input, output, offset) {
        this.inputOffset = 0;
        this.inputLength = input.length;
        this.input = input;
        this.outputOffset = offset;
        this.output = output;
      }
      function encode(bitfield, buffer, offset) {
        if (!offset) offset = 0;
        if (!buffer) buffer = alloc(encodingLength(bitfield));
        var state = new State(bitfield, buffer, offset);
        rle(state);
        encode.bytes = state.outputOffset - offset;
        return buffer;
      }
      function encodingLength(bitfield) {
        var state = new State(bitfield, null, 0);
        rle(state);
        return state.outputOffset;
      }
      function decode(buffer, offset) {
        if (!offset) offset = 0;
        var bitfield = alloc(decodingLength(buffer, offset));
        var ptr = 0;
        while (offset < buffer.length) {
          var next = varint.decode(buffer, offset);
          var repeat = next & 1;
          var len = repeat ? (next - (next & 3)) / 4 : next / 2;
          offset += varint.decode.bytes;
          if (repeat) {
            bitfield.fill(next & 2 ? 255 : 0, ptr, ptr + len);
          } else {
            buffer.copy(bitfield, ptr, offset, offset + len);
            offset += len;
          }
          ptr += len;
        }
        bitfield.fill(0, ptr);
        decode.bytes = buffer.length - offset;
        return bitfield;
      }
      function decodingLength(buffer, offset) {
        if (!offset) offset = 0;
        var len = 0;
        while (offset < buffer.length) {
          var next = varint.decode(buffer, offset);
          offset += varint.decode.bytes;
          var repeat = next & 1;
          var slice = repeat ? (next - (next & 3)) / 4 : next / 2;
          len += slice;
          if (!repeat) offset += slice;
        }
        if (offset > buffer.length) throw new Error("Invalid RLE bitfield");
        if (len & n - 1) return len + (n - (len & n - 1));
        return len;
      }
      function rle(state) {
        var len = 0;
        var bits = 0;
        var input = state.input;
        while (state.inputLength > 0 && !input[state.inputLength - 1]) state.inputLength--;
        for (var i = 0; i < state.inputLength; i++) {
          if (input[i] === bits) {
            len++;
            continue;
          }
          if (len) encodeUpdate(state, i, len, bits);
          if (input[i] === 0 || input[i] === 255) {
            bits = input[i];
            len = 1;
          } else {
            len = 0;
          }
        }
        if (len) encodeUpdate(state, state.inputLength, len, bits);
        encodeFinal(state);
      }
      function encodeHead(state, end) {
        var headLength = end - state.inputOffset;
        varint.encode(2 * headLength, state.output, state.outputOffset);
        state.outputOffset += varint.encode.bytes;
        state.input.copy(state.output, state.outputOffset, state.inputOffset, end);
        state.outputOffset += headLength;
      }
      function encodeFinal(state) {
        var headLength = state.inputLength - state.inputOffset;
        if (!headLength) return;
        if (!state.output) {
          state.outputOffset += headLength + varint.encodingLength(2 * headLength);
        } else {
          encodeHead(state, state.inputLength);
        }
        state.inputOffset = state.inputLength;
      }
      function encodeUpdate(state, i, len, bit) {
        var headLength = i - len - state.inputOffset;
        var headCost = headLength ? varint.encodingLength(2 * headLength) + headLength : 0;
        var enc = 4 * len + (bit ? 2 : 0) + 1;
        var encCost = headCost + varint.encodingLength(enc);
        var baseCost = varint.encodingLength(2 * (i - state.inputOffset)) + i - state.inputOffset;
        if (encCost >= baseCost) return;
        if (!state.output) {
          state.outputOffset += encCost;
          state.inputOffset = i;
          return;
        }
        if (headLength) encodeHead(state, i - len);
        varint.encode(enc, state.output, state.outputOffset);
        state.outputOffset += varint.encode.bytes;
        state.inputOffset = i;
      }
    }
  }
});

// node_modules/.pnpm/memory-pager@1.5.0/node_modules/memory-pager/index.js
var require_memory_pager = __commonJS({
  "node_modules/.pnpm/memory-pager@1.5.0/node_modules/memory-pager/index.js"(exports, module) {
    module.exports = Pager;
    function Pager(pageSize, opts) {
      if (!(this instanceof Pager)) return new Pager(pageSize, opts);
      this.length = 0;
      this.updates = [];
      this.path = new Uint16Array(4);
      this.pages = new Array(32768);
      this.maxPages = this.pages.length;
      this.level = 0;
      this.pageSize = pageSize || 1024;
      this.deduplicate = opts ? opts.deduplicate : null;
      this.zeros = this.deduplicate ? alloc(this.deduplicate.length) : null;
    }
    Pager.prototype.updated = function(page) {
      while (this.deduplicate && page.buffer[page.deduplicate] === this.deduplicate[page.deduplicate]) {
        page.deduplicate++;
        if (page.deduplicate === this.deduplicate.length) {
          page.deduplicate = 0;
          if (page.buffer.equals && page.buffer.equals(this.deduplicate)) page.buffer = this.deduplicate;
          break;
        }
      }
      if (page.updated || !this.updates) return;
      page.updated = true;
      this.updates.push(page);
    };
    Pager.prototype.lastUpdate = function() {
      if (!this.updates || !this.updates.length) return null;
      var page = this.updates.pop();
      page.updated = false;
      return page;
    };
    Pager.prototype._array = function(i, noAllocate) {
      if (i >= this.maxPages) {
        if (noAllocate) return;
        grow(this, i);
      }
      factor(i, this.path);
      var arr = this.pages;
      for (var j = this.level; j > 0; j--) {
        var p = this.path[j];
        var next = arr[p];
        if (!next) {
          if (noAllocate) return;
          next = arr[p] = new Array(32768);
        }
        arr = next;
      }
      return arr;
    };
    Pager.prototype.get = function(i, noAllocate) {
      var arr = this._array(i, noAllocate);
      var first = this.path[0];
      var page = arr && arr[first];
      if (!page && !noAllocate) {
        page = arr[first] = new Page(i, alloc(this.pageSize));
        if (i >= this.length) this.length = i + 1;
      }
      if (page && page.buffer === this.deduplicate && this.deduplicate && !noAllocate) {
        page.buffer = copy(page.buffer);
        page.deduplicate = 0;
      }
      return page;
    };
    Pager.prototype.set = function(i, buf) {
      var arr = this._array(i, false);
      var first = this.path[0];
      if (i >= this.length) this.length = i + 1;
      if (!buf || this.zeros && buf.equals && buf.equals(this.zeros)) {
        arr[first] = void 0;
        return;
      }
      if (this.deduplicate && buf.equals && buf.equals(this.deduplicate)) {
        buf = this.deduplicate;
      }
      var page = arr[first];
      var b = truncate(buf, this.pageSize);
      if (page) page.buffer = b;
      else arr[first] = new Page(i, b);
    };
    Pager.prototype.toBuffer = function() {
      var list = new Array(this.length);
      var empty = alloc(this.pageSize);
      var ptr = 0;
      while (ptr < list.length) {
        var arr = this._array(ptr, true);
        for (var i = 0; i < 32768 && ptr < list.length; i++) {
          list[ptr++] = arr && arr[i] ? arr[i].buffer : empty;
        }
      }
      return Buffer.concat(list);
    };
    function grow(pager, index) {
      while (pager.maxPages < index) {
        var old = pager.pages;
        pager.pages = new Array(32768);
        pager.pages[0] = old;
        pager.level++;
        pager.maxPages *= 32768;
      }
    }
    function truncate(buf, len) {
      if (buf.length === len) return buf;
      if (buf.length > len) return buf.slice(0, len);
      var cpy = alloc(len);
      buf.copy(cpy);
      return cpy;
    }
    function alloc(size) {
      if (Buffer.alloc) return Buffer.alloc(size);
      var buf = new Buffer(size);
      buf.fill(0);
      return buf;
    }
    function copy(buf) {
      var cpy = Buffer.allocUnsafe ? Buffer.allocUnsafe(buf.length) : new Buffer(buf.length);
      buf.copy(cpy);
      return cpy;
    }
    function Page(i, buf) {
      this.offset = i * buf.length;
      this.buffer = buf;
      this.updated = false;
      this.deduplicate = 0;
    }
    function factor(n, out) {
      n = (n - (out[0] = n & 32767)) / 32768;
      n = (n - (out[1] = n & 32767)) / 32768;
      out[3] = (n - (out[2] = n & 32767)) / 32768 & 32767;
    }
  }
});

// node_modules/.pnpm/sparse-bitfield@3.0.3/node_modules/sparse-bitfield/index.js
var require_sparse_bitfield = __commonJS({
  "node_modules/.pnpm/sparse-bitfield@3.0.3/node_modules/sparse-bitfield/index.js"(exports, module) {
    var pager = require_memory_pager();
    module.exports = Bitfield;
    function Bitfield(opts) {
      if (!(this instanceof Bitfield)) return new Bitfield(opts);
      if (!opts) opts = {};
      if (Buffer.isBuffer(opts)) opts = { buffer: opts };
      this.pageOffset = opts.pageOffset || 0;
      this.pageSize = opts.pageSize || 1024;
      this.pages = opts.pages || pager(this.pageSize);
      this.byteLength = this.pages.length * this.pageSize;
      this.length = 8 * this.byteLength;
      if (!powerOfTwo(this.pageSize)) throw new Error("The page size should be a power of two");
      this._trackUpdates = !!opts.trackUpdates;
      this._pageMask = this.pageSize - 1;
      if (opts.buffer) {
        for (var i = 0; i < opts.buffer.length; i += this.pageSize) {
          this.pages.set(i / this.pageSize, opts.buffer.slice(i, i + this.pageSize));
        }
        this.byteLength = opts.buffer.length;
        this.length = 8 * this.byteLength;
      }
    }
    Bitfield.prototype.get = function(i) {
      var o = i & 7;
      var j = (i - o) / 8;
      return !!(this.getByte(j) & 128 >> o);
    };
    Bitfield.prototype.getByte = function(i) {
      var o = i & this._pageMask;
      var j = (i - o) / this.pageSize;
      var page = this.pages.get(j, true);
      return page ? page.buffer[o + this.pageOffset] : 0;
    };
    Bitfield.prototype.set = function(i, v) {
      var o = i & 7;
      var j = (i - o) / 8;
      var b = this.getByte(j);
      return this.setByte(j, v ? b | 128 >> o : b & (255 ^ 128 >> o));
    };
    Bitfield.prototype.toBuffer = function() {
      var all = alloc(this.pages.length * this.pageSize);
      for (var i = 0; i < this.pages.length; i++) {
        var next = this.pages.get(i, true);
        var allOffset = i * this.pageSize;
        if (next) next.buffer.copy(all, allOffset, this.pageOffset, this.pageOffset + this.pageSize);
      }
      return all;
    };
    Bitfield.prototype.setByte = function(i, b) {
      var o = i & this._pageMask;
      var j = (i - o) / this.pageSize;
      var page = this.pages.get(j, false);
      o += this.pageOffset;
      if (page.buffer[o] === b) return false;
      page.buffer[o] = b;
      if (i >= this.byteLength) {
        this.byteLength = i + 1;
        this.length = this.byteLength * 8;
      }
      if (this._trackUpdates) this.pages.updated(page);
      return true;
    };
    function alloc(n) {
      if (Buffer.alloc) return Buffer.alloc(n);
      var b = new Buffer(n);
      b.fill(0);
      return b;
    }
    function powerOfTwo(x) {
      return !(x & x - 1);
    }
  }
});

// node_modules/.pnpm/hypercore@9.12.0/node_modules/hypercore/lib/bitfield.js
var require_bitfield = __commonJS({
  "node_modules/.pnpm/hypercore@9.12.0/node_modules/hypercore/lib/bitfield.js"(exports, module) {
    var flat = require_flat_tree();
    var rle = require_bitfield_rle();
    var pager = require_memory_pager();
    var bitfield = require_sparse_bitfield();
    var INDEX_UPDATE_MASK = [63, 207, 243, 252];
    var INDEX_ITERATE_MASK = [0, 192, 240, 252];
    var DATA_ITERATE_MASK = [128, 192, 224, 240, 248, 252, 254, 255];
    var DATA_UPDATE_MASK = [127, 191, 223, 239, 247, 251, 253, 254];
    var MAP_PARENT_RIGHT = new Array(256);
    var MAP_PARENT_LEFT = new Array(256);
    var NEXT_DATA_0_BIT = new Array(256);
    var NEXT_INDEX_0_BIT = new Array(256);
    var TOTAL_1_BITS = new Array(256);
    for (i = 0; i < 256; i++) {
      a = (i & 15 << 4) >> 4;
      b = i & 15;
      nibble = [0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4];
      MAP_PARENT_RIGHT[i] = (a === 15 ? 3 : a === 0 ? 0 : 1) << 2 | (b === 15 ? 3 : b === 0 ? 0 : 1);
      MAP_PARENT_LEFT[i] = MAP_PARENT_RIGHT[i] << 4;
      NEXT_DATA_0_BIT[i] = i === 255 ? -1 : 8 - Math.ceil(Math.log(256 - i) / Math.log(2));
      NEXT_INDEX_0_BIT[i] = i === 255 ? -1 : Math.floor(NEXT_DATA_0_BIT[i] / 2);
      TOTAL_1_BITS[i] = nibble[i >> 4] + nibble[i & 15];
    }
    var a;
    var b;
    var nibble;
    var i;
    module.exports = Bitfield;
    function Bitfield(pageSize, pages) {
      if (!(this instanceof Bitfield)) return new Bitfield(pageSize, pages);
      if (!pageSize) pageSize = 2048 + 1024 + 512;
      var deduplicate = Buffer.allocUnsafe(pageSize);
      deduplicate.fill(255);
      this.indexSize = pageSize - 2048 - 1024;
      this.pages = pager(pageSize, { deduplicate });
      if (pages) {
        for (var i2 = 0; i2 < pages.length; i2++) {
          this.pages.set(i2, pages[i2]);
        }
      }
      this.data = bitfield({
        pageSize: 1024,
        pageOffset: 0,
        pages: this.pages,
        trackUpdates: true
      });
      this.tree = bitfield({
        pageSize: 2048,
        pageOffset: 1024,
        pages: this.pages,
        trackUpdates: true
      });
      this.index = bitfield({
        pageSize: this.indexSize,
        pageOffset: 1024 + 2048,
        pages: this.pages,
        trackUpdates: true
      });
      this.length = this.data.length;
      this._iterator = flat.iterator(0);
    }
    Bitfield.prototype.set = function(i2, value) {
      var o = i2 & 7;
      i2 = (i2 - o) / 8;
      var v = value ? this.data.getByte(i2) | 128 >> o : this.data.getByte(i2) & DATA_UPDATE_MASK[o];
      if (!this.data.setByte(i2, v)) return false;
      this.length = this.data.length;
      this._setIndex(i2, v);
      return true;
    };
    Bitfield.prototype.get = function(i2) {
      return this.data.get(i2);
    };
    Bitfield.prototype.total = function(start, end) {
      if (!start || start < 0) start = 0;
      if (!end) end = this.data.length;
      if (end < start) return 0;
      if (end > this.data.length) {
        this._expand(end);
      }
      var o = start & 7;
      var e = end & 7;
      var pos = (start - o) / 8;
      var last = (end - e) / 8;
      var leftMask = 255 - (o ? DATA_ITERATE_MASK[o - 1] : 0);
      var rightMask = e ? DATA_ITERATE_MASK[e - 1] : 0;
      var byte = this.data.getByte(pos);
      if (pos === last) {
        return TOTAL_1_BITS[byte & leftMask & rightMask];
      }
      var total = TOTAL_1_BITS[byte & leftMask];
      for (var i2 = pos + 1; i2 < last; i2++) {
        total += TOTAL_1_BITS[this.data.getByte(i2)];
      }
      total += TOTAL_1_BITS[this.data.getByte(last) & rightMask];
      return total;
    };
    Bitfield.prototype.compress = function(start, length) {
      if (!start && !length) return rle.encode(this.data.toBuffer());
      if (start + length > this.length) length = Math.max(1, this.length - start);
      var buf = Buffer.alloc(Math.ceil(length / 8));
      var p = start / this.data.pageSize / 8;
      var end = p + length / this.data.pageSize / 8;
      var offset = p * this.data.pageSize;
      for (; p < end; p++) {
        var page = this.data.pages.get(p, true);
        if (!page || !page.buffer) continue;
        page.buffer.copy(buf, p * this.data.pageSize - offset, this.data.pageOffset, this.data.pageOffset + this.data.pageSize);
      }
      return rle.encode(buf);
    };
    Bitfield.prototype._setIndex = function(i2, value) {
      var o = i2 & 3;
      i2 = (i2 - o) / 4;
      var bitfield2 = this.index;
      var ite = this._iterator;
      var start = 2 * i2;
      var byte = bitfield2.getByte(start) & INDEX_UPDATE_MASK[o] | getIndexValue(value) >> 2 * o;
      var len = bitfield2.length;
      var maxLength = this.pages.length * this.indexSize;
      ite.seek(start);
      while (ite.index < maxLength && bitfield2.setByte(ite.index, byte)) {
        if (ite.isLeft()) {
          byte = MAP_PARENT_LEFT[byte] | MAP_PARENT_RIGHT[bitfield2.getByte(ite.sibling())];
        } else {
          byte = MAP_PARENT_RIGHT[byte] | MAP_PARENT_LEFT[bitfield2.getByte(ite.sibling())];
        }
        ite.parent();
      }
      if (len !== bitfield2.length) this._expand(len);
      return ite.index !== start;
    };
    Bitfield.prototype._expand = function(len) {
      var roots = flat.fullRoots(2 * len);
      var bitfield2 = this.index;
      var ite = this._iterator;
      var byte = 0;
      for (var i2 = 0; i2 < roots.length; i2++) {
        ite.seek(roots[i2]);
        byte = bitfield2.getByte(ite.index);
        do {
          if (ite.isLeft()) {
            byte = MAP_PARENT_LEFT[byte] | MAP_PARENT_RIGHT[bitfield2.getByte(ite.sibling())];
          } else {
            byte = MAP_PARENT_RIGHT[byte] | MAP_PARENT_LEFT[bitfield2.getByte(ite.sibling())];
          }
        } while (setByteNoAlloc(bitfield2, ite.parent(), byte));
      }
    };
    function setByteNoAlloc(bitfield2, i2, b2) {
      if (8 * i2 >= bitfield2.length) return false;
      return bitfield2.setByte(i2, b2);
    }
    Bitfield.prototype.iterator = function(start, end) {
      var ite = new Iterator(this);
      ite.range(start || 0, end || this.length);
      ite.seek(0);
      return ite;
    };
    function Iterator(bitfield2) {
      this.start = 0;
      this.end = 0;
      this._indexEnd = 0;
      this._pos = 0;
      this._byte = 0;
      this._bitfield = bitfield2;
    }
    Iterator.prototype.range = function(start, end) {
      this.start = start;
      this.end = end;
      this._indexEnd = 2 * Math.ceil(end / 32);
      if (this.end > this._bitfield.length) {
        this._bitfield._expand(this.end);
      }
      return this;
    };
    Iterator.prototype.seek = function(offset) {
      offset += this.start;
      if (offset < this.start) offset = this.start;
      if (offset >= this.end) {
        this._pos = -1;
        return this;
      }
      var o = offset & 7;
      this._pos = (offset - o) / 8;
      this._byte = this._bitfield.data.getByte(this._pos) | (o ? DATA_ITERATE_MASK[o - 1] : 0);
      return this;
    };
    Iterator.prototype.random = function() {
      var i2 = this.seek(Math.floor(Math.random() * (this.end - this.start))).next();
      return i2 === -1 ? this.seek(0).next() : i2;
    };
    Iterator.prototype.next = function() {
      if (this._pos === -1) return -1;
      var dataBitfield = this._bitfield.data;
      var free = NEXT_DATA_0_BIT[this._byte];
      while (free === -1) {
        this._byte = dataBitfield.getByte(++this._pos);
        free = NEXT_DATA_0_BIT[this._byte];
        if (free === -1) {
          this._pos = this._skipAhead(this._pos);
          if (this._pos === -1) return -1;
          this._byte = dataBitfield.getByte(this._pos);
          free = NEXT_DATA_0_BIT[this._byte];
        }
      }
      this._byte |= DATA_ITERATE_MASK[free];
      var n = 8 * this._pos + free;
      return n < this.end ? n : -1;
    };
    Iterator.prototype.peek = function() {
      if (this._pos === -1) return -1;
      var free = NEXT_DATA_0_BIT[this._byte];
      var n = 8 * this._pos + free;
      return n < this.end ? n : -1;
    };
    Iterator.prototype._skipAhead = function(start) {
      var indexBitfield = this._bitfield.index;
      var treeEnd = this._indexEnd;
      var ite = this._bitfield._iterator;
      var o = start & 3;
      ite.seek(2 * ((start - o) / 4));
      var treeByte = indexBitfield.getByte(ite.index) | INDEX_ITERATE_MASK[o];
      while (NEXT_INDEX_0_BIT[treeByte] === -1) {
        if (ite.isLeft()) {
          ite.next();
        } else {
          ite.next();
          ite.parent();
        }
        if (rightSpan(ite) >= treeEnd) {
          while (rightSpan(ite) >= treeEnd && isParent(ite)) ite.leftChild();
          if (rightSpan(ite) >= treeEnd) return -1;
        }
        treeByte = indexBitfield.getByte(ite.index);
      }
      while (ite.factor > 2) {
        if (NEXT_INDEX_0_BIT[treeByte] < 2) ite.leftChild();
        else ite.rightChild();
        treeByte = indexBitfield.getByte(ite.index);
      }
      var free = NEXT_INDEX_0_BIT[treeByte];
      if (free === -1) free = 4;
      var next = ite.index * 2 + free;
      return next <= start ? start + 1 : next;
    };
    function rightSpan(ite) {
      return ite.index + ite.factor / 2 - 1;
    }
    function isParent(ite) {
      return ite.index & 1;
    }
    function getIndexValue(n) {
      switch (n) {
        case 255:
          return 192;
        case 0:
          return 0;
        default:
          return 64;
      }
    }
  }
});

// node_modules/.pnpm/hypercore@9.12.0/node_modules/hypercore/lib/tree-index.js
var require_tree_index = __commonJS({
  "node_modules/.pnpm/hypercore@9.12.0/node_modules/hypercore/lib/tree-index.js"(exports, module) {
    var flat = require_flat_tree();
    var bitfield = require_sparse_bitfield();
    module.exports = TreeIndex;
    function TreeIndex(bits) {
      if (!(this instanceof TreeIndex)) return new TreeIndex(bits);
      this.bitfield = bits || bitfield();
    }
    TreeIndex.prototype.proof = function(index, opts) {
      if (!opts) opts = {};
      var nodes = [];
      var remoteTree = opts.tree || new TreeIndex();
      var digest = opts.digest || 0;
      if (!this.get(index)) return null;
      if (opts.hash) nodes.push(index);
      if (digest === 1) return { nodes, verifiedBy: 0 };
      var roots = null;
      var sibling = index;
      var next = index;
      var hasRoot = digest & 1;
      digest = rightShift(digest);
      while (digest) {
        if (digest === 1 && hasRoot) {
          if (this.get(next)) remoteTree.set(next);
          if (flat.sibling(next) < next) next = flat.sibling(next);
          roots = flat.fullRoots(flat.rightSpan(next) + 2);
          for (var i = 0; i < roots.length; i++) {
            if (this.get(roots[i])) remoteTree.set(roots[i]);
          }
          break;
        }
        sibling = flat.sibling(next);
        if (digest & 1) {
          if (this.get(sibling)) remoteTree.set(sibling);
        }
        next = flat.parent(next);
        digest = rightShift(digest);
      }
      next = index;
      while (!remoteTree.get(next)) {
        sibling = flat.sibling(next);
        if (!this.get(sibling)) {
          var verifiedBy = this.verifiedBy(next);
          addFullRoots(verifiedBy, nodes, next, remoteTree);
          return { nodes, verifiedBy };
        } else {
          if (!remoteTree.get(sibling)) nodes.push(sibling);
        }
        next = flat.parent(next);
      }
      return { nodes, verifiedBy: 0 };
    };
    TreeIndex.prototype.digest = function(index) {
      if (this.get(index)) return 1;
      var digest = 0;
      var next = flat.sibling(index);
      var max = Math.max(next + 2, this.bitfield.length);
      var bit = 2;
      var depth = flat.depth(index);
      var parent = flat.parent(next, depth++);
      while (flat.rightSpan(next) < max || flat.leftSpan(parent) > 0) {
        if (this.get(next)) {
          digest += bit;
        }
        if (this.get(parent)) {
          digest += 2 * bit;
          if (!(digest & 1)) digest += 1;
          if (digest + 1 === 4 * bit) return 1;
          return digest;
        }
        next = flat.sibling(parent);
        parent = flat.parent(next, depth++);
        bit *= 2;
      }
      return digest;
    };
    TreeIndex.prototype.blocks = function() {
      var top = 0;
      var next = 0;
      var max = this.bitfield.length;
      while (flat.rightSpan(next) < max) {
        next = flat.parent(next);
        if (this.get(next)) top = next;
      }
      return (this.get(top) ? this.verifiedBy(top) : 0) / 2;
    };
    TreeIndex.prototype.roots = function() {
      return flat.fullRoots(2 * this.blocks());
    };
    TreeIndex.prototype.verifiedBy = function(index, nodes) {
      var hasIndex = this.get(index);
      if (!hasIndex) return 0;
      var depth = flat.depth(index);
      var top = index;
      var parent = flat.parent(top, depth++);
      while (this.get(parent) && this.get(flat.sibling(top))) {
        top = parent;
        parent = flat.parent(top, depth++);
      }
      depth--;
      while (depth) {
        top = flat.leftChild(flat.index(depth, flat.offset(top, depth) + 1), depth);
        depth--;
        while (!this.get(top) && depth) top = flat.leftChild(top, depth--);
        if (nodes && this.get(top)) nodes.push(top);
      }
      return this.get(top) ? top + 2 : top;
    };
    TreeIndex.prototype.get = function(index) {
      return this.bitfield.get(index);
    };
    TreeIndex.prototype.truncate = function(len) {
      const currentLen = 2 * this.blocks();
      const roots = flat.fullRoots(len);
      for (let i = len; i < currentLen; i++) {
        this.bitfield.set(i, false);
      }
      for (const root of roots) {
        let p = flat.parent(root);
        while (p < len) {
          this.bitfield.set(p, false);
          p = flat.parent(p);
        }
      }
    };
    TreeIndex.prototype.set = function(index) {
      if (!this.bitfield.set(index, true)) return false;
      while (this.bitfield.get(flat.sibling(index))) {
        index = flat.parent(index);
        if (!this.bitfield.set(index, true)) break;
      }
      return true;
    };
    function rightShift(n) {
      return (n - (n & 1)) / 2;
    }
    function addFullRoots(verifiedBy, nodes, root, remoteTree) {
      var roots = flat.fullRoots(verifiedBy);
      for (var i = 0; i < roots.length; i++) {
        if (roots[i] !== root && !remoteTree.get(roots[i])) nodes.push(roots[i]);
      }
    }
  }
});

// node_modules/.pnpm/buffer-fill@1.0.0/node_modules/buffer-fill/index.js
var require_buffer_fill = __commonJS({
  "node_modules/.pnpm/buffer-fill@1.0.0/node_modules/buffer-fill/index.js"(exports, module) {
    var hasFullSupport = function() {
      try {
        if (!Buffer.isEncoding("latin1")) {
          return false;
        }
        var buf = Buffer.alloc ? Buffer.alloc(4) : new Buffer(4);
        buf.fill("ab", "ucs2");
        return buf.toString("hex") === "61006200";
      } catch (_) {
        return false;
      }
    }();
    function isSingleByte(val2) {
      return val2.length === 1 && val2.charCodeAt(0) < 256;
    }
    function fillWithNumber(buffer, val2, start, end) {
      if (start < 0 || end > buffer.length) {
        throw new RangeError("Out of range index");
      }
      start = start >>> 0;
      end = end === void 0 ? buffer.length : end >>> 0;
      if (end > start) {
        buffer.fill(val2, start, end);
      }
      return buffer;
    }
    function fillWithBuffer(buffer, val2, start, end) {
      if (start < 0 || end > buffer.length) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return buffer;
      }
      start = start >>> 0;
      end = end === void 0 ? buffer.length : end >>> 0;
      var pos = start;
      var len = val2.length;
      while (pos <= end - len) {
        val2.copy(buffer, pos);
        pos += len;
      }
      if (pos !== end) {
        val2.copy(buffer, pos, 0, end - pos);
      }
      return buffer;
    }
    function fill(buffer, val2, start, end, encoding) {
      if (hasFullSupport) {
        return buffer.fill(val2, start, end, encoding);
      }
      if (typeof val2 === "number") {
        return fillWithNumber(buffer, val2, start, end);
      }
      if (typeof val2 === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = buffer.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = buffer.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (encoding === "latin1") {
          encoding = "binary";
        }
        if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val2 === "") {
          return fillWithNumber(buffer, 0, start, end);
        }
        if (isSingleByte(val2)) {
          return fillWithNumber(buffer, val2.charCodeAt(0), start, end);
        }
        val2 = new Buffer(val2, encoding);
      }
      if (Buffer.isBuffer(val2)) {
        return fillWithBuffer(buffer, val2, start, end);
      }
      return fillWithNumber(buffer, 0, start, end);
    }
    module.exports = fill;
  }
});

// node_modules/.pnpm/buffer-alloc@1.2.0/node_modules/buffer-alloc/index.js
var require_buffer_alloc = __commonJS({
  "node_modules/.pnpm/buffer-alloc@1.2.0/node_modules/buffer-alloc/index.js"(exports, module) {
    var bufferFill = require_buffer_fill();
    var allocUnsafe = require_buffer_alloc_unsafe();
    module.exports = function alloc(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be a number');
      }
      if (size < 0) {
        throw new RangeError('"size" argument must not be negative');
      }
      if (Buffer.alloc) {
        return Buffer.alloc(size, fill, encoding);
      }
      var buffer = allocUnsafe(size);
      if (size === 0) {
        return buffer;
      }
      if (fill === void 0) {
        return bufferFill(buffer, 0);
      }
      if (typeof encoding !== "string") {
        encoding = void 0;
      }
      return bufferFill(buffer, fill, encoding);
    };
  }
});

// node_modules/.pnpm/uint64be@2.0.2/node_modules/uint64be/index.js
var require_uint64be = __commonJS({
  "node_modules/.pnpm/uint64be@2.0.2/node_modules/uint64be/index.js"(exports) {
    var bufferAlloc = require_buffer_alloc();
    var UINT_32_MAX = Math.pow(2, 32);
    exports.encodingLength = function() {
      return 8;
    };
    exports.encode = function(num, buf, offset) {
      if (!buf) buf = bufferAlloc(8);
      if (!offset) offset = 0;
      var top = Math.floor(num / UINT_32_MAX);
      var rem = num - top * UINT_32_MAX;
      buf.writeUInt32BE(top, offset);
      buf.writeUInt32BE(rem, offset + 4);
      return buf;
    };
    exports.decode = function(buf, offset) {
      if (!offset) offset = 0;
      var top = buf.readUInt32BE(offset);
      var rem = buf.readUInt32BE(offset + 4);
      return top * UINT_32_MAX + rem;
    };
    exports.encode.bytes = 8;
    exports.decode.bytes = 8;
  }
});

// node_modules/.pnpm/hypercore-cache@1.0.2/node_modules/hypercore-cache/index.js
var require_hypercore_cache = __commonJS({
  "node_modules/.pnpm/hypercore-cache@1.0.2/node_modules/hypercore-cache/index.js"(exports, module) {
    var DEFAULT_MAX_BYTE_SIZE = 1024 * 1024 * 16;
    var NamespacedCache = class {
      constructor(parent, name) {
        this.name = name;
        this.parent = parent;
      }
      get _info() {
        return this.parent._info;
      }
      set(key, value) {
        return this.parent._set(this.name, key, value);
      }
      del(key) {
        return this.parent._del(this.name, key);
      }
      get(key) {
        return this.parent._get(this.name, key);
      }
    };
    module.exports = class HypercoreCache {
      constructor(opts = {}) {
        this.maxByteSize = opts.maxByteSize || DEFAULT_MAX_BYTE_SIZE;
        this.onEvict = opts.onEvict;
        this.estimateSize = opts.estimateSize || defaultSize;
        this._nextNamespace = 0;
        this.defaultCache = new NamespacedCache(this, this._nextNamespace++);
        this._stale = null;
        this._fresh = /* @__PURE__ */ new Map();
        this._freshByteSize = 0;
        this._staleByteSize = 0;
      }
      get _info() {
        return {
          freshByteSize: this._freshByteSize,
          staleByteSize: this._staleByteSize,
          staleEntries: this._stale ? this._stale.size : 0,
          freshEntries: this._fresh.size,
          byteSize: this.byteSize
        };
      }
      _prefix(namespace, key) {
        return namespace + ":" + key;
      }
      _gc() {
        if (this.onEvict && this._staleByteSize > 0) this.onEvict(this._stale);
        this._stale = this._fresh;
        this._fresh = /* @__PURE__ */ new Map();
        this._staleByteSize = this._freshByteSize;
        this._freshByteSize = 0;
      }
      _get(namespace, key, prefixedKey) {
        if (!prefixedKey) prefixedKey = this._prefix(namespace, key);
        return this._fresh.get(prefixedKey) || this._stale && this._stale.get(prefixedKey);
      }
      _set(namespace, key, value) {
        const valueSize = this.estimateSize(value);
        const prefixedKey = this._prefix(namespace, key);
        if (this._freshByteSize + valueSize > this.maxByteSize) {
          this._gc();
        }
        this._fresh.set(prefixedKey, value);
        this._freshByteSize += valueSize;
      }
      _del(namespace, key) {
        const prefixedKey = this._prefix(namespace, key);
        let val2 = this._stale && this._stale.get(prefixedKey);
        if (val2) {
          this._stale.delete(prefixedKey);
          this._staleByteSize -= this.estimateSize(val2);
        }
        val2 = this._fresh.get(prefixedKey);
        if (val2) {
          this._fresh.delete(prefixedKey);
          this._freshByteSize -= this.estimateSize(val2);
        }
      }
      get byteSize() {
        return this._freshByteSize + this._staleByteSize;
      }
      namespace() {
        const cache = new NamespacedCache(this, this._nextNamespace++);
        return cache;
      }
      set(key, value) {
        return this.defaultCache.set(key, value);
      }
      del(key) {
        return this.defaultCache.del(key);
      }
      get(key) {
        return this.defaultCache.get(key);
      }
    };
    function defaultSize() {
      return 1024;
    }
  }
});

// node_modules/.pnpm/hypercore@9.12.0/node_modules/hypercore/lib/cache.js
var require_cache = __commonJS({
  "node_modules/.pnpm/hypercore@9.12.0/node_modules/hypercore/lib/cache.js"(exports, module) {
    var HypercoreCache = require_hypercore_cache();
    var DEFAULT_TREE_CACHE_SIZE = 65536 * 40;
    function createCache(opts) {
      if (opts.cache === false) return {};
      const cacheOpts = opts.cache || {};
      if (cacheOpts.tree === void 0 || typeof cacheOpts.tree === "number") {
        const cacheSize = cacheOpts.tree || opts.storageCacheSize;
        cacheOpts.tree = new HypercoreCache({
          maxByteSize: cacheSize !== void 0 ? cacheSize : DEFAULT_TREE_CACHE_SIZE,
          estimateSize: () => 40
        });
      }
      if (cacheOpts.data === void 0) return cacheOpts;
      if (typeof cacheOpts.data === "number") {
        cacheOpts.data = new HypercoreCache({
          maxByteSize: cacheOpts.data,
          estimateSize: (buf) => buf.length
        });
      }
      return cacheOpts;
    }
    module.exports = createCache;
  }
});

// node_modules/.pnpm/hypercore@9.12.0/node_modules/hypercore/lib/storage.js
var require_storage = __commonJS({
  "node_modules/.pnpm/hypercore@9.12.0/node_modules/hypercore/lib/storage.js"(exports, module) {
    var uint64be = require_uint64be();
    var flat = require_flat_tree();
    var createCache = require_cache();
    module.exports = Storage;
    var noarr = [];
    function Storage(create, opts) {
      if (!(this instanceof Storage)) return new Storage(create, opts);
      const cache = createCache(opts);
      this.treeCache = cache.tree || null;
      this.dataCache = cache.data || null;
      this.key = null;
      this.secretKey = null;
      this.tree = null;
      this.data = null;
      this.bitfield = null;
      this.signatures = null;
      this.create = create;
    }
    Storage.prototype.putData = function(index, data, nodes, cb) {
      if (!cb) cb = noop;
      var self = this;
      if (!data.length) return cb(null);
      this.dataOffset(index, nodes, function(err, offset, size) {
        if (err) return cb(err);
        if (size !== data.length) return cb(new Error("Unexpected data size"));
        self.data.write(offset, data, cb);
      });
    };
    Storage.prototype.getData = function(index, cb) {
      var self = this;
      var cached = this.dataCache && this.dataCache.get(index);
      if (cached) return process.nextTick(cb, null, cached);
      this.dataOffset(index, noarr, function(err, offset, size) {
        if (err) return cb(err);
        self.data.read(offset, size, (err2, data) => {
          if (err2) return cb(err2);
          if (self.dataCache) self.dataCache.set(index, data);
          return cb(null, data);
        });
      });
    };
    Storage.prototype.nextSignature = function(index, cb) {
      var self = this;
      this._getSignature(index, function(err, signature) {
        if (err) return cb(err);
        if (isBlank(signature)) return self.nextSignature(index + 1, cb);
        cb(null, { index, signature });
      });
    };
    Storage.prototype.getSignature = function(index, cb) {
      this._getSignature(index, function(err, signature) {
        if (err) return cb(err);
        if (isBlank(signature)) return cb(new Error("No signature found"));
        cb(null, signature);
      });
    };
    Storage.prototype._getSignature = function(index, cb) {
      this.signatures.read(32 + 64 * index, 64, cb);
    };
    Storage.prototype.putSignature = function(index, signature, cb) {
      this.signatures.write(32 + 64 * index, signature, cb);
    };
    Storage.prototype.deleteSignatures = function(start, end, cb) {
      this.signatures.del(32 + 64 * start, (end - start) * 64, cb);
    };
    Storage.prototype.dataOffset = function(index, cachedNodes, cb) {
      var roots = flat.fullRoots(2 * index);
      var self = this;
      var offset = 0;
      var pending = roots.length;
      var error = null;
      var blk = 2 * index;
      if (!pending) {
        pending = 1;
        onnode(null, null);
        return;
      }
      for (var i = 0; i < roots.length; i++) {
        var node = findNode(cachedNodes, roots[i]);
        if (node) onnode(null, node);
        else this.getNode(roots[i], onnode);
      }
      function onlast(err, node2) {
        if (err) return cb(err);
        cb(null, offset, node2.size);
      }
      function onnode(err, node2) {
        if (err) error = err;
        if (node2) offset += node2.size;
        if (--pending) return;
        if (error) return cb(error);
        var last = findNode(cachedNodes, blk);
        if (last) onlast(null, last);
        else self.getNode(blk, onlast);
      }
    };
    Storage.prototype.getDataBatch = function(start, n, cb) {
      var result = new Array(n);
      var sizes = new Array(n);
      var self = this;
      this.dataOffset(start, noarr, function(err, offset, size) {
        if (err) return cb(err);
        start++;
        n--;
        if (n <= 0) return ontree(null, null);
        self.tree.read(32 + 80 * start, 80 * n - 40, ontree);
        function ontree(err2, buf) {
          if (err2) return cb(err2);
          var total = sizes[0] = size;
          if (buf) {
            for (var i = 1; i < sizes.length; i++) {
              sizes[i] = uint64be.decode(buf, 32 + (i - 1) * 80);
              total += sizes[i];
            }
          }
          self.data.read(offset, total, ondata);
        }
        function ondata(err2, buf) {
          if (err2) return cb(err2);
          var total = 0;
          for (var i = 0; i < result.length; i++) {
            result[i] = buf.slice(total, total += sizes[i]);
          }
          cb(null, result);
        }
      });
    };
    Storage.prototype.getNode = function(index, cb) {
      if (this.treeCache) {
        var cached = this.treeCache.get(index);
        if (cached) return cb(null, cached);
      }
      var self = this;
      this.tree.read(32 + 40 * index, 40, function(err, buf) {
        if (err) return cb(err);
        var hash = buf.slice(0, 32);
        var size = uint64be.decode(buf, 32);
        if (!size && isBlank(hash)) return cb(new Error("No node found"));
        var val2 = new Node(index, self.treeCache ? copyMaybe(hash, 40) : hash, size, null);
        if (self.treeCache) self.treeCache.set(index, val2);
        cb(null, val2);
      });
    };
    Storage.prototype.putNodeBatch = function(index, nodes, cb) {
      if (!cb) cb = noop;
      var buf = Buffer.alloc(nodes.length * 40);
      for (var i = 0; i < nodes.length; i++) {
        var offset = i * 40;
        var node = nodes[i];
        if (!node) continue;
        node.hash.copy(buf, offset);
        uint64be.encode(node.size, buf, 32 + offset);
      }
      this.tree.write(32 + 40 * index, buf, cb);
    };
    Storage.prototype.putNode = function(index, node, cb) {
      if (!cb) cb = noop;
      var buf = Buffer.allocUnsafe(40);
      node.hash.copy(buf, 0);
      uint64be.encode(node.size, buf, 32);
      this.tree.write(32 + 40 * index, buf, cb);
    };
    Storage.prototype.putBitfield = function(offset, data, cb) {
      this.bitfield.write(32 + offset, data, cb);
    };
    Storage.prototype.close = function(cb) {
      if (!cb) cb = noop;
      var missing = 6;
      var error = null;
      close(this.bitfield, done);
      close(this.tree, done);
      close(this.data, done);
      close(this.key, done);
      close(this.secretKey, done);
      close(this.signatures, done);
      function done(err) {
        if (err) error = err;
        if (--missing) return;
        cb(error);
      }
    };
    Storage.prototype.destroy = function(cb) {
      if (!cb) cb = noop;
      var missing = 6;
      var error = null;
      destroy(this.bitfield, done);
      destroy(this.tree, done);
      destroy(this.data, done);
      destroy(this.key, done);
      destroy(this.secretKey, done);
      destroy(this.signatures, done);
      function done(err) {
        if (err) error = err;
        if (--missing) return;
        cb(error);
      }
    };
    Storage.prototype.openKey = function(opts, cb) {
      if (typeof opts === "function") return this.openKey({}, opts);
      if (!this.key) this.key = this.create("key", opts);
      this.key.read(0, 32, cb);
    };
    Storage.prototype.open = function(opts, cb) {
      if (typeof opts === "function") return this.open({}, opts);
      var self = this;
      var error = null;
      var missing = 5;
      if (!this.key) this.key = this.create("key", opts);
      if (!this.secretKey) this.secretKey = this.create("secret_key", opts);
      if (!this.tree) this.tree = this.create("tree", opts);
      if (!this.data) this.data = this.create("data", opts);
      if (!this.bitfield) this.bitfield = this.create("bitfield", opts);
      if (!this.signatures) this.signatures = this.create("signatures", opts);
      var result = {
        bitfield: [],
        bitfieldPageSize: 3584,
        // we upgraded the page size to fix a bug
        secretKey: null,
        key: null
      };
      this.bitfield.read(0, 32, function(err, h) {
        if (err && err.code === "ELOCKED") return cb(err);
        if (h) result.bitfieldPageSize = h.readUInt16BE(5);
        self.bitfield.write(0, header(0, result.bitfieldPageSize, null), function(err2) {
          if (err2) return cb(err2);
          readAll(self.bitfield, 32, result.bitfieldPageSize, function(err3, pages) {
            if (pages) result.bitfield = pages;
            done(err3);
          });
        });
      });
      this.signatures.write(0, header(1, 64, "Ed25519"), done);
      this.tree.write(0, header(2, 40, "BLAKE2b"), done);
      this.secretKey.read(0, 64, function(_, data) {
        if (data) result.secretKey = data;
        done(null);
      });
      this.key.read(0, 32, function(_, data) {
        if (data) result.key = data;
        done(null);
      });
      function done(err) {
        if (err) error = err;
        if (--missing) return;
        if (error) cb(error);
        else cb(null, result);
      }
    };
    Storage.Node = Node;
    function noop() {
    }
    function copyMaybe(buf, maxSize) {
      if (buf.buffer.byteLength <= maxSize) return buf;
      const cpy = Buffer.alloc(buf.byteLength);
      buf.copy(cpy);
      return cpy;
    }
    function header(type, size, name) {
      var buf = Buffer.alloc(32);
      buf[0] = 5;
      buf[1] = 2;
      buf[2] = 87;
      buf[3] = type;
      buf[4] = 0;
      buf.writeUInt16BE(size, 5);
      if (name) {
        buf[7] = name.length;
        buf.write(name, 8);
      }
      return buf;
    }
    function Node(index, hash, size) {
      this.index = index;
      this.hash = hash;
      this.size = size;
    }
    function findNode(nodes, index) {
      for (var i = 0; i < nodes.length; i++) {
        if (nodes[i].index === index) return nodes[i];
      }
      return null;
    }
    function isBlank(buf) {
      for (var i = 0; i < buf.length; i++) {
        if (buf[i]) return false;
      }
      return true;
    }
    function close(st, cb) {
      if (st.close) st.close(cb);
      else cb();
    }
    function destroy(st, cb) {
      if (st.destroy) st.destroy(cb);
      else cb();
    }
    function statAndReadAll(st, offset, pageSize, cb) {
      st.stat(function(err, stat) {
        if (err) return cb(null, []);
        var result = [];
        loop(null, null);
        function loop(err2, batch) {
          if (err2) return cb(err2);
          if (batch) {
            offset += batch.length;
            for (var i = 0; i < batch.length; i += pageSize) {
              result.push(batch.slice(i, i + pageSize));
            }
          }
          var next = Math.min(stat.size - offset, 32 * pageSize);
          if (!next) return cb(null, result);
          st.read(offset, next, loop);
        }
      });
    }
    function readAll(st, offset, pageSize, cb) {
      if (st.statable === true) return statAndReadAll(st, offset, pageSize, cb);
      var bufs = [];
      st.read(offset, pageSize, loop);
      function loop(err, buf) {
        if (err) return cb(null, bufs);
        bufs.push(buf);
        st.read(offset + bufs.length * pageSize, pageSize, loop);
      }
    }
  }
});

// node_modules/.pnpm/uint64be@3.0.0/node_modules/uint64be/index.js
var require_uint64be2 = __commonJS({
  "node_modules/.pnpm/uint64be@3.0.0/node_modules/uint64be/index.js"(exports) {
    var UINT_32_MAX = Math.pow(2, 32);
    exports.encodingLength = function() {
      return 8;
    };
    exports.encode = function(num, buf, offset) {
      if (!buf) buf = Buffer.allocUnsafe(8);
      if (!offset) offset = 0;
      const top = Math.floor(num / UINT_32_MAX);
      const rem = num - top * UINT_32_MAX;
      buf.writeUInt32BE(top, offset);
      buf.writeUInt32BE(rem, offset + 4);
      return buf;
    };
    exports.decode = function(buf, offset) {
      if (!offset) offset = 0;
      const top = buf.readUInt32BE(offset);
      const rem = buf.readUInt32BE(offset + 4);
      return top * UINT_32_MAX + rem;
    };
    exports.encode.bytes = 8;
    exports.decode.bytes = 8;
  }
});

// node_modules/.pnpm/hypercore-crypto@2.3.2/node_modules/hypercore-crypto/index.js
var require_hypercore_crypto = __commonJS({
  "node_modules/.pnpm/hypercore-crypto@2.3.2/node_modules/hypercore-crypto/index.js"(exports) {
    var sodium = import$sodium_universal;
    var uint64be = require_uint64be2();
    var LEAF_TYPE = Buffer.from([0]);
    var PARENT_TYPE = Buffer.from([1]);
    var ROOT_TYPE = Buffer.from([2]);
    var CAP_TYPE = Buffer.from([3]);
    var HYPERCORE = Buffer.from("hypercore");
    var HYPERCORE_CAP = Buffer.from("hypercore capability");
    exports.writerCapability = function(key, secretKey, split) {
      if (!split) return null;
      const out = Buffer.allocUnsafe(32);
      sodium.crypto_generichash_batch(out, [
        CAP_TYPE,
        HYPERCORE_CAP,
        split.tx.slice(0, 32),
        key
      ], split.rx.slice(0, 32));
      return exports.sign(out, secretKey);
    };
    exports.verifyRemoteWriterCapability = function(key, cap, split) {
      if (!split) return null;
      const out = Buffer.allocUnsafe(32);
      sodium.crypto_generichash_batch(out, [
        CAP_TYPE,
        HYPERCORE_CAP,
        split.rx.slice(0, 32),
        key
      ], split.tx.slice(0, 32));
      return exports.verify(out, cap, key);
    };
    exports.capability = function(key, split) {
      if (!split) return null;
      const out = Buffer.allocUnsafe(32);
      sodium.crypto_generichash_batch(out, [
        HYPERCORE_CAP,
        split.tx.slice(0, 32),
        key
      ], split.rx.slice(0, 32));
      return out;
    };
    exports.remoteCapability = function(key, split) {
      if (!split) return null;
      const out = Buffer.allocUnsafe(32);
      sodium.crypto_generichash_batch(out, [
        HYPERCORE_CAP,
        split.rx.slice(0, 32),
        key
      ], split.tx.slice(0, 32));
      return out;
    };
    exports.keyPair = function(seed) {
      const publicKey = Buffer.allocUnsafe(sodium.crypto_sign_PUBLICKEYBYTES);
      const secretKey = Buffer.allocUnsafe(sodium.crypto_sign_SECRETKEYBYTES);
      if (seed) sodium.crypto_sign_seed_keypair(publicKey, secretKey, seed);
      else sodium.crypto_sign_keypair(publicKey, secretKey);
      return {
        publicKey,
        secretKey
      };
    };
    exports.validateKeyPair = function(keyPair) {
      const pk = Buffer.allocUnsafe(sodium.crypto_sign_PUBLICKEYBYTES);
      sodium.crypto_sign_ed25519_sk_to_pk(pk, keyPair.secretKey);
      return pk.equals(keyPair.publicKey);
    };
    exports.sign = function(message, secretKey) {
      const signature = Buffer.allocUnsafe(sodium.crypto_sign_BYTES);
      sodium.crypto_sign_detached(signature, message, secretKey);
      return signature;
    };
    exports.verify = function(message, signature, publicKey) {
      return sodium.crypto_sign_verify_detached(signature, message, publicKey);
    };
    exports.data = function(data) {
      const out = Buffer.allocUnsafe(32);
      sodium.crypto_generichash_batch(out, [
        LEAF_TYPE,
        encodeUInt64(data.length),
        data
      ]);
      return out;
    };
    exports.leaf = function(leaf) {
      return exports.data(leaf.data);
    };
    exports.parent = function(a, b) {
      if (a.index > b.index) {
        const tmp = a;
        a = b;
        b = tmp;
      }
      const out = Buffer.allocUnsafe(32);
      sodium.crypto_generichash_batch(out, [
        PARENT_TYPE,
        encodeUInt64(a.size + b.size),
        a.hash,
        b.hash
      ]);
      return out;
    };
    exports.tree = function(roots, out) {
      const buffers = new Array(3 * roots.length + 1);
      var j = 0;
      buffers[j++] = ROOT_TYPE;
      for (var i = 0; i < roots.length; i++) {
        const r = roots[i];
        buffers[j++] = r.hash;
        buffers[j++] = encodeUInt64(r.index);
        buffers[j++] = encodeUInt64(r.size);
      }
      if (!out) out = Buffer.allocUnsafe(32);
      sodium.crypto_generichash_batch(out, buffers);
      return out;
    };
    exports.signable = function(roots, length) {
      const out = Buffer.allocUnsafe(40);
      if (Buffer.isBuffer(roots)) roots.copy(out);
      else exports.tree(roots, out.slice(0, 32));
      uint64be.encode(length, out.slice(32));
      return out;
    };
    exports.randomBytes = function(n) {
      const buf = Buffer.allocUnsafe(n);
      sodium.randombytes_buf(buf);
      return buf;
    };
    exports.discoveryKey = function(publicKey) {
      const digest = Buffer.allocUnsafe(32);
      sodium.crypto_generichash(digest, HYPERCORE, publicKey);
      return digest;
    };
    if (sodium.sodium_free) {
      exports.free = function(secureBuf) {
        if (secureBuf.secure) sodium.sodium_free(secureBuf);
      };
    } else {
      exports.free = function() {
      };
    }
    function encodeUInt64(n) {
      return uint64be.encode(n, Buffer.allocUnsafe(8));
    }
  }
});

// node_modules/.pnpm/inspect-custom-symbol@1.1.1/node_modules/inspect-custom-symbol/browser.js
var require_browser = __commonJS({
  "node_modules/.pnpm/inspect-custom-symbol@1.1.1/node_modules/inspect-custom-symbol/browser.js"(exports, module) {
    module.exports = Symbol.for("nodejs.util.inspect.custom");
  }
});

// node_modules/.pnpm/pretty-hash@1.0.1/node_modules/pretty-hash/index.js
var require_pretty_hash = __commonJS({
  "node_modules/.pnpm/pretty-hash@1.0.1/node_modules/pretty-hash/index.js"(exports, module) {
    module.exports = function prettyHash(buf) {
      if (Buffer.isBuffer(buf)) buf = buf.toString("hex");
      if (typeof buf === "string" && buf.length > 8) {
        return buf.slice(0, 6) + ".." + buf.slice(-2);
      }
      return buf;
    };
  }
});

// node_modules/.pnpm/nanoguard@1.3.0/node_modules/nanoguard/index.js
var require_nanoguard = __commonJS({
  "node_modules/.pnpm/nanoguard@1.3.0/node_modules/nanoguard/index.js"(exports, module) {
    module.exports = class Nanoguard {
      constructor() {
        this._tick = 0;
        this._fns = [];
        this._dep = null;
      }
      get waiting() {
        return this._tick > 0;
      }
      depend(dep) {
        if (this._dep !== null) throw new Error("Can only depend on one other guard currently");
        this._dep = dep;
      }
      wait() {
        this._tick++;
      }
      continue(cb, err, val2) {
        if (this._tick === 1) process.nextTick(continueNT, this);
        else this._tick--;
        if (cb) cb(err, val2);
      }
      waitAndContinue() {
        let once = false;
        this.wait();
        return () => {
          if (once) return false;
          once = true;
          this.continue();
          return true;
        };
      }
      continueSync(cb, err, val2) {
        if (--this._tick) return;
        while (this._fns !== null && this._fns.length) this._ready(this._fns.pop());
        if (cb) cb(err, val2);
      }
      destroy() {
        const fns = this._fns;
        if (fns) return;
        this._fns = null;
        while (fns.length) fns.pop()();
      }
      ready(fn) {
        if (this._fns === null || this._tick === 0) this._ready(fn);
        else this._fns.push(fn);
      }
      _ready(fn) {
        if (this._dep === null) fn();
        else this._dep.ready(fn);
      }
    };
    function continueNT(guard) {
      guard.continueSync();
    }
  }
});

// node_modules/.pnpm/hypercore@9.12.0/node_modules/hypercore/lib/safe-buffer-equals.js
var require_safe_buffer_equals = __commonJS({
  "node_modules/.pnpm/hypercore@9.12.0/node_modules/hypercore/lib/safe-buffer-equals.js"(exports, module) {
    module.exports = function safeBufferEquals(a, b) {
      if (!a) return !b;
      if (!b) return !a;
      return Buffer.compare(a, b) === 0;
    };
  }
});

// node_modules/.pnpm/nanoassert@2.0.0/node_modules/nanoassert/index.js
var require_nanoassert = __commonJS({
  "node_modules/.pnpm/nanoassert@2.0.0/node_modules/nanoassert/index.js"(exports, module) {
    module.exports = assert;
    var AssertionError = class extends Error {
    };
    AssertionError.prototype.name = "AssertionError";
    function assert(t, m) {
      if (!t) {
        var err = new AssertionError(m);
        if (Error.captureStackTrace) Error.captureStackTrace(err, assert);
        throw err;
      }
    }
  }
});

// node_modules/.pnpm/clone@2.1.2/node_modules/clone/clone.js
var require_clone = __commonJS({
  "node_modules/.pnpm/clone@2.1.2/node_modules/clone/clone.js"(exports, module) {
    var clone = function() {
      "use strict";
      function _instanceof(obj, type) {
        return type != null && obj instanceof type;
      }
      var nativeMap;
      try {
        nativeMap = Map;
      } catch (_) {
        nativeMap = function() {
        };
      }
      var nativeSet;
      try {
        nativeSet = Set;
      } catch (_) {
        nativeSet = function() {
        };
      }
      var nativePromise;
      try {
        nativePromise = Promise;
      } catch (_) {
        nativePromise = function() {
        };
      }
      function clone2(parent, circular, depth, prototype, includeNonEnumerable) {
        if (typeof circular === "object") {
          depth = circular.depth;
          prototype = circular.prototype;
          includeNonEnumerable = circular.includeNonEnumerable;
          circular = circular.circular;
        }
        var allParents = [];
        var allChildren = [];
        var useBuffer = typeof Buffer != "undefined";
        if (typeof circular == "undefined")
          circular = true;
        if (typeof depth == "undefined")
          depth = Infinity;
        function _clone(parent2, depth2) {
          if (parent2 === null)
            return null;
          if (depth2 === 0)
            return parent2;
          var child;
          var proto;
          if (typeof parent2 != "object") {
            return parent2;
          }
          if (_instanceof(parent2, nativeMap)) {
            child = new nativeMap();
          } else if (_instanceof(parent2, nativeSet)) {
            child = new nativeSet();
          } else if (_instanceof(parent2, nativePromise)) {
            child = new nativePromise(function(resolve, reject) {
              parent2.then(function(value) {
                resolve(_clone(value, depth2 - 1));
              }, function(err) {
                reject(_clone(err, depth2 - 1));
              });
            });
          } else if (clone2.__isArray(parent2)) {
            child = [];
          } else if (clone2.__isRegExp(parent2)) {
            child = new RegExp(parent2.source, __getRegExpFlags(parent2));
            if (parent2.lastIndex) child.lastIndex = parent2.lastIndex;
          } else if (clone2.__isDate(parent2)) {
            child = new Date(parent2.getTime());
          } else if (useBuffer && Buffer.isBuffer(parent2)) {
            if (Buffer.allocUnsafe) {
              child = Buffer.allocUnsafe(parent2.length);
            } else {
              child = new Buffer(parent2.length);
            }
            parent2.copy(child);
            return child;
          } else if (_instanceof(parent2, Error)) {
            child = Object.create(parent2);
          } else {
            if (typeof prototype == "undefined") {
              proto = Object.getPrototypeOf(parent2);
              child = Object.create(proto);
            } else {
              child = Object.create(prototype);
              proto = prototype;
            }
          }
          if (circular) {
            var index = allParents.indexOf(parent2);
            if (index != -1) {
              return allChildren[index];
            }
            allParents.push(parent2);
            allChildren.push(child);
          }
          if (_instanceof(parent2, nativeMap)) {
            parent2.forEach(function(value, key) {
              var keyChild = _clone(key, depth2 - 1);
              var valueChild = _clone(value, depth2 - 1);
              child.set(keyChild, valueChild);
            });
          }
          if (_instanceof(parent2, nativeSet)) {
            parent2.forEach(function(value) {
              var entryChild = _clone(value, depth2 - 1);
              child.add(entryChild);
            });
          }
          for (var i in parent2) {
            var attrs;
            if (proto) {
              attrs = Object.getOwnPropertyDescriptor(proto, i);
            }
            if (attrs && attrs.set == null) {
              continue;
            }
            child[i] = _clone(parent2[i], depth2 - 1);
          }
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(parent2);
            for (var i = 0; i < symbols.length; i++) {
              var symbol = symbols[i];
              var descriptor = Object.getOwnPropertyDescriptor(parent2, symbol);
              if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
                continue;
              }
              child[symbol] = _clone(parent2[symbol], depth2 - 1);
              if (!descriptor.enumerable) {
                Object.defineProperty(child, symbol, {
                  enumerable: false
                });
              }
            }
          }
          if (includeNonEnumerable) {
            var allPropertyNames = Object.getOwnPropertyNames(parent2);
            for (var i = 0; i < allPropertyNames.length; i++) {
              var propertyName = allPropertyNames[i];
              var descriptor = Object.getOwnPropertyDescriptor(parent2, propertyName);
              if (descriptor && descriptor.enumerable) {
                continue;
              }
              child[propertyName] = _clone(parent2[propertyName], depth2 - 1);
              Object.defineProperty(child, propertyName, {
                enumerable: false
              });
            }
          }
          return child;
        }
        return _clone(parent, depth);
      }
      clone2.clonePrototype = function clonePrototype(parent) {
        if (parent === null)
          return null;
        var c = function() {
        };
        c.prototype = parent;
        return new c();
      };
      function __objToStr(o) {
        return Object.prototype.toString.call(o);
      }
      clone2.__objToStr = __objToStr;
      function __isDate(o) {
        return typeof o === "object" && __objToStr(o) === "[object Date]";
      }
      clone2.__isDate = __isDate;
      function __isArray(o) {
        return typeof o === "object" && __objToStr(o) === "[object Array]";
      }
      clone2.__isArray = __isArray;
      function __isRegExp(o) {
        return typeof o === "object" && __objToStr(o) === "[object RegExp]";
      }
      clone2.__isRegExp = __isRegExp;
      function __getRegExpFlags(re) {
        var flags = "";
        if (re.global) flags += "g";
        if (re.ignoreCase) flags += "i";
        if (re.multiline) flags += "m";
        return flags;
      }
      clone2.__getRegExpFlags = __getRegExpFlags;
      return clone2;
    }();
    if (typeof module === "object" && module.exports) {
      module.exports = clone;
    }
  }
});

// node_modules/.pnpm/noise-protocol@3.0.1/node_modules/noise-protocol/cipher.js
var require_cipher = __commonJS({
  "node_modules/.pnpm/noise-protocol@3.0.1/node_modules/noise-protocol/cipher.js"(exports, module) {
    var { sodium_malloc, sodium_memzero } = import$sodium_universal_memory;
    var {
      crypto_aead_chacha20poly1305_ietf_KEYBYTES,
      crypto_aead_chacha20poly1305_ietf_NPUBBYTES,
      crypto_aead_chacha20poly1305_ietf_ABYTES,
      crypto_aead_chacha20poly1305_ietf_encrypt,
      crypto_aead_chacha20poly1305_ietf_decrypt
    } = import$sodium_universal_crypto_aead;
    var assert = require_nanoassert();
    var KEYLEN = 32;
    var NONCELEN = 8;
    var MACLEN = 16;
    assert(crypto_aead_chacha20poly1305_ietf_KEYBYTES === KEYLEN);
    assert(crypto_aead_chacha20poly1305_ietf_NPUBBYTES === 4 + NONCELEN);
    assert(crypto_aead_chacha20poly1305_ietf_ABYTES === MACLEN);
    module.exports = {
      KEYLEN,
      NONCELEN,
      MACLEN,
      encrypt,
      decrypt,
      rekey
    };
    var ElongatedNonce = sodium_malloc(crypto_aead_chacha20poly1305_ietf_NPUBBYTES);
    function encrypt(out, k, n, ad, plaintext) {
      assert(out.byteLength >= plaintext.byteLength + MACLEN, "output buffer must be at least plaintext plus MACLEN bytes long");
      assert(k.byteLength === KEYLEN);
      assert(n.byteLength === NONCELEN);
      assert(ad == null ? true : ad.byteLength != null);
      sodium_memzero(ElongatedNonce);
      ElongatedNonce.set(n, 4);
      encrypt.bytesWritten = crypto_aead_chacha20poly1305_ietf_encrypt(out.subarray(0, plaintext.byteLength + MACLEN), plaintext, ad, null, ElongatedNonce, k);
      encrypt.bytesRead = encrypt.bytesWritten - MACLEN;
      sodium_memzero(ElongatedNonce);
    }
    encrypt.bytesWritten = 0;
    encrypt.bytesRead = 0;
    function decrypt(out, k, n, ad, ciphertext) {
      assert(out.byteLength >= ciphertext.byteLength - MACLEN);
      assert(k.byteLength === KEYLEN);
      assert(n.byteLength === NONCELEN);
      assert(ad == null ? true : ad.byteLength != null);
      sodium_memzero(ElongatedNonce);
      ElongatedNonce.set(n, 4);
      decrypt.bytesWritten = crypto_aead_chacha20poly1305_ietf_decrypt(out.subarray(0, ciphertext.byteLength - MACLEN), null, ciphertext, ad, ElongatedNonce, k);
      decrypt.bytesRead = decrypt.bytesWritten + MACLEN;
      sodium_memzero(ElongatedNonce);
    }
    decrypt.bytesWritten = 0;
    decrypt.bytesRead = 0;
    var maxnonce = new Uint8Array(8).fill(255);
    var zerolen = new Uint8Array(0);
    var zeros = new Uint8Array(32);
    var IntermediateKey = sodium_malloc(KEYLEN + MACLEN);
    sodium_memzero(IntermediateKey);
    function rekey(out, k) {
      assert(out.byteLength === KEYLEN);
      assert(k.byteLength === KEYLEN);
      sodium_memzero(IntermediateKey);
      IntermediateKey.set(k);
      encrypt(IntermediateKey, k, maxnonce, zerolen, zeros);
      rekey.bytesWritten = encrypt.bytesWritten;
      rekey.bytesRead = encrypt.bytesRead;
      out.set(IntermediateKey.subarray(0, KEYLEN));
      sodium_memzero(IntermediateKey);
    }
    rekey.bytesWritten = 0;
    rekey.bytesRead = 0;
  }
});

// node_modules/.pnpm/noise-protocol@3.0.1/node_modules/noise-protocol/cipher-state.js
var require_cipher_state = __commonJS({
  "node_modules/.pnpm/noise-protocol@3.0.1/node_modules/noise-protocol/cipher-state.js"(exports, module) {
    var { sodium_memzero } = import$sodium_universal_memory;
    var { sodium_increment, sodium_memcmp, sodium_is_zero } = import$sodium_universal_helpers;
    var assert = require_nanoassert();
    var cipher = require_cipher();
    var STATELEN = cipher.KEYLEN + cipher.NONCELEN;
    var NONCELEN = cipher.NONCELEN;
    var MACLEN = cipher.MACLEN;
    module.exports = {
      STATELEN,
      NONCELEN,
      MACLEN,
      initializeKey,
      hasKey,
      setNonce,
      encryptWithAd,
      decryptWithAd,
      rekey
    };
    var KEY_BEGIN = 0;
    var KEY_END = cipher.KEYLEN;
    var NONCE_BEGIN = KEY_END;
    var NONCE_END = NONCE_BEGIN + cipher.NONCELEN;
    function initializeKey(state, key) {
      assert(state.byteLength === STATELEN);
      assert(key == null ? true : key.byteLength === cipher.KEYLEN);
      if (key == null) {
        sodium_memzero(state.subarray(KEY_BEGIN, KEY_END));
        return;
      }
      state.set(key);
      sodium_memzero(state.subarray(NONCE_BEGIN, NONCE_END));
    }
    function hasKey(state) {
      assert(state.byteLength === STATELEN);
      var k = state.subarray(KEY_BEGIN, KEY_END);
      return sodium_is_zero(k) === false;
    }
    function setNonce(state, nonce) {
      assert(state.byteLength === STATELEN);
      assert(nonce.byteLength === NONCELEN);
      state.set(nonce, NONCE_BEGIN);
    }
    var maxnonce = new Uint8Array(8).fill(255);
    function encryptWithAd(state, out, ad, plaintext) {
      assert(state.byteLength === STATELEN);
      assert(out.byteLength != null);
      assert(plaintext.byteLength != null);
      var n = state.subarray(NONCE_BEGIN, NONCE_END);
      if (sodium_memcmp(n, maxnonce)) throw new Error("Nonce overflow");
      if (hasKey(state) === false) {
        out.set(plaintext);
        encryptWithAd.bytesRead = plaintext.byteLength;
        encryptWithAd.bytesWritten = encryptWithAd.bytesRead;
        return;
      }
      var k = state.subarray(KEY_BEGIN, KEY_END);
      cipher.encrypt(
        out,
        k,
        n,
        ad,
        plaintext
      );
      encryptWithAd.bytesRead = cipher.encrypt.bytesRead;
      encryptWithAd.bytesWritten = cipher.encrypt.bytesWritten;
      sodium_increment(n);
    }
    encryptWithAd.bytesRead = 0;
    encryptWithAd.bytesWritten = 0;
    function decryptWithAd(state, out, ad, ciphertext) {
      assert(state.byteLength === STATELEN);
      assert(out.byteLength != null);
      assert(ciphertext.byteLength != null);
      var n = state.subarray(NONCE_BEGIN, NONCE_END);
      if (sodium_memcmp(n, maxnonce)) throw new Error("Nonce overflow");
      if (hasKey(state) === false) {
        out.set(ciphertext);
        decryptWithAd.bytesRead = ciphertext.byteLength;
        decryptWithAd.bytesWritten = decryptWithAd.bytesRead;
        return;
      }
      var k = state.subarray(KEY_BEGIN, KEY_END);
      cipher.decrypt(
        out,
        k,
        n,
        ad,
        ciphertext
      );
      decryptWithAd.bytesRead = cipher.decrypt.bytesRead;
      decryptWithAd.bytesWritten = cipher.decrypt.bytesWritten;
      sodium_increment(n);
    }
    decryptWithAd.bytesRead = 0;
    decryptWithAd.bytesWritten = 0;
    function rekey(state) {
      assert(state.byteLength === STATELEN);
      var k = state.subarray(KEY_BEGIN, KEY_END);
      cipher.rekey(k, k);
      rekey.bytesRead = cipher.rekey.bytesRead;
      rekey.bytesWritten = cipher.rekey.bytesWritten;
    }
    rekey.bytesRead = 0;
    rekey.bytesWritten = 0;
  }
});

// node_modules/.pnpm/nanoassert@1.1.0/node_modules/nanoassert/index.js
var require_nanoassert2 = __commonJS({
  "node_modules/.pnpm/nanoassert@1.1.0/node_modules/nanoassert/index.js"(exports, module) {
    assert.notEqual = notEqual;
    assert.notOk = notOk;
    assert.equal = equal;
    assert.ok = assert;
    module.exports = assert;
    function equal(a, b, m) {
      assert(a == b, m);
    }
    function notEqual(a, b, m) {
      assert(a != b, m);
    }
    function notOk(t, m) {
      assert(!t, m);
    }
    function assert(t, m) {
      if (!t) throw new Error(m || "AssertionError");
    }
  }
});

// node_modules/.pnpm/hmac-blake2b@2.0.0/node_modules/hmac-blake2b/index.js
var require_hmac_blake2b = __commonJS({
  "node_modules/.pnpm/hmac-blake2b@2.0.0/node_modules/hmac-blake2b/index.js"(exports, module) {
    var { sodium_malloc, sodium_memzero } = import$sodium_universal_memory;
    var { crypto_generichash, crypto_generichash_batch } = import$sodium_universal_crypto_generichash;
    var assert = require_nanoassert2();
    var HASHLEN = 64;
    var BLOCKLEN = 128;
    var scratch = sodium_malloc(BLOCKLEN * 3);
    var HMACKey = scratch.subarray(BLOCKLEN * 0, BLOCKLEN * 1);
    var OuterKeyPad = scratch.subarray(BLOCKLEN * 1, BLOCKLEN * 2);
    var InnerKeyPad = scratch.subarray(BLOCKLEN * 2, BLOCKLEN * 3);
    module.exports = function hmac(out, data, key) {
      assert(out.byteLength === HASHLEN);
      assert(key.byteLength != null);
      assert(Array.isArray(data) ? data.every((d) => d.byteLength != null) : data.byteLength != null);
      if (key.byteLength > BLOCKLEN) {
        crypto_generichash(HMACKey.subarray(0, HASHLEN), key);
        sodium_memzero(HMACKey.subarray(HASHLEN));
      } else {
        HMACKey.set(key);
        sodium_memzero(HMACKey.subarray(key.byteLength));
      }
      for (var i = 0; i < HMACKey.byteLength; i++) {
        OuterKeyPad[i] = 92 ^ HMACKey[i];
        InnerKeyPad[i] = 54 ^ HMACKey[i];
      }
      sodium_memzero(HMACKey);
      crypto_generichash_batch(out, [InnerKeyPad].concat(data));
      sodium_memzero(InnerKeyPad);
      crypto_generichash_batch(out, [OuterKeyPad].concat(out));
      sodium_memzero(OuterKeyPad);
    };
    module.exports.BYTES = HASHLEN;
    module.exports.KEYBYTES = BLOCKLEN;
  }
});

// node_modules/.pnpm/noise-protocol@3.0.1/node_modules/noise-protocol/dh.js
var require_dh = __commonJS({
  "node_modules/.pnpm/noise-protocol@3.0.1/node_modules/noise-protocol/dh.js"(exports, module) {
    var { crypto_kx_SEEDBYTES, crypto_kx_keypair, crypto_kx_seed_keypair } = import$sodium_universal_crypto_kx;
    var { crypto_scalarmult_BYTES, crypto_scalarmult_SCALARBYTES, crypto_scalarmult } = import$sodium_universal_crypto_scalarmult;
    var assert = require_nanoassert();
    var DHLEN = crypto_scalarmult_BYTES;
    var PKLEN = crypto_scalarmult_BYTES;
    var SKLEN = crypto_scalarmult_SCALARBYTES;
    var SEEDLEN = crypto_kx_SEEDBYTES;
    module.exports = {
      DHLEN,
      PKLEN,
      SKLEN,
      SEEDLEN,
      generateKeypair,
      generateSeedKeypair,
      dh
    };
    function generateKeypair(pk, sk) {
      assert(pk.byteLength === PKLEN);
      assert(sk.byteLength === SKLEN);
      crypto_kx_keypair(pk, sk);
    }
    function generateSeedKeypair(pk, sk, seed) {
      assert(pk.byteLength === PKLEN);
      assert(sk.byteLength === SKLEN);
      assert(seed.byteLength === SKLEN);
      crypto_kx_seed_keypair(pk, sk, seed);
    }
    function dh(output, lsk, pk) {
      assert(output.byteLength === DHLEN);
      assert(lsk.byteLength === SKLEN);
      assert(pk.byteLength === PKLEN);
      crypto_scalarmult(
        output,
        lsk,
        pk
      );
    }
  }
});

// node_modules/.pnpm/noise-protocol@3.0.1/node_modules/noise-protocol/hash.js
var require_hash = __commonJS({
  "node_modules/.pnpm/noise-protocol@3.0.1/node_modules/noise-protocol/hash.js"(exports, module) {
    var { sodium_malloc, sodium_memzero } = import$sodium_universal_memory;
    var { crypto_generichash_batch } = import$sodium_universal_crypto_generichash;
    var assert = require_nanoassert();
    var hmacBlake2b = require_hmac_blake2b();
    var dh = require_dh();
    var HASHLEN = 64;
    var BLOCKLEN = 128;
    assert(hmacBlake2b.KEYBYTES === BLOCKLEN, "mismatching hmac BLOCKLEN");
    assert(hmacBlake2b.BYTES === HASHLEN, "mismatching hmac HASHLEN");
    module.exports = {
      HASHLEN,
      BLOCKLEN,
      hash,
      hkdf
    };
    function hash(out, data) {
      assert(out.byteLength === HASHLEN);
      assert(Array.isArray(data));
      crypto_generichash_batch(out, data);
    }
    function hmac(out, key, data) {
      return hmacBlake2b(out, data, key);
    }
    var TempKey = sodium_malloc(HASHLEN);
    var Byte0x01 = new Uint8Array([1]);
    var Byte0x02 = new Uint8Array([2]);
    var Byte0x03 = new Uint8Array([3]);
    function hkdf(out1, out2, out3, chainingKey, inputKeyMaterial) {
      assert(out1.byteLength === HASHLEN);
      assert(out2.byteLength === HASHLEN);
      assert(out3 == null ? true : out3.byteLength === HASHLEN);
      assert(chainingKey.byteLength === HASHLEN);
      assert([0, 32, dh.DHLEN, dh.PKLEN].includes(inputKeyMaterial.byteLength));
      sodium_memzero(TempKey);
      hmac(TempKey, chainingKey, [inputKeyMaterial]);
      hmac(out1, TempKey, [Byte0x01]);
      hmac(out2, TempKey, [out1, Byte0x02]);
      if (out3 != null) {
        hmac(out3, TempKey, [out2, Byte0x03]);
      }
      sodium_memzero(TempKey);
    }
  }
});

// node_modules/.pnpm/noise-protocol@3.0.1/node_modules/noise-protocol/symmetric-state.js
var require_symmetric_state = __commonJS({
  "node_modules/.pnpm/noise-protocol@3.0.1/node_modules/noise-protocol/symmetric-state.js"(exports, module) {
    var { sodium_malloc, sodium_memzero } = import$sodium_universal_memory;
    var assert = require_nanoassert();
    var cipherState = require_cipher_state();
    var hash = require_hash();
    var STATELEN = hash.HASHLEN + hash.HASHLEN + cipherState.STATELEN;
    var HASHLEN = hash.HASHLEN;
    module.exports = {
      STATELEN,
      initializeSymmetric,
      mixKey,
      mixHash,
      mixKeyAndHash,
      getHandshakeHash,
      encryptAndHash,
      decryptAndHash,
      split,
      _hasKey
    };
    var CHAINING_KEY_BEGIN = 0;
    var CHAINING_KEY_END = hash.HASHLEN;
    var HASH_BEGIN = CHAINING_KEY_END;
    var HASH_END = HASH_BEGIN + hash.HASHLEN;
    var CIPHER_BEGIN = HASH_END;
    var CIPHER_END = CIPHER_BEGIN + cipherState.STATELEN;
    function initializeSymmetric(state, protocolName) {
      assert(state.byteLength === STATELEN);
      assert(protocolName.byteLength != null);
      sodium_memzero(state);
      if (protocolName.byteLength <= HASHLEN) state.set(protocolName, HASH_BEGIN);
      else hash.hash(state.subarray(HASH_BEGIN, HASH_END), [protocolName]);
      state.subarray(CHAINING_KEY_BEGIN, CHAINING_KEY_END).set(state.subarray(HASH_BEGIN, HASH_END));
      cipherState.initializeKey(state.subarray(CIPHER_BEGIN, CIPHER_END), null);
    }
    var TempKey = sodium_malloc(HASHLEN);
    function mixKey(state, inputKeyMaterial) {
      assert(state.byteLength === STATELEN);
      assert(inputKeyMaterial.byteLength != null);
      hash.hkdf(
        state.subarray(CHAINING_KEY_BEGIN, CHAINING_KEY_END),
        TempKey,
        null,
        state.subarray(CHAINING_KEY_BEGIN, CHAINING_KEY_END),
        inputKeyMaterial
      );
      cipherState.initializeKey(state.subarray(CIPHER_BEGIN, CIPHER_END), TempKey.subarray(0, 32));
      sodium_memzero(TempKey);
    }
    function mixHash(state, data) {
      assert(state.byteLength === STATELEN);
      var h = state.subarray(HASH_BEGIN, HASH_END);
      hash.hash(h, [h, data]);
    }
    var TempHash = sodium_malloc(HASHLEN);
    function mixKeyAndHash(state, inputKeyMaterial) {
      assert(state.byteLength === STATELEN);
      assert(inputKeyMaterial.byteLength != null);
      hash.hkdf(
        state.subarray(CHAINING_KEY_BEGIN, CHAINING_KEY_END),
        TempHash,
        TempKey,
        state.subarray(CHAINING_KEY_BEGIN, CHAINING_KEY_END),
        inputKeyMaterial
      );
      mixHash(state, TempHash);
      sodium_memzero(TempHash);
      cipherState.initializeKey(state.subarray(CIPHER_BEGIN, CIPHER_END), TempKey.subarray(0, 32));
      sodium_memzero(TempKey);
    }
    function getHandshakeHash(state, out) {
      assert(state.byteLength === STATELEN);
      assert(out.byteLength === HASHLEN);
      out.set(state.subarray(HASH_BEGIN, HASH_END));
    }
    function encryptAndHash(state, ciphertext, plaintext) {
      assert(state.byteLength === STATELEN);
      assert(ciphertext.byteLength != null);
      assert(plaintext.byteLength != null);
      var cstate = state.subarray(CIPHER_BEGIN, CIPHER_END);
      var h = state.subarray(HASH_BEGIN, HASH_END);
      cipherState.encryptWithAd(cstate, ciphertext, h, plaintext);
      encryptAndHash.bytesRead = cipherState.encryptWithAd.bytesRead;
      encryptAndHash.bytesWritten = cipherState.encryptWithAd.bytesWritten;
      mixHash(state, ciphertext.subarray(0, encryptAndHash.bytesWritten));
    }
    encryptAndHash.bytesRead = 0;
    encryptAndHash.bytesWritten = 0;
    function decryptAndHash(state, plaintext, ciphertext) {
      assert(state.byteLength === STATELEN);
      assert(plaintext.byteLength != null);
      assert(ciphertext.byteLength != null);
      var cstate = state.subarray(CIPHER_BEGIN, CIPHER_END);
      var h = state.subarray(HASH_BEGIN, HASH_END);
      cipherState.decryptWithAd(cstate, plaintext, h, ciphertext);
      decryptAndHash.bytesRead = cipherState.decryptWithAd.bytesRead;
      decryptAndHash.bytesWritten = cipherState.decryptWithAd.bytesWritten;
      mixHash(state, ciphertext.subarray(0, decryptAndHash.bytesRead));
    }
    decryptAndHash.bytesRead = 0;
    decryptAndHash.bytesWritten = 0;
    var TempKey1 = sodium_malloc(HASHLEN);
    var TempKey2 = sodium_malloc(HASHLEN);
    var zerolen = new Uint8Array(0);
    function split(state, cipherstate1, cipherstate2) {
      assert(state.byteLength === STATELEN);
      assert(cipherstate1.byteLength === cipherState.STATELEN);
      assert(cipherstate2.byteLength === cipherState.STATELEN);
      hash.hkdf(
        TempKey1,
        TempKey2,
        null,
        state.subarray(CHAINING_KEY_BEGIN, CHAINING_KEY_END),
        zerolen
      );
      cipherState.initializeKey(cipherstate1, TempKey1.subarray(0, 32));
      cipherState.initializeKey(cipherstate2, TempKey2.subarray(0, 32));
      sodium_memzero(TempKey1);
      sodium_memzero(TempKey2);
    }
    function _hasKey(state) {
      return cipherState.hasKey(state.subarray(CIPHER_BEGIN, CIPHER_END));
    }
  }
});

// node_modules/.pnpm/noise-protocol@3.0.1/node_modules/noise-protocol/handshake-state.js
var require_handshake_state = __commonJS({
  "node_modules/.pnpm/noise-protocol@3.0.1/node_modules/noise-protocol/handshake-state.js"(exports, module) {
    var { sodium_malloc, sodium_memzero, sodium_free } = import$sodium_universal_memory;
    var assert = require_nanoassert();
    var clone = require_clone();
    var symmetricState = require_symmetric_state();
    var cipherState = require_cipher_state();
    var dh = require_dh();
    var PKLEN = dh.PKLEN;
    var SKLEN = dh.SKLEN;
    module.exports = Object.freeze({
      initialize,
      writeMessage,
      readMessage,
      destroy,
      keygen,
      seedKeygen,
      SKLEN,
      PKLEN
    });
    function HandshakeState() {
      this.symmetricState = sodium_malloc(symmetricState.STATELEN);
      this.initiator = null;
      this.spk = null;
      this.ssk = null;
      this.epk = null;
      this.esk = null;
      this.rs = null;
      this.re = null;
      this.messagePatterns = null;
    }
    var INITIATOR = Symbol("initiator");
    var RESPONDER = Symbol("responder");
    var TOK_S = Symbol("s");
    var TOK_E = Symbol("e");
    var TOK_ES = Symbol("es");
    var TOK_SE = Symbol("se");
    var TOK_EE = Symbol("ee");
    var TOK_SS = Symbol("es");
    var PATTERNS = Object.freeze({
      N: {
        premessages: [
          [RESPONDER, TOK_S]
        ],
        messagePatterns: [
          [INITIATOR, TOK_E, TOK_ES]
        ]
      },
      K: {
        premessages: [
          [INITIATOR, TOK_S],
          [RESPONDER, TOK_S]
        ],
        messagePatterns: [
          [INITIATOR, TOK_E, TOK_ES, TOK_SS]
        ]
      },
      X: {
        premessages: [
          [RESPONDER, TOK_S]
        ],
        messagePatterns: [
          [INITIATOR, TOK_E, TOK_ES, TOK_S, TOK_SS]
        ]
      },
      NN: {
        premessages: [],
        messagePatterns: [
          [INITIATOR, TOK_E],
          [RESPONDER, TOK_E, TOK_EE]
        ]
      },
      KN: {
        premessages: [
          [INITIATOR, TOK_S]
        ],
        messagePatterns: [
          [INITIATOR, TOK_E],
          [RESPONDER, TOK_E, TOK_EE, TOK_SE]
        ]
      },
      NK: {
        premessages: [
          [RESPONDER, TOK_S]
        ],
        messagePatterns: [
          [INITIATOR, TOK_E, TOK_ES],
          [RESPONDER, TOK_E, TOK_EE]
        ]
      },
      KK: {
        premessages: [
          [INITIATOR, TOK_S],
          [RESPONDER, TOK_S]
        ],
        messagePatterns: [
          [INITIATOR, TOK_E, TOK_ES, TOK_SS],
          [RESPONDER, TOK_E, TOK_EE, TOK_SE]
        ]
      },
      NX: {
        premessages: [],
        messagePatterns: [
          [INITIATOR, TOK_E],
          [RESPONDER, TOK_E, TOK_EE, TOK_S, TOK_ES]
        ]
      },
      KX: {
        premessages: [
          [INITIATOR, TOK_S]
        ],
        messagePatterns: [
          [INITIATOR, TOK_E],
          [RESPONDER, TOK_E, TOK_EE, TOK_SE, TOK_S, TOK_ES]
        ]
      },
      XN: {
        premessages: [],
        messagePatterns: [
          [INITIATOR, TOK_E],
          [RESPONDER, TOK_E, TOK_EE],
          [INITIATOR, TOK_S, TOK_SE]
        ]
      },
      IN: {
        premessages: [],
        messagePatterns: [
          [INITIATOR, TOK_E, TOK_S],
          [RESPONDER, TOK_E, TOK_EE, TOK_SE]
        ]
      },
      XK: {
        premessages: [
          [RESPONDER, TOK_S]
        ],
        messagePatterns: [
          [INITIATOR, TOK_E, TOK_ES],
          [RESPONDER, TOK_E, TOK_EE],
          [INITIATOR, TOK_S, TOK_SE]
        ]
      },
      IK: {
        premessages: [
          [RESPONDER, TOK_S]
        ],
        messagePatterns: [
          [INITIATOR, TOK_E, TOK_ES, TOK_S, TOK_SS],
          [RESPONDER, TOK_E, TOK_EE, TOK_SE]
        ]
      },
      XX: {
        premessages: [],
        messagePatterns: [
          [INITIATOR, TOK_E],
          [RESPONDER, TOK_E, TOK_EE, TOK_S, TOK_ES],
          [INITIATOR, TOK_S, TOK_SE]
        ]
      },
      IX: {
        premessages: [],
        messagePatterns: [
          [INITIATOR, TOK_E, TOK_S],
          [RESPONDER, TOK_E, TOK_EE, TOK_SE, TOK_S, TOK_ES]
        ]
      }
    });
    function sodiumBufferCopy(src) {
      var buf = sodium_malloc(src.byteLength);
      buf.set(src);
      return buf;
    }
    function initialize(handshakePattern, initiator, prologue, s, e, rs, re) {
      assert(Object.keys(PATTERNS).includes(handshakePattern), "Unsupported handshake pattern");
      assert(typeof initiator === "boolean", "Initiator must be a boolean");
      assert(prologue.byteLength != null, "prolouge must be a Buffer");
      assert(e == null ? true : e.publicKey.byteLength === dh.PKLEN, `e.publicKey must be ${dh.PKLEN} bytes`);
      assert(e == null ? true : e.secretKey.byteLength === dh.SKLEN, `e.secretKey must be ${dh.SKLEN} bytes`);
      assert(rs == null ? true : rs.byteLength === dh.PKLEN, `rs must be ${dh.PKLEN} bytes`);
      assert(re == null ? true : re.byteLength === dh.PKLEN, `re must be ${dh.PKLEN} bytes`);
      var state = new HandshakeState();
      var protocolName = Uint8Array.from(`Noise_${handshakePattern}_25519_ChaChaPoly_BLAKE2b`, toCharCode);
      symmetricState.initializeSymmetric(state.symmetricState, protocolName);
      symmetricState.mixHash(state.symmetricState, prologue);
      state.role = initiator === true ? INITIATOR : RESPONDER;
      if (s != null) {
        assert(s.publicKey.byteLength === dh.PKLEN, `s.publicKey must be ${dh.PKLEN} bytes`);
        assert(s.secretKey.byteLength === dh.SKLEN, `s.secretKey must be ${dh.SKLEN} bytes`);
        state.spk = sodiumBufferCopy(s.publicKey);
        state.ssk = sodiumBufferCopy(s.secretKey);
      }
      if (e != null) {
        assert(e.publicKey.byteLength === dh.PKLEN);
        assert(e.secretKey.byteLength === dh.SKLEN);
        state.epk = sodiumBufferCopy(e.publicKey);
        state.esk = sodiumBufferCopy(e.secretKey);
      }
      if (rs != null) {
        assert(rs.byteLength === dh.PKLEN);
        state.rs = sodiumBufferCopy(rs);
      }
      if (re != null) {
        assert(re.byteLength === dh.PKLEN);
        state.re = sodiumBufferCopy(re);
      }
      var pat = PATTERNS[handshakePattern];
      for (var pattern of clone(pat.premessages)) {
        var patternRole = pattern.shift();
        for (var token of pattern) {
          switch (token) {
            case TOK_E:
              assert(state.role === patternRole ? state.epk.byteLength != null : state.re.byteLength != null);
              symmetricState.mixHash(state.symmetricState, state.role === patternRole ? state.epk : state.re);
              break;
            case TOK_S:
              assert(state.role === patternRole ? state.spk.byteLength != null : state.rs.byteLength != null);
              symmetricState.mixHash(state.symmetricState, state.role === patternRole ? state.spk : state.rs);
              break;
            default:
              throw new Error("Invalid premessage pattern");
          }
        }
      }
      state.messagePatterns = clone(pat.messagePatterns);
      assert(
        state.messagePatterns.filter((p) => p[0] === INITIATOR).some((p) => p.includes(TOK_S)) ? state.spk !== null && state.ssk !== null : true,
        // Default if none is found
        "This handshake pattern requires a static keypair"
      );
      return state;
    }
    var DhResult = sodium_malloc(dh.DHLEN);
    function writeMessage(state, payload, messageBuffer) {
      assert(state instanceof HandshakeState);
      assert(payload.byteLength != null);
      assert(messageBuffer.byteLength != null);
      var mpat = state.messagePatterns.shift();
      var moffset = 0;
      assert(mpat != null);
      assert(state.role === mpat.shift());
      for (var token of mpat) {
        switch (token) {
          case TOK_E:
            assert(state.epk == null);
            assert(state.esk == null);
            state.epk = sodium_malloc(dh.PKLEN);
            state.esk = sodium_malloc(dh.SKLEN);
            dh.generateKeypair(state.epk, state.esk);
            messageBuffer.set(state.epk, moffset);
            moffset += state.epk.byteLength;
            symmetricState.mixHash(state.symmetricState, state.epk);
            break;
          case TOK_S:
            assert(state.spk.byteLength === dh.PKLEN);
            symmetricState.encryptAndHash(state.symmetricState, messageBuffer.subarray(moffset), state.spk);
            moffset += symmetricState.encryptAndHash.bytesWritten;
            break;
          case TOK_EE:
            dh.dh(DhResult, state.esk, state.re);
            symmetricState.mixKey(state.symmetricState, DhResult);
            sodium_memzero(DhResult);
            break;
          case TOK_ES:
            if (state.role === INITIATOR) dh.dh(DhResult, state.esk, state.rs);
            else dh.dh(DhResult, state.ssk, state.re);
            symmetricState.mixKey(state.symmetricState, DhResult);
            sodium_memzero(DhResult);
            break;
          case TOK_SE:
            if (state.role === INITIATOR) dh.dh(DhResult, state.ssk, state.re);
            else dh.dh(DhResult, state.esk, state.rs);
            symmetricState.mixKey(state.symmetricState, DhResult);
            sodium_memzero(DhResult);
            break;
          case TOK_SS:
            dh.dh(DhResult, state.ssk, state.rs);
            symmetricState.mixKey(state.symmetricState, DhResult);
            sodium_memzero(DhResult);
            break;
          default:
            throw new Error("Invalid message pattern");
        }
      }
      symmetricState.encryptAndHash(state.symmetricState, messageBuffer.subarray(moffset), payload);
      moffset += symmetricState.encryptAndHash.bytesWritten;
      writeMessage.bytes = moffset;
      if (state.messagePatterns.length === 0) {
        var tx = sodium_malloc(cipherState.STATELEN);
        var rx = sodium_malloc(cipherState.STATELEN);
        symmetricState.split(state.symmetricState, tx, rx);
        return { tx, rx };
      }
    }
    writeMessage.bytes = 0;
    function readMessage(state, message, payloadBuffer) {
      assert(state instanceof HandshakeState);
      assert(message.byteLength != null);
      assert(payloadBuffer.byteLength != null);
      var mpat = state.messagePatterns.shift();
      var moffset = 0;
      assert(mpat != null);
      assert(mpat.shift() !== state.role);
      for (var token of mpat) {
        switch (token) {
          case TOK_E:
            assert(state.re == null);
            assert(message.byteLength - moffset >= dh.PKLEN);
            state.re = sodium_malloc(dh.PKLEN);
            state.re.set(message.subarray(moffset, moffset + dh.PKLEN));
            moffset += dh.PKLEN;
            symmetricState.mixHash(state.symmetricState, state.re);
            break;
          case TOK_S:
            assert(state.rs == null);
            state.rs = sodium_malloc(dh.PKLEN);
            var bytes = 0;
            if (symmetricState._hasKey(state.symmetricState)) {
              bytes = dh.PKLEN + 16;
            } else {
              bytes = dh.PKLEN;
            }
            assert(message.byteLength - moffset >= bytes);
            symmetricState.decryptAndHash(
              state.symmetricState,
              state.rs,
              message.subarray(moffset, moffset + bytes)
              // <- called temp in noise spec
            );
            moffset += symmetricState.decryptAndHash.bytesRead;
            break;
          case TOK_EE:
            dh.dh(DhResult, state.esk, state.re);
            symmetricState.mixKey(state.symmetricState, DhResult);
            sodium_memzero(DhResult);
            break;
          case TOK_ES:
            if (state.role === INITIATOR) dh.dh(DhResult, state.esk, state.rs);
            else dh.dh(DhResult, state.ssk, state.re);
            symmetricState.mixKey(state.symmetricState, DhResult);
            sodium_memzero(DhResult);
            break;
          case TOK_SE:
            if (state.role === INITIATOR) dh.dh(DhResult, state.ssk, state.re);
            else dh.dh(DhResult, state.esk, state.rs);
            symmetricState.mixKey(state.symmetricState, DhResult);
            sodium_memzero(DhResult);
            break;
          case TOK_SS:
            dh.dh(DhResult, state.ssk, state.rs);
            symmetricState.mixKey(state.symmetricState, DhResult);
            sodium_memzero(DhResult);
            break;
          default:
            throw new Error("Invalid message pattern");
        }
      }
      symmetricState.decryptAndHash(state.symmetricState, payloadBuffer, message.subarray(moffset));
      readMessage.bytes = symmetricState.decryptAndHash.bytesWritten;
      if (state.messagePatterns.length === 0) {
        var tx = sodium_malloc(cipherState.STATELEN);
        var rx = sodium_malloc(cipherState.STATELEN);
        symmetricState.split(state.symmetricState, rx, tx);
        return { tx, rx };
      }
    }
    readMessage.bytes = 0;
    function destroy(state) {
      if (state.symmetricState != null) {
        sodium_free(state.symmetricState);
        state.symmetricState = null;
      }
      state.role = null;
      if (state.spk != null) {
        sodium_free(state.spk);
        state.spk = null;
      }
      if (state.ssk != null) {
        sodium_free(state.ssk);
        state.ssk = null;
      }
      if (state.epk != null) {
        sodium_free(state.epk);
        state.epk = null;
      }
      if (state.esk != null) {
        sodium_free(state.esk);
        state.esk = null;
      }
      if (state.rs != null) {
        sodium_free(state.rs);
        state.rs = null;
      }
      if (state.re != null) {
        sodium_free(state.re);
        state.re = null;
      }
      state.messagePatterns = null;
    }
    function keygen(obj, sk) {
      if (!obj) {
        obj = { publicKey: sodium_malloc(PKLEN), secretKey: sodium_malloc(SKLEN) };
        return keygen(obj);
      }
      if (obj.publicKey) {
        dh.generateKeypair(obj.publicKey, obj.secretKey);
        return obj;
      }
      if (obj.byteLength != null) dh.generateKeypair(null, obj);
    }
    function seedKeygen(seed) {
      var obj = { publicKey: sodium_malloc(PKLEN), secretKey: sodium_malloc(SKLEN) };
      dh.generateSeedKeypair(obj.publicKey, obj.secretKey, seed);
      return obj;
    }
    function toCharCode(s) {
      return s.charCodeAt(0);
    }
  }
});

// node_modules/.pnpm/noise-protocol@3.0.1/node_modules/noise-protocol/index.js
var require_noise_protocol = __commonJS({
  "node_modules/.pnpm/noise-protocol@3.0.1/node_modules/noise-protocol/index.js"(exports, module) {
    module.exports = require_handshake_state();
  }
});

// node_modules/.pnpm/simple-handshake@3.0.0/node_modules/simple-handshake/index.js
var require_simple_handshake = __commonJS({
  "node_modules/.pnpm/simple-handshake@3.0.0/node_modules/simple-handshake/index.js"(exports, module) {
    var noise = require_noise_protocol();
    var NoiseSymmetricState = require_symmetric_state();
    var NoiseHash = require_hash();
    var assert = require_nanoassert();
    var EMPTY = Buffer.alloc(0);
    function SimpleHandshake(isInitiator, opts) {
      if (!(this instanceof SimpleHandshake)) return new SimpleHandshake(isInitiator, opts);
      opts = opts || {};
      var pattern = opts.pattern || "NN";
      var prolouge = opts.prolouge || EMPTY;
      this.handshakeHash = null;
      this.onstatickey = opts.onstatickey || function(_, cb) {
        cb();
      };
      this.onephemeralkey = opts.onephemeralkey || function(_, cb) {
        cb();
      };
      this.onhandshake = opts.onhandshake || function(_, cb) {
        cb();
      };
      this.state = noise.initialize(
        pattern,
        isInitiator,
        prolouge,
        opts.staticKeyPair,
        opts.ephemeralKeyPair,
        opts.remoteStaticKey,
        opts.remoteEphemeralKey
      );
      this.waiting = isInitiator === false;
      this.finished = false;
      this.split = null;
      this._tx = Buffer.alloc(65535);
      this._rx = Buffer.alloc(65535);
    }
    SimpleHandshake.prototype.recv = function recv(data, cb) {
      var self = this;
      assert(self.finished === false, "Should not call recv if finished");
      assert(data != null, "must have data");
      assert(data.byteLength <= self._rx.byteLength, "too much data received");
      assert(self.waiting === true, "Wrong state, not ready to receive data");
      assert(self.split == null, "split should be null");
      var hasREBefore = self.state.re != null;
      var hasRSBefore = self.state.rs != null;
      try {
        self.split = noise.readMessage(self.state, data, self._rx);
      } catch (ex) {
        return self._finish(ex, null, cb);
      }
      self.waiting = false;
      var hasREAfter = self.state.re != null;
      var hasRSAfter = self.state.rs != null;
      if (hasREBefore === false && hasREAfter === true) {
        return self.onephemeralkey(self.state.re, checkStatic);
      }
      return checkStatic();
      function checkStatic(err) {
        if (err) return ondone(err);
        if (hasRSBefore === false && hasRSAfter === true) {
          return self.onstatickey(self.state.rs, ondone);
        }
        return ondone();
      }
      function ondone(err) {
        if (err) return self._finish(err, null, cb);
        var msg = self._rx.subarray(0, noise.readMessage.bytes);
        if (self.split) return self._finish(null, msg, cb);
        cb(null, msg);
      }
    };
    SimpleHandshake.prototype.send = function send(data, cb) {
      assert(this.finished === false, "Should not call send if finished");
      assert(this.waiting === false, "Wrong state, not ready to send data");
      assert(this.split == null, "split should be null");
      data = data || EMPTY;
      try {
        this.split = noise.writeMessage(this.state, data, this._tx);
      } catch (ex) {
        return this._finish(ex, null, cb);
      }
      this.waiting = true;
      var buf = this._tx.subarray(0, noise.writeMessage.bytes);
      if (this.split != null) return this._finish(null, buf, cb);
      return cb(null, buf);
    };
    SimpleHandshake.prototype.destroy = function() {
      this._finish(null, null, function() {
      });
    };
    SimpleHandshake.prototype._finish = function _finish(err, msg, cb) {
      assert(this.finished === false, "Already finished");
      const self = this;
      self.finished = true;
      self.waiting = false;
      if (self.split) {
        self.handshakeHash = Buffer.alloc(NoiseHash.HASHLEN);
        NoiseSymmetricState.getHandshakeHash(self.state.symmetricState, self.handshakeHash);
      }
      if (err) return ondone(err);
      self.onhandshake(self.state, ondone);
      function ondone(err2) {
        noise.destroy(self.state);
        cb(err2, msg, self.split);
        self._rx.fill(0);
        self._tx.fill(0);
      }
    };
    SimpleHandshake.keygen = noise.keygen;
    SimpleHandshake.seedKeygen = noise.seedKeygen;
    module.exports = SimpleHandshake;
  }
});

// node_modules/.pnpm/varint@5.0.2/node_modules/varint/encode.js
var require_encode2 = __commonJS({
  "node_modules/.pnpm/varint@5.0.2/node_modules/varint/encode.js"(exports, module) {
    module.exports = encode;
    var MSB = 128;
    var REST = 127;
    var MSBALL = ~REST;
    var INT = Math.pow(2, 31);
    function encode(num, out, offset) {
      out = out || [];
      offset = offset || 0;
      var oldOffset = offset;
      while (num >= INT) {
        out[offset++] = num & 255 | MSB;
        num /= 128;
      }
      while (num & MSBALL) {
        out[offset++] = num & 255 | MSB;
        num >>>= 7;
      }
      out[offset] = num | 0;
      encode.bytes = offset - oldOffset + 1;
      return out;
    }
  }
});

// node_modules/.pnpm/varint@5.0.2/node_modules/varint/decode.js
var require_decode2 = __commonJS({
  "node_modules/.pnpm/varint@5.0.2/node_modules/varint/decode.js"(exports, module) {
    module.exports = read;
    var MSB = 128;
    var REST = 127;
    function read(buf, offset) {
      var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
      do {
        if (counter >= l) {
          read.bytes = 0;
          throw new RangeError("Could not decode varint");
        }
        b = buf[counter++];
        res += shift < 28 ? (b & REST) << shift : (b & REST) * Math.pow(2, shift);
        shift += 7;
      } while (b >= MSB);
      read.bytes = counter - offset;
      return res;
    }
  }
});

// node_modules/.pnpm/varint@5.0.2/node_modules/varint/length.js
var require_length2 = __commonJS({
  "node_modules/.pnpm/varint@5.0.2/node_modules/varint/length.js"(exports, module) {
    var N1 = Math.pow(2, 7);
    var N2 = Math.pow(2, 14);
    var N3 = Math.pow(2, 21);
    var N4 = Math.pow(2, 28);
    var N5 = Math.pow(2, 35);
    var N6 = Math.pow(2, 42);
    var N7 = Math.pow(2, 49);
    var N8 = Math.pow(2, 56);
    var N9 = Math.pow(2, 63);
    module.exports = function(value) {
      return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
    };
  }
});

// node_modules/.pnpm/varint@5.0.2/node_modules/varint/index.js
var require_varint2 = __commonJS({
  "node_modules/.pnpm/varint@5.0.2/node_modules/varint/index.js"(exports, module) {
    module.exports = {
      encode: require_encode2(),
      decode: require_decode2(),
      encodingLength: require_length2()
    };
  }
});

// node_modules/.pnpm/simple-hypercore-protocol@2.1.2/node_modules/simple-hypercore-protocol/lib/handshake.js
var require_handshake = __commonJS({
  "node_modules/.pnpm/simple-hypercore-protocol@2.1.2/node_modules/simple-hypercore-protocol/lib/handshake.js"(exports, module) {
    var SH = require_simple_handshake();
    var DH = require_dh();
    var crypto = require_hypercore_crypto();
    var varint = require_varint2();
    module.exports = class ProtocolHandshake {
      constructor(initiator, payload, opts, done) {
        this.options = opts;
        this.ondone = done;
        this.buffer = null;
        this.length = 0;
        this.remotePayload = null;
        this.payload = payload;
        this.keyPair = opts.keyPair || ProtocolHandshake.keyPair();
        this.remotePublicKey = null;
        this.onrecv = onrecv.bind(this);
        this.onsend = onsend.bind(this);
        this.destroyed = false;
        this.noise = SH(initiator, {
          pattern: "XX",
          onhandshake,
          staticKeyPair: this.keyPair,
          onstatickey: onstatickey.bind(this)
        });
        const self = this;
        if (this.noise.waiting === false) process.nextTick(start, this);
        function onhandshake(state, cb) {
          process.nextTick(finish, self);
          cb(null);
        }
      }
      recv(data) {
        if (this.destroyed) return;
        if (this.buffer) this.buffer = Buffer.concat([this.buffer, data]);
        else this.buffer = data;
        while (!this.destroyed && !this.noise.finished) {
          if (!this.buffer || this.buffer.length < 3) return;
          if (this.length) {
            if (this.buffer.length < this.length) return;
            const message = this.buffer.slice(0, this.length);
            this.buffer = this.length < this.buffer.length ? this.buffer.slice(this.length) : null;
            this.length = 0;
            this.noise.recv(message, this.onrecv);
          } else {
            this.length = varint.decode(this.buffer, 0);
            this.buffer = this.buffer.slice(varint.decode.bytes);
          }
        }
      }
      destroy(err) {
        if (this.destroyed) return;
        this.destroyed = true;
        if (!this.noise.finished) this.noise.destroy();
        this.ondone(err);
      }
      static keyPair(seed) {
        const obj = {
          // suboptimal but to reduce secure memory overhead on linux with default settings
          // better fix is to batch mallocs in noise-protocol
          publicKey: Buffer.alloc(DH.PKLEN),
          secretKey: Buffer.alloc(DH.SKLEN)
        };
        if (seed) DH.generateSeedKeypair(obj.publicKey, obj.secretKey, seed);
        else DH.generateKeypair(obj.publicKey, obj.secretKey);
        return obj;
      }
    };
    function finish(self) {
      if (self.destroyed) return;
      self.destroyed = true;
      const split = { rx: Buffer.from(self.noise.split.rx), tx: Buffer.from(self.noise.split.tx) };
      crypto.free(self.noise.split.rx);
      crypto.free(self.noise.split.tx);
      self.ondone(null, self.remotePayload, split, self.buffer, self.remotePublicKey, self.noise.handshakeHash);
    }
    function start(self) {
      if (self.destroyed) return;
      self.noise.send(self.payload, self.onsend);
    }
    function onsend(err, data) {
      if (err) return this.destroy(err);
      const buf = Buffer.allocUnsafe(varint.encodingLength(data.length) + data.length);
      varint.encode(data.length, buf, 0);
      data.copy(buf, varint.encode.bytes);
      this.options.send(buf);
    }
    function onrecv(err, data) {
      if (err) return this.destroy(err);
      if (data && data.length) this.remotePayload = Buffer.from(data);
      if (this.destroyed || this.noise.finished) return;
      if (this.noise.waiting === false) {
        this.noise.send(this.payload, this.onsend);
      }
    }
    function onstatickey(remoteKey, done) {
      this.remotePublicKey = Buffer.from(remoteKey);
      if (this.options.onauthenticate) this.options.onauthenticate(this.remotePublicKey, done);
      else done(null);
    }
  }
});

// node_modules/.pnpm/varint@5.0.0/node_modules/varint/encode.js
var require_encode3 = __commonJS({
  "node_modules/.pnpm/varint@5.0.0/node_modules/varint/encode.js"(exports, module) {
    module.exports = encode;
    var MSB = 128;
    var REST = 127;
    var MSBALL = ~REST;
    var INT = Math.pow(2, 31);
    function encode(num, out, offset) {
      out = out || [];
      offset = offset || 0;
      var oldOffset = offset;
      while (num >= INT) {
        out[offset++] = num & 255 | MSB;
        num /= 128;
      }
      while (num & MSBALL) {
        out[offset++] = num & 255 | MSB;
        num >>>= 7;
      }
      out[offset] = num | 0;
      encode.bytes = offset - oldOffset + 1;
      return out;
    }
  }
});

// node_modules/.pnpm/varint@5.0.0/node_modules/varint/decode.js
var require_decode3 = __commonJS({
  "node_modules/.pnpm/varint@5.0.0/node_modules/varint/decode.js"(exports, module) {
    module.exports = read;
    var MSB = 128;
    var REST = 127;
    function read(buf, offset) {
      var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
      do {
        if (counter >= l) {
          read.bytes = 0;
          throw new RangeError("Could not decode varint");
        }
        b = buf[counter++];
        res += shift < 28 ? (b & REST) << shift : (b & REST) * Math.pow(2, shift);
        shift += 7;
      } while (b >= MSB);
      read.bytes = counter - offset;
      return res;
    }
  }
});

// node_modules/.pnpm/varint@5.0.0/node_modules/varint/length.js
var require_length3 = __commonJS({
  "node_modules/.pnpm/varint@5.0.0/node_modules/varint/length.js"(exports, module) {
    var N1 = Math.pow(2, 7);
    var N2 = Math.pow(2, 14);
    var N3 = Math.pow(2, 21);
    var N4 = Math.pow(2, 28);
    var N5 = Math.pow(2, 35);
    var N6 = Math.pow(2, 42);
    var N7 = Math.pow(2, 49);
    var N8 = Math.pow(2, 56);
    var N9 = Math.pow(2, 63);
    module.exports = function(value) {
      return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
    };
  }
});

// node_modules/.pnpm/varint@5.0.0/node_modules/varint/index.js
var require_varint3 = __commonJS({
  "node_modules/.pnpm/varint@5.0.0/node_modules/varint/index.js"(exports, module) {
    module.exports = {
      encode: require_encode3(),
      decode: require_decode3(),
      encodingLength: require_length3()
    };
  }
});

// node_modules/.pnpm/signed-varint@2.0.1/node_modules/signed-varint/index.js
var require_signed_varint = __commonJS({
  "node_modules/.pnpm/signed-varint@2.0.1/node_modules/signed-varint/index.js"(exports) {
    var varint = require_varint2();
    exports.encode = function encode(v, b, o) {
      v = v >= 0 ? v * 2 : v * -2 - 1;
      var r = varint.encode(v, b, o);
      encode.bytes = varint.encode.bytes;
      return r;
    };
    exports.decode = function decode(b, o) {
      var v = varint.decode(b, o);
      decode.bytes = varint.decode.bytes;
      return v & 1 ? (v + 1) / -2 : v / 2;
    };
    exports.encodingLength = function(v) {
      return varint.encodingLength(v >= 0 ? v * 2 : v * -2 - 1);
    };
  }
});

// node_modules/.pnpm/b4a@1.6.0/node_modules/b4a/lib/ascii.js
var require_ascii = __commonJS({
  "node_modules/.pnpm/b4a@1.6.0/node_modules/b4a/lib/ascii.js"(exports, module) {
    function byteLength(string) {
      return string.length;
    }
    function toString(buffer) {
      const len = buffer.byteLength;
      let result = "";
      for (let i = 0; i < len; i++) {
        result += String.fromCharCode(buffer[i]);
      }
      return result;
    }
    function write(buffer, string, offset = 0, length = byteLength(string)) {
      const len = Math.min(length, buffer.byteLength - offset);
      for (let i = 0; i < len; i++) {
        buffer[offset + i] = string.charCodeAt(i);
      }
      return len;
    }
    module.exports = {
      byteLength,
      toString,
      write
    };
  }
});

// node_modules/.pnpm/b4a@1.6.0/node_modules/b4a/lib/base64.js
var require_base64 = __commonJS({
  "node_modules/.pnpm/b4a@1.6.0/node_modules/b4a/lib/base64.js"(exports, module) {
    var alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    var codes = new Uint8Array(256);
    for (let i = 0; i < alphabet.length; i++) {
      codes[alphabet.charCodeAt(i)] = i;
    }
    codes[
      /* - */
      45
    ] = 62;
    codes[
      /* _ */
      95
    ] = 63;
    function byteLength(string) {
      let len = string.length;
      if (string.charCodeAt(len - 1) === 61) len--;
      if (len > 1 && string.charCodeAt(len - 1) === 61) len--;
      return len * 3 >>> 2;
    }
    function toString(buffer) {
      const len = buffer.byteLength;
      let result = "";
      for (let i = 0; i < len; i += 3) {
        result += alphabet[buffer[i] >> 2] + alphabet[(buffer[i] & 3) << 4 | buffer[i + 1] >> 4] + alphabet[(buffer[i + 1] & 15) << 2 | buffer[i + 2] >> 6] + alphabet[buffer[i + 2] & 63];
      }
      if (len % 3 === 2) {
        result = result.substring(0, result.length - 1) + "=";
      } else if (len % 3 === 1) {
        result = result.substring(0, result.length - 2) + "==";
      }
      return result;
    }
    function write(buffer, string, offset = 0, length = byteLength(string)) {
      const len = Math.min(length, buffer.byteLength - offset);
      for (let i = 0, j = 0; i < len; i += 4) {
        const a = codes[string.charCodeAt(i)];
        const b = codes[string.charCodeAt(i + 1)];
        const c = codes[string.charCodeAt(i + 2)];
        const d = codes[string.charCodeAt(i + 3)];
        buffer[j++] = a << 2 | b >> 4;
        buffer[j++] = (b & 15) << 4 | c >> 2;
        buffer[j++] = (c & 3) << 6 | d & 63;
      }
      return len;
    }
    module.exports = {
      byteLength,
      toString,
      write
    };
  }
});

// node_modules/.pnpm/b4a@1.6.0/node_modules/b4a/lib/hex.js
var require_hex = __commonJS({
  "node_modules/.pnpm/b4a@1.6.0/node_modules/b4a/lib/hex.js"(exports, module) {
    function byteLength(string) {
      return string.length >>> 1;
    }
    function toString(buffer) {
      const len = buffer.byteLength;
      buffer = new DataView(buffer.buffer, buffer.byteOffset, len);
      let result = "";
      let i = 0;
      for (let n = len - len % 4; i < n; i += 4) {
        result += buffer.getUint32(i).toString(16).padStart(8, "0");
      }
      for (; i < len; i++) {
        result += buffer.getUint8(i).toString(16).padStart(2, "0");
      }
      return result;
    }
    function write(buffer, string, offset = 0, length = byteLength(string)) {
      const len = Math.min(length, buffer.byteLength - offset);
      for (let i = 0; i < len; i++) {
        const a = hexValue(string.charCodeAt(i * 2));
        const b = hexValue(string.charCodeAt(i * 2 + 1));
        if (a === void 0 || b === void 0) {
          return buffer.subarray(0, i);
        }
        buffer[offset + i] = a << 4 | b;
      }
      return len;
    }
    module.exports = {
      byteLength,
      toString,
      write
    };
    function hexValue(char) {
      if (char >= 48 && char <= 57) return char - 48;
      if (char >= 65 && char <= 70) return char - 65 + 10;
      if (char >= 97 && char <= 102) return char - 97 + 10;
    }
  }
});

// node_modules/.pnpm/b4a@1.6.0/node_modules/b4a/lib/utf8.js
var require_utf8 = __commonJS({
  "node_modules/.pnpm/b4a@1.6.0/node_modules/b4a/lib/utf8.js"(exports, module) {
    function byteLength(string) {
      let length = 0;
      for (let i = 0, n = string.length; i < n; i++) {
        const code = string.charCodeAt(i);
        if (code >= 55296 && code <= 56319 && i + 1 < n) {
          const code2 = string.charCodeAt(i + 1);
          if (code2 >= 56320 && code2 <= 57343) {
            length += 4;
            i++;
            continue;
          }
        }
        if (code <= 127) length += 1;
        else if (code <= 2047) length += 2;
        else length += 3;
      }
      return length;
    }
    var toString;
    if (typeof TextDecoder !== "undefined") {
      const decoder = new TextDecoder();
      toString = function toString2(buffer) {
        return decoder.decode(buffer);
      };
    } else {
      toString = function toString2(buffer) {
        const len = buffer.byteLength;
        let output = "";
        let i = 0;
        while (i < len) {
          let byte = buffer[i];
          if (byte <= 127) {
            output += String.fromCharCode(byte);
            i++;
            continue;
          }
          let bytesNeeded = 0;
          let codePoint = 0;
          if (byte <= 223) {
            bytesNeeded = 1;
            codePoint = byte & 31;
          } else if (byte <= 239) {
            bytesNeeded = 2;
            codePoint = byte & 15;
          } else if (byte <= 244) {
            bytesNeeded = 3;
            codePoint = byte & 7;
          }
          if (len - i - bytesNeeded > 0) {
            let k = 0;
            while (k < bytesNeeded) {
              byte = buffer[i + k + 1];
              codePoint = codePoint << 6 | byte & 63;
              k += 1;
            }
          } else {
            codePoint = 65533;
            bytesNeeded = len - i;
          }
          output += String.fromCodePoint(codePoint);
          i += bytesNeeded + 1;
        }
        return output;
      };
    }
    var write;
    if (typeof TextEncoder !== "undefined") {
      const encoder = new TextEncoder();
      write = function write2(buffer, string, offset = 0, length = byteLength(string)) {
        const len = Math.min(length, buffer.byteLength - offset);
        encoder.encodeInto(string, buffer.subarray(offset, offset + len));
        return len;
      };
    } else {
      write = function write2(buffer, string, offset = 0, length = byteLength(string)) {
        const len = Math.min(length, buffer.byteLength - offset);
        buffer = buffer.subarray(offset, offset + len);
        let i = 0;
        let j = 0;
        while (i < string.length) {
          const code = string.codePointAt(i);
          if (code <= 127) {
            buffer[j++] = code;
            i++;
            continue;
          }
          let count = 0;
          let bits = 0;
          if (code <= 2047) {
            count = 6;
            bits = 192;
          } else if (code <= 65535) {
            count = 12;
            bits = 224;
          } else if (code <= 2097151) {
            count = 18;
            bits = 240;
          }
          buffer[j++] = bits | code >> count;
          count -= 6;
          while (count >= 0) {
            buffer[j++] = 128 | code >> count & 63;
            count -= 6;
          }
          i += code >= 65536 ? 2 : 1;
        }
        return len;
      };
    }
    module.exports = {
      byteLength,
      toString,
      write
    };
  }
});

// node_modules/.pnpm/b4a@1.6.0/node_modules/b4a/lib/utf16le.js
var require_utf16le = __commonJS({
  "node_modules/.pnpm/b4a@1.6.0/node_modules/b4a/lib/utf16le.js"(exports, module) {
    function byteLength(string) {
      return string.length * 2;
    }
    function toString(buffer) {
      const len = buffer.byteLength;
      let result = "";
      for (let i = 0; i < len - 1; i += 2) {
        result += String.fromCharCode(buffer[i] + buffer[i + 1] * 256);
      }
      return result;
    }
    function write(buffer, string, offset = 0, length = byteLength(string)) {
      const len = Math.min(length, buffer.byteLength - offset);
      let units = len;
      for (let i = 0; i < string.length; ++i) {
        if ((units -= 2) < 0) break;
        const c = string.charCodeAt(i);
        const hi = c >> 8;
        const lo = c % 256;
        buffer[offset + i * 2] = lo;
        buffer[offset + i * 2 + 1] = hi;
      }
      return len;
    }
    module.exports = {
      byteLength,
      toString,
      write
    };
  }
});

// node_modules/.pnpm/b4a@1.6.0/node_modules/b4a/browser.js
var require_browser2 = __commonJS({
  "node_modules/.pnpm/b4a@1.6.0/node_modules/b4a/browser.js"(exports, module) {
    var ascii = require_ascii();
    var base64 = require_base64();
    var hex = require_hex();
    var utf8 = require_utf8();
    var utf16le = require_utf16le();
    var LE = new Uint8Array(Uint16Array.of(255).buffer)[0] === 255;
    function codecFor(encoding) {
      switch (encoding) {
        case "ascii":
          return ascii;
        case "base64":
          return base64;
        case "hex":
          return hex;
        case "utf8":
        case "utf-8":
        case void 0:
          return utf8;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16le;
        default:
          throw new Error(`Unknown encoding: ${encoding}`);
      }
    }
    function isBuffer(value) {
      return value instanceof Uint8Array;
    }
    function isEncoding(encoding) {
      try {
        codecFor(encoding);
        return true;
      } catch {
        return false;
      }
    }
    function alloc(size, fill2, encoding) {
      const buffer = new Uint8Array(size);
      if (fill2 !== void 0) fill2(buffer, fill2, 0, buffer.byteLength, encoding);
      return buffer;
    }
    function allocUnsafe(size) {
      return new Uint8Array(size);
    }
    function allocUnsafeSlow(size) {
      return new Uint8Array(size);
    }
    function byteLength(string, encoding) {
      return codecFor(encoding).byteLength(string);
    }
    function compare(a, b) {
      if (a === b) return 0;
      const len = Math.min(a.byteLength, b.byteLength);
      a = new DataView(a.buffer, a.byteOffset, a.byteLength);
      b = new DataView(b.buffer, b.byteOffset, b.byteLength);
      let i = 0;
      for (let n = len - len % 4; i < n; i += 4) {
        const x = a.getUint32(i, LE);
        const y = b.getUint32(i, LE);
        if (x !== y) break;
      }
      for (; i < len; i++) {
        const x = a.getUint8(i);
        const y = b.getUint8(i);
        if (x < y) return -1;
        if (x > y) return 1;
      }
      return a.byteLength > b.byteLength ? 1 : a.byteLength < b.byteLength ? -1 : 0;
    }
    function concat(buffers, totalLength) {
      if (totalLength === void 0) {
        totalLength = buffers.reduce((len, buffer) => len + buffer.byteLength, 0);
      }
      const result = new Uint8Array(totalLength);
      buffers.reduce(
        (offset, buffer) => {
          result.set(buffer, offset);
          return offset + buffer.byteLength;
        },
        0
      );
      return result;
    }
    function copy(source, target, targetStart = 0, start = 0, end = source.byteLength) {
      if (end > 0 && end < start) return 0;
      if (end === start) return 0;
      if (source.byteLength === 0 || target.byteLength === 0) return 0;
      if (targetStart < 0) throw new RangeError("targetStart is out of range");
      if (start < 0 || start >= source.byteLength) throw new RangeError("sourceStart is out of range");
      if (end < 0) throw new RangeError("sourceEnd is out of range");
      if (targetStart >= target.byteLength) targetStart = target.byteLength;
      if (end > source.byteLength) end = source.byteLength;
      if (target.byteLength - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (source === target) {
        target.copyWithin(targetStart, start, end);
      } else {
        target.set(source.subarray(start, end), targetStart);
      }
      return len;
    }
    function equals(a, b) {
      if (a === b) return true;
      if (a.byteLength !== b.byteLength) return false;
      const len = a.byteLength;
      a = new DataView(a.buffer, a.byteOffset, a.byteLength);
      b = new DataView(b.buffer, b.byteOffset, b.byteLength);
      let i = 0;
      for (let n = len - len % 4; i < n; i += 4) {
        if (a.getUint32(i, LE) !== b.getUint32(i, LE)) return false;
      }
      for (; i < len; i++) {
        if (a.getUint8(i) !== b.getUint8(i)) return false;
      }
      return true;
    }
    function fill(buffer, value, offset, end, encoding) {
      if (typeof value === "string") {
        if (typeof offset === "string") {
          encoding = offset;
          offset = 0;
          end = buffer.byteLength;
        } else if (typeof end === "string") {
          encoding = end;
          end = buffer.byteLength;
        }
      } else if (typeof val === "number") {
        value = value & 255;
      } else if (typeof val === "boolean") {
        value = +value;
      }
      if (offset < 0 || buffer.byteLength < offset || buffer.byteLength < end) {
        throw new RangeError("Out of range index");
      }
      if (offset === void 0) offset = 0;
      if (end === void 0) end = buffer.byteLength;
      if (end <= offset) return buffer;
      if (!value) value = 0;
      if (typeof value === "number") {
        for (let i = offset; i < end; ++i) {
          buffer[i] = value;
        }
      } else {
        value = isBuffer(value) ? value : from(value, encoding);
        const len = value.byteLength;
        for (let i = 0; i < end - offset; ++i) {
          buffer[i + offset] = value[i % len];
        }
      }
      return buffer;
    }
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") return fromString(value, encodingOrOffset);
      if (Array.isArray(value)) return fromArray(value);
      if (ArrayBuffer.isView(value)) return fromBuffer(value);
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    function fromString(string, encoding) {
      const codec = codecFor(encoding);
      const buffer = new Uint8Array(codec.byteLength(string));
      codec.write(buffer, string, 0, buffer.byteLength);
      return buffer;
    }
    function fromArray(array) {
      const buffer = new Uint8Array(array.length);
      buffer.set(array);
      return buffer;
    }
    function fromBuffer(buffer) {
      const copy2 = new Uint8Array(buffer.byteLength);
      copy2.set(buffer);
      return copy2;
    }
    function fromArrayBuffer(arrayBuffer, byteOffset, length) {
      return new Uint8Array(arrayBuffer, byteOffset, length);
    }
    function includes(buffer, value, byteOffset, encoding) {
      return indexOf(buffer, value, byteOffset, encoding) !== -1;
    }
    function bidirectionalIndexOf(buffer, value, byteOffset, encoding, first) {
      if (buffer.byteLength === 0) return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset === void 0) {
        byteOffset = first ? 0 : buffer.length - 1;
      } else if (byteOffset < 0) {
        byteOffset += buffer.byteLength;
      }
      if (byteOffset >= buffer.byteLength) {
        if (first) return -1;
        else byteOffset = buffer.byteLength - 1;
      } else if (byteOffset < 0) {
        if (first) byteOffset = 0;
        else return -1;
      }
      if (typeof value === "string") {
        value = from(value, encoding);
      } else if (typeof value === "number") {
        value = value & 255;
        if (first) {
          return buffer.indexOf(value, byteOffset);
        } else {
          return buffer.lastIndexOf(value, byteOffset);
        }
      }
      if (value.byteLength === 0) return -1;
      if (first) {
        let foundIndex = -1;
        for (let i = byteOffset; i < buffer.byteLength; i++) {
          if (buffer[i] === value[foundIndex === -1 ? 0 : i - foundIndex]) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === value.byteLength) return foundIndex;
          } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + value.byteLength > buffer.byteLength) {
          byteOffset = buffer.byteLength - value.byteLength;
        }
        for (let i = byteOffset; i >= 0; i--) {
          let found = true;
          for (let j = 0; j < value.byteLength; j++) {
            if (buffer[i + j] !== value[j]) {
              found = false;
              break;
            }
          }
          if (found) return i;
        }
      }
      return -1;
    }
    function indexOf(buffer, value, byteOffset, encoding) {
      return bidirectionalIndexOf(
        buffer,
        value,
        byteOffset,
        encoding,
        true
        /* first */
      );
    }
    function lastIndexOf(buffer, value, byteOffset, encoding) {
      return bidirectionalIndexOf(
        buffer,
        value,
        byteOffset,
        encoding,
        false
        /* last */
      );
    }
    function swap(buffer, n, m) {
      const i = buffer[n];
      buffer[n] = buffer[m];
      buffer[m] = i;
    }
    function swap16(buffer) {
      const len = buffer.byteLength;
      if (len % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (let i = 0; i < len; i += 2) swap(buffer, i, i + 1);
      return buffer;
    }
    function swap32(buffer) {
      const len = buffer.byteLength;
      if (len % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (let i = 0; i < len; i += 4) {
        swap(buffer, i, i + 3);
        swap(buffer, i + 1, i + 2);
      }
      return buffer;
    }
    function swap64(buffer) {
      const len = buffer.byteLength;
      if (len % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (let i = 0; i < len; i += 8) {
        swap(buffer, i, i + 7);
        swap(buffer, i + 1, i + 6);
        swap(buffer, i + 2, i + 5);
        swap(buffer, i + 3, i + 4);
      }
      return buffer;
    }
    function toBuffer(buffer) {
      return buffer;
    }
    function toString(buffer, encoding, start = 0, end = buffer.byteLength) {
      const len = buffer.byteLength;
      if (start >= len) return "";
      if (end <= start) return "";
      if (start < 0) start = 0;
      if (end > len) end = len;
      if (start !== 0 || end < len) buffer = buffer.subarray(start, end);
      return codecFor(encoding).toString(buffer);
    }
    function write(buffer, string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        offset = void 0;
      } else if (encoding === void 0 && typeof length === "string") {
        encoding = length;
        length = void 0;
      }
      return codecFor(encoding).write(buffer, string, offset, length);
    }
    function writeDoubleLE(buffer, value, offset) {
      if (offset === void 0) offset = 0;
      const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
      view.setFloat64(offset, value, true);
      return offset + 8;
    }
    function writeFloatLE(buffer, value, offset) {
      if (offset === void 0) offset = 0;
      const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
      view.setFloat32(offset, value, true);
      return offset + 4;
    }
    function writeUInt32LE(buffer, value, offset) {
      if (offset === void 0) offset = 0;
      const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
      view.setUint32(offset, value, true);
      return offset + 4;
    }
    function writeInt32LE(buffer, value, offset) {
      if (offset === void 0) offset = 0;
      const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
      view.setInt32(offset, value, true);
      return offset + 4;
    }
    function readDoubleLE(buffer, offset) {
      if (offset === void 0) offset = 0;
      const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
      return view.getFloat64(offset, true);
    }
    function readFloatLE(buffer, offset) {
      if (offset === void 0) offset = 0;
      const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
      return view.getFloat32(offset, true);
    }
    function readUInt32LE(buffer, offset) {
      if (offset === void 0) offset = 0;
      const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
      return view.getUint32(offset, true);
    }
    function readInt32LE(buffer, offset) {
      if (offset === void 0) offset = 0;
      const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
      return view.getInt32(offset, true);
    }
    module.exports = {
      isBuffer,
      isEncoding,
      alloc,
      allocUnsafe,
      allocUnsafeSlow,
      byteLength,
      compare,
      concat,
      copy,
      equals,
      fill,
      from,
      includes,
      indexOf,
      lastIndexOf,
      swap16,
      swap32,
      swap64,
      toBuffer,
      toString,
      write,
      writeDoubleLE,
      writeFloatLE,
      writeUInt32LE,
      writeInt32LE,
      readDoubleLE,
      readFloatLE,
      readUInt32LE,
      readInt32LE
    };
  }
});

// node_modules/.pnpm/protocol-buffers-encodings@1.2.0/node_modules/protocol-buffers-encodings/index.js
var require_protocol_buffers_encodings = __commonJS({
  "node_modules/.pnpm/protocol-buffers-encodings@1.2.0/node_modules/protocol-buffers-encodings/index.js"(exports) {
    var varint = require_varint3();
    var svarint = require_signed_varint();
    var b4a = require_browser2();
    exports.make = encoder;
    exports.name = function(enc) {
      var keys = Object.keys(exports);
      for (var i = 0; i < keys.length; i++) {
        if (exports[keys[i]] === enc) return keys[i];
      }
      return null;
    };
    exports.skip = function(type, buffer, offset) {
      switch (type) {
        case 0:
          varint.decode(buffer, offset);
          return offset + varint.decode.bytes;
        case 1:
          return offset + 8;
        case 2:
          var len = varint.decode(buffer, offset);
          return offset + varint.decode.bytes + len;
        case 3:
        case 4:
          throw new Error("Groups are not supported");
        case 5:
          return offset + 4;
      }
      throw new Error("Unknown wire type: " + type);
    };
    exports.bytes = encoder(
      2,
      function encode(val2, buffer, offset) {
        var oldOffset = offset;
        var len = bufferLength(val2);
        varint.encode(len, buffer, offset);
        offset += varint.encode.bytes;
        if (b4a.isBuffer(val2)) b4a.copy(val2, buffer, offset);
        else b4a.write(buffer, val2, offset, len);
        offset += len;
        encode.bytes = offset - oldOffset;
        return buffer;
      },
      function decode(buffer, offset) {
        var oldOffset = offset;
        var len = varint.decode(buffer, offset);
        offset += varint.decode.bytes;
        var val2 = buffer.subarray(offset, offset + len);
        offset += val2.length;
        decode.bytes = offset - oldOffset;
        return val2;
      },
      function encodingLength(val2) {
        var len = bufferLength(val2);
        return varint.encodingLength(len) + len;
      }
    );
    exports.string = encoder(
      2,
      function encode(val2, buffer, offset) {
        var oldOffset = offset;
        var len = b4a.byteLength(val2);
        varint.encode(len, buffer, offset, "utf-8");
        offset += varint.encode.bytes;
        b4a.write(buffer, val2, offset, len);
        offset += len;
        encode.bytes = offset - oldOffset;
        return buffer;
      },
      function decode(buffer, offset) {
        var oldOffset = offset;
        var len = varint.decode(buffer, offset);
        offset += varint.decode.bytes;
        var val2 = b4a.toString(buffer, "utf-8", offset, offset + len);
        offset += len;
        decode.bytes = offset - oldOffset;
        return val2;
      },
      function encodingLength(val2) {
        var len = b4a.byteLength(val2);
        return varint.encodingLength(len) + len;
      }
    );
    exports.bool = encoder(
      0,
      function encode(val2, buffer, offset) {
        buffer[offset] = val2 ? 1 : 0;
        encode.bytes = 1;
        return buffer;
      },
      function decode(buffer, offset) {
        var bool = buffer[offset] > 0;
        decode.bytes = 1;
        return bool;
      },
      function encodingLength() {
        return 1;
      }
    );
    exports.int32 = encoder(
      0,
      function encode(val2, buffer, offset) {
        varint.encode(val2 < 0 ? val2 + 4294967296 : val2, buffer, offset);
        encode.bytes = varint.encode.bytes;
        return buffer;
      },
      function decode(buffer, offset) {
        var val2 = varint.decode(buffer, offset);
        decode.bytes = varint.decode.bytes;
        return val2 > 2147483647 ? val2 - 4294967296 : val2;
      },
      function encodingLength(val2) {
        return varint.encodingLength(val2 < 0 ? val2 + 4294967296 : val2);
      }
    );
    exports.int64 = encoder(
      0,
      function encode(val2, buffer, offset) {
        if (val2 < 0) {
          var last = offset + 9;
          varint.encode(val2 * -1, buffer, offset);
          offset += varint.encode.bytes - 1;
          buffer[offset] = buffer[offset] | 128;
          while (offset < last - 1) {
            offset++;
            buffer[offset] = 255;
          }
          buffer[last] = 1;
          encode.bytes = 10;
        } else {
          varint.encode(val2, buffer, offset);
          encode.bytes = varint.encode.bytes;
        }
        return buffer;
      },
      function decode(buffer, offset) {
        var val2 = varint.decode(buffer, offset);
        if (val2 >= Math.pow(2, 63)) {
          var limit = 9;
          while (buffer[offset + limit - 1] === 255) limit--;
          limit = limit || 9;
          var subset = b4a.allocUnsafe(limit);
          b4a.copy(buffer, subset, 0, offset, offset + limit);
          subset[limit - 1] = subset[limit - 1] & 127;
          val2 = -1 * varint.decode(subset, 0);
          decode.bytes = 10;
        } else {
          decode.bytes = varint.decode.bytes;
        }
        return val2;
      },
      function encodingLength(val2) {
        return val2 < 0 ? 10 : varint.encodingLength(val2);
      }
    );
    exports.sint32 = exports.sint64 = encoder(
      0,
      svarint.encode,
      svarint.decode,
      svarint.encodingLength
    );
    exports.uint32 = exports.uint64 = exports.enum = exports.varint = encoder(
      0,
      varint.encode,
      varint.decode,
      varint.encodingLength
    );
    exports.fixed64 = exports.sfixed64 = encoder(
      1,
      function encode(val2, buffer, offset) {
        b4a.copy(val2, buffer, offset);
        encode.bytes = 8;
        return buffer;
      },
      function decode(buffer, offset) {
        var val2 = buffer.subarray(offset, offset + 8);
        decode.bytes = 8;
        return val2;
      },
      function encodingLength() {
        return 8;
      }
    );
    exports.double = encoder(
      1,
      function encode(val2, buffer, offset) {
        b4a.writeDoubleLE(buffer, val2, offset);
        encode.bytes = 8;
        return buffer;
      },
      function decode(buffer, offset) {
        var val2 = b4a.readDoubleLE(buffer, offset);
        decode.bytes = 8;
        return val2;
      },
      function encodingLength() {
        return 8;
      }
    );
    exports.fixed32 = encoder(
      5,
      function encode(val2, buffer, offset) {
        b4a.writeUInt32LE(buffer, val2, offset);
        encode.bytes = 4;
        return buffer;
      },
      function decode(buffer, offset) {
        var val2 = b4a.readUInt32LE(buffer, offset);
        decode.bytes = 4;
        return val2;
      },
      function encodingLength() {
        return 4;
      }
    );
    exports.sfixed32 = encoder(
      5,
      function encode(val2, buffer, offset) {
        b4a.writeInt32LE(buffer, val2, offset);
        encode.bytes = 4;
        return buffer;
      },
      function decode(buffer, offset) {
        var val2 = b4a.readInt32LE(buffer, offset);
        decode.bytes = 4;
        return val2;
      },
      function encodingLength() {
        return 4;
      }
    );
    exports.float = encoder(
      5,
      function encode(val2, buffer, offset) {
        b4a.writeFloatLE(buffer, val2, offset);
        encode.bytes = 4;
        return buffer;
      },
      function decode(buffer, offset) {
        var val2 = b4a.readFloatLE(buffer, offset);
        decode.bytes = 4;
        return val2;
      },
      function encodingLength() {
        return 4;
      }
    );
    function encoder(type, encode, decode, encodingLength) {
      encode.bytes = decode.bytes = 0;
      return {
        type,
        encode,
        decode,
        encodingLength
      };
    }
    function bufferLength(val2) {
      return b4a.isBuffer(val2) ? val2.length : b4a.byteLength(val2);
    }
  }
});

// node_modules/.pnpm/simple-hypercore-protocol@2.1.2/node_modules/simple-hypercore-protocol/messages.js
var require_messages = __commonJS({
  "node_modules/.pnpm/simple-hypercore-protocol@2.1.2/node_modules/simple-hypercore-protocol/messages.js"(exports) {
    var encodings = require_protocol_buffers_encodings();
    var varint = encodings.varint;
    var skip = encodings.skip;
    var NoisePayload = exports.NoisePayload = {
      buffer: true,
      encodingLength: null,
      encode: null,
      decode: null
    };
    var Open = exports.Open = {
      buffer: true,
      encodingLength: null,
      encode: null,
      decode: null
    };
    var Options = exports.Options = {
      buffer: true,
      encodingLength: null,
      encode: null,
      decode: null
    };
    var Status = exports.Status = {
      buffer: true,
      encodingLength: null,
      encode: null,
      decode: null
    };
    var Have = exports.Have = {
      buffer: true,
      encodingLength: null,
      encode: null,
      decode: null
    };
    var Unhave = exports.Unhave = {
      buffer: true,
      encodingLength: null,
      encode: null,
      decode: null
    };
    var Want = exports.Want = {
      buffer: true,
      encodingLength: null,
      encode: null,
      decode: null
    };
    var Unwant = exports.Unwant = {
      buffer: true,
      encodingLength: null,
      encode: null,
      decode: null
    };
    var Request = exports.Request = {
      buffer: true,
      encodingLength: null,
      encode: null,
      decode: null
    };
    var Cancel = exports.Cancel = {
      buffer: true,
      encodingLength: null,
      encode: null,
      decode: null
    };
    var Data = exports.Data = {
      buffer: true,
      encodingLength: null,
      encode: null,
      decode: null
    };
    var Close = exports.Close = {
      buffer: true,
      encodingLength: null,
      encode: null,
      decode: null
    };
    defineNoisePayload();
    defineOpen();
    defineOptions();
    defineStatus();
    defineHave();
    defineUnhave();
    defineWant();
    defineUnwant();
    defineRequest();
    defineCancel();
    defineData();
    defineClose();
    function defineNoisePayload() {
      var enc = [
        encodings.bytes
      ];
      NoisePayload.encodingLength = encodingLength;
      NoisePayload.encode = encode;
      NoisePayload.decode = decode;
      function encodingLength(obj) {
        var length = 0;
        if (!defined(obj.nonce)) throw new Error("nonce is required");
        var len = enc[0].encodingLength(obj.nonce);
        length += 1 + len;
        return length;
      }
      function encode(obj, buf, offset) {
        if (!offset) offset = 0;
        if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj));
        var oldOffset = offset;
        if (!defined(obj.nonce)) throw new Error("nonce is required");
        buf[offset++] = 10;
        enc[0].encode(obj.nonce, buf, offset);
        offset += enc[0].encode.bytes;
        encode.bytes = offset - oldOffset;
        return buf;
      }
      function decode(buf, offset, end) {
        if (!offset) offset = 0;
        if (!end) end = buf.length;
        if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid");
        var oldOffset = offset;
        var obj = {
          nonce: null
        };
        var found0 = false;
        while (true) {
          if (end <= offset) {
            if (!found0) throw new Error("Decoded message is not valid");
            decode.bytes = offset - oldOffset;
            return obj;
          }
          var prefix = varint.decode(buf, offset);
          offset += varint.decode.bytes;
          var tag = prefix >> 3;
          switch (tag) {
            case 1:
              obj.nonce = enc[0].decode(buf, offset);
              offset += enc[0].decode.bytes;
              found0 = true;
              break;
            default:
              offset = skip(prefix & 7, buf, offset);
          }
        }
      }
    }
    function defineOpen() {
      var enc = [
        encodings.bytes
      ];
      Open.encodingLength = encodingLength;
      Open.encode = encode;
      Open.decode = decode;
      function encodingLength(obj) {
        var length = 0;
        if (!defined(obj.discoveryKey)) throw new Error("discoveryKey is required");
        var len = enc[0].encodingLength(obj.discoveryKey);
        length += 1 + len;
        if (defined(obj.capability)) {
          var len = enc[0].encodingLength(obj.capability);
          length += 1 + len;
        }
        return length;
      }
      function encode(obj, buf, offset) {
        if (!offset) offset = 0;
        if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj));
        var oldOffset = offset;
        if (!defined(obj.discoveryKey)) throw new Error("discoveryKey is required");
        buf[offset++] = 10;
        enc[0].encode(obj.discoveryKey, buf, offset);
        offset += enc[0].encode.bytes;
        if (defined(obj.capability)) {
          buf[offset++] = 18;
          enc[0].encode(obj.capability, buf, offset);
          offset += enc[0].encode.bytes;
        }
        encode.bytes = offset - oldOffset;
        return buf;
      }
      function decode(buf, offset, end) {
        if (!offset) offset = 0;
        if (!end) end = buf.length;
        if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid");
        var oldOffset = offset;
        var obj = {
          discoveryKey: null,
          capability: null
        };
        var found0 = false;
        while (true) {
          if (end <= offset) {
            if (!found0) throw new Error("Decoded message is not valid");
            decode.bytes = offset - oldOffset;
            return obj;
          }
          var prefix = varint.decode(buf, offset);
          offset += varint.decode.bytes;
          var tag = prefix >> 3;
          switch (tag) {
            case 1:
              obj.discoveryKey = enc[0].decode(buf, offset);
              offset += enc[0].decode.bytes;
              found0 = true;
              break;
            case 2:
              obj.capability = enc[0].decode(buf, offset);
              offset += enc[0].decode.bytes;
              break;
            default:
              offset = skip(prefix & 7, buf, offset);
          }
        }
      }
    }
    function defineOptions() {
      var enc = [
        encodings.string,
        encodings.bool
      ];
      Options.encodingLength = encodingLength;
      Options.encode = encode;
      Options.decode = decode;
      function encodingLength(obj) {
        var length = 0;
        if (defined(obj.extensions)) {
          for (var i = 0; i < obj.extensions.length; i++) {
            if (!defined(obj.extensions[i])) continue;
            var len = enc[0].encodingLength(obj.extensions[i]);
            length += 1 + len;
          }
        }
        if (defined(obj.ack)) {
          var len = enc[1].encodingLength(obj.ack);
          length += 1 + len;
        }
        return length;
      }
      function encode(obj, buf, offset) {
        if (!offset) offset = 0;
        if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj));
        var oldOffset = offset;
        if (defined(obj.extensions)) {
          for (var i = 0; i < obj.extensions.length; i++) {
            if (!defined(obj.extensions[i])) continue;
            buf[offset++] = 10;
            enc[0].encode(obj.extensions[i], buf, offset);
            offset += enc[0].encode.bytes;
          }
        }
        if (defined(obj.ack)) {
          buf[offset++] = 16;
          enc[1].encode(obj.ack, buf, offset);
          offset += enc[1].encode.bytes;
        }
        encode.bytes = offset - oldOffset;
        return buf;
      }
      function decode(buf, offset, end) {
        if (!offset) offset = 0;
        if (!end) end = buf.length;
        if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid");
        var oldOffset = offset;
        var obj = {
          extensions: [],
          ack: false
        };
        while (true) {
          if (end <= offset) {
            decode.bytes = offset - oldOffset;
            return obj;
          }
          var prefix = varint.decode(buf, offset);
          offset += varint.decode.bytes;
          var tag = prefix >> 3;
          switch (tag) {
            case 1:
              obj.extensions.push(enc[0].decode(buf, offset));
              offset += enc[0].decode.bytes;
              break;
            case 2:
              obj.ack = enc[1].decode(buf, offset);
              offset += enc[1].decode.bytes;
              break;
            default:
              offset = skip(prefix & 7, buf, offset);
          }
        }
      }
    }
    function defineStatus() {
      var enc = [
        encodings.bool
      ];
      Status.encodingLength = encodingLength;
      Status.encode = encode;
      Status.decode = decode;
      function encodingLength(obj) {
        var length = 0;
        if (defined(obj.uploading)) {
          var len = enc[0].encodingLength(obj.uploading);
          length += 1 + len;
        }
        if (defined(obj.downloading)) {
          var len = enc[0].encodingLength(obj.downloading);
          length += 1 + len;
        }
        return length;
      }
      function encode(obj, buf, offset) {
        if (!offset) offset = 0;
        if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj));
        var oldOffset = offset;
        if (defined(obj.uploading)) {
          buf[offset++] = 8;
          enc[0].encode(obj.uploading, buf, offset);
          offset += enc[0].encode.bytes;
        }
        if (defined(obj.downloading)) {
          buf[offset++] = 16;
          enc[0].encode(obj.downloading, buf, offset);
          offset += enc[0].encode.bytes;
        }
        encode.bytes = offset - oldOffset;
        return buf;
      }
      function decode(buf, offset, end) {
        if (!offset) offset = 0;
        if (!end) end = buf.length;
        if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid");
        var oldOffset = offset;
        var obj = {
          uploading: false,
          downloading: false
        };
        while (true) {
          if (end <= offset) {
            decode.bytes = offset - oldOffset;
            return obj;
          }
          var prefix = varint.decode(buf, offset);
          offset += varint.decode.bytes;
          var tag = prefix >> 3;
          switch (tag) {
            case 1:
              obj.uploading = enc[0].decode(buf, offset);
              offset += enc[0].decode.bytes;
              break;
            case 2:
              obj.downloading = enc[0].decode(buf, offset);
              offset += enc[0].decode.bytes;
              break;
            default:
              offset = skip(prefix & 7, buf, offset);
          }
        }
      }
    }
    function defineHave() {
      var enc = [
        encodings.varint,
        encodings.bytes,
        encodings.bool
      ];
      Have.encodingLength = encodingLength;
      Have.encode = encode;
      Have.decode = decode;
      function encodingLength(obj) {
        var length = 0;
        if (!defined(obj.start)) throw new Error("start is required");
        var len = enc[0].encodingLength(obj.start);
        length += 1 + len;
        if (defined(obj.length)) {
          var len = enc[0].encodingLength(obj.length);
          length += 1 + len;
        }
        if (defined(obj.bitfield)) {
          var len = enc[1].encodingLength(obj.bitfield);
          length += 1 + len;
        }
        if (defined(obj.ack)) {
          var len = enc[2].encodingLength(obj.ack);
          length += 1 + len;
        }
        return length;
      }
      function encode(obj, buf, offset) {
        if (!offset) offset = 0;
        if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj));
        var oldOffset = offset;
        if (!defined(obj.start)) throw new Error("start is required");
        buf[offset++] = 8;
        enc[0].encode(obj.start, buf, offset);
        offset += enc[0].encode.bytes;
        if (defined(obj.length)) {
          buf[offset++] = 16;
          enc[0].encode(obj.length, buf, offset);
          offset += enc[0].encode.bytes;
        }
        if (defined(obj.bitfield)) {
          buf[offset++] = 26;
          enc[1].encode(obj.bitfield, buf, offset);
          offset += enc[1].encode.bytes;
        }
        if (defined(obj.ack)) {
          buf[offset++] = 32;
          enc[2].encode(obj.ack, buf, offset);
          offset += enc[2].encode.bytes;
        }
        encode.bytes = offset - oldOffset;
        return buf;
      }
      function decode(buf, offset, end) {
        if (!offset) offset = 0;
        if (!end) end = buf.length;
        if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid");
        var oldOffset = offset;
        var obj = {
          start: 0,
          length: 1,
          bitfield: null,
          ack: false
        };
        var found0 = false;
        while (true) {
          if (end <= offset) {
            if (!found0) throw new Error("Decoded message is not valid");
            decode.bytes = offset - oldOffset;
            return obj;
          }
          var prefix = varint.decode(buf, offset);
          offset += varint.decode.bytes;
          var tag = prefix >> 3;
          switch (tag) {
            case 1:
              obj.start = enc[0].decode(buf, offset);
              offset += enc[0].decode.bytes;
              found0 = true;
              break;
            case 2:
              obj.length = enc[0].decode(buf, offset);
              offset += enc[0].decode.bytes;
              break;
            case 3:
              obj.bitfield = enc[1].decode(buf, offset);
              offset += enc[1].decode.bytes;
              break;
            case 4:
              obj.ack = enc[2].decode(buf, offset);
              offset += enc[2].decode.bytes;
              break;
            default:
              offset = skip(prefix & 7, buf, offset);
          }
        }
      }
    }
    function defineUnhave() {
      var enc = [
        encodings.varint
      ];
      Unhave.encodingLength = encodingLength;
      Unhave.encode = encode;
      Unhave.decode = decode;
      function encodingLength(obj) {
        var length = 0;
        if (!defined(obj.start)) throw new Error("start is required");
        var len = enc[0].encodingLength(obj.start);
        length += 1 + len;
        if (defined(obj.length)) {
          var len = enc[0].encodingLength(obj.length);
          length += 1 + len;
        }
        return length;
      }
      function encode(obj, buf, offset) {
        if (!offset) offset = 0;
        if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj));
        var oldOffset = offset;
        if (!defined(obj.start)) throw new Error("start is required");
        buf[offset++] = 8;
        enc[0].encode(obj.start, buf, offset);
        offset += enc[0].encode.bytes;
        if (defined(obj.length)) {
          buf[offset++] = 16;
          enc[0].encode(obj.length, buf, offset);
          offset += enc[0].encode.bytes;
        }
        encode.bytes = offset - oldOffset;
        return buf;
      }
      function decode(buf, offset, end) {
        if (!offset) offset = 0;
        if (!end) end = buf.length;
        if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid");
        var oldOffset = offset;
        var obj = {
          start: 0,
          length: 1
        };
        var found0 = false;
        while (true) {
          if (end <= offset) {
            if (!found0) throw new Error("Decoded message is not valid");
            decode.bytes = offset - oldOffset;
            return obj;
          }
          var prefix = varint.decode(buf, offset);
          offset += varint.decode.bytes;
          var tag = prefix >> 3;
          switch (tag) {
            case 1:
              obj.start = enc[0].decode(buf, offset);
              offset += enc[0].decode.bytes;
              found0 = true;
              break;
            case 2:
              obj.length = enc[0].decode(buf, offset);
              offset += enc[0].decode.bytes;
              break;
            default:
              offset = skip(prefix & 7, buf, offset);
          }
        }
      }
    }
    function defineWant() {
      var enc = [
        encodings.varint
      ];
      Want.encodingLength = encodingLength;
      Want.encode = encode;
      Want.decode = decode;
      function encodingLength(obj) {
        var length = 0;
        if (!defined(obj.start)) throw new Error("start is required");
        var len = enc[0].encodingLength(obj.start);
        length += 1 + len;
        if (defined(obj.length)) {
          var len = enc[0].encodingLength(obj.length);
          length += 1 + len;
        }
        return length;
      }
      function encode(obj, buf, offset) {
        if (!offset) offset = 0;
        if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj));
        var oldOffset = offset;
        if (!defined(obj.start)) throw new Error("start is required");
        buf[offset++] = 8;
        enc[0].encode(obj.start, buf, offset);
        offset += enc[0].encode.bytes;
        if (defined(obj.length)) {
          buf[offset++] = 16;
          enc[0].encode(obj.length, buf, offset);
          offset += enc[0].encode.bytes;
        }
        encode.bytes = offset - oldOffset;
        return buf;
      }
      function decode(buf, offset, end) {
        if (!offset) offset = 0;
        if (!end) end = buf.length;
        if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid");
        var oldOffset = offset;
        var obj = {
          start: 0,
          length: 0
        };
        var found0 = false;
        while (true) {
          if (end <= offset) {
            if (!found0) throw new Error("Decoded message is not valid");
            decode.bytes = offset - oldOffset;
            return obj;
          }
          var prefix = varint.decode(buf, offset);
          offset += varint.decode.bytes;
          var tag = prefix >> 3;
          switch (tag) {
            case 1:
              obj.start = enc[0].decode(buf, offset);
              offset += enc[0].decode.bytes;
              found0 = true;
              break;
            case 2:
              obj.length = enc[0].decode(buf, offset);
              offset += enc[0].decode.bytes;
              break;
            default:
              offset = skip(prefix & 7, buf, offset);
          }
        }
      }
    }
    function defineUnwant() {
      var enc = [
        encodings.varint
      ];
      Unwant.encodingLength = encodingLength;
      Unwant.encode = encode;
      Unwant.decode = decode;
      function encodingLength(obj) {
        var length = 0;
        if (!defined(obj.start)) throw new Error("start is required");
        var len = enc[0].encodingLength(obj.start);
        length += 1 + len;
        if (defined(obj.length)) {
          var len = enc[0].encodingLength(obj.length);
          length += 1 + len;
        }
        return length;
      }
      function encode(obj, buf, offset) {
        if (!offset) offset = 0;
        if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj));
        var oldOffset = offset;
        if (!defined(obj.start)) throw new Error("start is required");
        buf[offset++] = 8;
        enc[0].encode(obj.start, buf, offset);
        offset += enc[0].encode.bytes;
        if (defined(obj.length)) {
          buf[offset++] = 16;
          enc[0].encode(obj.length, buf, offset);
          offset += enc[0].encode.bytes;
        }
        encode.bytes = offset - oldOffset;
        return buf;
      }
      function decode(buf, offset, end) {
        if (!offset) offset = 0;
        if (!end) end = buf.length;
        if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid");
        var oldOffset = offset;
        var obj = {
          start: 0,
          length: 0
        };
        var found0 = false;
        while (true) {
          if (end <= offset) {
            if (!found0) throw new Error("Decoded message is not valid");
            decode.bytes = offset - oldOffset;
            return obj;
          }
          var prefix = varint.decode(buf, offset);
          offset += varint.decode.bytes;
          var tag = prefix >> 3;
          switch (tag) {
            case 1:
              obj.start = enc[0].decode(buf, offset);
              offset += enc[0].decode.bytes;
              found0 = true;
              break;
            case 2:
              obj.length = enc[0].decode(buf, offset);
              offset += enc[0].decode.bytes;
              break;
            default:
              offset = skip(prefix & 7, buf, offset);
          }
        }
      }
    }
    function defineRequest() {
      var enc = [
        encodings.varint,
        encodings.bool
      ];
      Request.encodingLength = encodingLength;
      Request.encode = encode;
      Request.decode = decode;
      function encodingLength(obj) {
        var length = 0;
        if (!defined(obj.index)) throw new Error("index is required");
        var len = enc[0].encodingLength(obj.index);
        length += 1 + len;
        if (defined(obj.bytes)) {
          var len = enc[0].encodingLength(obj.bytes);
          length += 1 + len;
        }
        if (defined(obj.hash)) {
          var len = enc[1].encodingLength(obj.hash);
          length += 1 + len;
        }
        if (defined(obj.nodes)) {
          var len = enc[0].encodingLength(obj.nodes);
          length += 1 + len;
        }
        return length;
      }
      function encode(obj, buf, offset) {
        if (!offset) offset = 0;
        if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj));
        var oldOffset = offset;
        if (!defined(obj.index)) throw new Error("index is required");
        buf[offset++] = 8;
        enc[0].encode(obj.index, buf, offset);
        offset += enc[0].encode.bytes;
        if (defined(obj.bytes)) {
          buf[offset++] = 16;
          enc[0].encode(obj.bytes, buf, offset);
          offset += enc[0].encode.bytes;
        }
        if (defined(obj.hash)) {
          buf[offset++] = 24;
          enc[1].encode(obj.hash, buf, offset);
          offset += enc[1].encode.bytes;
        }
        if (defined(obj.nodes)) {
          buf[offset++] = 32;
          enc[0].encode(obj.nodes, buf, offset);
          offset += enc[0].encode.bytes;
        }
        encode.bytes = offset - oldOffset;
        return buf;
      }
      function decode(buf, offset, end) {
        if (!offset) offset = 0;
        if (!end) end = buf.length;
        if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid");
        var oldOffset = offset;
        var obj = {
          index: 0,
          bytes: 0,
          hash: false,
          nodes: 0
        };
        var found0 = false;
        while (true) {
          if (end <= offset) {
            if (!found0) throw new Error("Decoded message is not valid");
            decode.bytes = offset - oldOffset;
            return obj;
          }
          var prefix = varint.decode(buf, offset);
          offset += varint.decode.bytes;
          var tag = prefix >> 3;
          switch (tag) {
            case 1:
              obj.index = enc[0].decode(buf, offset);
              offset += enc[0].decode.bytes;
              found0 = true;
              break;
            case 2:
              obj.bytes = enc[0].decode(buf, offset);
              offset += enc[0].decode.bytes;
              break;
            case 3:
              obj.hash = enc[1].decode(buf, offset);
              offset += enc[1].decode.bytes;
              break;
            case 4:
              obj.nodes = enc[0].decode(buf, offset);
              offset += enc[0].decode.bytes;
              break;
            default:
              offset = skip(prefix & 7, buf, offset);
          }
        }
      }
    }
    function defineCancel() {
      var enc = [
        encodings.varint,
        encodings.bool
      ];
      Cancel.encodingLength = encodingLength;
      Cancel.encode = encode;
      Cancel.decode = decode;
      function encodingLength(obj) {
        var length = 0;
        if (!defined(obj.index)) throw new Error("index is required");
        var len = enc[0].encodingLength(obj.index);
        length += 1 + len;
        if (defined(obj.bytes)) {
          var len = enc[0].encodingLength(obj.bytes);
          length += 1 + len;
        }
        if (defined(obj.hash)) {
          var len = enc[1].encodingLength(obj.hash);
          length += 1 + len;
        }
        return length;
      }
      function encode(obj, buf, offset) {
        if (!offset) offset = 0;
        if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj));
        var oldOffset = offset;
        if (!defined(obj.index)) throw new Error("index is required");
        buf[offset++] = 8;
        enc[0].encode(obj.index, buf, offset);
        offset += enc[0].encode.bytes;
        if (defined(obj.bytes)) {
          buf[offset++] = 16;
          enc[0].encode(obj.bytes, buf, offset);
          offset += enc[0].encode.bytes;
        }
        if (defined(obj.hash)) {
          buf[offset++] = 24;
          enc[1].encode(obj.hash, buf, offset);
          offset += enc[1].encode.bytes;
        }
        encode.bytes = offset - oldOffset;
        return buf;
      }
      function decode(buf, offset, end) {
        if (!offset) offset = 0;
        if (!end) end = buf.length;
        if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid");
        var oldOffset = offset;
        var obj = {
          index: 0,
          bytes: 0,
          hash: false
        };
        var found0 = false;
        while (true) {
          if (end <= offset) {
            if (!found0) throw new Error("Decoded message is not valid");
            decode.bytes = offset - oldOffset;
            return obj;
          }
          var prefix = varint.decode(buf, offset);
          offset += varint.decode.bytes;
          var tag = prefix >> 3;
          switch (tag) {
            case 1:
              obj.index = enc[0].decode(buf, offset);
              offset += enc[0].decode.bytes;
              found0 = true;
              break;
            case 2:
              obj.bytes = enc[0].decode(buf, offset);
              offset += enc[0].decode.bytes;
              break;
            case 3:
              obj.hash = enc[1].decode(buf, offset);
              offset += enc[1].decode.bytes;
              break;
            default:
              offset = skip(prefix & 7, buf, offset);
          }
        }
      }
    }
    function defineData() {
      var Node = Data.Node = {
        buffer: true,
        encodingLength: null,
        encode: null,
        decode: null
      };
      defineNode();
      function defineNode() {
        var enc2 = [
          encodings.varint,
          encodings.bytes
        ];
        Node.encodingLength = encodingLength2;
        Node.encode = encode2;
        Node.decode = decode2;
        function encodingLength2(obj) {
          var length = 0;
          if (!defined(obj.index)) throw new Error("index is required");
          var len = enc2[0].encodingLength(obj.index);
          length += 1 + len;
          if (!defined(obj.hash)) throw new Error("hash is required");
          var len = enc2[1].encodingLength(obj.hash);
          length += 1 + len;
          if (!defined(obj.size)) throw new Error("size is required");
          var len = enc2[0].encodingLength(obj.size);
          length += 1 + len;
          return length;
        }
        function encode2(obj, buf, offset) {
          if (!offset) offset = 0;
          if (!buf) buf = Buffer.allocUnsafe(encodingLength2(obj));
          var oldOffset = offset;
          if (!defined(obj.index)) throw new Error("index is required");
          buf[offset++] = 8;
          enc2[0].encode(obj.index, buf, offset);
          offset += enc2[0].encode.bytes;
          if (!defined(obj.hash)) throw new Error("hash is required");
          buf[offset++] = 18;
          enc2[1].encode(obj.hash, buf, offset);
          offset += enc2[1].encode.bytes;
          if (!defined(obj.size)) throw new Error("size is required");
          buf[offset++] = 24;
          enc2[0].encode(obj.size, buf, offset);
          offset += enc2[0].encode.bytes;
          encode2.bytes = offset - oldOffset;
          return buf;
        }
        function decode2(buf, offset, end) {
          if (!offset) offset = 0;
          if (!end) end = buf.length;
          if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid");
          var oldOffset = offset;
          var obj = {
            index: 0,
            hash: null,
            size: 0
          };
          var found0 = false;
          var found1 = false;
          var found2 = false;
          while (true) {
            if (end <= offset) {
              if (!found0 || !found1 || !found2) throw new Error("Decoded message is not valid");
              decode2.bytes = offset - oldOffset;
              return obj;
            }
            var prefix = varint.decode(buf, offset);
            offset += varint.decode.bytes;
            var tag = prefix >> 3;
            switch (tag) {
              case 1:
                obj.index = enc2[0].decode(buf, offset);
                offset += enc2[0].decode.bytes;
                found0 = true;
                break;
              case 2:
                obj.hash = enc2[1].decode(buf, offset);
                offset += enc2[1].decode.bytes;
                found1 = true;
                break;
              case 3:
                obj.size = enc2[0].decode(buf, offset);
                offset += enc2[0].decode.bytes;
                found2 = true;
                break;
              default:
                offset = skip(prefix & 7, buf, offset);
            }
          }
        }
      }
      var enc = [
        encodings.varint,
        encodings.bytes,
        Node
      ];
      Data.encodingLength = encodingLength;
      Data.encode = encode;
      Data.decode = decode;
      function encodingLength(obj) {
        var length = 0;
        if (!defined(obj.index)) throw new Error("index is required");
        var len = enc[0].encodingLength(obj.index);
        length += 1 + len;
        if (defined(obj.value)) {
          var len = enc[1].encodingLength(obj.value);
          length += 1 + len;
        }
        if (defined(obj.nodes)) {
          for (var i = 0; i < obj.nodes.length; i++) {
            if (!defined(obj.nodes[i])) continue;
            var len = enc[2].encodingLength(obj.nodes[i]);
            length += varint.encodingLength(len);
            length += 1 + len;
          }
        }
        if (defined(obj.signature)) {
          var len = enc[1].encodingLength(obj.signature);
          length += 1 + len;
        }
        return length;
      }
      function encode(obj, buf, offset) {
        if (!offset) offset = 0;
        if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj));
        var oldOffset = offset;
        if (!defined(obj.index)) throw new Error("index is required");
        buf[offset++] = 8;
        enc[0].encode(obj.index, buf, offset);
        offset += enc[0].encode.bytes;
        if (defined(obj.value)) {
          buf[offset++] = 18;
          enc[1].encode(obj.value, buf, offset);
          offset += enc[1].encode.bytes;
        }
        if (defined(obj.nodes)) {
          for (var i = 0; i < obj.nodes.length; i++) {
            if (!defined(obj.nodes[i])) continue;
            buf[offset++] = 26;
            varint.encode(enc[2].encodingLength(obj.nodes[i]), buf, offset);
            offset += varint.encode.bytes;
            enc[2].encode(obj.nodes[i], buf, offset);
            offset += enc[2].encode.bytes;
          }
        }
        if (defined(obj.signature)) {
          buf[offset++] = 34;
          enc[1].encode(obj.signature, buf, offset);
          offset += enc[1].encode.bytes;
        }
        encode.bytes = offset - oldOffset;
        return buf;
      }
      function decode(buf, offset, end) {
        if (!offset) offset = 0;
        if (!end) end = buf.length;
        if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid");
        var oldOffset = offset;
        var obj = {
          index: 0,
          value: null,
          nodes: [],
          signature: null
        };
        var found0 = false;
        while (true) {
          if (end <= offset) {
            if (!found0) throw new Error("Decoded message is not valid");
            decode.bytes = offset - oldOffset;
            return obj;
          }
          var prefix = varint.decode(buf, offset);
          offset += varint.decode.bytes;
          var tag = prefix >> 3;
          switch (tag) {
            case 1:
              obj.index = enc[0].decode(buf, offset);
              offset += enc[0].decode.bytes;
              found0 = true;
              break;
            case 2:
              obj.value = enc[1].decode(buf, offset);
              offset += enc[1].decode.bytes;
              break;
            case 3:
              var len = varint.decode(buf, offset);
              offset += varint.decode.bytes;
              obj.nodes.push(enc[2].decode(buf, offset, offset + len));
              offset += enc[2].decode.bytes;
              break;
            case 4:
              obj.signature = enc[1].decode(buf, offset);
              offset += enc[1].decode.bytes;
              break;
            default:
              offset = skip(prefix & 7, buf, offset);
          }
        }
      }
    }
    function defineClose() {
      var enc = [
        encodings.bytes
      ];
      Close.encodingLength = encodingLength;
      Close.encode = encode;
      Close.decode = decode;
      function encodingLength(obj) {
        var length = 0;
        if (defined(obj.discoveryKey)) {
          var len = enc[0].encodingLength(obj.discoveryKey);
          length += 1 + len;
        }
        return length;
      }
      function encode(obj, buf, offset) {
        if (!offset) offset = 0;
        if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj));
        var oldOffset = offset;
        if (defined(obj.discoveryKey)) {
          buf[offset++] = 10;
          enc[0].encode(obj.discoveryKey, buf, offset);
          offset += enc[0].encode.bytes;
        }
        encode.bytes = offset - oldOffset;
        return buf;
      }
      function decode(buf, offset, end) {
        if (!offset) offset = 0;
        if (!end) end = buf.length;
        if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid");
        var oldOffset = offset;
        var obj = {
          discoveryKey: null
        };
        while (true) {
          if (end <= offset) {
            decode.bytes = offset - oldOffset;
            return obj;
          }
          var prefix = varint.decode(buf, offset);
          offset += varint.decode.bytes;
          var tag = prefix >> 3;
          switch (tag) {
            case 1:
              obj.discoveryKey = enc[0].decode(buf, offset);
              offset += enc[0].decode.bytes;
              break;
            default:
              offset = skip(prefix & 7, buf, offset);
          }
        }
      }
    }
    function defined(val2) {
      return val2 !== null && val2 !== void 0 && (typeof val2 !== "number" || !isNaN(val2));
    }
  }
});

// node_modules/.pnpm/xsalsa20@1.2.0/node_modules/xsalsa20/xsalsa20.js
var require_xsalsa20 = __commonJS({
  "node_modules/.pnpm/xsalsa20@1.2.0/node_modules/xsalsa20/xsalsa20.js"(exports, module) {
    var __commonJS2 = (cb, mod) => function __require2() {
      return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
    };
    var __toBinary = /* @__PURE__ */ (() => {
      var table = new Uint8Array(128);
      for (var i = 0; i < 64; i++)
        table[i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i * 4 - 205] = i;
      return (base64) => {
        var n = base64.length, bytes2 = new Uint8Array((n - (base64[n - 1] == "=") - (base64[n - 2] == "=")) * 3 / 4 | 0);
        for (var i2 = 0, j = 0; i2 < n; ) {
          var c0 = table[base64.charCodeAt(i2++)], c1 = table[base64.charCodeAt(i2++)];
          var c2 = table[base64.charCodeAt(i2++)], c3 = table[base64.charCodeAt(i2++)];
          bytes2[j++] = c0 << 2 | c1 >> 4;
          bytes2[j++] = c1 << 4 | c2 >> 2;
          bytes2[j++] = c2 << 6 | c3;
        }
        return bytes2;
      };
    })();
    var require_xsalsa203 = __commonJS2({
      "wasm-binary:./xsalsa20.wat"(exports2, module2) {
        module2.exports = __toBinary("AGFzbQEAAAABGgNgBn9/f39/fwBgBn9/f39+fwF+YAN/f38AAwcGAAEBAgICBQUBAQroBwcoAwZtZW1vcnkCAAx4c2Fsc2EyMF94b3IAAAxjb3JlX3NhbHNhMjAABArqEQYYACAAIAEgAiADIAQgACkDACAFEAE3AwALPQBB8AAgAyAFEAMgACABIAIgA0EQaiAEQfAAEAJB8ABCADcDAEH4AEIANwMAQYABQgA3AwBBiAFCADcDAAuHBQEBfyACQQBGBEBCAA8LQdAAIAUpAwA3AwBB2AAgBUEIaikDADcDAEHgACAFQRBqKQMANwMAQegAIAVBGGopAwA3AwBBACADKQMANwMAQQggBDcDAAJAA0AgAkHAAEkNAUEQQQBB0AAQBSAAIAEpAwBBECkDAIU3AwAgAEEIaiABQQhqKQMAQRgpAwCFNwMAIABBEGogAUEQaikDAEEgKQMAhTcDACAAQRhqIAFBGGopAwBBKCkDAIU3AwAgAEEgaiABQSBqKQMAQTApAwCFNwMAIABBKGogAUEoaikDAEE4KQMAhTcDACAAQTBqIAFBMGopAwBBwAApAwCFNwMAIABBOGogAUE4aikDAEHIACkDAIU3AwBBCEEIKQMAQgF8NwMAIABBwABqIQAgAUHAAGohASACQcAAayECDAALC0EIKQMAIQQgAkEASwRAQRBBAEHQABAFAkACQAJAAkACQAJAAkACQCACQQhuDgcHBgUEAwIBAAsgAEE4aiABQThqKQMAQcgAKQMAhTcDAAsgAEEwaiABQTBqKQMAQcAAKQMAhTcDAAsgAEEoaiABQShqKQMAQTgpAwCFNwMACyAAQSBqIAFBIGopAwBBMCkDAIU3AwALIABBGGogAUEYaikDAEEoKQMAhTcDAAsgAEEQaiABQRBqKQMAQSApAwCFNwMACyAAQQhqIAFBCGopAwBBGCkDAIU3AwALIAAgASkDAEEQKQMAhTcDAAtBEEIANwMAQRhCADcDAEEgQgA3AwBBKEIANwMAQTBCADcDAEE4QgA3AwBBwABCADcDAEHIAEIANwMAQdAAQgA3AwBB2ABCADcDAEHgAEIANwMAQegAQgA3AwAgBA8LnQUBEX9B5fDBiwYhA0HuyIGZAyEIQbLaiMsHIQ1B9MqB2QYhEiACKAIAIQQgAkEEaigCACEFIAJBCGooAgAhBiACQQxqKAIAIQcgAkEQaigCACEOIAJBFGooAgAhDyACQRhqKAIAIRAgAkEcaigCACERIAEoAgAhCSABQQRqKAIAIQogAUEIaigCACELIAFBDGooAgAhDEEUIRMCQANAIBNBAEYNASAHIAMgD2pBB3dzIQcgCyAHIANqQQl3cyELIA8gCyAHakENd3MhDyADIA8gC2pBEndzIQMgDCAIIARqQQd3cyEMIBAgDCAIakEJd3MhECAEIBAgDGpBDXdzIQQgCCAEIBBqQRJ3cyEIIBEgDSAJakEHd3MhESAFIBEgDWpBCXdzIQUgCSAFIBFqQQ13cyEJIA0gCSAFakESd3MhDSAGIBIgDmpBB3dzIQYgCiAGIBJqQQl3cyEKIA4gCiAGakENd3MhDiASIA4gCmpBEndzIRIgBCADIAZqQQd3cyEEIAUgBCADakEJd3MhBSAGIAUgBGpBDXdzIQYgAyAGIAVqQRJ3cyEDIAkgCCAHakEHd3MhCSAKIAkgCGpBCXdzIQogByAKIAlqQQ13cyEHIAggByAKakESd3MhCCAOIA0gDGpBB3dzIQ4gCyAOIA1qQQl3cyELIAwgCyAOakENd3MhDCANIAwgC2pBEndzIQ0gDyASIBFqQQd3cyEPIBAgDyASakEJd3MhECARIBAgD2pBDXdzIREgEiARIBBqQRJ3cyESIBNBAmshEwwACwsgACADNgIAIABBBGogCDYCACAAQQhqIA02AgAgAEEMaiASNgIAIABBEGogCTYCACAAQRRqIAo2AgAgAEEYaiALNgIAIABBHGogDDYCAAsKACAAIAEgAhAFC90GASF/QeXwwYsGIQNB7siBmQMhCEGy2ojLByENQfTKgdkGIRIgAigCACEEIAJBBGooAgAhBSACQQhqKAIAIQYgAkEMaigCACEHIAJBEGooAgAhDiACQRRqKAIAIQ8gAkEYaigCACEQIAJBHGooAgAhESABKAIAIQkgAUEEaigCACEKIAFBCGooAgAhCyABQQxqKAIAIQwgAyETIAQhFCAFIRUgBiEWIAchFyAIIRggCSEZIAohGiALIRsgDCEcIA0hHSAOIR4gDyEfIBAhICARISEgEiEiQRQhIwJAA0AgI0EARg0BIAcgAyAPakEHd3MhByALIAcgA2pBCXdzIQsgDyALIAdqQQ13cyEPIAMgDyALakESd3MhAyAMIAggBGpBB3dzIQwgECAMIAhqQQl3cyEQIAQgECAMakENd3MhBCAIIAQgEGpBEndzIQggESANIAlqQQd3cyERIAUgESANakEJd3MhBSAJIAUgEWpBDXdzIQkgDSAJIAVqQRJ3cyENIAYgEiAOakEHd3MhBiAKIAYgEmpBCXdzIQogDiAKIAZqQQ13cyEOIBIgDiAKakESd3MhEiAEIAMgBmpBB3dzIQQgBSAEIANqQQl3cyEFIAYgBSAEakENd3MhBiADIAYgBWpBEndzIQMgCSAIIAdqQQd3cyEJIAogCSAIakEJd3MhCiAHIAogCWpBDXdzIQcgCCAHIApqQRJ3cyEIIA4gDSAMakEHd3MhDiALIA4gDWpBCXdzIQsgDCALIA5qQQ13cyEMIA0gDCALakESd3MhDSAPIBIgEWpBB3dzIQ8gECAPIBJqQQl3cyEQIBEgECAPakENd3MhESASIBEgEGpBEndzIRIgI0ECayEjDAALCyAAIAMgE2o2AgAgAEEEaiAEIBRqNgIAIABBCGogBSAVajYCACAAQQxqIAYgFmo2AgAgAEEQaiAHIBdqNgIAIABBFGogCCAYajYCACAAQRhqIAkgGWo2AgAgAEEcaiAKIBpqNgIAIABBIGogCyAbajYCACAAQSRqIAwgHGo2AgAgAEEoaiANIB1qNgIAIABBLGogDiAeajYCACAAQTBqIA8gH2o2AgAgAEE0aiAQICBqNgIAIABBOGogESAhajYCACAAQTxqIBIgImo2AgAL");
      }
    });
    var bytes = require_xsalsa203();
    var compiled = new WebAssembly.Module(bytes);
    module.exports = (imports) => {
      const instance = new WebAssembly.Instance(compiled, imports);
      return instance.exports;
    };
  }
});

// node_modules/.pnpm/xsalsa20@1.2.0/node_modules/xsalsa20/index.js
var require_xsalsa202 = __commonJS({
  "node_modules/.pnpm/xsalsa20@1.2.0/node_modules/xsalsa20/index.js"(exports, module) {
    var xsalsa20 = typeof WebAssembly !== "undefined" && require_xsalsa20()();
    var SIGMA = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
    var head = 144;
    var top = head;
    var free = [];
    module.exports = XSalsa20;
    XSalsa20.NONCEBYTES = 24;
    XSalsa20.KEYBYTES = 32;
    XSalsa20.core_hsalsa20 = core_hsalsa20;
    XSalsa20.SIGMA = SIGMA;
    function XSalsa20(nonce, key) {
      if (!(this instanceof XSalsa20)) return new XSalsa20(nonce, key);
      if (!nonce || nonce.length < 24) throw new Error("nonce must be at least 24 bytes");
      if (!key || key.length < 32) throw new Error("key must be at least 32 bytes");
      this._xor = xsalsa20 ? new WASM(nonce, key) : new Fallback(nonce, key);
    }
    XSalsa20.prototype.update = function(input, output) {
      if (!input) throw new Error("input must be Uint8Array or Buffer");
      if (!output) output = new Uint8Array(input.length);
      if (input.length) this._xor.update(input, output);
      return output;
    };
    XSalsa20.prototype.final = XSalsa20.prototype.finalize = function() {
      this._xor.finalize();
      this._xor = null;
    };
    function WASM(nonce, key) {
      if (!free.length) {
        free.push(head);
        head += 64;
      }
      this._pointer = free.pop();
      this._nonce = this._pointer + 8;
      this._key = this._nonce + 24;
      this._overflow = 0;
      this._memory = new Uint8Array(xsalsa20.memory.buffer);
      this._memory.fill(0, this._pointer, this._pointer + 8);
      this._memory.set(nonce, this._nonce);
      this._memory.set(key, this._key);
    }
    WASM.prototype.realloc = function(size) {
      xsalsa20.memory.grow(Math.ceil(Math.abs(size - this._memory.length) / 65536));
      this._memory = new Uint8Array(xsalsa20.memory.buffer);
    };
    WASM.prototype.update = function(input, output) {
      var len = this._overflow + input.length;
      var start = head + this._overflow;
      top = head + len;
      if (top >= this._memory.length) this.realloc(top);
      this._memory.set(input, start);
      xsalsa20.xsalsa20_xor(this._pointer, head, head, len, this._nonce, this._key);
      output.set(this._memory.subarray(start, head + len));
      this._overflow = len & 63;
    };
    WASM.prototype.finalize = function() {
      this._memory.fill(0, this._pointer, this._key + 32);
      if (top > head) {
        this._memory.fill(0, head, top);
        top = 0;
      }
      free.push(this._pointer);
    };
    function Fallback(nonce, key) {
      this._s = new Uint8Array(32);
      this._z = new Uint8Array(16);
      this._overflow = 0;
      core_hsalsa20(this._s, nonce, key, SIGMA);
      for (var i = 0; i < 8; i++) this._z[i] = nonce[i + 16];
    }
    Fallback.prototype.update = function(input, output) {
      var x = new Uint8Array(64);
      var u = 0;
      var i = this._overflow;
      var b = input.length + this._overflow;
      var z = this._z;
      var mpos = -this._overflow;
      var cpos = -this._overflow;
      while (b >= 64) {
        core_salsa20(x, z, this._s, SIGMA);
        for (; i < 64; i++) output[cpos + i] = input[mpos + i] ^ x[i];
        u = 1;
        for (i = 8; i < 16; i++) {
          u += z[i] & 255 | 0;
          z[i] = u & 255;
          u >>>= 8;
        }
        b -= 64;
        cpos += 64;
        mpos += 64;
        i = 0;
      }
      if (b > 0) {
        core_salsa20(x, z, this._s, SIGMA);
        for (; i < b; i++) output[cpos + i] = input[mpos + i] ^ x[i];
      }
      this._overflow = b & 63;
    };
    Fallback.prototype.finalize = function() {
      this._s.fill(0);
      this._z.fill(0);
    };
    function core_salsa20(o, p, k, c) {
      var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
      var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
      for (var i = 0; i < 20; i += 2) {
        u = x0 + x12 | 0;
        x4 ^= u << 7 | u >>> 25;
        u = x4 + x0 | 0;
        x8 ^= u << 9 | u >>> 23;
        u = x8 + x4 | 0;
        x12 ^= u << 13 | u >>> 19;
        u = x12 + x8 | 0;
        x0 ^= u << 18 | u >>> 14;
        u = x5 + x1 | 0;
        x9 ^= u << 7 | u >>> 25;
        u = x9 + x5 | 0;
        x13 ^= u << 9 | u >>> 23;
        u = x13 + x9 | 0;
        x1 ^= u << 13 | u >>> 19;
        u = x1 + x13 | 0;
        x5 ^= u << 18 | u >>> 14;
        u = x10 + x6 | 0;
        x14 ^= u << 7 | u >>> 25;
        u = x14 + x10 | 0;
        x2 ^= u << 9 | u >>> 23;
        u = x2 + x14 | 0;
        x6 ^= u << 13 | u >>> 19;
        u = x6 + x2 | 0;
        x10 ^= u << 18 | u >>> 14;
        u = x15 + x11 | 0;
        x3 ^= u << 7 | u >>> 25;
        u = x3 + x15 | 0;
        x7 ^= u << 9 | u >>> 23;
        u = x7 + x3 | 0;
        x11 ^= u << 13 | u >>> 19;
        u = x11 + x7 | 0;
        x15 ^= u << 18 | u >>> 14;
        u = x0 + x3 | 0;
        x1 ^= u << 7 | u >>> 25;
        u = x1 + x0 | 0;
        x2 ^= u << 9 | u >>> 23;
        u = x2 + x1 | 0;
        x3 ^= u << 13 | u >>> 19;
        u = x3 + x2 | 0;
        x0 ^= u << 18 | u >>> 14;
        u = x5 + x4 | 0;
        x6 ^= u << 7 | u >>> 25;
        u = x6 + x5 | 0;
        x7 ^= u << 9 | u >>> 23;
        u = x7 + x6 | 0;
        x4 ^= u << 13 | u >>> 19;
        u = x4 + x7 | 0;
        x5 ^= u << 18 | u >>> 14;
        u = x10 + x9 | 0;
        x11 ^= u << 7 | u >>> 25;
        u = x11 + x10 | 0;
        x8 ^= u << 9 | u >>> 23;
        u = x8 + x11 | 0;
        x9 ^= u << 13 | u >>> 19;
        u = x9 + x8 | 0;
        x10 ^= u << 18 | u >>> 14;
        u = x15 + x14 | 0;
        x12 ^= u << 7 | u >>> 25;
        u = x12 + x15 | 0;
        x13 ^= u << 9 | u >>> 23;
        u = x13 + x12 | 0;
        x14 ^= u << 13 | u >>> 19;
        u = x14 + x13 | 0;
        x15 ^= u << 18 | u >>> 14;
      }
      x0 = x0 + j0 | 0;
      x1 = x1 + j1 | 0;
      x2 = x2 + j2 | 0;
      x3 = x3 + j3 | 0;
      x4 = x4 + j4 | 0;
      x5 = x5 + j5 | 0;
      x6 = x6 + j6 | 0;
      x7 = x7 + j7 | 0;
      x8 = x8 + j8 | 0;
      x9 = x9 + j9 | 0;
      x10 = x10 + j10 | 0;
      x11 = x11 + j11 | 0;
      x12 = x12 + j12 | 0;
      x13 = x13 + j13 | 0;
      x14 = x14 + j14 | 0;
      x15 = x15 + j15 | 0;
      o[0] = x0 >>> 0 & 255;
      o[1] = x0 >>> 8 & 255;
      o[2] = x0 >>> 16 & 255;
      o[3] = x0 >>> 24 & 255;
      o[4] = x1 >>> 0 & 255;
      o[5] = x1 >>> 8 & 255;
      o[6] = x1 >>> 16 & 255;
      o[7] = x1 >>> 24 & 255;
      o[8] = x2 >>> 0 & 255;
      o[9] = x2 >>> 8 & 255;
      o[10] = x2 >>> 16 & 255;
      o[11] = x2 >>> 24 & 255;
      o[12] = x3 >>> 0 & 255;
      o[13] = x3 >>> 8 & 255;
      o[14] = x3 >>> 16 & 255;
      o[15] = x3 >>> 24 & 255;
      o[16] = x4 >>> 0 & 255;
      o[17] = x4 >>> 8 & 255;
      o[18] = x4 >>> 16 & 255;
      o[19] = x4 >>> 24 & 255;
      o[20] = x5 >>> 0 & 255;
      o[21] = x5 >>> 8 & 255;
      o[22] = x5 >>> 16 & 255;
      o[23] = x5 >>> 24 & 255;
      o[24] = x6 >>> 0 & 255;
      o[25] = x6 >>> 8 & 255;
      o[26] = x6 >>> 16 & 255;
      o[27] = x6 >>> 24 & 255;
      o[28] = x7 >>> 0 & 255;
      o[29] = x7 >>> 8 & 255;
      o[30] = x7 >>> 16 & 255;
      o[31] = x7 >>> 24 & 255;
      o[32] = x8 >>> 0 & 255;
      o[33] = x8 >>> 8 & 255;
      o[34] = x8 >>> 16 & 255;
      o[35] = x8 >>> 24 & 255;
      o[36] = x9 >>> 0 & 255;
      o[37] = x9 >>> 8 & 255;
      o[38] = x9 >>> 16 & 255;
      o[39] = x9 >>> 24 & 255;
      o[40] = x10 >>> 0 & 255;
      o[41] = x10 >>> 8 & 255;
      o[42] = x10 >>> 16 & 255;
      o[43] = x10 >>> 24 & 255;
      o[44] = x11 >>> 0 & 255;
      o[45] = x11 >>> 8 & 255;
      o[46] = x11 >>> 16 & 255;
      o[47] = x11 >>> 24 & 255;
      o[48] = x12 >>> 0 & 255;
      o[49] = x12 >>> 8 & 255;
      o[50] = x12 >>> 16 & 255;
      o[51] = x12 >>> 24 & 255;
      o[52] = x13 >>> 0 & 255;
      o[53] = x13 >>> 8 & 255;
      o[54] = x13 >>> 16 & 255;
      o[55] = x13 >>> 24 & 255;
      o[56] = x14 >>> 0 & 255;
      o[57] = x14 >>> 8 & 255;
      o[58] = x14 >>> 16 & 255;
      o[59] = x14 >>> 24 & 255;
      o[60] = x15 >>> 0 & 255;
      o[61] = x15 >>> 8 & 255;
      o[62] = x15 >>> 16 & 255;
      o[63] = x15 >>> 24 & 255;
    }
    function core_hsalsa20(o, p, k, c) {
      var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
      var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
      for (var i = 0; i < 20; i += 2) {
        u = x0 + x12 | 0;
        x4 ^= u << 7 | u >>> 25;
        u = x4 + x0 | 0;
        x8 ^= u << 9 | u >>> 23;
        u = x8 + x4 | 0;
        x12 ^= u << 13 | u >>> 19;
        u = x12 + x8 | 0;
        x0 ^= u << 18 | u >>> 14;
        u = x5 + x1 | 0;
        x9 ^= u << 7 | u >>> 25;
        u = x9 + x5 | 0;
        x13 ^= u << 9 | u >>> 23;
        u = x13 + x9 | 0;
        x1 ^= u << 13 | u >>> 19;
        u = x1 + x13 | 0;
        x5 ^= u << 18 | u >>> 14;
        u = x10 + x6 | 0;
        x14 ^= u << 7 | u >>> 25;
        u = x14 + x10 | 0;
        x2 ^= u << 9 | u >>> 23;
        u = x2 + x14 | 0;
        x6 ^= u << 13 | u >>> 19;
        u = x6 + x2 | 0;
        x10 ^= u << 18 | u >>> 14;
        u = x15 + x11 | 0;
        x3 ^= u << 7 | u >>> 25;
        u = x3 + x15 | 0;
        x7 ^= u << 9 | u >>> 23;
        u = x7 + x3 | 0;
        x11 ^= u << 13 | u >>> 19;
        u = x11 + x7 | 0;
        x15 ^= u << 18 | u >>> 14;
        u = x0 + x3 | 0;
        x1 ^= u << 7 | u >>> 25;
        u = x1 + x0 | 0;
        x2 ^= u << 9 | u >>> 23;
        u = x2 + x1 | 0;
        x3 ^= u << 13 | u >>> 19;
        u = x3 + x2 | 0;
        x0 ^= u << 18 | u >>> 14;
        u = x5 + x4 | 0;
        x6 ^= u << 7 | u >>> 25;
        u = x6 + x5 | 0;
        x7 ^= u << 9 | u >>> 23;
        u = x7 + x6 | 0;
        x4 ^= u << 13 | u >>> 19;
        u = x4 + x7 | 0;
        x5 ^= u << 18 | u >>> 14;
        u = x10 + x9 | 0;
        x11 ^= u << 7 | u >>> 25;
        u = x11 + x10 | 0;
        x8 ^= u << 9 | u >>> 23;
        u = x8 + x11 | 0;
        x9 ^= u << 13 | u >>> 19;
        u = x9 + x8 | 0;
        x10 ^= u << 18 | u >>> 14;
        u = x15 + x14 | 0;
        x12 ^= u << 7 | u >>> 25;
        u = x12 + x15 | 0;
        x13 ^= u << 9 | u >>> 23;
        u = x13 + x12 | 0;
        x14 ^= u << 13 | u >>> 19;
        u = x14 + x13 | 0;
        x15 ^= u << 18 | u >>> 14;
      }
      o[0] = x0 >>> 0 & 255;
      o[1] = x0 >>> 8 & 255;
      o[2] = x0 >>> 16 & 255;
      o[3] = x0 >>> 24 & 255;
      o[4] = x5 >>> 0 & 255;
      o[5] = x5 >>> 8 & 255;
      o[6] = x5 >>> 16 & 255;
      o[7] = x5 >>> 24 & 255;
      o[8] = x10 >>> 0 & 255;
      o[9] = x10 >>> 8 & 255;
      o[10] = x10 >>> 16 & 255;
      o[11] = x10 >>> 24 & 255;
      o[12] = x15 >>> 0 & 255;
      o[13] = x15 >>> 8 & 255;
      o[14] = x15 >>> 16 & 255;
      o[15] = x15 >>> 24 & 255;
      o[16] = x6 >>> 0 & 255;
      o[17] = x6 >>> 8 & 255;
      o[18] = x6 >>> 16 & 255;
      o[19] = x6 >>> 24 & 255;
      o[20] = x7 >>> 0 & 255;
      o[21] = x7 >>> 8 & 255;
      o[22] = x7 >>> 16 & 255;
      o[23] = x7 >>> 24 & 255;
      o[24] = x8 >>> 0 & 255;
      o[25] = x8 >>> 8 & 255;
      o[26] = x8 >>> 16 & 255;
      o[27] = x8 >>> 24 & 255;
      o[28] = x9 >>> 0 & 255;
      o[29] = x9 >>> 8 & 255;
      o[30] = x9 >>> 16 & 255;
      o[31] = x9 >>> 24 & 255;
    }
  }
});

// node_modules/.pnpm/xsalsa20-universal@1.0.0/node_modules/xsalsa20-universal/browser.js
var require_browser3 = __commonJS({
  "node_modules/.pnpm/xsalsa20-universal@1.0.0/node_modules/xsalsa20-universal/browser.js"(exports, module) {
    var xsalsa20 = require_xsalsa202();
    module.exports = class XORJS {
      constructor(nonce, key) {
        this.instance = xsalsa20(nonce, key);
      }
      update(out, message) {
        this.instance.update(message, out);
      }
      final() {
        this.instance.finalize();
      }
    };
  }
});

// node_modules/.pnpm/simple-hypercore-protocol@2.1.2/node_modules/simple-hypercore-protocol/lib/xor.js
var require_xor = __commonJS({
  "node_modules/.pnpm/simple-hypercore-protocol@2.1.2/node_modules/simple-hypercore-protocol/lib/xor.js"(exports, module) {
    var XSalsa20 = require_browser3();
    var crypto = require_hypercore_crypto();
    module.exports = class XOR {
      constructor(nonces, split) {
        this.rnonce = nonces.rnonce;
        this.tnonce = nonces.tnonce;
        this.rx = new XSalsa20(this.rnonce, split.rx.slice(0, 32));
        this.tx = new XSalsa20(this.tnonce, split.tx.slice(0, 32));
      }
      encrypt(data) {
        this.tx.update(data, data);
        return data;
      }
      decrypt(data) {
        this.rx.update(data, data);
        return data;
      }
      destroy() {
        this.tx.final();
        this.rx.final();
      }
      static nonce() {
        return crypto.randomBytes(24);
      }
    };
  }
});

// node_modules/.pnpm/simple-message-channels@1.2.1/node_modules/simple-message-channels/index.js
var require_simple_message_channels = __commonJS({
  "node_modules/.pnpm/simple-message-channels@1.2.1/node_modules/simple-message-channels/index.js"(exports, module) {
    var varint = require_varint2();
    module.exports = class SimpleMessageChannels {
      constructor({ maxSize = 8 * 1024 * 1024, context = null, onmessage = null, onmissing = null, types = null } = {}) {
        this._message = null;
        this._ptr = 0;
        this._varint = 0;
        this._factor = 1;
        this._length = 0;
        this._header = 0;
        this._state = 0;
        this._consumed = 0;
        this._maxSize = maxSize;
        this._types = types || [];
        this.receiving = false;
        this.destroyed = false;
        this.error = null;
        this.context = context;
        this.onmessage = onmessage;
        this.onmissing = onmissing;
      }
      destroy(err) {
        if (err) this.error = err;
        this.destroyed = true;
      }
      recv(data) {
        if (this.receiving === true) throw new Error("Cannot recursively receive data");
        this.receiving = true;
        let offset = 0;
        while (offset < data.length) {
          if (this._state === 2) offset = this._readMessage(data, offset);
          else offset = this._readVarint(data, offset);
        }
        if (this._state === 2 && this._length === 0) {
          this._readMessage(data, offset);
        }
        this.receiving = false;
        return !this.destroyed;
      }
      _readMessage(data, offset) {
        const free = data.length - offset;
        if (free >= this._length) {
          if (this._message) {
            data.copy(this._message, this._message.length - this._length, offset);
          } else {
            this._message = data.slice(offset, offset + this._length);
          }
          return this._nextState(data, offset += this._length) ? offset : data.length;
        }
        if (!this._message) this._message = Buffer.allocUnsafe(this._length);
        data.copy(this._message, this._message.length - this._length, offset);
        this._length -= free;
        return data.length;
      }
      _readVarint(data, offset) {
        for (; offset < data.length; offset++) {
          this._varint += (data[offset] & 127) * this._factor;
          this._consumed++;
          if (data[offset] < 128) return this._nextState(data, ++offset) ? offset : data.length;
          this._factor *= 128;
        }
        if (this._consumed >= 8) this.destroy(new Error("Incoming varint is invalid"));
        return data.length;
      }
      _nextState(data, offset) {
        switch (this._state) {
          case 0:
            this._state = 1;
            this._factor = 1;
            this._length = this._varint;
            this._consumed = this._varint = 0;
            if (this._length === 0) this._state = 0;
            return true;
          case 1:
            this._state = 2;
            this._factor = 1;
            this._header = this._varint;
            this._length -= this._consumed;
            this._consumed = this._varint = 0;
            if (this._length < 0 || this._length > this._maxSize) {
              this.destroy(new Error("Incoming message is larger than max size"));
              return false;
            }
            if (this.onmissing) {
              const extra = data.length - offset;
              if (this._length > extra) this.onmissing(this._length - extra, this.context);
            }
            return true;
          case 2:
            this._state = 0;
            this._onmessage(this._header >> 4, this._header & 15, this._message, data, offset);
            this._message = null;
            return !this.destroyed;
          default:
            return false;
        }
      }
      _onmessage(channel, type, message, data, offset) {
        if (type >= this._types.length) {
          if (this.onmessage === null) return;
          return this.onmessage(channel, type, message, this.context, data, offset);
        }
        let m = null;
        const { onmessage, encoding, context } = this._types[type];
        try {
          m = encoding.decode(message);
        } catch (err) {
          this.destroy(err);
          return;
        }
        onmessage(channel, m, context, data, offset);
      }
      send(channel, type, message) {
        const header = channel << 4 | type;
        const length = this._encodingLength(type, message) + varint.encodingLength(header);
        const payload = Buffer.allocUnsafe(varint.encodingLength(length) + length);
        varint.encode(length, payload, 0);
        const offset = varint.encode.bytes;
        varint.encode(header, payload, offset);
        this._encode(type, message, payload, offset + varint.encode.bytes);
        return payload;
      }
      sendBatch(messages) {
        let length = 0;
        let offset = 0;
        for (const { type, message } of messages) {
          length += 16 + this._encodingLength(type, message);
        }
        const payload = Buffer.allocUnsafe(length);
        for (const { channel, type, message } of messages) {
          const header = channel << 4 | type;
          const length2 = this._encodingLength(type, message) + varint.encodingLength(header);
          varint.encode(length2, payload, offset);
          offset += varint.encode.bytes;
          varint.encode(header, payload, offset);
          offset += varint.encode.bytes;
          offset += this._encode(type, message, payload, offset);
        }
        return payload.slice(0, offset);
      }
      _encodingLength(type, message) {
        if (type >= this._types.length) return message.length;
        return this._types[type].encoding.encodingLength(message);
      }
      _encode(type, message, buf, offset) {
        if (type >= this._types.length) {
          message.copy(buf, offset);
          return message.length;
        }
        const enc = this._types[type].encoding;
        enc.encode(message, buf, offset);
        return enc.encode.bytes;
      }
    };
  }
});

// node_modules/.pnpm/simple-hypercore-protocol@2.1.2/node_modules/simple-hypercore-protocol/index.js
var require_simple_hypercore_protocol = __commonJS({
  "node_modules/.pnpm/simple-hypercore-protocol@2.1.2/node_modules/simple-hypercore-protocol/index.js"(exports, module) {
    var Handshake = require_handshake();
    var messages = require_messages();
    var XOR = require_xor();
    var SMC = require_simple_message_channels();
    var crypto = require_hypercore_crypto();
    var varint = require_varint2();
    module.exports = class SimpleProtocol {
      constructor(initiator, handlers) {
        const payload = { nonce: XOR.nonce() };
        this.handlers = handlers || {};
        this.remotePayload = null;
        this.remotePublicKey = null;
        this.publicKey = null;
        this.handshakeHash = null;
        this.destroyed = false;
        this._initiator = initiator;
        this._payload = payload;
        this._pending = [];
        this._handshake = null;
        this._split = null;
        this._encryption = null;
        this._noise = !(handlers.encrypted === false && handlers.noise === false);
        this._buffering = null;
        this._handshaking = false;
        this._messages = new SMC({
          onmessage,
          onmissing,
          context: this,
          types: [
            { context: this, onmessage: onopen, encoding: messages.Open },
            { context: this, onmessage: onoptions, encoding: messages.Options },
            { context: this, onmessage: onstatus, encoding: messages.Status },
            { context: this, onmessage: onhave, encoding: messages.Have },
            { context: this, onmessage: onunhave, encoding: messages.Unhave },
            { context: this, onmessage: onwant, encoding: messages.Want },
            { context: this, onmessage: onunwant, encoding: messages.Unwant },
            { context: this, onmessage: onrequest, encoding: messages.Request },
            { context: this, onmessage: oncancel, encoding: messages.Cancel },
            { context: this, onmessage: ondata, encoding: messages.Data },
            { context: this, onmessage: onclose, encoding: messages.Close }
          ]
        });
        if (handlers.encrypted !== false || handlers.noise !== false) {
          this._handshaking = true;
          if (typeof this.handlers.keyPair !== "function") {
            this._onkeypair(null, this.handlers.keyPair || null);
          } else {
            this._buffering = [];
            this.handlers.keyPair(this._onkeypair.bind(this));
          }
        }
      }
      _onkeypair(err, keyPair) {
        if (err) return this.destroy(err);
        if (this._handshake !== null) return;
        this.handlers.keyPair = keyPair;
        const handshake = new Handshake(this._initiator, messages.NoisePayload.encode(this._payload), this.handlers, this._onhandshake.bind(this));
        this.publicKey = handshake.keyPair.publicKey;
        this._handshake = handshake;
        if (this._buffering) {
          while (this._buffering.length) this._recv(this._buffering.shift());
        }
        this._buffering = null;
      }
      open(ch, message) {
        return this._send(ch, 0, message);
      }
      options(ch, message) {
        return this._send(ch, 1, message);
      }
      status(ch, message) {
        return this._send(ch, 2, message);
      }
      have(ch, message) {
        return this._send(ch, 3, message);
      }
      unhave(ch, message) {
        return this._send(ch, 4, message);
      }
      want(ch, message) {
        return this._send(ch, 5, message);
      }
      unwant(ch, message) {
        return this._send(ch, 6, message);
      }
      request(ch, message) {
        return this._send(ch, 7, message);
      }
      cancel(ch, message) {
        return this._send(ch, 8, message);
      }
      data(ch, message) {
        return this._send(ch, 9, message);
      }
      close(ch, message) {
        return this._send(ch, 10, message || {});
      }
      extension(ch, id, message) {
        const buf = Buffer.allocUnsafe(varint.encodingLength(id) + message.length);
        varint.encode(id, buf, 0);
        message.copy(buf, varint.encode.bytes);
        return this._send(ch, 15, buf);
      }
      ping() {
        if (this._handshaking || this._pending.length) return;
        let ping = Buffer.from([0]);
        if (this._encryption !== null) {
          ping = this._encryption.encrypt(ping);
        }
        return this.handlers.send(ping);
      }
      _onhandshake(err, remotePayload, split, overflow, remotePublicKey, handshakeHash) {
        if (err) return this.destroy(new Error("Noise handshake error"));
        if (!remotePayload) return this.destroy(new Error("Remote did not include a handshake payload"));
        this.remotePublicKey = remotePublicKey;
        this.handshakeHash = handshakeHash;
        try {
          remotePayload = messages.NoisePayload.decode(remotePayload);
        } catch (_) {
          return this.destroy(new Error("Could not parse remote payload"));
        }
        this._handshake = null;
        this._handshaking = false;
        this._split = split;
        this._encryption = this.handlers.encrypted === false ? null : new XOR({ rnonce: remotePayload.nonce, tnonce: this._payload.nonce }, split);
        this.remotePayload = remotePayload;
        if (this.handlers.onhandshake) this.handlers.onhandshake();
        if (this.destroyed) return;
        if (overflow) this.recv(overflow);
        while (this._pending.length && !this.destroyed) {
          this._sendNow(...this._pending.shift());
        }
      }
      _send(channel, type, message) {
        if (this._handshaking || this._pending.length) {
          this._pending.push([channel, type, message]);
          return false;
        }
        return this._sendNow(channel, type, message);
      }
      _sendNow(channel, type, message) {
        if (type === 0 && message.key && !message.capability) {
          message.capability = this.capability(message.key);
          message.key = null;
        }
        let data = this._messages.send(channel, type, message);
        if (this._encryption !== null) {
          data = this._encryption.encrypt(data);
        }
        return this.handlers.send(data);
      }
      capability(key) {
        return crypto.capability(key, this._split);
      }
      remoteCapability(key) {
        return crypto.remoteCapability(key, this._split);
      }
      recv(data) {
        if (this._buffering !== null) this._buffering.push(data);
        else this._recv(data);
      }
      _recv(data) {
        if (this.destroyed) return;
        if (this._handshaking) {
          this._handshake.recv(data);
          return;
        }
        if (this._encryption !== null) {
          data = this._encryption.decrypt(data);
        }
        if (!this._messages.recv(data)) {
          this.destroy(this._messages.error);
        }
      }
      destroy(err) {
        if (this.destroyed) return;
        this.destroyed = true;
        if (this._handshake) this._handshake.destroy();
        if (this._encryption) this._encryption.destroy();
        if (this.handlers.destroy) this.handlers.destroy(err);
      }
      static keyPair(seed) {
        return Handshake.keyPair(seed);
      }
    };
    function onopen(ch, message, self) {
      if (self.handlers.onopen) self.handlers.onopen(ch, message);
    }
    function onoptions(ch, message, self) {
      if (self.handlers.onoptions) self.handlers.onoptions(ch, message);
    }
    function onstatus(ch, message, self) {
      if (self.handlers.onstatus) self.handlers.onstatus(ch, message);
    }
    function onhave(ch, message, self) {
      if (self.handlers.onhave) self.handlers.onhave(ch, message);
    }
    function onunhave(ch, message, self) {
      if (self.handlers.onunhave) self.handlers.onunhave(ch, message);
    }
    function onwant(ch, message, self) {
      if (self.handlers.onwant) self.handlers.onwant(ch, message);
    }
    function onunwant(ch, message, self) {
      if (self.handlers.onunwant) self.handlers.onunwant(ch, message);
    }
    function onrequest(ch, message, self) {
      if (self.handlers.onrequest) self.handlers.onrequest(ch, message);
    }
    function oncancel(ch, message, self) {
      if (self.handlers.oncancel) self.handlers.oncancel(ch, message);
    }
    function ondata(ch, message, self) {
      if (self.handlers.ondata) self.handlers.ondata(ch, message);
    }
    function onclose(ch, message, self) {
      if (self.handlers.onclose) self.handlers.onclose(ch, message);
    }
    function onmessage(ch, type, message, self) {
      if (type !== 15) return;
      const id = varint.decode(message);
      const m = message.slice(varint.decode.bytes);
      if (self.handlers.onextension) self.handlers.onextension(ch, id, m);
    }
    function onmissing(bytes, self) {
      if (self.handlers.onmissing) self.handlers.onmissing(bytes);
    }
  }
});

// node_modules/.pnpm/timeout-refresh@1.0.3/node_modules/timeout-refresh/browser.js
var require_browser4 = __commonJS({
  "node_modules/.pnpm/timeout-refresh@1.0.3/node_modules/timeout-refresh/browser.js"(exports, module) {
    module.exports = Timeout;
    function Timeout(ms, fn, ctx) {
      if (!(this instanceof Timeout)) return new Timeout(ms, fn, ctx);
      this.ms = ms;
      this.ontimeout = fn;
      this.context = ctx || null;
      this.called = false;
      this._timeout = setTimeout(call, ms, this);
    }
    Timeout.prototype.refresh = function() {
      if (this.called || this.ontimeout === null) return;
      clearTimeout(this._timeout);
      this._timeout = setTimeout(call, this.ms, this);
    };
    Timeout.prototype.destroy = function() {
      this.ontimeout = null;
      clearTimeout(this._timeout);
    };
    function call(self) {
      self.called = true;
      self.ontimeout.call(self.context);
    }
  }
});

// node_modules/.pnpm/abstract-extension@3.1.1/node_modules/abstract-extension/index.js
var require_abstract_extension = __commonJS({
  "node_modules/.pnpm/abstract-extension@3.1.1/node_modules/abstract-extension/index.js"(exports, module) {
    var codecs = require_codecs();
    var AbstractExtension = class {
      constructor(local, name, handlers = {}) {
        this.id = 0;
        this.name = name;
        this.encoding = codecs(handlers.encoding || "binary");
        this.handlers = handlers;
        this.local = local;
      }
      encode(message) {
        return this.encoding.encode(message);
      }
      remoteSupports() {
        return !!(this.local && this.local.map && this.local.map[this.id] === this);
      }
      onmessage(buf, context) {
        if (!this.handlers.onmessage) return;
        let message;
        try {
          message = this.encoding.decode(buf);
        } catch (err) {
          if (this.handlers.onerror) this.handlers.onerror(err, context);
          return;
        }
        this.handlers.onmessage(message, context);
      }
      get destroyed() {
        return this.local === null;
      }
      destroy() {
        if (this.local === null) return;
        this.local._remove(this);
        this.local = null;
      }
      static createLocal(handlers = null) {
        return new Local(handlers, this);
      }
    };
    var Remote = class {
      constructor(local) {
        this.local = local;
        this.names = null;
        this.map = null;
        this.changes = 0;
      }
      update(names) {
        this.names = names;
        this.changes = 0;
      }
      onmessage(id, message, context = null) {
        if (this.changes !== this.local.changes) {
          this.map = this.names ? match(this.local.messages, this.names) : null;
          this.changes = this.local.changes;
        }
        const m = this.map && this.map[id];
        if (m) m.onmessage(message, context);
      }
    };
    var Local = class {
      constructor(handlers = null, M) {
        this.messages = [];
        this.handlers = handlers;
        this.Extension = M;
        this.changes = 1;
        this.exclusive = true;
      }
      get length() {
        return this.messages.length;
      }
      [Symbol.iterator]() {
        return this.messages[Symbol.iterator]();
      }
      get(name) {
        for (const m of this.messages) {
          if (m.name === name) return m;
        }
        return null;
      }
      add(name, handlers) {
        let m;
        if (typeof handlers !== "function") {
          m = new this.Extension(this, name, handlers);
        } else {
          m = new this.Extension(this, name, {});
          m.handlers = handlers(m) || {};
          m.encoding = codecs(m.handlers.encoding || "binary");
        }
        this.changes++;
        this.messages.push(m);
        this.messages.sort(sortMessages);
        for (let i = 0; i < this.messages.length; i++) {
          this.messages[i].id = i;
        }
        if (this.exclusive) {
          if (m.id > 0 && this.messages[m.id - 1].name === m.name || m.id < this.messages.length - 1 && this.messages[m.id + 1].name === m.name) {
            this._remove(m);
            throw new Error("Cannot add multiple messages with the same name");
          }
        }
        if (this.handlers && this.handlers.onextensionupdate) this.handlers.onextensionupdate();
        return m;
      }
      remote() {
        return new Remote(this);
      }
      _remove(m) {
        this.changes++;
        this.messages.splice(m.id, 1);
        m.id = -1;
        if (this.handlers && this.handlers.onextensionupdate) this.handlers.onextensionupdate();
      }
      names() {
        const names = new Array(this.messages.length);
        for (let i = 0; i < names.length; i++) {
          names[i] = this.messages[i].name;
        }
        return names;
      }
    };
    function sortMessages(a, b) {
      return a.name < b.name ? -1 : a.name > b.name ? 1 : 0;
    }
    function match(local, remote) {
      let i = 0;
      let j = 0;
      const map = new Array(remote.length);
      while (i < local.length && j < remote.length) {
        const l = local[i].name;
        const r = remote[j];
        if (l < r) i++;
        else if (l > r) j++;
        else map[j++] = local[i];
      }
      return map;
    }
    module.exports = AbstractExtension;
  }
});

// node_modules/.pnpm/ms@2.1.2/node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/.pnpm/ms@2.1.2/node_modules/ms/index.js"(exports, module) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module.exports = function(val2, options) {
      options = options || {};
      var type = typeof val2;
      if (type === "string" && val2.length > 0) {
        return parse(val2);
      } else if (type === "number" && isFinite(val2)) {
        return options.long ? fmtLong(val2) : fmtShort(val2);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val2)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/common.js"(exports, module) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self.diff = ms;
          self.prev = prevTime;
          self.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val2 = args[index];
              match = formatter.call(self, val2);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self, args);
          const logFn = self.log || createDebug.log;
          logFn.apply(self, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val2) {
        if (val2 instanceof Error) {
          return val2.stack || val2.message;
        }
        return val2;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module.exports = setup;
  }
});

// node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/browser.js
var require_browser5 = __commonJS({
  "node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/browser.js"(exports, module) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/.pnpm/hypercore-protocol@8.0.7/node_modules/hypercore-protocol/index.js
var require_hypercore_protocol = __commonJS({
  "node_modules/.pnpm/hypercore-protocol@8.0.7/node_modules/hypercore-protocol/index.js"(exports, module) {
    var SHP = require_simple_hypercore_protocol();
    var crypto = require_hypercore_crypto();
    var timeout = require_browser4();
    var inspect = require_browser();
    var Nanoguard = require_nanoguard();
    var pretty = require_pretty_hash();
    var Message = require_abstract_extension();
    var { Duplex } = import$streamx;
    var debug = require_browser5()("hypercore-protocol");
    var StreamExtension = class extends Message {
      send(message) {
        const stream = this.local.handlers;
        if (stream._changes !== this.local.changes) {
          stream._changes = this.local.changes;
          stream.state.options(0, { extensions: this.local.names() });
        }
        return stream.state.extension(0, this.id, this.encode(message));
      }
    };
    var Channelizer = class {
      constructor(stream, { encrypted, noise, keyPair }) {
        this.stream = stream;
        this.created = /* @__PURE__ */ new Map();
        this.local = [null];
        this.remote = [null];
        this.noise = !(noise === false && encrypted === false);
        this.encrypted = encrypted !== false;
        this.keyPair = keyPair;
      }
      allocLocal() {
        const id = this.local.indexOf(null);
        if (id > 0) return id;
        this.local.push(null);
        return this.local.length - 1;
      }
      attachLocal(ch) {
        const id = this.allocLocal();
        this.local[id] = ch;
        ch.localId = id;
      }
      attachRemote(ch, id) {
        if (this.remote.length === id) this.remote.push(null);
        this.remote[id] = ch;
        ch.remoteId = id;
      }
      detachChannel(ch) {
        if (ch.localId > -1 && this.local[ch.localId] === ch) {
          this.local[ch.localId] = null;
          ch.localId = -1;
          if (ch.handlers && ch.handlers.onclose) ch.handlers.onclose();
        }
        if (ch.remoteId > -1 && this.remote[ch.remoteId] === ch) {
          this.remote[ch.remoteId] = null;
        }
        const hex = ch.discoveryKey.toString("hex");
        if (this.created.get(hex) === ch) this.created.delete(hex);
      }
      getChannel(dk) {
        return this.created.get(dk.toString("hex"));
      }
      createChannel(dk) {
        const hex = dk.toString("hex");
        const old = this.created.get(hex);
        if (old) return old;
        const fresh = new Channel(this.stream.state, this.stream, dk);
        this.created.set(hex, fresh);
        return fresh;
      }
      onauthenticate(key, done) {
        if (this.stream.handlers && this.stream.handlers.onauthenticate) this.stream.handlers.onauthenticate(key, done);
        else done(null);
      }
      onhandshake() {
        debug("recv handshake");
        if (this.stream.handlers && this.stream.handlers.onhandshake) this.stream.handlers.onhandshake();
        this.stream.emit("handshake");
      }
      onopen(channelId, message) {
        debug("recv open", channelId, message);
        const ch = this.createChannel(message.discoveryKey);
        ch.remoteCapability = message.capability;
        this.attachRemote(ch, channelId);
        if (ch.localId === -1) {
          if (this.stream.handlers.ondiscoverykey) this.stream.handlers.ondiscoverykey(ch.discoveryKey);
          this.stream.emit("discovery-key", ch.discoveryKey);
        } else {
          if (this.noise && !ch.remoteVerified) {
            this.stream.destroy(new Error("Invalid remote channel capability"));
            return;
          }
          this.stream.emit("duplex-channel", ch);
        }
        if (ch.handlers && ch.handlers.onopen) ch.handlers.onopen();
        if (this.stream.handlers.onremoteopen) this.stream.handlers.onremoteopen(ch.discoveryKey);
        this.stream.emit("remote-open", ch.discoveryKey);
      }
      onoptions(channelId, message) {
        debug("recv options", channelId, message);
        const ch = this.remote[channelId];
        if (ch && ch.handlers && ch.handlers.onoptions) ch.handlers.onoptions(message);
        else if (channelId === 0 && !ch) this.stream._updateExtensions(message.extensions);
      }
      onstatus(channelId, message) {
        debug("recv status", channelId, message);
        const ch = this.remote[channelId];
        if (ch && ch.handlers && ch.handlers.onstatus) ch.handlers.onstatus(message);
      }
      onhave(channelId, message) {
        debug("recv have", channelId, message);
        const ch = this.remote[channelId];
        if (ch && ch.handlers && ch.handlers.onhave) ch.handlers.onhave(message);
      }
      onunhave(channelId, message) {
        debug("recv unhave", channelId, message);
        const ch = this.remote[channelId];
        if (ch && ch.handlers && ch.handlers.onunhave) ch.handlers.onunhave(message);
      }
      onwant(channelId, message) {
        debug("recv want", channelId, message);
        const ch = this.remote[channelId];
        if (ch && ch.handlers && ch.handlers.onwant) ch.handlers.onwant(message);
      }
      onunwant(channelId, message) {
        debug("recv unwant", channelId, message);
        const ch = this.remote[channelId];
        if (ch && ch.handlers && ch.handlers.onunwant) ch.handlers.onunwant(message);
      }
      onrequest(channelId, message) {
        debug("recv request", channelId, message);
        const ch = this.remote[channelId];
        if (ch && ch.handlers && ch.handlers.onrequest) ch.handlers.onrequest(message);
      }
      oncancel(channelId, message) {
        debug("recv cancel", channelId, message);
        const ch = this.remote[channelId];
        if (ch && ch.handlers && ch.handlers.oncancel) ch.handlers.oncancel(message);
      }
      ondata(channelId, message) {
        debug("recv data", channelId, message);
        const ch = this.remote[channelId];
        if (ch && ch.handlers && ch.handlers.ondata) ch.handlers.ondata(message);
      }
      onextension(channelId, id, buf) {
        debug("recv extension", channelId, id);
        const ch = this.remote[channelId];
        if (ch && ch.handlers && ch.handlers.onextension) ch.handlers.onextension(id, buf);
        else if (channelId === 0 && !ch) this.stream.remoteExtensions.onmessage(id, buf);
      }
      onclose(channelId, message) {
        debug("recv close", channelId, message);
        let ch = channelId < this.remote.length ? this.remote[channelId] : null;
        if (ch) {
          this.remote[channelId] = null;
        } else if (message.discoveryKey) {
          ch = this.getChannel(message.discoveryKey);
        }
        if (!ch) return;
        if (ch.localId > -1 && this.local[ch.localId] === ch) {
          this.local[ch.localId] = null;
          ch.state.close(ch.localId, {});
          ch.localId = -1;
          if (ch.handlers && ch.handlers.onclose) ch.handlers.onclose();
        }
        if (this.stream.handlers && this.stream.handlers.onchannelclose) {
          this.stream.handlers.onchannelclose(ch.discoveryKey, ch.key);
        }
        const hex = ch.discoveryKey.toString("hex");
        if (this.created.get(hex) === ch) this.created.delete(hex);
        this.stream._prefinalize();
      }
      onmissing(bytes) {
        if (this.stream._utp === null) return;
        this.stream._utp.setContentSize(bytes);
      }
      // called by the state machine
      send(data) {
        if (this.stream.keepAlive !== null) this.stream.keepAlive.refresh();
        this.stream.bytesSent += data.length;
        return this.stream.push(data);
      }
      // called by the state machine
      destroy(err) {
        this.stream.destroy(err);
        this.local = [];
        this.remote = [];
        for (const ch of this.created.values()) {
          const closed = ch.localId === -1;
          ch.localId = ch.remoteId = -1;
          if (!closed && ch.handlers && ch.handlers.onclose) ch.handlers.onclose();
          if (this.stream.handlers && this.stream.handlers.onchannelclose) {
            this.stream.handlers.onchannelclose(ch.discoveryKey, ch.key);
          }
        }
        this.created.clear();
      }
    };
    var Channel = class {
      constructor(state, stream, dk) {
        this.key = null;
        this.discoveryKey = dk;
        this.localId = -1;
        this.remoteId = -1;
        this.remoteCapability = null;
        this.handlers = null;
        this.state = state;
        this.stream = stream;
      }
      get opened() {
        return this.localId > -1;
      }
      get closed() {
        return this.localId === -1;
      }
      get remoteOpened() {
        return this.remoteId > -1;
      }
      get remoteVerified() {
        return this.localId > -1 && this.remoteId > -1 && !!this.remoteCapability && this.remoteCapability.equals(this.state.remoteCapability(this.key));
      }
      options(message) {
        debug("send options", message);
        return this.state.options(this.localId, message);
      }
      status(message) {
        debug("send status", message);
        return this.state.status(this.localId, message);
      }
      have(message) {
        debug("send have", message);
        return this.state.have(this.localId, message);
      }
      unhave(message) {
        debug("send unhave", message);
        return this.state.unhave(this.localId, message);
      }
      want(message) {
        debug("send want", message);
        return this.state.want(this.localId, message);
      }
      unwant(message) {
        debug("send unwant", message);
        return this.state.unwant(this.localId, message);
      }
      request(message) {
        debug("send request", message);
        return this.state.request(this.localId, message);
      }
      cancel(message) {
        debug("send cancel", message);
        return this.state.cancel(this.localId, message);
      }
      data(message) {
        debug("send data", message);
        return this.state.data(this.localId, message);
      }
      extension(id, buf) {
        debug("send extension", id);
        return this.state.extension(this.localId, id, buf);
      }
      close() {
        debug("send close");
        if (this.closed) return;
        const localId = this.localId;
        this.stream.channelizer.detachChannel(this);
        this.state.close(localId, {});
        this.stream._prefinalize();
      }
      destroy(err) {
        this.stream.destroy(err);
      }
    };
    module.exports = class ProtocolStream extends Duplex {
      constructor(initiator, handlers = {}) {
        super();
        if (typeof initiator !== "boolean") throw new Error("Must specify initiator boolean in replication stream");
        this.initiator = initiator;
        this.handlers = handlers;
        this.channelizer = new Channelizer(this, {
          encrypted: handlers.encrypted,
          noise: handlers.noise,
          keyPair: handlers.keyPair
        });
        this.state = new SHP(initiator, this.channelizer);
        this.live = !!handlers.live;
        this.timeout = null;
        this.keepAlive = null;
        this.prefinalize = new Nanoguard();
        this.bytesSent = 0;
        this.bytesReceived = 0;
        this.extensions = StreamExtension.createLocal(this);
        this.remoteExtensions = this.extensions.remote();
        this._utp = null;
        this._changes = 0;
        this.once("finish", this.push.bind(this, null));
        this.on("pipe", this._onpipe);
        if (handlers.timeout !== false && handlers.timeout !== 0) {
          const timeout2 = handlers.timeout || 2e4;
          this.setTimeout(timeout2, () => this.destroy(new Error("ETIMEDOUT")));
          this.setKeepAlive(Math.ceil(timeout2 / 2));
        }
      }
      registerExtension(name, handlers) {
        return this.extensions.add(name, handlers);
      }
      [inspect](depth, opts) {
        let indent = "";
        if (typeof opts.indentationLvl === "number") {
          while (indent.length < opts.indentationLvl) indent += " ";
        }
        return "HypercoreProtocolStream(\n" + indent + "  publicKey: " + opts.stylize(this.publicKey && pretty(this.publicKey), "string") + "\n" + indent + "  remotePublicKey: " + opts.stylize(this.remotePublicKey && pretty(this.remotePublicKey), "string") + "\n" + indent + "  remoteAddress: " + opts.stylize(this.remoteAddress, "string") + "\n" + indent + "  remoteType: " + opts.stylize(this.remoteType, "string") + "\n" + indent + "  live: " + opts.stylize(this.live, "boolean") + "\n" + indent + "  initiator: " + opts.stylize(this.initiator, "boolean") + "\n" + indent + "  channelCount: " + opts.stylize(this.channelCount, "number") + "\n" + indent + "  destroyed: " + opts.stylize(this.destroyed, "boolean") + "\n" + indent + "  prefinalized: " + opts.stylize(!this.prefinalize.waiting, "boolean") + "\n" + indent + "  bytesSent: " + opts.stylize(this.bytesSent, "number") + "\n" + indent + "  bytesReceived: " + opts.stylize(this.bytesReceived, "number") + "\n" + indent + ")";
      }
      static isProtocolStream(s) {
        return !!(s && typeof s.initiator === "boolean" && typeof s.pipe === "function" && s.state);
      }
      static keyPair(seed) {
        return SHP.keyPair(seed);
      }
      get remoteAddress() {
        const to = this._readableState.pipeTo;
        if (!to) return null;
        if (ProtocolStream.isProtocolStream(to)) return null;
        return to.remoteAddress;
      }
      get remoteType() {
        const to = this._readableState.pipeTo;
        if (!to) return null;
        if (to._utp) return "utp";
        if (to.remoteAddress) return "tcp";
        return "unknown";
      }
      get publicKey() {
        return this.state.publicKey;
      }
      get remotePublicKey() {
        return this.state.remotePublicKey;
      }
      _onpipe(dest) {
        if (typeof dest.setContentSize === "function") this._utp = dest;
      }
      _write(data, cb) {
        if (this.timeout !== null) this.timeout.refresh();
        this.bytesReceived += data.length;
        this.state.recv(data);
        cb(null);
      }
      _destroy(cb) {
        this._predestroy();
        this.channelizer.destroy();
        this.state.destroy();
        cb(null);
      }
      _predestroy() {
        if (this.timeout !== null) {
          this.timeout.destroy();
          this.timeout = null;
        }
        if (this.keepAlive !== null) {
          this.keepAlive.destroy();
          this.keepAlive = null;
        }
        this.prefinalize.destroy();
      }
      _prefinalize() {
        this.emit("prefinalize");
        this.prefinalize.ready(() => {
          if (this.destroyed) return;
          if (this.channelCount) return;
          if (this.live) return;
          this.finalize();
        });
      }
      _updateExtensions(names) {
        this.remoteExtensions.update(names);
        if (this.handlers.onextensions) this.handlers.onextensions(names);
        this.emit("extensions", names);
      }
      remoteOpened(key) {
        const ch = this.channelizer.getChannel(crypto.discoveryKey(key));
        return !!(ch && ch.remoteId > -1);
      }
      remoteVerified(key) {
        const ch = this.channelizer.getChannel(crypto.discoveryKey(key));
        return !!ch && !!ch.remoteCapability && ch.remoteCapability.equals(this.state.remoteCapability(key));
      }
      opened(key) {
        const ch = this.channelizer.getChannel(crypto.discoveryKey(key));
        return !!(ch && ch.localId > -1);
      }
      ping() {
        return this.state.ping();
      }
      setKeepAlive(ms) {
        if (this.keepAlive) this.keepAlive.destroy();
        if (!ms) {
          this.keepAlive = null;
          return;
        }
        this.keepAlive = timeout(ms, ping, this);
        function ping() {
          this.ping();
          this.keepAlive = timeout(ms, ping, this);
        }
      }
      setTimeout(ms, ontimeout) {
        if (this.timeout) this.timeout.destroy();
        if (!ms) {
          this.timeout = null;
          return;
        }
        this.timeout = timeout(ms, this.emit.bind(this, "timeout"));
        if (ontimeout) this.once("timeout", ontimeout);
      }
      get channelCount() {
        return this.channelizer.created.size;
      }
      get channels() {
        return this.channelizer.created.values();
      }
      open(key, handlers) {
        const discoveryKey = crypto.discoveryKey(key);
        const ch = this.channelizer.createChannel(discoveryKey);
        if (ch.key === null) {
          ch.key = key;
          this.channelizer.attachLocal(ch);
          this.state.open(ch.localId, { key, discoveryKey });
        }
        if (handlers) ch.handlers = handlers;
        if (ch.remoteId > -1) this.emit("duplex-channel", ch);
        return ch;
      }
      close(discoveryKey) {
        const ch = this.channelizer.getChannel(discoveryKey);
        if (ch && ch.localId > -1) {
          ch.close();
          return;
        }
        this.state.close(this.channelizer.allocLocal(), { discoveryKey });
      }
      finalize() {
        this.push(null);
      }
    };
  }
});

// node_modules/.pnpm/count-trailing-zeros@1.0.1/node_modules/count-trailing-zeros/ctz.js
var require_ctz = __commonJS({
  "node_modules/.pnpm/count-trailing-zeros@1.0.1/node_modules/count-trailing-zeros/ctz.js"(exports, module) {
    module.exports = function(v) {
      var c = 32;
      v &= -v;
      if (v) c--;
      if (v & 65535) c -= 16;
      if (v & 16711935) c -= 8;
      if (v & 252645135) c -= 4;
      if (v & 858993459) c -= 2;
      if (v & 1431655765) c -= 1;
      return c;
    };
  }
});

// node_modules/.pnpm/fast-bitfield@1.2.2/node_modules/fast-bitfield/index.js
var require_fast_bitfield = __commonJS({
  "node_modules/.pnpm/fast-bitfield@1.2.2/node_modules/fast-bitfield/index.js"(exports, module) {
    "use strict";
    var ctz = require_ctz();
    module.exports = () => new Bitfield();
    var Page = class {
      constructor(level) {
        const buf = new Uint8Array(level ? 8456 : 4360);
        const b = buf.byteOffset;
        this.buffer = buf;
        this.bits = level ? null : new Uint32Array(buf.buffer, b, 1024);
        this.children = level ? new Array(32768) : null;
        this.level = level;
        this.allOne = level ? [
          new Uint32Array(buf.buffer, b, 1024),
          new Uint32Array(buf.buffer, b + 4096, 32),
          new Uint32Array(buf.buffer, b + 4224, 1)
        ] : [
          this.bits,
          new Uint32Array(buf.buffer, b + 4096, 32),
          new Uint32Array(buf.buffer, b + 4224, 1)
        ];
        this.oneOne = level ? [
          new Uint32Array(buf.buffer, b + 4228, 1024),
          new Uint32Array(buf.buffer, b + 8324, 32),
          new Uint32Array(buf.buffer, b + 8452, 1)
        ] : [
          this.bits,
          new Uint32Array(buf.buffer, b + 4228, 32),
          new Uint32Array(buf.buffer, b + 4356, 1)
        ];
      }
    };
    var ZEROS = [new Page(0), new Page(1), new Page(2), new Page(3)];
    var MASK = new Uint32Array(32);
    var MASK_INCL = new Uint32Array(32);
    for (i = 0; i < 32; i++) {
      MASK[i] = Math.pow(2, 31 - i) - 1;
      MASK_INCL[i] = Math.pow(2, 32 - i) - 1;
    }
    var i;
    var LITTLE_ENDIAN = new Uint8Array(MASK.buffer, MASK.byteOffset, 1)[0] === 255;
    var Bitfield = class {
      constructor() {
        this.length = 32768;
        this.littleEndian = LITTLE_ENDIAN;
        this._path = new Uint16Array(5);
        this._offsets = new Uint16Array(this._path.buffer, this._path.byteOffset + 2, 4);
        this._parents = new Array(4).fill(null);
        this._page = new Page(0);
        this._allocs = 1;
      }
      last() {
        var page = this._page;
        var b = 0;
        while (true) {
          for (var i2 = 2; i2 >= 0; i2--) {
            const c = ctz(page.oneOne[i2][b]);
            if (c === 32) return -1;
            b = (b << 5) + (31 - c);
          }
          this._path[page.level] = b;
          if (!page.level) return defactor(this._path);
          page = page.children[b];
          b = 0;
        }
      }
      set(index, bit) {
        const page = this._getPage(index, bit);
        if (!page) return false;
        const i2 = this._path[0];
        const r = i2 & 31;
        const b = i2 >>> 5;
        const prev = page.bits[b];
        page.bits[b] = bit ? prev | 2147483648 >>> r : prev & ~(2147483648 >>> r);
        const upd = page.bits[b];
        if (upd === prev) return false;
        this._updateAllOne(page, b, upd);
        this._updateOneOne(page, b, upd);
        return true;
      }
      get(index) {
        const page = this._getPage(index, false);
        if (!page) return false;
        const i2 = this._path[0];
        const r = i2 & 31;
        return (page.bits[i2 >>> 5] & 2147483648 >>> r) !== 0;
      }
      iterator() {
        return new Iterator(this);
      }
      fill(val2, start, end) {
        if (!start) start = 0;
        if (val2 === true) return this._fillBit(true, start, end === 0 ? end : end || this.length);
        if (val2 === false) return this._fillBit(false, start, end === 0 ? end : end || this.length);
        this._fillBuffer(val2, start, end === 0 ? end : end || start + 8 * val2.length);
      }
      grow() {
        if (this._page.level === 3) throw new Error("Cannot grow beyond " + this.length);
        const page = this._page;
        this._page = new Page(page.level + 1);
        this._page.children[0] = page;
        if (this._page.level === 3) this.length = Number.MAX_SAFE_INTEGER;
        else this.length *= 32768;
      }
      _fillBuffer(buf, start, end) {
        if (start & 7 || end & 7) throw new Error("Offsets must be a multiple of 8");
        start /= 8;
        while (end > this.length) this.grow();
        end /= 8;
        const offset = start;
        var page = this._getPage(8 * start, true);
        while (start < end) {
          const delta = end - start < 4096 ? end - start : 4096;
          const s = start - offset;
          start += this._setPageBuffer(page, buf.subarray(s, s + delta), start & 1023);
          if (start !== end) page = this._nextPage(page, 8 * start);
        }
      }
      _fillBit(bit, start, end) {
        var page = this._getPage(start, bit);
        while (start < end) {
          const delta = end - start < 32768 ? end - start : 32768;
          start += this._setPageBits(page, bit, start & 32767, delta);
          if (start !== end) page = this._nextPage(page, start);
        }
      }
      _nextPage(page, start) {
        const i2 = ++this._offsets[page.level];
        return i2 === 32768 ? this._getPage(start, true) : this._parents[page.level].children[i2] || this._addPage(this._parents[page.level], i2);
      }
      _setPageBuffer(page, buf, start) {
        new Uint8Array(page.bits.buffer, page.bits.byteOffset, page.bits.length * 4).set(buf, start);
        start >>>= 2;
        this._update(page, start, start + (buf.length >>> 2) + (buf.length & 3 ? 1 : 0));
        return buf.length;
      }
      _setPageBits(page, bit, start, end) {
        const s = start >>> 5;
        const e = end >>> 5;
        const sm = 4294967295 >>> (start & 31);
        const em = ~(4294967295 >>> (end & 31));
        if (s === e) {
          page.bits[s] = bit ? page.bits[s] | sm & em : page.bits[s] & ~(sm & em);
          this._update(page, s, s + 1);
          return end - start;
        }
        page.bits[s] = bit ? page.bits[s] | sm : page.bits[s] & ~sm;
        if (e - s > 2) page.bits.fill(bit ? 4294967295 : 0, s + 1, e - 1);
        if (e === 1024) {
          page.bits[e - 1] = bit ? 4294967295 : 0;
          this._update(page, s, e);
          return end - start;
        }
        page.bits[e] = bit ? page.bits[e] | em : page.bits[e] & ~em;
        this._update(page, s, e + 1);
        return end - start;
      }
      _update(page, start, end) {
        for (; start < end; start++) {
          const upd = page.bits[start];
          this._updateAllOne(page, start, upd);
          this._updateOneOne(page, start, upd);
        }
      }
      _updateAllOne(page, b, upd) {
        var i2 = 1;
        do {
          for (; i2 < 3; i2++) {
            const buf = page.allOne[i2];
            const r = b & 31;
            const prev = buf[b >>>= 5];
            buf[b] = upd === 4294967295 ? prev | 2147483648 >>> r : prev & ~(2147483648 >>> r);
            upd = buf[b];
            if (upd === prev) return;
          }
          b += this._offsets[page.level];
          page = this._parents[page.level];
          i2 = 0;
        } while (page);
      }
      _updateOneOne(page, b, upd) {
        var i2 = 1;
        do {
          for (; i2 < 3; i2++) {
            const buf = page.oneOne[i2];
            const r = b & 31;
            const prev = buf[b >>>= 5];
            buf[b] = upd !== 0 ? prev | 2147483648 >>> r : prev & ~(2147483648 >>> r);
            upd = buf[b];
            if (upd === prev) return;
          }
          b += this._offsets[page.level];
          page = this._parents[page.level];
          i2 = 0;
          if (upd === 0 && page) {
            page.children[this._offsets[page.level - 1]] = void 0;
          }
        } while (page);
      }
      _getPage(index, createIfMissing) {
        factor(index, this._path);
        while (index >= this.length) {
          if (!createIfMissing) return null;
          this.grow();
        }
        var page = this._page;
        for (var i2 = page.level; i2 > 0 && page; i2--) {
          const p = this._path[i2];
          this._parents[i2 - 1] = page;
          page = page.children[p] || (createIfMissing ? this._addPage(page, p) : null);
        }
        return page;
      }
      _addPage(page, i2) {
        this._allocs++;
        page = page.children[i2] = new Page(page.level - 1);
        return page;
      }
    };
    var Iterator = class {
      constructor(bitfield) {
        this._bitfield = bitfield;
        this._path = new Uint16Array(5);
        this._offsets = new Uint16Array(this._path.buffer, this._path.byteOffset + 2, 4);
        this._parents = new Array(4).fill(null);
        this._page = null;
        this._allocs = bitfield._allocs;
        this.seek(0);
      }
      seek(index) {
        this._allocs = this._bitfield._allocs;
        if (index >= this._bitfield.length) {
          this._page = null;
          return this;
        }
        factor(index, this._path);
        this._page = this._bitfield._page;
        for (var i2 = this._page.level; i2 > 0; i2--) {
          this._parents[i2 - 1] = this._page;
          this._page = this._page.children[this._path[i2]] || ZEROS[i2 - 1];
        }
        return this;
      }
      next(bit) {
        return bit ? this.nextTrue() : this.nextFalse();
      }
      nextFalse() {
        if (this._allocs !== this._bitfield._allocs) {
          this.seek(defactor(this._path));
        }
        var page = this._page;
        var b = this._path[0];
        var mask = MASK_INCL;
        while (page) {
          for (var i2 = 0; i2 < 3; i2++) {
            const r = b & 31;
            const clz = Math.clz32(~page.allOne[i2][b >>>= 5] & mask[r]);
            if (clz !== 32) return this._downLeftFalse(page, i2, b, clz);
            mask = MASK;
          }
          b = this._offsets[page.level];
          page = this._parents[page.level];
        }
        return -1;
      }
      _downLeftFalse(page, i2, b, clz) {
        while (true) {
          while (i2) {
            b = (b << 5) + clz;
            clz = Math.clz32(~page.allOne[--i2][b]);
          }
          b = (b << 5) + clz;
          if (!page.level) break;
          this._parents[page.level - 1] = page;
          this._path[page.level] = b;
          page = page.children[b];
          i2 = 3;
          clz = b = 0;
        }
        this._page = page;
        this._path[0] = b;
        return this._inc();
      }
      nextTrue() {
        var page = this._page;
        var b = this._path[0];
        var mask = MASK_INCL;
        while (page) {
          for (var i2 = 0; i2 < 3; i2++) {
            const r = b & 31;
            const clz = Math.clz32(page.oneOne[i2][b >>>= 5] & mask[r]);
            if (clz !== 32) return this._downLeftTrue(page, i2, b, clz);
            mask = MASK;
          }
          b = this._offsets[page.level];
          page = this._parents[page.level];
        }
        return -1;
      }
      _downLeftTrue(page, i2, b, clz) {
        while (true) {
          while (i2) {
            b = (b << 5) + clz;
            clz = Math.clz32(page.oneOne[--i2][b]);
          }
          b = (b << 5) + clz;
          if (!page.level) break;
          this._parents[page.level - 1] = page;
          this._path[page.level] = b;
          page = page.children[b];
          i2 = 3;
          clz = b = 0;
        }
        this._page = page;
        this._path[0] = b;
        return this._inc();
      }
      _inc() {
        const n = defactor(this._path);
        if (this._path[0] < 32767) this._path[0]++;
        else this.seek(n + 1);
        return n;
      }
    };
    function defactor(out) {
      return ((out[3] * 32768 + out[2]) * 32768 + out[1]) * 32768 + out[0];
    }
    function factor(n, out) {
      n = (n - (out[0] = n & 32767)) / 32768;
      n = (n - (out[1] = n & 32767)) / 32768;
      out[3] = (n - (out[2] = n & 32767)) / 32768 & 32767;
    }
  }
});

// node_modules/.pnpm/hypercore@9.12.0/node_modules/hypercore/lib/replicate.js
var require_replicate = __commonJS({
  "node_modules/.pnpm/hypercore@9.12.0/node_modules/hypercore/lib/replicate.js"(exports, module) {
    var Protocol = require_hypercore_protocol();
    var timeout = require_browser4();
    var bitfield = require_fast_bitfield();
    var set = require_unordered_set();
    var rle = require_bitfield_rle().align(4);
    var treeIndex = require_tree_index();
    var EMPTY = new Uint8Array(1024);
    module.exports = replicate;
    function replicate(feed, initiator, opts) {
      feed.ifAvailable.wait();
      var stream = Protocol.isProtocolStream(initiator) ? initiator : opts.stream;
      if (!stream) {
        if (!opts.keyPair) opts.keyPair = feed.noiseKeyPair;
        stream = new Protocol(initiator, opts);
      }
      if (feed.opened) onready(null);
      else feed.ready(onready);
      return stream;
      function onready(err) {
        feed.ifAvailable.continue();
        if (err) return stream.destroy(err);
        if (stream.destroyed) return;
        if (stream.opened(feed.key)) return;
        if (opts.noise !== false && opts.onfeedauthenticate) {
          if (!stream.remotePublicKey) {
            feed.ifAvailable.wait();
            stream.setMaxListeners(0);
            stream.on("close", onhandshake);
            stream.on("handshake", onhandshake);
            return;
          }
          feedauthenticate();
          return;
        }
        replicatePeer();
      }
      function onhandshake() {
        feed.ifAvailable.continue();
        stream.off("close", onhandshake);
        stream.off("handshake", onhandshake);
        feedauthenticate();
      }
      function feedauthenticate() {
        if (stream.destroyed) return;
        if (stream.opened(feed.key)) return;
        feed.ifAvailable.wait();
        opts.onfeedauthenticate(feed, stream.remotePublicKey, function(err) {
          feed.ifAvailable.continue();
          if (stream.destroyed) return;
          if (stream.opened(feed.key)) return;
          if (err) {
            stream.close(feed.discoveryKey);
            return;
          }
          replicatePeer();
        });
      }
      function replicatePeer() {
        if (opts.noise !== false) {
          if (stream.remoteOpened(feed.key) && !stream.remoteVerified(feed.key)) {
            stream.close(feed.discoveryKey);
            return;
          }
        }
        var peer = new Peer(feed, opts);
        peer.feed = feed;
        peer.stream = stream.open(feed.key, peer);
        stream.setMaxListeners(0);
        peer.ready();
        feed.emit("replicating", stream);
      }
    }
    function Peer(feed, opts) {
      if (opts.extensions) throw new Error("Per peer extensions is not supported. Use feed.registerExtension instead");
      this.feed = feed;
      this.stream = null;
      this.wants = bitfield();
      this.remoteBitfield = bitfield();
      this.remoteLength = 0;
      this.remoteWant = false;
      this.remoteTree = null;
      this.remoteAck = false;
      this.remoteOpened = false;
      this.live = !!opts.live;
      this.sparse = feed.sparse;
      this.ack = !!opts.ack;
      this.remoteDownloading = true;
      this.remoteUploading = true;
      this.remoteExtensions = feed.extensions.remote();
      this.downloading = typeof opts.download === "boolean" ? opts.download : feed.downloading;
      this.uploading = typeof opts.upload === "boolean" ? opts.upload : feed.uploading;
      this.updated = false;
      this.maxRequests = opts.maxRequests || feed.maxRequests || 16;
      this.urgentRequests = this.maxRequests + 16;
      this.inflightRequests = [];
      this.inflightWants = 0;
      this._index = -1;
      this._lastBytes = 0;
      this._first = true;
      this._closed = false;
      this._destroyed = false;
      this._defaultDownloading = this.downloading;
      this._iterator = this.remoteBitfield.iterator();
      this._requestTimeout = null;
      this.stats = !opts.stats ? null : {
        uploadedBytes: 0,
        uploadedBlocks: 0,
        downloadedBytes: 0,
        downloadedBlocks: 0
      };
    }
    Object.defineProperty(Peer.prototype, "remoteAddress", {
      enumerable: true,
      get: function() {
        return this.stream.stream.remoteAddress;
      }
    });
    Object.defineProperty(Peer.prototype, "remoteType", {
      enumerable: true,
      get: function() {
        return this.stream.stream.remoteType;
      }
    });
    Object.defineProperty(Peer.prototype, "remotePublicKey", {
      enumerable: true,
      get: function() {
        return this.stream.state.remotePublicKey;
      }
    });
    Peer.prototype.onwant = function(want) {
      if (!this.uploading) return;
      if (want.start & 8191 || want.length & 8191) return;
      if (!this.remoteWant && this.feed.length && this.feed.bitfield.get(this.feed.length - 1)) {
        this.stream.have({ start: this.feed.length - 1 });
      }
      this.remoteWant = true;
      var rle2 = this.feed.bitfield.compress(want.start, want.length);
      this.stream.have({ start: want.start, length: want.length, bitfield: rle2 });
    };
    Peer.prototype.ondata = function(data) {
      var self = this;
      var allowPush = this.feed.allowPush || !data.value;
      if (!allowPush && !this.feed._reserved.get(data.index)) {
        if (!self.feed.bitfield.get(data.index)) self.unhave({ start: data.index });
        self._clear(data.index, !data.value);
        return;
      }
      this.feed._putBuffer(data.index, data.value, data, this, function(err) {
        if (err) return self.destroy(err);
        if (data.value) self.remoteBitfield.set(data.index, false);
        if (self.remoteAck) {
          self.stream.have({ start: data.index, length: 1, ack: true });
        }
        if (self.stats && data.value) {
          self.stats.downloadedBlocks += 1;
          self.stats.downloadedBytes += data.value.length;
        }
        self._clear(data.index, !data.value);
      });
    };
    Peer.prototype._clear = function(index, hash) {
      for (var i = 0; i < this.inflightRequests.length; i++) {
        if (this.inflightRequests[i].index === index) {
          if (this._requestTimeout !== null) this._requestTimeout.refresh();
          this.inflightRequests.splice(i, 1);
          i--;
        }
      }
      this.feed._reserved.set(index, false);
      this.feed._updatePeers();
      if (this.inflightRequests.length === 0 && this._requestTimeout !== null) {
        this._requestTimeout.destroy();
        this._requestTimeout = null;
      }
    };
    Peer.prototype.onrequest = function(request) {
      if (!this.uploading) return;
      if (request.bytes) return this._onbytes(request);
      if (!this.remoteTree) this.remoteTree = treeIndex();
      var self = this;
      var opts = { digest: request.nodes, hash: request.hash, tree: this.remoteTree };
      this.feed.proof(request.index, opts, onproof);
      function onproof(err, proof) {
        if (err) return self.destroy(err);
        if (request.hash) onvalue(null, null);
        else if (self.feed.bitfield.get(request.index)) self.feed._getBuffer(request.index, onvalue);
        function onvalue(err2, value) {
          if (!self.uploading) return;
          if (err2) return self.destroy(err2);
          if (value) {
            if (self.stats) {
              self.stats.uploadedBlocks += 1;
              self.stats.uploadedBytes += value.length;
              self.feed._stats.uploadedBlocks += 1;
              self.feed._stats.uploadedBytes += value.length;
            }
            self.feed.emit("upload", request.index, value, self);
          }
          if (request.index + 1 > self.remoteLength) {
            self.remoteLength = request.index + 1;
            self._updateEnd();
          }
          self.stream.data({
            index: request.index,
            value,
            nodes: proof.nodes,
            signature: proof.signature
          });
        }
      }
    };
    Peer.prototype._updateOptions = function() {
      if (this.ack || this.feed.extensions.length) {
        this.stream.options({
          ack: this.ack,
          extensions: this.feed.extensions.names()
        });
      }
    };
    Peer.prototype.setDownloading = function(downloading) {
      if (downloading === this.downloading) return;
      this.downloading = downloading;
      this.stream.status({
        downloading,
        uploading: this.uploading
      });
      this.update();
    };
    Peer.prototype.setUploading = function(uploading) {
      if (uploading === this.uploading) return;
      this.uploading = uploading;
      this.stream.status({
        downloading: this.downloading,
        uploading
      });
      this.update();
    };
    Peer.prototype._onbytes = function(request) {
      var self = this;
      this.feed.seek(request.bytes, { wait: false }, function(err, index) {
        if (err) {
          request.bytes = 0;
          self.onrequest(request);
          return;
        }
        if (self._lastBytes === request.bytes) return;
        self._lastBytes = request.bytes;
        request.bytes = 0;
        request.index = index;
        request.nodes = 0;
        self.onrequest(request);
      });
    };
    Peer.prototype._onrequesttimeout = function() {
      this._requestTimeout = null;
      if (!this.inflightRequests.length) return;
      var first = this.inflightRequests[0];
      if (first.hash ? this.feed.tree.get(2 * first.index) : this.feed.bitfield.get(first.index)) {
        this.inflightRequests.shift();
        this.feed._reserved.set(first.index, false);
        if (this.stream.stream.timeout) {
          this._requestTimeout = timeout(this.stream.stream.timeout.ms, this._onrequesttimeout, this);
        }
        return;
      }
      this.destroy(new Error("Request timeout"));
    };
    Peer.prototype.onhave = function(have) {
      this.feed.emit("peer-ack", this, have);
      if (this.ack && have.ack && !have.bitfield && this.feed.bitfield.get(have.start)) {
        this.stream.stream.emit("ack", have);
        return;
      }
      var updated = this._first;
      if (this._first) this._first = false;
      if (have.length === 1024 * 1024 && this.inflightWants > 0) {
        this.feed.ifAvailable.continue();
        this.inflightWants--;
      }
      if (have.bitfield) {
        if (have.length === 0 || have.length === 1) {
          this.wants = null;
        }
        var buf = rle.decode(have.bitfield);
        var bits = buf.length * 8;
        remoteAndNotLocal(this.feed.bitfield, buf, this.remoteBitfield.littleEndian, have.start);
        this.remoteBitfield.fill(buf, have.start);
        if (bits > this.remoteLength) {
          this.remoteLength = this.remoteBitfield.last() + 1;
          updated = true;
        }
      } else {
        var start = have.start;
        var len = have.length || 1;
        while (len--) this.remoteBitfield.set(start, !this.feed.bitfield.get(start++));
        if (start > this.remoteLength) {
          this.remoteLength = start;
          updated = true;
        }
      }
      if (updated) {
        this.updated = true;
        this.feed.emit("remote-update", this);
      }
      this._updateEnd();
      this.update();
    };
    Peer.prototype._updateEnd = function() {
      if (this.live || this.feed.sparse || !this.feed._selections.length) return;
      var sel = this.feed._selections[0];
      var remoteLength = this.feed.length || -1;
      for (var i = 0; i < this.feed.peers.length; i++) {
        if (this.feed.peers[i].remoteLength > remoteLength) {
          remoteLength = this.feed.peers[i].remoteLength;
        }
      }
      sel.end = remoteLength;
    };
    Peer.prototype.onextension = function(id, message) {
      this.remoteExtensions.onmessage(id, message, this);
    };
    Peer.prototype.onstatus = function(info) {
      this.remoteUploading = info.uploading;
      this.remoteDownloading = info.downloading;
      if (!info.uploading) {
        while (this.inflightRequests.length) {
          const data = this.inflightRequests[0];
          this._clear(data.index, !data.value);
        }
        for (var i = 0; i < this.inflightWants; i++) {
          this.feed.ifAvailable.continue();
        }
        this.inflightWants = 0;
        this.wants = bitfield();
      }
      this.update();
      if (info.downloading || this.live) return;
      if (this.feed._selections.length && this.downloading) return;
      this._autoEnd();
    };
    Peer.prototype._autoEnd = function() {
      if (this.uploading && this.remoteDownloading) return;
      if ((this.sparse || this.live) && (this.remoteUploading || this.downloading)) return;
      this.end();
    };
    Peer.prototype.onunhave = function(unhave) {
      var start = unhave.start;
      var len = unhave.length || 1;
      if (start === 0 && len >= this.remoteLength) {
        this.remoteLength = 0;
        this.remoteBitfield = bitfield();
        return;
      }
      while (len--) this.remoteBitfield.set(start++, false);
    };
    Peer.prototype.onunwant = Peer.prototype.oncancel = function() {
    };
    Peer.prototype.onclose = function() {
      this._close();
    };
    Peer.prototype.have = function(have) {
      if (this.stream && this.remoteWant) this.stream.have(have);
      var start = have.start;
      var len = have.length;
      while (len--) this.remoteBitfield.set(start++, false);
    };
    Peer.prototype.unhave = function(unhave) {
      if (this.stream && this.remoteWant) this.stream.unhave(unhave);
    };
    Peer.prototype.haveBytes = function(bytes) {
      for (var i = 0; i < this.inflightRequests.length; i++) {
        if (this.inflightRequests[i].bytes === bytes) {
          this.feed._reserved.set(this.inflightRequests[i].index, false);
          this.inflightRequests.splice(i, 1);
          i--;
        }
      }
      this.update();
      if (this.inflightRequests.length === 0 && this._requestTimeout !== null) {
        this._requestTimeout.destroy();
        this._requestTimeout = null;
      }
    };
    Peer.prototype.update = function() {
      while (this._update()) {
      }
      this._sendWantsMaybe();
    };
    Peer.prototype._update = function() {
      if (!this.downloading || !this.remoteUploading) return false;
      var selections = this.feed._selections;
      var waiting = this.feed._waiting;
      var wlen = waiting.length;
      var slen = selections.length;
      var inflight = this.inflightRequests.length;
      var offset = 0;
      var i = 0;
      while (inflight < this.urgentRequests) {
        offset = Math.floor(Math.random() * waiting.length);
        for (i = 0; i < waiting.length; i++) {
          var w = waiting[offset++];
          if (offset === waiting.length) offset = 0;
          this._downloadWaiting(w);
          if (waiting.length !== wlen) return true;
          if (this.inflightRequests.length >= this.urgentRequests) return false;
        }
        if (inflight === this.inflightRequests.length) break;
        inflight = this.inflightRequests.length;
      }
      while (inflight < this.maxRequests) {
        offset = Math.floor(Math.random() * selections.length);
        for (i = 0; i < selections.length; i++) {
          var s = selections[offset++];
          if (offset === selections.length) offset = 0;
          if (!s.iterator) s.iterator = this.feed.bitfield.iterator(s.start, s.end);
          if (s.blocks) this._downloadBlocks(s);
          else this._downloadRange(s);
          if (selections.length !== slen) return true;
          if (this.inflightRequests.length >= this.maxRequests) return false;
        }
        if (inflight === this.inflightRequests.length) return false;
        inflight = this.inflightRequests.length;
      }
      return false;
    };
    Peer.prototype.onopen = function() {
      this.feed.ifAvailable.continue();
      this.remoteOpened = true;
      this._updateOptions();
      if (!this.uploading || !this.downloading) {
        this.stream.status({
          uploading: this.uploading,
          downloading: this.downloading
        });
      }
      this._sendWants();
      this.feed.emit("peer-open", this);
    };
    Peer.prototype.onoptions = function(options) {
      this.remoteAck = options.ack;
      this.remoteExtensions.update(options.extensions);
    };
    Peer.prototype.ready = function() {
      this.feed.ifAvailable.wait();
      set.add(this.feed.peers, this);
      this.feed.emit("peer-add", this);
      if (this.stream.remoteOpened) this.onopen();
    };
    Peer.prototype.end = function() {
      if (!this.downloading && !this.remoteDownloading && !this.live) {
        if (!this._defaultDownloading) {
          this.stream.status({ downloading: false, uploading: false });
        }
        this._close();
        return;
      }
      if (!this._closed) {
        this._closed = true;
        this.downloading = false;
        this.stream.status({ downloading: false, uploading: true });
      } else {
        if (!this.live) this._close();
      }
    };
    Peer.prototype._close = function() {
      if (!this._destroyed) {
        this._destroyed = true;
        this.stream.close();
      }
      if (this._index === -1) return;
      set.remove(this.feed.peers, this);
      this._index = -1;
      for (var i = 0; i < this.inflightRequests.length; i++) {
        this.feed._reserved.set(this.inflightRequests[i].index, false);
      }
      if (this._requestTimeout !== null) {
        this._requestTimeout.destroy();
        this._requestTimeout = null;
      }
      this._updateEnd();
      this.remoteWant = false;
      this.feed._updatePeers();
      this.feed.emit("peer-remove", this);
      for (i = 0; i < this.inflightWants; i++) {
        this.feed.ifAvailable.continue();
      }
      if (!this.remoteOpened) {
        this.feed.ifAvailable.continue();
      }
    };
    Peer.prototype.destroy = function(err) {
      if (this._index === -1 || this._destroyed) return;
      this.stream.destroy(err);
      this._destroyed = true;
      this._close();
    };
    Peer.prototype._sendWantsMaybe = function() {
      if (this.inflightRequests.length < this.urgentRequests) this._sendWants();
    };
    Peer.prototype._sendWants = function() {
      if (!this.wants || !this.downloading || !this.remoteOpened || !this.remoteUploading) return;
      if (this.inflightWants >= 16) return;
      var i;
      for (i = 0; i < this.feed._waiting.length; i++) {
        var w = this.feed._waiting[i];
        if (w.index === -1) this._sendWantRange(w);
        else this._sendWant(w.index);
        if (this.inflightWants >= 16) return;
      }
      for (i = 0; i < this.feed._selections.length; i++) {
        var s = this.feed._selections[i];
        this._sendWantRange(s);
        if (this.inflightWants >= 16) return;
      }
      this._sendWant(0);
    };
    Peer.prototype._sendWantRange = function(s) {
      if (s.blocks) {
        if (!s.selected) s.selected = /* @__PURE__ */ new WeakSet();
        if (s.selected.has(this)) return;
        s.selected.add(this);
        for (const block of s.blocks) {
          this._sendWant(block);
        }
        return;
      }
      var want = s.start ? 1024 * 1024 * Math.floor(s.start / 1024 / 1024) : 0;
      while (true) {
        if (want >= this.remoteLength) return;
        if (s.end !== -1 && want >= s.end) return;
        if (this._sendWant(want)) return;
        if (!this.wants.get(Math.floor(want / 1024 / 1024))) return;
        want += 1024 * 1024;
      }
    };
    Peer.prototype._sendWant = function(index) {
      var len = 1024 * 1024;
      var j = Math.floor(index / len);
      if (this.wants.get(j)) return false;
      this.wants.set(j, true);
      this.inflightWants++;
      this.feed.ifAvailable.wait();
      this.stream.want({ start: j * len, length: len });
      return true;
    };
    Peer.prototype._downloadWaiting = function(wait) {
      if (!wait.bytes) {
        if (!this.remoteBitfield.get(wait.index) || !this.feed._reserved.set(wait.index, true)) {
          if (!wait.update || this.feed._reserved.get(wait.index)) return;
          const i = this._iterator.seek(wait.index).next(true);
          if (i === -1 || !this.feed._reserved.set(i, true)) return;
          wait.index = i;
        }
        this._request(wait.index, 0, wait.hash === true);
        return;
      }
      this._downloadRange(wait);
    };
    Peer.prototype._downloadBlocks = function(range) {
      while (range.blocksDownloaded < range.blocks.length) {
        const blk = range.blocks[range.blocksDownloaded];
        if (!this.feed.bitfield.get(blk)) break;
        range.blocksDownloaded++;
      }
      if (range.blocksDownloaded >= range.blocks.length) {
        set.remove(this.feed._selections, range);
        range.callback(null);
        return;
      }
      for (var i = range.blocksDownloaded; i < range.blocks.length; i++) {
        const blk = range.blocks[i];
        if (this.remoteBitfield.get(blk) && this.feed._reserved.set(blk, true)) {
          range.requested++;
          this._request(blk, 0, false);
          return;
        }
      }
    };
    Peer.prototype._downloadRange = function(range) {
      if (!range.iterator) range.iterator = this.feed.bitfield.iterator(range.start, range.end);
      var reserved = this.feed._reserved;
      var ite = this._iterator;
      var wantedEnd = Math.min(range.end === -1 ? this.remoteLength : range.end, this.remoteLength);
      var i = range.linear ? ite.seek(range.start).next(true) : nextRandom(ite, range.start, wantedEnd);
      var start = i;
      if (i === -1 || i >= wantedEnd) {
        if (!range.bytes && range.end > -1 && this.feed.length >= range.end && range.iterator.seek(0).next() === -1) {
          set.remove(this.feed._selections, range);
          range.callback(null);
          if (!this.live && !this.sparse && !this.feed._selections.length) this.end();
        }
        return;
      }
      while (range.hash && this.feed.tree.get(2 * i) || !reserved.set(i, true)) {
        i = ite.next(true);
        if (i > -1 && i < wantedEnd) {
          continue;
        }
        if (!range.linear && start !== 0) {
          i = ite.seek(range.start).next(true);
          start = 0;
          if (i > -1 && i < wantedEnd) continue;
        }
        if (range.hash) {
          for (var j = range.start; j < wantedEnd; j++) {
            if (!this.feed.tree.get(2 * j)) return;
          }
          if (!range.bytes) {
            set.remove(this.feed._selections, range);
            range.callback(null);
          }
        }
        return;
      }
      range.requested++;
      this._request(i, range.bytes || 0, range.hash);
    };
    Peer.prototype._request = function(index, bytes, hash) {
      var request = {
        bytes,
        index,
        hash,
        nodes: this.feed.digest(index)
      };
      if (this._requestTimeout === null && this.stream.stream.timeout) {
        this._requestTimeout = timeout(this.stream.stream.timeout.ms, this._onrequesttimeout, this);
      }
      this.inflightRequests.push(request);
      this.stream.request(request);
    };
    Peer.prototype.extension = function(id, message) {
      this.stream.extension(id, message);
    };
    function createView(page) {
      var buf = page ? page.buffer : EMPTY;
      return new DataView(buf.buffer, buf.byteOffset, 1024);
    }
    function remoteAndNotLocal(local, buf, le, start) {
      var remote = new DataView(buf.buffer, buf.byteOffset);
      var len = Math.floor(buf.length / 4);
      var arr = new Uint32Array(buf.buffer, buf.byteOffset, len);
      var p = start / 8192;
      var l = 0;
      var page = createView(local.pages.get(p++, true));
      for (var i = 0; i < len; i++) {
        arr[i] = remote.getUint32(4 * i, !le) & ~page.getUint32(4 * l++, !le);
        if (l === 256) {
          page = createView(local.pages.get(p++, true));
          l = 0;
        }
      }
    }
    function nextRandom(ite, start, end) {
      var len = end - start;
      var i = ite.seek(Math.floor(Math.random() * len) + start).next(true);
      return i === -1 || i >= end ? ite.seek(start).next(true) : i;
    }
  }
});

// node_modules/.pnpm/nanoresource@1.3.0/node_modules/nanoresource/emitter.js
var require_emitter = __commonJS({
  "node_modules/.pnpm/nanoresource@1.3.0/node_modules/nanoresource/emitter.js"(exports, module) {
    var events = import$_dxos_node_std_events;
    var inherits = require_inherits_browser();
    var opening = Symbol("opening queue");
    var preclosing = Symbol("closing when inactive");
    var closing = Symbol("closing queue");
    var sync = Symbol("sync");
    var fastClose = Symbol("fast close");
    module.exports = Nanoresource;
    function Nanoresource(opts) {
      if (!(this instanceof Nanoresource)) return new Nanoresource(opts);
      events.EventEmitter.call(this);
      if (!opts) opts = {};
      if (opts.open) this._open = opts.open;
      if (opts.close) this._close = opts.close;
      this.opening = false;
      this.opened = false;
      this.closing = false;
      this.closed = false;
      this.actives = 0;
      this[opening] = null;
      this[preclosing] = null;
      this[closing] = null;
      this[sync] = false;
      this[fastClose] = true;
    }
    inherits(Nanoresource, events.EventEmitter);
    Nanoresource.prototype._open = function(cb) {
      cb(null);
    };
    Nanoresource.prototype._close = function(cb) {
      cb(null);
    };
    Nanoresource.prototype.open = function(cb) {
      if (!cb) cb = noop;
      if (this[closing] || this.closed) return process.nextTick(cb, new Error("Resource is closed"));
      if (this.opened) return process.nextTick(cb);
      if (this[opening]) {
        this[opening].push(cb);
        return;
      }
      this.opening = true;
      this[opening] = [cb];
      this[sync] = true;
      this._open(onopen.bind(this));
      this[sync] = false;
    };
    Nanoresource.prototype.active = function(cb) {
      if (this[fastClose] && this[preclosing] || this[closing] || this.closed) {
        if (cb) process.nextTick(cb, new Error("Resource is closed"));
        return false;
      }
      this.actives++;
      return true;
    };
    Nanoresource.prototype.inactive = function(cb, err, val2) {
      if (!--this.actives) {
        const queue = this[preclosing];
        if (queue) {
          this[preclosing] = null;
          while (queue.length) this.close(queue.shift());
        }
      }
      if (cb) cb(err, val2);
    };
    Nanoresource.prototype.close = function(allowActive, cb) {
      if (typeof allowActive === "function") return this.close(false, allowActive);
      if (!cb) cb = noop;
      if (allowActive) this[fastClose] = false;
      if (this.closed) return process.nextTick(cb);
      if (this.actives || this[opening]) {
        if (!this[preclosing]) this[preclosing] = [];
        this[preclosing].push(cb);
        return;
      }
      if (!this.opened) {
        this.closed = true;
        process.nextTick(cb);
        return;
      }
      if (this[closing]) {
        this[closing].push(cb);
        return;
      }
      this.closing = true;
      this[closing] = [cb];
      this[sync] = true;
      this._close(onclose.bind(this));
      this[sync] = false;
    };
    function onopen(err) {
      if (this[sync]) return process.nextTick(onopen.bind(this), err);
      const oqueue = this[opening];
      this[opening] = null;
      this.opening = false;
      this.opened = !err;
      while (oqueue.length) oqueue.shift()(err);
      const cqueue = this[preclosing];
      if (cqueue && !this.actives) {
        this[preclosing] = null;
        while (cqueue.length) this.close(cqueue.shift());
      }
    }
    function onclose(err) {
      if (this[sync]) return process.nextTick(onclose.bind(this), err);
      const queue = this[closing];
      this.closing = false;
      this[closing] = null;
      this.closed = !err;
      while (queue.length) queue.shift()(err);
    }
    function noop() {
    }
  }
});

// packages/common/hypercore/src/empty.ts
var require_empty = __commonJS({
  "packages/common/hypercore/src/empty.ts"(exports, module) {
    module.exports = new Proxy({}, {
      get: (target, prop) => {
        throw new Error("Package has been stripped");
      }
    });
  }
});

// node_modules/.pnpm/hypercore-streams@1.0.1/node_modules/hypercore-streams/index.js
var require_hypercore_streams = __commonJS({
  "node_modules/.pnpm/hypercore-streams@1.0.1/node_modules/hypercore-streams/index.js"(exports, module) {
    var { Writable, Readable: Readable2 } = import$streamx;
    var WriteStream = class extends Writable {
      constructor(feed, opts) {
        super();
        this.feed = feed;
        this.maxBlockSize = opts && opts.maxBlockSize || 0;
      }
      _writev(batch, cb) {
        this.feed.append(this.maxBlockSize ? this._ensureMaxSize(batch) : batch, cb);
      }
      _ensureMaxSize(batch) {
        for (let i = 0; i < batch.length; i++) {
          let blk = batch[i];
          if (blk.length > this.maxBlockSize) {
            const chunked = [];
            while (blk.length > this.maxBlockSize) {
              chunked.push(blk.slice(0, this.maxBlockSize));
              blk = blk.slice(this.maxBlockSize);
            }
            if (blk.length) chunked.push(blk);
            batch.splice(i, 1, ...chunked);
            i += chunked.length - 1;
          }
        }
        return batch;
      }
    };
    var ReadStream = class extends Readable2 {
      constructor(feed, opts = {}) {
        super();
        this.feed = feed;
        this.start = opts.start || 0;
        this.end = typeof opts.end === "number" ? opts.end : -1;
        this.live = !!opts.live;
        this.snapshot = opts.snapshot !== false;
        this.tail = !!opts.tail;
        this.index = this.start;
        this.options = { wait: opts.wait !== false, ifAvailable: !!opts.ifAvailable, valueEncoding: opts.valueEncoding };
      }
      _open(cb) {
        this.feed.ready((err) => {
          if (err) return cb(err);
          if (this.end === -1) {
            if (this.live) this.end = Infinity;
            else if (this.snapshot) this.end = this.feed.length;
            if (this.start > this.end) this.push(null);
          }
          if (this.tail) this.start = this.feed.length;
          this.index = this.start;
          cb(null);
        });
      }
      _read(cb) {
        if (this.index === this.end || this.end === -1 && this.index >= this.feed.length) {
          this.push(null);
          return cb(null);
        }
        this.feed.get(this.index++, this.options, (err, block) => {
          if (err) return cb(err);
          this.push(block);
          cb(null);
        });
      }
    };
    module.exports = { WriteStream, ReadStream };
  }
});

// node_modules/.pnpm/hypercore@9.12.0/node_modules/hypercore/index.js
var require_hypercore = __commonJS({
  "node_modules/.pnpm/hypercore@9.12.0/node_modules/hypercore/index.js"(exports, module) {
    var low = require_last_one_wins();
    var remove = require_unordered_array_remove();
    var set = require_unordered_set();
    var MerkleGenerator = require_generator();
    var flat = require_flat_tree();
    var codecs = require_codecs();
    var batcher = require_atomic_batcher();
    var inherits = require_inherits_browser();
    var bitfield = require_bitfield();
    var sparseBitfield = require_sparse_bitfield();
    var treeIndex = require_tree_index();
    var storage = require_storage();
    var crypto = require_hypercore_crypto();
    var inspect = require_browser();
    var pretty = require_pretty_hash();
    var Nanoguard = require_nanoguard();
    var safeBufferEquals = require_safe_buffer_equals();
    var replicate = require_replicate();
    var Protocol = require_hypercore_protocol();
    var Message = require_abstract_extension();
    var Nanoresource = require_emitter();
    var defaultStorage = require_empty();
    var { WriteStream, ReadStream } = require_hypercore_streams();
    var Extension = class extends Message {
      broadcast(message) {
        const feed = this.local.handlers;
        const buf = this.encoding.encode(message);
        let broadcasted = false;
        for (const peer of feed.peers) {
          broadcasted = true;
          peer.extension(this.id, buf);
        }
        return broadcasted;
      }
      send(message, peer) {
        peer.extension(this.id, this.encode(message));
      }
    };
    var defaultCrypto = {
      sign(data, sk, cb) {
        return cb(null, crypto.sign(data, sk));
      },
      verify(sig, data, pk, cb) {
        return cb(null, crypto.verify(sig, data, pk));
      }
    };
    module.exports = Feed;
    function Feed(createStorage2, key, opts) {
      if (!(this instanceof Feed)) return new Feed(createStorage2, key, opts);
      Nanoresource.call(this);
      if (typeof createStorage2 === "string") createStorage2 = defaultStorageDir(createStorage2);
      if (typeof createStorage2 !== "function") throw new Error("Storage should be a function or string");
      if (typeof key === "string") key = Buffer.from(key, "hex");
      if (!Buffer.isBuffer(key) && !opts) {
        opts = key;
        key = null;
      }
      if (!opts) opts = {};
      var self = this;
      var secretKey = opts.secretKey || null;
      if (typeof secretKey === "string") secretKey = Buffer.from(secretKey, "hex");
      this.noiseKeyPair = opts.noiseKeyPair || Protocol.keyPair();
      this.live = opts.live !== false;
      this.sparse = !!opts.sparse;
      this.length = 0;
      this.byteLength = 0;
      this.maxRequests = opts.maxRequests || 16;
      this.key = key || opts.key || null;
      this.discoveryKey = this.key && crypto.discoveryKey(this.key);
      this.secretKey = secretKey;
      this.bitfield = null;
      this.tree = null;
      this.writable = !!opts.writable;
      this.readable = true;
      this.downloading = opts.downloading !== false;
      this.uploading = opts.uploading !== false;
      this.allowPush = !!opts.allowPush;
      this.peers = [];
      this.ifAvailable = new Nanoguard();
      this.extensions = Extension.createLocal(this);
      this.crypto = opts.crypto || defaultCrypto;
      this._onwrite = opts.onwrite || null;
      this._force = !!opts.force;
      this._expectedLength = -1;
      this._indexing = !!opts.indexing;
      this._createIfMissing = opts.createIfMissing !== false;
      this._overwrite = !!opts.overwrite;
      this._storeSecretKey = opts.storeSecretKey !== false;
      this._alwaysIfAvailable = !!opts.ifAvailable;
      this._merkle = null;
      this._storage = storage(createStorage2, opts);
      this._batch = batcher(this._onwrite ? workHook : work);
      this.timeouts = opts.timeouts || {
        get(cb) {
          cb(null);
        },
        update(cb) {
          cb(null);
        }
      };
      this._seq = 0;
      this._waiting = [];
      this._selections = [];
      this._reserved = sparseBitfield();
      this._synced = null;
      this._downloadingSet = typeof opts.downloading === "boolean";
      this._stats = typeof opts.stats !== "undefined" && !opts.stats ? null : {
        downloadedBlocks: 0,
        downloadedBytes: 0,
        uploadedBlocks: 0,
        uploadedBytes: 0
      };
      this._codec = toCodec(opts.valueEncoding);
      this._sync = low(sync);
      if (!this.sparse) this.download({ start: 0, end: -1 });
      if (this.sparse && opts.eagerUpdate) {
        this.update(function loop(err) {
          if (err) self.emit("update-error", err);
          self.update(loop);
        });
      }
      this.open(onerror);
      function onerror(err) {
        if (err) self.emit("error", err);
      }
      function workHook(values, cb) {
        if (!self._merkle) return self._reloadMerkleStateBeforeAppend(workHook, values, cb);
        self._appendHook(values, cb);
      }
      function work(values, cb) {
        if (!self._merkle) return self._reloadMerkleStateBeforeAppend(work, values, cb);
        self._append(values, cb);
      }
      function sync(_, cb) {
        self._syncBitfield(cb);
      }
    }
    inherits(Feed, Nanoresource);
    Feed.discoveryKey = crypto.discoveryKey;
    Feed.prototype[inspect] = function(depth, opts) {
      var indent = "";
      if (typeof opts.indentationLvl === "number") {
        while (indent.length < opts.indentationLvl) indent += " ";
      }
      return "Hypercore(\n" + indent + "  key: " + opts.stylize(this.key && pretty(this.key), "string") + "\n" + indent + "  discoveryKey: " + opts.stylize(this.discoveryKey && pretty(this.discoveryKey), "string") + "\n" + indent + "  opened: " + opts.stylize(this.opened, "boolean") + "\n" + indent + "  sparse: " + opts.stylize(this.sparse, "boolean") + "\n" + indent + "  writable: " + opts.stylize(this.writable, "boolean") + "\n" + indent + "  length: " + opts.stylize(this.length, "number") + "\n" + indent + "  byteLength: " + opts.stylize(this.byteLength, "number") + "\n" + indent + "  peers: " + opts.stylize(this.peers.length, "number") + "\n" + indent + ")";
    };
    Object.defineProperty(Feed.prototype, "remoteLength", {
      enumerable: true,
      get: function() {
        var len = 0;
        for (var i = 0; i < this.peers.length; i++) {
          var remoteLength = this.peers[i].remoteLength;
          if (remoteLength > len) len = remoteLength;
        }
        return len;
      }
    });
    Object.defineProperty(Feed.prototype, "stats", {
      enumerable: true,
      get: function() {
        if (!this._stats) return null;
        var peerStats = [];
        for (var i = 0; i < this.peers.length; i++) {
          var peer = this.peers[i];
          peerStats[i] = peer.stats;
        }
        return {
          peers: peerStats,
          totals: this._stats
        };
      }
    });
    Feed.prototype.replicate = function(initiator, opts) {
      if ((!this._selections.length || this._selections[0].end !== -1) && !this.sparse && !(opts && opts.live)) {
        this.download({ start: 0, end: -1 });
      }
      if (isOptions(initiator) && !opts) {
        opts = initiator;
        initiator = opts.initiator;
      }
      opts = opts || {};
      opts.stats = !!this._stats;
      opts.noise = !(opts.noise === false && opts.encrypted === false);
      return replicate(this, initiator, opts);
    };
    Feed.prototype.registerExtension = function(name, handlers) {
      return this.extensions.add(name, handlers);
    };
    Feed.prototype.onextensionupdate = function() {
      for (const peer of this.peers) peer._updateOptions();
    };
    Feed.prototype.setDownloading = function(downloading) {
      if (this.downloading === downloading && this._downloadingSet) return;
      this.downloading = downloading;
      this._downloadingSet = true;
      this.ready((err) => {
        if (err) return;
        for (const peer of this.peers) peer.setDownloading(this.downloading);
      });
    };
    Feed.prototype.setUploading = function(uploading) {
      if (uploading === this.uploading) return;
      this.uploading = uploading;
      this.ready((err) => {
        if (err) return;
        for (const peer of this.peers) peer.setUploading(this.uploading);
      });
    };
    Feed.prototype.ready = Feed.prototype.open;
    Feed.prototype.update = function(opts, cb) {
      if (typeof opts === "function") return this.update(-1, opts);
      if (typeof opts === "number") opts = { minLength: opts };
      if (!opts) opts = {};
      if (!cb) cb = noop;
      var self = this;
      var len = typeof opts.minLength === "number" ? opts.minLength : -1;
      this.ready(function(err) {
        if (err) return cb(err);
        if (len === -1) len = self.length + 1;
        if (self.length >= len) return cb(null);
        const ifAvailable = typeof opts.ifAvailable === "boolean" ? opts.ifAvailable : self._alwaysIfAvailable;
        if (ifAvailable && self.writable && !opts.force) return cb(new Error("No update available from peers"));
        if (self.writable) cb = self._writeStateReloader(cb);
        var w = {
          hash: opts.hash !== false,
          bytes: 0,
          index: len - 1,
          options: opts,
          update: true,
          callback: cb
        };
        self._waiting.push(w);
        if (ifAvailable) self._ifAvailable(w, len);
        self._updatePeers();
      });
    };
    Feed.prototype.setExpectedLength = function(len) {
      this._expectedLength = len;
      this.ready((err) => {
        if (err) return;
        this.ifAvailable.ready(() => {
          this._expectedLength = -1;
        });
        if (this._expectedLength === -1 || this._expectedLength > this.length) return;
        for (const w of this._waiting) {
          if (w.update && w.ifAvailable) w.callback(new Error("Expected length is less than current length"));
        }
      });
    };
    Feed.prototype.truncate = function(newLength, cb) {
      if (!cb) cb = noop;
      const self = this;
      this.ready(function(err) {
        if (err) return cb(err);
        self._roots(newLength, function(err2, roots) {
          if (err2) return cb(err2);
          const oldLength = self.length;
          if (oldLength <= newLength) return cb(null);
          let byteLength = 0;
          for (const { size } of roots) byteLength += size;
          for (let i = oldLength; i < newLength; i++) self.data.set(i, false);
          self.byteLength = byteLength;
          self.length = newLength;
          self.tree.truncate(2 * newLength);
          self._merkle = new MerkleGenerator(crypto, roots);
          self._sync(null, function(err3) {
            if (err3) return cb(err3);
            self._storage.deleteSignatures(newLength, oldLength, cb);
          });
        });
      });
    };
    Feed.prototype._ifAvailable = function(w, minLength) {
      var cb = w.callback;
      var called = false;
      var self = this;
      w.callback = done;
      w.ifAvailable = true;
      if (this._expectedLength > -1 && this._expectedLength <= this.length) {
        return process.nextTick(w.callback, new Error("Expected length is less than current length"));
      }
      this.timeouts.update(function() {
        if (self.closed) return done(new Error("Closed"));
        process.nextTick(readyNT, self.ifAvailable, function() {
          if (self.closed) return done(new Error("Closed"));
          if (self.length >= minLength || self.remoteLength >= minLength) return;
          done(new Error("No update available from peers"));
        });
      });
      function done(err) {
        if (called) return;
        called = true;
        var i = self._waiting.indexOf(w);
        if (i > -1) remove(self._waiting, i);
        cb(err);
      }
    };
    Feed.prototype._ifAvailableGet = function(w) {
      var cb = w.callback;
      var called = false;
      var self = this;
      w.callback = done;
      self.timeouts.get(function() {
        if (self.closed) return done(new Error("Closed"));
        process.nextTick(readyNT, self.ifAvailable, function() {
          if (self.closed) return done(new Error("Closed"));
          for (var i = 0; i < self.peers.length; i++) {
            var peer = self.peers[i];
            if (peer.remoteBitfield.get(w.index)) return;
          }
          done(new Error("Block not available from peers"));
        });
      });
      function done(err, data) {
        if (called) return;
        called = true;
        var i = self._waiting.indexOf(w);
        if (i > -1) remove(self._waiting, i);
        cb(err, data);
      }
    };
    Feed.prototype._writeStateReloader = function(cb) {
      var self = this;
      return function(err) {
        if (err) return cb(err);
        self._reloadMerkleState(cb);
      };
    };
    Feed.prototype._reloadMerkleState = function(cb) {
      var self = this;
      this._roots(self.length, function(err, roots) {
        if (err) return cb(err);
        self._merkle = new MerkleGenerator(crypto, roots);
        cb(null);
      });
    };
    Feed.prototype._reloadMerkleStateBeforeAppend = function(work, values, cb) {
      this._reloadMerkleState(function(err) {
        if (err) return cb(err);
        work(values, cb);
      });
    };
    Feed.prototype._open = function(cb) {
      var self = this;
      var generatedKey = false;
      var retryOpen = true;
      this._storage.openKey(function(_, key) {
        if (key && !self._overwrite && !self.key) self.key = key;
        if (!self.key && self.live) {
          var keyPair = crypto.keyPair();
          self.secretKey = keyPair.secretKey;
          self.key = keyPair.publicKey;
          generatedKey = true;
        }
        self.discoveryKey = self.key && crypto.discoveryKey(self.key);
        self._storage.open({ key: self.key, discoveryKey: self.discoveryKey }, onopen);
      });
      function onopen(err, state) {
        if (err) return cb(err);
        if (!state.key && state.bitfield.length) {
          self._overwrite = true;
        }
        if (self._force && state.key && self.key && Buffer.compare(state.key, self.key) !== 0) {
          self._overwrite = true;
        }
        if (self._overwrite) {
          state.bitfield = [];
          state.key = state.secretKey = null;
        }
        self.bitfield = bitfield(state.bitfieldPageSize, state.bitfield);
        self.tree = treeIndex(self.bitfield.tree);
        self.length = self.tree.blocks();
        self._seq = self.length;
        if (state.key && self.key && Buffer.compare(state.key, self.key) !== 0) {
          return self._forceClose(cb, new Error("Another hypercore is stored here"));
        }
        if (state.key) self.key = state.key;
        if (state.secretKey) self.secretKey = state.secretKey;
        if (!self.length) return onsignature(null, null);
        self._storage.getSignature(self.length - 1, onsignature);
        function onsignature(_, sig) {
          if (self.length) self.live = !!sig;
          if ((generatedKey || !self.key) && !self._createIfMissing) {
            return self._forceClose(cb, new Error("No hypercore is stored here"));
          }
          if (!self.key && self.live) {
            var keyPair = crypto.keyPair();
            self.secretKey = keyPair.secretKey;
            self.key = keyPair.publicKey;
          }
          var writable = !!self.secretKey || self.key === null;
          if (!writable && self.writable) return self._forceClose(cb, new Error("Feed is not writable"));
          self.writable = writable;
          if (!self._downloadingSet) self.downloading = !writable;
          self.discoveryKey = self.key && crypto.discoveryKey(self.key);
          if (self._storeSecretKey && !self.secretKey) {
            self._storeSecretKey = false;
          }
          var shouldWriteKey = generatedKey || !safeBufferEquals(self.key, state.key);
          var shouldWriteSecretKey = self._storeSecretKey && (generatedKey || !safeBufferEquals(self.secretKey, state.secretKey));
          var missing = 1 + (shouldWriteKey ? 1 : 0) + (shouldWriteSecretKey ? 1 : 0) + (self._overwrite ? 1 : 0);
          var error = null;
          if (shouldWriteKey) self._storage.key.write(0, self.key, done);
          if (shouldWriteSecretKey) self._storage.secretKey.write(0, self.secretKey, done);
          if (self._overwrite) {
            self._storage.bitfield.del(32, Infinity, done);
          }
          done(null);
          function done(err2) {
            if (err2) error = err2;
            if (--missing) return;
            if (error) return self._forceClose(cb, error);
            self._roots(self.length, onroots);
          }
          function onroots(err2, roots) {
            if (err2 && retryOpen) {
              retryOpen = false;
              self.length--;
              self._storage.getSignature(self.length - 1, onsignature);
              return;
            }
            if (err2) return self._forceClose(cb, err2);
            self._merkle = new MerkleGenerator(crypto, roots);
            self.byteLength = roots.reduce(addSize, 0);
            self.emit("ready");
            cb(null);
          }
        }
      }
    };
    Feed.prototype.download = function(range, cb) {
      if (typeof range === "function") return this.download(null, range);
      if (typeof range === "number") range = { start: range, end: range + 1 };
      if (Array.isArray(range)) range = { blocks: range };
      if (!range) range = {};
      if (!cb) cb = noop;
      if (!this.readable) return cb(new Error("Feed is closed"));
      if (range.blocks && typeof range.start !== "number") {
        var min = -1;
        var max = 0;
        for (var i = 0; i < range.blocks.length; i++) {
          const blk = range.blocks[i];
          if (min === -1 || blk < min) min = blk;
          if (blk >= max) max = blk + 1;
        }
        range.start = min === -1 ? 0 : min;
        range.end = max;
      }
      var sel = {
        _index: this._selections.length,
        hash: !!range.hash,
        iterator: null,
        start: range.start || 0,
        end: range.end || -1,
        want: 0,
        linear: !!range.linear,
        blocks: range.blocks || null,
        blocksDownloaded: 0,
        requested: 0,
        callback: cb
      };
      sel.want = toWantRange(sel.start);
      this._selections.push(sel);
      this._updatePeers();
      return sel;
    };
    Feed.prototype.undownload = function(range) {
      if (typeof range === "number") range = { start: range, end: range + 1 };
      if (!range) range = {};
      if (range.callback && range._index > -1) {
        set.remove(this._selections, range);
        process.nextTick(range.callback, createError("ECANCELED", -11, "Download was cancelled"));
        return;
      }
      var start = range.start || 0;
      var end = range.end || -1;
      var hash = !!range.hash;
      var linear = !!range.linear;
      for (var i = 0; i < this._selections.length; i++) {
        var s = this._selections[i];
        if (s.start === start && s.end === end && s.hash === hash && s.linear === linear) {
          set.remove(this._selections, s);
          process.nextTick(range.callback, createError("ECANCELED", -11, "Download was cancelled"));
          return;
        }
      }
    };
    Feed.prototype.digest = function(index) {
      return this.tree.digest(2 * index);
    };
    Feed.prototype.proof = function(index, opts, cb) {
      if (typeof opts === "function") return this.proof(index, null, opts);
      if (!this.opened) return this._readyAndProof(index, opts, cb);
      if (!opts) opts = {};
      var proof = this.tree.proof(2 * index, opts);
      if (!proof) return cb(new Error("No proof available for this index"));
      var needsSig = this.live && !!proof.verifiedBy;
      var pending = proof.nodes.length + (needsSig ? 1 : 0);
      var error = null;
      var signature = null;
      var nodes = new Array(proof.nodes.length);
      if (!pending) return cb(null, { nodes, signature: null });
      for (var i = 0; i < proof.nodes.length; i++) {
        this._storage.getNode(proof.nodes[i], onnode);
      }
      if (needsSig) {
        this._storage.getSignature(proof.verifiedBy / 2 - 1, onsignature);
      }
      function onsignature(err, sig) {
        if (sig) signature = sig;
        onnode(err, null);
      }
      function onnode(err, node) {
        if (err) error = err;
        if (node) {
          nodes[proof.nodes.indexOf(node.index)] = node;
        }
        if (--pending) return;
        if (error) return cb(error);
        cb(null, { nodes, signature });
      }
    };
    Feed.prototype._readyAndProof = function(index, opts, cb) {
      var self = this;
      this.ready(function(err) {
        if (err) return cb(err);
        self.proof(index, opts, cb);
      });
    };
    Feed.prototype.put = function(index, data, proof, cb) {
      if (!this.opened) return this._readyAndPut(index, data, proof, cb);
      this._putBuffer(index, data === null ? null : this._codec.encode(data), proof, null, cb);
    };
    Feed.prototype.cancel = function(start, end) {
      if (typeof start !== "symbol") {
        if (!end) end = start + 1;
        for (var i = this._selections.length - 1; i >= 0; i--) {
          var sel = this._selections[i];
          if (start <= sel.start && sel.end <= end) {
            this.undownload(sel);
          }
        }
      }
      if (this.opened) this._cancel(start, end);
      else this._readyAndCancel(start, end);
    };
    Feed.prototype._cancel = function(start, end) {
      var i = 0;
      if (typeof start === "symbol") {
        for (i = this._waiting.length - 1; i >= 0; i--) {
          const w2 = this._waiting[i];
          if (w2.options.cancel === start) {
            remove(this._waiting, i);
            this._reserved.set(w2.index, false);
            if (w2.callback) process.nextTick(w2.callback, new Error("Request cancelled"));
            this._updatePeers();
            return;
          }
        }
        return;
      }
      for (i = start; i < end; i++) {
        this._reserved.set(i, false);
      }
      for (i = this._waiting.length - 1; i >= 0; i--) {
        var w = this._waiting[i];
        if (start <= w.start && w.end <= end || start <= w.index && w.index < end) {
          remove(this._waiting, i);
          if (w.callback) process.nextTick(w.callback, new Error("Request cancelled"));
        }
      }
    };
    Feed.prototype.clear = function(start, end, opts, cb) {
      if (typeof end === "function") return this.clear(start, start + 1, null, end);
      if (typeof opts === "function") return this.clear(start, end, null, opts);
      if (!opts) opts = {};
      if (!end) end = start + 1;
      if (!cb) cb = noop;
      var self = this;
      var byteOffset = start === 0 ? 0 : typeof opts.byteOffset === "number" ? opts.byteOffset : -1;
      var byteLength = typeof opts.byteLength === "number" ? opts.byteLength : -1;
      this.ready(function(err) {
        if (err) return cb(err);
        var modified = false;
        for (var i = start; i < end; i++) {
          if (self.bitfield.set(i, false)) modified = true;
        }
        if (!modified) return process.nextTick(cb);
        self._unannounce({ start, length: end - start });
        if (opts.delete === false || self._indexing) return sync();
        if (byteOffset > -1) return onstartbytes(null, byteOffset);
        self._storage.dataOffset(start, [], onstartbytes);
        function sync() {
          self.emit("clear", start, end);
          self._sync(null, cb);
        }
        function onstartbytes(err2, offset) {
          if (err2) return cb(err2);
          byteOffset = offset;
          if (byteLength > -1) return onendbytes(null, byteLength + byteOffset);
          if (end === self.length) return onendbytes(null, self.byteLength);
          self._storage.dataOffset(end, [], onendbytes);
        }
        function onendbytes(err2, end2) {
          if (err2) return cb(err2);
          if (!self._storage.data.del) return sync();
          self._storage.data.del(byteOffset, end2 - byteOffset, sync);
        }
      });
    };
    Feed.prototype.signature = function(index, cb) {
      if (typeof index === "function") return this.signature(this.length - 1, index);
      if (index < 0 || index >= this.length) return cb(new Error("No signature available for this index"));
      this._storage.nextSignature(index, cb);
    };
    Feed.prototype.verify = function(index, signature, cb) {
      var self = this;
      this.rootHashes(index, function(err, roots) {
        if (err) return cb(err);
        var checksum = crypto.signable(roots, index + 1);
        verifyCompat(self, checksum, signature, function(err2, valid) {
          if (err2) return cb(err2);
          if (!valid) return cb(new Error("Signature verification failed"));
          return cb(null, true);
        });
      });
    };
    Feed.prototype.rootHashes = function(index, cb) {
      this._getRootsToVerify(index * 2 + 2, {}, [], cb);
    };
    Feed.prototype.seek = function(bytes, opts, cb) {
      if (typeof opts === "function") return this.seek(bytes, null, opts);
      if (!opts) opts = {};
      if (!this.opened) return this._readyAndSeek(bytes, opts, cb);
      var self = this;
      if (bytes === this.byteLength) return process.nextTick(cb, null, this.length, 0);
      this._seek(bytes, function(err, index, offset) {
        if (!err && isBlock(index)) return done(index / 2, offset);
        if (opts.wait === false) return cb(err || new Error("Unable to seek to this offset"));
        var start = opts.start || 0;
        var end = opts.end || -1;
        if (!err) {
          var left = flat.leftSpan(index) / 2;
          var right = flat.rightSpan(index) / 2 + 1;
          if (left > start) start = left;
          if (right < end || end === -1) end = right;
        }
        if (end > -1 && end <= start) return cb(new Error("Unable to seek to this offset"));
        var w = {
          hash: opts.hash !== false,
          bytes,
          index: -1,
          ifAvailable: opts && typeof opts.ifAvailable === "boolean" ? opts.ifAvailable : self._alwaysIfAvailable,
          start,
          end,
          want: toWantRange(start),
          requested: 0,
          callback: cb || noop
        };
        self._waiting.push(w);
        self._updatePeers();
        if (w.ifAvailable) self._ifAvailableSeek(w);
      });
      function done(index, offset) {
        for (var i = 0; i < self.peers.length; i++) {
          self.peers[i].haveBytes(bytes);
        }
        cb(null, index, offset);
      }
    };
    Feed.prototype._ifAvailableSeek = function(w) {
      var self = this;
      var cb = w.callback;
      self.timeouts.get(function() {
        if (self.closed) return done(new Error("Closed"));
        process.nextTick(readyNT, self.ifAvailable, function() {
          if (self.closed) return done(new Error("Closed"));
          let available = false;
          for (const peer of self.peers) {
            const ite = peer._iterator;
            let i = ite.seek(w.start).next(true);
            while (self.tree.get(i * 2) && i > -1) i = ite.next(true);
            if (i > -1 && (w.end === -1 || i < w.end)) {
              available = true;
              break;
            }
          }
          if (!available) done(new Error("Seek not available from peers"));
        });
      });
      function done(err) {
        var i = self._waiting.indexOf(w);
        if (i > -1) {
          remove(self._waiting, i);
          w.callback = noop;
          cb(err);
        }
      }
    };
    Feed.prototype._seek = function(offset, cb) {
      if (offset === 0) return cb(null, 0, 0);
      var self = this;
      var roots = flat.fullRoots(this.length * 2);
      var nearestRoot = 0;
      loop(null, null);
      function onroot(top) {
        if (isBlock(top)) return cb(null, nearestRoot, offset);
        var left = flat.leftChild(top);
        while (!self.tree.get(left)) {
          if (isBlock(left)) return cb(null, nearestRoot, offset);
          left = flat.leftChild(left);
        }
        self._storage.getNode(left, onleftchild);
      }
      function onleftchild(err, node) {
        if (err) return cb(err);
        if (node.size > offset) {
          nearestRoot = node.index;
          onroot(node.index);
        } else {
          offset -= node.size;
          if (flat.parent(node.index) === nearestRoot) {
            nearestRoot = flat.sibling(node.index);
            onroot(nearestRoot);
          } else {
            onroot(flat.sibling(node.index));
          }
        }
      }
      function loop(err, node) {
        if (err) return cb(err);
        if (node) {
          if (node.size > offset) {
            nearestRoot = node.index;
            return onroot(node.index);
          }
          offset -= node.size;
        }
        if (!roots.length) return cb(new Error("Out of bounds"));
        self._storage.getNode(roots.shift(), loop);
      }
    };
    Feed.prototype._readyAndSeek = function(bytes, opts, cb) {
      var self = this;
      this.ready(function(err) {
        if (err) return cb(err);
        self.seek(bytes, opts, cb);
      });
    };
    Feed.prototype._getBuffer = function(index, cb) {
      this._storage.getData(index, cb);
    };
    Feed.prototype._putBuffer = function(index, data, proof, from, cb) {
      var self = this;
      var trusted = -1;
      var missing = [];
      var next = 2 * index;
      var i = data ? 0 : 1;
      while (true) {
        if (this.tree.get(next)) {
          trusted = next;
          break;
        }
        var sib = flat.sibling(next);
        next = flat.parent(next);
        if (i < proof.nodes.length && proof.nodes[i].index === sib) {
          i++;
          continue;
        }
        if (!this.tree.get(sib)) break;
        missing.push(sib);
      }
      if (trusted === -1 && this.tree.get(next)) trusted = next;
      var error = null;
      var trustedNode = null;
      var missingNodes = new Array(missing.length);
      var pending = missing.length + (trusted > -1 ? 1 : 0);
      for (i = 0; i < missing.length; i++) this._storage.getNode(missing[i], onmissing);
      if (trusted > -1) this._storage.getNode(trusted, ontrusted);
      if (!missing.length && trusted === -1) onmissingloaded(null);
      function ontrusted(err, node) {
        if (err) error = err;
        if (node) trustedNode = node;
        if (!--pending) onmissingloaded(error);
      }
      function onmissing(err, node) {
        if (err) error = err;
        if (node) missingNodes[missing.indexOf(node.index)] = node;
        if (!--pending) onmissingloaded(error);
      }
      function onmissingloaded(err) {
        if (err) return cb(err);
        self._verifyAndWrite(index, data, proof, missingNodes, trustedNode, from, cb);
      }
    };
    Feed.prototype._readyAndPut = function(index, data, proof, cb) {
      var self = this;
      this.ready(function(err) {
        if (err) return cb(err);
        self.put(index, data, proof, cb);
      });
    };
    Feed.prototype._write = function(index, data, nodes, sig, from, cb) {
      if (!this._onwrite) return this._writeAfterHook(index, data, nodes, sig, from, cb);
      this._onwrite(index, data, from, writeHookDone(this, index, data, nodes, sig, from, cb));
    };
    function writeHookDone(self, index, data, nodes, sig, from, cb) {
      return function(err) {
        if (err) return cb(err);
        self._writeAfterHook(index, data, nodes, sig, from, cb);
      };
    }
    Feed.prototype._writeAfterHook = function(index, data, nodes, sig, from, cb) {
      var self = this;
      var pending = nodes.length + 1 + (sig ? 1 : 0);
      var error = null;
      for (var i = 0; i < nodes.length; i++) this._storage.putNode(nodes[i].index, nodes[i], ondone);
      if (data) this._storage.putData(index, data, nodes, ondone);
      else ondone();
      if (sig) this._storage.putSignature(sig.index, sig.signature, ondone);
      function ondone(err) {
        if (err) error = err;
        if (--pending) return;
        if (error) return cb(error);
        self._writeDone(index, data, nodes, from, cb);
      }
    };
    Feed.prototype._writeDone = function(index, data, nodes, from, cb) {
      for (var i = 0; i < nodes.length; i++) this.tree.set(nodes[i].index);
      this.tree.set(2 * index);
      if (data) {
        if (this.bitfield.set(index, true)) {
          if (this._stats) {
            this._stats.downloadedBlocks += 1;
            this._stats.downloadedBytes += data.length;
          }
          this.emit("download", index, data, from);
        }
        if (this.peers.length) this._announce({ start: index }, from);
        if (!this.writable) {
          if (!this._synced) this._synced = this.bitfield.iterator(0, this.length);
          if (this._synced.next() === -1) {
            this._synced.range(0, this.length);
            this._synced.seek(0);
            if (this._synced.next() === -1) {
              this.emit("sync");
            }
          }
        }
      }
      this._sync(null, cb);
    };
    Feed.prototype._verifyAndWrite = function(index, data, proof, localNodes, trustedNode, from, cb) {
      var visited = [];
      var remoteNodes = proof.nodes;
      var top = data ? new storage.Node(2 * index, crypto.data(data), data.length) : remoteNodes.shift();
      if (verifyNode(trustedNode, top)) {
        this._write(index, data, visited, null, from, cb);
        return;
      }
      while (true) {
        var node = null;
        var next = flat.sibling(top.index);
        if (remoteNodes.length && remoteNodes[0].index === next) {
          node = remoteNodes.shift();
          visited.push(node);
        } else if (localNodes.length && localNodes[0].index === next) {
          node = localNodes.shift();
        } else {
          this._verifyRootsAndWrite(index, data, top, proof, visited, from, cb);
          return;
        }
        visited.push(top);
        top = new storage.Node(flat.parent(top.index), crypto.parent(top, node), top.size + node.size);
        if (verifyNode(trustedNode, top)) {
          this._write(index, data, visited, null, from, cb);
          return;
        }
      }
    };
    Feed.prototype._verifyRootsAndWrite = function(index, data, top, proof, nodes, from, cb) {
      var remoteNodes = proof.nodes;
      var lastNode = remoteNodes.length ? remoteNodes[remoteNodes.length - 1].index : top.index;
      var verifiedBy = Math.max(flat.rightSpan(top.index), flat.rightSpan(lastNode)) + 2;
      var length = verifiedBy / 2;
      var self = this;
      this._getRootsToVerify(verifiedBy, top, remoteNodes, function(err, roots, extraNodes) {
        if (err) return cb(err);
        var checksum = crypto.signable(roots, length);
        var signature = null;
        if (self.length && self.live && !proof.signature) {
          return cb(new Error("Remote did not include a signature"));
        }
        if (proof.signature) {
          verifyCompat(self, checksum, proof.signature, function(err2, valid) {
            if (err2) return cb(err2);
            if (!valid) return cb(new Error("Remote signature could not be verified"));
            signature = { index: verifiedBy / 2 - 1, signature: proof.signature };
            write();
          });
        } else {
          if (Buffer.compare(checksum.slice(0, 32), self.key) !== 0) {
            return cb(new Error("Remote checksum failed"));
          }
          write();
        }
        function write() {
          self.live = !!signature;
          if (length > self.length) {
            if (self.writable) self._merkle = null;
            self.length = length;
            self._seq = length;
            self.byteLength = roots.reduce(addSize, 0);
            if (self._synced) self._synced.seek(0, self.length);
            self.emit("append");
          }
          self._write(index, data, nodes.concat(extraNodes), signature, from, cb);
        }
      });
    };
    Feed.prototype._getRootsToVerify = function(verifiedBy, top, remoteNodes, cb) {
      var indexes = flat.fullRoots(verifiedBy);
      var roots = new Array(indexes.length);
      var nodes = [];
      var error = null;
      var pending = roots.length;
      for (var i = 0; i < indexes.length; i++) {
        if (indexes[i] === top.index) {
          nodes.push(top);
          onnode(null, top);
        } else if (remoteNodes.length && indexes[i] === remoteNodes[0].index) {
          nodes.push(remoteNodes[0]);
          onnode(null, remoteNodes.shift());
        } else if (this.tree.get(indexes[i])) {
          this._storage.getNode(indexes[i], onnode);
        } else {
          onnode(new Error("Missing tree roots needed for verify"));
        }
      }
      function onnode(err, node) {
        if (err) error = err;
        if (node) roots[indexes.indexOf(node.index)] = node;
        if (!--pending) done(error);
      }
      function done(err) {
        if (err) return cb(err);
        cb(null, roots, nodes);
      }
    };
    Feed.prototype._announce = function(message, from) {
      for (var i = 0; i < this.peers.length; i++) {
        var peer = this.peers[i];
        if (peer !== from) peer.have(message);
      }
    };
    Feed.prototype._unannounce = function(message) {
      for (var i = 0; i < this.peers.length; i++) this.peers[i].unhave(message);
    };
    Feed.prototype.downloaded = function(start, end, cb) {
      const count = this.bitfield.total(start, end);
      if (cb) process.nextTick(cb, null, count);
      return count;
    };
    Feed.prototype.has = function(start, end, cb) {
      if (typeof end === "function") return this.has(start, void 0, end);
      if (end === void 0) {
        const res2 = this.bitfield.get(start);
        if (cb) process.nextTick(cb, null, res2);
        return res2;
      }
      const total = end - start;
      const res = total === this.bitfield.total(start, end);
      if (cb) process.nextTick(cb, null, res);
      return res;
    };
    Feed.prototype.getBlockInfo = function(index, cb) {
      var self = this;
      this.ready(function(err) {
        if (err) return cb(err);
        self._storage.getNode(2 * index, cb);
      });
    };
    Feed.prototype.head = function(opts, cb) {
      if (typeof opts === "function") return this.head({}, opts);
      var self = this;
      this.ready(function(err) {
        if (err) return cb(err);
        if (opts && opts.update) self.update(opts, onupdate);
        else process.nextTick(onupdate);
      });
      function onupdate() {
        if (self.length === 0) cb(new Error("feed is empty"));
        else self.get(self.length - 1, opts, cb);
      }
    };
    Feed.prototype.get = function(index, opts, cb) {
      if (typeof opts === "function") return this.get(index, null, opts);
      opts = { ...opts };
      if (!opts.cancel) opts.cancel = Symbol("hypercore-get");
      if (!this.opened) return this._readyAndGet(index, opts, cb);
      if (!this.readable) {
        process.nextTick(cb, new Error("Feed is closed"));
        return opts.cancel;
      }
      if (opts.timeout) cb = timeoutCallback(cb, opts.timeout);
      if (!this.bitfield.get(index)) {
        if (opts && opts.wait === false) return process.nextTick(cb, new Error("Block not downloaded"));
        var w = { bytes: 0, hash: false, index, options: opts, requested: 0, callback: cb };
        this._waiting.push(w);
        if (opts && typeof opts.ifAvailable === "boolean" ? opts.ifAvailable : this._alwaysIfAvailable) this._ifAvailableGet(w);
        this._updatePeers();
        if (opts.onwait) {
          const onwait = opts.onwait;
          opts.onwait = null;
          onwait(index);
        }
        return opts.cancel;
      }
      if (opts && opts.valueEncoding) cb = wrapCodec(toCodec(opts.valueEncoding), cb);
      else if (this._codec !== codecs.binary) cb = wrapCodec(this._codec, cb);
      this._getBuffer(index, cb);
      return opts.cancel;
    };
    Feed.prototype._readyAndGet = function(index, opts, cb) {
      var self = this;
      this.ready(function(err) {
        if (err) return cb(err);
        self.get(index, opts, cb);
      });
      return opts.cancel;
    };
    Feed.prototype.getBatch = function(start, end, opts, cb) {
      if (typeof opts === "function") return this.getBatch(start, end, null, opts);
      if (!this.opened) return this._readyAndGetBatch(start, end, opts, cb);
      var self = this;
      var wait = !opts || opts.wait !== false;
      if (this.has(start, end)) return this._getBatch(start, end, opts, cb);
      if (!wait) return process.nextTick(cb, new Error("Block not downloaded"));
      if (opts && opts.timeout) cb = timeoutCallback(cb, opts.timeout);
      this.download({ start, end }, function(err) {
        if (err) return cb(err);
        self._getBatch(start, end, opts, cb);
      });
    };
    Feed.prototype._getBatch = function(start, end, opts, cb) {
      var enc = opts && opts.valueEncoding;
      var codec = enc ? toCodec(enc) : this._codec;
      this._storage.getDataBatch(start, end - start, onbatch);
      function onbatch(err, buffers) {
        if (err) return cb(err);
        var batch = new Array(buffers.length);
        for (var i = 0; i < buffers.length; i++) {
          try {
            batch[i] = codec ? codec.decode(buffers[i]) : buffers[i];
          } catch (err2) {
            return cb(err2);
          }
        }
        cb(null, batch);
      }
    };
    Feed.prototype._readyAndGetBatch = function(start, end, opts, cb) {
      var self = this;
      this.ready(function(err) {
        if (err) return cb(err);
        self.getBatch(start, end, opts, cb);
      });
    };
    Feed.prototype._updatePeers = function() {
      for (var i = 0; i < this.peers.length; i++) this.peers[i].update();
    };
    Feed.prototype.createWriteStream = function(opts) {
      return new WriteStream(this, opts);
    };
    Feed.prototype.createReadStream = function(opts) {
      return new ReadStream(this, opts);
    };
    Feed.prototype.finalize = function(cb) {
      if (!this.key) {
        this.key = crypto.tree(this._merkle.roots);
        this.discoveryKey = crypto.discoveryKey(this.key);
      }
      this._storage.key.write(0, this.key, cb);
    };
    Feed.prototype.append = function(batch, cb) {
      if (!cb) cb = noop;
      var self = this;
      var list = Array.isArray(batch) ? batch : [batch];
      this._batch(list, onappend);
      function onappend(err) {
        if (err) return cb(err);
        var seq = self._seq;
        self._seq += list.length;
        cb(null, seq);
      }
    };
    Feed.prototype.flush = function(cb) {
      this.append([], cb);
    };
    Feed.prototype.destroyStorage = function(cb) {
      const self = this;
      this.close(function(err) {
        if (err) cb(err);
        else self._storage.destroy(cb);
      });
    };
    Feed.prototype._close = function(cb) {
      const self = this;
      for (const peer of this.peers) {
        if (!peer._destroyed) peer._close();
      }
      this._forceClose(onclose, null);
      function onclose(err) {
        if (!err) self.emit("close");
        cb(err);
      }
    };
    Feed.prototype._forceClose = function(cb, error) {
      var self = this;
      this.writable = false;
      this.readable = false;
      this._storage.close(function(err) {
        if (!err) err = error;
        self._destroy(err || new Error("Feed is closed"));
        cb(err);
      });
    };
    Feed.prototype._destroy = function(err) {
      this.ifAvailable.destroy();
      while (this._waiting.length) {
        this._waiting.pop().callback(err);
      }
      while (this._selections.length) {
        this._selections.pop().callback(err);
      }
    };
    Feed.prototype._appendHook = function(batch, cb) {
      var self = this;
      var missing = batch.length;
      var error = null;
      if (!missing) return this._append(batch, cb);
      for (var i = 0; i < batch.length; i++) {
        this._onwrite(i + this.length, batch[i], null, done);
      }
      function done(err) {
        if (err) error = err;
        if (--missing) return;
        if (error) return cb(error);
        self._append(batch, cb);
      }
    };
    Feed.prototype._append = function(batch, cb) {
      if (!this.opened) return this._readyAndAppend(batch, cb);
      if (!this.writable) return cb(new Error("This feed is not writable. Did you create it?"));
      var self = this;
      var pending = 1;
      var offset = 0;
      var error = null;
      var nodeBatch = new Array(batch.length ? batch.length * 2 - 1 : 0);
      var nodeOffset = this.length * 2;
      var dataBatch = new Array(batch.length);
      if (!pending) return cb();
      for (var i = 0; i < batch.length; i++) {
        var data = this._codec.encode(batch[i]);
        var nodes = this._merkle.next(data);
        if (data.length > 8388608) return cb(new Error("Individual blocks has be less than 8MB"));
        offset += data.length;
        dataBatch[i] = data;
        for (var j = 0; j < nodes.length; j++) {
          var node = nodes[j];
          if (node.index >= nodeOffset && node.index - nodeOffset < nodeBatch.length) {
            nodeBatch[node.index - nodeOffset] = node;
          } else {
            pending++;
            this._storage.putNode(node.index, node, done);
          }
        }
      }
      if (this.live && batch.length) {
        pending++;
        this.crypto.sign(crypto.signable(this._merkle.roots, self.length + batch.length), this.secretKey, function(err, sig) {
          if (err) return done(err);
          self._storage.putSignature(self.length + batch.length - 1, sig, done);
        });
      }
      if (!this._indexing) {
        pending++;
        if (dataBatch.length === 1) this._storage.data.write(this.byteLength, dataBatch[0], done);
        else this._storage.data.write(this.byteLength, Buffer.concat(dataBatch), done);
      }
      this._storage.putNodeBatch(nodeOffset, nodeBatch, done);
      function done(err) {
        if (err) error = err;
        if (--pending) return;
        if (error) return cb(error);
        var start = self.length;
        self.byteLength += offset;
        for (var i2 = 0; i2 < batch.length; i2++) {
          self.bitfield.set(self.length, true);
          self.tree.set(2 * self.length++);
        }
        self.emit("append");
        var message = self.length - start > 1 ? { start, length: self.length - start } : { start };
        if (self.peers.length) self._announce(message);
        self._sync(null, cb);
      }
    };
    Feed.prototype._readyAndAppend = function(batch, cb) {
      var self = this;
      this.ready(function(err) {
        if (err) return cb(err);
        self._append(batch, cb);
      });
    };
    Feed.prototype._readyAndCancel = function(start, end) {
      var self = this;
      this.ready(function() {
        self._cancel(start, end);
      });
    };
    Feed.prototype._pollWaiting = function() {
      var len = this._waiting.length;
      for (var i = 0; i < len; i++) {
        var next = this._waiting[i];
        if (!next.bytes && !this.bitfield.get(next.index) && (!next.hash || !this.tree.get(next.index * 2))) {
          continue;
        }
        remove(this._waiting, i--);
        len--;
        if (next.bytes) this.seek(next.bytes, next, next.callback);
        else if (next.update) this.update(next.index + 1, next.callback);
        else this.get(next.index, next.options, next.callback);
      }
    };
    Feed.prototype._syncBitfield = function(cb) {
      var missing = this.bitfield.pages.updates.length;
      var next = null;
      var error = null;
      if (!missing) {
        this._pollWaiting();
        return cb(null);
      }
      while ((next = this.bitfield.pages.lastUpdate()) !== null) {
        this._storage.putBitfield(next.offset, next.buffer, ondone);
      }
      this._pollWaiting();
      function ondone(err) {
        if (err) error = err;
        if (--missing) return;
        cb(error);
      }
    };
    Feed.prototype._roots = function(index, cb) {
      var roots = flat.fullRoots(2 * index);
      var result = new Array(roots.length);
      var pending = roots.length;
      var error = null;
      if (!pending) return cb(null, result);
      for (var i = 0; i < roots.length; i++) {
        this._storage.getNode(roots[i], onnode);
      }
      function onnode(err, node) {
        if (err) error = err;
        if (node) result[roots.indexOf(node.index)] = node;
        if (--pending) return;
        if (error) return cb(error);
        cb(null, result);
      }
    };
    Feed.prototype.audit = function(cb) {
      if (!cb) cb = noop;
      var self = this;
      var report = {
        valid: 0,
        invalid: 0
      };
      this.ready(function(err) {
        if (err) return cb(err);
        var block = 0;
        var max = self.length;
        next();
        function onnode(err2, node) {
          if (err2) return ondata(null, null);
          self._storage.getData(block, ondata);
          function ondata(_, data) {
            var verified = data && crypto.data(data).equals(node.hash);
            if (verified) report.valid++;
            else report.invalid++;
            self.bitfield.set(block, verified);
            block++;
            next();
          }
        }
        function next() {
          while (block < max && !self.bitfield.get(block)) block++;
          if (block >= max) return done();
          self._storage.getNode(2 * block, onnode);
        }
        function done() {
          self._sync(null, function(err2) {
            if (err2) return cb(err2);
            cb(null, report);
          });
        }
      });
    };
    Feed.prototype.extension = function(name, message) {
      var peers = this.peers;
      for (var i = 0; i < peers.length; i++) {
        peers[i].extension(name, message);
      }
    };
    function noop() {
    }
    function verifyNode(trusted, node) {
      return trusted && trusted.index === node.index && Buffer.compare(trusted.hash, node.hash) === 0;
    }
    function addSize(size, node) {
      return size + node.size;
    }
    function isBlock(index) {
      return (index & 1) === 0;
    }
    function toCodec(enc) {
      return codecs(enc === "json" ? "ndjson" : enc);
    }
    function wrapCodec(enc, cb) {
      return function(err, buf) {
        if (err) return cb(err);
        try {
          buf = enc.decode(buf);
        } catch (err2) {
          return cb(err2);
        }
        cb(null, buf);
      };
    }
    function timeoutCallback(cb, timeout) {
      var failed = false;
      var id = setTimeout(ontimeout, timeout);
      return done;
      function ontimeout() {
        failed = true;
        var err = new Error("ETIMEDOUT");
        err.code = "ETIMEDOUT";
        cb(err);
      }
      function done(err, val2) {
        if (failed) return;
        clearTimeout(id);
        cb(err, val2);
      }
    }
    function toWantRange(i) {
      return Math.floor(i / 1024 / 1024) * 1024 * 1024;
    }
    function createError(code, errno, msg) {
      var err = new Error(msg);
      err.code = code;
      err.errno = errno;
      return err;
    }
    function defaultStorageDir(directory) {
      return function(name) {
        return defaultStorage(name, { directory });
      };
    }
    function isOptions(initiator) {
      return !Protocol.isProtocolStream(initiator) && typeof initiator === "object" && !!initiator && typeof initiator.initiator === "boolean";
    }
    function readyNT(ifAvailable, fn) {
      ifAvailable.ready(fn);
    }
    function verifyCompat(self, checksum, signature, cb) {
      self.crypto.verify(checksum, signature, self.key, function(err, valid) {
        if (err || valid) return cb(err, valid);
        self.crypto.verify(checksum.slice(0, 32), signature, self.key, cb);
      });
    }
  }
});

// packages/common/hypercore/src/index.ts
var import_hypercore2 = __toESM(require_hypercore(), 1);

// packages/common/hypercore/src/crypto.ts
import { callbackify } from "@dxos/node-std/util";
import { verifySignature } from "@dxos/crypto";
import { invariant } from "@dxos/invariant";
import { arrayToBuffer } from "@dxos/util";
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/common/hypercore/src/crypto.ts";
var createCodecEncoding = (codec, opts) => ({
  encode: (obj) => arrayToBuffer(codec.encode(obj, opts)),
  decode: (buffer) => codec.decode(buffer, opts)
});
var createCrypto = (signer, publicKey) => {
  invariant(signer, void 0, {
    F: __dxlog_file,
    L: 27,
    S: void 0,
    A: [
      "signer",
      ""
    ]
  });
  invariant(publicKey, void 0, {
    F: __dxlog_file,
    L: 28,
    S: void 0,
    A: [
      "publicKey",
      ""
    ]
  });
  return {
    sign: (message, secretKey, cb) => {
      callbackify(signer.sign.bind(signer))(publicKey, message, (err, result) => {
        if (err) {
          cb(err, null);
          return;
        }
        cb(null, arrayToBuffer(result));
      });
    },
    verify: async (message, signature, key, cb) => {
      callbackify(verifySignature)(publicKey, message, signature, cb);
    }
  };
};

// packages/common/hypercore/src/defaults.ts
var defaultFeedOptions = {
  createIfMissing: true,
  valueEncoding: "binary"
};
var defaultReadStreamOptions = {
  start: 0,
  end: Infinity,
  snapshot: true,
  tail: false,
  live: false,
  timeout: 0,
  wait: true,
  batch: 1
};
var defaultWriteStreamOptions = {
  maxBlockSize: Infinity
};
var defaultReplicateOptions = {
  live: false,
  ack: false,
  download: true,
  upload: true,
  encrypted: true,
  noise: true
};

// packages/common/hypercore/src/hypercore-factory.ts
var import_hypercore = __toESM(require_hypercore(), 1);
import { invariant as invariant2 } from "@dxos/invariant";
import { createStorage, StorageType } from "@dxos/random-access-storage";

// packages/common/hypercore/src/util.ts
import util from "@dxos/node-std/util";
var py = (obj, fn) => util.promisify(fn.bind(obj));

// packages/common/hypercore/src/hypercore-factory.ts
var __dxlog_file2 = "/home/runner/work/dxos/dxos/packages/common/hypercore/src/hypercore-factory.ts";
var HypercoreFactory = class {
  constructor(_root = createStorage({
    type: StorageType.RAM
  }).createDirectory(), _options) {
    this._root = _root;
    this._options = _options;
    invariant2(this._root, void 0, {
      F: __dxlog_file2,
      L: 21,
      S: this,
      A: [
        "this._root",
        ""
      ]
    });
  }
  /**
  * Creates a feed using a storage factory prefixed with the feed's key.
  * NOTE: We have to use our `random-access-storage` implementation since the native ones
  * do not behave uniformly across platforms.
  */
  createFeed(publicKey, options) {
    const directory = this._root.createDirectory(publicKey.toString("hex"));
    const storage = (filename) => directory.getOrCreateFile(filename).native;
    return (0, import_hypercore.default)(storage, publicKey, Object.assign({}, this._options, options));
  }
  /**
  * Creates and opens a feed.
  */
  async openFeed(publicKey, options) {
    const feed = this.createFeed(publicKey, options);
    await py(feed, feed.open)();
    return feed;
  }
};

// packages/common/hypercore/src/iterator.ts
import { Readable } from "readable-stream";
var createReadable = (stream) => {
  return new Readable({
    objectMode: true
  }).wrap(stream);
};
var createAsyncIterator = (stream) => {
  return stream[Symbol.asyncIterator]();
};
var export_hypercore = import_hypercore2.default;
export {
  HypercoreFactory,
  createAsyncIterator,
  createCodecEncoding,
  createCrypto,
  createReadable,
  defaultFeedOptions,
  defaultReadStreamOptions,
  defaultReplicateOptions,
  defaultWriteStreamOptions,
  export_hypercore as hypercore
};
//# sourceMappingURL=index.mjs.map
