//
// Copyright 2020 DXOS.org
//

// @generated by protoc-gen-es v2.1.0 with parameter "target=ts,import_extension=js"
// @generated from file dxos/halo/credentials/greet.proto (package dxos.halo.credentials.greet, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import type { Any } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_any } from "@bufbuild/protobuf/wkt";
import type { KeyType } from "../keys_pb.js";
import { file_dxos_halo_keys } from "../keys_pb.js";
import type { PublicKey } from "../../keys_pb.js";
import { file_dxos_keys } from "../../keys_pb.js";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file dxos/halo/credentials/greet.proto.
 */
export const file_dxos_halo_credentials_greet: GenFile = /*@__PURE__*/
  fileDesc("CiFkeG9zL2hhbG8vY3JlZGVudGlhbHMvZ3JlZXQucHJvdG8SG2R4b3MuaGFsby5jcmVkZW50aWFscy5ncmVldCLSAQoHQ29tbWFuZBI6Cgdjb21tYW5kGAEgASgOMikuZHhvcy5oYWxvLmNyZWRlbnRpYWxzLmdyZWV0LkNvbW1hbmQuVHlwZRITCgZzZWNyZXQYAiABKAxIAIgBARIkCgZwYXJhbXMYCiADKAsyFC5nb29nbGUucHJvdG9idWYuQW55IkUKBFR5cGUSCQoFQkVHSU4QABINCglIQU5EU0hBS0UQARIMCghOT1RBUklaRRACEgoKBkZJTklTSBADEgkKBUNMQUlNEApCCQoHX3NlY3JldCKWAQoNQmVnaW5SZXNwb25zZRJCCgRpbmZvGAEgAygLMjQuZHhvcy5oYWxvLmNyZWRlbnRpYWxzLmdyZWV0LkJlZ2luUmVzcG9uc2UuSW5mb0VudHJ5GkEKCUluZm9FbnRyeRILCgNrZXkYASABKAkSIwoFdmFsdWUYAiABKAsyFC5nb29nbGUucHJvdG9idWYuQW55OgI4ASJLChFIYW5kc2hha2VSZXNwb25zZRINCgVub25jZRgBIAEoDBInCglzcGFjZV9rZXkYAiABKAsyFC5keG9zLmtleXMuUHVibGljS2V5ImQKEE5vdGFyaXplUmVzcG9uc2USJAoGY29waWVzGAEgAygLMhQuZ29vZ2xlLnByb3RvYnVmLkFueRIqCgxnZW5lc2lzX2ZlZWQYAyABKAsyFC5keG9zLmtleXMuUHVibGljS2V5IloKB0tleUhpbnQSKAoKcHVibGljX2tleRgBIAEoCzIULmR4b3Mua2V5cy5QdWJsaWNLZXkSJQoEdHlwZRgCIAEoDjIXLmR4b3MuaGFsby5rZXlzLktleVR5cGUiMwoNQ2xhaW1SZXNwb25zZRIKCgJpZBgBIAEoDBIWCg5yZW5kZXp2b3VzX2tleRgCIAEoDGIGcHJvdG8z", [file_google_protobuf_any, file_dxos_halo_keys, file_dxos_keys]);

/**
 * *
 * A Greeter command.
 *
 * @generated from message dxos.halo.credentials.greet.Command
 */
export type Command = Message<"dxos.halo.credentials.greet.Command"> & {
  /**
   * @generated from field: dxos.halo.credentials.greet.Command.Type command = 1;
   */
  command: Command_Type;

  /**
   * Auth secret (PIN, hash, AuthMessage, etc.).
   *
   * @generated from field: optional bytes secret = 2;
   */
  secret?: Uint8Array;

  /**
   * TODO(burdon): These seem to be signed messages? In which case we already know the type.
   * TODO(dboreham): static typing of contained messages is not yet supported, change from any when it is.
   * Parameters to the command.
   *
   * @generated from field: repeated google.protobuf.Any params = 10;
   */
  params: Any[];
};

/**
 * Describes the message dxos.halo.credentials.greet.Command.
 * Use `create(CommandSchema)` to create a new message.
 */
export const CommandSchema: GenMessage<Command> = /*@__PURE__*/
  messageDesc(file_dxos_halo_credentials_greet, 0);

/**
 * @generated from enum dxos.halo.credentials.greet.Command.Type
 */
export enum Command_Type {
  /**
   * @generated from enum value: BEGIN = 0;
   */
  BEGIN = 0,

  /**
   * @generated from enum value: HANDSHAKE = 1;
   */
  HANDSHAKE = 1,

  /**
   * @generated from enum value: NOTARIZE = 2;
   */
  NOTARIZE = 2,

  /**
   * @generated from enum value: FINISH = 3;
   */
  FINISH = 3,

  /**
   * @generated from enum value: CLAIM = 10;
   */
  CLAIM = 10,
}

/**
 * Describes the enum dxos.halo.credentials.greet.Command.Type.
 */
export const Command_TypeSchema: GenEnum<Command_Type> = /*@__PURE__*/
  enumDesc(file_dxos_halo_credentials_greet, 0, 0);

/**
 *
 * Info is optional, and not needed for very simple schemes like using a PIN, but more complicated scenarios schemes
 * might need to communicate additional info in the response (eg, what key is expected for a signed AuthMessage).
 *
 *
 * @generated from message dxos.halo.credentials.greet.BeginResponse
 */
export type BeginResponse = Message<"dxos.halo.credentials.greet.BeginResponse"> & {
  /**
   * @generated from field: map<string, google.protobuf.Any> info = 1;
   */
  info: { [key: string]: Any };
};

/**
 * Describes the message dxos.halo.credentials.greet.BeginResponse.
 * Use `create(BeginResponseSchema)` to create a new message.
 */
export const BeginResponseSchema: GenMessage<BeginResponse> = /*@__PURE__*/
  messageDesc(file_dxos_halo_credentials_greet, 1);

/**
 *
 * The next command is 'HANDSHAKE', the invitee sends the `secret` for authentication, and if successful, the
 * Greeter returns the `space_key` and a `nonce` which the invitee will need to use for the Space credential messages.
 *
 *
 * @generated from message dxos.halo.credentials.greet.HandshakeResponse
 */
export type HandshakeResponse = Message<"dxos.halo.credentials.greet.HandshakeResponse"> & {
  /**
   * Random bytes which must be included in the signed portion of messages submitted in a 'NOTARIZE' command
   * (proving ownership of the keys in question).
   *
   * @generated from field: bytes nonce = 1;
   */
  nonce: Uint8Array;

  /**
   * The public key of the space.
   *
   * @generated from field: dxos.keys.PublicKey space_key = 2;
   */
  spaceKey?: PublicKey;
};

/**
 * Describes the message dxos.halo.credentials.greet.HandshakeResponse.
 * Use `create(HandshakeResponseSchema)` to create a new message.
 */
export const HandshakeResponseSchema: GenMessage<HandshakeResponse> = /*@__PURE__*/
  messageDesc(file_dxos_halo_credentials_greet, 2);

/**
 *
 * The 'NOTARIZE' command takes an array of SignedMessages which the invitee would like added to the Space. The
 * standard case would be a message admitting an Identity (or Device) key and a message admitting a feed.
 *
 *
 * @generated from message dxos.halo.credentials.greet.NotarizeResponse
 */
export type NotarizeResponse = Message<"dxos.halo.credentials.greet.NotarizeResponse"> & {
  /**
   * A copy of each of the messages as written to the Space (now in an Envelope signed by the Greeter) and the Feed
   * and key hints necessary to bootstrap the invitee into the Space.
   *
   * @generated from field: repeated google.protobuf.Any copies = 1;
   */
  copies: Any[];

  /**
   * @generated from field: dxos.keys.PublicKey genesis_feed = 3;
   */
  genesisFeed?: PublicKey;
};

/**
 * Describes the message dxos.halo.credentials.greet.NotarizeResponse.
 * Use `create(NotarizeResponseSchema)` to create a new message.
 */
export const NotarizeResponseSchema: GenMessage<NotarizeResponse> = /*@__PURE__*/
  messageDesc(file_dxos_halo_credentials_greet, 3);

/**
 * TODO(dmaretskyi): Verify if this is valid. Wouldn't the knowledge of the space's public key be enough to verify the rest of credential messages?
 *
 * Feed and key hints are by the invitee, because even though the Space members now trust it, it does not trust
 * them. Until it has a chance to replicate, it cannot construct its own understanding of the Space from space.*
 * messages, but neither can it replicate unless it trusts its peers. The Hints break this cycle by providing an
 * initial set of keys and Feeds to trust.
 *
 *
 * @generated from message dxos.halo.credentials.greet.KeyHint
 */
export type KeyHint = Message<"dxos.halo.credentials.greet.KeyHint"> & {
  /**
   * TODO(telackey): These should be changed to be the full set of signed space messages, so the recipient can build
   * and verify the space structure just as it would if it had obtained them from the feeds.
   *
   * @generated from field: dxos.keys.PublicKey public_key = 1;
   */
  publicKey?: PublicKey;

  /**
   * @generated from field: dxos.halo.keys.KeyType type = 2;
   */
  type: KeyType;
};

/**
 * Describes the message dxos.halo.credentials.greet.KeyHint.
 * Use `create(KeyHintSchema)` to create a new message.
 */
export const KeyHintSchema: GenMessage<KeyHint> = /*@__PURE__*/
  messageDesc(file_dxos_halo_credentials_greet, 4);

/**
 *
 * The 'CLAIM' command is used to trigger the Greeting flow by "claiming" a SpaceInvitation which was replicated
 * to the Space or presented as a "proof".
 *
 * The ClaimResponse provides the invitee with information about the interactive invitation triggered by the "claim",
 * such as the invitation ID and the swarm key to use to connect to the Greeter.
 *
 *
 * @generated from message dxos.halo.credentials.greet.ClaimResponse
 */
export type ClaimResponse = Message<"dxos.halo.credentials.greet.ClaimResponse"> & {
  /**
   * The ID of the invitation.
   *
   * @generated from field: bytes id = 1;
   */
  id: Uint8Array;

  /**
   * The swarm key to use to rendezvous with the Greeter.
   *
   * @generated from field: bytes rendezvous_key = 2;
   */
  rendezvousKey: Uint8Array;
};

/**
 * Describes the message dxos.halo.credentials.greet.ClaimResponse.
 * Use `create(ClaimResponseSchema)` to create a new message.
 */
export const ClaimResponseSchema: GenMessage<ClaimResponse> = /*@__PURE__*/
  messageDesc(file_dxos_halo_credentials_greet, 5);

