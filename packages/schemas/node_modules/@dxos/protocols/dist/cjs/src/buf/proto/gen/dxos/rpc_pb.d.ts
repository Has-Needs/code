import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import type { Any } from "@bufbuild/protobuf/wkt";
import type { Error } from "./error_pb.js";
import type { Message } from "@bufbuild/protobuf";
/**
 * Describes the file dxos/rpc.proto.
 */
export declare const file_dxos_rpc: GenFile;
/**
 * @generated from message dxos.rpc.RpcMessage
 */
export type RpcMessage = Message<"dxos.rpc.RpcMessage"> & {
    /**
     * @generated from oneof dxos.rpc.RpcMessage.content
     */
    content: {
        /**
         * @generated from field: dxos.rpc.Request request = 1;
         */
        value: Request;
        case: "request";
    } | {
        /**
         * @generated from field: dxos.rpc.Response response = 2;
         */
        value: Response;
        case: "response";
    } | {
        /**
         * / Means that the node is trying to open the connection.
         *
         * @generated from field: bool open = 3;
         */
        value: boolean;
        case: "open";
    } | {
        /**
         * / Means that the node has received the "open" message and is ready to perform requests.
         *
         * @generated from field: bool open_ack = 4;
         */
        value: boolean;
        case: "openAck";
    } | {
        /**
         * @generated from field: dxos.rpc.StreamClose stream_close = 5;
         */
        value: StreamClose;
        case: "streamClose";
    } | {
        /**
         * / Request to close the connection.
         *
         * @generated from field: dxos.rpc.Bye bye = 6;
         */
        value: Bye;
        case: "bye";
    } | {
        case: undefined;
        value?: undefined;
    };
};
/**
 * Describes the message dxos.rpc.RpcMessage.
 * Use `create(RpcMessageSchema)` to create a new message.
 */
export declare const RpcMessageSchema: GenMessage<RpcMessage>;
/**
 * @generated from message dxos.rpc.Request
 */
export type Request = Message<"dxos.rpc.Request"> & {
    /**
     * @generated from field: int32 id = 1;
     */
    id: number;
    /**
     * @generated from field: string method = 2;
     */
    method: string;
    /**
     * @generated from field: google.protobuf.Any payload = 3;
     */
    payload?: Any;
    /**
     * @generated from field: bool stream = 4;
     */
    stream: boolean;
};
/**
 * Describes the message dxos.rpc.Request.
 * Use `create(RequestSchema)` to create a new message.
 */
export declare const RequestSchema: GenMessage<Request>;
/**
 * @generated from message dxos.rpc.Response
 */
export type Response = Message<"dxos.rpc.Response"> & {
    /**
     * @generated from field: int32 id = 1;
     */
    id: number;
    /**
     * @generated from oneof dxos.rpc.Response.content
     */
    content: {
        /**
         * @generated from field: google.protobuf.Any payload = 2;
         */
        value: Any;
        case: "payload";
    } | {
        /**
         * @generated from field: dxos.error.Error error = 3;
         */
        value: Error;
        case: "error";
    } | {
        /**
         * / Sent when stream is closed without an error.
         *
         * @generated from field: bool close = 4;
         */
        value: boolean;
        case: "close";
    } | {
        /**
         * *
         * Sent when the server has processed a request with a streaming response.
         * Can be skipped by the server.
         * In this case the first payload should be treated as the server being ready.
         *
         * @generated from field: bool stream_ready = 5;
         */
        value: boolean;
        case: "streamReady";
    } | {
        case: undefined;
        value?: undefined;
    };
};
/**
 * Describes the message dxos.rpc.Response.
 * Use `create(ResponseSchema)` to create a new message.
 */
export declare const ResponseSchema: GenMessage<Response>;
/**
 * TODO(burdon): Generalize to event?
 * Sent by client to end the streaming response.
 *
 * @generated from message dxos.rpc.StreamClose
 */
export type StreamClose = Message<"dxos.rpc.StreamClose"> & {
    /**
     * @generated from field: int32 id = 1;
     */
    id: number;
};
/**
 * Describes the message dxos.rpc.StreamClose.
 * Use `create(StreamCloseSchema)` to create a new message.
 */
export declare const StreamCloseSchema: GenMessage<StreamClose>;
/**
 * TODO(burdon): Rename Trace.
 *
 * @generated from message dxos.rpc.MessageTrace
 */
export type MessageTrace = Message<"dxos.rpc.MessageTrace"> & {
    /**
     * @generated from field: dxos.rpc.MessageTrace.Direction direction = 1;
     */
    direction: MessageTrace_Direction;
    /**
     * @generated from field: bytes data = 2;
     */
    data: Uint8Array;
};
/**
 * Describes the message dxos.rpc.MessageTrace.
 * Use `create(MessageTraceSchema)` to create a new message.
 */
export declare const MessageTraceSchema: GenMessage<MessageTrace>;
/**
 * @generated from enum dxos.rpc.MessageTrace.Direction
 */
export declare enum MessageTrace_Direction {
    /**
     * @generated from enum value: INCOMING = 0;
     */
    INCOMING = 0,
    /**
     * @generated from enum value: OUTGOING = 1;
     */
    OUTGOING = 1
}
/**
 * Describes the enum dxos.rpc.MessageTrace.Direction.
 */
export declare const MessageTrace_DirectionSchema: GenEnum<MessageTrace_Direction>;
/**
 * *
 * Request to close the connection.
 * Connection is closed once both sides have received the Bye message.
 *
 * @generated from message dxos.rpc.Bye
 */
export type Bye = Message<"dxos.rpc.Bye"> & {};
/**
 * Describes the message dxos.rpc.Bye.
 * Use `create(ByeSchema)` to create a new message.
 */
export declare const ByeSchema: GenMessage<Bye>;
//# sourceMappingURL=rpc_pb.d.ts.map