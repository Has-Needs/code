import type { GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv1";
import type { EmptySchema } from "@bufbuild/protobuf/wkt";
import type { Message } from "@bufbuild/protobuf";
/**
 * Describes the file dxos/echo/service.proto.
 */
export declare const file_dxos_echo_service: GenFile;
/**
 * @generated from message dxos.echo.service.SubscribeRequest
 */
export type SubscribeRequest = Message<"dxos.echo.service.SubscribeRequest"> & {
    /**
     * @generated from field: string subscription_id = 1;
     */
    subscriptionId: string;
    /**
     * @generated from field: string space_id = 2;
     */
    spaceId: string;
};
/**
 * Describes the message dxos.echo.service.SubscribeRequest.
 * Use `create(SubscribeRequestSchema)` to create a new message.
 */
export declare const SubscribeRequestSchema: GenMessage<SubscribeRequest>;
/**
 * @generated from message dxos.echo.service.BatchedDocumentUpdates
 */
export type BatchedDocumentUpdates = Message<"dxos.echo.service.BatchedDocumentUpdates"> & {
    /**
     * @generated from field: repeated dxos.echo.service.DocumentUpdate updates = 1;
     */
    updates: DocumentUpdate[];
};
/**
 * Describes the message dxos.echo.service.BatchedDocumentUpdates.
 * Use `create(BatchedDocumentUpdatesSchema)` to create a new message.
 */
export declare const BatchedDocumentUpdatesSchema: GenMessage<BatchedDocumentUpdates>;
/**
 * @generated from message dxos.echo.service.UpdateRequest
 */
export type UpdateRequest = Message<"dxos.echo.service.UpdateRequest"> & {
    /**
     * @generated from field: string subscription_id = 1;
     */
    subscriptionId: string;
    /**
     * @generated from field: repeated dxos.echo.service.DocumentUpdate updates = 2;
     */
    updates: DocumentUpdate[];
};
/**
 * Describes the message dxos.echo.service.UpdateRequest.
 * Use `create(UpdateRequestSchema)` to create a new message.
 */
export declare const UpdateRequestSchema: GenMessage<UpdateRequest>;
/**
 * @generated from message dxos.echo.service.UpdateSubscriptionRequest
 */
export type UpdateSubscriptionRequest = Message<"dxos.echo.service.UpdateSubscriptionRequest"> & {
    /**
     * *
     * Id of the subscription to update.
     * Subscription id is returned by `Subscribe` rpc.
     *
     * @generated from field: string subscription_id = 1;
     */
    subscriptionId: string;
    /**
     * *
     * Automerge document ids to subscribe for updates.
     * Used for already existing documents.
     * To add new document use `write` rpc.
     *
     * @generated from field: repeated string add_ids = 3;
     */
    addIds: string[];
    /**
     * *
     * Automerge document ids to unsubscribe from.
     *
     * @generated from field: repeated string remove_ids = 4;
     */
    removeIds: string[];
};
/**
 * Describes the message dxos.echo.service.UpdateSubscriptionRequest.
 * Use `create(UpdateSubscriptionRequestSchema)` to create a new message.
 */
export declare const UpdateSubscriptionRequestSchema: GenMessage<UpdateSubscriptionRequest>;
/**
 * @generated from message dxos.echo.service.FlushRequest
 */
export type FlushRequest = Message<"dxos.echo.service.FlushRequest"> & {
    /**
     * *
     * Automerge specific document ids to wait to flush.
     *
     * @generated from field: repeated string document_ids = 1;
     */
    documentIds: string[];
};
/**
 * Describes the message dxos.echo.service.FlushRequest.
 * Use `create(FlushRequestSchema)` to create a new message.
 */
export declare const FlushRequestSchema: GenMessage<FlushRequest>;
/**
 * @generated from message dxos.echo.service.DocumentUpdate
 */
export type DocumentUpdate = Message<"dxos.echo.service.DocumentUpdate"> & {
    /**
     * *
     * Automerge document id.
     *
     * @generated from field: string document_id = 1;
     */
    documentId: string;
    /**
     * *
     * Automerge document incremental update.
     * Value returned by `Automerge.saveSince()`.
     *
     * @generated from field: bytes mutation = 2;
     */
    mutation: Uint8Array;
    /**
     * *
     * Set to true for init mutation of document.
     * default: undefined.
     *
     * @generated from field: optional bool is_new = 3;
     */
    isNew?: boolean;
};
/**
 * Describes the message dxos.echo.service.DocumentUpdate.
 * Use `create(DocumentUpdateSchema)` to create a new message.
 */
export declare const DocumentUpdateSchema: GenMessage<DocumentUpdate>;
/**
 * @generated from message dxos.echo.service.DocHeadsList
 */
export type DocHeadsList = Message<"dxos.echo.service.DocHeadsList"> & {
    /**
     * @generated from field: repeated dxos.echo.service.DocHeadsList.Entry entries = 1;
     */
    entries: DocHeadsList_Entry[];
};
/**
 * Describes the message dxos.echo.service.DocHeadsList.
 * Use `create(DocHeadsListSchema)` to create a new message.
 */
export declare const DocHeadsListSchema: GenMessage<DocHeadsList>;
/**
 * @generated from message dxos.echo.service.DocHeadsList.Entry
 */
export type DocHeadsList_Entry = Message<"dxos.echo.service.DocHeadsList.Entry"> & {
    /**
     * @generated from field: string document_id = 1;
     */
    documentId: string;
    /**
     * @generated from field: repeated string heads = 2;
     */
    heads: string[];
};
/**
 * Describes the message dxos.echo.service.DocHeadsList.Entry.
 * Use `create(DocHeadsList_EntrySchema)` to create a new message.
 */
export declare const DocHeadsList_EntrySchema: GenMessage<DocHeadsList_Entry>;
/**
 * @generated from message dxos.echo.service.GetDocumentHeadsRequest
 */
export type GetDocumentHeadsRequest = Message<"dxos.echo.service.GetDocumentHeadsRequest"> & {
    /**
     * @generated from field: repeated string document_ids = 1;
     */
    documentIds: string[];
};
/**
 * Describes the message dxos.echo.service.GetDocumentHeadsRequest.
 * Use `create(GetDocumentHeadsRequestSchema)` to create a new message.
 */
export declare const GetDocumentHeadsRequestSchema: GenMessage<GetDocumentHeadsRequest>;
/**
 * @generated from message dxos.echo.service.GetDocumentHeadsResponse
 */
export type GetDocumentHeadsResponse = Message<"dxos.echo.service.GetDocumentHeadsResponse"> & {
    /**
     * @generated from field: dxos.echo.service.DocHeadsList heads = 1;
     */
    heads?: DocHeadsList;
};
/**
 * Describes the message dxos.echo.service.GetDocumentHeadsResponse.
 * Use `create(GetDocumentHeadsResponseSchema)` to create a new message.
 */
export declare const GetDocumentHeadsResponseSchema: GenMessage<GetDocumentHeadsResponse>;
/**
 * @generated from message dxos.echo.service.WaitUntilHeadsReplicatedRequest
 */
export type WaitUntilHeadsReplicatedRequest = Message<"dxos.echo.service.WaitUntilHeadsReplicatedRequest"> & {
    /**
     * @generated from field: dxos.echo.service.DocHeadsList heads = 1;
     */
    heads?: DocHeadsList;
};
/**
 * Describes the message dxos.echo.service.WaitUntilHeadsReplicatedRequest.
 * Use `create(WaitUntilHeadsReplicatedRequestSchema)` to create a new message.
 */
export declare const WaitUntilHeadsReplicatedRequestSchema: GenMessage<WaitUntilHeadsReplicatedRequest>;
/**
 * @generated from message dxos.echo.service.ReIndexHeadsRequest
 */
export type ReIndexHeadsRequest = Message<"dxos.echo.service.ReIndexHeadsRequest"> & {
    /**
     * @generated from field: repeated string document_ids = 1;
     */
    documentIds: string[];
};
/**
 * Describes the message dxos.echo.service.ReIndexHeadsRequest.
 * Use `create(ReIndexHeadsRequestSchema)` to create a new message.
 */
export declare const ReIndexHeadsRequestSchema: GenMessage<ReIndexHeadsRequest>;
/**
 * @generated from message dxos.echo.service.GetSpaceSyncStateRequest
 */
export type GetSpaceSyncStateRequest = Message<"dxos.echo.service.GetSpaceSyncStateRequest"> & {
    /**
     * @generated from field: string space_id = 1;
     */
    spaceId: string;
};
/**
 * Describes the message dxos.echo.service.GetSpaceSyncStateRequest.
 * Use `create(GetSpaceSyncStateRequestSchema)` to create a new message.
 */
export declare const GetSpaceSyncStateRequestSchema: GenMessage<GetSpaceSyncStateRequest>;
/**
 * @generated from message dxos.echo.service.SpaceSyncState
 */
export type SpaceSyncState = Message<"dxos.echo.service.SpaceSyncState"> & {
    /**
     * @generated from field: repeated dxos.echo.service.SpaceSyncState.PeerState peers = 1;
     */
    peers: SpaceSyncState_PeerState[];
};
/**
 * Describes the message dxos.echo.service.SpaceSyncState.
 * Use `create(SpaceSyncStateSchema)` to create a new message.
 */
export declare const SpaceSyncStateSchema: GenMessage<SpaceSyncState>;
/**
 * @generated from message dxos.echo.service.SpaceSyncState.PeerState
 */
export type SpaceSyncState_PeerState = Message<"dxos.echo.service.SpaceSyncState.PeerState"> & {
    /**
     * @generated from field: string peer_id = 1;
     */
    peerId: string;
    /**
     * *
     * Documents that are present locally but not on the remote peer.
     *
     * @generated from field: int32 missing_on_remote = 10;
     */
    missingOnRemote: number;
    /**
     * *
     * Documents that are present on the remote peer but not locally.
     *
     * @generated from field: int32 missing_on_local = 11;
     */
    missingOnLocal: number;
    /**
     * *
     * Documents that are present on both peers but have different heads.
     *
     * @generated from field: int32 different_documents = 12;
     */
    differentDocuments: number;
    /**
     * *
     * Total number of documents locally.
     *
     * @generated from field: int32 local_document_count = 13;
     */
    localDocumentCount: number;
    /**
     * *
     * Total number of documents on the remote peer.
     *
     * @generated from field: int32 remote_document_count = 14;
     */
    remoteDocumentCount: number;
};
/**
 * Describes the message dxos.echo.service.SpaceSyncState.PeerState.
 * Use `create(SpaceSyncState_PeerStateSchema)` to create a new message.
 */
export declare const SpaceSyncState_PeerStateSchema: GenMessage<SpaceSyncState_PeerState>;
/**
 * @generated from service dxos.echo.service.DataService
 */
export declare const DataService: GenService<{
    /**
     * *
     * Subscribe to incremental updates of multiple automerge socuments.
     * Which documents are subscribed to is defined in the `UpdateSubscription`.
     * Used to propagate changes from services to client.
     *
     * @generated from rpc dxos.echo.service.DataService.Subscribe
     */
    subscribe: {
        methodKind: "server_streaming";
        input: typeof SubscribeRequestSchema;
        output: typeof BatchedDocumentUpdatesSchema;
    };
    /**
     * *
     * Change which documents are subscribed to for specific subscription.
     *
     * @generated from rpc dxos.echo.service.DataService.UpdateSubscription
     */
    updateSubscription: {
        methodKind: "unary";
        input: typeof UpdateSubscriptionRequestSchema;
        output: typeof EmptySchema;
    };
    /**
     * *
     * Write incremental updates to multiple automerge documents.
     * Used to propagate changes from client to services.
     *
     * @generated from rpc dxos.echo.service.DataService.Update
     */
    update: {
        methodKind: "unary";
        input: typeof UpdateRequestSchema;
        output: typeof EmptySchema;
    };
    /**
     * @generated from rpc dxos.echo.service.DataService.Flush
     */
    flush: {
        methodKind: "unary";
        input: typeof FlushRequestSchema;
        output: typeof EmptySchema;
    };
    /**
     * @generated from rpc dxos.echo.service.DataService.GetDocumentHeads
     */
    getDocumentHeads: {
        methodKind: "unary";
        input: typeof GetDocumentHeadsRequestSchema;
        output: typeof GetDocumentHeadsResponseSchema;
    };
    /**
     * / Wait until the we have the specified changes on the worker locally. Does not take into account the index or client.
     *
     * @generated from rpc dxos.echo.service.DataService.WaitUntilHeadsReplicated
     */
    waitUntilHeadsReplicated: {
        methodKind: "unary";
        input: typeof WaitUntilHeadsReplicatedRequestSchema;
        output: typeof EmptySchema;
    };
    /**
     * / Update heads index for selected docuemnts.
     *
     * @generated from rpc dxos.echo.service.DataService.ReIndexHeads
     */
    reIndexHeads: {
        methodKind: "unary";
        input: typeof ReIndexHeadsRequestSchema;
        output: typeof EmptySchema;
    };
    /**
     * / Wait for any pending index updates.
     *
     * @generated from rpc dxos.echo.service.DataService.UpdateIndexes
     */
    updateIndexes: {
        methodKind: "unary";
        input: typeof EmptySchema;
        output: typeof EmptySchema;
    };
    /**
     * TODO(dmaretskyi): Stream subscription.
     *
     * @generated from rpc dxos.echo.service.DataService.SubscribeSpaceSyncState
     */
    subscribeSpaceSyncState: {
        methodKind: "server_streaming";
        input: typeof GetSpaceSyncStateRequestSchema;
        output: typeof SpaceSyncStateSchema;
    };
}>;
//# sourceMappingURL=service_pb.d.ts.map