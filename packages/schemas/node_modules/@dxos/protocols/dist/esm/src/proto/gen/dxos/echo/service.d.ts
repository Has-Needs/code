import type { Stream, RequestOptions } from "@dxos/codec-protobuf";
/**
 * Defined in:
 *   {@link file://./../../../dxos/echo/service.proto}
 */
export interface SubscribeRequest {
    subscriptionId: string;
    spaceId: string;
}
/**
 * Defined in:
 *   {@link file://./../../../dxos/echo/service.proto}
 */
export interface BatchedDocumentUpdates {
    updates?: DocumentUpdate[];
}
/**
 * Defined in:
 *   {@link file://./../../../dxos/echo/service.proto}
 */
export interface UpdateRequest {
    subscriptionId: string;
    updates?: DocumentUpdate[];
}
/**
 * Defined in:
 *   {@link file://./../../../dxos/echo/service.proto}
 */
export interface UpdateSubscriptionRequest {
    /**
     * Id of the subscription to update.
     * Subscription id is returned by `Subscribe` rpc.
     */
    subscriptionId: string;
    /**
     * Automerge document ids to subscribe for updates.
     * Used for already existing documents.
     * To add new document use `write` rpc.
     */
    addIds?: string[];
    /**
     * Automerge document ids to unsubscribe from.
     */
    removeIds?: string[];
}
/**
 * Defined in:
 *   {@link file://./../../../dxos/echo/service.proto}
 */
export interface FlushRequest {
    /**
     * Automerge specific document ids to wait to flush.
     */
    documentIds?: string[];
}
/**
 * Defined in:
 *   {@link file://./../../../dxos/echo/service.proto}
 */
export interface DocumentUpdate {
    /**
     * Automerge document id.
     */
    documentId: string;
    /**
     * Automerge document incremental update.
     * Value returned by `Automerge.saveSince()`.
     */
    mutation: Uint8Array;
    /**
     * Set to true for init mutation of document.
     * default: undefined.
     *
     * Options:
     *   - proto3_optional = true
     */
    isNew?: boolean;
}
/**
 * Defined in:
 *   {@link file://./../../../dxos/echo/service.proto}
 */
export interface DocHeadsList {
    entries?: DocHeadsList.Entry[];
}
export declare namespace DocHeadsList {
    /**
     * Defined in:
     *   {@link file://./../../../dxos/echo/service.proto}
     */
    interface Entry {
        documentId: string;
        heads?: string[];
    }
}
/**
 * Defined in:
 *   {@link file://./../../../dxos/echo/service.proto}
 */
export interface GetDocumentHeadsRequest {
    documentIds?: string[];
}
/**
 * Defined in:
 *   {@link file://./../../../dxos/echo/service.proto}
 */
export interface GetDocumentHeadsResponse {
    heads: DocHeadsList;
}
/**
 * Defined in:
 *   {@link file://./../../../dxos/echo/service.proto}
 */
export interface WaitUntilHeadsReplicatedRequest {
    heads: DocHeadsList;
}
/**
 * Defined in:
 *   {@link file://./../../../dxos/echo/service.proto}
 */
export interface ReIndexHeadsRequest {
    documentIds?: string[];
}
/**
 * Defined in:
 *   {@link file://./../../../dxos/echo/service.proto}
 */
export interface GetSpaceSyncStateRequest {
    spaceId: string;
}
/**
 * Defined in:
 *   {@link file://./../../../dxos/echo/service.proto}
 */
export interface SpaceSyncState {
    peers?: SpaceSyncState.PeerState[];
}
export declare namespace SpaceSyncState {
    /**
     * Defined in:
     *   {@link file://./../../../dxos/echo/service.proto}
     */
    interface PeerState {
        peerId: string;
        /**
         * Documents that are present locally but not on the remote peer.
         */
        missingOnRemote: number;
        /**
         * Documents that are present on the remote peer but not locally.
         */
        missingOnLocal: number;
        /**
         * Documents that are present on both peers but have different heads.
         */
        differentDocuments: number;
        /**
         * Total number of documents locally.
         */
        localDocumentCount: number;
        /**
         * Total number of documents on the remote peer.
         */
        remoteDocumentCount: number;
    }
}
/**
 * Defined in:
 *   {@link file://./../../../dxos/echo/service.proto}
 */
export interface DataService {
    /**
     * Subscribe to incremental updates of multiple automerge socuments.
     * Which documents are subscribed to is defined in the `UpdateSubscription`.
     * Used to propagate changes from services to client.
     */
    subscribe: (request: SubscribeRequest, options?: RequestOptions) => Stream<BatchedDocumentUpdates>;
    /**
     * Change which documents are subscribed to for specific subscription.
     */
    updateSubscription: (request: UpdateSubscriptionRequest, options?: RequestOptions) => Promise<void>;
    /**
     * Write incremental updates to multiple automerge documents.
     * Used to propagate changes from client to services.
     */
    update: (request: UpdateRequest, options?: RequestOptions) => Promise<void>;
    flush: (request: FlushRequest, options?: RequestOptions) => Promise<void>;
    getDocumentHeads: (request: GetDocumentHeadsRequest, options?: RequestOptions) => Promise<GetDocumentHeadsResponse>;
    /**
     * Wait until the we have the specified changes on the worker locally. Does not take into account the index or client.
     */
    waitUntilHeadsReplicated: (request: WaitUntilHeadsReplicatedRequest, options?: RequestOptions) => Promise<void>;
    /**
     * Update heads index for selected docuemnts.
     */
    reIndexHeads: (request: ReIndexHeadsRequest, options?: RequestOptions) => Promise<void>;
    /**
     * Wait for any pending index updates.
     */
    updateIndexes: (request: void, options?: RequestOptions) => Promise<void>;
    subscribeSpaceSyncState: (request: GetSpaceSyncStateRequest, options?: RequestOptions) => Stream<SpaceSyncState>;
}
//# sourceMappingURL=service.d.ts.map