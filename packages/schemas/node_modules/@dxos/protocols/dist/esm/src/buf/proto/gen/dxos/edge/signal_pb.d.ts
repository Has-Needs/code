import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import type { Any, Timestamp } from "@bufbuild/protobuf/wkt";
import type { PublicKey } from "../keys_pb.js";
import type { Peer } from "./messenger_pb.js";
import type { Message as Message$1 } from "@bufbuild/protobuf";
/**
 * Describes the file dxos/edge/signal.proto.
 */
export declare const file_dxos_edge_signal: GenFile;
/**
 * @generated from message dxos.edge.signal.JoinRequest
 */
export type JoinRequest = Message$1<"dxos.edge.signal.JoinRequest"> & {
    /**
     * @generated from field: dxos.keys.PublicKey topic = 1;
     */
    topic?: PublicKey;
    /**
     * @generated from field: dxos.edge.messenger.Peer peer = 2;
     */
    peer?: Peer;
};
/**
 * Describes the message dxos.edge.signal.JoinRequest.
 * Use `create(JoinRequestSchema)` to create a new message.
 */
export declare const JoinRequestSchema: GenMessage<JoinRequest>;
/**
 * @generated from message dxos.edge.signal.LeaveRequest
 */
export type LeaveRequest = Message$1<"dxos.edge.signal.LeaveRequest"> & {
    /**
     * @generated from field: dxos.keys.PublicKey topic = 1;
     */
    topic?: PublicKey;
    /**
     * @generated from field: dxos.edge.messenger.Peer peer = 2;
     */
    peer?: Peer;
};
/**
 * Describes the message dxos.edge.signal.LeaveRequest.
 * Use `create(LeaveRequestSchema)` to create a new message.
 */
export declare const LeaveRequestSchema: GenMessage<LeaveRequest>;
/**
 * @generated from message dxos.edge.signal.QueryRequest
 */
export type QueryRequest = Message$1<"dxos.edge.signal.QueryRequest"> & {
    /**
     * @generated from field: dxos.keys.PublicKey topic = 1;
     */
    topic?: PublicKey;
};
/**
 * Describes the message dxos.edge.signal.QueryRequest.
 * Use `create(QueryRequestSchema)` to create a new message.
 */
export declare const QueryRequestSchema: GenMessage<QueryRequest>;
/**
 * @generated from message dxos.edge.signal.Message
 */
export type Message = Message$1<"dxos.edge.signal.Message"> & {
    /**
     * @generated from field: dxos.edge.messenger.Peer author = 1;
     */
    author?: Peer;
    /**
     * @generated from field: dxos.edge.messenger.Peer recipient = 2;
     */
    recipient?: Peer;
    /**
     * @generated from field: google.protobuf.Any payload = 3;
     */
    payload?: Any;
};
/**
 * Describes the message dxos.edge.signal.Message.
 * Use `create(MessageSchema)` to create a new message.
 */
export declare const MessageSchema: GenMessage<Message>;
/**
 * / Goes on Pub/Sub swarm topic and as a Join stream in RPC.
 *
 * @generated from message dxos.edge.signal.SwarmEvent
 */
export type SwarmEvent = Message$1<"dxos.edge.signal.SwarmEvent"> & {
    /**
     * @generated from field: dxos.keys.PublicKey topic = 1;
     */
    topic?: PublicKey;
    /**
     * @generated from oneof dxos.edge.signal.SwarmEvent.event
     */
    event: {
        /**
         * / The peer was announced as available on the swarm.
         *
         * @generated from field: dxos.edge.signal.SwarmEvent.PeerAvailable peer_available = 2;
         */
        value: SwarmEvent_PeerAvailable;
        case: "peerAvailable";
    } | {
        /**
         * / The peer left, or their announcement timed out.
         *
         * @generated from field: dxos.edge.signal.SwarmEvent.PeerLeft peer_left = 3;
         */
        value: SwarmEvent_PeerLeft;
        case: "peerLeft";
    } | {
        case: undefined;
        value?: undefined;
    };
};
/**
 * Describes the message dxos.edge.signal.SwarmEvent.
 * Use `create(SwarmEventSchema)` to create a new message.
 */
export declare const SwarmEventSchema: GenMessage<SwarmEvent>;
/**
 * Announce peer available on swarm.
 *
 * @generated from message dxos.edge.signal.SwarmEvent.PeerAvailable
 */
export type SwarmEvent_PeerAvailable = Message$1<"dxos.edge.signal.SwarmEvent.PeerAvailable"> & {
    /**
     * @generated from field: dxos.edge.messenger.Peer peer = 1;
     */
    peer?: Peer;
    /**
     * @generated from field: google.protobuf.Timestamp since = 2;
     */
    since?: Timestamp;
    /**
     * When, if at all (handle the default value as not), this availability would expires were it not re-announced, like
     * periodically in Pub/Sub with some margin such that Pub/Sub network partitions lead to offline statuses.
     *
     * @generated from field: optional google.protobuf.Timestamp until = 3;
     */
    until?: Timestamp;
    /**
     * / Only relevant in Pub/Sub. Optional, the host topic to eagerly send PeerAvailable messages back to.
     *
     * @generated from field: optional bytes announce_back_to_host = 4;
     */
    announceBackToHost?: Uint8Array;
};
/**
 * Describes the message dxos.edge.signal.SwarmEvent.PeerAvailable.
 * Use `create(SwarmEvent_PeerAvailableSchema)` to create a new message.
 */
export declare const SwarmEvent_PeerAvailableSchema: GenMessage<SwarmEvent_PeerAvailable>;
/**
 * @generated from message dxos.edge.signal.SwarmEvent.PeerLeft
 */
export type SwarmEvent_PeerLeft = Message$1<"dxos.edge.signal.SwarmEvent.PeerLeft"> & {
    /**
     * @generated from field: dxos.edge.messenger.Peer peer = 1;
     */
    peer?: Peer;
};
/**
 * Describes the message dxos.edge.signal.SwarmEvent.PeerLeft.
 * Use `create(SwarmEvent_PeerLeftSchema)` to create a new message.
 */
export declare const SwarmEvent_PeerLeftSchema: GenMessage<SwarmEvent_PeerLeft>;
//# sourceMappingURL=signal_pb.d.ts.map