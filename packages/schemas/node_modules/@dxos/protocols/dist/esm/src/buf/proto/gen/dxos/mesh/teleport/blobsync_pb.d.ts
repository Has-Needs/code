import type { GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv1";
import type { EmptySchema } from "@bufbuild/protobuf/wkt";
import type { Message } from "@bufbuild/protobuf";
/**
 * Describes the file dxos/mesh/teleport/blobsync.proto.
 */
export declare const file_dxos_mesh_teleport_blobsync: GenFile;
/**
 * @generated from message dxos.mesh.teleport.blobsync.WantList
 */
export type WantList = Message<"dxos.mesh.teleport.blobsync.WantList"> & {
    /**
     * / Requested blobs. If bitfield is empty, all chunks are requested.
     *
     * @generated from field: repeated dxos.mesh.teleport.blobsync.WantList.Entry blobs = 1;
     */
    blobs: WantList_Entry[];
};
/**
 * Describes the message dxos.mesh.teleport.blobsync.WantList.
 * Use `create(WantListSchema)` to create a new message.
 */
export declare const WantListSchema: GenMessage<WantList>;
/**
 * @generated from message dxos.mesh.teleport.blobsync.WantList.Entry
 */
export type WantList_Entry = Message<"dxos.mesh.teleport.blobsync.WantList.Entry"> & {
    /**
     * @generated from field: bytes id = 1;
     */
    id: Uint8Array;
    /**
     * *
     * Size of chunk in bytes. Must be a power of 2. Default is 4096.
     * If chunk_size is missing, host will provide it.
     *
     * @generated from field: optional int32 chunk_size = 2;
     */
    chunkSize?: number;
    /**
     * *
     * Bitfield of requested chunks.
     * Every bit represents a chunk.
     * Chunks are indexed from MSB to LSB.
     *
     * If bitfield is missing, all chunks are requested.
     *
     * @generated from field: optional bytes bitfield = 3;
     */
    bitfield?: Uint8Array;
};
/**
 * Describes the message dxos.mesh.teleport.blobsync.WantList.Entry.
 * Use `create(WantList_EntrySchema)` to create a new message.
 */
export declare const WantList_EntrySchema: GenMessage<WantList_Entry>;
/**
 * @generated from message dxos.mesh.teleport.blobsync.BlobChunk
 */
export type BlobChunk = Message<"dxos.mesh.teleport.blobsync.BlobChunk"> & {
    /**
     * @generated from field: bytes id = 1;
     */
    id: Uint8Array;
    /**
     * / In bytes
     *
     * @generated from field: optional int32 chunk_size = 2;
     */
    chunkSize?: number;
    /**
     * / Offset from the start of blob in bytes.
     *
     * @generated from field: optional int32 chunk_offset = 3;
     */
    chunkOffset?: number;
    /**
     * / Total length of blob.
     *
     * @generated from field: optional int32 total_length = 4;
     */
    totalLength?: number;
    /**
     * @generated from field: bytes payload = 100;
     */
    payload: Uint8Array;
};
/**
 * Describes the message dxos.mesh.teleport.blobsync.BlobChunk.
 * Use `create(BlobChunkSchema)` to create a new message.
 */
export declare const BlobChunkSchema: GenMessage<BlobChunk>;
/**
 * *
 * Allows synchronization of opaque data objects between two peers.
 * Loosely based on Bittorrent protocol.
 *
 * @generated from service dxos.mesh.teleport.blobsync.BlobSyncService
 */
export declare const BlobSyncService: GenService<{
    /**
     * / Notify the peer that we want to receive specified objects.
     *
     * @generated from rpc dxos.mesh.teleport.blobsync.BlobSyncService.Want
     */
    want: {
        methodKind: "unary";
        input: typeof WantListSchema;
        output: typeof EmptySchema;
    };
    /**
     * / Send an object to the peer.
     *
     * @generated from rpc dxos.mesh.teleport.blobsync.BlobSyncService.Push
     */
    push: {
        methodKind: "unary";
        input: typeof BlobChunkSchema;
        output: typeof EmptySchema;
    };
}>;
//# sourceMappingURL=blobsync_pb.d.ts.map