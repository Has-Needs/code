import { Event } from '@dxos/async';
import { Context } from '@dxos/context';
import { type FeedWrapper, type FeedWriter } from '@dxos/feed-store';
import { PublicKey } from '@dxos/keys';
import { type FeedMessageBlock } from '@dxos/protocols';
import type { FeedMessage } from '@dxos/protocols/proto/dxos/echo/feed';
import { Timeframe } from '@dxos/timeframe';
import { ComplexMap } from '@dxos/util';
import { TimeframeClock } from './timeframe-clock';
export type WaitUntilReachedTargetParams = {
    /**
     * For cancellation.
     */
    ctx?: Context;
    timeout?: number;
    /**
     * @default true
     */
    breakOnStall?: boolean;
};
/**
 * External state accessor.
 */
export declare class PipelineState {
    private _feeds;
    private _timeframeClock;
    readonly timeframeUpdate: Event<Timeframe>;
    readonly stalled: Event<void>;
    /**
     * Target timeframe we are waiting to reach.
     */
    private _targetTimeframe;
    constructor(_feeds: ComplexMap<PublicKey, FeedWrapper<FeedMessage>>, _timeframeClock: TimeframeClock);
    /**
     * Latest theoretical timeframe based on the last mutation in each feed.
     * NOTE: This might never be reached if the mutation dependencies
     */
    get endTimeframe(): Timeframe;
    get startTimeframe(): Timeframe;
    get timeframe(): Timeframe;
    get pendingTimeframe(): Timeframe;
    get targetTimeframe(): Timeframe;
    get reachedTarget(): boolean;
    get feeds(): FeedWrapper<FeedMessage>[];
    waitUntilTimeframe(target: Timeframe): Promise<void>;
    setTargetTimeframe(target: Timeframe): void;
    /**
     * Wait until the pipeline processes all messages in the feed and reaches the target timeframe if that is set.
     *
     * This function will resolve immediately if the pipeline is stalled.
     *
     * @param timeout Timeout in milliseconds to specify the maximum wait time.
     */
    waitUntilReachedTargetTimeframe({ ctx, timeout, breakOnStall, }?: WaitUntilReachedTargetParams): Promise<void>;
}
export interface PipelineAccessor {
    state: PipelineState;
    writer: FeedWriter<FeedMessage.Payload>;
}
/**
 * A multi-reader pipeline that operates on feeds.
 * Might have a single writable feed.
 * Has a timeframe clock to handle message ordering.
 *
 * NOTE:
 *  - Feeds passed in must have value encoding consistent with the type expected by the iterator/writer.
 *
 * # Usage examples
 *
 * ## Create a new space.
 *
 * 1. Generate space key, genesis feed key.
 * 2. Create and open pipeline reading from {}.
 * 3. Create and add the writable genesis feed.
 * 4. Write the initial sequence of control and credential messages.
 *
 * ## Load an existing space from storage
 *
 * 1. Load space key, genesis feed key, get starting timeframe from saved snapshot.
 * 2. Create and open pipeline reading from the initial timeframe.
 * 3. Open and add the genesis feed.
 * 4. Once the writable feed is added, the pipeline becomes writable.
 *
 * ## Join an existing space created by another agent/device.
 *
 * 1. Get the space key, genesis feed key from another agent.
 * 2. (optionally) Download the snapshot from another agent.
 * 3. Create and open pipeline.
 * 4. Generate the writable feed key.
 * 5. Wait for the writable feed to be added.
 */
export declare class Pipeline implements PipelineAccessor {
    private readonly _timeframeClock;
    private readonly _feeds;
    private readonly _state;
    private readonly _processingTrigger;
    private readonly _pauseTrigger;
    private readonly _downloads;
    private _feedSetIterator?;
    private _writer;
    private _isStopping;
    private _isStarted;
    private _isBeingConsumed;
    private _isPaused;
    get state(): PipelineState;
    get writer(): FeedWriter<FeedMessage.Payload>;
    hasFeed(feedKey: PublicKey): boolean;
    getFeeds(): FeedWrapper<FeedMessage>[];
    addFeed(feed: FeedWrapper<FeedMessage>): Promise<void>;
    setWriteFeed(feed: FeedWrapper<FeedMessage>): void;
    start(): Promise<void>;
    stop(): Promise<void>;
    /**
     * @param timeframe Timeframe of already processed messages.
     *  The pipeline will start processing messages AFTER this timeframe.
     */
    setCursor(timeframe: Timeframe): Promise<void>;
    /**
     * Calling pause while processing will cause a deadlock.
     */
    pause(): Promise<void>;
    unpause(): Promise<void>;
    /**
     * Starts to iterate over the ordered messages from the added feeds.
     * Updates the timeframe clock after the message has bee processed.
     */
    consume(): AsyncIterable<FeedMessageBlock>;
    private _setFeedDownloadState;
    private _initIterator;
}
//# sourceMappingURL=pipeline.d.ts.map