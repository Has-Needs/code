import { Context, Resource } from '@dxos/context';
import { type QueryAST } from '@dxos/echo-protocol';
import { type Indexer } from '@dxos/indexing';
import { type QueryReactivity, type QueryResult } from '@dxos/protocols/proto/dxos/echo/query';
import type { QueryPlan } from './plan';
import type { AutomergeHost } from '../automerge';
import type { SpaceStateManager } from '../db-host';
type QueryExecutorOptions = {
    indexer: Indexer;
    automergeHost: AutomergeHost;
    spaceStateManager: SpaceStateManager;
    queryId: string;
    query: QueryAST.Query;
    reactivity: QueryReactivity;
};
type QueryExecutionResult = {
    /**
     * Whether the query results have changed since the last execution.
     */
    changed: boolean;
};
/**
 * Recursive data structure that represents the execution trace of a query.
 */
export type ExecutionTrace = {
    name: string;
    details: string;
    objectCount: number;
    documentsLoaded: number;
    indexHits: number;
    executionTime: number;
    indexQueryTime: number;
    documentLoadTime: number;
    children: ExecutionTrace[];
};
export declare const ExecutionTrace: Readonly<{
    makeEmpty: () => ExecutionTrace;
    format: (trace: ExecutionTrace) => string;
}>;
/**
 * Executes query plans against the Indexer and AutomergeHost.
 *
 * The QueryExecutor is responsible for:
 * - Executing query plans step by step
 * - Managing the working set of query results
 * - Loading documents from the database
 * - Tracking execution performance metrics
 * - Handling different types of query operations (select, filter, traverse, etc.)
 */
export declare class QueryExecutor extends Resource {
    private readonly _indexer;
    private readonly _automergeHost;
    private readonly _spaceStateManager;
    /**
     * Id of this query.
     */
    private readonly _id;
    private readonly _query;
    private readonly _reactivity;
    private _plan;
    private _trace;
    private _lastResultSet;
    constructor(options: QueryExecutorOptions);
    get query(): QueryAST.Query;
    get plan(): QueryPlan.Plan;
    get trace(): ExecutionTrace;
    protected _open(ctx: Context): Promise<void>;
    protected _close(ctx: Context): Promise<void>;
    getResults(): QueryResult[];
    execQuery(): Promise<QueryExecutionResult>;
    private _execPlan;
    private _execStep;
    private _execSelectStep;
    private _execFilterStep;
    private _execFilterDeletedStep;
    private _execTraverseStep;
    private _execUnionStep;
    private _execSetDifferenceStep;
    private _loadDocumentsAfterIndexQuery;
    private _loadFromIndexHit;
    private _loadFromDXN;
}
export {};
//# sourceMappingURL=query-executor.d.ts.map