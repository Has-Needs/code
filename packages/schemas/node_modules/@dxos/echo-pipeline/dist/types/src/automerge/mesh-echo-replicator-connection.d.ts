import { Resource } from '@dxos/context';
import { type PublicKey } from '@dxos/keys';
import type { AutomergeProtocolMessage } from '@dxos/protocols';
import { AutomergeReplicator, type AutomergeReplicatorFactory } from '@dxos/teleport-extension-automerge-replicator';
import type { ReplicatorConnection, ShouldAdvertiseParams, ShouldSyncCollectionParams } from './echo-replicator';
export type MeshReplicatorConnectionParams = {
    ownPeerId: string;
    onRemoteConnected: () => void;
    onRemoteDisconnected: () => void;
    shouldAdvertise: (params: ShouldAdvertiseParams) => Promise<boolean>;
    shouldSyncCollection: (params: ShouldSyncCollectionParams) => boolean;
    replicatorFactory?: AutomergeReplicatorFactory;
};
export declare class MeshReplicatorConnection extends Resource implements ReplicatorConnection {
    private readonly _params;
    readable: ReadableStream<AutomergeProtocolMessage>;
    writable: WritableStream<AutomergeProtocolMessage>;
    remoteDeviceKey: PublicKey | null;
    readonly replicatorExtension: AutomergeReplicator;
    private _remotePeerId;
    private _isEnabled;
    constructor(_params: MeshReplicatorConnectionParams);
    private _disconnectIfEnabled;
    get peerId(): string;
    get isEnabled(): boolean;
    shouldAdvertise(params: ShouldAdvertiseParams): Promise<boolean>;
    shouldSyncCollection(params: ShouldSyncCollectionParams): boolean;
    /**
     * Start exchanging messages with the remote peer.
     * Call after the remote peer has connected.
     */
    enable(): void;
    /**
     * Stop exchanging messages with the remote peer.
     */
    disable(): void;
}
//# sourceMappingURL=mesh-echo-replicator-connection.d.ts.map