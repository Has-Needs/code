import { type Doc, type Heads } from '@automerge/automerge';
import { Repo, type AnyDocumentId, type DocHandle, type DocumentId, type PeerId } from '@automerge/automerge-repo';
import { Event } from '@dxos/async';
import { Context, Resource } from '@dxos/context';
import { type CollectionId } from '@dxos/echo-protocol';
import { type IndexMetadataStore } from '@dxos/indexing';
import { PublicKey } from '@dxos/keys';
import { type LevelDB } from '@dxos/kv-store';
import { type DocHeadsList, type FlushRequest } from '@dxos/protocols/proto/dxos/echo/service';
import { type CollectionState } from './collection-synchronizer';
import { type EchoDataMonitor } from './echo-data-monitor';
import { type EchoReplicator } from './echo-replicator';
export type PeerIdProvider = () => string | undefined;
export type RootDocumentSpaceKeyProvider = (documentId: string) => PublicKey | undefined;
export type AutomergeHostParams = {
    db: LevelDB;
    indexMetadataStore: IndexMetadataStore;
    dataMonitor?: EchoDataMonitor;
    /**
     * Used for creating stable ids. A random key is generated on open, if no value is provided.
     */
    peerIdProvider?: PeerIdProvider;
    getSpaceKeyByRootDocumentId?: RootDocumentSpaceKeyProvider;
};
export type LoadDocOptions = {
    timeout?: number;
};
export type CreateDocOptions = {
    /**
     * Import the document together with its history.
     */
    preserveHistory?: boolean;
};
export declare const FIND_PARAMS: {
    allowableStates: ("requesting" | "ready")[];
};
/**
 * Abstracts over the AutomergeRepo.
 */
export declare class AutomergeHost extends Resource {
    private readonly _db;
    private readonly _indexMetadataStore;
    private readonly _echoNetworkAdapter;
    private readonly _collectionSynchronizer;
    private _repo;
    private _storage;
    private readonly _headsStore;
    private _peerId;
    private readonly _peerIdProvider?;
    private readonly _getSpaceKeyByRootDocumentId?;
    readonly collectionStateUpdated: Event<{
        collectionId: CollectionId;
    }>;
    /**
     * Fired after a batch of documents was saved to disk.
     */
    readonly documentsSaved: Event<void>;
    constructor({ db, indexMetadataStore, dataMonitor, peerIdProvider, getSpaceKeyByRootDocumentId, }: AutomergeHostParams);
    protected _open(): Promise<void>;
    protected _close(): Promise<void>;
    /**
     * @deprecated To be abstracted away.
     */
    get repo(): Repo;
    get peerId(): PeerId;
    get loadedDocsCount(): number;
    addReplicator(replicator: EchoReplicator): Promise<void>;
    removeReplicator(replicator: EchoReplicator): Promise<void>;
    /**
     * Loads the document handle from the repo and waits for it to be ready.
     */
    loadDoc<T>(ctx: Context, documentId: AnyDocumentId, opts?: LoadDocOptions): Promise<DocHandle<T>>;
    exportDoc(ctx: Context, id: AnyDocumentId): Promise<Uint8Array>;
    /**
     * Create new persisted document.
     */
    createDoc<T>(initialValue?: T | Doc<T> | Uint8Array, opts?: CreateDocOptions): DocHandle<T>;
    waitUntilHeadsReplicated(heads: DocHeadsList): Promise<void>;
    reIndexHeads(documentIds: DocumentId[]): Promise<void>;
    private _sharePolicy;
    private _beforeSave;
    private _shouldSyncCollection;
    /**
     * Called by AutomergeStorageAdapter after levelDB batch commit.
     */
    private _afterSave;
    private _automergePeers;
    private _isDocumentInRemoteCollection;
    private _getContainingSpaceForDocument;
    /**
     * Flush documents to disk.
     */
    flush({ documentIds }?: FlushRequest): Promise<void>;
    getHeads(documentIds: DocumentId[]): Promise<(Heads | undefined)[]>;
    getLocalCollectionState(collectionId: string): CollectionState | undefined;
    getRemoteCollectionStates(collectionId: string): ReadonlyMap<PeerId, CollectionState>;
    refreshCollection(collectionId: string): void;
    getCollectionSyncState(collectionId: string): Promise<CollectionSyncState>;
    /**
     * Update the local collection state based on the locally stored document heads.
     */
    updateLocalCollectionState(collectionId: string, documentIds: DocumentId[]): Promise<void>;
    clearLocalCollectionState(collectionId: string): Promise<void>;
    private _onCollectionStateQueried;
    private _onCollectionStateReceived;
    private _queryCollectionState;
    private _sendCollectionState;
    private _onPeerConnected;
    private _onPeerDisconnected;
    private _onRemoteCollectionStateUpdated;
    private _onHeadsChanged;
}
export type CollectionSyncState = {
    peers: PeerSyncState[];
};
export type PeerSyncState = {
    peerId: PeerId;
    /**
     * Documents that are present locally but not on the remote peer.
     */
    missingOnRemote: number;
    /**
     * Documents that are present on the remote peer but not locally.
     */
    missingOnLocal: number;
    /**
     * Documents that are present on both peers but have different heads.
     */
    differentDocuments: number;
    /**
     * Total number of documents locally.
     */
    localDocumentCount: number;
    /**
     * Total number of documents on the remote peer.
     */
    remoteDocumentCount: number;
};
//# sourceMappingURL=automerge-host.d.ts.map