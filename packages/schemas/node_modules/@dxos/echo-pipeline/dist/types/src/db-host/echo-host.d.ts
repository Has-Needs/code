import { type AnyDocumentId, type AutomergeUrl, type DocHandle, type DocumentId, type Repo } from '@automerge/automerge-repo';
import { Resource, type Context } from '@dxos/context';
import { type PublicKey, type SpaceId } from '@dxos/keys';
import { type LevelDB } from '@dxos/kv-store';
import { DataServiceImpl } from './data-service';
import { type DatabaseRoot } from './database-root';
import { QueryServiceImpl } from './query-service';
import { type LoadDocOptions, type CreateDocOptions, type EchoReplicator, type EchoDataStats, type PeerIdProvider, type RootDocumentSpaceKeyProvider } from '../automerge';
export interface EchoHostIndexingConfig {
    /**
     * @default true
     */
    fullText: boolean;
    /**
     * @default false
     */
    vector: boolean;
}
export type EchoHostParams = {
    kv: LevelDB;
    peerIdProvider?: PeerIdProvider;
    getSpaceKeyByRootDocumentId?: RootDocumentSpaceKeyProvider;
    indexing?: Partial<EchoHostIndexingConfig>;
};
/**
 * Host for the Echo database.
 * Manages multiple spaces.
 * Stores data to disk.
 * Can sync with pluggable data replicators.
 */
export declare class EchoHost extends Resource {
    private readonly _indexMetadataStore;
    private readonly _indexer;
    private readonly _automergeHost;
    private readonly _queryService;
    private readonly _dataService;
    private readonly _spaceStateManager;
    private readonly _echoDataMonitor;
    constructor({ kv, indexing, peerIdProvider, getSpaceKeyByRootDocumentId }: EchoHostParams);
    get queryService(): QueryServiceImpl;
    get dataService(): DataServiceImpl;
    /**
     * @deprecated To be abstracted away.
     */
    get automergeRepo(): Repo;
    get roots(): ReadonlyMap<DocumentId, DatabaseRoot>;
    protected _open(ctx: Context): Promise<void>;
    protected _close(ctx: Context): Promise<void>;
    /**
     * Flush all pending writes to the underlying storage.
     */
    flush(): Promise<void>;
    /**
     * Perform any pending index updates.
     */
    updateIndexes(): Promise<void>;
    /**
     * Loads the document handle from the repo and waits for it to be ready.
     */
    loadDoc<T>(ctx: Context, documentId: AnyDocumentId, opts?: LoadDocOptions): Promise<DocHandle<T>>;
    exportDoc(ctx: Context, id: AnyDocumentId): Promise<Uint8Array>;
    /**
     * Create new persisted document.
     */
    createDoc<T>(initialValue?: T, opts?: CreateDocOptions): DocHandle<T>;
    /**
     * Create new space root.
     */
    createSpaceRoot(spaceKey: PublicKey): Promise<DatabaseRoot>;
    openSpaceRoot(spaceId: SpaceId, automergeUrl: AutomergeUrl): Promise<DatabaseRoot>;
    closeSpaceRoot(automergeUrl: AutomergeUrl): Promise<void>;
    /**
     * Install data replicator.
     */
    addReplicator(replicator: EchoReplicator): Promise<void>;
    /**
     * Remove data replicator.
     */
    removeReplicator(replicator: EchoReplicator): Promise<void>;
}
export type { EchoDataStats };
export type EchoStatsDiagnostic = {
    loadedDocsCount: number;
    dataStats: EchoDataStats;
};
//# sourceMappingURL=echo-host.d.ts.map