{
  "version": 3,
  "sources": ["../../../src/db-host/data-service.ts", "../../../src/db-host/documents-synchronizer.ts", "../../../src/automerge/automerge-host.ts", "../../../src/automerge/collection-synchronizer.ts", "../../../src/automerge/echo-network-adapter.ts", "../../../src/automerge/network-protocol.ts", "../../../src/automerge/heads-store.ts", "../../../src/automerge/leveldb-storage-adapter.ts", "../../../src/automerge/mesh-echo-replicator.ts", "../../../src/automerge/mesh-echo-replicator-connection.ts", "../../../src/automerge/space-collection.ts", "../../../src/automerge/echo-data-monitor.ts", "../../../src/db-host/echo-host.ts", "../../../src/db-host/documents-iterator.ts", "../../../src/db-host/query-service.ts", "../../../src/query/query-executor.ts", "../../../src/query/query-planner.ts", "../../../src/query/errors.ts", "../../../src/query/plan.ts", "../../../src/db-host/space-state-manager.ts", "../../../src/db-host/database-root.ts", "../../../src/db-host/automerge-metrics.ts", "../../../src/edge/echo-edge-replicator.ts", "../../../src/edge/inflight-request-limiter.ts", "../../../src/util.ts"],
  "sourcesContent": ["//\n// Copyright 2021 DXOS.org\n//\n\nimport { type DocumentId } from '@automerge/automerge-repo';\n\nimport { UpdateScheduler } from '@dxos/async';\nimport { type RequestOptions } from '@dxos/codec-protobuf';\nimport { Stream } from '@dxos/codec-protobuf/stream';\nimport { invariant } from '@dxos/invariant';\nimport { SpaceId } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport {\n  type DataService,\n  type FlushRequest,\n  type SubscribeRequest,\n  type BatchedDocumentUpdates,\n  type UpdateSubscriptionRequest,\n  type GetDocumentHeadsRequest,\n  type GetDocumentHeadsResponse,\n  type ReIndexHeadsRequest,\n  type WaitUntilHeadsReplicatedRequest,\n  type UpdateRequest,\n  type GetSpaceSyncStateRequest,\n  type SpaceSyncState,\n} from '@dxos/protocols/proto/dxos/echo/service';\n\nimport { DocumentsSynchronizer } from './documents-synchronizer';\nimport { type SpaceStateManager } from './space-state-manager';\nimport { deriveCollectionIdFromSpaceId, type AutomergeHost } from '../automerge';\n\nexport type DataServiceParams = {\n  automergeHost: AutomergeHost;\n  spaceStateManager: SpaceStateManager;\n  updateIndexes: () => Promise<void>;\n};\n\n/**\n * Data sync between client and services.\n */\n// TODO(burdon): Move to client-services.\nexport class DataServiceImpl implements DataService {\n  /**\n   * Map of subscriptions.\n   * subscriptionId -> DocumentsSynchronizer\n   */\n  private readonly _subscriptions = new Map<string, DocumentsSynchronizer>();\n\n  private readonly _automergeHost: AutomergeHost;\n  private readonly _spaceStateManager: SpaceStateManager;\n  private readonly _updateIndexes: () => Promise<void>;\n\n  constructor(params: DataServiceParams) {\n    this._automergeHost = params.automergeHost;\n    this._spaceStateManager = params.spaceStateManager;\n    this._updateIndexes = params.updateIndexes;\n  }\n\n  subscribe(request: SubscribeRequest): Stream<BatchedDocumentUpdates> {\n    return new Stream<BatchedDocumentUpdates>(({ next, ready }) => {\n      const synchronizer = new DocumentsSynchronizer({\n        repo: this._automergeHost.repo,\n        sendUpdates: (updates) => next(updates),\n      });\n      synchronizer\n        .open()\n        .then(() => {\n          this._subscriptions.set(request.subscriptionId, synchronizer);\n          ready();\n        })\n        .catch((err) => log.catch(err));\n      return () => synchronizer.close();\n    });\n  }\n\n  async updateSubscription(request: UpdateSubscriptionRequest): Promise<void> {\n    const synchronizer = this._subscriptions.get(request.subscriptionId);\n    invariant(synchronizer, 'Subscription not found');\n\n    if (request.addIds?.length) {\n      await synchronizer.addDocuments(request.addIds as DocumentId[]);\n    }\n    if (request.removeIds?.length) {\n      await synchronizer.removeDocuments(request.removeIds as DocumentId[]);\n    }\n  }\n\n  async update(request: UpdateRequest): Promise<void> {\n    if (!request.updates) {\n      return;\n    }\n    const synchronizer = this._subscriptions.get(request.subscriptionId);\n    invariant(synchronizer, 'Subscription not found');\n\n    await synchronizer.update(request.updates);\n  }\n\n  async flush(request: FlushRequest): Promise<void> {\n    await this._automergeHost.flush(request);\n  }\n\n  async getDocumentHeads(request: GetDocumentHeadsRequest): Promise<GetDocumentHeadsResponse> {\n    const documentIds = request.documentIds;\n    if (!documentIds) {\n      return { heads: { entries: [] } };\n    }\n    const heads = await this._automergeHost.getHeads(documentIds as DocumentId[]);\n    return {\n      heads: {\n        entries: heads.map((heads, idx) => ({ documentId: documentIds[idx], heads })),\n      },\n    };\n  }\n\n  async waitUntilHeadsReplicated(\n    request: WaitUntilHeadsReplicatedRequest,\n    options?: RequestOptions | undefined,\n  ): Promise<void> {\n    await this._automergeHost.waitUntilHeadsReplicated(request.heads);\n  }\n\n  async reIndexHeads(request: ReIndexHeadsRequest, options?: RequestOptions): Promise<void> {\n    await this._automergeHost.reIndexHeads((request.documentIds ?? []) as DocumentId[]);\n  }\n\n  async updateIndexes(): Promise<void> {\n    await this._updateIndexes();\n  }\n\n  subscribeSpaceSyncState(request: GetSpaceSyncStateRequest): Stream<SpaceSyncState> {\n    return new Stream<SpaceSyncState>(({ ctx, next, ready }) => {\n      const spaceId = request.spaceId;\n      invariant(SpaceId.isValid(spaceId));\n\n      const rootDocumentId = this._spaceStateManager.getSpaceRootDocumentId(spaceId);\n      let collectionId = rootDocumentId && deriveCollectionIdFromSpaceId(spaceId, rootDocumentId);\n      this._spaceStateManager.spaceDocumentListUpdated.on(ctx, (event) => {\n        const newId = deriveCollectionIdFromSpaceId(spaceId, event.spaceRootId);\n        if (newId !== collectionId) {\n          collectionId = newId;\n          scheduler.trigger();\n        }\n      });\n\n      const scheduler = new UpdateScheduler(ctx, async () => {\n        const state = collectionId ? await this._automergeHost.getCollectionSyncState(collectionId) : { peers: [] };\n\n        next({\n          peers: state.peers.map((peer) => ({\n            peerId: peer.peerId,\n            missingOnRemote: peer.missingOnRemote,\n            missingOnLocal: peer.missingOnLocal,\n            differentDocuments: peer.differentDocuments,\n            localDocumentCount: peer.localDocumentCount,\n            remoteDocumentCount: peer.remoteDocumentCount,\n          })),\n        });\n      });\n\n      this._automergeHost.collectionStateUpdated.on(ctx, (e) => {\n        if (e.collectionId === collectionId) {\n          scheduler.trigger();\n        }\n      });\n      scheduler.trigger();\n    });\n  }\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { next as A, type Heads } from '@automerge/automerge';\nimport { type Repo, type DocHandle, type DocumentId } from '@automerge/automerge-repo';\n\nimport { UpdateScheduler } from '@dxos/async';\nimport { Resource } from '@dxos/context';\nimport { type DatabaseDirectory } from '@dxos/echo-protocol';\nimport { invariant } from '@dxos/invariant';\nimport { log } from '@dxos/log';\nimport { type BatchedDocumentUpdates, type DocumentUpdate } from '@dxos/protocols/proto/dxos/echo/service';\n\nimport { FIND_PARAMS } from '../automerge';\n\nconst MAX_UPDATE_FREQ = 10; // [updates/sec]\n\nexport type DocumentsSynchronizerParams = {\n  repo: Repo;\n  sendUpdates: (updates: BatchedDocumentUpdates) => void;\n};\n\ninterface DocSyncState {\n  handle: DocHandle<DatabaseDirectory>;\n  lastSentHead?: Heads;\n  clearSubscriptions?: () => void;\n}\n\n/**\n * Manages a connection and replication between worker's Automerge Repo and the client's Repo.\n */\nexport class DocumentsSynchronizer extends Resource {\n  private readonly _syncStates = new Map<DocumentId, DocSyncState>();\n  /**\n   * Documents that have pending updates.\n   * Used to batch updates.\n   */\n  private readonly _pendingUpdates = new Set<DocumentId>();\n\n  /**\n   * Job that schedules if there are pending updates.\n   */\n  private _sendUpdatesJob?: UpdateScheduler = undefined;\n\n  constructor(private readonly _params: DocumentsSynchronizerParams) {\n    super();\n  }\n\n  addDocuments(documentIds: DocumentId[], retryCounter = 0): void {\n    if (retryCounter > 3) {\n      log.warn('Failed to load document, retry limit reached', { documentIds });\n      return;\n    }\n\n    for (const documentId of documentIds) {\n      this._params.repo\n        .find<DatabaseDirectory>(documentId as DocumentId)\n        .then(async (doc) => {\n          await doc.whenReady();\n          this._startSync(doc);\n          this._pendingUpdates.add(doc.documentId);\n          this._sendUpdatesJob!.trigger();\n        })\n        .catch((error) => {\n          log.warn('Failed to load document, wraparound', { documentId, error });\n          this.addDocuments([documentId], retryCounter + 1);\n        });\n    }\n  }\n\n  removeDocuments(documentIds: DocumentId[]): void {\n    for (const documentId of documentIds) {\n      this._syncStates.get(documentId)?.clearSubscriptions?.();\n      this._syncStates.delete(documentId);\n      this._pendingUpdates.delete(documentId);\n    }\n  }\n\n  protected override async _open(): Promise<void> {\n    this._sendUpdatesJob = new UpdateScheduler(this._ctx, this._checkAndSendUpdates.bind(this), {\n      maxFrequency: MAX_UPDATE_FREQ,\n    });\n  }\n\n  protected override async _close(): Promise<void> {\n    await this._sendUpdatesJob!.join();\n    this._syncStates.clear();\n  }\n\n  async update(updates: DocumentUpdate[]): Promise<void> {\n    for (const { documentId, mutation, isNew } of updates) {\n      if (isNew) {\n        const doc = await this._params.repo.find<DatabaseDirectory>(documentId as DocumentId, FIND_PARAMS);\n        doc.update((doc) => A.loadIncremental(doc, mutation));\n        this._startSync(doc);\n      } else {\n        this._writeMutation(documentId as DocumentId, mutation);\n      }\n    }\n  }\n\n  private _startSync(doc: DocHandle<DatabaseDirectory>): void {\n    if (this._syncStates.has(doc.documentId)) {\n      log('Document already being synced', { documentId: doc.documentId });\n      return;\n    }\n\n    const syncState: DocSyncState = { handle: doc };\n    this._subscribeForChanges(syncState);\n    this._syncStates.set(doc.documentId, syncState);\n  }\n\n  _subscribeForChanges(syncState: DocSyncState): void {\n    const handler = () => {\n      this._pendingUpdates.add(syncState.handle.documentId);\n      this._sendUpdatesJob!.trigger();\n    };\n    syncState.handle.on('heads-changed', handler);\n    syncState.clearSubscriptions = () => syncState.handle.off('heads-changed', handler);\n  }\n\n  private async _checkAndSendUpdates(): Promise<void> {\n    const updates: DocumentUpdate[] = [];\n\n    const docsWithPendingUpdates = Array.from(this._pendingUpdates);\n    this._pendingUpdates.clear();\n\n    for (const documentId of docsWithPendingUpdates) {\n      const update = this._getPendingChanges(documentId);\n      if (update) {\n        updates.push({\n          documentId,\n          mutation: update,\n        });\n      }\n    }\n\n    if (updates.length > 0) {\n      this._params.sendUpdates({ updates });\n    }\n  }\n\n  private _getPendingChanges(documentId: DocumentId): Uint8Array | void {\n    const syncState = this._syncStates.get(documentId);\n    invariant(syncState, 'Sync state for document not found');\n    const handle = syncState.handle;\n    if (!handle || !handle.isReady() || !handle.doc()) {\n      return;\n    }\n    const doc = handle.doc();\n    const mutation = syncState.lastSentHead ? A.saveSince(doc, syncState.lastSentHead) : A.save(doc);\n    if (mutation.length === 0) {\n      return;\n    }\n    syncState.lastSentHead = A.getHeads(doc);\n    return mutation;\n  }\n\n  private _writeMutation(documentId: DocumentId, mutation: Uint8Array): void {\n    const syncState = this._syncStates.get(documentId);\n    invariant(syncState, 'Sync state for document not found');\n    syncState.handle.update((doc) => {\n      const headsBefore = A.getHeads(doc);\n      const newDoc = A.loadIncremental(doc, mutation);\n      if (A.equals(headsBefore, syncState.lastSentHead)) {\n        syncState.lastSentHead = A.getHeads(newDoc);\n      }\n      return newDoc;\n    });\n  }\n}\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport {\n  getBackend,\n  getHeads,\n  isAutomerge,\n  equals as headsEquals,\n  save,\n  type Doc,\n  type Heads,\n} from '@automerge/automerge';\nimport {\n  type DocHandleChangePayload,\n  Repo,\n  type AnyDocumentId,\n  type DocHandle,\n  type DocumentId,\n  type PeerCandidatePayload,\n  type PeerDisconnectedPayload,\n  type PeerId,\n  type StorageAdapterInterface,\n  type StorageKey,\n  interpretAsDocumentId,\n  type HandleState,\n} from '@automerge/automerge-repo';\n\nimport { Event, asyncTimeout } from '@dxos/async';\nimport { Context, Resource, cancelWithContext, type Lifecycle } from '@dxos/context';\nimport { DatabaseDirectory, type CollectionId } from '@dxos/echo-protocol';\nimport { type IndexMetadataStore } from '@dxos/indexing';\nimport { invariant } from '@dxos/invariant';\nimport { PublicKey } from '@dxos/keys';\nimport { type LevelDB } from '@dxos/kv-store';\nimport { log } from '@dxos/log';\nimport { objectPointerCodec } from '@dxos/protocols';\nimport { type DocHeadsList, type FlushRequest } from '@dxos/protocols/proto/dxos/echo/service';\nimport { trace } from '@dxos/tracing';\nimport { bufferToArray } from '@dxos/util';\n\nimport { CollectionSynchronizer, diffCollectionState, type CollectionState } from './collection-synchronizer';\nimport { type EchoDataMonitor } from './echo-data-monitor';\nimport { EchoNetworkAdapter, isEchoPeerMetadata } from './echo-network-adapter';\nimport { type EchoReplicator, type RemoteDocumentExistenceCheckParams } from './echo-replicator';\nimport { HeadsStore } from './heads-store';\nimport { LevelDBStorageAdapter, type BeforeSaveParams } from './leveldb-storage-adapter';\n\nexport type PeerIdProvider = () => string | undefined;\n\nexport type RootDocumentSpaceKeyProvider = (documentId: string) => PublicKey | undefined;\n\nexport type AutomergeHostParams = {\n  db: LevelDB;\n\n  indexMetadataStore: IndexMetadataStore;\n  dataMonitor?: EchoDataMonitor;\n\n  /**\n   * Used for creating stable ids. A random key is generated on open, if no value is provided.\n   */\n  peerIdProvider?: PeerIdProvider;\n  getSpaceKeyByRootDocumentId?: RootDocumentSpaceKeyProvider;\n};\n\nexport type LoadDocOptions = {\n  timeout?: number;\n};\n\nexport type CreateDocOptions = {\n  /**\n   * Import the document together with its history.\n   */\n  preserveHistory?: boolean;\n};\n\nexport const FIND_PARAMS = {\n  allowableStates: ['ready', 'requesting'] satisfies HandleState[],\n};\n\n/**\n * Abstracts over the AutomergeRepo.\n */\n@trace.resource()\nexport class AutomergeHost extends Resource {\n  private readonly _db: LevelDB;\n  private readonly _indexMetadataStore: IndexMetadataStore;\n  private readonly _echoNetworkAdapter: EchoNetworkAdapter;\n\n  private readonly _collectionSynchronizer = new CollectionSynchronizer({\n    queryCollectionState: this._queryCollectionState.bind(this),\n    sendCollectionState: this._sendCollectionState.bind(this),\n    shouldSyncCollection: this._shouldSyncCollection.bind(this),\n  });\n\n  private _repo!: Repo;\n  private _storage!: StorageAdapterInterface & Lifecycle;\n  private readonly _headsStore: HeadsStore;\n\n  @trace.info()\n  private _peerId!: PeerId;\n\n  private readonly _peerIdProvider?: PeerIdProvider;\n  private readonly _getSpaceKeyByRootDocumentId?: RootDocumentSpaceKeyProvider;\n\n  public readonly collectionStateUpdated = new Event<{ collectionId: CollectionId }>();\n\n  /**\n   * Fired after a batch of documents was saved to disk.\n   */\n  public readonly documentsSaved = new Event();\n\n  constructor({\n    db,\n    indexMetadataStore,\n    dataMonitor,\n    peerIdProvider,\n    getSpaceKeyByRootDocumentId,\n  }: AutomergeHostParams) {\n    super();\n    this._db = db;\n    this._storage = new LevelDBStorageAdapter({\n      db: db.sublevel('automerge'),\n      callbacks: {\n        beforeSave: async (params) => this._beforeSave(params),\n        afterSave: async (key) => this._afterSave(key),\n      },\n      monitor: dataMonitor,\n    });\n    this._echoNetworkAdapter = new EchoNetworkAdapter({\n      getContainingSpaceForDocument: this._getContainingSpaceForDocument.bind(this),\n      isDocumentInRemoteCollection: this._isDocumentInRemoteCollection.bind(this),\n      onCollectionStateQueried: this._onCollectionStateQueried.bind(this),\n      onCollectionStateReceived: this._onCollectionStateReceived.bind(this),\n      monitor: dataMonitor,\n    });\n    this._headsStore = new HeadsStore({ db: db.sublevel('heads') });\n    this._indexMetadataStore = indexMetadataStore;\n    this._peerIdProvider = peerIdProvider;\n    this._getSpaceKeyByRootDocumentId = getSpaceKeyByRootDocumentId;\n  }\n\n  protected override async _open(): Promise<void> {\n    this._peerId = `host-${this._peerIdProvider?.() ?? PublicKey.random().toHex()}` as PeerId;\n\n    await this._storage.open?.();\n\n    // Construct the automerge repo.\n    this._repo = new Repo({\n      peerId: this._peerId as PeerId,\n      sharePolicy: this._sharePolicy.bind(this),\n      storage: this._storage,\n      network: [\n        // Upstream swarm.\n        this._echoNetworkAdapter,\n      ],\n    });\n\n    let updatingAuthScope = false;\n    Event.wrap(this._echoNetworkAdapter, 'peer-candidate').on(\n      this._ctx,\n      ((e: PeerCandidatePayload) => !updatingAuthScope && this._onPeerConnected(e.peerId)) as any,\n    );\n    Event.wrap(this._echoNetworkAdapter, 'peer-disconnected').on(\n      this._ctx,\n      ((e: PeerDisconnectedPayload) => !updatingAuthScope && this._onPeerDisconnected(e.peerId)) as any,\n    );\n\n    this._collectionSynchronizer.remoteStateUpdated.on(this._ctx, ({ collectionId, peerId, newDocsAppeared }) => {\n      this._onRemoteCollectionStateUpdated(collectionId, peerId);\n      this.collectionStateUpdated.emit({ collectionId: collectionId as CollectionId });\n      // We use collection lookups during share policy check, so we might need to update share policy for the new doc\n      if (newDocsAppeared) {\n        updatingAuthScope = true;\n        try {\n          this._echoNetworkAdapter.onConnectionAuthScopeChanged(peerId);\n        } finally {\n          updatingAuthScope = false;\n        }\n      }\n    });\n\n    await this._echoNetworkAdapter.open();\n    await this._collectionSynchronizer.open();\n    await this._echoNetworkAdapter.open();\n    await this._echoNetworkAdapter.whenConnected();\n  }\n\n  protected override async _close(): Promise<void> {\n    await this._collectionSynchronizer.close();\n    await this._storage.close?.();\n    await this._echoNetworkAdapter.close();\n    await this._ctx.dispose();\n  }\n\n  /**\n   * @deprecated To be abstracted away.\n   */\n  get repo(): Repo {\n    return this._repo;\n  }\n\n  get peerId(): PeerId {\n    return this._peerId;\n  }\n\n  get loadedDocsCount(): number {\n    return Object.keys(this._repo.handles).length;\n  }\n\n  async addReplicator(replicator: EchoReplicator): Promise<void> {\n    await this._echoNetworkAdapter.addReplicator(replicator);\n  }\n\n  async removeReplicator(replicator: EchoReplicator): Promise<void> {\n    await this._echoNetworkAdapter.removeReplicator(replicator);\n  }\n\n  /**\n   * Loads the document handle from the repo and waits for it to be ready.\n   */\n  async loadDoc<T>(ctx: Context, documentId: AnyDocumentId, opts?: LoadDocOptions): Promise<DocHandle<T>> {\n    let handle: DocHandle<T> | undefined;\n    if (typeof documentId === 'string') {\n      // NOTE: documentId might also be a URL, in which case this lookup will fail.\n      handle = this._repo.handles[documentId as DocumentId];\n    }\n    if (!handle) {\n      handle = await this._repo.find(documentId as DocumentId, FIND_PARAMS);\n    }\n\n    // `whenReady` creates a timeout so we guard it with an if to skip it if the handle is already ready.\n    if (!handle.isReady()) {\n      if (!opts?.timeout) {\n        await cancelWithContext(ctx, handle.whenReady());\n      } else {\n        await cancelWithContext(ctx, asyncTimeout(handle.whenReady(), opts.timeout));\n      }\n    }\n\n    return handle;\n  }\n\n  async exportDoc(ctx: Context, id: AnyDocumentId): Promise<Uint8Array> {\n    const documentId = interpretAsDocumentId(id);\n\n    const chunks = await this._storage.loadRange([documentId]);\n    return bufferToArray(Buffer.concat(chunks.map((c) => c.data!)));\n  }\n\n  /**\n   * Create new persisted document.\n   */\n  createDoc<T>(initialValue?: T | Doc<T> | Uint8Array, opts?: CreateDocOptions): DocHandle<T> {\n    if (opts?.preserveHistory) {\n      if (initialValue instanceof Uint8Array) {\n        return this._repo.import(initialValue);\n      }\n\n      if (!isAutomerge(initialValue)) {\n        throw new TypeError('Initial value must be an Automerge document');\n      }\n\n      // TODO(dmaretskyi): There's a more efficient way.\n      return this._repo.import(save(initialValue as Doc<T>));\n    } else {\n      if (initialValue instanceof Uint8Array) {\n        throw new Error('Cannot create document from Uint8Array without preserving history');\n      }\n\n      return this._repo.create(initialValue);\n    }\n  }\n\n  async waitUntilHeadsReplicated(heads: DocHeadsList): Promise<void> {\n    const entries = heads.entries;\n    if (!entries?.length) {\n      return;\n    }\n    const documentIds = entries.map((entry) => entry.documentId as DocumentId);\n    const documentHeads = await this.getHeads(documentIds);\n    const headsToWait = entries.filter((entry, index) => {\n      const targetHeads = entry.heads;\n      if (!targetHeads || targetHeads.length === 0) {\n        return false;\n      }\n      const currentHeads = documentHeads[index];\n      return !(currentHeads !== null && headsEquals(currentHeads, targetHeads));\n    });\n    if (headsToWait.length > 0) {\n      await Promise.all(\n        headsToWait.map(async (entry, index) => {\n          const handle = await this.loadDoc<DatabaseDirectory>(Context.default(), entry.documentId as DocumentId);\n          await waitForHeads(handle, entry.heads!);\n        }),\n      );\n    }\n\n    // Flush to disk handles loaded to memory also so that the indexer can pick up the changes.\n    await this._repo.flush(\n      documentIds.filter((documentId) => this._repo.handles[documentId] && this._repo.handles[documentId].isReady()),\n    );\n  }\n\n  async reIndexHeads(documentIds: DocumentId[]): Promise<void> {\n    for (const documentId of documentIds) {\n      log('re-indexing heads for document', { documentId });\n      const handle = await this._repo.find(documentId, FIND_PARAMS);\n      if (!handle.isReady()) {\n        log.warn('document is not available locally, skipping', { documentId });\n        continue; // Handle not available locally.\n      }\n\n      const heads = handle.heads();\n      const batch = this._db.batch();\n      this._headsStore.setHeads(documentId, heads, batch);\n      await batch.write();\n    }\n    log('done re-indexing heads');\n  }\n\n  // TODO(dmaretskyi): Share based on HALO permissions and space affinity.\n  // Hosts, running in the worker, don't share documents unless requested by other peers.\n  // NOTE: If both peers return sharePolicy=false the replication will not happen\n  // https://github.com/automerge/automerge-repo/pull/292\n  private async _sharePolicy(peerId: PeerId, documentId?: DocumentId): Promise<boolean> {\n    if (peerId.startsWith('client-')) {\n      return false; // Only send docs to clients if they are requested.\n    }\n\n    if (!documentId) {\n      return false;\n    }\n\n    const peerMetadata = this.repo.peerMetadataByPeerId[peerId];\n    if (isEchoPeerMetadata(peerMetadata)) {\n      return this._echoNetworkAdapter.shouldAdvertise(peerId, { documentId });\n    }\n\n    return false;\n  }\n\n  private async _beforeSave({ path, batch }: BeforeSaveParams): Promise<void> {\n    const handle = this._repo.handles[path[0] as DocumentId];\n    if (!handle || !handle.isReady()) {\n      return;\n    }\n    const doc = handle.doc();\n    if (!doc) {\n      return;\n    }\n\n    const heads = getHeads(doc);\n    this._headsStore.setHeads(handle.documentId, heads, batch);\n\n    const spaceKey = DatabaseDirectory.getSpaceKey(doc) ?? undefined;\n    const objectIds = Object.keys(doc.objects ?? {});\n    const encodedIds = objectIds.map((objectId) =>\n      objectPointerCodec.encode({ documentId: handle.documentId, objectId, spaceKey }),\n    );\n    const idToLastHash = new Map(encodedIds.map((id) => [id, heads]));\n    this._indexMetadataStore.markDirty(idToLastHash, batch);\n  }\n\n  private _shouldSyncCollection(collectionId: string, peerId: PeerId): boolean {\n    const peerMetadata = this._repo.peerMetadataByPeerId[peerId];\n    if (isEchoPeerMetadata(peerMetadata)) {\n      return this._echoNetworkAdapter.shouldSyncCollection(peerId, { collectionId });\n    }\n\n    return false;\n  }\n\n  /**\n   * Called by AutomergeStorageAdapter after levelDB batch commit.\n   */\n  private async _afterSave(path: StorageKey): Promise<void> {\n    this._indexMetadataStore.notifyMarkedDirty();\n\n    const documentId = path[0] as DocumentId;\n    const document = this._repo.handles[documentId]?.doc();\n    if (document) {\n      const heads = getHeads(document);\n      this._onHeadsChanged(documentId, heads);\n    }\n    this.documentsSaved.emit();\n  }\n\n  @trace.info({ depth: null })\n  private _automergePeers(): PeerId[] {\n    return this._repo.peers;\n  }\n\n  private async _isDocumentInRemoteCollection(params: RemoteDocumentExistenceCheckParams): Promise<boolean> {\n    for (const collectionId of this._collectionSynchronizer.getRegisteredCollectionIds()) {\n      const remoteCollections = this._collectionSynchronizer.getRemoteCollectionStates(collectionId);\n      const remotePeerDocs = remoteCollections.get(params.peerId as PeerId)?.documents;\n      if (remotePeerDocs && params.documentId in remotePeerDocs) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private async _getContainingSpaceForDocument(documentId: string): Promise<PublicKey | null> {\n    const handle = this._repo.handles[documentId as any];\n    if (handle.state === 'loading') {\n      await handle.whenReady();\n    }\n    if (handle && handle.isReady() && handle.doc()) {\n      const spaceKeyHex = DatabaseDirectory.getSpaceKey(handle.doc());\n      if (spaceKeyHex) {\n        return PublicKey.from(spaceKeyHex);\n      }\n    }\n    /**\n     * Edge case on the initial space setup.\n     * A peer is maybe trying to share space root document with us after a successful invitation.\n     * We don't have a document to check access block locally, so we need to rely on external sources (space metada).\n     */\n    const rootDocSpaceKey = this._getSpaceKeyByRootDocumentId?.(documentId);\n    if (rootDocSpaceKey) {\n      return rootDocSpaceKey;\n    }\n\n    return null;\n  }\n\n  /**\n   * Flush documents to disk.\n   */\n  @trace.span({ showInBrowserTimeline: true })\n  async flush({ documentIds }: FlushRequest = {}): Promise<void> {\n    // Note: Sync protocol for client and services ensures that all handles should have all changes.\n\n    const loadedDocuments = documentIds?.filter((documentId): documentId is DocumentId => {\n      const handle = this._repo.handles[documentId as DocumentId];\n      return handle && handle.isReady();\n    });\n    await this._repo.flush(loadedDocuments);\n  }\n\n  async getHeads(documentIds: DocumentId[]): Promise<(Heads | undefined)[]> {\n    const result: (Heads | undefined)[] = [];\n    const storeRequestIds: DocumentId[] = [];\n    const storeResultIndices: number[] = [];\n    for (const documentId of documentIds) {\n      const handle = this._repo.handles[documentId];\n      if (handle && handle.isReady() && handle.doc()) {\n        result.push(getHeads(handle.doc()!));\n      } else {\n        storeRequestIds.push(documentId);\n        storeResultIndices.push(result.length);\n        result.push(undefined);\n      }\n    }\n    if (storeRequestIds.length > 0) {\n      const storedHeads = await this._headsStore.getHeads(storeRequestIds);\n      for (let i = 0; i < storedHeads.length; i++) {\n        result[storeResultIndices[i]] = storedHeads[i];\n      }\n    }\n    return result;\n  }\n\n  //\n  // Collection sync.\n  //\n\n  getLocalCollectionState(collectionId: string): CollectionState | undefined {\n    return this._collectionSynchronizer.getLocalCollectionState(collectionId);\n  }\n\n  getRemoteCollectionStates(collectionId: string): ReadonlyMap<PeerId, CollectionState> {\n    return this._collectionSynchronizer.getRemoteCollectionStates(collectionId);\n  }\n\n  refreshCollection(collectionId: string): void {\n    this._collectionSynchronizer.refreshCollection(collectionId);\n  }\n\n  async getCollectionSyncState(collectionId: string): Promise<CollectionSyncState> {\n    const result: CollectionSyncState = {\n      peers: [],\n    };\n\n    const localState = this.getLocalCollectionState(collectionId);\n    const remoteState = this.getRemoteCollectionStates(collectionId);\n\n    if (!localState) {\n      return result;\n    }\n\n    for (const [peerId, state] of remoteState) {\n      const diff = diffCollectionState(localState, state);\n      result.peers.push({\n        peerId,\n        missingOnRemote: diff.missingOnRemote.length,\n        missingOnLocal: diff.missingOnLocal.length,\n        differentDocuments: diff.different.length,\n        localDocumentCount: Object.keys(localState.documents).length,\n        remoteDocumentCount: Object.keys(state.documents).length,\n      });\n    }\n\n    return result;\n  }\n\n  /**\n   * Update the local collection state based on the locally stored document heads.\n   */\n  async updateLocalCollectionState(collectionId: string, documentIds: DocumentId[]): Promise<void> {\n    const heads = await this.getHeads(documentIds);\n    const documents: Record<DocumentId, Heads> = Object.fromEntries(\n      heads.map((heads, index) => [documentIds[index], heads ?? []]),\n    );\n    this._collectionSynchronizer.setLocalCollectionState(collectionId, { documents });\n  }\n\n  async clearLocalCollectionState(collectionId: string): Promise<void> {\n    this._collectionSynchronizer.clearLocalCollectionState(collectionId);\n  }\n\n  private _onCollectionStateQueried(collectionId: string, peerId: PeerId): void {\n    this._collectionSynchronizer.onCollectionStateQueried(collectionId, peerId);\n  }\n\n  private _onCollectionStateReceived(collectionId: string, peerId: PeerId, state: unknown): void {\n    this._collectionSynchronizer.onRemoteStateReceived(collectionId, peerId, decodeCollectionState(state));\n  }\n\n  private _queryCollectionState(collectionId: string, peerId: PeerId): void {\n    this._echoNetworkAdapter.queryCollectionState(collectionId, peerId);\n  }\n\n  private _sendCollectionState(collectionId: string, peerId: PeerId, state: CollectionState): void {\n    this._echoNetworkAdapter.sendCollectionState(collectionId, peerId, encodeCollectionState(state));\n  }\n\n  private _onPeerConnected(peerId: PeerId): void {\n    this._collectionSynchronizer.onConnectionOpen(peerId);\n  }\n\n  private _onPeerDisconnected(peerId: PeerId): void {\n    this._collectionSynchronizer.onConnectionClosed(peerId);\n  }\n\n  private _onRemoteCollectionStateUpdated(collectionId: string, peerId: PeerId): void {\n    const localState = this._collectionSynchronizer.getLocalCollectionState(collectionId);\n    const remoteState = this._collectionSynchronizer.getRemoteCollectionStates(collectionId).get(peerId);\n\n    if (!localState || !remoteState) {\n      return;\n    }\n\n    const { different, missingOnLocal, missingOnRemote } = diffCollectionState(localState, remoteState);\n    const toReplicate = [...missingOnLocal, ...missingOnRemote, ...different];\n\n    if (toReplicate.length === 0) {\n      return;\n    }\n\n    log('replicating documents after collection sync', {\n      collectionId,\n      peerId,\n      toReplicate,\n      count: toReplicate.length,\n    });\n\n    // Load the documents so they will start syncing.\n    for (const documentId of toReplicate) {\n      this._repo.findWithProgress(documentId);\n    }\n  }\n\n  private _onHeadsChanged(documentId: DocumentId, heads: Heads): void {\n    const collectionsChanged = new Set<CollectionId>();\n    for (const collectionId of this._collectionSynchronizer.getRegisteredCollectionIds()) {\n      const state = this._collectionSynchronizer.getLocalCollectionState(collectionId);\n      if (state?.documents[documentId]) {\n        const newState = structuredClone(state);\n        newState.documents[documentId] = heads;\n        this._collectionSynchronizer.setLocalCollectionState(collectionId, newState);\n        collectionsChanged.add(collectionId as CollectionId);\n      }\n    }\n    for (const collectionId of collectionsChanged) {\n      this.collectionStateUpdated.emit({ collectionId });\n    }\n  }\n}\n\nconst waitForHeads = async (handle: DocHandle<DatabaseDirectory>, heads: Heads) => {\n  const unavailableHeads = new Set(heads);\n\n  await handle.whenReady();\n  await Event.wrap<DocHandleChangePayload<DatabaseDirectory>>(handle, 'change').waitForCondition(() => {\n    // Check if unavailable heads became available.\n    for (const changeHash of unavailableHeads.values()) {\n      if (changeIsPresentInDoc(handle.doc()!, changeHash)) {\n        unavailableHeads.delete(changeHash);\n      }\n    }\n\n    return unavailableHeads.size === 0;\n  });\n};\n\nconst changeIsPresentInDoc = (doc: Doc<any>, changeHash: string): boolean => {\n  return !!getBackend(doc).getChangeByHash(changeHash);\n};\n\nconst decodeCollectionState = (state: unknown): CollectionState => {\n  invariant(typeof state === 'object' && state !== null, 'Invalid state');\n\n  return state as CollectionState;\n};\n\nconst encodeCollectionState = (state: CollectionState): unknown => {\n  return state;\n};\n\nexport type CollectionSyncState = {\n  peers: PeerSyncState[];\n};\n\nexport type PeerSyncState = {\n  peerId: PeerId;\n  /**\n   * Documents that are present locally but not on the remote peer.\n   */\n  missingOnRemote: number;\n\n  /**\n   * Documents that are present on the remote peer but not locally.\n   */\n  missingOnLocal: number;\n\n  /**\n   * Documents that are present on both peers but have different heads.\n   */\n  differentDocuments: number;\n\n  /**\n   * Total number of documents locally.\n   */\n  localDocumentCount: number;\n\n  /**\n   * Total number of documents on the remote peer.\n   */\n  remoteDocumentCount: number;\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { next as am } from '@automerge/automerge';\nimport type { DocumentId, PeerId } from '@automerge/automerge-repo';\n\nimport { asyncReturn, Event, scheduleTask, scheduleTaskInterval } from '@dxos/async';\nimport { Resource, type Context } from '@dxos/context';\nimport { log } from '@dxos/log';\nimport { trace } from '@dxos/tracing';\nimport { defaultMap } from '@dxos/util';\n\nconst MIN_QUERY_INTERVAL = 5_000;\n\nconst POLL_INTERVAL = 30_000;\n\nexport type CollectionSynchronizerParams = {\n  sendCollectionState: (collectionId: string, peerId: PeerId, state: CollectionState) => void;\n  queryCollectionState: (collectionId: string, peerId: PeerId) => void;\n  shouldSyncCollection: (collectionId: string, peerId: PeerId) => boolean;\n};\n\n/**\n * Implements collection sync protocol.\n */\n@trace.resource()\nexport class CollectionSynchronizer extends Resource {\n  private readonly _sendCollectionState: CollectionSynchronizerParams['sendCollectionState'];\n  private readonly _queryCollectionState: CollectionSynchronizerParams['queryCollectionState'];\n  private readonly _shouldSyncCollection: CollectionSynchronizerParams['shouldSyncCollection'];\n\n  /**\n   * CollectionId -> State.\n   */\n  private readonly _perCollectionStates = new Map<string, PerCollectionState>();\n  private readonly _activeCollections = new Set<string>();\n\n  private readonly _connectedPeers = new Set<PeerId>();\n\n  public readonly remoteStateUpdated = new Event<{ collectionId: string; peerId: PeerId; newDocsAppeared: boolean }>();\n\n  constructor(params: CollectionSynchronizerParams) {\n    super();\n    this._sendCollectionState = params.sendCollectionState;\n    this._queryCollectionState = params.queryCollectionState;\n    this._shouldSyncCollection = params.shouldSyncCollection;\n  }\n\n  protected override async _open(ctx: Context): Promise<void> {\n    scheduleTaskInterval(\n      this._ctx,\n      async () => {\n        for (const collectionId of this._perCollectionStates.keys()) {\n          if (this._activeCollections.has(collectionId)) {\n            this.refreshCollection(collectionId);\n            await asyncReturn();\n          }\n        }\n      },\n      POLL_INTERVAL,\n    );\n  }\n\n  getRegisteredCollectionIds(): string[] {\n    return [...this._activeCollections];\n  }\n\n  getLocalCollectionState(collectionId: string): CollectionState | undefined {\n    return this._perCollectionStates.get(collectionId)?.localState;\n  }\n\n  setLocalCollectionState(collectionId: string, state: CollectionState): void {\n    this._activeCollections.add(collectionId);\n\n    log('setLocalCollectionState', { collectionId, state });\n    this._getOrCreatePerCollectionState(collectionId).localState = state;\n\n    queueMicrotask(async () => {\n      if (!this._ctx.disposed && this._activeCollections.has(collectionId)) {\n        this._refreshInterestedPeers(collectionId);\n        this.refreshCollection(collectionId);\n      }\n    });\n  }\n\n  clearLocalCollectionState(collectionId: string): void {\n    this._activeCollections.delete(collectionId);\n    this._perCollectionStates.delete(collectionId);\n    log('clearLocalCollectionState', { collectionId });\n  }\n\n  getRemoteCollectionStates(collectionId: string): ReadonlyMap<PeerId, CollectionState> {\n    return this._getOrCreatePerCollectionState(collectionId).remoteStates;\n  }\n\n  refreshCollection(collectionId: string): void {\n    let scheduleAnotherRefresh = false;\n    const state = this._getOrCreatePerCollectionState(collectionId);\n    for (const peerId of this._connectedPeers) {\n      if (state.interestedPeers.has(peerId)) {\n        const lastQueried = state.lastQueried.get(peerId) ?? 0;\n        if (Date.now() - lastQueried > MIN_QUERY_INTERVAL) {\n          state.lastQueried.set(peerId, Date.now());\n          this._queryCollectionState(collectionId, peerId);\n        } else {\n          scheduleAnotherRefresh = true;\n        }\n      }\n    }\n    if (scheduleAnotherRefresh) {\n      scheduleTask(this._ctx, () => this.refreshCollection(collectionId), MIN_QUERY_INTERVAL);\n    }\n  }\n\n  /**\n   * Callback when a connection to a peer is established.\n   */\n  onConnectionOpen(peerId: PeerId): void {\n    const spanId = getSpanName(peerId);\n    trace.spanStart({\n      id: spanId,\n      methodName: spanId,\n      instance: this,\n      parentCtx: this._ctx,\n      showInBrowserTimeline: true,\n      attributes: { peerId },\n    });\n    this._connectedPeers.add(peerId);\n\n    queueMicrotask(async () => {\n      if (this._ctx.disposed) {\n        return;\n      }\n      for (const [collectionId, state] of this._perCollectionStates.entries()) {\n        if (this._activeCollections.has(collectionId) && this._shouldSyncCollection(collectionId, peerId)) {\n          state.interestedPeers.add(peerId);\n          state.lastQueried.set(peerId, Date.now());\n          this._queryCollectionState(collectionId, peerId);\n        }\n      }\n    });\n  }\n\n  /**\n   * Callback when a connection to a peer is closed.\n   */\n  onConnectionClosed(peerId: PeerId): void {\n    this._connectedPeers.delete(peerId);\n\n    for (const perCollectionState of this._perCollectionStates.values()) {\n      perCollectionState.remoteStates.delete(peerId);\n    }\n  }\n\n  /**\n   * Callback when a peer queries the state of a collection.\n   */\n  onCollectionStateQueried(collectionId: string, peerId: PeerId): void {\n    const perCollectionState = this._getOrCreatePerCollectionState(collectionId);\n\n    if (perCollectionState.localState) {\n      this._sendCollectionState(collectionId, peerId, perCollectionState.localState);\n    }\n  }\n\n  /**\n   * Callback when a peer sends the state of a collection.\n   */\n  onRemoteStateReceived(collectionId: string, peerId: PeerId, state: CollectionState): void {\n    log('onRemoteStateReceived', { collectionId, peerId, state });\n    validateCollectionState(state);\n    const perCollectionState = this._getOrCreatePerCollectionState(collectionId);\n    const existingState = perCollectionState.remoteStates.get(peerId) ?? { documents: {} };\n    const diff = diffCollectionState(existingState, state);\n    const spanId = getSpanName(peerId);\n    if (diff.different.length === 0) {\n      trace.spanEnd(spanId);\n    } else {\n      trace.spanStart({\n        id: spanId,\n        methodName: spanId,\n        instance: this,\n        parentCtx: this._ctx,\n        showInBrowserTimeline: true,\n        attributes: { peerId },\n      });\n    }\n    if (diff.missingOnLocal.length > 0 || diff.different.length > 0) {\n      perCollectionState.remoteStates.set(peerId, state);\n      this.remoteStateUpdated.emit({ peerId, collectionId, newDocsAppeared: diff.missingOnLocal.length > 0 });\n    }\n  }\n\n  private _getOrCreatePerCollectionState(collectionId: string): PerCollectionState {\n    return defaultMap(this._perCollectionStates, collectionId, () => ({\n      localState: undefined,\n      remoteStates: new Map(),\n      interestedPeers: new Set(),\n      lastQueried: new Map(),\n    }));\n  }\n\n  private _refreshInterestedPeers(collectionId: string): void {\n    for (const peerId of this._connectedPeers) {\n      if (this._shouldSyncCollection(collectionId, peerId)) {\n        this._getOrCreatePerCollectionState(collectionId).interestedPeers.add(peerId);\n      } else {\n        this._getOrCreatePerCollectionState(collectionId).interestedPeers.delete(peerId);\n      }\n    }\n  }\n}\n\ntype PerCollectionState = {\n  localState?: CollectionState;\n  remoteStates: Map<PeerId, CollectionState>;\n  interestedPeers: Set<PeerId>;\n  lastQueried: Map<PeerId, number>;\n};\n\nexport type CollectionState = {\n  /**\n   * DocumentId -> Heads.\n   */\n  documents: Record<string, string[]>;\n};\n\nexport type CollectionStateDiff = {\n  missingOnRemote: DocumentId[];\n  missingOnLocal: DocumentId[];\n  different: DocumentId[];\n};\n\nexport const diffCollectionState = (local: CollectionState, remote: CollectionState): CollectionStateDiff => {\n  const allDocuments = new Set<DocumentId>([...Object.keys(local.documents), ...Object.keys(remote.documents)] as any);\n\n  const missingOnRemote: DocumentId[] = [];\n  const missingOnLocal: DocumentId[] = [];\n  const different: DocumentId[] = [];\n  for (const documentId of allDocuments) {\n    if (!local.documents[documentId]) {\n      missingOnLocal.push(documentId as DocumentId);\n    } else if (!remote.documents[documentId]) {\n      missingOnRemote.push(documentId as DocumentId);\n    } else if (!am.equals(local.documents[documentId], remote.documents[documentId])) {\n      different.push(documentId as DocumentId);\n    }\n  }\n\n  return {\n    missingOnRemote,\n    missingOnLocal,\n    different,\n  };\n};\n\nconst validateCollectionState = (state: CollectionState) => {\n  Object.entries(state.documents).forEach(([documentId, heads]) => {\n    if (!isValidDocumentId(documentId as DocumentId)) {\n      throw new Error(`Invalid documentId: ${documentId}`);\n    }\n    if (Array.isArray(heads) && heads.some((head) => typeof head !== 'string')) {\n      throw new Error(`Invalid heads: ${heads}`);\n    }\n  });\n};\n\nconst isValidDocumentId = (documentId: DocumentId) => {\n  return typeof documentId === 'string' && !documentId.includes(':');\n};\n\nconst getSpanName = (peerId: PeerId) => {\n  return `collection-sync-${peerId}`;\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { NetworkAdapter, type Message, type PeerId, type PeerMetadata } from '@automerge/automerge-repo';\n\nimport { synchronized, Trigger } from '@dxos/async';\nimport { LifecycleState } from '@dxos/context';\nimport { invariant } from '@dxos/invariant';\nimport { type PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport type { AutomergeProtocolMessage } from '@dxos/protocols';\nimport { isNonNullable } from '@dxos/util';\n\nimport {\n  type EchoReplicator,\n  type RemoteDocumentExistenceCheckParams,\n  type ReplicatorConnection,\n  type ShouldAdvertiseParams,\n  type ShouldSyncCollectionParams,\n} from './echo-replicator';\nimport {\n  isCollectionQueryMessage,\n  isCollectionStateMessage,\n  type CollectionQueryMessage,\n  type CollectionStateMessage,\n} from './network-protocol';\nimport { createIdFromSpaceKey } from '../common/space-id';\n\nexport interface NetworkDataMonitor {\n  recordPeerConnected(peerId: string): void;\n  recordPeerDisconnected(peerId: string): void;\n  recordMessageSent(message: Message, duration: number): void;\n  recordMessageReceived(message: Message): void;\n  recordMessageSendingFailed(message: Message): void;\n}\n\nexport type EchoNetworkAdapterParams = {\n  getContainingSpaceForDocument: (documentId: string) => Promise<PublicKey | null>;\n  isDocumentInRemoteCollection: (params: RemoteDocumentExistenceCheckParams) => Promise<boolean>;\n  onCollectionStateQueried: (collectionId: string, peerId: PeerId) => void;\n  onCollectionStateReceived: (collectionId: string, peerId: PeerId, state: unknown) => void;\n  monitor?: NetworkDataMonitor;\n};\n\ntype ConnectionEntry = {\n  isOpen: boolean;\n  connection: ReplicatorConnection;\n  reader: ReadableStreamDefaultReader<AutomergeProtocolMessage>;\n  writer: WritableStreamDefaultWriter<AutomergeProtocolMessage>;\n};\n\n/**\n * Manages a set of {@link EchoReplicator} instances.\n */\nexport class EchoNetworkAdapter extends NetworkAdapter {\n  private readonly _replicators = new Set<EchoReplicator>();\n  /**\n   * Remote peer id -> connection.\n   */\n  private readonly _connections = new Map<PeerId, ConnectionEntry>();\n  private _lifecycleState: LifecycleState = LifecycleState.CLOSED;\n  private readonly _connected = new Trigger();\n  private readonly _ready = new Trigger();\n\n  constructor(private readonly _params: EchoNetworkAdapterParams) {\n    super();\n  }\n\n  override isReady(): boolean {\n    return this._lifecycleState === LifecycleState.OPEN;\n  }\n\n  override whenReady(): Promise<void> {\n    return this._ready.wait();\n  }\n\n  override connect(peerId: PeerId, peerMetadata?: PeerMetadata | undefined): void {\n    this.peerId = peerId;\n    this.peerMetadata = peerMetadata;\n    this._connected.wake();\n  }\n\n  override send(message: Message): void {\n    this._send(message);\n  }\n\n  override disconnect(): void {\n    // No-op\n  }\n\n  @synchronized\n  async open(): Promise<void> {\n    if (this._lifecycleState === LifecycleState.OPEN) {\n      return;\n    }\n    this._lifecycleState = LifecycleState.OPEN;\n    this._ready.wake();\n  }\n\n  @synchronized\n  async close(): Promise<this | undefined> {\n    if (this._lifecycleState === LifecycleState.CLOSED) {\n      return this;\n    }\n\n    for (const replicator of this._replicators) {\n      await replicator.disconnect();\n    }\n    this._replicators.clear();\n\n    this._ready.reset();\n    this._lifecycleState = LifecycleState.CLOSED;\n  }\n\n  async whenConnected(): Promise<void> {\n    await this._connected.wait({ timeout: 10_000 });\n  }\n\n  public onConnectionAuthScopeChanged(peer: PeerId): void {\n    const entry = this._connections.get(peer);\n    if (entry) {\n      this._onConnectionAuthScopeChanged(entry.connection);\n    }\n  }\n\n  @synchronized\n  async addReplicator(replicator: EchoReplicator): Promise<void> {\n    invariant(this._lifecycleState === LifecycleState.OPEN);\n    invariant(this.peerId);\n    invariant(!this._replicators.has(replicator));\n\n    this._replicators.add(replicator);\n    await replicator.connect({\n      peerId: this.peerId,\n      onConnectionOpen: this._onConnectionOpen.bind(this),\n      onConnectionClosed: this._onConnectionClosed.bind(this),\n      onConnectionAuthScopeChanged: this._onConnectionAuthScopeChanged.bind(this),\n      isDocumentInRemoteCollection: this._params.isDocumentInRemoteCollection,\n      getContainingSpaceForDocument: this._params.getContainingSpaceForDocument,\n      getContainingSpaceIdForDocument: async (documentId) => {\n        const key = await this._params.getContainingSpaceForDocument(documentId);\n        return key ? createIdFromSpaceKey(key) : null;\n      },\n    });\n  }\n\n  @synchronized\n  async removeReplicator(replicator: EchoReplicator): Promise<void> {\n    invariant(this._lifecycleState === LifecycleState.OPEN);\n    invariant(this._replicators.has(replicator));\n    await replicator.disconnect();\n    this._replicators.delete(replicator);\n  }\n\n  async shouldAdvertise(peerId: PeerId, params: ShouldAdvertiseParams): Promise<boolean> {\n    const connection = this._connections.get(peerId);\n    if (!connection) {\n      return false;\n    }\n\n    return connection.connection.shouldAdvertise(params);\n  }\n\n  shouldSyncCollection(peerId: PeerId, params: ShouldSyncCollectionParams): boolean {\n    const connection = this._connections.get(peerId);\n    if (!connection) {\n      return false;\n    }\n\n    return connection.connection.shouldSyncCollection(params);\n  }\n\n  queryCollectionState(collectionId: string, targetId: PeerId): void {\n    const message: CollectionQueryMessage = {\n      type: 'collection-query',\n      senderId: this.peerId as PeerId,\n      targetId,\n      collectionId,\n    };\n    this._send(message);\n  }\n\n  sendCollectionState(collectionId: string, targetId: PeerId, state: unknown): void {\n    const message: CollectionStateMessage = {\n      type: 'collection-state',\n      senderId: this.peerId as PeerId,\n      targetId,\n      collectionId,\n      state,\n    };\n    this._send(message);\n  }\n\n  // TODO(dmaretskyi): Remove.\n  getPeersInterestedInCollection(collectionId: string): PeerId[] {\n    return Array.from(this._connections.values())\n      .map((connection) => {\n        return connection.connection.shouldSyncCollection({ collectionId })\n          ? (connection.connection.peerId as PeerId)\n          : null;\n      })\n      .filter(isNonNullable);\n  }\n\n  private _send(message: Message): void {\n    const connectionEntry = this._connections.get(message.targetId);\n    if (!connectionEntry) {\n      throw new Error('Connection not found.');\n    }\n\n    // TODO(dmaretskyi): Find a way to enforce backpressure on AM-repo.\n    const start = Date.now();\n    connectionEntry.writer\n      .write(message as AutomergeProtocolMessage)\n      .then(() => {\n        this._params.monitor?.recordMessageSent(message, Date.now() - start);\n      })\n      .catch((err) => {\n        if (connectionEntry.isOpen) {\n          log.catch(err);\n        }\n\n        this._params.monitor?.recordMessageSendingFailed(message);\n      });\n  }\n\n  private _onConnectionOpen(connection: ReplicatorConnection): void {\n    log('connection opened', { peerId: connection.peerId });\n    invariant(!this._connections.has(connection.peerId as PeerId));\n    const connectionEntry: ConnectionEntry = {\n      isOpen: true,\n      connection,\n      reader: connection.readable.getReader(),\n      writer: connection.writable.getWriter(),\n    };\n\n    this._connections.set(connection.peerId as PeerId, connectionEntry);\n\n    // Read inbound messages.\n    queueMicrotask(async () => {\n      try {\n        while (true) {\n          // TODO(dmaretskyi): Find a way to enforce backpressure on AM-repo.\n          const { done, value } = await connectionEntry.reader.read();\n          if (done) {\n            break;\n          }\n\n          this._onMessage(value as Message);\n        }\n      } catch (err) {\n        if (connectionEntry.isOpen) {\n          log.catch(err);\n        }\n      }\n    });\n\n    log('emit peer-candidate', { peerId: connection.peerId });\n    this._emitPeerCandidate(connection);\n    this._params.monitor?.recordPeerConnected(connection.peerId);\n  }\n\n  private _onMessage(message: Message): void {\n    if (isCollectionQueryMessage(message)) {\n      this._params.onCollectionStateQueried(message.collectionId, message.senderId);\n    } else if (isCollectionStateMessage(message)) {\n      this._params.onCollectionStateReceived(message.collectionId, message.senderId, message.state);\n    } else {\n      this.emit('message', message);\n    }\n    this._params.monitor?.recordMessageReceived(message);\n  }\n\n  private _onConnectionClosed(connection: ReplicatorConnection): void {\n    log('connection closed', { peerId: connection.peerId });\n    const entry = this._connections.get(connection.peerId as PeerId);\n    invariant(entry);\n\n    entry.isOpen = false;\n    this.emit('peer-disconnected', { peerId: connection.peerId as PeerId });\n    this._params.monitor?.recordPeerDisconnected(connection.peerId);\n\n    void entry.reader.cancel().catch((err) => log.catch(err));\n    void entry.writer.abort().catch((err) => log.catch(err));\n    this._connections.delete(connection.peerId as PeerId);\n  }\n\n  /**\n   * Trigger doc-synchronizer shared documents set recalculation. Happens on peer-candidate.\n   * TODO(y): replace with a proper API call when sharePolicy update becomes supported by automerge-repo\n   */\n  private _onConnectionAuthScopeChanged(connection: ReplicatorConnection): void {\n    log('Connection auth scope changed', { peerId: connection.peerId });\n    const entry = this._connections.get(connection.peerId as PeerId);\n    invariant(entry);\n    this.emit('peer-disconnected', { peerId: connection.peerId as PeerId });\n    this._emitPeerCandidate(connection);\n  }\n\n  private _emitPeerCandidate(connection: ReplicatorConnection): void {\n    this.emit('peer-candidate', {\n      peerId: connection.peerId as PeerId,\n      peerMetadata: createEchoPeerMetadata(),\n    });\n  }\n}\n\nexport const createEchoPeerMetadata = (): PeerMetadata =>\n  ({\n    // TODO(dmaretskyi): Refactor this.\n    dxos_peerSource: 'EchoNetworkAdapter',\n  }) as any;\n\nexport const isEchoPeerMetadata = (metadata: PeerMetadata): boolean =>\n  (metadata as any)?.dxos_peerSource === 'EchoNetworkAdapter';\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport type { Message } from '@automerge/automerge-repo';\n\nimport {\n  type CollectionQueryMessage,\n  type CollectionStateMessage,\n  MESSAGE_TYPE_COLLECTION_QUERY,\n  MESSAGE_TYPE_COLLECTION_STATE,\n} from '@dxos/protocols';\n\nexport { type CollectionStateMessage, type CollectionQueryMessage };\n\nexport const isCollectionQueryMessage = (message: Message): message is CollectionQueryMessage =>\n  message.type === MESSAGE_TYPE_COLLECTION_QUERY;\n\nexport const isCollectionStateMessage = (message: Message): message is CollectionStateMessage =>\n  message.type === MESSAGE_TYPE_COLLECTION_STATE;\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport type { Heads } from '@automerge/automerge';\nimport type { DocumentId } from '@automerge/automerge-repo';\n\nimport { headsEncoding } from '@dxos/indexing';\nimport type { BatchLevel, SublevelDB } from '@dxos/kv-store';\n\nexport type HeadsStoreParams = {\n  db: SublevelDB;\n};\n\nexport class HeadsStore {\n  private readonly _db: SublevelDB;\n\n  constructor({ db }: HeadsStoreParams) {\n    this._db = db;\n  }\n\n  setHeads(documentId: DocumentId, heads: Heads, batch: BatchLevel): void {\n    batch.put<DocumentId, Heads>(documentId, heads, {\n      sublevel: this._db,\n      keyEncoding: 'utf8',\n      valueEncoding: headsEncoding,\n    });\n  }\n\n  // TODO(dmaretskyi): Make batched.\n  async getHeads(documentIds: DocumentId[]): Promise<Array<Heads | undefined>> {\n    return this._db.getMany<DocumentId, Heads>(documentIds, {\n      keyEncoding: 'utf8',\n      valueEncoding: headsEncoding,\n    });\n  }\n}\n", "//\n// Copyright 2024 DXOS.org\n// s\n\nimport { type StorageAdapterInterface, type Chunk, type StorageKey } from '@automerge/automerge-repo';\nimport { type MixedEncoding } from 'level-transcoder';\n\nimport { LifecycleState, Resource } from '@dxos/context';\nimport { type BatchLevel, type SublevelDB } from '@dxos/kv-store';\nimport { type MaybePromise } from '@dxos/util';\n\nexport interface StorageAdapterDataMonitor {\n  recordBytesStored(count: number): void;\n  recordBytesLoaded(count: number): void;\n  recordLoadDuration(durationMs: number): void;\n  recordStoreDuration(durationMs: number): void;\n}\n\nexport type LevelDBStorageAdapterParams = {\n  db: SublevelDB;\n  callbacks?: StorageCallbacks;\n  monitor?: StorageAdapterDataMonitor;\n};\n\nexport type BeforeSaveParams = { path: StorageKey; batch: BatchLevel };\n\nexport interface StorageCallbacks {\n  beforeSave(params: BeforeSaveParams): MaybePromise<void>;\n  afterSave(path: StorageKey): MaybePromise<void>;\n}\n\nexport class LevelDBStorageAdapter extends Resource implements StorageAdapterInterface {\n  constructor(private readonly _params: LevelDBStorageAdapterParams) {\n    super();\n  }\n\n  async load(keyArray: StorageKey): Promise<Uint8Array | undefined> {\n    try {\n      if (this._lifecycleState !== LifecycleState.OPEN) {\n        // TODO(mykola): this should be an error.\n        return undefined;\n      }\n      const startMs = Date.now();\n      const chunk = await this._params.db.get<StorageKey, Uint8Array>(keyArray, { ...encodingOptions });\n      this._params.monitor?.recordBytesLoaded(chunk.byteLength);\n      this._params.monitor?.recordLoadDuration(Date.now() - startMs);\n      return chunk;\n    } catch (err: any) {\n      if (isLevelDbNotFoundError(err)) {\n        return undefined;\n      }\n      throw err;\n    }\n  }\n\n  async save(keyArray: StorageKey, binary: Uint8Array): Promise<void> {\n    if (this._lifecycleState !== LifecycleState.OPEN) {\n      return undefined;\n    }\n    const startMs = Date.now();\n    const batch = this._params.db.batch();\n\n    await this._params.callbacks?.beforeSave?.({ path: keyArray, batch });\n    batch.put<StorageKey, Uint8Array>(keyArray, Buffer.from(binary), {\n      ...encodingOptions,\n    });\n    await batch.write();\n    this._params.monitor?.recordBytesStored(binary.byteLength);\n\n    await this._params.callbacks?.afterSave?.(keyArray);\n    this._params.monitor?.recordStoreDuration(Date.now() - startMs);\n  }\n\n  async remove(keyArray: StorageKey): Promise<void> {\n    if (this._lifecycleState !== LifecycleState.OPEN) {\n      return undefined;\n    }\n    await this._params.db.del<StorageKey>(keyArray, { ...encodingOptions });\n  }\n\n  async loadRange(keyPrefix: StorageKey): Promise<Chunk[]> {\n    if (this._lifecycleState !== LifecycleState.OPEN) {\n      return [];\n    }\n    const startMs = Date.now();\n    const result: Chunk[] = [];\n    for await (const [key, value] of this._params.db.iterator<StorageKey, Uint8Array>({\n      gte: keyPrefix,\n      lte: [...keyPrefix, '\\uffff'],\n      ...encodingOptions,\n    })) {\n      result.push({\n        key,\n        data: value,\n      });\n      this._params.monitor?.recordBytesLoaded(value.byteLength);\n    }\n    this._params.monitor?.recordLoadDuration(Date.now() - startMs);\n    return result;\n  }\n\n  async removeRange(keyPrefix: StorageKey): Promise<void> {\n    if (this._lifecycleState !== LifecycleState.OPEN) {\n      return undefined;\n    }\n    const batch = this._params.db.batch();\n\n    for await (const [key] of this._params.db.iterator<StorageKey, Uint8Array>({\n      gte: keyPrefix,\n      lte: [...keyPrefix, '\\uffff'],\n      ...encodingOptions,\n    })) {\n      batch.del<StorageKey>(key, { ...encodingOptions });\n    }\n    await batch.write();\n  }\n}\n\nconst keyEncoder: MixedEncoding<StorageKey, Uint8Array, StorageKey> = {\n  encode: (key: StorageKey): Uint8Array =>\n    Buffer.from(key.map((k) => k.replaceAll('%', '%25').replaceAll('-', '%2D')).join('-')),\n  decode: (key: Uint8Array): StorageKey =>\n    Buffer.from(key)\n      .toString()\n      .split('-')\n      .map((k) => k.replaceAll('%2D', '-').replaceAll('%25', '%')),\n  format: 'buffer',\n};\n\nexport const encodingOptions = {\n  keyEncoding: keyEncoder,\n  valueEncoding: 'buffer',\n};\n\nconst isLevelDbNotFoundError = (err: any): boolean => err.code === 'LEVEL_NOT_FOUND';\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport type { CollectionId } from '@dxos/echo-protocol';\nimport { invariant } from '@dxos/invariant';\nimport { PublicKey, type SpaceId } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport {\n  type AutomergeReplicator,\n  type AutomergeReplicatorFactory,\n} from '@dxos/teleport-extension-automerge-replicator';\nimport { ComplexSet, defaultMap } from '@dxos/util';\n\nimport { type EchoReplicator, type EchoReplicatorContext, type ShouldAdvertiseParams } from './echo-replicator';\nimport { MeshReplicatorConnection } from './mesh-echo-replicator-connection';\nimport { getSpaceIdFromCollectionId } from './space-collection';\nimport { createIdFromSpaceKey } from '../common/space-id';\n\n// TODO(dmaretskyi): Move out of @dxos/echo-pipeline.\n\n/**\n * Used to replicate with other peers over the network.\n */\nexport class MeshEchoReplicator implements EchoReplicator {\n  /**\n   * We might have multiple connections open with a peer (one per space), but there'll be only one enabled\n   * connection at any given moment, because there's a single repo for all the spaces.\n   * When a connection closes (space was closed) it gets removed from the list and the next connection\n   * in the line gets enabled.\n   */\n  private readonly _connectionsPerPeer = new Map<string, MeshReplicatorConnection[]>();\n  /**\n   * A set of all connections (enabled and disabled).\n   */\n  private readonly _connections = new Set<MeshReplicatorConnection>();\n\n  /**\n   * spaceId -> deviceKey[]\n   */\n  private readonly _authorizedDevices = new Map<SpaceId, ComplexSet<PublicKey>>();\n\n  private _context: EchoReplicatorContext | null = null;\n\n  async connect(context: EchoReplicatorContext): Promise<void> {\n    this._context = context;\n  }\n\n  async disconnect(): Promise<void> {\n    for (const connection of this._connections) {\n      if (connection.isEnabled) {\n        this._context?.onConnectionClosed(connection);\n      }\n    }\n\n    for (const connection of this._connections) {\n      await connection.close();\n    }\n\n    this._connections.clear();\n    this._connectionsPerPeer.clear();\n\n    this._context = null;\n  }\n\n  createExtension(extensionFactory?: AutomergeReplicatorFactory): AutomergeReplicator {\n    invariant(this._context);\n\n    const connection: MeshReplicatorConnection = new MeshReplicatorConnection({\n      ownPeerId: this._context.peerId,\n      replicatorFactory: extensionFactory,\n      onRemoteConnected: async () => {\n        log('onRemoteConnected', { peerId: connection.peerId });\n        invariant(this._context);\n\n        const existingConnections = this._connectionsPerPeer.get(connection.peerId);\n        if (existingConnections?.length) {\n          const enabledConnection = existingConnections[0];\n          this._context.onConnectionAuthScopeChanged(enabledConnection);\n          existingConnections.push(connection);\n        } else {\n          this._connectionsPerPeer.set(connection.peerId, [connection]);\n          this._context.onConnectionOpen(connection);\n          connection.enable();\n        }\n      },\n      onRemoteDisconnected: async () => {\n        log('onRemoteDisconnected', { peerId: connection.peerId });\n\n        this._connections.delete(connection);\n\n        const existingConnections = this._connectionsPerPeer.get(connection.peerId) ?? [];\n\n        const index = existingConnections.indexOf(connection);\n        if (index < 0) {\n          log.warn('disconnected connection not found', { peerId: connection.peerId });\n          return;\n        }\n\n        existingConnections.splice(index, 1);\n\n        if (connection.isEnabled) {\n          this._context?.onConnectionClosed(connection);\n          connection.disable();\n\n          // Promote the next connection to enabled\n          if (existingConnections.length > 0) {\n            this._context?.onConnectionOpen(existingConnections[0]);\n            existingConnections[0].enable();\n          }\n        }\n      },\n      shouldAdvertise: async (params: ShouldAdvertiseParams) => {\n        log('shouldAdvertise', { peerId: connection.peerId, documentId: params.documentId });\n        invariant(this._context);\n        try {\n          const spaceKey = await this._context.getContainingSpaceForDocument(params.documentId);\n          if (!spaceKey) {\n            const remoteDocumentExists = await this._context.isDocumentInRemoteCollection({\n              documentId: params.documentId,\n              peerId: connection.peerId,\n            });\n            log('document not found locally for share policy check', {\n              peerId: connection.peerId,\n              documentId: params.documentId,\n              acceptDocument: remoteDocumentExists,\n            });\n\n            // If a document is not present locally return true if another peer claims to have it.\n            // Simply returning true will add the peer to \"generous peers list\" for this document which will\n            // start replication of the document after we receive, even if the peer is not in the corresponding space.\n            return remoteDocumentExists;\n          }\n\n          const spaceId = await createIdFromSpaceKey(spaceKey);\n\n          const authorizedDevices = this._authorizedDevices.get(spaceId);\n\n          if (!connection.remoteDeviceKey) {\n            log('device key not found for share policy check', {\n              peerId: connection.peerId,\n              documentId: params.documentId,\n            });\n            return false;\n          }\n\n          const isAuthorized = authorizedDevices?.has(connection.remoteDeviceKey) ?? false;\n          log('share policy check', {\n            localPeer: this._context.peerId,\n            remotePeer: connection.peerId,\n            documentId: params.documentId,\n            deviceKey: connection.remoteDeviceKey,\n            spaceKey,\n            isAuthorized,\n          });\n          return isAuthorized;\n        } catch (err) {\n          log.catch(err);\n          return false;\n        }\n      },\n      shouldSyncCollection: ({ collectionId }) => {\n        const spaceId = getSpaceIdFromCollectionId(collectionId as CollectionId);\n\n        const authorizedDevices = this._authorizedDevices.get(spaceId);\n\n        if (!connection.remoteDeviceKey) {\n          log('device key not found for collection sync check', {\n            peerId: connection.peerId,\n            collectionId,\n          });\n          return false;\n        }\n\n        const isAuthorized = authorizedDevices?.has(connection.remoteDeviceKey) ?? false;\n        return isAuthorized;\n      },\n    });\n    this._connections.add(connection);\n\n    return connection.replicatorExtension;\n  }\n\n  async authorizeDevice(spaceKey: PublicKey, deviceKey: PublicKey): Promise<void> {\n    log('authorizeDevice', { spaceKey, deviceKey });\n    const spaceId = await createIdFromSpaceKey(spaceKey);\n    defaultMap(this._authorizedDevices, spaceId, () => new ComplexSet(PublicKey.hash)).add(deviceKey);\n    for (const connection of this._connections) {\n      if (connection.isEnabled && connection.remoteDeviceKey && connection.remoteDeviceKey.equals(deviceKey)) {\n        if (this._connectionsPerPeer.has(connection.peerId)) {\n          this._context?.onConnectionAuthScopeChanged(connection);\n        }\n      }\n    }\n  }\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport * as A from '@automerge/automerge';\nimport { cbor } from '@automerge/automerge-repo';\n\nimport { Resource } from '@dxos/context';\nimport { invariant } from '@dxos/invariant';\nimport { type PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport type { AutomergeProtocolMessage } from '@dxos/protocols';\nimport { AutomergeReplicator, type AutomergeReplicatorFactory } from '@dxos/teleport-extension-automerge-replicator';\n\nimport type { ReplicatorConnection, ShouldAdvertiseParams, ShouldSyncCollectionParams } from './echo-replicator';\n\nconst DEFAULT_FACTORY: AutomergeReplicatorFactory = (params) => new AutomergeReplicator(...params);\n\nexport type MeshReplicatorConnectionParams = {\n  ownPeerId: string;\n  onRemoteConnected: () => void;\n  onRemoteDisconnected: () => void;\n  shouldAdvertise: (params: ShouldAdvertiseParams) => Promise<boolean>;\n  shouldSyncCollection: (params: ShouldSyncCollectionParams) => boolean;\n  replicatorFactory?: AutomergeReplicatorFactory;\n};\n\nexport class MeshReplicatorConnection extends Resource implements ReplicatorConnection {\n  public readable: ReadableStream<AutomergeProtocolMessage>;\n  public writable: WritableStream<AutomergeProtocolMessage>;\n  public remoteDeviceKey: PublicKey | null = null;\n\n  public readonly replicatorExtension: AutomergeReplicator;\n\n  private _remotePeerId: string | null = null;\n  private _isEnabled = false;\n\n  constructor(private readonly _params: MeshReplicatorConnectionParams) {\n    super();\n\n    let readableStreamController!: ReadableStreamDefaultController<AutomergeProtocolMessage>;\n    this.readable = new ReadableStream<AutomergeProtocolMessage>({\n      start: (controller) => {\n        readableStreamController = controller;\n        this._ctx.onDispose(() => controller.close());\n      },\n    });\n\n    this.writable = new WritableStream<AutomergeProtocolMessage>({\n      write: async (message: AutomergeProtocolMessage, controller) => {\n        invariant(this._isEnabled, 'Writing to a disabled connection');\n        try {\n          logSendSync(message);\n          await this.replicatorExtension.sendSyncMessage({ payload: cbor.encode(message) });\n        } catch (err) {\n          controller.error(err);\n          this._disconnectIfEnabled();\n        }\n      },\n    });\n\n    const createAutomergeReplicator = this._params.replicatorFactory ?? DEFAULT_FACTORY;\n    this.replicatorExtension = createAutomergeReplicator([\n      {\n        peerId: this._params.ownPeerId,\n      },\n      {\n        onStartReplication: async (info, remotePeerId /** Teleport ID */) => {\n          // Note: We store only one enabled extension per peer.\n          //       There can be a case where two connected peers have more than one teleport connection between them\n          //       and each of them uses different teleport connections to send messages.\n          //       It works because we receive messages from all teleport connections and Automerge Repo dedup them.\n          // TODO(mykola): Use only one teleport connection per peer.\n\n          this.remoteDeviceKey = remotePeerId;\n\n          // Set automerge id.\n          this._remotePeerId = info.id;\n\n          log('onStartReplication', { id: info.id, thisPeerId: this.peerId, remotePeerId: remotePeerId.toHex() });\n\n          this._params.onRemoteConnected();\n        },\n        onSyncMessage: async ({ payload }) => {\n          if (!this._isEnabled) {\n            return;\n          }\n          const message = cbor.decode(payload) as AutomergeProtocolMessage;\n          // Note: automerge Repo dedup messages.\n          readableStreamController.enqueue(message);\n        },\n        onClose: async () => {\n          this._disconnectIfEnabled();\n        },\n      },\n    ]);\n  }\n\n  private _disconnectIfEnabled(): void {\n    if (this._isEnabled) {\n      this._params.onRemoteDisconnected();\n    }\n  }\n\n  get peerId(): string {\n    invariant(this._remotePeerId != null, 'Remote peer has not connected yet.');\n    return this._remotePeerId;\n  }\n\n  get isEnabled() {\n    return this._isEnabled;\n  }\n\n  async shouldAdvertise(params: ShouldAdvertiseParams): Promise<boolean> {\n    return this._params.shouldAdvertise(params);\n  }\n\n  shouldSyncCollection(params: ShouldSyncCollectionParams): boolean {\n    return this._params.shouldSyncCollection(params);\n  }\n\n  /**\n   * Start exchanging messages with the remote peer.\n   * Call after the remote peer has connected.\n   */\n  enable(): void {\n    invariant(this._remotePeerId != null, 'Remote peer has not connected yet.');\n    this._isEnabled = true;\n  }\n\n  /**\n   * Stop exchanging messages with the remote peer.\n   */\n  disable(): void {\n    this._isEnabled = false;\n  }\n}\n\nconst logSendSync = (message: AutomergeProtocolMessage) => {\n  log('sendSyncMessage', () => {\n    const decodedSyncMessage = message.type === 'sync' && message.data ? A.decodeSyncMessage(message.data) : undefined;\n    return {\n      sync: decodedSyncMessage && {\n        headsLength: decodedSyncMessage.heads.length,\n        requesting: decodedSyncMessage.need.length > 0,\n        sendingChanges: decodedSyncMessage.changes.length > 0,\n      },\n      type: message.type,\n      from: message.senderId,\n      to: message.targetId,\n    };\n  });\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { type DocumentId } from '@automerge/automerge-repo';\n\nimport type { CollectionId } from '@dxos/echo-protocol';\nimport { invariant } from '@dxos/invariant';\nimport { SpaceId } from '@dxos/keys';\n\nexport const deriveCollectionIdFromSpaceId = (spaceId: SpaceId, rootDocumentId?: DocumentId): CollectionId =>\n  (rootDocumentId ? `space:${spaceId}:${rootDocumentId}` : `space:${spaceId}`) as CollectionId;\n\nexport const getSpaceIdFromCollectionId = (collectionId: CollectionId): SpaceId => {\n  const spaceId = collectionId.split(':')[1];\n  invariant(SpaceId.isValid(spaceId));\n  return spaceId;\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { type Message } from '@automerge/automerge-repo';\n\nimport { type TimeAware, trace } from '@dxos/tracing';\nimport { CircularBuffer, mapValues, SlidingWindowSummary, type SlidingWindowSummaryConfig } from '@dxos/util';\n\nimport { type NetworkDataMonitor } from './echo-network-adapter';\nimport { type StorageAdapterDataMonitor } from './leveldb-storage-adapter';\nimport { isCollectionQueryMessage, isCollectionStateMessage } from './network-protocol';\n\nconst PER_SECOND_RATE_AVG_WINDOW_SIZE = 5;\nconst DEFAULT_AVG_WINDOW_SIZE = 25;\n\nexport type EchoDataMonitorOptions = {\n  timeSeriesLength: number;\n};\n\n@trace.resource()\nexport class EchoDataMonitor implements StorageAdapterDataMonitor, NetworkDataMonitor, TimeAware {\n  private _lastTick = 0;\n\n  private _activeCounters = createLocalCounters();\n  private _lastCompleteCounters: LocalCounters | undefined;\n  private readonly _localTimeSeries = createLocalTimeSeries();\n  private readonly _storageAverages = createStorageAverages();\n  private readonly _replicationAverages = createNetworkAverages();\n  private readonly _sizeByMessage: { [type: string]: SlidingWindowSummary } = {};\n  private readonly _lastReceivedMessages = new CircularBuffer<StoredMessage>(100);\n  private readonly _lastSentMessages = new CircularBuffer<StoredMessage>(100);\n\n  private _connectionsCount = 0;\n\n  constructor(private readonly _params: EchoDataMonitorOptions = { timeSeriesLength: 30 }) {}\n\n  public tick(timeMs: number): void {\n    this._advanceTimeWindow(timeMs - this._lastTick);\n    this._lastTick = timeMs;\n  }\n\n  public computeStats(): EchoDataStats {\n    return {\n      meta: {\n        rateAverageOverSeconds: PER_SECOND_RATE_AVG_WINDOW_SIZE,\n      },\n      storage: {\n        reads: {\n          payloadSize: this._storageAverages.loadedChunkSize.average(),\n          opDuration: this._storageAverages.loadDuration.average(),\n          countPerSecond: this._storageAverages.loadsPerSecond.average(),\n        },\n        writes: {\n          payloadSize: this._storageAverages.storedChunkSize.average(),\n          opDuration: this._storageAverages.storeDuration.average(),\n          countPerSecond: this._storageAverages.storesPerSecond.average(),\n        },\n      },\n      replicator: {\n        connections: this._connectionsCount,\n        receivedMessages: {\n          payloadSize: this._replicationAverages.receivedMessageSize.average(),\n          countPerSecond: this._replicationAverages.receivedPerSecond.average(),\n        },\n        sentMessages: {\n          payloadSize: this._replicationAverages.sentMessageSize.average(),\n          opDuration: this._replicationAverages.sendDuration.average(),\n          countPerSecond: this._replicationAverages.sentPerSecond.average(),\n          failedPerSecond: this._replicationAverages.sendsFailedPerSecond.average(),\n        },\n        countByMessage: this._computeMessageHistogram('type'),\n        avgSizeByMessage: mapValues(this._sizeByMessage, (summary) => summary.average()),\n      },\n    };\n  }\n\n  public get connectionsCount() {\n    return this._connectionsCount;\n  }\n\n  /**\n   * @internal\n   */\n  get lastPerSecondStats() {\n    return this._lastCompleteCounters;\n  }\n\n  /**\n   * @internal\n   */\n  get timeSeries() {\n    return { ...this._localTimeSeries.storage, ...this._localTimeSeries.replication };\n  }\n\n  /**\n   * @internal\n   */\n  get messagesByPeerId() {\n    return this._computeMessageHistogram('peerId');\n  }\n\n  private _advanceTimeWindow(millisPassed: number): void {\n    const oldMetrics = Object.freeze(this._activeCounters);\n    this._activeCounters = createLocalCounters();\n    this._lastCompleteCounters = oldMetrics;\n    for (const peerId of Object.keys(oldMetrics.byPeerId)) {\n      this._activeCounters.byPeerId[peerId] = createMessageCounter();\n    }\n    this._addToTimeSeries(oldMetrics.replication, this._localTimeSeries.replication);\n    this._addToTimeSeries(oldMetrics.storage, this._localTimeSeries.storage);\n    // Prevent skewed measurements of incomplete buckets / after CPU freezes.\n    if (Math.abs(millisPassed - 1000) < 100) {\n      this._reportPerSecondRate(oldMetrics);\n    }\n  }\n\n  private _addToTimeSeries<T extends object>(values: T, timeSeries: TimeSeries<T>): void {\n    for (const [key, value] of Object.entries(values)) {\n      const values: (typeof value)[] = (timeSeries as any)[key];\n      values.push(value);\n      if (values.length > this._params.timeSeriesLength) {\n        values.shift();\n      }\n    }\n  }\n\n  private _reportPerSecondRate(metrics: LocalCounters): void {\n    const toReport: [string, number, SlidingWindowSummary][] = [\n      ['storage.load', metrics.storage.loadedChunks, this._storageAverages.loadsPerSecond],\n      ['storage.store', metrics.storage.storedChunks, this._storageAverages.storesPerSecond],\n      ['network.receive', metrics.replication.received, this._replicationAverages.receivedPerSecond],\n      ['network.send', metrics.replication.sent, this._replicationAverages.sentPerSecond],\n    ];\n    for (const [metricName, metric, summary] of toReport) {\n      summary.record(metric);\n      if (metric > 0) {\n        trace.metrics.distribution(`dxos.echo.${metricName}-rate`, metric);\n        trace.metrics.increment(`dxos.echo.${metricName}`, 1, { tags: { status: 'busy' } });\n      } else {\n        trace.metrics.increment(`dxos.echo.${metricName}`, 1, { tags: { status: 'idle' } });\n      }\n    }\n    this._replicationAverages.sendsFailedPerSecond.record(metrics.replication.failed);\n  }\n\n  public recordPeerConnected(peerId: string): void {\n    this._activeCounters.byPeerId[peerId] = createMessageCounter();\n    this._connectionsCount++;\n  }\n\n  public recordPeerDisconnected(peerId: string): void {\n    this._connectionsCount--;\n    delete this._activeCounters.byPeerId[peerId];\n  }\n\n  public recordBytesStored(count: number): void {\n    this._activeCounters.storage.storedChunks++;\n    this._activeCounters.storage.storedBytes += count;\n    this._storageAverages.storedChunkSize.record(count);\n    trace.metrics.distribution('dxos.echo.storage.bytes-stored', count, { unit: 'bytes' });\n  }\n\n  public recordLoadDuration(durationMs: number): void {\n    this._storageAverages.loadDuration.record(durationMs);\n  }\n\n  public recordStoreDuration(durationMs: number): void {\n    this._storageAverages.storeDuration.record(durationMs);\n  }\n\n  public recordBytesLoaded(count: number): void {\n    this._activeCounters.storage.loadedChunks++;\n    this._activeCounters.storage.loadedBytes += count;\n    this._storageAverages.loadedChunkSize.record(count);\n    trace.metrics.distribution('dxos.echo.storage.bytes-loaded', count, { unit: 'bytes' });\n  }\n\n  public recordMessageSent(message: Message, duration: number): void {\n    let metricsGroupName;\n    const bytes = getByteCount(message);\n    const tags = { type: message.type };\n    if (isAutomergeProtocolMessage(message)) {\n      this._activeCounters.replication.sent++;\n      this._replicationAverages.sendDuration.record(duration);\n      this._replicationAverages.sentMessageSize.record(bytes);\n      metricsGroupName = 'replication';\n    } else {\n      metricsGroupName = 'collection-sync';\n    }\n    trace.metrics.distribution(`dxos.echo.${metricsGroupName}.bytes-sent`, bytes, { unit: 'bytes', tags });\n    trace.metrics.distribution(`dxos.echo.${metricsGroupName}.send-duration`, duration, { unit: 'millisecond', tags });\n    trace.metrics.increment(`dxos.echo.${metricsGroupName}.send-status`, 1, { tags: { ...tags, success: true } });\n    const { messageSize, messageCounts } = this._getStatsForType(message);\n    messageSize.record(bytes);\n    messageCounts.sent++;\n    this._lastSentMessages.push({ type: message.type, peerId: message.targetId });\n  }\n\n  public recordMessageReceived(message: Message): void {\n    const bytes = getByteCount(message);\n    const tags = { type: message.type };\n    if (isAutomergeProtocolMessage(message)) {\n      this._activeCounters.replication.received++;\n      this._replicationAverages.receivedMessageSize.record(bytes);\n      trace.metrics.distribution('dxos.echo.replication.bytes-received', bytes, { unit: 'bytes', tags });\n    } else {\n      trace.metrics.distribution('dxos.echo.collection-sync.bytes-received', bytes, { unit: 'bytes', tags });\n    }\n    const { messageSize, messageCounts } = this._getStatsForType(message);\n    messageSize.record(bytes);\n    messageCounts.received++;\n    this._lastReceivedMessages.push({ type: message.type, peerId: message.senderId });\n  }\n\n  public recordMessageSendingFailed(message: Message): void {\n    const tags = { type: message.type, success: false };\n    if (isAutomergeProtocolMessage(message)) {\n      this._activeCounters.replication.failed++;\n      trace.metrics.increment('dxos.echo.replication.send-status', 1, { unit: 'bytes', tags });\n    } else {\n      trace.metrics.increment('dxos.echo.collection-sync.send-status', 1, { unit: 'bytes', tags });\n    }\n    const { messageCounts } = this._getStatsForType(message);\n    messageCounts.failed++;\n  }\n\n  private _getStatsForType(message: Message): { messageCounts: MessageCounts; messageSize: SlidingWindowSummary } {\n    const messageSize = (this._sizeByMessage[message.type] ??= createSlidingWindow());\n    const messageCounts = (this._activeCounters.byType[message.type] ??= createMessageCounter());\n    return { messageCounts, messageSize };\n  }\n\n  private _computeMessageHistogram(groupKey: keyof StoredMessage): MessageAttributeHistogram {\n    const result: MessageAttributeHistogram = {};\n    for (const receivedMessage of this._lastReceivedMessages) {\n      const counters = (result[receivedMessage[groupKey]] ??= { received: 0, sent: 0 });\n      counters.received++;\n    }\n    for (const receivedMessage of this._lastSentMessages) {\n      const counters = (result[receivedMessage[groupKey]] ??= { received: 0, sent: 0 });\n      counters.sent++;\n    }\n    return result;\n  }\n}\n\ntype BaseDataOpStats = {\n  payloadSize: number;\n  countPerSecond: number;\n};\n\nexport type TimedDataOpStats = BaseDataOpStats & { opDuration: number };\n\ntype TimeSeries<T extends object> = { [key in keyof T]: T[key][] };\n\ntype StorageCounts = {\n  storedChunks: number;\n  storedBytes: number;\n  loadedChunks: number;\n  loadedBytes: number;\n};\ntype StorageCountTimeSeries = TimeSeries<StorageCounts>;\n\ntype MessageCounts = {\n  sent: number;\n  received: number;\n  failed: number;\n};\ntype MessageCountTimeSeries = TimeSeries<MessageCounts>;\n\ntype MessageAttributeHistogram = {\n  [Message: string]: {\n    received: number;\n    sent: number;\n  };\n};\n\nexport type EchoDataStats = {\n  meta: {\n    rateAverageOverSeconds: number;\n  };\n  storage: {\n    reads: TimedDataOpStats;\n    writes: TimedDataOpStats;\n  };\n  replicator: {\n    connections: number;\n    receivedMessages: BaseDataOpStats;\n    sentMessages: TimedDataOpStats & { failedPerSecond: number };\n    avgSizeByMessage: { [Message: string]: number };\n    countByMessage: MessageAttributeHistogram;\n  };\n};\n\ntype StoredMessage = { type: string; peerId: string };\n\ntype StorageAverages = {\n  storedChunkSize: SlidingWindowSummary;\n  storesPerSecond: SlidingWindowSummary;\n  loadedChunkSize: SlidingWindowSummary;\n  loadsPerSecond: SlidingWindowSummary;\n  loadDuration: SlidingWindowSummary;\n  storeDuration: SlidingWindowSummary;\n};\n\n// TODO(burdon): Standardize: `sent`/`recv`.\ntype NetworkAverages = {\n  receivedMessageSize: SlidingWindowSummary;\n  receivedPerSecond: SlidingWindowSummary;\n  sentMessageSize: SlidingWindowSummary;\n  sentPerSecond: SlidingWindowSummary;\n  sendDuration: SlidingWindowSummary;\n  sendsFailedPerSecond: SlidingWindowSummary;\n};\n\ntype LocalCounters = {\n  storage: StorageCounts;\n  replication: MessageCounts;\n  byPeerId: { [peerId: string]: MessageCounts };\n  byType: { [type: string]: MessageCounts };\n};\n\ntype LocalTimeSeries = {\n  storage: StorageCountTimeSeries;\n  replication: MessageCountTimeSeries;\n};\n\nconst isAutomergeProtocolMessage = (message: Message) => {\n  return !(isCollectionQueryMessage(message) || isCollectionStateMessage(message));\n};\n\nconst createSlidingWindow = (overrides?: SlidingWindowSummaryConfig) =>\n  new SlidingWindowSummary({ dataPoints: DEFAULT_AVG_WINDOW_SIZE, precision: 2, ...overrides });\n\nconst createLocalCounters = (): LocalCounters => ({\n  storage: { loadedBytes: 0, storedBytes: 0, storedChunks: 0, loadedChunks: 0 },\n  replication: createMessageCounter(),\n  byPeerId: {},\n  byType: {},\n});\n\nconst createLocalTimeSeries = (): LocalTimeSeries => ({\n  storage: { loadedBytes: [], storedBytes: [], storedChunks: [], loadedChunks: [] },\n  replication: { sent: [], failed: [], received: [] },\n});\n\nconst createMessageCounter = (): MessageCounts => ({ sent: 0, received: 0, failed: 0 });\n\nconst createNetworkAverages = (): NetworkAverages => ({\n  receivedMessageSize: createSlidingWindow(),\n  sentMessageSize: createSlidingWindow(),\n  sendDuration: createSlidingWindow(),\n  receivedPerSecond: createSlidingWindow({ dataPoints: PER_SECOND_RATE_AVG_WINDOW_SIZE }),\n  sentPerSecond: createSlidingWindow({ dataPoints: PER_SECOND_RATE_AVG_WINDOW_SIZE }),\n  sendsFailedPerSecond: createSlidingWindow({ dataPoints: PER_SECOND_RATE_AVG_WINDOW_SIZE }),\n});\n\nconst createStorageAverages = (): StorageAverages => ({\n  storedChunkSize: createSlidingWindow(),\n  loadedChunkSize: createSlidingWindow(),\n  loadDuration: createSlidingWindow(),\n  storeDuration: createSlidingWindow(),\n  loadsPerSecond: createSlidingWindow({ dataPoints: PER_SECOND_RATE_AVG_WINDOW_SIZE }),\n  storesPerSecond: createSlidingWindow({ dataPoints: PER_SECOND_RATE_AVG_WINDOW_SIZE }),\n});\n\nconst getByteCount = (message: Message): number => {\n  return (\n    message.type.length +\n    message.senderId.length +\n    message.targetId.length +\n    (message.data?.byteLength ?? 0) +\n    (message.documentId?.length ?? 0)\n  );\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport {\n  type AnyDocumentId,\n  type AutomergeUrl,\n  type DocHandle,\n  type DocumentId,\n  type Repo,\n} from '@automerge/automerge-repo';\n\nimport { LifecycleState, Resource, type Context } from '@dxos/context';\nimport { todo } from '@dxos/debug';\nimport { createIdFromSpaceKey, SpaceDocVersion, type DatabaseDirectory } from '@dxos/echo-protocol';\nimport { IndexMetadataStore, IndexStore, Indexer } from '@dxos/indexing';\nimport { invariant } from '@dxos/invariant';\nimport { type PublicKey, type SpaceId } from '@dxos/keys';\nimport { type LevelDB } from '@dxos/kv-store';\nimport { IndexKind } from '@dxos/protocols/proto/dxos/echo/indexing';\nimport { trace } from '@dxos/tracing';\n\nimport { DataServiceImpl } from './data-service';\nimport { type DatabaseRoot } from './database-root';\nimport { createSelectedDocumentsIterator } from './documents-iterator';\nimport { QueryServiceImpl } from './query-service';\nimport { SpaceStateManager } from './space-state-manager';\nimport {\n  AutomergeHost,\n  FIND_PARAMS,\n  EchoDataMonitor,\n  deriveCollectionIdFromSpaceId,\n  type LoadDocOptions,\n  type CreateDocOptions,\n  type EchoReplicator,\n  type EchoDataStats,\n  type PeerIdProvider,\n  type RootDocumentSpaceKeyProvider,\n} from '../automerge';\n\nexport interface EchoHostIndexingConfig {\n  /**\n   * @default true\n   */\n  fullText: boolean;\n\n  /**\n   * @default false\n   */\n  vector: boolean;\n}\n\nconst DEFAULT_INDEXING_CONFIG: EchoHostIndexingConfig = {\n  // TODO(dmaretskyi): Disabled by default since embedding generation is expensive.\n  fullText: false,\n  vector: false,\n};\n\nexport type EchoHostParams = {\n  kv: LevelDB;\n  peerIdProvider?: PeerIdProvider;\n  getSpaceKeyByRootDocumentId?: RootDocumentSpaceKeyProvider;\n\n  indexing?: Partial<EchoHostIndexingConfig>;\n};\n\n/**\n * Host for the Echo database.\n * Manages multiple spaces.\n * Stores data to disk.\n * Can sync with pluggable data replicators.\n */\nexport class EchoHost extends Resource {\n  private readonly _indexMetadataStore: IndexMetadataStore;\n  private readonly _indexer: Indexer;\n  private readonly _automergeHost: AutomergeHost;\n  private readonly _queryService: QueryServiceImpl;\n  private readonly _dataService: DataServiceImpl;\n  private readonly _spaceStateManager = new SpaceStateManager();\n  private readonly _echoDataMonitor: EchoDataMonitor;\n\n  constructor({ kv, indexing = {}, peerIdProvider, getSpaceKeyByRootDocumentId }: EchoHostParams) {\n    super();\n\n    const indexingConfig = { ...DEFAULT_INDEXING_CONFIG, ...indexing };\n\n    this._indexMetadataStore = new IndexMetadataStore({ db: kv.sublevel('index-metadata') });\n    this._echoDataMonitor = new EchoDataMonitor();\n    this._automergeHost = new AutomergeHost({\n      db: kv,\n      dataMonitor: this._echoDataMonitor,\n      indexMetadataStore: this._indexMetadataStore,\n      peerIdProvider,\n      getSpaceKeyByRootDocumentId,\n    });\n\n    this._indexer = new Indexer({\n      db: kv,\n      indexStore: new IndexStore({ db: kv.sublevel('index-storage') }),\n      metadataStore: this._indexMetadataStore,\n      loadDocuments: createSelectedDocumentsIterator(this._automergeHost),\n      indexCooldownTime: process.env.NODE_ENV === 'test' ? 0 : undefined,\n    });\n    void this._indexer.setConfig({\n      enabled: true,\n      indexes: [\n        //\n        { kind: IndexKind.Kind.SCHEMA_MATCH },\n        { kind: IndexKind.Kind.GRAPH },\n\n        ...(indexingConfig.fullText ? [{ kind: IndexKind.Kind.FULL_TEXT }] : []),\n        ...(indexingConfig.vector ? [{ kind: IndexKind.Kind.VECTOR }] : []),\n      ],\n    });\n\n    this._queryService = new QueryServiceImpl({\n      automergeHost: this._automergeHost,\n      indexer: this._indexer,\n      spaceStateManager: this._spaceStateManager,\n    });\n\n    this._dataService = new DataServiceImpl({\n      automergeHost: this._automergeHost,\n      spaceStateManager: this._spaceStateManager,\n      updateIndexes: async () => {\n        await this._indexer.updateIndexes();\n      },\n    });\n\n    trace.diagnostic<EchoStatsDiagnostic>({\n      id: 'echo-stats',\n      name: 'Echo Stats',\n      fetch: async () => {\n        return {\n          dataStats: this._echoDataMonitor.computeStats(),\n          loadedDocsCount: this._automergeHost.loadedDocsCount,\n        };\n      },\n    });\n\n    trace.diagnostic({\n      id: 'database-roots',\n      name: 'Database Roots',\n      fetch: async () => {\n        return Array.from(this._spaceStateManager.roots.values()).map((root) => ({\n          url: root.url,\n          isLoaded: root.isLoaded,\n          spaceKey: root.getSpaceKey(),\n          inlineObjects: root.getInlineObjectCount(),\n          linkedObjects: root.getLinkedObjectCount(),\n        }));\n      },\n    });\n\n    trace.diagnostic({\n      id: 'database-root-metrics',\n      name: 'Database Roots (with metrics)',\n      fetch: async () => {\n        return Array.from(this._spaceStateManager.roots.values()).map((root) => ({\n          url: root.url,\n          isLoaded: root.isLoaded,\n          spaceKey: root.getSpaceKey(),\n          inlineObjects: root.getInlineObjectCount(),\n          linkedObjects: root.getLinkedObjectCount(),\n          ...(root.measureMetrics() ?? {}),\n        }));\n      },\n    });\n  }\n\n  get queryService(): QueryServiceImpl {\n    return this._queryService;\n  }\n\n  get dataService(): DataServiceImpl {\n    return this._dataService;\n  }\n\n  /**\n   * @deprecated To be abstracted away.\n   */\n  get automergeRepo(): Repo {\n    return this._automergeHost.repo;\n  }\n\n  get roots(): ReadonlyMap<DocumentId, DatabaseRoot> {\n    return this._spaceStateManager.roots;\n  }\n\n  protected override async _open(ctx: Context): Promise<void> {\n    await this._automergeHost.open();\n    await this._indexer.open(ctx);\n    await this._queryService.open(ctx);\n    await this._spaceStateManager.open(ctx);\n\n    this._spaceStateManager.spaceDocumentListUpdated.on(this._ctx, (e) => {\n      if (e.previousRootId) {\n        void this._automergeHost.clearLocalCollectionState(deriveCollectionIdFromSpaceId(e.spaceId, e.previousRootId));\n      }\n      // TODO(yaroslav): remove collection without spaceRootId after release (production<->staging interop)\n      void this._automergeHost.updateLocalCollectionState(deriveCollectionIdFromSpaceId(e.spaceId), e.documentIds);\n      void this._automergeHost.updateLocalCollectionState(\n        deriveCollectionIdFromSpaceId(e.spaceId, e.spaceRootId),\n        e.documentIds,\n      );\n    });\n    this._automergeHost.documentsSaved.on(this._ctx, () => {\n      this._queryService.invalidateQueries();\n    });\n  }\n\n  protected override async _close(ctx: Context): Promise<void> {\n    await this._queryService.close(ctx);\n    await this._spaceStateManager.close(ctx);\n    await this._indexer.close(ctx);\n    await this._automergeHost.close();\n  }\n\n  /**\n   * Flush all pending writes to the underlying storage.\n   */\n  async flush(): Promise<void> {\n    await this._automergeHost.repo.flush();\n  }\n\n  /**\n   * Perform any pending index updates.\n   */\n  async updateIndexes(): Promise<void> {\n    await this._indexer.updateIndexes();\n  }\n\n  /**\n   * Loads the document handle from the repo and waits for it to be ready.\n   */\n  async loadDoc<T>(ctx: Context, documentId: AnyDocumentId, opts?: LoadDocOptions): Promise<DocHandle<T>> {\n    return await this._automergeHost.loadDoc(ctx, documentId, opts);\n  }\n\n  async exportDoc(ctx: Context, id: AnyDocumentId): Promise<Uint8Array> {\n    return await this._automergeHost.exportDoc(ctx, id);\n  }\n\n  /**\n   * Create new persisted document.\n   */\n  createDoc<T>(initialValue?: T, opts?: CreateDocOptions): DocHandle<T> {\n    return this._automergeHost.createDoc(initialValue, opts);\n  }\n\n  /**\n   * Create new space root.\n   */\n  async createSpaceRoot(spaceKey: PublicKey): Promise<DatabaseRoot> {\n    invariant(this._lifecycleState === LifecycleState.OPEN);\n    const spaceId = await createIdFromSpaceKey(spaceKey);\n\n    const automergeRoot = this._automergeHost.createDoc<DatabaseDirectory>({\n      version: SpaceDocVersion.CURRENT,\n      access: { spaceKey: spaceKey.toHex() },\n\n      // Better to initialize them right away to avoid merge conflicts and data loss that can occur if those maps get created on the fly.\n      objects: {},\n      links: {},\n    });\n\n    await this._automergeHost.flush({ documentIds: [automergeRoot.documentId] });\n\n    return await this.openSpaceRoot(spaceId, automergeRoot.url);\n  }\n\n  // TODO(dmaretskyi): Change to document id.\n  async openSpaceRoot(spaceId: SpaceId, automergeUrl: AutomergeUrl): Promise<DatabaseRoot> {\n    invariant(this._lifecycleState === LifecycleState.OPEN);\n    const handle = await this._automergeHost.repo.find<DatabaseDirectory>(automergeUrl, FIND_PARAMS);\n    await handle.whenReady();\n\n    return this._spaceStateManager.assignRootToSpace(spaceId, handle);\n  }\n\n  // TODO(dmaretskyi): Change to document id.\n  async closeSpaceRoot(automergeUrl: AutomergeUrl): Promise<void> {\n    todo();\n  }\n\n  /**\n   * Install data replicator.\n   */\n  async addReplicator(replicator: EchoReplicator): Promise<void> {\n    await this._automergeHost.addReplicator(replicator);\n  }\n\n  /**\n   * Remove data replicator.\n   */\n  async removeReplicator(replicator: EchoReplicator): Promise<void> {\n    await this._automergeHost.removeReplicator(replicator);\n  }\n}\n\nexport type { EchoDataStats };\n\nexport type EchoStatsDiagnostic = {\n  loadedDocsCount: number;\n  dataStats: EchoDataStats;\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport * as A from '@automerge/automerge';\nimport { type DocumentId } from '@automerge/automerge-repo';\n\nimport { Context } from '@dxos/context';\nimport { DatabaseDirectory, SpaceDocVersion } from '@dxos/echo-protocol';\nimport { type IdToHeads, type ObjectSnapshot } from '@dxos/indexing';\nimport { invariant } from '@dxos/invariant';\nimport { log } from '@dxos/log';\nimport { ObjectPointerVersion, objectPointerCodec } from '@dxos/protocols';\n\nimport { type AutomergeHost } from '../automerge';\n\nconst LOG_VIEW_OPERATION_THRESHOLD = 300;\n\n/**\n * Factory for `loadDocuments` iterator.\n */\nexport const createSelectedDocumentsIterator = (automergeHost: AutomergeHost) =>\n  /**\n   * Get object data blobs from Automerge Repo by ids.\n   */\n  // TODO(mykola): Unload automerge handles after usage.\n  async function* loadDocuments(objects: IdToHeads): AsyncGenerator<ObjectSnapshot[], void, void> {\n    for (const [id, heads] of objects.entries()) {\n      try {\n        const { documentId, objectId } = objectPointerCodec.decode(id);\n        const handle = await automergeHost.loadDoc<DatabaseDirectory>(Context.default(), documentId as DocumentId);\n\n        let doc = handle.doc();\n        invariant(doc);\n\n        const currentHeads = A.getHeads(doc);\n\n        // Checkout the requested version of the document.\n        if (!A.equals(currentHeads, heads)) {\n          const begin = Date.now();\n          // `view` can take a long time even if the document is already at the right version.\n          doc = A.view(doc, heads);\n          const end = Date.now();\n          if (end - begin > LOG_VIEW_OPERATION_THRESHOLD) {\n            log('Checking out document version is taking too long', {\n              duration: end - begin,\n              requestedHeads: heads,\n              originalHeads: currentHeads,\n            });\n          }\n        }\n\n        // Skip outdated docs.\n        if (doc.version !== SpaceDocVersion.CURRENT) {\n          continue;\n        }\n\n        if (!doc.objects?.[objectId]) {\n          continue;\n        }\n\n        // Upgrade V0 object pointers to V1.\n        let newId = id;\n        if (objectPointerCodec.getVersion(id) === ObjectPointerVersion.V0) {\n          const spaceKey = DatabaseDirectory.getSpaceKey(doc) ?? undefined;\n          newId = objectPointerCodec.encode({ documentId, objectId, spaceKey });\n        }\n\n        yield [{ id: newId, object: doc.objects![objectId], heads }];\n      } catch (error) {\n        log.error('Error loading document', { heads, id, error });\n      }\n    }\n  };\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { getHeads } from '@automerge/automerge';\nimport { type DocHandle, type DocumentId } from '@automerge/automerge-repo';\nimport { Schema } from 'effect';\n\nimport { DeferredTask, scheduleMicroTask, synchronized } from '@dxos/async';\nimport { Stream } from '@dxos/codec-protobuf/stream';\nimport { Context, Resource } from '@dxos/context';\nimport { raise } from '@dxos/debug';\nimport { DatabaseDirectory, QueryAST } from '@dxos/echo-protocol';\nimport { type IdToHeads, type Indexer, type ObjectSnapshot } from '@dxos/indexing';\nimport { log } from '@dxos/log';\nimport { objectPointerCodec } from '@dxos/protocols';\nimport { type IndexConfig } from '@dxos/protocols/proto/dxos/echo/indexing';\nimport {\n  type QueryRequest,\n  type QueryResponse,\n  type QueryResult,\n  type QueryService,\n} from '@dxos/protocols/proto/dxos/echo/query';\nimport { trace } from '@dxos/tracing';\n\nimport type { SpaceStateManager } from './space-state-manager';\nimport { type AutomergeHost } from '../automerge';\nimport { QueryExecutor } from '../query';\n\nexport type QueryServiceParams = {\n  indexer: Indexer;\n  automergeHost: AutomergeHost;\n  spaceStateManager: SpaceStateManager;\n};\n\n/**\n * Represents an active query (stream and query state connected to that stream).\n */\ntype ActiveQuery = {\n  executor: QueryExecutor;\n  /**\n   * Schedule re-execution of the query if true.\n   */\n  dirty: boolean;\n\n  open: boolean;\n\n  firstResult: boolean;\n\n  sendResults: (results: QueryResult[]) => void;\n  onError: (err: Error) => void;\n\n  close: () => Promise<void>;\n};\n\n@trace.resource()\nexport class QueryServiceImpl extends Resource implements QueryService {\n  private readonly _queries = new Set<ActiveQuery>();\n\n  private _updateQueries!: DeferredTask;\n\n  // TODO(burdon): OK for options, but not params. Pass separately and type readonly here.\n  constructor(private readonly _params: QueryServiceParams) {\n    super();\n\n    trace.diagnostic({\n      id: 'active-queries',\n      name: 'Active Queries',\n      fetch: () => {\n        return Array.from(this._queries).map((query) => {\n          return {\n            query: JSON.stringify(query.executor.query),\n            plan: JSON.stringify(query.executor.plan),\n            trace: JSON.stringify(query.executor.trace),\n          };\n        });\n      },\n    });\n  }\n\n  override async _open(): Promise<void> {\n    this._params.indexer.updated.on(this._ctx, () => this.invalidateQueries());\n\n    this._updateQueries = new DeferredTask(this._ctx, this._executeQueries.bind(this));\n  }\n\n  @synchronized\n  override async _close(): Promise<void> {\n    await this._updateQueries.join();\n    await Promise.all(Array.from(this._queries).map((query) => query.close()));\n  }\n\n  async setConfig(config: IndexConfig): Promise<void> {\n    await this._params.indexer.setConfig(config);\n  }\n\n  execQuery(request: QueryRequest): Stream<QueryResponse> {\n    return new Stream<QueryResponse>(({ next, close, ctx }) => {\n      const queryEntry = this._createQuery(ctx, request, next, close, close);\n      scheduleMicroTask(ctx, async () => {\n        await queryEntry.executor.open();\n        queryEntry.open = true;\n        this._updateQueries.schedule();\n      });\n      return queryEntry.close;\n    });\n  }\n\n  /**\n   * Re-index all loaded documents.\n   */\n  async reindex(): Promise<void> {\n    log('Reindexing all documents...');\n    const iterator = createDocumentsIterator(this._params.automergeHost);\n    const ids: IdToHeads = new Map();\n    for await (const documents of iterator()) {\n      for (const { id, heads } of documents) {\n        ids.set(id, heads);\n      }\n      if (ids.size % 100 === 0) {\n        log('Collected documents...', { count: ids.size });\n      }\n    }\n\n    log('Marking all documents as dirty...', { count: ids.size });\n    await this._params.indexer.reindex(ids);\n  }\n\n  /**\n   * Schedule re-execution of all queries.\n   */\n  invalidateQueries() {\n    for (const query of this._queries) {\n      query.dirty = true;\n    }\n    this._updateQueries.schedule();\n  }\n\n  private _createQuery(\n    ctx: Context,\n    request: QueryRequest,\n    onResults: (respose: QueryResponse) => void,\n    onError: (err: Error) => void,\n    onClose: () => void,\n  ): ActiveQuery {\n    const parsedQuery = QueryAST.Query.pipe(Schema.decodeUnknownSync)(JSON.parse(request.query));\n    const queryEntry: ActiveQuery = {\n      executor: new QueryExecutor({\n        indexer: this._params.indexer,\n        automergeHost: this._params.automergeHost,\n        queryId: request.queryId ?? raise(new Error('query id required')),\n        query: parsedQuery,\n        reactivity: request.reactivity,\n        spaceStateManager: this._params.spaceStateManager,\n      }),\n      dirty: true,\n      open: false,\n      firstResult: true,\n      sendResults: (results) => {\n        if (ctx.disposed) {\n          return;\n        }\n        onResults({ queryId: request.queryId, results });\n      },\n      onError,\n      close: async () => {\n        onClose();\n        await queryEntry.executor.close();\n        this._queries.delete(queryEntry);\n      },\n    };\n    this._queries.add(queryEntry);\n    return queryEntry;\n  }\n\n  @trace.span({ showInBrowserTimeline: true })\n  private async _executeQueries() {\n    // TODO(dmaretskyi): How do we integrate this tracing info into the tracing API.\n    const begin = performance.now();\n    let count = 0;\n    await Promise.all(\n      Array.from(this._queries).map(async (query) => {\n        if (!query.dirty || !query.open) {\n          return;\n        }\n        count++;\n\n        try {\n          const { changed } = await query.executor.execQuery();\n          query.dirty = false;\n          if (changed || query.firstResult) {\n            query.firstResult = false;\n            query.sendResults(query.executor.getResults());\n          }\n        } catch (err) {\n          log.catch(err);\n        }\n      }),\n    );\n    log.verbose('executed queries', { count, duration: performance.now() - begin });\n  }\n}\n\n/**\n * Factory for `getAllDocuments` iterator.\n */\n// TODO(dmaretskyi): Get roots from echo-host.\nconst createDocumentsIterator = (automergeHost: AutomergeHost) =>\n  /**\n   * Recursively get all object data blobs from loaded documents from Automerge Repo.\n   */\n  // TODO(mykola): Unload automerge handles after usage.\n  async function* getAllDocuments(): AsyncGenerator<ObjectSnapshot[], void, void> {\n    /** visited automerge handles */\n    const visited = new Set<string>();\n\n    async function* getObjectsFromHandle(handle: DocHandle<DatabaseDirectory>): AsyncGenerator<ObjectSnapshot[]> {\n      if (visited.has(handle.documentId) || !handle.isReady()) {\n        return;\n      }\n\n      const doc = handle.doc()!;\n      const spaceKey = DatabaseDirectory.getSpaceKey(doc) ?? undefined;\n      if (doc.objects) {\n        yield Object.entries(doc.objects as { [key: string]: any }).map(([objectId, object]) => {\n          return {\n            id: objectPointerCodec.encode({ documentId: handle.documentId, objectId, spaceKey }),\n            object,\n            heads: getHeads(doc),\n          };\n        });\n      }\n\n      if (doc.links) {\n        for (const id of Object.values(doc.links as { [echoId: string]: string })) {\n          const urlString = id.toString();\n          if (visited.has(urlString)) {\n            continue;\n          }\n          const linkHandle = await automergeHost.loadDoc<DatabaseDirectory>(Context.default(), urlString as DocumentId);\n          for await (const result of getObjectsFromHandle(linkHandle)) {\n            yield result;\n          }\n        }\n      }\n\n      visited.add(handle.documentId);\n    }\n\n    // TODO(mykola): Use list of roots instead of iterating over all handles.\n    for (const handle of Object.values(automergeHost.repo.handles)) {\n      if (visited.has(handle.documentId)) {\n        continue;\n      }\n      for await (const result of getObjectsFromHandle(handle)) {\n        yield result;\n      }\n      visited.add(handle.documentId);\n    }\n  };\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport type { AutomergeUrl, DocumentId } from '@automerge/automerge-repo';\nimport { Match } from 'effect';\n\nimport { Context, ContextDisposedError, LifecycleState, Resource } from '@dxos/context';\nimport { DatabaseDirectory, isEncodedReference, ObjectStructure, type QueryAST } from '@dxos/echo-protocol';\nimport { EscapedPropPath, type FindResult, type Indexer } from '@dxos/indexing';\nimport { invariant } from '@dxos/invariant';\nimport { DXN, type ObjectId, PublicKey, type SpaceId } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { objectPointerCodec } from '@dxos/protocols';\nimport { type QueryReactivity, type QueryResult } from '@dxos/protocols/proto/dxos/echo/query';\nimport { getDeep, isNonNullable } from '@dxos/util';\n\nimport type { QueryPlan } from './plan';\nimport { QueryPlanner } from './query-planner';\nimport type { AutomergeHost } from '../automerge';\nimport { createIdFromSpaceKey } from '../common';\nimport type { SpaceStateManager } from '../db-host';\nimport { filterMatchObject } from '../filter';\n\ntype QueryExecutorOptions = {\n  indexer: Indexer;\n  automergeHost: AutomergeHost;\n  spaceStateManager: SpaceStateManager;\n\n  queryId: string;\n  query: QueryAST.Query;\n  reactivity: QueryReactivity;\n};\n\ntype QueryExecutionResult = {\n  /**\n   * Whether the query results have changed since the last execution.\n   */\n  changed: boolean;\n};\n\n/**\n * Represents an item in the query working set during execution.\n */\ntype QueryItem = {\n  objectId: ObjectId;\n  documentId: DocumentId;\n  spaceId: SpaceId;\n  doc: ObjectStructure;\n};\n\n/**\n * Recursive data structure that represents the execution trace of a query.\n */\nexport type ExecutionTrace = {\n  name: string;\n  details: string;\n\n  objectCount: number;\n  documentsLoaded: number;\n  indexHits: number;\n\n  executionTime: number;\n  indexQueryTime: number;\n  documentLoadTime: number;\n\n  children: ExecutionTrace[];\n};\n\nexport const ExecutionTrace = Object.freeze({\n  makeEmpty: (): ExecutionTrace => ({\n    name: 'Empty',\n    details: '',\n    objectCount: 0,\n    documentsLoaded: 0,\n    indexHits: 0,\n    indexQueryTime: 0,\n    documentLoadTime: 0,\n    executionTime: 0,\n    children: [],\n  }),\n  format: (trace: ExecutionTrace): string => {\n    const go = (trace: ExecutionTrace, indent: number): string => {\n      return [\n        `${' '.repeat(indent)} - ${trace.name}(${trace.details})`,\n        `${' '.repeat(indent)}   objects: ${trace.objectCount}  docs: ${trace.documentsLoaded}  index hits: ${trace.indexHits} | total: ${trace.executionTime.toFixed(0)}ms  index: ${trace.indexQueryTime.toFixed(0)}ms  load: ${trace.documentLoadTime.toFixed(0)}ms`,\n        '',\n        ...trace.children.map((child) => go(child, indent + 2)),\n      ].join('\\n');\n    };\n    return go(trace, 0);\n  },\n});\n\ntype StepExecutionResult = {\n  workingSet: QueryItem[];\n  trace: ExecutionTrace;\n};\n\nconst TRACE_QUERY_EXECUTION = false;\n\n/**\n * Executes query plans against the Indexer and AutomergeHost.\n *\n * The QueryExecutor is responsible for:\n * - Executing query plans step by step\n * - Managing the working set of query results\n * - Loading documents from the database\n * - Tracking execution performance metrics\n * - Handling different types of query operations (select, filter, traverse, etc.)\n */\nexport class QueryExecutor extends Resource {\n  private readonly _indexer: Indexer;\n  private readonly _automergeHost: AutomergeHost;\n  private readonly _spaceStateManager: SpaceStateManager;\n  /**\n   * Id of this query.\n   */\n  private readonly _id: string;\n  private readonly _query: QueryAST.Query;\n  // TODO(dmaretskyi): Might be used in the future.\n  private readonly _reactivity: QueryReactivity;\n\n  private _plan: QueryPlan.Plan;\n  private _trace: ExecutionTrace = ExecutionTrace.makeEmpty();\n  private _lastResultSet: QueryItem[] = [];\n\n  constructor(options: QueryExecutorOptions) {\n    super();\n\n    this._indexer = options.indexer;\n    this._automergeHost = options.automergeHost;\n    this._spaceStateManager = options.spaceStateManager;\n\n    this._id = options.queryId;\n    this._query = options.query;\n    this._reactivity = options.reactivity;\n\n    const queryPlanner = new QueryPlanner();\n    this._plan = queryPlanner.createPlan(this._query);\n  }\n\n  get query(): QueryAST.Query {\n    return this._query;\n  }\n\n  get plan(): QueryPlan.Plan {\n    return this._plan;\n  }\n\n  get trace(): ExecutionTrace {\n    return this._trace;\n  }\n\n  protected override async _open(ctx: Context): Promise<void> {}\n\n  protected override async _close(ctx: Context): Promise<void> {}\n\n  getResults(): QueryResult[] {\n    return this._lastResultSet.map(\n      (item): QueryResult => ({\n        id: item.objectId,\n        documentId: item.documentId,\n        spaceId: item.spaceId,\n\n        // TODO(dmaretskyi): Plumb through the rank.\n        rank: 0,\n      }),\n    );\n  }\n\n  async execQuery(): Promise<QueryExecutionResult> {\n    invariant(this._lifecycleState === LifecycleState.OPEN);\n\n    const prevResultSet = this._lastResultSet;\n    const { workingSet, trace } = await this._execPlan(this._plan, []);\n    this._lastResultSet = workingSet;\n    trace.name = 'Root';\n    trace.details = JSON.stringify({ id: this._id });\n    this._trace = trace;\n\n    const changed =\n      prevResultSet.length !== workingSet.length ||\n      prevResultSet.some(\n        (item, index) =>\n          workingSet[index].objectId !== item.objectId ||\n          workingSet[index].spaceId !== item.spaceId ||\n          workingSet[index].documentId !== item.documentId,\n      );\n\n    if (TRACE_QUERY_EXECUTION) {\n      // eslint-disable-next-line no-console\n      console.log(ExecutionTrace.format(trace));\n    }\n\n    return {\n      changed,\n    };\n  }\n\n  private async _execPlan(plan: QueryPlan.Plan, workingSet: QueryItem[]): Promise<StepExecutionResult> {\n    const trace = ExecutionTrace.makeEmpty();\n    const begin = performance.now();\n    for (const step of plan.steps) {\n      if (this._ctx.disposed) {\n        throw new ContextDisposedError();\n      }\n\n      const result = await this._execStep(step, workingSet);\n      workingSet = result.workingSet;\n      trace.children.push(result.trace);\n    }\n    trace.objectCount = workingSet.length;\n    trace.executionTime = performance.now() - begin;\n    return { workingSet, trace };\n  }\n\n  private async _execStep(step: QueryPlan.Step, workingSet: QueryItem[]): Promise<StepExecutionResult> {\n    if (this._ctx.disposed) {\n      return { workingSet, trace: ExecutionTrace.makeEmpty() };\n    }\n    let newWorkingSet: QueryItem[], trace: ExecutionTrace;\n\n    const begin = performance.now();\n    switch (step._tag) {\n      case 'ClearWorkingSetStep':\n        newWorkingSet = [];\n        trace = ExecutionTrace.makeEmpty();\n        break;\n      case 'SelectStep':\n        ({ workingSet: newWorkingSet, trace } = await this._execSelectStep(step, workingSet));\n        break;\n      case 'FilterStep':\n        ({ workingSet: newWorkingSet, trace } = await this._execFilterStep(step, workingSet));\n        break;\n      case 'FilterDeletedStep':\n        ({ workingSet: newWorkingSet, trace } = await this._execFilterDeletedStep(step, workingSet));\n        break;\n      case 'UnionStep':\n        ({ workingSet: newWorkingSet, trace } = await this._execUnionStep(step, workingSet));\n        break;\n      case 'SetDifferenceStep':\n        ({ workingSet: newWorkingSet, trace } = await this._execSetDifferenceStep(step, workingSet));\n        break;\n      case 'TraverseStep':\n        ({ workingSet: newWorkingSet, trace } = await this._execTraverseStep(step, workingSet));\n        break;\n      default:\n        throw new Error(`Unknown step type: ${(step as any)._tag}`);\n    }\n    trace.executionTime = performance.now() - begin;\n\n    return { workingSet: newWorkingSet, trace };\n  }\n\n  private async _execSelectStep(step: QueryPlan.SelectStep, workingSet: QueryItem[]): Promise<StepExecutionResult> {\n    workingSet = [...workingSet];\n\n    const trace: ExecutionTrace = {\n      ...ExecutionTrace.makeEmpty(),\n      name: 'Select',\n      details: JSON.stringify(step.selector),\n    };\n\n    switch (step.selector._tag) {\n      case 'WildcardSelector': {\n        const beginIndexQuery = performance.now();\n        const indexHits = await this._indexer.execQuery({\n          typenames: [],\n          inverted: false,\n        });\n        trace.indexHits = +indexHits.length;\n        trace.indexQueryTime += performance.now() - beginIndexQuery;\n\n        if (this._ctx.disposed) {\n          return { workingSet, trace };\n        }\n\n        const documentLoadStart = performance.now();\n        const results = await this._loadDocumentsAfterIndexQuery(indexHits);\n        trace.documentsLoaded += results.length;\n        trace.documentLoadTime += performance.now() - documentLoadStart;\n\n        workingSet.push(...results.filter(isNonNullable).filter((item) => step.spaces.includes(item.spaceId)));\n        trace.objectCount = workingSet.length;\n\n        break;\n      }\n      case 'IdSelector': {\n        const beginLoad = performance.now();\n        const items = await Promise.all(\n          step.selector.objectIds.map((id) =>\n            this._loadFromDXN(DXN.fromLocalObjectId(id), { sourceSpaceId: step.spaces[0] }),\n          ),\n        );\n        trace.documentLoadTime += performance.now() - beginLoad;\n\n        workingSet.push(...items.filter(isNonNullable));\n        trace.objectCount = workingSet.length;\n        break;\n      }\n      case 'TypeSelector': {\n        const beginIndexQuery = performance.now();\n        const indexHits = await this._indexer.execQuery({\n          typenames: step.selector.typename,\n          inverted: step.selector.inverted,\n        });\n        trace.indexHits = +indexHits.length;\n        trace.indexQueryTime += performance.now() - beginIndexQuery;\n\n        if (this._ctx.disposed) {\n          return { workingSet, trace };\n        }\n\n        const documentLoadStart = performance.now();\n        const results = await this._loadDocumentsAfterIndexQuery(indexHits);\n        trace.documentsLoaded += results.length;\n        trace.documentLoadTime += performance.now() - documentLoadStart;\n\n        workingSet.push(...results.filter(isNonNullable).filter((item) => step.spaces.includes(item.spaceId)));\n        trace.objectCount = workingSet.length;\n\n        break;\n      }\n      case 'TextSelector': {\n        const beginIndexQuery = performance.now();\n        const indexHits = await this._indexer.execQuery({\n          typenames: [],\n          text: {\n            query: step.selector.text,\n            kind: Match.type<QueryPlan.TextSearchKind>().pipe(\n              Match.withReturnType<'text' | 'vector'>(),\n              Match.when('full-text', () => 'text'),\n              Match.when('vector', () => 'vector'),\n              Match.orElseAbsurd,\n            )(step.selector.searchKind),\n          },\n        });\n        trace.indexHits = +indexHits.length;\n        trace.indexQueryTime += performance.now() - beginIndexQuery;\n\n        if (this._ctx.disposed) {\n          return { workingSet, trace };\n        }\n\n        const documentLoadStart = performance.now();\n        const results = await this._loadDocumentsAfterIndexQuery(indexHits);\n        trace.documentsLoaded += results.length;\n        trace.documentLoadTime += performance.now() - documentLoadStart;\n\n        workingSet.push(...results.filter(isNonNullable).filter((item) => step.spaces.includes(item.spaceId)));\n        trace.objectCount = workingSet.length;\n        break;\n      }\n      default:\n        throw new Error(`Unknown selector type: ${(step.selector as any)._tag}`);\n    }\n\n    return { workingSet, trace };\n  }\n\n  private async _execFilterStep(step: QueryPlan.FilterStep, workingSet: QueryItem[]): Promise<StepExecutionResult> {\n    const result = workingSet.filter((item) =>\n      filterMatchObject(step.filter, {\n        id: item.objectId,\n        spaceId: item.spaceId,\n        doc: item.doc,\n      }),\n    );\n    return {\n      workingSet: result,\n      trace: {\n        ...ExecutionTrace.makeEmpty(),\n        name: 'Filter',\n        details: JSON.stringify(step.filter),\n        objectCount: result.length,\n      },\n    };\n  }\n\n  private async _execFilterDeletedStep(\n    step: QueryPlan.FilterDeletedStep,\n    workingSet: QueryItem[],\n  ): Promise<StepExecutionResult> {\n    if (workingSet.length === 6) {\n      log.info('FilterDeletedStep', { step, workingSet });\n    }\n\n    const expected = step.mode === 'only-deleted';\n    const result = workingSet.filter((item) => ObjectStructure.isDeleted(item.doc) === expected);\n    return {\n      workingSet: result,\n      trace: {\n        ...ExecutionTrace.makeEmpty(),\n        name: 'FilterDeleted',\n        details: step.mode,\n        objectCount: result.length,\n      },\n    };\n  }\n\n  // TODO(dmaretskyi): This needs to be completed.\n  private async _execTraverseStep(step: QueryPlan.TraverseStep, workingSet: QueryItem[]): Promise<StepExecutionResult> {\n    const trace: ExecutionTrace = {\n      ...ExecutionTrace.makeEmpty(),\n      name: 'Traverse',\n      details: JSON.stringify(step.traversal),\n    };\n\n    const newWorkingSet: QueryItem[] = [];\n\n    switch (step.traversal._tag) {\n      case 'ReferenceTraversal': {\n        switch (step.traversal.direction) {\n          case 'outgoing': {\n            const property = EscapedPropPath.unescape(step.traversal.property);\n\n            const refs = workingSet\n              .flatMap((item) => {\n                const ref = getDeep(item.doc.data, property);\n                const refs = Array.isArray(ref) ? ref : [ref];\n                return refs.map((ref) => {\n                  try {\n                    return isEncodedReference(ref)\n                      ? {\n                          ref: DXN.parse(ref['/']),\n                          spaceId: item.spaceId,\n                        }\n                      : null;\n                  } catch {\n                    log.warn('Invalid reference', { ref: ref['/'] });\n                    return null;\n                  }\n                });\n              })\n              .filter(isNonNullable);\n\n            const beginLoad = performance.now();\n            const items = await Promise.all(\n              refs.map(({ ref, spaceId }) => this._loadFromDXN(ref, { sourceSpaceId: spaceId })),\n            );\n            trace.documentLoadTime += performance.now() - beginLoad;\n\n            newWorkingSet.push(...items.filter(isNonNullable));\n            trace.objectCount = newWorkingSet.length;\n\n            break;\n          }\n          case 'incoming': {\n            const indexHits = await this._indexer.execQuery({\n              typenames: [],\n              inverted: false,\n              graph: {\n                kind: 'inbound-reference',\n                property: step.traversal.property,\n                anchors: workingSet.map((item) => item.objectId),\n              },\n            });\n            trace.indexHits += indexHits.length;\n\n            const documentLoadStart = performance.now();\n            const results = await this._loadDocumentsAfterIndexQuery(indexHits);\n            trace.documentsLoaded += results.length;\n            trace.documentLoadTime += performance.now() - documentLoadStart;\n\n            newWorkingSet.push(...results.filter(isNonNullable));\n            trace.objectCount = newWorkingSet.length;\n\n            break;\n          }\n        }\n        break;\n      }\n      case 'RelationTraversal': {\n        switch (step.traversal.direction) {\n          case 'relation-to-source':\n          case 'relation-to-target': {\n            const refs = workingSet\n              .map((item) => {\n                const ref =\n                  step.traversal.direction === 'relation-to-source'\n                    ? ObjectStructure.getRelationSource(item.doc)\n                    : ObjectStructure.getRelationTarget(item.doc);\n\n                if (!isEncodedReference(ref)) {\n                  return null;\n                }\n                try {\n                  return {\n                    ref: DXN.parse(ref['/']),\n                    spaceId: item.spaceId,\n                  };\n                } catch {\n                  log.warn('Invalid reference', { ref: ref['/'] });\n                  return null;\n                }\n              })\n              .filter(isNonNullable);\n\n            const beginLoad = performance.now();\n            const items = await Promise.all(\n              refs.map(({ ref, spaceId }) => this._loadFromDXN(ref, { sourceSpaceId: spaceId })),\n            );\n            trace.documentLoadTime += performance.now() - beginLoad;\n\n            newWorkingSet.push(...items.filter(isNonNullable));\n            trace.objectCount = newWorkingSet.length;\n\n            break;\n          }\n\n          case 'source-to-relation':\n          case 'target-to-relation': {\n            const indexHits = await this._indexer.execQuery({\n              typenames: [],\n              inverted: false,\n              graph: {\n                kind: step.traversal.direction === 'source-to-relation' ? 'relation-source' : 'relation-target',\n                anchors: workingSet.map((item) => item.objectId),\n                property: null,\n              },\n            });\n\n            trace.indexHits += indexHits.length;\n\n            const documentLoadStart = performance.now();\n            const results = await this._loadDocumentsAfterIndexQuery(indexHits);\n            trace.documentsLoaded += results.length;\n            trace.documentLoadTime += performance.now() - documentLoadStart;\n\n            newWorkingSet.push(...results.filter(isNonNullable));\n            trace.objectCount = newWorkingSet.length;\n\n            break;\n          }\n        }\n        break;\n      }\n      default:\n        throw new Error(`Unknown traversal type: ${(step.traversal as any)._tag}`);\n    }\n\n    return { workingSet: newWorkingSet, trace };\n  }\n\n  private async _execUnionStep(step: QueryPlan.UnionStep, workingSet: QueryItem[]): Promise<StepExecutionResult> {\n    const results = new Map<ObjectId, QueryItem>();\n\n    const resultSets = await Promise.all(step.plans.map((plan) => this._execPlan(plan, [...workingSet])));\n\n    const trace: ExecutionTrace = {\n      ...ExecutionTrace.makeEmpty(),\n      name: 'Union',\n    };\n\n    // NOTE: Doing insertion after execution to ensure deterministic results. Probably not needed.\n    for (const resultSet of resultSets) {\n      for (const item of resultSet.workingSet) {\n        // Could be duplicate object ids in different spaces or in different epochs of the same space.\n        results.set(`${item.spaceId}:${item.documentId}:${item.objectId}`, item);\n      }\n      trace.children.push(resultSet.trace);\n    }\n\n    return {\n      workingSet: [...results.values()],\n      trace,\n    };\n  }\n\n  private async _execSetDifferenceStep(\n    step: QueryPlan.SetDifferenceStep,\n    workingSet: QueryItem[],\n  ): Promise<StepExecutionResult> {\n    const trace: ExecutionTrace = {\n      ...ExecutionTrace.makeEmpty(),\n      name: 'SetDifference',\n    };\n\n    const sourceResult = await this._execPlan(step.source, [...workingSet]);\n    const excludeResult = await this._execPlan(step.exclude, [...workingSet]);\n    trace.children.push(sourceResult.trace, excludeResult.trace);\n\n    return {\n      workingSet: sourceResult.workingSet.filter((item) => {\n        const index = excludeResult.workingSet.findIndex((i) => i.objectId === item.objectId);\n        return index === -1;\n      }),\n      trace,\n    };\n  }\n\n  private async _loadDocumentsAfterIndexQuery(indexHits: FindResult[]): Promise<(QueryItem | null)[]> {\n    return Promise.all(\n      indexHits.map(async (hit): Promise<QueryItem | null> => {\n        return this._loadFromIndexHit(hit);\n      }),\n    );\n  }\n\n  private async _loadFromIndexHit(hit: FindResult): Promise<QueryItem | null> {\n    const { objectId, documentId, spaceKey: spaceKeyInIndex } = objectPointerCodec.decode(hit.id);\n\n    const handle = await this._automergeHost.loadDoc<DatabaseDirectory>(Context.default(), documentId as DocumentId);\n    const doc = handle.doc();\n    if (!doc) {\n      return null;\n    }\n\n    const spaceKey = spaceKeyInIndex ?? DatabaseDirectory.getSpaceKey(doc);\n    if (!spaceKey) {\n      return null;\n    }\n\n    const object = DatabaseDirectory.getInlineObject(doc, objectId);\n    if (!object) {\n      return null;\n    }\n\n    return {\n      objectId,\n      documentId: documentId as DocumentId,\n      spaceId: await createIdFromSpaceKey(PublicKey.from(spaceKey)),\n      doc: object,\n    };\n  }\n\n  private async _loadFromDXN(dxn: DXN, { sourceSpaceId }: { sourceSpaceId: SpaceId }): Promise<QueryItem | null> {\n    const echoDxn = dxn.asEchoDXN();\n    if (!echoDxn) {\n      log.warn('unable to resolve DXN', { dxn });\n      return null;\n    }\n\n    const spaceId = echoDxn.spaceId ?? sourceSpaceId;\n\n    const spaceRoot = this._spaceStateManager.getRootBySpaceId(spaceId);\n    if (!spaceRoot) {\n      log.warn('no space state found for', { spaceId });\n      return null;\n    }\n    const dbDirectory = spaceRoot.doc();\n    if (!dbDirectory) {\n      log.warn('no space state found for', { spaceId });\n      return null;\n    }\n\n    const inlineObject = DatabaseDirectory.getInlineObject(dbDirectory, echoDxn.echoId);\n    if (inlineObject) {\n      return {\n        objectId: echoDxn.echoId,\n        documentId: spaceRoot.documentId,\n        spaceId,\n        doc: inlineObject,\n      };\n    }\n\n    const link = DatabaseDirectory.getLink(dbDirectory, echoDxn.echoId);\n    if (!link) {\n      return null;\n    }\n\n    const handle = await this._automergeHost.loadDoc<DatabaseDirectory>(Context.default(), link as AutomergeUrl);\n    const doc = handle.doc();\n    if (!doc) {\n      return null;\n    }\n\n    const object = DatabaseDirectory.getInlineObject(doc, echoDxn.echoId);\n    if (!object) {\n      return null;\n    }\n\n    return {\n      objectId: echoDxn.echoId,\n      documentId: handle.documentId,\n      spaceId,\n      doc: object,\n    };\n  }\n}\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { type QueryAST } from '@dxos/echo-protocol';\nimport { invariant } from '@dxos/invariant';\nimport type { DXN, SpaceId } from '@dxos/keys';\n\nimport { QueryError } from './errors';\nimport { QueryPlan } from './plan';\n\nexport type QueryPlannerOptions = {\n  defaultTextSearchKind: QueryPlan.TextSearchKind;\n};\n\nconst DEFAULT_OPTIONS: QueryPlannerOptions = {\n  defaultTextSearchKind: 'full-text',\n};\n\n/**\n * Constructs an optimized query plan.\n */\n// TODO(dmaretskyi): Implement inefficient versions of complex queries.\nexport class QueryPlanner {\n  private readonly _options: QueryPlannerOptions;\n\n  constructor(options?: Partial<QueryPlannerOptions>) {\n    this._options = {\n      ...DEFAULT_OPTIONS,\n      ...options,\n    };\n  }\n\n  createPlan(query: QueryAST.Query): QueryPlan.Plan {\n    let plan = this._generate(query, { ...DEFAULT_CONTEXT, originalQuery: query });\n    plan = this._optimizeEmptyFilters(plan);\n    plan = this._optimizeSoloUnions(plan);\n    return plan;\n  }\n\n  private _generate(query: QueryAST.Query, context: GenerationContext): QueryPlan.Plan {\n    switch (query.type) {\n      case 'options':\n        return this._generateOptionsClause(query, context);\n      case 'select':\n        return this._generateSelectClause(query, context);\n      case 'filter':\n        return this._generateFilterClause(query, context);\n      case 'incoming-references':\n        return this._generateIncomingReferencesClause(query, context);\n      case 'relation':\n        return this._generateRelationClause(query, context);\n      case 'relation-traversal':\n        return this._generateRelationTraversalClause(query, context);\n      case 'reference-traversal':\n        return this._generateReferenceTraversalClause(query, context);\n      case 'union':\n        return this._generateUnionClause(query, context);\n      case 'set-difference':\n        return this._generateSetDifferenceClause(query, context);\n      default:\n        throw new QueryError(`Unsupported query type: ${(query as any).type}`, {\n          context: { query: context.originalQuery },\n        });\n    }\n  }\n\n  private _generateOptionsClause(query: QueryAST.QueryOptionsClause, context: GenerationContext): QueryPlan.Plan {\n    const newContext = {\n      ...context,\n    };\n    if (query.options.spaceIds) {\n      newContext.selectionSpaces = query.options.spaceIds as readonly SpaceId[];\n    }\n    if (query.options.deleted) {\n      newContext.deletedHandling = query.options.deleted;\n    }\n    return this._generate(query.query, newContext);\n  }\n\n  private _generateSelectClause(query: QueryAST.QuerySelectClause, context: GenerationContext): QueryPlan.Plan {\n    return this._generateSelectionFromFilter(query.filter, context);\n  }\n\n  // TODO(dmaretskyi): This can be rewritten as a function of (filter[]) -> (selection ? undefined, rest: filter[]) that recurses onto itself.\n  // TODO(dmaretskyi): If the tip of the query ast is a [select, ...filter] shape we can reorder the filters so the query is most efficient.\n  private _generateSelectionFromFilter(filter: QueryAST.Filter, context: GenerationContext): QueryPlan.Plan {\n    switch (filter.type) {\n      case 'object': {\n        if (\n          context.selectionInverted &&\n          filter.id === undefined &&\n          filter.typename === null &&\n          Object.keys(filter.props).length === 0\n        ) {\n          // filter of nothing -> clear working set.\n          return QueryPlan.Plan.make([\n            {\n              _tag: 'ClearWorkingSetStep',\n            },\n            ...this._generateDeletedHandlingSteps(context),\n          ]);\n        }\n        if (context.selectionInverted) {\n          throw new QueryError('Query too complex', { context: { query: context.originalQuery } });\n        }\n\n        // Try to utilize indexes during selection, prioritizing selecting by id, then by typename.\n        // After selection, filter out using the remaining predicates.\n        if (filter.id && filter.id?.length > 0) {\n          return QueryPlan.Plan.make([\n            {\n              _tag: 'SelectStep',\n              spaces: context.selectionSpaces,\n              selector: {\n                _tag: 'IdSelector',\n                objectIds: filter.id,\n              },\n            },\n            ...this._generateDeletedHandlingSteps(context),\n            {\n              _tag: 'FilterStep',\n              filter: { ...filter, id: undefined },\n            },\n          ]);\n        } else if (filter.typename) {\n          return QueryPlan.Plan.make([\n            {\n              _tag: 'SelectStep',\n              spaces: context.selectionSpaces,\n              selector: {\n                _tag: 'TypeSelector',\n                typename: [filter.typename as DXN.String],\n                inverted: false,\n              },\n            },\n            ...this._generateDeletedHandlingSteps(context),\n            {\n              _tag: 'FilterStep',\n              filter: { ...filter, typename: null },\n            },\n          ]);\n        } else {\n          return QueryPlan.Plan.make([\n            {\n              _tag: 'SelectStep',\n              spaces: context.selectionSpaces,\n              selector: {\n                _tag: 'WildcardSelector',\n              },\n            },\n            ...this._generateDeletedHandlingSteps(context),\n            {\n              _tag: 'FilterStep',\n              filter: { ...filter },\n            },\n          ]);\n        }\n      }\n      case 'text-search': {\n        return QueryPlan.Plan.make([\n          {\n            _tag: 'SelectStep',\n            spaces: context.selectionSpaces,\n            selector: {\n              _tag: 'TextSelector',\n              text: filter.text,\n              searchKind: filter.searchKind ?? this._options.defaultTextSearchKind,\n            },\n          },\n          ...this._generateDeletedHandlingSteps(context),\n        ]);\n      }\n      case 'compare':\n        throw new QueryError('Query too complex', { context: { query: context.originalQuery } });\n      case 'in':\n        throw new QueryError('Query too complex', { context: { query: context.originalQuery } });\n      case 'range':\n        throw new QueryError('Query too complex', { context: { query: context.originalQuery } });\n      case 'not':\n        return this._generateSelectionFromFilter(filter.filter, {\n          ...context,\n          selectionInverted: !context.selectionInverted,\n        });\n      case 'and':\n        throw new QueryError('Query too complex', { context: { query: context.originalQuery } });\n      case 'or':\n        // Optimized case\n        if (filter.filters.every(isTrivialTypenameFilter)) {\n          const typenames = filter.filters.map((f) => {\n            invariant(f.type === 'object' && f.typename !== null);\n            return f.typename;\n          });\n          return QueryPlan.Plan.make([\n            {\n              _tag: 'SelectStep',\n              spaces: context.selectionSpaces,\n              selector: {\n                _tag: 'TypeSelector',\n                typename: typenames as DXN.String[],\n                inverted: context.selectionInverted,\n              },\n            },\n            ...this._generateDeletedHandlingSteps(context),\n          ]);\n        } else {\n          throw new QueryError('Query too complex', { context: { query: context.originalQuery } });\n        }\n\n      default:\n        throw new QueryError(`Unsupported filter type: ${(filter as any).type}`, {\n          context: { query: context.originalQuery },\n        });\n    }\n  }\n\n  private _generateDeletedHandlingSteps(context: GenerationContext): QueryPlan.Step[] {\n    switch (context.deletedHandling) {\n      case 'include':\n        return [];\n      case 'exclude':\n        return [\n          {\n            _tag: 'FilterDeletedStep',\n            mode: 'only-non-deleted',\n          },\n        ];\n      case 'only':\n        return [\n          {\n            _tag: 'FilterDeletedStep',\n            mode: 'only-deleted',\n          },\n        ];\n    }\n  }\n\n  private _generateUnionClause(query: QueryAST.QueryUnionClause, context: GenerationContext): QueryPlan.Plan {\n    return QueryPlan.Plan.make([\n      {\n        _tag: 'UnionStep',\n        plans: query.queries.map((query) => this._generate(query, context)),\n      },\n    ]);\n  }\n\n  private _generateSetDifferenceClause(\n    query: QueryAST.QuerySetDifferenceClause,\n    context: GenerationContext,\n  ): QueryPlan.Plan {\n    return QueryPlan.Plan.make([\n      {\n        _tag: 'SetDifferenceStep',\n        source: this._generate(query.source, context),\n        exclude: this._generate(query.exclude, context),\n      },\n    ]);\n  }\n\n  private _generateReferenceTraversalClause(\n    query: QueryAST.QueryReferenceTraversalClause,\n    context: GenerationContext,\n  ): QueryPlan.Plan {\n    return QueryPlan.Plan.make([\n      ...this._generate(query.anchor, context).steps,\n      {\n        _tag: 'TraverseStep',\n        traversal: {\n          _tag: 'ReferenceTraversal',\n          direction: 'outgoing',\n          property: query.property,\n        },\n      },\n      ...this._generateDeletedHandlingSteps(context),\n    ]);\n  }\n\n  private _generateIncomingReferencesClause(\n    query: QueryAST.QueryIncomingReferencesClause,\n    context: GenerationContext,\n  ): QueryPlan.Plan {\n    return QueryPlan.Plan.make([\n      ...this._generate(query.anchor, context).steps,\n      {\n        _tag: 'TraverseStep',\n        traversal: {\n          _tag: 'ReferenceTraversal',\n          direction: 'incoming',\n          property: query.property,\n        },\n      },\n      ...this._generateDeletedHandlingSteps(context),\n      {\n        _tag: 'FilterStep',\n        filter: {\n          type: 'object',\n          typename: query.typename,\n          props: {},\n        },\n      },\n    ]);\n  }\n\n  private _generateRelationTraversalClause(\n    query: QueryAST.QueryRelationTraversalClause,\n    context: GenerationContext,\n  ): QueryPlan.Plan {\n    switch (query.direction) {\n      case 'source': {\n        return QueryPlan.Plan.make([\n          ...this._generate(query.anchor, context).steps,\n          createRelationTraversalStep('relation-to-source'),\n          ...this._generateDeletedHandlingSteps(context),\n        ]);\n      }\n      case 'target': {\n        return QueryPlan.Plan.make([\n          ...this._generate(query.anchor, context).steps,\n          createRelationTraversalStep('relation-to-target'),\n          ...this._generateDeletedHandlingSteps(context),\n        ]);\n      }\n      case 'both': {\n        const anchorPlan = this._generate(query.anchor, context);\n        return QueryPlan.Plan.make([\n          ...anchorPlan.steps,\n          {\n            _tag: 'UnionStep',\n            plans: [\n              QueryPlan.Plan.make([createRelationTraversalStep('relation-to-source')]),\n              QueryPlan.Plan.make([createRelationTraversalStep('relation-to-target')]),\n            ],\n          },\n          ...this._generateDeletedHandlingSteps(context),\n        ]);\n      }\n    }\n  }\n\n  private _generateRelationClause(query: QueryAST.QueryRelationClause, context: GenerationContext): QueryPlan.Plan {\n    switch (query.direction) {\n      case 'outgoing': {\n        return QueryPlan.Plan.make([\n          ...this._generate(query.anchor, context).steps,\n          createRelationTraversalStep('source-to-relation'),\n          ...this._generateDeletedHandlingSteps(context),\n          {\n            _tag: 'FilterStep',\n            filter: query.filter ?? NOOP_FILTER,\n          },\n        ]);\n      }\n      case 'incoming': {\n        return QueryPlan.Plan.make([\n          ...this._generate(query.anchor, context).steps,\n          createRelationTraversalStep('target-to-relation'),\n          ...this._generateDeletedHandlingSteps(context),\n          {\n            _tag: 'FilterStep',\n            filter: query.filter ?? NOOP_FILTER,\n          },\n        ]);\n      }\n      case 'both': {\n        const anchorPlan = this._generate(query.anchor, context);\n        return QueryPlan.Plan.make([\n          ...anchorPlan.steps,\n          {\n            _tag: 'UnionStep',\n            plans: [\n              QueryPlan.Plan.make([createRelationTraversalStep('source-to-relation')]),\n              QueryPlan.Plan.make([createRelationTraversalStep('target-to-relation')]),\n            ],\n          },\n          ...this._generateDeletedHandlingSteps(context),\n          {\n            _tag: 'FilterStep',\n            filter: query.filter ?? NOOP_FILTER,\n          },\n        ]);\n      }\n    }\n  }\n\n  private _generateFilterClause(query: QueryAST.QueryFilterClause, context: GenerationContext): QueryPlan.Plan {\n    return QueryPlan.Plan.make([\n      ...this._generate(query.selection, context).steps,\n      {\n        _tag: 'FilterStep',\n        filter: query.filter,\n      },\n    ]);\n  }\n\n  /**\n   * Removes filter steps that have no predicates.\n   */\n  private _optimizeEmptyFilters(plan: QueryPlan.Plan): QueryPlan.Plan {\n    return QueryPlan.Plan.make(\n      plan.steps\n        .filter((step) => {\n          if (step._tag === 'FilterStep') {\n            return !QueryPlan.FilterStep.isNoop(step);\n          } else {\n            return true;\n          }\n        })\n        .map((step) => {\n          if (step._tag === 'UnionStep') {\n            return {\n              _tag: 'UnionStep',\n              plans: step.plans.map((plan) => this._optimizeEmptyFilters(plan)),\n            };\n          } else {\n            return step;\n          }\n        }),\n    );\n  }\n\n  /**\n   * Removes union steps that have only one child.\n   */\n  private _optimizeSoloUnions(plan: QueryPlan.Plan): QueryPlan.Plan {\n    // TODO(dmaretskyi): Implement this.\n    return plan;\n  }\n}\n\n/**\n * Context for query planning.\n */\ntype GenerationContext = {\n  /**\n   * The original query.\n   */\n  originalQuery: QueryAST.Query | null;\n\n  /**\n   * Which spaces to select from.\n   */\n  selectionSpaces: readonly SpaceId[];\n\n  /**\n   * How to handle deleted objects.\n   */\n  deletedHandling: 'include' | 'exclude' | 'only';\n\n  /**\n   * When generating a selection clause, whether to invert the filter.\n   */\n  selectionInverted: boolean;\n};\n\nconst DEFAULT_CONTEXT: GenerationContext = {\n  originalQuery: null,\n  selectionSpaces: [],\n  deletedHandling: 'exclude',\n  selectionInverted: false,\n};\n\nconst NOOP_FILTER: QueryAST.Filter = {\n  type: 'object',\n  typename: null,\n  id: [],\n  props: {},\n};\n\nconst createRelationTraversalStep = (direction: QueryPlan.RelationTraversal['direction']): QueryPlan.Step => ({\n  _tag: 'TraverseStep',\n  traversal: {\n    _tag: 'RelationTraversal',\n    direction,\n  },\n});\n\nconst isTrivialTypenameFilter = (filter: QueryAST.Filter): boolean => {\n  return (\n    filter.type === 'object' &&\n    filter.typename !== null &&\n    Object.keys(filter.props).length === 0 &&\n    (filter.id === undefined || filter.id.length === 0) &&\n    (filter.foreignKeys === undefined || filter.foreignKeys.length === 0)\n  );\n};\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { BaseError } from '@dxos/errors';\n\nexport class QueryError extends BaseError.extend('QUERY_ERROR') {}\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport type { QueryAST } from '@dxos/echo-protocol';\nimport type { EscapedPropPath } from '@dxos/indexing';\nimport type { DXN, ObjectId, SpaceId } from '@dxos/keys';\n\nexport namespace QueryPlan {\n  export type TextSearchKind = 'full-text' | 'vector' | 'hybrid';\n\n  /**\n   * A series of linear steps to execute a query.\n   * Steps can potentially contain sub-plans in case of unions.\n   *\n   * The query executor will execute each step in sequence.\n   * The plans start with a select step, which adds objects to the current working set.\n   * Then the next steps will act on the current working set, preforming filters, traversals, etc.\n   */\n  export type Plan = {\n    steps: Step[];\n  };\n\n  export const Plan = Object.freeze({\n    make: (steps: Step[]): Plan => ({ steps }),\n  });\n\n  export type Step =\n    | ClearWorkingSetStep\n    | SelectStep\n    | FilterStep\n    | FilterDeletedStep\n    | TraverseStep\n    | UnionStep\n    | SetDifferenceStep;\n\n  /**\n   * Clear the current working set.\n   */\n  export type ClearWorkingSetStep = {\n    _tag: 'ClearWorkingSetStep';\n  };\n\n  /**\n   * Select objects based on id, typename, or other predicates.\n   * Specifies the spaces to select from.\n   */\n  export type SelectStep = {\n    _tag: 'SelectStep';\n\n    spaces: readonly SpaceId[];\n    selector: Selector;\n  };\n\n  /**\n   * Specifier to scan the database for objects.\n   * Optimized to utilize database indexes.\n   */\n  export type Selector = WildcardSelector | IdSelector | TypeSelector | TextSelector;\n\n  export type WildcardSelector = {\n    _tag: 'WildcardSelector';\n  };\n\n  export type IdSelector = {\n    _tag: 'IdSelector';\n\n    objectIds: readonly ObjectId[];\n  };\n\n  /**\n   * Select objects by typename.\n   * Supports passing an array of typenames and an optional inverse flag to optimize for index implementation.\n   */\n  export type TypeSelector = {\n    _tag: 'TypeSelector';\n\n    typename: DXN.String[];\n    /**\n     * If true, select objects that do not match the typename.\n     */\n    inverted: boolean;\n  };\n\n  /**\n   * Select objects by preforming a full-text or vector search.\n   */\n  export type TextSelector = {\n    _tag: 'TextSelector';\n\n    text: string;\n    searchKind: TextSearchKind;\n  };\n\n  /**\n   * Filter objects in the current working set based on a predicate.\n   */\n  export type FilterStep = {\n    _tag: 'FilterStep';\n\n    filter: QueryAST.Filter;\n  };\n\n  export const FilterStep = Object.freeze({\n    isNoop: (step: FilterStep): boolean => {\n      switch (step.filter.type) {\n        case 'object': {\n          // TODO(dmaretskyi): This is error-prone, it could easily break if we add more clauses.\n          return (\n            step.filter.typename === null &&\n            (step.filter.id === undefined || step.filter.id.length === 0) &&\n            (step.filter.props === undefined || Object.keys(step.filter.props).length === 0) &&\n            (step.filter.foreignKeys === undefined || step.filter.foreignKeys.length === 0)\n          );\n        }\n        default:\n          return false;\n      }\n    },\n  });\n\n  /**\n   * Filter objects in the current working set based on the deleted state.\n   */\n  export type FilterDeletedStep = {\n    _tag: 'FilterDeletedStep';\n\n    mode: 'only-deleted' | 'only-non-deleted';\n  };\n\n  /**\n   * Traverse the object graph, starting from objects in the current working set.\n   */\n  export type TraverseStep = {\n    _tag: 'TraverseStep';\n\n    traversal: Traversal;\n  };\n\n  /**\n   * Describes a traversal of the object graph.\n   */\n  export type Traversal = ReferenceTraversal | RelationTraversal;\n\n  /**\n   * Traverse a reference connection.\n   */\n  export type ReferenceTraversal = {\n    _tag: 'ReferenceTraversal';\n\n    /**\n     * Property path where the reference is located.\n     */\n    property: EscapedPropPath;\n\n    /**\n     * outgoing: the reference points from the anchor object to the target.\n     * incoming: the reference points to the anchor object from the target.\n     */\n    direction: 'outgoing' | 'incoming';\n  };\n\n  /**\n   * Traverse a relation.\n   */\n  export type RelationTraversal = {\n    _tag: 'RelationTraversal';\n\n    /**\n     * The direction of the traversal.\n     * There are for variants since each relation has two connectors (source & target) and there are two directions to traverse each.\n     */\n    direction: 'source-to-relation' | 'relation-to-source' | 'target-to-relation' | 'relation-to-target';\n  };\n\n  /**\n   * Combine results from multiple plans.\n   * Each of the plans starts with a copy of the current working set.\n   * This supports plans where we first perform a selection, then traverse in different directions, and then combine the results.\n   */\n  export type UnionStep = {\n    _tag: 'UnionStep';\n\n    plans: Plan[];\n  };\n\n  /**\n   * Subtract the results of one plan from another.\n   */\n  export type SetDifferenceStep = {\n    _tag: 'SetDifferenceStep';\n\n    source: Plan;\n    exclude: Plan;\n  };\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { interpretAsDocumentId, type DocHandle, type DocumentId } from '@automerge/automerge-repo';\nimport isEqual from 'lodash.isequal';\n\nimport { Event, UpdateScheduler } from '@dxos/async';\nimport { Resource, Context, LifecycleState } from '@dxos/context';\nimport { type DatabaseDirectory } from '@dxos/echo-protocol';\nimport { invariant } from '@dxos/invariant';\nimport { type SpaceId } from '@dxos/keys';\n\nimport { DatabaseRoot } from './database-root';\n\nexport class SpaceStateManager extends Resource {\n  private readonly _roots = new Map<DocumentId, DatabaseRoot>();\n  private readonly _rootBySpace = new Map<SpaceId, DocumentId>();\n  private readonly _perRootContext = new Map<DocumentId, Context>();\n  private readonly _lastSpaceDocumentList = new Map<SpaceId, DocumentId[]>();\n\n  public readonly spaceDocumentListUpdated = new Event<SpaceDocumentListUpdatedEvent>();\n\n  protected override async _close(ctx: Context): Promise<void> {\n    for (const [_, rootCtx] of this._perRootContext) {\n      await rootCtx.dispose();\n    }\n    this._roots.clear();\n  }\n\n  get roots(): ReadonlyMap<DocumentId, DatabaseRoot> {\n    return this._roots;\n  }\n\n  getRootByDocumentId(documentId: DocumentId): DatabaseRoot | undefined {\n    return this._roots.get(documentId);\n  }\n\n  getSpaceRootDocumentId(spaceId: SpaceId): DocumentId | undefined {\n    return this._rootBySpace.get(spaceId);\n  }\n\n  getRootBySpaceId(spaceId: SpaceId): DatabaseRoot | undefined {\n    invariant(this._lifecycleState === LifecycleState.OPEN);\n    const documentId = this._rootBySpace.get(spaceId);\n    if (!documentId) {\n      return undefined;\n    }\n    return this._roots.get(documentId);\n  }\n\n  async assignRootToSpace(spaceId: SpaceId, handle: DocHandle<DatabaseDirectory>): Promise<DatabaseRoot> {\n    let root: DatabaseRoot;\n    if (this._roots.has(handle.documentId)) {\n      root = this._roots.get(handle.documentId)!;\n    } else {\n      root = new DatabaseRoot(handle);\n      this._roots.set(handle.documentId, root);\n    }\n\n    if (this._rootBySpace.get(spaceId) === root.handle.documentId) {\n      return root;\n    }\n\n    const prevRootId = this._rootBySpace.get(spaceId);\n    if (prevRootId) {\n      void this._perRootContext.get(prevRootId)?.dispose();\n      this._perRootContext.delete(prevRootId);\n    }\n\n    this._rootBySpace.set(spaceId, root.handle.documentId);\n    const ctx = new Context();\n\n    this._perRootContext.set(root.handle.documentId, ctx);\n\n    await root.handle.whenReady();\n\n    const documentListCheckScheduler = new UpdateScheduler(\n      ctx,\n      async () => {\n        const documentIds = [root.documentId, ...root.getAllLinkedDocuments().map((url) => interpretAsDocumentId(url))];\n        if (!isEqual(documentIds, this._lastSpaceDocumentList.get(spaceId))) {\n          this._lastSpaceDocumentList.set(spaceId, documentIds);\n          this.spaceDocumentListUpdated.emit(\n            new SpaceDocumentListUpdatedEvent(spaceId, root.documentId, prevRootId, documentIds),\n          );\n        }\n      },\n      { maxFrequency: 50 },\n    );\n    const triggerCheckOnChange = () => documentListCheckScheduler.trigger();\n    root.handle.addListener('change', triggerCheckOnChange);\n    ctx.onDispose(() => root.handle.removeListener('change', triggerCheckOnChange));\n\n    documentListCheckScheduler.trigger();\n\n    return root;\n  }\n}\n\nexport class SpaceDocumentListUpdatedEvent {\n  constructor(\n    public readonly spaceId: SpaceId,\n    public readonly spaceRootId: DocumentId,\n    public readonly previousRootId: DocumentId | undefined,\n    public readonly documentIds: DocumentId[],\n  ) {}\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport type * as A from '@automerge/automerge';\nimport { interpretAsDocumentId, type AutomergeUrl, type DocHandle, type DocumentId } from '@automerge/automerge-repo';\n\nimport { DatabaseDirectory, SpaceDocVersion } from '@dxos/echo-protocol';\nimport { invariant } from '@dxos/invariant';\n\nimport { measureDocMetrics, type DocMetrics } from './automerge-metrics';\n\nexport class DatabaseRoot {\n  static mapLinks(doc: DocHandle<DatabaseDirectory>, mapping: Record<DocumentId, DocumentId>): void {\n    doc.change((d) => {\n      if (!d.links) {\n        return;\n      }\n      for (const [key, value] of Object.entries(d.links)) {\n        const documentId = interpretAsDocumentId(value.toString() as any);\n        if (mapping[documentId]) {\n          d.links[key] = `automerge:${mapping[documentId]}`;\n        }\n      }\n    });\n  }\n\n  constructor(private readonly _rootHandle: DocHandle<DatabaseDirectory>) {}\n\n  get documentId(): DocumentId {\n    return this._rootHandle.documentId;\n  }\n\n  get url() {\n    return this._rootHandle.url;\n  }\n\n  get isLoaded(): boolean {\n    return this._rootHandle.isReady();\n  }\n\n  get handle(): DocHandle<DatabaseDirectory> {\n    return this._rootHandle;\n  }\n\n  doc(): A.Doc<DatabaseDirectory> | null {\n    return this._rootHandle.isReady() ? this._rootHandle.doc() : null;\n  }\n\n  getVersion(): SpaceDocVersion | null {\n    const doc = this.doc();\n    if (!doc) {\n      return null;\n    }\n\n    return doc.version ?? SpaceDocVersion.LEGACY;\n  }\n\n  getSpaceKey(): string | null {\n    const doc = this.doc();\n    if (!doc) {\n      return null;\n    }\n\n    return DatabaseDirectory.getSpaceKey(doc);\n  }\n\n  getInlineObjectCount(): number | null {\n    const doc = this.doc();\n    if (!doc) {\n      return null;\n    }\n\n    return Object.keys(doc.objects ?? {}).length;\n  }\n\n  getLinkedObjectCount(): number | null {\n    const doc = this.doc();\n    if (!doc) {\n      return null;\n    }\n\n    return Object.keys(doc.links ?? {}).length;\n  }\n\n  getAllLinkedDocuments(): AutomergeUrl[] {\n    const doc = this.doc();\n    invariant(doc);\n\n    // .toString() to handle RawString.\n    return Object.values(doc.links ?? {}).map((s) => s.toString()) as AutomergeUrl[];\n  }\n\n  measureMetrics(): DocMetrics | null {\n    const doc = this.doc();\n    if (!doc) {\n      return null;\n    }\n    return measureDocMetrics(doc);\n  }\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport * as A from '@automerge/automerge';\n\nimport { log } from '@dxos/log';\n\nexport type DocMetrics = {\n  compressedByteSize: number;\n  loadTime: number;\n  mutationCount: number;\n};\n\n/**\n * WARN: Slow to run on large docs.\n */\nexport const measureDocMetrics = (doc: A.Doc<any>): DocMetrics => {\n  const snapshot = A.save(doc);\n\n  const start = Date.now();\n  const temp = A.load(snapshot);\n  const end = Date.now();\n  A.free(temp);\n\n  const getAllChangesStart = Date.now();\n  const mutationCount = A.getAllChanges(doc).length;\n  const getAllChangesEnd = Date.now();\n\n  if (getAllChangesEnd - getAllChangesStart > 300) {\n    log.warn('getAllChanges took too long', { elapsed: getAllChangesEnd - getAllChangesStart });\n  }\n\n  return {\n    compressedByteSize: snapshot.byteLength,\n    loadTime: end - start,\n    mutationCount,\n  };\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { cbor } from '@automerge/automerge-repo';\n\nimport { Mutex, scheduleTask, scheduleMicroTask } from '@dxos/async';\nimport { Context, Resource } from '@dxos/context';\nimport { randomUUID } from '@dxos/crypto';\nimport type { CollectionId } from '@dxos/echo-protocol';\nimport { type EdgeConnection } from '@dxos/edge-client';\nimport { invariant } from '@dxos/invariant';\nimport type { SpaceId } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { EdgeService, type AutomergeProtocolMessage, type PeerId } from '@dxos/protocols';\nimport { buf } from '@dxos/protocols/buf';\nimport {\n  type Message as RouterMessage,\n  MessageSchema as RouterMessageSchema,\n} from '@dxos/protocols/buf/dxos/edge/messenger_pb';\nimport { bufferToArray } from '@dxos/util';\n\nimport { InflightRequestLimiter } from './inflight-request-limiter';\nimport {\n  getSpaceIdFromCollectionId,\n  type EchoReplicator,\n  type EchoReplicatorContext,\n  type ReplicatorConnection,\n  type ShouldAdvertiseParams,\n  type ShouldSyncCollectionParams,\n} from '../automerge';\n\n/**\n * Delay before restarting the connection after receiving a forbidden error.\n */\nconst INITIAL_RESTART_DELAY = 500;\nconst RESTART_DELAY_JITTER = 250;\nconst MAX_RESTART_DELAY = 5000;\n\nexport type EchoEdgeReplicatorParams = {\n  edgeConnection: EdgeConnection;\n  disableSharePolicy?: boolean;\n};\n\nexport class EchoEdgeReplicator implements EchoReplicator {\n  private readonly _edgeConnection: EdgeConnection;\n  private readonly _mutex = new Mutex();\n\n  private _ctx?: Context = undefined;\n  private _context: EchoReplicatorContext | null = null;\n  private _connectedSpaces = new Set<SpaceId>();\n  private _connections = new Map<SpaceId, EdgeReplicatorConnection>();\n  private _sharePolicyEnabled = true;\n\n  constructor({ edgeConnection, disableSharePolicy }: EchoEdgeReplicatorParams) {\n    this._edgeConnection = edgeConnection;\n    this._sharePolicyEnabled = !disableSharePolicy;\n  }\n\n  async connect(context: EchoReplicatorContext): Promise<void> {\n    log('connecting...', { peerId: context.peerId, connectedSpaces: this._connectedSpaces.size });\n    this._context = context;\n    this._ctx = Context.default();\n    this._ctx.onDispose(\n      this._edgeConnection.onReconnected(() => {\n        this._ctx && scheduleMicroTask(this._ctx, () => this._handleReconnect());\n      }),\n    );\n  }\n\n  private async _handleReconnect(): Promise<void> {\n    using _guard = await this._mutex.acquire();\n\n    const spaces = [...this._connectedSpaces];\n    for (const connection of this._connections.values()) {\n      await connection.close();\n    }\n    this._connections.clear();\n\n    if (this._context !== null) {\n      for (const spaceId of spaces) {\n        await this._openConnection(spaceId);\n      }\n    }\n  }\n\n  async disconnect(): Promise<void> {\n    using _guard = await this._mutex.acquire();\n    await this._ctx?.dispose();\n\n    for (const connection of this._connections.values()) {\n      await connection.close();\n    }\n    this._connections.clear();\n  }\n\n  async connectToSpace(spaceId: SpaceId): Promise<void> {\n    using _guard = await this._mutex.acquire();\n\n    if (this._connectedSpaces.has(spaceId)) {\n      return;\n    }\n    this._connectedSpaces.add(spaceId);\n\n    // Check if AM-repo requested that we connect to remote peers.\n    if (this._context !== null) {\n      await this._openConnection(spaceId);\n    }\n  }\n\n  async disconnectFromSpace(spaceId: SpaceId): Promise<void> {\n    using _guard = await this._mutex.acquire();\n\n    this._connectedSpaces.delete(spaceId);\n\n    const connection = this._connections.get(spaceId);\n    if (connection) {\n      await connection.close();\n      this._connections.delete(spaceId);\n    }\n  }\n\n  private async _openConnection(spaceId: SpaceId, reconnects: number = 0): Promise<void> {\n    invariant(this._context);\n    invariant(!this._connections.has(spaceId));\n\n    let restartScheduled = false;\n\n    const connection = new EdgeReplicatorConnection({\n      edgeConnection: this._edgeConnection,\n      spaceId,\n      context: this._context,\n      sharedPolicyEnabled: this._sharePolicyEnabled,\n      onRemoteConnected: async () => {\n        this._context?.onConnectionOpen(connection);\n      },\n      onRemoteDisconnected: async () => {\n        this._context?.onConnectionClosed(connection);\n      },\n      onRestartRequested: async () => {\n        if (!this._ctx || restartScheduled) {\n          return;\n        }\n\n        const restartDelay =\n          Math.min(MAX_RESTART_DELAY, INITIAL_RESTART_DELAY * reconnects) + Math.random() * RESTART_DELAY_JITTER;\n\n        log('connection restart scheduled', { spaceId, reconnects, restartDelay });\n\n        restartScheduled = true;\n        scheduleTask(\n          this._ctx,\n          async () => {\n            using _guard = await this._mutex.acquire();\n            if (this._connections.get(spaceId) !== connection) {\n              return;\n            }\n\n            const ctx = this._ctx;\n            await connection.close(); // Will call onRemoteDisconnected\n            this._connections.delete(spaceId);\n            if (ctx?.disposed) {\n              return;\n            }\n            await this._openConnection(spaceId, reconnects + 1);\n          },\n          restartDelay,\n        );\n      },\n    });\n    this._connections.set(spaceId, connection);\n\n    await connection.open();\n  }\n}\n\ntype EdgeReplicatorConnectionsParams = {\n  edgeConnection: EdgeConnection;\n  spaceId: SpaceId;\n  context: EchoReplicatorContext;\n  sharedPolicyEnabled: boolean;\n  onRemoteConnected: () => Promise<void>;\n  onRemoteDisconnected: () => Promise<void>;\n  onRestartRequested: () => Promise<void>;\n};\n\nconst MAX_INFLIGHT_REQUESTS = 5;\nconst MAX_RATE_LIMIT_WAIT_TIME_MS = 3000;\n\nclass EdgeReplicatorConnection extends Resource implements ReplicatorConnection {\n  private readonly _edgeConnection: EdgeConnection;\n  private readonly _remotePeerId: string | null = null;\n  private readonly _targetServiceId: string;\n  private readonly _spaceId: SpaceId;\n  private readonly _context: EchoReplicatorContext;\n  private readonly _sharedPolicyEnabled: boolean;\n  private readonly _onRemoteConnected: () => Promise<void>;\n  private readonly _onRemoteDisconnected: () => Promise<void>;\n  private readonly _onRestartRequested: () => void;\n\n  private _requestLimiter = new InflightRequestLimiter({\n    maxInflightRequests: MAX_INFLIGHT_REQUESTS,\n    resetBalanceTimeoutMs: MAX_RATE_LIMIT_WAIT_TIME_MS,\n  });\n\n  private _readableStreamController!: ReadableStreamDefaultController<AutomergeProtocolMessage>;\n\n  public readable: ReadableStream<AutomergeProtocolMessage>;\n  public writable: WritableStream<AutomergeProtocolMessage>;\n\n  constructor({\n    edgeConnection,\n    spaceId,\n    context,\n    sharedPolicyEnabled,\n    onRemoteConnected,\n    onRemoteDisconnected,\n    onRestartRequested,\n  }: EdgeReplicatorConnectionsParams) {\n    super();\n    this._edgeConnection = edgeConnection;\n    this._spaceId = spaceId;\n    this._context = context;\n    // Generate a unique peer id for every connection.\n    // This way automerge-repo will have separate sync states for every connection.\n    // This is important because the previous connection might have had some messages that failed to deliver\n    // abd if we don't clear the sync-state, automerge will not attempt to deliver them again.\n    this._remotePeerId = `${EdgeService.AUTOMERGE_REPLICATOR}:${spaceId}-${randomUUID()}`;\n    this._targetServiceId = `${EdgeService.AUTOMERGE_REPLICATOR}:${spaceId}`;\n    this._sharedPolicyEnabled = sharedPolicyEnabled;\n    this._onRemoteConnected = onRemoteConnected;\n    this._onRemoteDisconnected = onRemoteDisconnected;\n    this._onRestartRequested = onRestartRequested;\n\n    this.readable = new ReadableStream<AutomergeProtocolMessage>({\n      start: (controller) => {\n        this._readableStreamController = controller;\n      },\n    });\n\n    this.writable = new WritableStream<AutomergeProtocolMessage>({\n      write: async (message: AutomergeProtocolMessage, controller) => {\n        await this._requestLimiter.rateLimit(message);\n\n        await this._sendMessage(message);\n      },\n    });\n  }\n\n  protected override async _open(ctx: Context): Promise<void> {\n    log('opening...');\n\n    await this._requestLimiter.open();\n\n    // TODO: handle reconnects\n    this._ctx.onDispose(\n      this._edgeConnection.onMessage((msg: RouterMessage) => {\n        this._onMessage(msg);\n      }),\n    );\n\n    await this._onRemoteConnected();\n  }\n\n  protected override async _close(): Promise<void> {\n    log('closing...');\n    this._readableStreamController.close();\n\n    await this._requestLimiter.close();\n\n    await this._onRemoteDisconnected();\n  }\n\n  get peerId(): string {\n    invariant(this._remotePeerId, 'Not connected');\n    return this._remotePeerId;\n  }\n\n  async shouldAdvertise(params: ShouldAdvertiseParams): Promise<boolean> {\n    if (!this._sharedPolicyEnabled) {\n      return true;\n    }\n    const spaceId = await this._context.getContainingSpaceIdForDocument(params.documentId);\n    if (!spaceId) {\n      const remoteDocumentExists = await this._context.isDocumentInRemoteCollection({\n        documentId: params.documentId,\n        peerId: this._remotePeerId as PeerId,\n      });\n\n      log.verbose('document not found locally for share policy check', {\n        documentId: params.documentId,\n        acceptDocument: remoteDocumentExists,\n        remoteId: this._remotePeerId,\n      });\n\n      // If a document is not present locally return true only if it already exists on edge.\n      // Simply returning true will add edge to \"generous peers list\" for this document which will\n      // start replication of the document after we receive it potentially pushing it to replicator of the wrong space.\n      return remoteDocumentExists;\n    }\n    return spaceId === this._spaceId;\n  }\n\n  shouldSyncCollection(params: ShouldSyncCollectionParams): boolean {\n    if (!this._sharedPolicyEnabled) {\n      return true;\n    }\n    const spaceId = getSpaceIdFromCollectionId(params.collectionId as CollectionId);\n    // Only sync collections of form space:id:rootDoc, edge ignores legacy space:id collections\n    return spaceId === this._spaceId && params.collectionId.split(':').length === 3;\n  }\n\n  private _onMessage(message: RouterMessage): void {\n    if (message.serviceId !== this._targetServiceId) {\n      return;\n    }\n\n    const payload = cbor.decode(message.payload!.value) as AutomergeProtocolMessage;\n    log.verbose('received', {\n      type: payload.type,\n      documentId: payload.type === 'sync' && payload.documentId,\n      remoteId: this._remotePeerId,\n    });\n\n    // Fix the peer id.\n    payload.senderId = this._remotePeerId! as PeerId;\n    this._processMessage(payload);\n  }\n\n  private _processMessage(message: AutomergeProtocolMessage): void {\n    // There's a race between the credentials being replicated that are needed for access control and the data replication.\n    // AutomergeReplicator might return a Forbidden error if the credentials are not yet replicated.\n    // We restart the connection with some delay to account for that.\n    if (isForbiddenErrorMessage(message)) {\n      this._onRestartRequested();\n      return;\n    }\n\n    this._requestLimiter.handleResponse(message);\n\n    this._readableStreamController.enqueue(message);\n  }\n\n  private async _sendMessage(message: AutomergeProtocolMessage): Promise<void> {\n    // Fix the peer id.\n    (message as any).targetId = this._targetServiceId as PeerId;\n\n    log.verbose('sending...', {\n      type: message.type,\n      documentId: message.type === 'sync' && message.documentId,\n      remoteId: this._remotePeerId,\n    });\n\n    const encoded = cbor.encode(message);\n\n    await this._edgeConnection.send(\n      buf.create(RouterMessageSchema, {\n        serviceId: this._targetServiceId,\n        source: {\n          identityKey: this._edgeConnection.identityKey,\n          peerKey: this._edgeConnection.peerKey,\n        },\n        payload: { value: bufferToArray(encoded) },\n      }),\n    );\n  }\n}\n\n/**\n * This message is sent by EDGE AutomergeReplicator when the authorization is denied.\n */\nconst isForbiddenErrorMessage = (message: AutomergeProtocolMessage) =>\n  message.type === 'error' && message.message === 'Forbidden';\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { Trigger } from '@dxos/async';\nimport { Resource } from '@dxos/context';\nimport { log } from '@dxos/log';\nimport { type AutomergeProtocolMessage } from '@dxos/protocols';\n\ntype InflightRequestLimiterConfig = {\n  maxInflightRequests: number;\n  resetBalanceTimeoutMs: number;\n};\n\nexport class InflightRequestLimiter extends Resource {\n  /**\n   * Decrement when we receive a sync message, increment when we send one.\n   * Can't exceed _config.maxInflightRequests.\n   * Resets after timeout to avoid replicator being stuck.\n   */\n  private _inflightRequestBalance = 0;\n  private _requestBarrier = new Trigger();\n  private _resetBalanceTimeout: NodeJS.Timeout | undefined;\n\n  constructor(private readonly _config: InflightRequestLimiterConfig) {\n    super();\n  }\n\n  protected override async _open(): Promise<void> {\n    this._inflightRequestBalance = 0;\n    this._requestBarrier.reset();\n    this._requestBarrier.wake();\n  }\n\n  protected override async _close(): Promise<void> {\n    this._inflightRequestBalance = 0;\n    this._requestBarrier.throw(new Error('Rate limiter closed.'));\n    clearTimeout(this._resetBalanceTimeout);\n  }\n\n  public async rateLimit(message: AutomergeProtocolMessage): Promise<void> {\n    if (message.type !== 'sync') {\n      return;\n    }\n    while (this._inflightRequestBalance >= this._config.maxInflightRequests) {\n      await this._requestBarrier.wait();\n    }\n    this._inflightRequestBalance++;\n    if (this._inflightRequestBalance === this._config.maxInflightRequests) {\n      this._requestBarrier.reset();\n      this._resetBalanceTimeout = setTimeout(() => {\n        log.warn('Request balance has not changed during specified timeout, resetting request limiter.');\n        this._inflightRequestBalance = 0;\n        this._requestBarrier.wake();\n      }, this._config.resetBalanceTimeoutMs);\n    }\n  }\n\n  public handleResponse(message: AutomergeProtocolMessage): void {\n    if (message.type !== 'sync') {\n      return;\n    }\n    this._inflightRequestBalance--;\n    if (this._inflightRequestBalance + 1 === this._config.maxInflightRequests) {\n      this._requestBarrier.wake();\n      clearInterval(this._resetBalanceTimeout);\n    }\n  }\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { decodeReference, ObjectStructure, type DatabaseDirectory } from '@dxos/echo-protocol';\n\n/**\n * Assumes properties are at root.\n */\nexport const findInlineObjectOfType = (\n  spaceDoc: DatabaseDirectory,\n  typename: string,\n): [string, ObjectStructure] | undefined => {\n  for (const id in spaceDoc.objects ?? {}) {\n    const obj = spaceDoc.objects![id];\n    const objType = ObjectStructure.getTypeReference(obj);\n    if (objType && decodeReference(objType).objectId === typename) {\n      return [id, obj];\n    }\n  }\n\n  return undefined;\n};\n"],
  "mappings": "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",
  "names": ["import_async", "import_invariant", "import_log", "import_automerge", "import_context", "import_keys", "import_tracing", "import_util", "import_automerge_repo", "import_protocols", "import_echo_protocol", "import_indexing", "import_stream", "import_debug", "import_effect", "MIN_QUERY_INTERVAL", "POLL_INTERVAL", "CollectionSynchronizer", "Resource", "params", "Map", "_activeCollections", "Set", "_connectedPeers", "remoteStateUpdated", "Event", "_sendCollectionState", "sendCollectionState", "_queryCollectionState", "queryCollectionState", "_shouldSyncCollection", "shouldSyncCollection", "_open", "ctx", "scheduleTaskInterval", "_ctx", "collectionId", "_perCollectionStates", "keys", "has", "refreshCollection", "asyncReturn", "getRegisteredCollectionIds", "getLocalCollectionState", "get", "localState", "setLocalCollectionState", "state", "add", "log", "_getOrCreatePerCollectionState", "queueMicrotask", "disposed", "_refreshInterestedPeers", "clearLocalCollectionState", "delete", "getRemoteCollectionStates", "remoteStates", "scheduleAnotherRefresh", "peerId", "interestedPeers", "lastQueried", "Date", "now", "set", "scheduleTask", "onConnectionOpen", "spanId", "getSpanName", "trace", "spanStart", "id", "methodName", "instance", "parentCtx", "showInBrowserTimeline", "attributes", "entries", "onConnectionClosed", "perCollectionState", "values", "onCollectionStateQueried", "onRemoteStateReceived", "validateCollectionState", "existingState", "documents", "diff", "diffCollectionState", "different", "length", "spanEnd", "missingOnLocal", "emit", "newDocsAppeared", "defaultMap", "undefined", "resource", "local", "remote", "allDocuments", "Object", "missingOnRemote", "documentId", "push", "am", "equals", "forEach", "heads", "isValidDocumentId", "Error", "Array", "isArray", "some", "head", "includes", "isCollectionQueryMessage", "message", "type", "MESSAGE_TYPE_COLLECTION_QUERY", "isCollectionStateMessage", "MESSAGE_TYPE_COLLECTION_STATE", "EchoNetworkAdapter", "NetworkAdapter", "_params", "_replicators", "_connections", "_lifecycleState", "LifecycleState", "CLOSED", "_connected", "Trigger", "_ready", "isReady", "OPEN", "whenReady", "wait", "connect", "peerMetadata", "wake", "send", "_send", "disconnect", "open", "close", "replicator", "clear", "reset", "whenConnected", "timeout", "onConnectionAuthScopeChanged", "peer", "entry", "_onConnectionAuthScopeChanged", "connection", "addReplicator", "invariant", "_onConnectionOpen", "bind", "_onConnectionClosed", "isDocumentInRemoteCollection", "getContainingSpaceForDocument", "getContainingSpaceIdForDocument", "key", "createIdFromSpaceKey", "removeReplicator", "shouldAdvertise", "targetId", "senderId", "getPeersInterestedInCollection", "from", "map", "filter", "isNonNullable", "connectionEntry", "start", "writer", "write", "then", "monitor", "recordMessageSent", "catch", "err", "isOpen", "recordMessageSendingFailed", "reader", "readable", "getReader", "writable", "getWriter", "done", "value", "read", "_onMessage", "_emitPeerCandidate", "recordPeerConnected", "onCollectionStateReceived", "recordMessageReceived", "recordPeerDisconnected", "cancel", "abort", "createEchoPeerMetadata", "dxos_peerSource", "isEchoPeerMetadata", "metadata", "HeadsStore", "db", "_db", "setHeads", "batch", "put", "sublevel", "keyEncoding", "valueEncoding", "headsEncoding", "getHeads", "documentIds", "getMany", "LevelDBStorageAdapter", "load", "keyArray", "startMs", "chunk", "encodingOptions", "recordBytesLoaded", "byteLength", "recordLoadDuration", "isLevelDbNotFoundError", "save", "binary", "callbacks", "beforeSave", "path", "Buffer", "recordBytesStored", "afterSave", "recordStoreDuration", "remove", "del", "loadRange", "keyPrefix", "result", "iterator", "gte", "lte", "data", "removeRange", "keyEncoder", "encode", "k", "replaceAll", "join", "decode", "toString", "split", "format", "code", "FIND_PARAMS", "allowableStates", "AutomergeHost", "indexMetadataStore", "dataMonitor", "peerIdProvider", "getSpaceKeyByRootDocumentId", "_collectionSynchronizer", "collectionStateUpdated", "_storage", "_beforeSave", "_afterSave", "_echoNetworkAdapter", "_getContainingSpaceForDocument", "_isDocumentInRemoteCollection", "_onCollectionStateQueried", "_onCollectionStateReceived", "_headsStore", "_indexMetadataStore", "_peerIdProvider", "_getSpaceKeyByRootDocumentId", "_peerId", "PublicKey", "random", "toHex", "_repo", "Repo", "sharePolicy", "_sharePolicy", "storage", "network", "updatingAuthScope", "wrap", "on", "e", "_onPeerConnected", "_onPeerDisconnected", "_onRemoteCollectionStateUpdated", "_close", "dispose", "repo", "loadedDocsCount", "handles", "loadDoc", "opts", "handle", "find", "cancelWithContext", "asyncTimeout", "exportDoc", "interpretAsDocumentId", "chunks", "bufferToArray", "concat", "c", "createDoc", "initialValue", "preserveHistory", "Uint8Array", "import", "isAutomerge", "TypeError", "create", "waitUntilHeadsReplicated", "documentHeads", "headsToWait", "index", "targetHeads", "currentHeads", "headsEquals", "Promise", "all", "Context", "default", "waitForHeads", "flush", "reIndexHeads", "warn", "startsWith", "peerMetadataByPeerId", "doc", "spaceKey", "DatabaseDirectory", "getSpaceKey", "objectIds", "objects", "encodedIds", "objectId", "objectPointerCodec", "idToLastHash", "markDirty", "notifyMarkedDirty", "document", "_onHeadsChanged", "documentsSaved", "_automergePeers", "peers", "remoteCollections", "remotePeerDocs", "spaceKeyHex", "rootDocSpaceKey", "loadedDocuments", "storeRequestIds", "storeResultIndices", "storedHeads", "i", "getCollectionSyncState", "remoteState", "differentDocuments", "localDocumentCount", "remoteDocumentCount", "updateLocalCollectionState", "fromEntries", "decodeCollectionState", "encodeCollectionState", "toReplicate", "count", "findWithProgress", "collectionsChanged", "newState", "structuredClone", "info", "depth", "span", "unavailableHeads", "waitForCondition", "changeHash", "changeIsPresentInDoc", "size", "getBackend", "getChangeByHash", "DEFAULT_FACTORY", "AutomergeReplicator", "MeshReplicatorConnection", "remoteDeviceKey", "_remotePeerId", "_isEnabled", "readableStreamController", "ReadableStream", "controller", "onDispose", "WritableStream", "logSendSync", "replicatorExtension", "sendSyncMessage", "payload", "cbor", "error", "_disconnectIfEnabled", "createAutomergeReplicator", "replicatorFactory", "ownPeerId", "onStartReplication", "remotePeerId", "thisPeerId", "onRemoteConnected", "onSyncMessage", "enqueue", "onClose", "onRemoteDisconnected", "isEnabled", "enable", "disable", "decodedSyncMessage", "decodeSyncMessage", "sync", "headsLength", "requesting", "need", "sendingChanges", "changes", "to", "deriveCollectionIdFromSpaceId", "spaceId", "rootDocumentId", "getSpaceIdFromCollectionId", "SpaceId", "isValid", "MeshEchoReplicator", "_context", "context", "_connectionsPerPeer", "createExtension", "extensionFactory", "existingConnections", "enabledConnection", "indexOf", "splice", "remoteDocumentExists", "acceptDocument", "authorizedDevices", "_authorizedDevices", "isAuthorized", "localPeer", "remotePeer", "deviceKey", "authorizeDevice", "ComplexSet", "hash", "PER_SECOND_RATE_AVG_WINDOW_SIZE", "DEFAULT_AVG_WINDOW_SIZE", "EchoDataMonitor", "timeSeriesLength", "_lastTick", "_activeCounters", "createLocalCounters", "_localTimeSeries", "createLocalTimeSeries", "_storageAverages", "createStorageAverages", "_replicationAverages", "createNetworkAverages", "_sizeByMessage", "_lastReceivedMessages", "CircularBuffer", "_lastSentMessages", "_connectionsCount", "tick", "timeMs", "_advanceTimeWindow", "computeStats", "meta", "rateAverageOverSeconds", "reads", "payloadSize", "loadedChunkSize", "average", "opDuration", "loadDuration", "countPerSecond", "loadsPerSecond", "writes", "storedChunkSize", "storeDuration", "storesPerSecond", "connections", "receivedMessages", "receivedMessageSize", "receivedPerSecond", "sentMessages", "sentMessageSize", "sendDuration", "sentPerSecond", "failedPerSecond", "sendsFailedPerSecond", "countByMessage", "_computeMessageHistogram", "avgSizeByMessage", "mapValues", "summary", "connectionsCount", "lastPerSecondStats", "_lastCompleteCounters", "timeSeries", "replication", "messagesByPeerId", "millisPassed", "oldMetrics", "freeze", "byPeerId", "createMessageCounter", "_addToTimeSeries", "Math", "abs", "_reportPerSecondRate", "shift", "metrics", "toReport", "loadedChunks", "storedChunks", "received", "sent", "metricName", "metric", "record", "distribution", "increment", "tags", "status", "failed", "storedBytes", "unit", "durationMs", "loadedBytes", "duration", "metricsGroupName", "bytes", "getByteCount", "isAutomergeProtocolMessage", "success", "messageSize", "messageCounts", "_getStatsForType", "createSlidingWindow", "byType", "groupKey", "receivedMessage", "counters", "overrides", "SlidingWindowSummary", "dataPoints", "precision", "MAX_UPDATE_FREQ", "DocumentsSynchronizer", "_syncStates", "_pendingUpdates", "_sendUpdatesJob", "addDocuments", "retryCounter", "_startSync", "trigger", "removeDocuments", "clearSubscriptions", "UpdateScheduler", "_checkAndSendUpdates", "maxFrequency", "update", "updates", "mutation", "isNew", "A", "loadIncremental", "_writeMutation", "syncState", "_subscribeForChanges", "handler", "off", "docsWithPendingUpdates", "_getPendingChanges", "sendUpdates", "lastSentHead", "saveSince", "headsBefore", "newDoc", "DataServiceImpl", "_automergeHost", "automergeHost", "_spaceStateManager", "spaceStateManager", "_updateIndexes", "updateIndexes", "subscribe", "request", "Stream", "next", "ready", "synchronizer", "_subscriptions", "subscriptionId", "updateSubscription", "addIds", "removeIds", "getDocumentHeads", "idx", "options", "subscribeSpaceSyncState", "getSpaceRootDocumentId", "spaceDocumentListUpdated", "event", "newId", "spaceRootId", "scheduler", "LOG_VIEW_OPERATION_THRESHOLD", "createSelectedDocumentsIterator", "loadDocuments", "begin", "view", "end", "requestedHeads", "originalHeads", "version", "SpaceDocVersion", "CURRENT", "getVersion", "ObjectPointerVersion", "V0", "object", "QueryError", "BaseError", "extend", "QueryPlan", "Plan", "make", "steps", "FilterStep", "isNoop", "step", "typename", "props", "foreignKeys", "DEFAULT_OPTIONS", "defaultTextSearchKind", "QueryPlanner", "_options", "createPlan", "query", "plan", "_generate", "DEFAULT_CONTEXT", "originalQuery", "_optimizeEmptyFilters", "_optimizeSoloUnions", "_generateOptionsClause", "_generateSelectClause", "_generateFilterClause", "_generateIncomingReferencesClause", "_generateRelationClause", "_generateRelationTraversalClause", "_generateReferenceTraversalClause", "_generateUnionClause", "_generateSetDifferenceClause", "newContext", "spaceIds", "selectionSpaces", "deleted", "deletedHandling", "_generateSelectionFromFilter", "selectionInverted", "_tag", "_generateDeletedHandlingSteps", "spaces", "selector", "inverted", "text", "searchKind", "filters", "every", "isTrivialTypenameFilter", "typenames", "f", "mode", "plans", "queries", "source", "exclude", "anchor", "traversal", "direction", "property", "createRelationTraversalStep", "anchorPlan", "NOOP_FILTER", "selection", "ExecutionTrace", "makeEmpty", "name", "details", "objectCount", "documentsLoaded", "indexHits", "indexQueryTime", "documentLoadTime", "executionTime", "children", "go", "indent", "repeat", "toFixed", "child", "TRACE_QUERY_EXECUTION", "QueryExecutor", "_trace", "_lastResultSet", "_indexer", "indexer", "_id", "queryId", "_query", "_reactivity", "reactivity", "queryPlanner", "_plan", "getResults", "item", "rank", "execQuery", "prevResultSet", "workingSet", "_execPlan", "JSON", "stringify", "changed", "console", "performance", "ContextDisposedError", "_execStep", "newWorkingSet", "_execSelectStep", "_execFilterStep", "_execFilterDeletedStep", "_execUnionStep", "_execSetDifferenceStep", "_execTraverseStep", "beginIndexQuery", "documentLoadStart", "results", "_loadDocumentsAfterIndexQuery", "beginLoad", "items", "_loadFromDXN", "DXN", "fromLocalObjectId", "sourceSpaceId", "kind", "Match", "pipe", "withReturnType", "when", "orElseAbsurd", "filterMatchObject", "expected", "ObjectStructure", "isDeleted", "EscapedPropPath", "unescape", "refs", "flatMap", "ref", "getDeep", "isEncodedReference", "parse", "graph", "anchors", "getRelationSource", "getRelationTarget", "resultSets", "resultSet", "sourceResult", "excludeResult", "findIndex", "hit", "_loadFromIndexHit", "spaceKeyInIndex", "getInlineObject", "dxn", "echoDxn", "asEchoDXN", "spaceRoot", "getRootBySpaceId", "dbDirectory", "inlineObject", "echoId", "link", "getLink", "QueryServiceImpl", "_queries", "diagnostic", "fetch", "executor", "updated", "invalidateQueries", "_updateQueries", "DeferredTask", "_executeQueries", "setConfig", "config", "queryEntry", "_createQuery", "scheduleMicroTask", "schedule", "reindex", "createDocumentsIterator", "ids", "dirty", "onResults", "onError", "parsedQuery", "QueryAST", "Query", "Schema", "decodeUnknownSync", "raise", "firstResult", "sendResults", "verbose", "getAllDocuments", "visited", "getObjectsFromHandle", "links", "urlString", "linkHandle", "measureDocMetrics", "snapshot", "temp", "free", "getAllChangesStart", "mutationCount", "getAllChanges", "getAllChangesEnd", "elapsed", "compressedByteSize", "loadTime", "DatabaseRoot", "mapLinks", "mapping", "change", "d", "_rootHandle", "url", "isLoaded", "LEGACY", "getInlineObjectCount", "getLinkedObjectCount", "getAllLinkedDocuments", "s", "measureMetrics", "SpaceStateManager", "_roots", "_rootBySpace", "_perRootContext", "_lastSpaceDocumentList", "_", "rootCtx", "roots", "getRootByDocumentId", "assignRootToSpace", "root", "prevRootId", "documentListCheckScheduler", "isEqual", "SpaceDocumentListUpdatedEvent", "triggerCheckOnChange", "addListener", "removeListener", "previousRootId", "DEFAULT_INDEXING_CONFIG", "fullText", "vector", "EchoHost", "kv", "indexing", "indexingConfig", "IndexMetadataStore", "_echoDataMonitor", "Indexer", "indexStore", "IndexStore", "metadataStore", "indexCooldownTime", "process", "env", "NODE_ENV", "enabled", "indexes", "IndexKind", "Kind", "SCHEMA_MATCH", "GRAPH", "FULL_TEXT", "VECTOR", "_queryService", "_dataService", "dataStats", "inlineObjects", "linkedObjects", "queryService", "dataService", "automergeRepo", "createSpaceRoot", "automergeRoot", "access", "openSpaceRoot", "automergeUrl", "closeSpaceRoot", "todo", "InflightRequestLimiter", "_config", "_inflightRequestBalance", "_requestBarrier", "throw", "clearTimeout", "_resetBalanceTimeout", "rateLimit", "maxInflightRequests", "setTimeout", "resetBalanceTimeoutMs", "handleResponse", "clearInterval", "INITIAL_RESTART_DELAY", "RESTART_DELAY_JITTER", "MAX_RESTART_DELAY", "EchoEdgeReplicator", "edgeConnection", "disableSharePolicy", "_mutex", "Mutex", "_connectedSpaces", "_sharePolicyEnabled", "_edgeConnection", "connectedSpaces", "onReconnected", "_handleReconnect", "_guard", "acquire", "_openConnection", "connectToSpace", "disconnectFromSpace", "reconnects", "restartScheduled", "EdgeReplicatorConnection", "sharedPolicyEnabled", "onRestartRequested", "restartDelay", "min", "MAX_INFLIGHT_REQUESTS", "MAX_RATE_LIMIT_WAIT_TIME_MS", "_requestLimiter", "_spaceId", "EdgeService", "AUTOMERGE_REPLICATOR", "randomUUID", "_targetServiceId", "_sharedPolicyEnabled", "_onRemoteConnected", "_onRemoteDisconnected", "_onRestartRequested", "_readableStreamController", "_sendMessage", "onMessage", "msg", "remoteId", "serviceId", "_processMessage", "isForbiddenErrorMessage", "encoded", "buf", "RouterMessageSchema", "identityKey", "peerKey", "findInlineObjectOfType", "spaceDoc", "obj", "objType", "getTypeReference", "decodeReference"]
}
