{
  "version": 3,
  "sources": ["../../../src/common/codec.ts", "../../../src/common/feeds.ts", "../../../src/common/space-id.ts", "../../../src/metadata/metadata-store.ts", "../../../src/pipeline/timeframe-clock.ts", "../../../src/pipeline/pipeline.ts", "../../../src/pipeline/message-selector.ts", "../../../src/space/auth.ts", "../../../src/space/space.ts", "../../../src/space/control-pipeline.ts", "../../../src/space/admission-discovery-extension.ts", "../../../src/space/space-protocol.ts", "../../../src/space/space-manager.ts"],
  "sourcesContent": ["//\n// Copyright 2022 DXOS.org\n//\n\nimport { type Codec } from '@dxos/codec-protobuf';\nimport { createCodecEncoding } from '@dxos/hypercore';\nimport { schema } from '@dxos/protocols/proto';\nimport type { FeedMessage } from '@dxos/protocols/proto/dxos/echo/feed';\n\n/**\n * Codec for feed messages.\n */\nexport const codec: Codec<FeedMessage> = schema.getCodecForType('dxos.echo.feed.FeedMessage');\n\n/**\n * Value encoding used by feed store.\n */\nexport const valueEncoding = createCodecEncoding(codec);\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { type FeedWriter } from '@dxos/feed-store';\nimport { invariant } from '@dxos/invariant';\nimport { type MaybePromise } from '@dxos/util';\n\n/**\n * Maps the written arguments onto a different message type.\n */\nexport const createMappedFeedWriter = <Source extends {}, Target extends {}>(\n  mapper: (arg: Source) => MaybePromise<Target>,\n  writer: FeedWriter<Target>,\n): FeedWriter<Source> => {\n  invariant(mapper);\n  invariant(writer);\n\n  return {\n    write: async (data: Source, options) => await writer.write(await mapper(data), options),\n  };\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { subtleCrypto } from '@dxos/crypto';\nimport { PublicKey, SpaceId } from '@dxos/keys';\nimport { ComplexMap } from '@dxos/util';\n\nconst SPACE_IDS_CACHE = new ComplexMap<PublicKey, SpaceId>(PublicKey.hash);\n\n/**\n * Space keys are generated by creating a keypair, and then taking the first 20 bytes of the SHA-256 hash of the public key and encoding them to multibase RFC4648 base-32 format (prefixed with B, see Multibase Table).\n * Inspired by how ethereum addresses are derived.\n */\nexport const createIdFromSpaceKey = async (spaceKey: PublicKey): Promise<SpaceId> => {\n  const cachedValue = SPACE_IDS_CACHE.get(spaceKey);\n  if (cachedValue !== undefined) {\n    return cachedValue;\n  }\n\n  const digest = await subtleCrypto.digest('SHA-256', spaceKey.asUint8Array());\n\n  const bytes = new Uint8Array(digest).slice(0, SpaceId.byteLength);\n  const spaceId = SpaceId.encode(bytes);\n  SPACE_IDS_CACHE.set(spaceKey, spaceId);\n  return spaceId;\n};\n", "//\n// Copyright 2021 DXOS.org\n//\n\nimport CRC32 from 'crc-32';\n\nimport { Event, scheduleTaskInterval, synchronized } from '@dxos/async';\nimport { type Codec } from '@dxos/codec-protobuf';\nimport { Context } from '@dxos/context';\nimport { invariant } from '@dxos/invariant';\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { DataCorruptionError, STORAGE_VERSION } from '@dxos/protocols';\nimport { schema } from '@dxos/protocols/proto';\nimport { Invitation, SpaceState } from '@dxos/protocols/proto/dxos/client/services';\nimport {\n  type ControlPipelineSnapshot,\n  type EchoMetadata,\n  type SpaceMetadata,\n  type IdentityRecord,\n  type SpaceCache,\n  type LargeSpaceMetadata,\n  type EdgeReplicationSetting,\n} from '@dxos/protocols/proto/dxos/echo/metadata';\nimport { type Directory, type File } from '@dxos/random-access-storage';\nimport { type Timeframe } from '@dxos/timeframe';\nimport { ComplexMap, arrayToBuffer, forEachAsync, isNonNullable } from '@dxos/util';\n\nconst EXPIRED_INVITATION_CLEANUP_INTERVAL = 60 * 60 * 1000; // 1 hour\n\nexport interface AddSpaceOptions {\n  key: PublicKey;\n  genesisFeed: PublicKey;\n}\n\nconst emptyEchoMetadata = (): EchoMetadata => ({\n  version: STORAGE_VERSION,\n  spaces: [],\n  created: new Date(),\n  updated: new Date(),\n});\n\nconst emptyLargeSpaceMetadata = (): LargeSpaceMetadata => ({});\n\nconst EchoMetadata = schema.getCodecForType('dxos.echo.metadata.EchoMetadata');\nconst LargeSpaceMetadata = schema.getCodecForType('dxos.echo.metadata.LargeSpaceMetadata');\n\nexport class MetadataStore {\n  private _metadata: EchoMetadata = emptyEchoMetadata();\n  private _spaceLargeMetadata = new ComplexMap<PublicKey, LargeSpaceMetadata>(PublicKey.hash);\n\n  private _metadataFile?: File = undefined;\n\n  public readonly update = new Event<EchoMetadata>();\n  private readonly _invitationCleanupCtx = new Context();\n\n  /**\n   * @internal\n   */\n  readonly _directory: Directory;\n\n  constructor(directory: Directory) {\n    this._directory = directory;\n  }\n\n  get metadata(): EchoMetadata {\n    return this._metadata;\n  }\n\n  get version(): number {\n    return this._metadata.version ?? 0;\n  }\n\n  /**\n   * Returns a list of currently saved spaces. The list and objects in it can be modified addSpace and\n   * addSpaceFeed functions.\n   */\n  get spaces(): SpaceMetadata[] {\n    return this._metadata.spaces ?? [];\n  }\n\n  private async _readFile<T>(file: File, codec: Codec<T>): Promise<T | undefined> {\n    try {\n      const { size: fileLength } = await file.stat();\n      if (fileLength < 8) {\n        return;\n      }\n      // Loading file size from first 4 bytes.\n      const dataSize = fromBytesInt32(await file.read(0, 4));\n      const checksum = fromBytesInt32(await file.read(4, 4));\n      log('loaded', { size: dataSize, checksum, name: file.filename });\n\n      if (fileLength < dataSize + 8) {\n        throw new DataCorruptionError('Metadata size is smaller than expected.', { fileLength, dataSize });\n      }\n\n      const data = await file.read(8, dataSize);\n\n      const calculatedChecksum = CRC32.buf(data);\n      if (calculatedChecksum !== checksum) {\n        throw new DataCorruptionError('Metadata checksum is invalid.');\n      }\n\n      return codec.decode(data);\n    } finally {\n      await file.close();\n    }\n  }\n\n  /**\n   * @internal\n   */\n  async _writeFile<T>(file: File, codec: Codec<T>, data: T): Promise<void> {\n    const encoded = arrayToBuffer(codec.encode(data));\n    const checksum = CRC32.buf(encoded);\n\n    const result = Buffer.alloc(8 + encoded.length);\n\n    result.writeInt32LE(encoded.length, 0);\n    result.writeInt32LE(checksum, 4);\n    encoded.copy(result, 8);\n\n    // NOTE: This must be done in one write operation, otherwise the file can be corrupted.\n    await file.write(0, result);\n\n    log('saved', { size: encoded.length, checksum });\n  }\n\n  async close(): Promise<void> {\n    await this._invitationCleanupCtx.dispose();\n    await this.flush();\n    await this._metadataFile?.close();\n    this._metadataFile = undefined;\n    this._metadata = emptyEchoMetadata();\n    this._spaceLargeMetadata.clear();\n  }\n\n  /**\n   * Loads metadata from persistent storage.\n   */\n  @synchronized\n  async load(): Promise<void> {\n    if (!this._metadataFile || this._metadataFile.closed) {\n      this._metadataFile = this._directory.getOrCreateFile('EchoMetadata');\n    }\n\n    try {\n      const metadata = await this._readFile(this._metadataFile, EchoMetadata);\n      if (metadata) {\n        this._metadata = metadata;\n      }\n\n      // post-processing\n      this._metadata.spaces?.forEach((space) => {\n        space.state ??= SpaceState.SPACE_ACTIVE;\n      });\n    } catch (err: any) {\n      log.error('failed to load metadata', { err });\n      this._metadata = emptyEchoMetadata();\n    }\n\n    await forEachAsync(\n      [this._metadata.identity?.haloSpace.key, ...(this._metadata.spaces?.map((space) => space.key) ?? [])].filter(\n        isNonNullable,\n      ),\n      async (key) => {\n        try {\n          await this._loadSpaceLargeMetadata(key);\n        } catch (err: any) {\n          log.error('failed to load space large metadata', { err });\n        }\n      },\n    );\n\n    // Cleanup expired persistent invitations.\n    scheduleTaskInterval(\n      this._invitationCleanupCtx,\n      async () => {\n        for (const invitation of this._metadata.invitations ?? []) {\n          if (hasInvitationExpired(invitation) || isLegacyInvitationFormat(invitation)) {\n            await this.removeInvitation(invitation.invitationId);\n          }\n        }\n      },\n      EXPIRED_INVITATION_CLEANUP_INTERVAL,\n    );\n  }\n\n  @synchronized\n  private async _save(): Promise<void> {\n    const data: EchoMetadata = {\n      ...this._metadata,\n      version: STORAGE_VERSION,\n      created: this._metadata.created ?? new Date(),\n      updated: new Date(),\n    };\n    this.update.emit(data);\n\n    const file = this._directory.getOrCreateFile('EchoMetadata');\n\n    await this._writeFile(file, EchoMetadata, data);\n  }\n\n  private async _loadSpaceLargeMetadata(key: PublicKey): Promise<void> {\n    const file = this._directory.getOrCreateFile(`space_${key.toHex()}_large`);\n    try {\n      const metadata = await this._readFile(file, LargeSpaceMetadata);\n      if (metadata) {\n        this._spaceLargeMetadata.set(key, metadata);\n      }\n    } catch (err: any) {\n      log.error('failed to load space large metadata', { err });\n    }\n  }\n\n  @synchronized\n  private async _saveSpaceLargeMetadata(key: PublicKey): Promise<void> {\n    const data = this._getLargeSpaceMetadata(key);\n    const file = this._directory.getOrCreateFile(`space_${key.toHex()}_large`);\n    await this._writeFile(file, LargeSpaceMetadata, data);\n  }\n\n  async flush(): Promise<void> {\n    await this._directory.flush();\n  }\n\n  _getSpace(spaceKey: PublicKey): SpaceMetadata {\n    if (this._metadata.identity?.haloSpace.key.equals(spaceKey)) {\n      // Check if the space is the identity space.\n      return this._metadata.identity.haloSpace;\n    }\n\n    const space = this.spaces.find((space) => space.key.equals(spaceKey));\n    invariant(space, 'Space not found');\n    return space;\n  }\n\n  hasSpace(spaceKey: PublicKey): boolean {\n    if (this._metadata.identity?.haloSpace.key.equals(spaceKey)) {\n      // Check if the space is the identity space.\n      return true;\n    }\n\n    return !!this.spaces.find((space) => space.key.equals(spaceKey));\n  }\n\n  private _getLargeSpaceMetadata(key: PublicKey): LargeSpaceMetadata {\n    let entry = this._spaceLargeMetadata.get(key);\n    if (entry) {\n      return entry;\n    }\n\n    entry = emptyLargeSpaceMetadata();\n    this._spaceLargeMetadata.set(key, entry);\n    return entry;\n  }\n\n  /**\n   * Clears storage - doesn't work for now.\n   */\n  async clear(): Promise<void> {\n    log('clearing all metadata');\n    await this._directory.delete();\n    this._metadata = emptyEchoMetadata();\n  }\n\n  getIdentityRecord(): IdentityRecord | undefined {\n    return this._metadata.identity;\n  }\n\n  async setIdentityRecord(record: IdentityRecord): Promise<void> {\n    invariant(!this._metadata.identity, 'Cannot overwrite existing identity in metadata');\n\n    this._metadata.identity = record;\n    await this._save();\n    await this.flush();\n  }\n\n  getInvitations(): Invitation[] {\n    return this._metadata.invitations ?? [];\n  }\n\n  async addInvitation(invitation: Invitation): Promise<void> {\n    if (this._metadata.invitations?.find((i) => i.invitationId === invitation.invitationId)) {\n      return;\n    }\n\n    (this._metadata.invitations ??= []).push(invitation);\n    await this._save();\n    await this.flush();\n  }\n\n  async removeInvitation(invitationId: string): Promise<void> {\n    this._metadata.invitations = (this._metadata.invitations ?? []).filter((i) => i.invitationId !== invitationId);\n    await this._save();\n    await this.flush();\n  }\n\n  async addSpace(record: SpaceMetadata): Promise<void> {\n    invariant(\n      !(this._metadata.spaces ?? []).find((space) => space.key.equals(record.key)),\n      'Cannot overwrite existing space in metadata',\n    );\n\n    (this._metadata.spaces ??= []).push(record);\n    await this._save();\n    await this.flush();\n  }\n\n  async setSpaceDataLatestTimeframe(spaceKey: PublicKey, timeframe: Timeframe): Promise<void> {\n    this._getSpace(spaceKey).dataTimeframe = timeframe;\n    await this._save();\n  }\n\n  async setSpaceControlLatestTimeframe(spaceKey: PublicKey, timeframe: Timeframe): Promise<void> {\n    this._getSpace(spaceKey).controlTimeframe = timeframe;\n    await this._save();\n    await this.flush();\n  }\n\n  async setCache(spaceKey: PublicKey, cache: SpaceCache): Promise<void> {\n    this._getSpace(spaceKey).cache = cache;\n    await this._save();\n  }\n\n  async setWritableFeedKeys(spaceKey: PublicKey, controlFeedKey: PublicKey, dataFeedKey: PublicKey): Promise<void> {\n    const space = this._getSpace(spaceKey);\n    space.controlFeedKey = controlFeedKey;\n    space.dataFeedKey = dataFeedKey;\n    await this._save();\n    await this.flush();\n  }\n\n  async setSpaceState(spaceKey: PublicKey, state: SpaceState): Promise<void> {\n    this._getSpace(spaceKey).state = state;\n    await this._save();\n    await this.flush();\n  }\n\n  getSpaceControlPipelineSnapshot(spaceKey: PublicKey): ControlPipelineSnapshot | undefined {\n    return this._getLargeSpaceMetadata(spaceKey).controlPipelineSnapshot;\n  }\n\n  async setSpaceControlPipelineSnapshot(spaceKey: PublicKey, snapshot: ControlPipelineSnapshot): Promise<void> {\n    this._getLargeSpaceMetadata(spaceKey).controlPipelineSnapshot = snapshot;\n    await this._saveSpaceLargeMetadata(spaceKey);\n    await this.flush();\n  }\n\n  getSpaceEdgeReplicationSetting(spaceKey: PublicKey): EdgeReplicationSetting | undefined {\n    return this.hasSpace(spaceKey) ? this._getSpace(spaceKey).edgeReplication : undefined;\n  }\n\n  async setSpaceEdgeReplicationSetting(spaceKey: PublicKey, setting: EdgeReplicationSetting): Promise<void> {\n    this._getSpace(spaceKey).edgeReplication = setting;\n    await this._save();\n    await this.flush();\n  }\n}\n\nconst fromBytesInt32 = (buf: Buffer) => buf.readInt32LE(0);\n\nexport const hasInvitationExpired = (invitation: Invitation): boolean => {\n  return Boolean(\n    invitation.created &&\n      invitation.lifetime &&\n      invitation.lifetime !== 0 &&\n      invitation.created.getTime() + invitation.lifetime * 1000 < Date.now(),\n  );\n};\n\n// TODO: remove once \"multiuse\" type invitations get removed from local metadata of existing profiles\nconst isLegacyInvitationFormat = (invitation: Invitation): boolean => {\n  return invitation.type === Invitation.Type.MULTIUSE;\n};\n", "//\n// Copyright 2020 DXOS.org\n//\n\nimport { Event } from '@dxos/async';\nimport { timed } from '@dxos/debug';\nimport { type FeedIndex } from '@dxos/feed-store';\nimport { type PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { Timeframe } from '@dxos/timeframe';\n\nexport const mapTimeframeToFeedIndexes = (timeframe: Timeframe): FeedIndex[] =>\n  timeframe.frames().map(([feedKey, index]) => ({ feedKey, index }));\n\nexport const mapFeedIndexesToTimeframe = (indexes: FeedIndex[]): Timeframe =>\n  new Timeframe(indexes.map(({ feedKey, index }) => [feedKey, index]));\n\nexport const startAfter = (timeframe: Timeframe): FeedIndex[] =>\n  timeframe.frames().map(([feedKey, index]) => ({ feedKey, index: index + 1 }));\n\n/**\n * Keeps state of the last timeframe that was processed by ECHO.\n */\nexport class TimeframeClock {\n  readonly update = new Event<Timeframe>();\n\n  private _pendingTimeframe: Timeframe;\n\n  constructor(private _timeframe = new Timeframe()) {\n    this._pendingTimeframe = _timeframe;\n  }\n\n  /**\n   * Timeframe that was processed by ECHO.\n   */\n  get timeframe() {\n    return this._timeframe;\n  }\n\n  /**\n   * Timeframe that is currently being processed by ECHO.\n   * Will be equal to `timeframe` after the processing is complete.\n   */\n  get pendingTimeframe() {\n    return this._pendingTimeframe;\n  }\n\n  setTimeframe(timeframe: Timeframe): void {\n    this._timeframe = timeframe;\n    this._pendingTimeframe = timeframe;\n    this.update.emit(this._timeframe);\n  }\n\n  updatePendingTimeframe(key: PublicKey, seq: number): void {\n    this._pendingTimeframe = Timeframe.merge(this._pendingTimeframe, new Timeframe([[key, seq]]));\n  }\n\n  updateTimeframe(): void {\n    this._timeframe = this._pendingTimeframe;\n    this.update.emit(this._timeframe);\n  }\n\n  hasGaps(timeframe: Timeframe): boolean {\n    const gaps = Timeframe.dependencies(timeframe, this._timeframe);\n    return !gaps.isEmpty();\n  }\n\n  @timed(5_000)\n  async waitUntilReached(target: Timeframe): Promise<void> {\n    log('waitUntilReached', { target, current: this._timeframe });\n    await this.update.waitForCondition(() => {\n      log('check if reached', {\n        target,\n        current: this._timeframe,\n        deps: Timeframe.dependencies(target, this._timeframe),\n      });\n\n      return Timeframe.dependencies(target, this._timeframe).isEmpty();\n    });\n  }\n}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { Event, sleepWithContext, synchronized, Trigger } from '@dxos/async';\nimport { Context, rejectOnDispose } from '@dxos/context';\nimport { failUndefined } from '@dxos/debug';\nimport { FeedSetIterator, type FeedWrapper, type FeedWriter } from '@dxos/feed-store';\nimport { invariant } from '@dxos/invariant';\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { type FeedMessageBlock } from '@dxos/protocols';\nimport type { FeedMessage } from '@dxos/protocols/proto/dxos/echo/feed';\nimport { Timeframe } from '@dxos/timeframe';\nimport { ComplexMap } from '@dxos/util';\n\nimport { createMessageSelector } from './message-selector';\nimport { mapFeedIndexesToTimeframe, startAfter, TimeframeClock } from './timeframe-clock';\nimport { createMappedFeedWriter } from '../common';\n\nexport type WaitUntilReachedTargetParams = {\n  /**\n   * For cancellation.\n   */\n  ctx?: Context;\n  timeout?: number;\n\n  /**\n   * @default true\n   */\n  breakOnStall?: boolean;\n};\n\n/**\n * External state accessor.\n */\nexport class PipelineState {\n  /**\n   * @internal\n   */\n  _ctx = new Context();\n\n  // TODO(dmaretskyi): Remove?.\n  public readonly timeframeUpdate = this._timeframeClock.update;\n\n  public readonly stalled = new Event();\n\n  /**\n   * @internal\n   */\n  _startTimeframe: Timeframe = new Timeframe();\n\n  /**\n   * Target timeframe we are waiting to reach.\n   */\n  private _targetTimeframe: Timeframe | undefined;\n\n  /**\n   * @internal\n   */\n  _reachedTargetPromise: Promise<void> | undefined;\n\n  /**\n   * @internal\n   */\n  _reachedTarget: boolean = false;\n\n  constructor(\n    private _feeds: ComplexMap<PublicKey, FeedWrapper<FeedMessage>>,\n    private _timeframeClock: TimeframeClock,\n  ) {}\n\n  /**\n   * Latest theoretical timeframe based on the last mutation in each feed.\n   * NOTE: This might never be reached if the mutation dependencies\n   */\n  // TODO(dmaretskyi): Rename `totalTimeframe`? or `lastTimeframe`.\n  get endTimeframe() {\n    return mapFeedIndexesToTimeframe(\n      Array.from(this._feeds.values())\n        .filter((feed) => feed.length > 0)\n        .map((feed) => ({\n          feedKey: feed.key,\n          index: feed.length - 1,\n        })),\n    );\n  }\n\n  get startTimeframe() {\n    return this._startTimeframe;\n  }\n\n  get timeframe() {\n    return this._timeframeClock.timeframe;\n  }\n\n  get pendingTimeframe() {\n    return this._timeframeClock.pendingTimeframe;\n  }\n\n  get targetTimeframe() {\n    return this._targetTimeframe ? this._targetTimeframe : new Timeframe();\n  }\n\n  get reachedTarget() {\n    return this._reachedTarget;\n  }\n\n  get feeds() {\n    return Array.from(this._feeds.values());\n  }\n\n  async waitUntilTimeframe(target: Timeframe): Promise<void> {\n    await this._timeframeClock.waitUntilReached(target);\n  }\n\n  setTargetTimeframe(target: Timeframe): void {\n    this._targetTimeframe = target;\n  }\n\n  /**\n   * Wait until the pipeline processes all messages in the feed and reaches the target timeframe if that is set.\n   *\n   * This function will resolve immediately if the pipeline is stalled.\n   *\n   * @param timeout Timeout in milliseconds to specify the maximum wait time.\n   */\n  async waitUntilReachedTargetTimeframe({\n    ctx = new Context(),\n    timeout,\n    breakOnStall = true,\n  }: WaitUntilReachedTargetParams = {}): Promise<void> {\n    log('waitUntilReachedTargetTimeframe', {\n      timeout,\n      current: this.timeframe,\n      target: this.targetTimeframe,\n    });\n\n    this._reachedTargetPromise ??= Promise.race([\n      this._timeframeClock.update.waitForCondition(() => {\n        return Timeframe.dependencies(this.targetTimeframe, this.timeframe).isEmpty();\n      }),\n      ...(breakOnStall ? [this.stalled.discardParameter().waitForCount(1)] : []),\n    ]);\n\n    let done = false;\n\n    if (timeout) {\n      return Promise.race([\n        rejectOnDispose(ctx),\n        rejectOnDispose(this._ctx),\n        this._reachedTargetPromise.then(() => {\n          done = true;\n          this._reachedTarget = true;\n        }),\n        sleepWithContext(this._ctx, timeout).then(() => {\n          if (done) {\n            return;\n          }\n\n          log.warn('waitUntilReachedTargetTimeframe timed out', {\n            timeout,\n            current: this.timeframe,\n            target: this.targetTimeframe,\n            dependencies: Timeframe.dependencies(this.targetTimeframe, this.timeframe),\n          });\n        }),\n      ]);\n    } else {\n      return this._reachedTargetPromise;\n    }\n  }\n}\n\n// TODO(mykola): Extract to `@dxos/echo-protocol`\nexport interface PipelineAccessor {\n  state: PipelineState;\n  writer: FeedWriter<FeedMessage.Payload>;\n}\n\n/**\n * A multi-reader pipeline that operates on feeds.\n * Might have a single writable feed.\n * Has a timeframe clock to handle message ordering.\n *\n * NOTE:\n *  - Feeds passed in must have value encoding consistent with the type expected by the iterator/writer.\n *\n * # Usage examples\n *\n * ## Create a new space.\n *\n * 1. Generate space key, genesis feed key.\n * 2. Create and open pipeline reading from {}.\n * 3. Create and add the writable genesis feed.\n * 4. Write the initial sequence of control and credential messages.\n *\n * ## Load an existing space from storage\n *\n * 1. Load space key, genesis feed key, get starting timeframe from saved snapshot.\n * 2. Create and open pipeline reading from the initial timeframe.\n * 3. Open and add the genesis feed.\n * 4. Once the writable feed is added, the pipeline becomes writable.\n *\n * ## Join an existing space created by another agent/device.\n *\n * 1. Get the space key, genesis feed key from another agent.\n * 2. (optionally) Download the snapshot from another agent.\n * 3. Create and open pipeline.\n * 4. Generate the writable feed key.\n * 5. Wait for the writable feed to be added.\n */\nexport class Pipeline implements PipelineAccessor {\n  private readonly _timeframeClock = new TimeframeClock(new Timeframe());\n  private readonly _feeds = new ComplexMap<PublicKey, FeedWrapper<FeedMessage>>(PublicKey.hash);\n\n  // External state accessor.\n  private readonly _state: PipelineState = new PipelineState(this._feeds, this._timeframeClock);\n\n  // Waits for the message consumer to process the message and yield control back to the pipeline.\n  private readonly _processingTrigger = new Trigger().wake();\n  private readonly _pauseTrigger = new Trigger().wake();\n\n  // Pending downloads.\n  private readonly _downloads = new ComplexMap<FeedWrapper<FeedMessage>, any>((value) => PublicKey.hash(value.key));\n\n  // Inbound feed stream.\n  private _feedSetIterator?: FeedSetIterator<FeedMessage>;\n\n  // Outbound feed writer.\n  private _writer: FeedWriter<FeedMessage.Payload> | undefined;\n\n  private _isStopping = false;\n  private _isStarted = false;\n  private _isBeingConsumed = false;\n  private _isPaused = false;\n\n  get state() {\n    return this._state;\n  }\n\n  get writer(): FeedWriter<FeedMessage.Payload> {\n    invariant(this._writer, 'Writer not set.');\n    return this._writer;\n  }\n\n  hasFeed(feedKey: PublicKey): boolean {\n    return this._feeds.has(feedKey);\n  }\n\n  getFeeds(): FeedWrapper<FeedMessage>[] {\n    return this._feedSetIterator!.feeds;\n  }\n\n  // NOTE: This cannot be synchronized with `stop` because stop waits for the mutation processing to complete,\n  // which might be opening feeds during the mutation processing, which w\n  async addFeed(feed: FeedWrapper<FeedMessage>): Promise<void> {\n    this._feeds.set(feed.key, feed);\n\n    if (this._feedSetIterator) {\n      await this._feedSetIterator.addFeed(feed);\n    }\n\n    if (this._isStarted && !this._isPaused) {\n      this._setFeedDownloadState(feed);\n    }\n  }\n\n  setWriteFeed(feed: FeedWrapper<FeedMessage>): void {\n    invariant(!this._writer, 'Writer already set.');\n    invariant(feed.properties.writable, 'Feed must be writable.');\n\n    this._writer = createMappedFeedWriter<FeedMessage.Payload, FeedMessage>(\n      (payload: FeedMessage.Payload) => ({\n        timeframe: this._timeframeClock.timeframe,\n        payload,\n      }),\n      feed.createFeedWriter(),\n    );\n  }\n\n  @synchronized\n  async start(): Promise<void> {\n    invariant(!this._isStarted, 'Pipeline is already started.');\n    log('starting...');\n    await this._initIterator();\n    await this._feedSetIterator!.open();\n    this._isStarted = true;\n    log('started');\n\n    if (!this._isPaused) {\n      for (const feed of this._feeds.values()) {\n        this._setFeedDownloadState(feed);\n      }\n    }\n  }\n\n  @synchronized\n  async stop(): Promise<void> {\n    log('stopping...');\n    this._isStopping = true;\n    for (const [feed, handle] of this._downloads.entries()) {\n      feed.undownload(handle);\n    }\n    this._downloads.clear();\n    await this._feedSetIterator?.close();\n    await this._processingTrigger.wait(); // Wait for the in-flight message to be processed.\n    await this._state._ctx.dispose();\n    this._state._ctx = new Context();\n    this._state._reachedTargetPromise = undefined;\n    this._state._reachedTarget = false;\n    this._isStarted = false;\n    log('stopped');\n  }\n\n  /**\n   * @param timeframe Timeframe of already processed messages.\n   *  The pipeline will start processing messages AFTER this timeframe.\n   */\n  @synchronized\n  async setCursor(timeframe: Timeframe): Promise<void> {\n    invariant(!this._isStarted || this._isPaused, 'Invalid state.');\n\n    this._state._startTimeframe = timeframe;\n    this._timeframeClock.setTimeframe(timeframe);\n\n    // Cancel downloads of mutations before the cursor.\n    if (this._feedSetIterator) {\n      await this._feedSetIterator.close();\n      await this._initIterator();\n      await this._feedSetIterator.open();\n    }\n  }\n\n  /**\n   * Calling pause while processing will cause a deadlock.\n   */\n  @synchronized\n  async pause(): Promise<void> {\n    if (this._isPaused) {\n      return;\n    }\n\n    this._pauseTrigger.reset();\n    await this._processingTrigger.wait();\n    this._isPaused = true;\n  }\n\n  @synchronized\n  async unpause(): Promise<void> {\n    invariant(this._isPaused, 'Pipeline is not paused.');\n\n    this._pauseTrigger.wake();\n    this._isPaused = false;\n\n    for (const feed of this._feeds.values()) {\n      this._setFeedDownloadState(feed);\n    }\n  }\n\n  /**\n   * Starts to iterate over the ordered messages from the added feeds.\n   * Updates the timeframe clock after the message has bee processed.\n   */\n  async *consume(): AsyncIterable<FeedMessageBlock> {\n    invariant(!this._isBeingConsumed, 'Pipeline is already being consumed.');\n    this._isBeingConsumed = true;\n\n    invariant(this._feedSetIterator, 'Iterator not initialized.');\n    let lastFeedSetIterator = this._feedSetIterator;\n    let iterable = lastFeedSetIterator[Symbol.asyncIterator]();\n\n    while (!this._isStopping) {\n      await this._pauseTrigger.wait();\n\n      // Iterator might have been changed while we were waiting for the processing to complete.\n      if (lastFeedSetIterator !== this._feedSetIterator) {\n        invariant(this._feedSetIterator, 'Iterator not initialized.');\n        lastFeedSetIterator = this._feedSetIterator;\n        iterable = lastFeedSetIterator[Symbol.asyncIterator]();\n      }\n\n      // Will be canceled when the iterator gets closed.\n      const { done, value } = await iterable.next();\n      if (!done) {\n        const block = value ?? failUndefined();\n        this._processingTrigger.reset();\n        this._timeframeClock.updatePendingTimeframe(PublicKey.from(block.feedKey), block.seq);\n        yield block;\n        this._processingTrigger.wake();\n        this._timeframeClock.updateTimeframe();\n      }\n    }\n\n    // TODO(burdon): Test re-entrant?\n    this._isBeingConsumed = false;\n  }\n\n  private _setFeedDownloadState(feed: FeedWrapper<FeedMessage>): void {\n    let handle = this._downloads.get(feed); // TODO(burdon): Always undefined?\n    if (handle) {\n      feed.undownload(handle);\n    }\n\n    const timeframe = this._state._startTimeframe;\n    const seq = timeframe.get(feed.key) ?? -1;\n    log('download', { feed: feed.key.truncate(), seq, length: feed.length });\n    handle = feed.download({ start: seq + 1, linear: true }, (err: any, data: any) => {\n      if (err) {\n        // log.warn(err); // TODO(burdon): Feed is closed/Download was cancelled.\n      } else {\n        log('downloaded', { data }); // TODO(burdon): Never called.\n      }\n    });\n\n    this._downloads.set(feed, handle);\n  }\n\n  private async _initIterator(): Promise<void> {\n    this._feedSetIterator = new FeedSetIterator<FeedMessage>(createMessageSelector(this._timeframeClock), {\n      start: startAfter(this._timeframeClock.timeframe),\n      stallTimeout: 1000,\n    });\n\n    this._feedSetIterator.stalled.on((iterator) => {\n      log.warn(`Stalled after ${iterator.options.stallTimeout}ms with ${iterator.size} feeds.`, {\n        currentTimeframe: this._timeframeClock.timeframe,\n        targetTimeframe: this._state.targetTimeframe,\n      });\n      this._state.stalled.emit();\n    });\n\n    for (const feed of this._feeds.values()) {\n      await this._feedSetIterator.addFeed(feed);\n    }\n  }\n}\n", "//\n// Copyright 2020 DXOS.org\n//\n\nimport { type FeedBlock, type FeedBlockSelector } from '@dxos/feed-store';\nimport { invariant } from '@dxos/invariant';\nimport { log } from '@dxos/log';\nimport type { FeedMessage } from '@dxos/protocols/proto/dxos/echo/feed';\n\nimport { type TimeframeClock } from './timeframe-clock';\n\n/**\n * The MessageSelector makes sure that we read in a trusted order.\n * The first message we wish to process is the SpaceGenesis, which will admit a Feed.\n * As we encounter and process FeedAdmit messages those are added to the Space's trust,\n * and we begin processing messages from them as well.\n */\nexport const createMessageSelector = (timeframeClock: TimeframeClock): FeedBlockSelector<FeedMessage> => {\n  return (messages: FeedBlock<FeedMessage>[]) => {\n    // Pick the first candidate with a valid timeframe that has no gaps.\n    for (let i = 0; i < messages.length; i++) {\n      const {\n        data: { timeframe },\n      } = messages[i];\n      invariant(timeframe);\n\n      if (!timeframeClock.hasGaps(timeframe)) {\n        return i;\n      }\n    }\n\n    // Not ready for this message yet.\n    log('Skipping...');\n  };\n};\n", "//\n// Copyright 2019 DXOS.org\n//\n\nimport { runInContext, scheduleTask } from '@dxos/async';\nimport { Context } from '@dxos/context';\nimport { randomBytes } from '@dxos/crypto';\nimport { invariant } from '@dxos/invariant';\nimport { log } from '@dxos/log';\nimport { schema } from '@dxos/protocols/proto';\nimport { type AuthService } from '@dxos/protocols/proto/dxos/mesh/teleport/auth';\nimport { type ExtensionContext, RpcExtension } from '@dxos/teleport';\n\nexport type AuthProvider = (nonce: Uint8Array) => Promise<Uint8Array | undefined>;\n\nexport type AuthVerifier = (nonce: Uint8Array, credential: Uint8Array) => Promise<boolean>;\n\nexport type AuthExtensionParams = {\n  provider: AuthProvider;\n  verifier: AuthVerifier;\n  onAuthSuccess: () => void;\n  onAuthFailure: () => void;\n};\n\nexport class AuthExtension extends RpcExtension<Services, Services> {\n  private readonly _ctx = new Context({\n    onError: (err) => {\n      log.catch(err);\n    },\n  });\n\n  constructor(private readonly _authParams: AuthExtensionParams) {\n    super({\n      requested: {\n        AuthService: schema.getService('dxos.mesh.teleport.auth.AuthService'),\n      },\n      exposed: {\n        AuthService: schema.getService('dxos.mesh.teleport.auth.AuthService'),\n      },\n      timeout: 60 * 1000, // Long timeout because auth can wait for sync in certain cases.\n    });\n  }\n\n  protected async getHandlers(): Promise<Services> {\n    return {\n      AuthService: {\n        authenticate: async ({ challenge }) => {\n          try {\n            const credential = await this._authParams.provider(challenge);\n            if (!credential) {\n              throw new Error('auth rejected');\n            }\n            return { credential };\n          } catch (err) {\n            log.error('failed to generate auth credentials', err);\n            throw new Error('auth rejected');\n          }\n        },\n      },\n    };\n  }\n\n  override async onOpen(context: ExtensionContext): Promise<void> {\n    await super.onOpen(context);\n    scheduleTask(this._ctx, async () => {\n      try {\n        const challenge = randomBytes(32);\n        const { credential } = await this.rpc.AuthService.authenticate({ challenge });\n        invariant(credential?.length > 0, 'invalid credential');\n        const success = await this._authParams.verifier(challenge, credential);\n        invariant(success, 'credential not verified');\n        runInContext(this._ctx, () => this._authParams.onAuthSuccess());\n      } catch (err) {\n        log('auth failed', err);\n        this.close();\n        this._authParams.onAuthFailure();\n      }\n    });\n  }\n\n  override async onClose(): Promise<void> {\n    await this._ctx.dispose();\n    await super.onClose();\n  }\n\n  override async onAbort(): Promise<void> {\n    await this._ctx.dispose();\n    await super.onAbort();\n  }\n}\n\ntype Services = { AuthService: AuthService };\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { Event, scheduleMicroTask, synchronized, trackLeaks } from '@dxos/async';\nimport { type Context, Resource } from '@dxos/context';\nimport { type DelegateInvitationCredential, type FeedInfo, type MemberInfo } from '@dxos/credentials';\nimport { type FeedOptions, type FeedWrapper } from '@dxos/feed-store';\nimport { invariant } from '@dxos/invariant';\nimport { type PublicKey, type SpaceId } from '@dxos/keys';\nimport { log, logInfo } from '@dxos/log';\nimport type { FeedMessage } from '@dxos/protocols/proto/dxos/echo/feed';\nimport { AdmittedFeed, type Credential } from '@dxos/protocols/proto/dxos/halo/credentials';\nimport { type Timeframe } from '@dxos/timeframe';\nimport { trace } from '@dxos/tracing';\nimport { type AsyncCallback, Callback } from '@dxos/util';\n\nimport { ControlPipeline } from './control-pipeline';\nimport { type SpaceProtocol } from './space-protocol';\nimport { type MetadataStore } from '../metadata';\nimport { type PipelineAccessor } from '../pipeline';\n\n// TODO(burdon): Factor out?\ntype FeedProvider = (feedKey: PublicKey, opts?: FeedOptions) => Promise<FeedWrapper<FeedMessage>>;\n\nexport type SpaceParams = {\n  id: SpaceId;\n  spaceKey: PublicKey;\n  protocol: SpaceProtocol;\n  genesisFeed: FeedWrapper<FeedMessage>;\n  feedProvider: FeedProvider;\n  metadataStore: MetadataStore;\n  memberKey: PublicKey;\n\n  // TODO(dmaretskyi): Superseded by epochs.\n  snapshotId?: string | undefined;\n\n  onDelegatedInvitationStatusChange: (invitation: DelegateInvitationCredential, isActive: boolean) => Promise<void>;\n  onMemberRolesChanged: (member: MemberInfo[]) => Promise<void>;\n};\n\nexport type CreatePipelineParams = {\n  start: Timeframe;\n  // designation: AdmittedFeed.Designation;\n};\n\n/**\n * Spaces are globally addressable databases with access control.\n */\n// TODO(dmaretskyi): Extract database stuff.\n// TODO(dmaretskyi): Rename HaloGraph move to HALO.\n@trackLeaks('open', 'close')\n@trace.resource()\nexport class Space extends Resource {\n  public readonly onCredentialProcessed = new Callback<AsyncCallback<Credential>>();\n  public readonly stateUpdate = new Event();\n  @trace.info()\n  public readonly protocol: SpaceProtocol;\n\n  private readonly _id: SpaceId;\n  private readonly _key: PublicKey;\n  private readonly _genesisFeedKey: PublicKey;\n  private readonly _feedProvider: FeedProvider;\n  @trace.info()\n  private readonly _controlPipeline: ControlPipeline;\n\n  private _controlFeed?: FeedWrapper<FeedMessage>;\n  private _dataFeed?: FeedWrapper<FeedMessage>;\n\n  constructor(params: SpaceParams) {\n    super();\n    invariant(params.spaceKey && params.feedProvider);\n    this._id = params.id;\n    this._key = params.spaceKey;\n    this._genesisFeedKey = params.genesisFeed.key;\n    this._feedProvider = params.feedProvider;\n\n    this._controlPipeline = new ControlPipeline({\n      spaceKey: params.spaceKey,\n      genesisFeed: params.genesisFeed,\n      feedProvider: params.feedProvider,\n      metadataStore: params.metadataStore,\n    });\n\n    // TODO(dmaretskyi): Feed set abstraction.\n    this._controlPipeline.onFeedAdmitted.set(async (info) => {\n      // Enable sparse replication to not download mutations covered by prior epochs.\n      const sparse = info.assertion.designation === AdmittedFeed.Designation.DATA;\n\n      if (!info.key.equals(params.genesisFeed.key)) {\n        scheduleMicroTask(this._ctx, async () => {\n          await this.protocol.addFeed(await params.feedProvider(info.key, { sparse }));\n        });\n      }\n    });\n\n    this._controlPipeline.onCredentialProcessed.set(async (credential) => {\n      await this.onCredentialProcessed.callIfSet(credential);\n      log('onCredentialProcessed', { credential });\n      this.stateUpdate.emit();\n    });\n    this._controlPipeline.onDelegatedInvitation.set(async (invitation) => {\n      log('onDelegatedInvitation', { invitation });\n      await params.onDelegatedInvitationStatusChange(invitation, true);\n    });\n    this._controlPipeline.onDelegatedInvitationRemoved.set(async (invitation) => {\n      log('onDelegatedInvitationRemoved', { invitation });\n      await params.onDelegatedInvitationStatusChange(invitation, false);\n    });\n    this._controlPipeline.onMemberRoleChanged.set(async (changedMembers) => {\n      log('onMemberRoleChanged', () => ({ changedMembers: changedMembers.map((m) => [m.key, m.role]) }));\n      await params.onMemberRolesChanged(changedMembers);\n    });\n\n    // Start replicating the genesis feed.\n    this.protocol = params.protocol;\n  }\n\n  @logInfo\n  @trace.info()\n  get id() {\n    return this._id;\n  }\n\n  @logInfo\n  @trace.info()\n  get key() {\n    return this._key;\n  }\n\n  get genesisFeedKey(): PublicKey {\n    return this._genesisFeedKey;\n  }\n\n  get controlFeedKey() {\n    return this._controlFeed?.key;\n  }\n\n  get dataFeedKey() {\n    return this._dataFeed?.key;\n  }\n\n  get spaceState() {\n    return this._controlPipeline.spaceState;\n  }\n\n  /**\n   * @test-only\n   */\n  get controlPipeline(): PipelineAccessor {\n    return this._controlPipeline.pipeline;\n  }\n\n  async setControlFeed(feed: FeedWrapper<FeedMessage>): Promise<this> {\n    invariant(!this._controlFeed, 'Control feed already set.');\n    this._controlFeed = feed;\n    await this._controlPipeline.setWriteFeed(feed);\n    return this;\n  }\n\n  async setDataFeed(feed: FeedWrapper<FeedMessage>): Promise<this> {\n    invariant(!this._dataFeed, 'Data feed already set.');\n    this._dataFeed = feed;\n    return this;\n  }\n\n  /**\n   * Use for diagnostics.\n   */\n  getControlFeeds(): FeedInfo[] {\n    return Array.from(this._controlPipeline.spaceState.feeds.values());\n  }\n\n  @trace.span()\n  protected override async _open(ctx: Context): Promise<void> {\n    log('opening...');\n\n    // Order is important.\n    await this._controlPipeline.start();\n\n    log('opened');\n  }\n\n  @synchronized\n  public async startProtocol(): Promise<void> {\n    invariant(this.isOpen);\n    await this.protocol.start();\n    await this.protocol.addFeed(await this._feedProvider(this._genesisFeedKey));\n  }\n\n  @synchronized\n  protected override async _close(): Promise<void> {\n    log('closing...', { key: this._key });\n\n    // Closes in reverse order to open.\n    await this.protocol.stop();\n    await this._controlPipeline.stop();\n\n    log('closed');\n  }\n}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { DeferredTask, sleepWithContext, trackLeaks } from '@dxos/async';\nimport { Context } from '@dxos/context';\nimport {\n  SpaceStateMachine,\n  type SpaceState,\n  type MemberInfo,\n  type FeedInfo,\n  type DelegateInvitationCredential,\n} from '@dxos/credentials';\nimport { type FeedWrapper } from '@dxos/feed-store';\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { type FeedMessageBlock } from '@dxos/protocols';\nimport type { FeedMessage } from '@dxos/protocols/proto/dxos/echo/feed';\nimport { type ControlPipelineSnapshot } from '@dxos/protocols/proto/dxos/echo/metadata';\nimport { AdmittedFeed, type Credential } from '@dxos/protocols/proto/dxos/halo/credentials';\nimport { Timeframe } from '@dxos/timeframe';\nimport { TimeSeriesCounter, TimeUsageCounter, trace } from '@dxos/tracing';\nimport { type AsyncCallback, Callback, tracer } from '@dxos/util';\n\nimport { type MetadataStore } from '../metadata';\nimport { Pipeline, type PipelineAccessor } from '../pipeline';\n\nexport type ControlPipelineParams = {\n  spaceKey: PublicKey;\n  genesisFeed: FeedWrapper<FeedMessage>;\n  feedProvider: (feedKey: PublicKey) => Promise<FeedWrapper<FeedMessage>>;\n  metadataStore: MetadataStore;\n};\n\nconst TIMEFRAME_SAVE_DEBOUNCE_INTERVAL = 500;\n\nconst CONTROL_PIPELINE_SNAPSHOT_DELAY = 10_000;\n\nconst USE_SNAPSHOTS = true;\n\n/**\n * Processes HALO credentials, which include genesis and invitations.\n */\n@trace.resource()\n@trackLeaks('start', 'stop')\nexport class ControlPipeline {\n  private readonly _ctx = new Context();\n  private readonly _pipeline: Pipeline;\n  private readonly _spaceStateMachine: SpaceStateMachine;\n\n  private readonly _spaceKey: PublicKey;\n  private readonly _metadata: MetadataStore;\n  private _targetTimeframe?: Timeframe;\n  private _lastTimeframeSaveTime: number = Date.now();\n\n  public readonly onFeedAdmitted = new Callback<AsyncCallback<FeedInfo>>();\n  public readonly onMemberRoleChanged: Callback<AsyncCallback<MemberInfo[]>>;\n  public readonly onCredentialProcessed: Callback<AsyncCallback<Credential>>;\n  public readonly onDelegatedInvitation: Callback<AsyncCallback<DelegateInvitationCredential>>;\n  public readonly onDelegatedInvitationRemoved: Callback<AsyncCallback<DelegateInvitationCredential>>;\n\n  @trace.metricsCounter()\n  private _usage = new TimeUsageCounter();\n\n  @trace.metricsCounter()\n  private _mutations = new TimeSeriesCounter();\n\n  private _snapshotTask = new DeferredTask(this._ctx, async () => {\n    await sleepWithContext(this._ctx, CONTROL_PIPELINE_SNAPSHOT_DELAY);\n    await this._saveSnapshot();\n  });\n\n  constructor({ spaceKey, genesisFeed, feedProvider, metadataStore }: ControlPipelineParams) {\n    this._spaceKey = spaceKey;\n    this._metadata = metadataStore;\n    this._pipeline = new Pipeline();\n    void this._pipeline.addFeed(genesisFeed); // TODO(burdon): Require async open/close?\n\n    this._spaceStateMachine = new SpaceStateMachine(spaceKey);\n    this._spaceStateMachine.onFeedAdmitted.set(async (info) => {\n      // log('feed admitted', { info });\n      log('feed admitted', { key: info.key });\n\n      // TODO(burdon): Check not stopping.\n      if (info.assertion.designation === AdmittedFeed.Designation.CONTROL && !info.key.equals(genesisFeed.key)) {\n        queueMicrotask(async () => {\n          try {\n            const feed = await feedProvider(info.key);\n            if (!this._pipeline.hasFeed(feed.key)) {\n              await this._pipeline.addFeed(feed);\n            }\n          } catch (err: any) {\n            log.catch(err);\n          }\n        });\n      }\n\n      await this.onFeedAdmitted.callIfSet(info);\n    });\n\n    this.onMemberRoleChanged = this._spaceStateMachine.onMemberRoleChanged;\n    this.onCredentialProcessed = this._spaceStateMachine.onCredentialProcessed;\n    this.onDelegatedInvitation = this._spaceStateMachine.onDelegatedInvitation;\n    this.onDelegatedInvitationRemoved = this._spaceStateMachine.onDelegatedInvitationRemoved;\n  }\n\n  get spaceState(): SpaceState {\n    return this._spaceStateMachine;\n  }\n\n  get pipeline(): PipelineAccessor {\n    return this._pipeline;\n  }\n\n  async setWriteFeed(feed: FeedWrapper<FeedMessage>): Promise<void> {\n    await this._pipeline.addFeed(feed);\n    this._pipeline.setWriteFeed(feed);\n  }\n\n  @trace.span({ showInBrowserTimeline: true })\n  async start(): Promise<void> {\n    const snapshot = this._metadata.getSpaceControlPipelineSnapshot(this._spaceKey);\n    log('load snapshot', { key: this._spaceKey, present: !!snapshot, tf: snapshot?.timeframe });\n    if (USE_SNAPSHOTS && snapshot) {\n      await this._processSnapshot(snapshot);\n    }\n\n    log('starting...');\n    setTimeout(async () => {\n      void this._consumePipeline(new Context());\n    });\n\n    await this._pipeline.start();\n    log('started');\n  }\n\n  private async _processSnapshot(snapshot: ControlPipelineSnapshot): Promise<void> {\n    await this._pipeline.setCursor(snapshot.timeframe);\n\n    for (const message of snapshot.messages ?? []) {\n      const result = await this._spaceStateMachine.process(message.credential, {\n        sourceFeed: message.feedKey,\n        skipVerification: true,\n      });\n\n      if (!result) {\n        log.warn('credential processing failed from snapshot', { message });\n      }\n    }\n  }\n\n  private async _saveSnapshot(): Promise<void> {\n    await this._pipeline.pause();\n    const snapshot: ControlPipelineSnapshot = {\n      timeframe: this._pipeline.state.timeframe,\n      messages: this._spaceStateMachine.credentialEntries.map((entry) => ({\n        feedKey: entry.sourceFeed,\n        credential: entry.credential,\n      })),\n    };\n    await this._pipeline.unpause();\n\n    log('save snapshot', { key: this._spaceKey, snapshot: getSnapshotLoggerContext(snapshot) });\n    await this._metadata.setSpaceControlPipelineSnapshot(this._spaceKey, snapshot);\n  }\n\n  @trace.span()\n  private async _consumePipeline(ctx: Context): Promise<void> {\n    for await (const msg of this._pipeline.consume()) {\n      const span = this._usage.beginRecording();\n      this._mutations.inc();\n\n      try {\n        await this._processMessage(ctx, msg);\n      } catch (err: any) {\n        log.catch(err);\n      }\n\n      span.end();\n    }\n  }\n\n  @trace.span()\n  private async _processMessage(ctx: Context, msg: FeedMessageBlock): Promise<void> {\n    log('processing', { key: msg.feedKey, seq: msg.seq });\n    if (msg.data.payload.credential) {\n      const timer = tracer.mark('dxos.echo.pipeline.control');\n      const result = await this._spaceStateMachine.process(msg.data.payload.credential.credential, {\n        sourceFeed: PublicKey.from(msg.feedKey),\n      });\n\n      timer.end();\n      if (!result) {\n        log.warn('processing failed', { msg });\n      } else {\n        await this._noteTargetStateIfNeeded(this._pipeline.state.pendingTimeframe);\n      }\n\n      this._snapshotTask.schedule();\n    }\n  }\n\n  private async _noteTargetStateIfNeeded(timeframe: Timeframe): Promise<void> {\n    // TODO(dmaretskyi): Replace this with a proper debounce/throttle.\n\n    if (Date.now() - this._lastTimeframeSaveTime > TIMEFRAME_SAVE_DEBOUNCE_INTERVAL) {\n      this._lastTimeframeSaveTime = Date.now();\n\n      await this._saveTargetTimeframe(timeframe);\n    }\n  }\n\n  async stop(): Promise<void> {\n    log('stopping...');\n    await this._ctx.dispose();\n    await this._pipeline.stop();\n    await this._saveTargetTimeframe(this._pipeline.state.timeframe);\n    log('stopped');\n  }\n\n  private async _saveTargetTimeframe(timeframe: Timeframe): Promise<void> {\n    try {\n      const newTimeframe = Timeframe.merge(this._targetTimeframe ?? new Timeframe(), timeframe);\n      await this._metadata.setSpaceControlLatestTimeframe(this._spaceKey, newTimeframe);\n      this._targetTimeframe = newTimeframe;\n    } catch (err: any) {\n      log(err);\n    }\n  }\n}\n\nconst getSnapshotLoggerContext = (snapshot: ControlPipelineSnapshot) => {\n  return snapshot.messages?.map((msg) => {\n    const issuer = msg.credential.issuer;\n    const subject = msg.credential.subject.id;\n    const type = msg.credential.subject.assertion['@type'];\n    return { issuer, subject, type };\n  });\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { scheduleTask, type Trigger } from '@dxos/async';\nimport { Context } from '@dxos/context';\nimport { ProtocolError } from '@dxos/protocols';\nimport { schema } from '@dxos/protocols/proto';\nimport { type Credential } from '@dxos/protocols/proto/dxos/halo/credentials';\nimport {\n  type AdmissionDiscoveryService,\n  type GetAdmissionCredentialResponse,\n  type GetAdmissionCredentialRequest,\n} from '@dxos/protocols/proto/dxos/mesh/teleport';\nimport { type ExtensionContext, RpcExtension } from '@dxos/teleport';\n\nimport { type Space } from './space';\n\n/**\n * Guest's side for a connection to a concrete peer in p2p network during invitation.\n */\nexport class CredentialRetrieverExtension extends RpcExtension<\n  { AdmissionDiscoveryService: AdmissionDiscoveryService },\n  {}\n> {\n  private _ctx = new Context();\n\n  constructor(\n    private readonly _request: GetAdmissionCredentialRequest,\n    private readonly _onResult: Trigger<Credential>,\n  ) {\n    super({\n      requested: {\n        AdmissionDiscoveryService: schema.getService('dxos.mesh.teleport.AdmissionDiscoveryService'),\n      },\n    });\n  }\n\n  protected override async getHandlers(): Promise<{}> {\n    return {};\n  }\n\n  override async onOpen(context: ExtensionContext): Promise<void> {\n    await super.onOpen(context);\n    scheduleTask(this._ctx, async () => {\n      try {\n        const result = await this.rpc.AdmissionDiscoveryService.getAdmissionCredential(this._request);\n        this._onResult.wake(result.admissionCredential);\n      } catch (err: any) {\n        context.close(err);\n      }\n    });\n  }\n\n  override async onClose(): Promise<void> {\n    await this._ctx.dispose();\n  }\n\n  override async onAbort(): Promise<void> {\n    await this._ctx.dispose();\n  }\n}\n\nexport class CredentialServerExtension extends RpcExtension<\n  {},\n  { AdmissionDiscoveryService: AdmissionDiscoveryService }\n> {\n  constructor(private readonly _space: Space) {\n    super({\n      exposed: {\n        AdmissionDiscoveryService: schema.getService('dxos.mesh.teleport.AdmissionDiscoveryService'),\n      },\n    });\n  }\n\n  protected override async getHandlers(): Promise<{ AdmissionDiscoveryService: AdmissionDiscoveryService }> {\n    return {\n      AdmissionDiscoveryService: {\n        getAdmissionCredential: async (\n          request: GetAdmissionCredentialRequest,\n        ): Promise<GetAdmissionCredentialResponse> => {\n          const memberInfo = this._space.spaceState.members.get(request.memberKey);\n          if (!memberInfo?.credential) {\n            throw new ProtocolError('Space member not found.', request);\n          }\n          return { admissionCredential: memberInfo.credential };\n        },\n      },\n    };\n  }\n}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { type Event } from '@dxos/async';\nimport { discoveryKey, subtleCrypto } from '@dxos/crypto';\nimport { type FeedWrapper } from '@dxos/feed-store';\nimport { PublicKey } from '@dxos/keys';\nimport { log, logInfo } from '@dxos/log';\nimport {\n  MMSTTopology,\n  type SwarmNetworkManager,\n  type SwarmConnection,\n  type WireProtocol,\n  type WireProtocolParams,\n  type WireProtocolProvider,\n} from '@dxos/network-manager';\nimport type { FeedMessage } from '@dxos/protocols/proto/dxos/echo/feed';\nimport { type MuxerStats, Teleport } from '@dxos/teleport';\nimport { type BlobStore, BlobSync } from '@dxos/teleport-extension-object-sync';\nimport { ReplicatorExtension } from '@dxos/teleport-extension-replicator';\nimport { trace } from '@dxos/tracing';\nimport { CallbackCollection, ComplexMap, type AsyncCallback } from '@dxos/util';\n\nimport { AuthExtension, type AuthProvider, type AuthVerifier } from './auth';\n\nexport const MOCK_AUTH_PROVIDER: AuthProvider = async (nonce: Uint8Array) => Buffer.from('mock');\nexport const MOCK_AUTH_VERIFIER: AuthVerifier = async (nonce: Uint8Array, credential: Uint8Array) => true;\n\n// TODO(burdon): Reconcile with SigningContext (define types together).\nexport interface SwarmIdentity {\n  peerKey: PublicKey;\n  identityKey: PublicKey;\n  credentialProvider: AuthProvider;\n  credentialAuthenticator: AuthVerifier;\n}\n\nexport type SpaceProtocolOptions = {\n  topic: PublicKey; // TODO(burdon): Rename?\n  swarmIdentity: SwarmIdentity;\n  networkManager: SwarmNetworkManager;\n\n  blobStore: BlobStore;\n\n  onFeed?: (feed: FeedWrapper<FeedMessage>) => Promise<void>;\n\n  /**\n   * Called when new session is authenticated.\n   * Additional extensions can be added here.\n   */\n  onSessionAuth?: (session: Teleport) => void;\n  onAuthFailure?: (session: Teleport) => void;\n\n  disableP2pReplication?: boolean;\n};\n\n/**\n * Manages Teleport protocol stream creation and joining swarms with replication and presence extensions.\n */\n@trace.resource()\nexport class SpaceProtocol {\n  private readonly _networkManager: SwarmNetworkManager;\n  private readonly _swarmIdentity: SwarmIdentity;\n  private readonly _onSessionAuth?: (session: Teleport) => void;\n  private readonly _onAuthFailure?: (session: Teleport) => void;\n\n  public readonly blobSync: BlobSync;\n\n  private readonly _disableP2pReplication: boolean;\n\n  @logInfo\n  @trace.info()\n  private readonly _topic: Promise<PublicKey>;\n\n  @trace.info()\n  private readonly _spaceKey: PublicKey;\n\n  private readonly _feeds = new Set<FeedWrapper<FeedMessage>>();\n  private readonly _sessions = new ComplexMap<PublicKey, SpaceProtocolSession>(PublicKey.hash);\n  // TODO(burdon): Move to config (with sensible defaults).\n  private readonly _topology = new MMSTTopology({\n    originateConnections: 4,\n    maxPeers: 10,\n    sampleSize: 20,\n  });\n\n  private _connection?: SwarmConnection;\n\n  public readonly feedAdded = new CallbackCollection<AsyncCallback<FeedWrapper<FeedMessage>>>();\n\n  get sessions(): ReadonlyMap<PublicKey, SpaceProtocolSession> {\n    return this._sessions;\n  }\n\n  get feeds(): ReadonlySet<FeedWrapper<FeedMessage>> {\n    return this._feeds;\n  }\n\n  @logInfo\n  private get _ownPeerKey() {\n    return this._swarmIdentity.peerKey;\n  }\n\n  constructor({\n    topic,\n    swarmIdentity,\n    networkManager,\n    onSessionAuth,\n    onAuthFailure,\n    blobStore,\n    disableP2pReplication,\n  }: SpaceProtocolOptions) {\n    this._spaceKey = topic;\n    this._networkManager = networkManager;\n    this._swarmIdentity = swarmIdentity;\n    this._onSessionAuth = onSessionAuth;\n    this._onAuthFailure = onAuthFailure;\n    this.blobSync = new BlobSync({ blobStore });\n\n    // TODO(burdon): Async race condition? Move to start?\n    this._topic = subtleCrypto.digest('SHA-256', topic.asBuffer()).then(discoveryKey).then(PublicKey.from);\n\n    this._disableP2pReplication = disableP2pReplication ?? false;\n  }\n\n  // TODO(burdon): Create abstraction for Space (e.g., add keys and have provider).\n  async addFeed(feed: FeedWrapper<FeedMessage>): Promise<void> {\n    log('addFeed', { key: feed.key });\n\n    this._feeds.add(feed);\n    for (const session of this._sessions.values()) {\n      session.replicator.addFeed(feed);\n    }\n\n    await this.feedAdded.callSerial(feed);\n  }\n\n  // TODO(burdon): Rename open? Common open/close interfaces for all services?\n  async start(): Promise<void> {\n    if (this._connection) {\n      return;\n    }\n\n    // TODO(burdon): Document why empty buffer.\n    const credentials = await this._swarmIdentity.credentialProvider(Buffer.from(''));\n\n    await this.blobSync.open();\n\n    log('starting...');\n    const topic = await this._topic;\n    this._connection = await this._networkManager.joinSwarm({\n      protocolProvider: this._createProtocolProvider(credentials),\n      topic,\n      topology: this._topology,\n      label: `swarm ${topic.truncate()} for space ${this._spaceKey.truncate()}`,\n    });\n\n    log('started');\n  }\n\n  public updateTopology(): void {\n    this._topology.forceUpdate();\n  }\n\n  async stop(): Promise<void> {\n    await this.blobSync.close();\n\n    if (this._connection) {\n      log('stopping...');\n      await this._connection.close();\n      log('stopped');\n    }\n  }\n\n  private _createProtocolProvider(credentials: Uint8Array | undefined): WireProtocolProvider {\n    return (wireParams) => {\n      const session = new SpaceProtocolSession({\n        wireParams,\n        swarmIdentity: this._swarmIdentity,\n        onSessionAuth: this._onSessionAuth,\n        onAuthFailure: this._onAuthFailure,\n        blobSync: this.blobSync,\n        disableP2pReplication: this._disableP2pReplication,\n      });\n      this._sessions.set(wireParams.remotePeerId, session);\n\n      for (const feed of this._feeds) {\n        session.replicator.addFeed(feed);\n      }\n\n      return session;\n    };\n  }\n}\n\nexport type SpaceProtocolSessionParams = {\n  wireParams: WireProtocolParams;\n  swarmIdentity: SwarmIdentity;\n\n  blobSync: BlobSync;\n\n  /**\n   * Called when new session is authenticated.\n   * Additional extensions can be added here.\n   */\n  onSessionAuth?: (session: Teleport) => void;\n\n  onAuthFailure?: (session: Teleport) => void;\n\n  disableP2pReplication?: boolean;\n};\n\nexport enum AuthStatus {\n  INITIAL = 'INITIAL',\n  SUCCESS = 'SUCCESS',\n  FAILURE = 'FAILURE',\n}\n\n// TODO(dmaretskyi): Move to a separate file.\n/**\n * Represents a single connection to a remote peer\n */\nexport class SpaceProtocolSession implements WireProtocol {\n  @logInfo\n  private readonly _wireParams: WireProtocolParams;\n\n  private readonly _disableP2pReplication: boolean;\n\n  private readonly _onSessionAuth?: (session: Teleport) => void;\n  private readonly _onAuthFailure?: (session: Teleport) => void;\n  private readonly _swarmIdentity: SwarmIdentity;\n  private readonly _blobSync: BlobSync;\n\n  private readonly _teleport: Teleport;\n\n  // TODO(dmaretskyi): Start with upload=false when switching it on the fly works.\n  public readonly replicator = new ReplicatorExtension().setOptions({ upload: true });\n\n  private _authStatus = AuthStatus.INITIAL;\n\n  @logInfo\n  get authStatus() {\n    return this._authStatus;\n  }\n\n  get stats(): Event<MuxerStats> {\n    return this._teleport.stats;\n  }\n\n  // TODO(dmaretskyi): Allow to pass in extra extensions.\n  constructor({\n    wireParams,\n    swarmIdentity,\n    onSessionAuth,\n    onAuthFailure,\n    blobSync,\n    disableP2pReplication,\n  }: SpaceProtocolSessionParams) {\n    this._wireParams = wireParams;\n    this._swarmIdentity = swarmIdentity;\n    this._onSessionAuth = onSessionAuth;\n    this._onAuthFailure = onAuthFailure;\n    this._blobSync = blobSync;\n\n    this._teleport = new Teleport(wireParams);\n\n    this._disableP2pReplication = disableP2pReplication ?? false;\n  }\n\n  get stream() {\n    return this._teleport.stream;\n  }\n\n  async open(sessionId?: PublicKey): Promise<void> {\n    await this._teleport.open(sessionId);\n    this._teleport.addExtension(\n      'dxos.mesh.teleport.auth',\n      new AuthExtension({\n        provider: this._swarmIdentity.credentialProvider,\n        verifier: this._swarmIdentity.credentialAuthenticator,\n        onAuthSuccess: () => {\n          log('Peer authenticated');\n          this._authStatus = AuthStatus.SUCCESS;\n          this._onSessionAuth?.(this._teleport);\n          // TODO(dmaretskyi): Configure replicator to upload.\n        },\n        onAuthFailure: () => {\n          this._authStatus = AuthStatus.FAILURE;\n          this._onAuthFailure?.(this._teleport);\n        },\n      }),\n    );\n\n    if (!this._disableP2pReplication) {\n      this._teleport.addExtension('dxos.mesh.teleport.replicator', this.replicator);\n    }\n    this._teleport.addExtension('dxos.mesh.teleport.blobsync', this._blobSync.createExtension());\n  }\n\n  async close(): Promise<void> {\n    log('close');\n    await this._teleport.close();\n  }\n\n  async abort(): Promise<void> {\n    await this._teleport.abort();\n  }\n}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { type AutomergeUrl, parseAutomergeUrl } from '@automerge/automerge-repo';\n\nimport { synchronized, trackLeaks, Trigger } from '@dxos/async';\nimport { getCredentialAssertion, type DelegateInvitationCredential, type MemberInfo } from '@dxos/credentials';\nimport { failUndefined } from '@dxos/debug';\nimport { type FeedStore } from '@dxos/feed-store';\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { type SwarmNetworkManager } from '@dxos/network-manager';\nimport { trace } from '@dxos/protocols';\nimport type { FeedMessage } from '@dxos/protocols/proto/dxos/echo/feed';\nimport { type SpaceMetadata } from '@dxos/protocols/proto/dxos/echo/metadata';\nimport type { Credential } from '@dxos/protocols/proto/dxos/halo/credentials';\nimport { type Teleport } from '@dxos/teleport';\nimport { type BlobStore } from '@dxos/teleport-extension-object-sync';\nimport { ComplexMap } from '@dxos/util';\n\nimport { CredentialRetrieverExtension } from './admission-discovery-extension';\nimport { Space } from './space';\nimport { SpaceProtocol, type SwarmIdentity } from './space-protocol';\nimport { createIdFromSpaceKey } from '../common/space-id';\nimport { type MetadataStore } from '../metadata';\n\nexport type SpaceManagerParams = {\n  feedStore: FeedStore<FeedMessage>;\n  networkManager: SwarmNetworkManager;\n  metadataStore: MetadataStore;\n\n  blobStore: BlobStore;\n\n  disableP2pReplication?: boolean;\n};\n\nexport type ConstructSpaceParams = {\n  metadata: SpaceMetadata;\n  swarmIdentity: SwarmIdentity;\n  memberKey: PublicKey;\n  /**\n   * Called when connection auth passed successful.\n   */\n  onAuthorizedConnection: (session: Teleport) => void;\n  onAuthFailure?: (session: Teleport) => void;\n  onDelegatedInvitationStatusChange: (invitation: DelegateInvitationCredential, isActive: boolean) => Promise<void>;\n  onMemberRolesChanged: (member: MemberInfo[]) => Promise<void>;\n};\n\nexport type RequestSpaceAdmissionCredentialParams = {\n  spaceKey: PublicKey;\n  identityKey: PublicKey;\n  swarmIdentity: SwarmIdentity;\n  timeout: number;\n};\n\n/**\n * Manages a collection of ECHO (Data) Spaces.\n */\n@trackLeaks('open', 'close')\nexport class SpaceManager {\n  private readonly _spaces = new ComplexMap<PublicKey, Space>(PublicKey.hash);\n  private readonly _feedStore: FeedStore<FeedMessage>;\n  private readonly _networkManager: SwarmNetworkManager;\n  private readonly _metadataStore: MetadataStore;\n  private readonly _blobStore: BlobStore;\n  private readonly _instanceId = PublicKey.random().toHex();\n  private readonly _disableP2pReplication: boolean;\n\n  constructor({ feedStore, networkManager, metadataStore, blobStore, disableP2pReplication }: SpaceManagerParams) {\n    // TODO(burdon): Assert.\n    this._feedStore = feedStore;\n    this._networkManager = networkManager;\n    this._metadataStore = metadataStore;\n    this._blobStore = blobStore;\n    this._disableP2pReplication = disableP2pReplication ?? false;\n  }\n\n  // TODO(burdon): Remove.\n  get spaces() {\n    return this._spaces;\n  }\n\n  @synchronized\n  async open(): Promise<void> {}\n\n  @synchronized\n  async close(): Promise<void> {\n    await Promise.all([...this._spaces.values()].map((space) => space.close()));\n  }\n\n  async constructSpace({\n    metadata,\n    swarmIdentity,\n    onAuthorizedConnection,\n    onAuthFailure,\n    onDelegatedInvitationStatusChange,\n    onMemberRolesChanged,\n    memberKey,\n  }: ConstructSpaceParams): Promise<Space> {\n    log.trace('dxos.echo.space-manager.construct-space', trace.begin({ id: this._instanceId }));\n    log('constructing space...', { spaceKey: metadata.genesisFeedKey });\n\n    // The genesis feed will be the same as the control feed if the space was created by the local agent.\n    const genesisFeed = await this._feedStore.openFeed(metadata.genesisFeedKey ?? failUndefined());\n\n    const spaceKey = metadata.key;\n    const spaceId = await createIdFromSpaceKey(spaceKey);\n    const protocol = new SpaceProtocol({\n      topic: spaceKey,\n      swarmIdentity,\n      networkManager: this._networkManager,\n      onSessionAuth: onAuthorizedConnection,\n      onAuthFailure,\n      blobStore: this._blobStore,\n      disableP2pReplication: this._disableP2pReplication,\n    });\n\n    const space = new Space({\n      id: spaceId,\n      spaceKey,\n      protocol,\n      genesisFeed,\n      feedProvider: (feedKey, opts) => this._feedStore.openFeed(feedKey, opts),\n      metadataStore: this._metadataStore,\n      memberKey,\n      onDelegatedInvitationStatusChange,\n      onMemberRolesChanged,\n    });\n    this._spaces.set(space.key, space);\n\n    log.trace('dxos.echo.space-manager.construct-space', trace.end({ id: this._instanceId }));\n    return space;\n  }\n\n  public async requestSpaceAdmissionCredential(params: RequestSpaceAdmissionCredentialParams): Promise<Credential> {\n    const traceKey = 'dxos.echo.space-manager.request-space-admission';\n    log.trace(traceKey, trace.begin({ id: this._instanceId }));\n    log('requesting space admission credential...', { spaceKey: params.spaceKey });\n\n    const onCredentialResolved = new Trigger<Credential>();\n    const protocol = new SpaceProtocol({\n      topic: params.spaceKey,\n      swarmIdentity: params.swarmIdentity,\n      networkManager: this._networkManager,\n      onSessionAuth: (session: Teleport) => {\n        session.addExtension(\n          'dxos.mesh.teleport.admission-discovery',\n          new CredentialRetrieverExtension(\n            { spaceKey: params.spaceKey, memberKey: params.identityKey },\n            onCredentialResolved,\n          ),\n        );\n      },\n      onAuthFailure: (session: Teleport) => session.close(),\n      blobStore: this._blobStore,\n      disableP2pReplication: this._disableP2pReplication,\n    });\n\n    try {\n      await protocol.start();\n      const credential = await onCredentialResolved.wait({ timeout: params.timeout });\n      log.trace(traceKey, trace.end({ id: this._instanceId }));\n      return credential;\n    } catch (err: any) {\n      log.trace(traceKey, trace.error({ id: this._instanceId, error: err }));\n      throw err;\n    } finally {\n      await protocol.stop();\n    }\n  }\n\n  public findSpaceByRootDocumentId(documentId: string): Space | undefined {\n    return [...this._spaces.values()].find((space) => {\n      return space.spaceState.credentials.some((credential) => {\n        const assertion = getCredentialAssertion(credential);\n        if (assertion['@type'] !== 'dxos.halo.credentials.Epoch') {\n          return false;\n        }\n        if (!assertion?.automergeRoot) {\n          return false;\n        }\n        return parseAutomergeUrl(assertion.automergeRoot as AutomergeUrl).documentId === documentId;\n      });\n    });\n  }\n}\n"],
  "mappings": "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",
  "names": ["import_invariant", "import_keys", "import_proto", "import_util", "import_async", "import_log", "import_context", "import_debug", "import_timeframe", "import_crypto", "import_credentials", "import_tracing", "import_protocols", "import_teleport", "codec", "schema", "getCodecForType", "valueEncoding", "createCodecEncoding", "createMappedFeedWriter", "mapper", "writer", "invariant", "write", "data", "options", "SPACE_IDS_CACHE", "ComplexMap", "PublicKey", "hash", "createIdFromSpaceKey", "spaceKey", "cachedValue", "get", "undefined", "digest", "subtleCrypto", "asUint8Array", "bytes", "Uint8Array", "slice", "SpaceId", "byteLength", "spaceId", "encode", "set", "EXPIRED_INVITATION_CLEANUP_INTERVAL", "emptyEchoMetadata", "version", "STORAGE_VERSION", "spaces", "created", "Date", "updated", "emptyLargeSpaceMetadata", "EchoMetadata", "LargeSpaceMetadata", "MetadataStore", "directory", "_metadata", "_spaceLargeMetadata", "_metadataFile", "update", "Event", "_invitationCleanupCtx", "Context", "_directory", "metadata", "_readFile", "file", "size", "fileLength", "stat", "dataSize", "fromBytesInt32", "read", "checksum", "log", "name", "filename", "DataCorruptionError", "calculatedChecksum", "CRC32", "buf", "decode", "close", "_writeFile", "encoded", "arrayToBuffer", "result", "Buffer", "alloc", "length", "writeInt32LE", "copy", "dispose", "flush", "clear", "load", "closed", "getOrCreateFile", "forEach", "space", "state", "SpaceState", "SPACE_ACTIVE", "err", "error", "forEachAsync", "identity", "haloSpace", "key", "map", "filter", "isNonNullable", "_loadSpaceLargeMetadata", "scheduleTaskInterval", "invitation", "invitations", "hasInvitationExpired", "isLegacyInvitationFormat", "removeInvitation", "invitationId", "_save", "emit", "toHex", "_saveSpaceLargeMetadata", "_getLargeSpaceMetadata", "_getSpace", "equals", "find", "hasSpace", "entry", "delete", "getIdentityRecord", "setIdentityRecord", "record", "getInvitations", "addInvitation", "i", "push", "addSpace", "setSpaceDataLatestTimeframe", "timeframe", "dataTimeframe", "setSpaceControlLatestTimeframe", "controlTimeframe", "setCache", "cache", "setWritableFeedKeys", "controlFeedKey", "dataFeedKey", "setSpaceState", "getSpaceControlPipelineSnapshot", "controlPipelineSnapshot", "setSpaceControlPipelineSnapshot", "snapshot", "getSpaceEdgeReplicationSetting", "edgeReplication", "setSpaceEdgeReplicationSetting", "setting", "readInt32LE", "Boolean", "lifetime", "getTime", "now", "type", "Invitation", "Type", "MULTIUSE", "mapTimeframeToFeedIndexes", "frames", "feedKey", "index", "mapFeedIndexesToTimeframe", "indexes", "Timeframe", "startAfter", "TimeframeClock", "_timeframe", "_pendingTimeframe", "pendingTimeframe", "setTimeframe", "updatePendingTimeframe", "seq", "merge", "updateTimeframe", "hasGaps", "gaps", "dependencies", "isEmpty", "waitUntilReached", "target", "current", "waitForCondition", "deps", "createMessageSelector", "timeframeClock", "messages", "PipelineState", "_feeds", "_timeframeClock", "_ctx", "timeframeUpdate", "stalled", "_startTimeframe", "_reachedTarget", "endTimeframe", "Array", "from", "values", "feed", "startTimeframe", "targetTimeframe", "_targetTimeframe", "reachedTarget", "feeds", "waitUntilTimeframe", "setTargetTimeframe", "waitUntilReachedTargetTimeframe", "ctx", "timeout", "breakOnStall", "_reachedTargetPromise", "Promise", "race", "discardParameter", "waitForCount", "done", "rejectOnDispose", "then", "sleepWithContext", "warn", "Pipeline", "Trigger", "wake", "_pauseTrigger", "value", "_isStopping", "_isStarted", "_isBeingConsumed", "_isPaused", "_state", "_writer", "hasFeed", "has", "getFeeds", "_feedSetIterator", "addFeed", "_setFeedDownloadState", "setWriteFeed", "properties", "writable", "payload", "createFeedWriter", "start", "_initIterator", "open", "stop", "handle", "_downloads", "entries", "undownload", "_processingTrigger", "wait", "setCursor", "pause", "reset", "unpause", "consume", "lastFeedSetIterator", "iterable", "Symbol", "asyncIterator", "next", "block", "failUndefined", "truncate", "download", "linear", "FeedSetIterator", "stallTimeout", "on", "iterator", "currentTimeframe", "AuthExtension", "RpcExtension", "_authParams", "requested", "AuthService", "getService", "exposed", "onError", "catch", "getHandlers", "authenticate", "challenge", "credential", "provider", "Error", "onOpen", "context", "scheduleTask", "randomBytes", "rpc", "success", "verifier", "runInContext", "onAuthSuccess", "onAuthFailure", "onClose", "onAbort", "TIMEFRAME_SAVE_DEBOUNCE_INTERVAL", "CONTROL_PIPELINE_SNAPSHOT_DELAY", "USE_SNAPSHOTS", "ControlPipeline", "genesisFeed", "feedProvider", "metadataStore", "_lastTimeframeSaveTime", "onFeedAdmitted", "Callback", "_usage", "TimeUsageCounter", "_mutations", "TimeSeriesCounter", "_snapshotTask", "DeferredTask", "_saveSnapshot", "_spaceKey", "_pipeline", "_spaceStateMachine", "SpaceStateMachine", "info", "assertion", "designation", "AdmittedFeed", "Designation", "CONTROL", "queueMicrotask", "callIfSet", "onMemberRoleChanged", "onCredentialProcessed", "onDelegatedInvitation", "onDelegatedInvitationRemoved", "spaceState", "pipeline", "present", "tf", "_processSnapshot", "setTimeout", "_consumePipeline", "message", "process", "sourceFeed", "skipVerification", "credentialEntries", "getSnapshotLoggerContext", "msg", "span", "beginRecording", "inc", "_processMessage", "end", "timer", "tracer", "mark", "_noteTargetStateIfNeeded", "schedule", "_saveTargetTimeframe", "newTimeframe", "metricsCounter", "showInBrowserTimeline", "resource", "issuer", "subject", "id", "Space", "Resource", "params", "stateUpdate", "_id", "_key", "_genesisFeedKey", "_feedProvider", "_controlPipeline", "sparse", "DATA", "scheduleMicroTask", "protocol", "onDelegatedInvitationStatusChange", "changedMembers", "m", "role", "onMemberRolesChanged", "genesisFeedKey", "_controlFeed", "_dataFeed", "controlPipeline", "setControlFeed", "setDataFeed", "getControlFeeds", "_open", "startProtocol", "isOpen", "_close", "CredentialRetrieverExtension", "_request", "_onResult", "AdmissionDiscoveryService", "getAdmissionCredential", "admissionCredential", "CredentialServerExtension", "_space", "request", "memberInfo", "members", "memberKey", "ProtocolError", "MOCK_AUTH_PROVIDER", "nonce", "MOCK_AUTH_VERIFIER", "SpaceProtocol", "topic", "swarmIdentity", "networkManager", "onSessionAuth", "blobStore", "disableP2pReplication", "Set", "_sessions", "MMSTTopology", "originateConnections", "maxPeers", "sampleSize", "feedAdded", "CallbackCollection", "_networkManager", "_swarmIdentity", "_onSessionAuth", "_onAuthFailure", "blobSync", "BlobSync", "_topic", "asBuffer", "discoveryKey", "_disableP2pReplication", "sessions", "_ownPeerKey", "peerKey", "add", "session", "replicator", "callSerial", "_connection", "credentials", "credentialProvider", "joinSwarm", "protocolProvider", "_createProtocolProvider", "topology", "_topology", "label", "updateTopology", "forceUpdate", "wireParams", "SpaceProtocolSession", "remotePeerId", "AuthStatus", "ReplicatorExtension", "setOptions", "upload", "_authStatus", "_wireParams", "_blobSync", "_teleport", "Teleport", "authStatus", "stats", "stream", "sessionId", "addExtension", "credentialAuthenticator", "createExtension", "abort", "SpaceManager", "feedStore", "_spaces", "_instanceId", "random", "_feedStore", "_metadataStore", "_blobStore", "all", "constructSpace", "onAuthorizedConnection", "trace", "begin", "openFeed", "opts", "requestSpaceAdmissionCredential", "traceKey", "onCredentialResolved", "identityKey", "findSpaceByRootDocumentId", "documentId", "some", "getCredentialAssertion", "automergeRoot", "parseAutomergeUrl"]
}
