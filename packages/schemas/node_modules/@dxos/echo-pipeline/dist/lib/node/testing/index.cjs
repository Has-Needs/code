"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var testing_exports = {};
__export(testing_exports, {
  MemoryNetworkManagerProvider: () => MemoryNetworkManagerProvider,
  TestAdapter: () => TestAdapter,
  TestAgent: () => TestAgent,
  TestAgentBuilder: () => TestAgentBuilder,
  TestData: () => test_data_exports,
  TestFeedBuilder: () => TestFeedBuilder,
  TestReplicationNetwork: () => TestReplicationNetwork,
  TestReplicator: () => TestReplicator,
  TestReplicatorConnection: () => TestReplicatorConnection,
  TestSchema: () => test_schema_exports,
  WebsocketNetworkManagerProvider: () => WebsocketNetworkManagerProvider,
  brokenAutomergeReplicatorFactory: () => brokenAutomergeReplicatorFactory,
  changeStorageVersionInMetadata: () => changeStorageVersionInMetadata,
  testAutomergeReplicatorFactory: () => testAutomergeReplicatorFactory
});
module.exports = __toCommonJS(testing_exports);
var import_chunk_JXX6LF5U = require("../chunk-JXX6LF5U.cjs");
var import_chunk_Q7SFCCGT = require("../chunk-Q7SFCCGT.cjs");
var import_log = require("@dxos/log");
var import_proto = require("@dxos/protocols/proto");
var import_context = require("@dxos/context");
var import_credentials = require("@dxos/credentials");
var import_keys = require("@dxos/keys");
var import_messaging = require("@dxos/messaging");
var import_network_manager = require("@dxos/network-manager");
var import_credentials2 = require("@dxos/protocols/proto/dxos/halo/credentials");
var import_random_access_storage = require("@dxos/random-access-storage");
var import_teleport_extension_gossip = require("@dxos/teleport-extension-gossip");
var import_teleport_extension_object_sync = require("@dxos/teleport-extension-object-sync");
var import_util = require("@dxos/util");
var import_testing = require("@dxos/feed-store/testing");
var import_automerge_repo = require("@automerge/automerge-repo");
var import_async = require("@dxos/async");
var import_invariant = require("@dxos/invariant");
var import_log2 = require("@dxos/log");
var import_async2 = require("@dxos/async");
var import_context2 = require("@dxos/context");
var import_invariant2 = require("@dxos/invariant");
var import_log3 = require("@dxos/log");
var import_teleport_extension_automerge_replicator = require("@dxos/teleport-extension-automerge-replicator");
var import_effect = require("effect");
var import_echo = require("@dxos/echo");
var import_echo_protocol = require("@dxos/echo-protocol");
var import_echo_schema = require("@dxos/echo-schema");
var import_keys2 = require("@dxos/keys");
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/core/echo/echo-pipeline/src/testing/change-metadata.ts";
var EchoMetadata = import_proto.schema.getCodecForType("dxos.echo.metadata.EchoMetadata");
var changeStorageVersionInMetadata = async (storage, version) => {
  (0, import_log.log)("Changing storage version in metadata. USE ONLY FOR TESTING.", void 0, {
    F: __dxlog_file,
    L: 19,
    S: void 0,
    C: (f, a) => f(...a)
  });
  const metadata = new import_chunk_JXX6LF5U.MetadataStore(storage.createDirectory("metadata"));
  await metadata.load();
  const echoMetadata = metadata.metadata;
  echoMetadata.version = version;
  const file = metadata._directory.getOrCreateFile("EchoMetadata");
  await metadata._writeFile(file, EchoMetadata, echoMetadata);
  await metadata._directory.flush();
};
var TestFeedBuilder = class extends import_testing.TestBuilder {
  constructor() {
    super({
      valueEncoding: import_chunk_JXX6LF5U.valueEncoding
    });
  }
};
var __dxlog_file2 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-pipeline/src/testing/test-agent-builder.ts";
var MemoryNetworkManagerProvider = (signalContext) => () => new import_network_manager.SwarmNetworkManager({
  signalManager: new import_messaging.MemorySignalManager(signalContext),
  transportFactory: import_network_manager.MemoryTransportFactory
});
var WebsocketNetworkManagerProvider = (signalUrl) => () => new import_network_manager.SwarmNetworkManager({
  signalManager: new import_messaging.WebsocketSignalManager([
    {
      server: signalUrl
    }
  ]),
  transportFactory: (0, import_network_manager.createRtcTransportFactory)()
});
var TestAgentBuilder = class {
  constructor({ storage, networkManagerProvider } = {}) {
    this._agents = new import_util.ComplexMap(import_keys.PublicKey.hash);
    this._storage = storage ?? (0, import_random_access_storage.createStorage)({
      type: import_random_access_storage.StorageType.RAM
    });
    this._networkManagerProvider = networkManagerProvider ?? MemoryNetworkManagerProvider(new import_messaging.MemorySignalManagerContext());
  }
  async close() {
    return Promise.all(this.agents.map((agent) => agent.close()));
  }
  get agents() {
    return Array.from(this._agents.values());
  }
  getAgent(deviceKey) {
    return this._agents.get(deviceKey);
  }
  async createPeer() {
    const feedBuilder = new TestFeedBuilder().setStorage(this._storage, `agent-${this._agents.size}`);
    const identityKey = await feedBuilder.keyring.createKey();
    const deviceKey = await feedBuilder.keyring.createKey();
    const agent = new TestAgent(this._networkManagerProvider, feedBuilder, identityKey, deviceKey);
    this._agents.set(deviceKey, agent);
    return agent;
  }
};
var TestAgent = class {
  get metadataStore() {
    return this._metadataStore ??= new import_chunk_JXX6LF5U.MetadataStore(this.storage.createDirectory("metadata"));
  }
  get blobStore() {
    return this._blobStore ??= new import_teleport_extension_object_sync.BlobStore(this.storage.createDirectory("blobs"));
  }
  constructor(_networkManagerProvider, _feedBuilder, identityKey, deviceKey) {
    this._networkManagerProvider = _networkManagerProvider;
    this._feedBuilder = _feedBuilder;
    this.identityKey = identityKey;
    this.deviceKey = deviceKey;
    this._spaces = new import_util.ComplexMap(import_keys.PublicKey.hash);
    this.storage = this._feedBuilder.storage;
    this.keyring = this._feedBuilder.keyring;
    this.feedStore = this._feedBuilder.createFeedStore();
  }
  async close() {
    return Promise.all([
      ...this.spaces.map((space) => space.close())
    ]);
  }
  get spaces() {
    return Array.from(this._spaces.values());
  }
  getSpace(spaceKey2) {
    return this._spaces.get(spaceKey2);
  }
  get networkManager() {
    if (this._networkManager) {
      return this._networkManager;
    }
    this._networkManager = this._networkManagerProvider();
    this._networkManager.setPeerInfo({
      peerKey: this.deviceKey.toHex(),
      identityKey: this.identityKey.toHex()
    });
    return this._networkManager;
  }
  get spaceManager() {
    return this._spaceManager ??= new import_chunk_JXX6LF5U.SpaceManager({
      feedStore: this.feedStore,
      networkManager: this.networkManager,
      metadataStore: this.metadataStore,
      blobStore: this.blobStore
    });
  }
  async createSpace(identityKey = this.identityKey, spaceKey2, genesisKey, dataKey, saveMetadata = false) {
    if (!spaceKey2) {
      saveMetadata = true;
      spaceKey2 = await this.keyring.createKey();
    }
    if (!genesisKey) {
      genesisKey = await this.keyring.createKey();
    }
    const controlFeed = await this.feedStore.openFeed(genesisKey, {
      writable: true
    });
    const dataFeed = await this.feedStore.openFeed(dataKey ?? await this.keyring.createKey(), {
      writable: true,
      sparse: true
    });
    const metadata = {
      key: spaceKey2,
      genesisFeedKey: genesisKey,
      controlFeedKey: controlFeed.key,
      dataFeedKey: dataFeed.key
    };
    if (saveMetadata) {
      await this.metadataStore.addSpace(metadata);
    }
    await this.spaceManager.open();
    const space = await this.spaceManager.constructSpace({
      metadata,
      swarmIdentity: {
        identityKey: this.identityKey,
        peerKey: this.deviceKey,
        credentialProvider: import_chunk_JXX6LF5U.MOCK_AUTH_PROVIDER,
        credentialAuthenticator: import_chunk_JXX6LF5U.MOCK_AUTH_VERIFIER
      },
      memberKey: identityKey,
      onAuthorizedConnection: (session) => {
        session.addExtension("dxos.mesh.teleport.gossip", this.createGossip().createExtension({
          remotePeerId: session.remotePeerId
        }));
      },
      onDelegatedInvitationStatusChange: async () => {
      },
      onMemberRolesChanged: async () => {
      }
    });
    await space.setControlFeed(controlFeed);
    await space.setDataFeed(dataFeed);
    await space.open(new import_context.Context(void 0, {
      F: __dxlog_file2,
      L: 205
    }));
    this._spaces.set(spaceKey2, space);
    return space;
  }
  createSpaceProtocol(topic, gossip) {
    return new import_chunk_JXX6LF5U.SpaceProtocol({
      topic,
      swarmIdentity: {
        identityKey: this.identityKey,
        peerKey: this.deviceKey,
        credentialProvider: import_chunk_JXX6LF5U.MOCK_AUTH_PROVIDER,
        credentialAuthenticator: import_chunk_JXX6LF5U.MOCK_AUTH_VERIFIER
      },
      networkManager: this.networkManager,
      blobStore: this.blobStore,
      onSessionAuth: (session) => {
        session.addExtension("dxos.mesh.teleport.gossip", (gossip ?? this.createGossip()).createExtension({
          remotePeerId: session.remotePeerId
        }));
      }
    });
  }
  createGossip() {
    return new import_teleport_extension_gossip.Gossip({
      localPeerId: this.deviceKey
    });
  }
  createPresence(gossip) {
    return new import_teleport_extension_gossip.Presence({
      announceInterval: 30,
      offlineTimeout: 200,
      identityKey: this.identityKey,
      gossip: gossip ?? this.createGossip()
    });
  }
  async spaceGenesis(space) {
    const generator = new import_credentials.CredentialGenerator(this.keyring, this.identityKey, this.deviceKey);
    const credentials = [
      ...await generator.createSpaceGenesis(space.key, space.controlFeedKey),
      await generator.createFeedAdmission(space.key, space.dataFeedKey, import_credentials2.AdmittedFeed.Designation.DATA),
      await generator.createEpochCredential(space.key)
    ];
    for (const credential of credentials) {
      await space.controlPipeline.writer.write({
        credential: {
          credential
        }
      });
    }
  }
};
var __dxlog_file3 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-pipeline/src/testing/test-network-adapter.ts";
var TestAdapter = class _TestAdapter extends import_automerge_repo.NetworkAdapter {
  static createPair(connectionStateProvider = () => "on") {
    const adapter1 = new _TestAdapter({
      send: (message) => connectionStateProvider() === "on" && (0, import_async.sleep)(10).then(() => adapter2.receive(message))
    });
    const adapter2 = new _TestAdapter({
      send: (message) => connectionStateProvider() === "on" && (0, import_async.sleep)(10).then(() => adapter1.receive(message))
    });
    return [
      adapter1,
      adapter2
    ];
  }
  constructor(_params) {
    super(), this._params = _params, this.onConnect = new import_async.Trigger();
  }
  isReady() {
    return true;
  }
  whenReady() {
    return Promise.resolve();
  }
  connect(peerId) {
    this.peerId = peerId;
    this.onConnect.wake();
  }
  peerCandidate(peerId) {
    (0, import_invariant.invariant)(peerId, "PeerId is required", {
      F: __dxlog_file3,
      L: 45,
      S: this,
      A: [
        "peerId",
        "'PeerId is required'"
      ]
    });
    this.emit("peer-candidate", {
      peerId,
      peerMetadata: {}
    });
  }
  peerDisconnected(peerId) {
    (0, import_invariant.invariant)(peerId, "PeerId is required", {
      F: __dxlog_file3,
      L: 50,
      S: this,
      A: [
        "peerId",
        "'PeerId is required'"
      ]
    });
    this.emit("peer-disconnected", {
      peerId
    });
  }
  send(message) {
    (0, import_log2.log)("send", {
      from: message.senderId,
      to: message.targetId,
      type: message.type
    }, {
      F: __dxlog_file3,
      L: 55,
      S: this,
      C: (f, a) => f(...a)
    });
    this._params.send(message);
  }
  disconnect() {
    this.peerId = void 0;
  }
  receive(message) {
    (0, import_invariant.invariant)(this.peerId, "Peer id is not set", {
      F: __dxlog_file3,
      L: 64,
      S: this,
      A: [
        "this.peerId",
        "'Peer id is not set'"
      ]
    });
    this.emit("message", message);
  }
};
function _ts_decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file4 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-pipeline/src/testing/test-replicator.ts";
var TestReplicationNetwork = class extends import_context2.Resource {
  constructor(options = {}) {
    super();
    this._replicators = /* @__PURE__ */ new Set();
    this._latency = void 0;
    this._latency = options.latency;
  }
  async _close(ctx) {
    for (const replicator of this._replicators) {
      for (const connection of replicator.connections) {
        void connection.writable.abort();
        void connection.readable.cancel();
      }
    }
  }
  async createReplicator() {
    const replicator = new TestReplicator({
      onConnect: async () => {
        (0, import_invariant2.invariant)(this._lifecycleState === import_context2.LifecycleState.OPEN, void 0, {
          F: __dxlog_file4,
          L: 45,
          S: this,
          A: [
            "this._lifecycleState === LifecycleState.OPEN",
            ""
          ]
        });
        await this._connectReplicator(replicator);
      },
      onDisconnect: async () => {
        (0, import_invariant2.invariant)(this._lifecycleState === import_context2.LifecycleState.OPEN, void 0, {
          F: __dxlog_file4,
          L: 49,
          S: this,
          A: [
            "this._lifecycleState === LifecycleState.OPEN",
            ""
          ]
        });
        await this._disconnectReplicator(replicator);
      }
    });
    this._replicators.add(replicator);
    return replicator;
  }
  async _connectReplicator(replicator) {
    for (const otherReplicator of this._replicators.values()) {
      if (otherReplicator === replicator || !otherReplicator.connected) {
        continue;
      }
      (0, import_log3.log)("create connection", {
        from: replicator.context.peerId,
        to: otherReplicator.context.peerId
      }, {
        F: __dxlog_file4,
        L: 63,
        S: this,
        C: (f, a) => f(...a)
      });
      const [connection1, connection2] = this._createConnectionPair(replicator.context.peerId, otherReplicator.context.peerId);
      await replicator.context.onConnectionOpen(connection1);
      await otherReplicator.context.onConnectionOpen(connection2);
    }
  }
  async _disconnectReplicator(replicator) {
    for (const connection of replicator.connections) {
      await replicator.context.onConnectionClosed(connection);
      await connection.otherSide.owningReplicator.removeConnection(connection.otherSide);
    }
  }
  _createConnectionPair(peer1, peer2) {
    const LOG = false;
    const forward = new TransformStream({
      transform: async (message, controller) => {
        if (LOG) {
          (0, import_log3.log)("replicate", {
            from: peer1,
            to: peer2,
            message
          }, {
            F: __dxlog_file4,
            L: 86,
            S: this,
            C: (f, a) => f(...a)
          });
        }
        if (this._latency !== void 0) {
          await (0, import_async2.sleep)(this._latency);
        }
        controller.enqueue(message);
      }
    });
    const backwards = new TransformStream({
      transform: async (message, controller) => {
        if (LOG) {
          (0, import_log3.log)("replicate", {
            from: peer2,
            to: peer1,
            message
          }, {
            F: __dxlog_file4,
            L: 99,
            S: this,
            C: (f, a) => f(...a)
          });
        }
        if (this._latency !== void 0) {
          await (0, import_async2.sleep)(this._latency);
        }
        controller.enqueue(message);
      }
    });
    const connection1 = new TestReplicatorConnection(peer2, backwards.readable, forward.writable);
    const connection2 = new TestReplicatorConnection(peer1, forward.readable, backwards.writable);
    connection1.otherSide = connection2;
    connection2.otherSide = connection1;
    return [
      connection1,
      connection2
    ];
  }
};
_ts_decorate([
  import_async2.synchronized
], TestReplicationNetwork.prototype, "_connectReplicator", null);
var TestReplicator = class {
  constructor(_params) {
    this._params = _params;
    this.connected = false;
    this.context = void 0;
    this.connections = /* @__PURE__ */ new Set();
  }
  async connect(context) {
    (0, import_log3.log)("connect", {
      peerId: context.peerId
    }, {
      F: __dxlog_file4,
      L: 131,
      S: this,
      C: (f, a) => f(...a)
    });
    this.context = context;
    this.connected = true;
    await this._params.onConnect();
  }
  async disconnect() {
    (0, import_log3.log)("disconnect", {
      peerId: this.context.peerId
    }, {
      F: __dxlog_file4,
      L: 138,
      S: this,
      C: (f, a) => f(...a)
    });
    this.connected = false;
    await this._params.onDisconnect();
  }
  async addConnection(connection) {
    connection.owningReplicator = this;
    this.connections.add(connection);
    this.context.onConnectionOpen(connection);
  }
  async removeConnection(connection) {
    connection.owningReplicator = void 0;
    this.context.onConnectionClosed(connection);
    this.connections.delete(connection);
  }
};
var TestReplicatorConnection = class {
  constructor(peerId, readable, writable) {
    this.peerId = peerId;
    this.readable = readable;
    this.writable = writable;
    this.otherSide = void 0;
    this.owningReplicator = void 0;
  }
  async shouldAdvertise(params) {
    return true;
  }
  shouldSyncCollection(params) {
    return true;
  }
};
var testAutomergeReplicatorFactory = (params) => {
  return new import_teleport_extension_automerge_replicator.AutomergeReplicator({
    ...params[0],
    sendSyncRetryPolicy: {
      retryBackoff: 20,
      retriesBeforeBackoff: 2,
      maxRetries: 3
    }
  }, params[1]);
};
var brokenAutomergeReplicatorFactory = (params) => {
  params[1].onSyncMessage = () => {
    throw new Error();
  };
  return testAutomergeReplicatorFactory(params);
};
var test_schema_exports = {};
(0, import_chunk_Q7SFCCGT.__export)(test_schema_exports, {
  Organization: () => Organization,
  Person: () => Person,
  Task: () => Task,
  WorksFor: () => WorksFor
});
var Person = import_effect.Schema.Struct({
  name: import_effect.Schema.String,
  email: import_effect.Schema.optional(import_effect.Schema.String),
  age: import_effect.Schema.optional(import_effect.Schema.Number)
}).pipe(import_echo.Type.Obj({
  typename: "dxos.org/type/Person",
  version: "0.1.0"
}));
var Organization = import_effect.Schema.Struct({
  name: import_effect.Schema.String
}).pipe(import_echo.Type.Obj({
  typename: "dxos.org/type/Organization",
  version: "0.1.0"
}));
var WorksFor = import_effect.Schema.Struct({
  since: import_effect.Schema.String
}).pipe(import_echo.Type.Relation({
  typename: "dxos.org/type/WorksFor",
  version: "0.1.0",
  source: Person,
  target: Organization
}));
var Task = import_effect.Schema.Struct({
  title: import_effect.Schema.String,
  createdAt: import_effect.Schema.String,
  assignee: import_echo.Type.Ref(Person)
}).pipe(import_echo.Type.Obj({
  typename: "dxos.org/type/Task",
  version: "0.1.0"
}));
var test_data_exports = {};
(0, import_chunk_Q7SFCCGT.__export)(test_data_exports, {
  ORGS: () => ORGS,
  PEOPLE: () => PEOPLE,
  TASKS: () => TASKS,
  WORKS_FOR: () => WORKS_FOR
});
var spaceKey = import_keys2.PublicKey.random();
var PEOPLE = {
  fred: import_echo_protocol.DatabaseDirectory.make({
    spaceKey: spaceKey.toHex(),
    objects: {
      [import_keys2.ObjectId.random()]: import_echo_protocol.ObjectStructure.makeObject({
        type: (0, import_echo_schema.getSchemaDXN)(Person).toString(),
        data: {
          name: "Fred"
        }
      })
    }
  }),
  alice: import_echo_protocol.DatabaseDirectory.make({
    spaceKey: spaceKey.toHex(),
    objects: {
      [import_keys2.ObjectId.random()]: import_echo_protocol.ObjectStructure.makeObject({
        type: (0, import_echo_schema.getSchemaDXN)(Person).toString(),
        data: {
          name: "Alice"
        }
      })
    }
  })
};
var ORGS = {
  cyberdyne: import_echo_protocol.DatabaseDirectory.make({
    spaceKey: spaceKey.toHex(),
    objects: {
      [import_keys2.ObjectId.random()]: import_echo_protocol.ObjectStructure.makeObject({
        type: (0, import_echo_schema.getSchemaDXN)(Organization).toString(),
        data: {
          name: "Cyberdyne Systems",
          founded: "1984"
        }
      })
    }
  }),
  aperture: import_echo_protocol.DatabaseDirectory.make({
    spaceKey: spaceKey.toHex(),
    objects: {
      [import_keys2.ObjectId.random()]: import_echo_protocol.ObjectStructure.makeObject({
        type: (0, import_echo_schema.getSchemaDXN)(Organization).toString(),
        data: {
          name: "Aperture Science",
          founded: "1953"
        }
      })
    }
  })
};
var WORKS_FOR = {
  fredWorksForCyberdyne: import_echo_protocol.DatabaseDirectory.make({
    spaceKey: spaceKey.toHex(),
    objects: {
      [import_keys2.ObjectId.random()]: import_echo_protocol.ObjectStructure.makeRelation({
        type: (0, import_echo_schema.getSchemaDXN)(WorksFor).toString(),
        source: {
          "/": import_keys2.DXN.fromLocalObjectId(Object.keys(PEOPLE.fred.objects)[0]).toString()
        },
        target: {
          "/": import_keys2.DXN.fromLocalObjectId(Object.keys(ORGS.cyberdyne.objects)[0]).toString()
        },
        data: {
          since: "2020",
          position: "Engineer"
        }
      })
    }
  }),
  aliceWorksForAperture: import_echo_protocol.DatabaseDirectory.make({
    spaceKey: spaceKey.toHex(),
    objects: {
      [import_keys2.ObjectId.random()]: import_echo_protocol.ObjectStructure.makeRelation({
        type: (0, import_echo_schema.getSchemaDXN)(WorksFor).toString(),
        source: {
          "/": import_keys2.DXN.fromLocalObjectId(Object.keys(PEOPLE.alice.objects)[0]).toString()
        },
        target: {
          "/": import_keys2.DXN.fromLocalObjectId(Object.keys(ORGS.aperture.objects)[0]).toString()
        },
        data: {
          since: "2018",
          position: "Research Scientist"
        }
      })
    }
  })
};
var TASKS = {
  task1: import_echo_protocol.DatabaseDirectory.make({
    spaceKey: spaceKey.toHex(),
    objects: {
      [import_keys2.ObjectId.random()]: import_echo_protocol.ObjectStructure.makeObject({
        type: (0, import_echo_schema.getSchemaDXN)(Task).toString(),
        data: {
          title: "Complete project documentation",
          description: "Write comprehensive documentation for the new system",
          status: "in-progress",
          dueDate: "2023-12-31",
          assignee: {
            "/": import_keys2.DXN.fromLocalObjectId(Object.keys(PEOPLE.fred.objects)[0]).toString()
          }
        }
      })
    }
  }),
  task2: import_echo_protocol.DatabaseDirectory.make({
    spaceKey: spaceKey.toHex(),
    objects: {
      [import_keys2.ObjectId.random()]: import_echo_protocol.ObjectStructure.makeObject({
        type: (0, import_echo_schema.getSchemaDXN)(Task).toString(),
        data: {
          title: "Run experiments",
          description: "Conduct series of experiments on the portal device",
          status: "pending",
          dueDate: "2023-11-15",
          assignee: {
            "/": import_keys2.DXN.fromLocalObjectId(Object.keys(PEOPLE.alice.objects)[0]).toString()
          }
        }
      })
    }
  })
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  MemoryNetworkManagerProvider,
  TestAdapter,
  TestAgent,
  TestAgentBuilder,
  TestData,
  TestFeedBuilder,
  TestReplicationNetwork,
  TestReplicator,
  TestReplicatorConnection,
  TestSchema,
  WebsocketNetworkManagerProvider,
  brokenAutomergeReplicatorFactory,
  changeStorageVersionInMetadata,
  testAutomergeReplicatorFactory
});
//# sourceMappingURL=index.cjs.map
