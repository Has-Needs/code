import "@dxos/node-std/globals";

// packages/core/echo/echo-pipeline/src/common/codec.ts
import { createCodecEncoding } from "@dxos/hypercore";
import { schema } from "@dxos/protocols/proto";
var codec = schema.getCodecForType("dxos.echo.feed.FeedMessage");
var valueEncoding = createCodecEncoding(codec);

// packages/core/echo/echo-pipeline/src/common/feeds.ts
import { invariant } from "@dxos/invariant";
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/core/echo/echo-pipeline/src/common/feeds.ts";
var createMappedFeedWriter = (mapper, writer) => {
  invariant(mapper, void 0, {
    F: __dxlog_file,
    L: 16,
    S: void 0,
    A: [
      "mapper",
      ""
    ]
  });
  invariant(writer, void 0, {
    F: __dxlog_file,
    L: 17,
    S: void 0,
    A: [
      "writer",
      ""
    ]
  });
  return {
    write: async (data, options) => await writer.write(await mapper(data), options)
  };
};

// packages/core/echo/echo-pipeline/src/common/space-id.ts
import { subtleCrypto } from "@dxos/crypto";
import { PublicKey, SpaceId } from "@dxos/keys";
import { ComplexMap } from "@dxos/util";
var SPACE_IDS_CACHE = new ComplexMap(PublicKey.hash);
var createIdFromSpaceKey = async (spaceKey) => {
  const cachedValue = SPACE_IDS_CACHE.get(spaceKey);
  if (cachedValue !== void 0) {
    return cachedValue;
  }
  const digest = await subtleCrypto.digest("SHA-256", spaceKey.asUint8Array());
  const bytes = new Uint8Array(digest).slice(0, SpaceId.byteLength);
  const spaceId = SpaceId.encode(bytes);
  SPACE_IDS_CACHE.set(spaceKey, spaceId);
  return spaceId;
};

// packages/core/echo/echo-pipeline/src/metadata/metadata-store.ts
import CRC32 from "crc-32";
import { Event, scheduleTaskInterval, synchronized } from "@dxos/async";
import { Context } from "@dxos/context";
import { invariant as invariant2 } from "@dxos/invariant";
import { PublicKey as PublicKey2 } from "@dxos/keys";
import { log } from "@dxos/log";
import { DataCorruptionError, STORAGE_VERSION } from "@dxos/protocols";
import { schema as schema2 } from "@dxos/protocols/proto";
import { Invitation, SpaceState } from "@dxos/protocols/proto/dxos/client/services";
import { ComplexMap as ComplexMap2, arrayToBuffer, forEachAsync, isNonNullable } from "@dxos/util";
function _ts_decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file2 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-pipeline/src/metadata/metadata-store.ts";
var EXPIRED_INVITATION_CLEANUP_INTERVAL = 60 * 60 * 1e3;
var emptyEchoMetadata = () => ({
  version: STORAGE_VERSION,
  spaces: [],
  created: /* @__PURE__ */ new Date(),
  updated: /* @__PURE__ */ new Date()
});
var emptyLargeSpaceMetadata = () => ({});
var EchoMetadata = schema2.getCodecForType("dxos.echo.metadata.EchoMetadata");
var LargeSpaceMetadata = schema2.getCodecForType("dxos.echo.metadata.LargeSpaceMetadata");
var MetadataStore = class {
  constructor(directory) {
    this._metadata = emptyEchoMetadata();
    this._spaceLargeMetadata = new ComplexMap2(PublicKey2.hash);
    this._metadataFile = void 0;
    this.update = new Event();
    this._invitationCleanupCtx = new Context(void 0, {
      F: __dxlog_file2,
      L: 55
    });
    this._directory = directory;
  }
  get metadata() {
    return this._metadata;
  }
  get version() {
    return this._metadata.version ?? 0;
  }
  /**
  * Returns a list of currently saved spaces. The list and objects in it can be modified addSpace and
  * addSpaceFeed functions.
  */
  get spaces() {
    return this._metadata.spaces ?? [];
  }
  async _readFile(file, codec2) {
    try {
      const { size: fileLength } = await file.stat();
      if (fileLength < 8) {
        return;
      }
      const dataSize = fromBytesInt32(await file.read(0, 4));
      const checksum = fromBytesInt32(await file.read(4, 4));
      log("loaded", {
        size: dataSize,
        checksum,
        name: file.filename
      }, {
        F: __dxlog_file2,
        L: 91,
        S: this,
        C: (f, a) => f(...a)
      });
      if (fileLength < dataSize + 8) {
        throw new DataCorruptionError("Metadata size is smaller than expected.", {
          fileLength,
          dataSize
        });
      }
      const data = await file.read(8, dataSize);
      const calculatedChecksum = CRC32.buf(data);
      if (calculatedChecksum !== checksum) {
        throw new DataCorruptionError("Metadata checksum is invalid.");
      }
      return codec2.decode(data);
    } finally {
      await file.close();
    }
  }
  /**
  * @internal
  */
  async _writeFile(file, codec2, data) {
    const encoded = arrayToBuffer(codec2.encode(data));
    const checksum = CRC32.buf(encoded);
    const result = Buffer.alloc(8 + encoded.length);
    result.writeInt32LE(encoded.length, 0);
    result.writeInt32LE(checksum, 4);
    encoded.copy(result, 8);
    await file.write(0, result);
    log("saved", {
      size: encoded.length,
      checksum
    }, {
      F: __dxlog_file2,
      L: 126,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  async close() {
    await this._invitationCleanupCtx.dispose();
    await this.flush();
    await this._metadataFile?.close();
    this._metadataFile = void 0;
    this._metadata = emptyEchoMetadata();
    this._spaceLargeMetadata.clear();
  }
  /**
  * Loads metadata from persistent storage.
  */
  async load() {
    if (!this._metadataFile || this._metadataFile.closed) {
      this._metadataFile = this._directory.getOrCreateFile("EchoMetadata");
    }
    try {
      const metadata = await this._readFile(this._metadataFile, EchoMetadata);
      if (metadata) {
        this._metadata = metadata;
      }
      this._metadata.spaces?.forEach((space) => {
        space.state ??= SpaceState.SPACE_ACTIVE;
      });
    } catch (err) {
      log.error("failed to load metadata", {
        err
      }, {
        F: __dxlog_file2,
        L: 158,
        S: this,
        C: (f, a) => f(...a)
      });
      this._metadata = emptyEchoMetadata();
    }
    await forEachAsync([
      this._metadata.identity?.haloSpace.key,
      ...this._metadata.spaces?.map((space) => space.key) ?? []
    ].filter(isNonNullable), async (key) => {
      try {
        await this._loadSpaceLargeMetadata(key);
      } catch (err) {
        log.error("failed to load space large metadata", {
          err
        }, {
          F: __dxlog_file2,
          L: 170,
          S: this,
          C: (f, a) => f(...a)
        });
      }
    });
    scheduleTaskInterval(this._invitationCleanupCtx, async () => {
      for (const invitation of this._metadata.invitations ?? []) {
        if (hasInvitationExpired(invitation) || isLegacyInvitationFormat(invitation)) {
          await this.removeInvitation(invitation.invitationId);
        }
      }
    }, EXPIRED_INVITATION_CLEANUP_INTERVAL);
  }
  async _save() {
    const data = {
      ...this._metadata,
      version: STORAGE_VERSION,
      created: this._metadata.created ?? /* @__PURE__ */ new Date(),
      updated: /* @__PURE__ */ new Date()
    };
    this.update.emit(data);
    const file = this._directory.getOrCreateFile("EchoMetadata");
    await this._writeFile(file, EchoMetadata, data);
  }
  async _loadSpaceLargeMetadata(key) {
    const file = this._directory.getOrCreateFile(`space_${key.toHex()}_large`);
    try {
      const metadata = await this._readFile(file, LargeSpaceMetadata);
      if (metadata) {
        this._spaceLargeMetadata.set(key, metadata);
      }
    } catch (err) {
      log.error("failed to load space large metadata", {
        err
      }, {
        F: __dxlog_file2,
        L: 212,
        S: this,
        C: (f, a) => f(...a)
      });
    }
  }
  async _saveSpaceLargeMetadata(key) {
    const data = this._getLargeSpaceMetadata(key);
    const file = this._directory.getOrCreateFile(`space_${key.toHex()}_large`);
    await this._writeFile(file, LargeSpaceMetadata, data);
  }
  async flush() {
    await this._directory.flush();
  }
  _getSpace(spaceKey) {
    if (this._metadata.identity?.haloSpace.key.equals(spaceKey)) {
      return this._metadata.identity.haloSpace;
    }
    const space = this.spaces.find((space2) => space2.key.equals(spaceKey));
    invariant2(space, "Space not found", {
      F: __dxlog_file2,
      L: 234,
      S: this,
      A: [
        "space",
        "'Space not found'"
      ]
    });
    return space;
  }
  hasSpace(spaceKey) {
    if (this._metadata.identity?.haloSpace.key.equals(spaceKey)) {
      return true;
    }
    return !!this.spaces.find((space) => space.key.equals(spaceKey));
  }
  _getLargeSpaceMetadata(key) {
    let entry = this._spaceLargeMetadata.get(key);
    if (entry) {
      return entry;
    }
    entry = emptyLargeSpaceMetadata();
    this._spaceLargeMetadata.set(key, entry);
    return entry;
  }
  /**
  * Clears storage - doesn't work for now.
  */
  async clear() {
    log("clearing all metadata", void 0, {
      F: __dxlog_file2,
      L: 262,
      S: this,
      C: (f, a) => f(...a)
    });
    await this._directory.delete();
    this._metadata = emptyEchoMetadata();
  }
  getIdentityRecord() {
    return this._metadata.identity;
  }
  async setIdentityRecord(record) {
    invariant2(!this._metadata.identity, "Cannot overwrite existing identity in metadata", {
      F: __dxlog_file2,
      L: 272,
      S: this,
      A: [
        "!this._metadata.identity",
        "'Cannot overwrite existing identity in metadata'"
      ]
    });
    this._metadata.identity = record;
    await this._save();
    await this.flush();
  }
  getInvitations() {
    return this._metadata.invitations ?? [];
  }
  async addInvitation(invitation) {
    if (this._metadata.invitations?.find((i) => i.invitationId === invitation.invitationId)) {
      return;
    }
    (this._metadata.invitations ??= []).push(invitation);
    await this._save();
    await this.flush();
  }
  async removeInvitation(invitationId) {
    this._metadata.invitations = (this._metadata.invitations ?? []).filter((i) => i.invitationId !== invitationId);
    await this._save();
    await this.flush();
  }
  async addSpace(record) {
    invariant2(!(this._metadata.spaces ?? []).find((space) => space.key.equals(record.key)), "Cannot overwrite existing space in metadata", {
      F: __dxlog_file2,
      L: 300,
      S: this,
      A: [
        "!(this._metadata.spaces ?? []).find((space) => space.key.equals(record.key))",
        "'Cannot overwrite existing space in metadata'"
      ]
    });
    (this._metadata.spaces ??= []).push(record);
    await this._save();
    await this.flush();
  }
  async setSpaceDataLatestTimeframe(spaceKey, timeframe) {
    this._getSpace(spaceKey).dataTimeframe = timeframe;
    await this._save();
  }
  async setSpaceControlLatestTimeframe(spaceKey, timeframe) {
    this._getSpace(spaceKey).controlTimeframe = timeframe;
    await this._save();
    await this.flush();
  }
  async setCache(spaceKey, cache) {
    this._getSpace(spaceKey).cache = cache;
    await this._save();
  }
  async setWritableFeedKeys(spaceKey, controlFeedKey, dataFeedKey) {
    const space = this._getSpace(spaceKey);
    space.controlFeedKey = controlFeedKey;
    space.dataFeedKey = dataFeedKey;
    await this._save();
    await this.flush();
  }
  async setSpaceState(spaceKey, state) {
    this._getSpace(spaceKey).state = state;
    await this._save();
    await this.flush();
  }
  getSpaceControlPipelineSnapshot(spaceKey) {
    return this._getLargeSpaceMetadata(spaceKey).controlPipelineSnapshot;
  }
  async setSpaceControlPipelineSnapshot(spaceKey, snapshot) {
    this._getLargeSpaceMetadata(spaceKey).controlPipelineSnapshot = snapshot;
    await this._saveSpaceLargeMetadata(spaceKey);
    await this.flush();
  }
  getSpaceEdgeReplicationSetting(spaceKey) {
    return this.hasSpace(spaceKey) ? this._getSpace(spaceKey).edgeReplication : void 0;
  }
  async setSpaceEdgeReplicationSetting(spaceKey, setting) {
    this._getSpace(spaceKey).edgeReplication = setting;
    await this._save();
    await this.flush();
  }
};
_ts_decorate([
  synchronized
], MetadataStore.prototype, "load", null);
_ts_decorate([
  synchronized
], MetadataStore.prototype, "_save", null);
_ts_decorate([
  synchronized
], MetadataStore.prototype, "_saveSpaceLargeMetadata", null);
var fromBytesInt32 = (buf) => buf.readInt32LE(0);
var hasInvitationExpired = (invitation) => {
  return Boolean(invitation.created && invitation.lifetime && invitation.lifetime !== 0 && invitation.created.getTime() + invitation.lifetime * 1e3 < Date.now());
};
var isLegacyInvitationFormat = (invitation) => {
  return invitation.type === Invitation.Type.MULTIUSE;
};

// packages/core/echo/echo-pipeline/src/pipeline/timeframe-clock.ts
import { Event as Event2 } from "@dxos/async";
import { timed } from "@dxos/debug";
import { log as log2 } from "@dxos/log";
import { Timeframe } from "@dxos/timeframe";
function _ts_decorate2(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file3 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-pipeline/src/pipeline/timeframe-clock.ts";
var mapTimeframeToFeedIndexes = (timeframe) => timeframe.frames().map(([feedKey, index]) => ({
  feedKey,
  index
}));
var mapFeedIndexesToTimeframe = (indexes) => new Timeframe(indexes.map(({ feedKey, index }) => [
  feedKey,
  index
]));
var startAfter = (timeframe) => timeframe.frames().map(([feedKey, index]) => ({
  feedKey,
  index: index + 1
}));
var TimeframeClock = class {
  constructor(_timeframe = new Timeframe()) {
    this._timeframe = _timeframe;
    this.update = new Event2();
    this._pendingTimeframe = _timeframe;
  }
  /**
  * Timeframe that was processed by ECHO.
  */
  get timeframe() {
    return this._timeframe;
  }
  /**
  * Timeframe that is currently being processed by ECHO.
  * Will be equal to `timeframe` after the processing is complete.
  */
  get pendingTimeframe() {
    return this._pendingTimeframe;
  }
  setTimeframe(timeframe) {
    this._timeframe = timeframe;
    this._pendingTimeframe = timeframe;
    this.update.emit(this._timeframe);
  }
  updatePendingTimeframe(key, seq) {
    this._pendingTimeframe = Timeframe.merge(this._pendingTimeframe, new Timeframe([
      [
        key,
        seq
      ]
    ]));
  }
  updateTimeframe() {
    this._timeframe = this._pendingTimeframe;
    this.update.emit(this._timeframe);
  }
  hasGaps(timeframe) {
    const gaps = Timeframe.dependencies(timeframe, this._timeframe);
    return !gaps.isEmpty();
  }
  async waitUntilReached(target) {
    log2("waitUntilReached", {
      target,
      current: this._timeframe
    }, {
      F: __dxlog_file3,
      L: 70,
      S: this,
      C: (f, a) => f(...a)
    });
    await this.update.waitForCondition(() => {
      log2("check if reached", {
        target,
        current: this._timeframe,
        deps: Timeframe.dependencies(target, this._timeframe)
      }, {
        F: __dxlog_file3,
        L: 72,
        S: this,
        C: (f, a) => f(...a)
      });
      return Timeframe.dependencies(target, this._timeframe).isEmpty();
    });
  }
};
_ts_decorate2([
  timed(5e3)
], TimeframeClock.prototype, "waitUntilReached", null);

// packages/core/echo/echo-pipeline/src/pipeline/pipeline.ts
import { Event as Event3, sleepWithContext, synchronized as synchronized2, Trigger } from "@dxos/async";
import { Context as Context2, rejectOnDispose } from "@dxos/context";
import { failUndefined } from "@dxos/debug";
import { FeedSetIterator } from "@dxos/feed-store";
import { invariant as invariant4 } from "@dxos/invariant";
import { PublicKey as PublicKey3 } from "@dxos/keys";
import { log as log4 } from "@dxos/log";
import { Timeframe as Timeframe2 } from "@dxos/timeframe";
import { ComplexMap as ComplexMap3 } from "@dxos/util";

// packages/core/echo/echo-pipeline/src/pipeline/message-selector.ts
import { invariant as invariant3 } from "@dxos/invariant";
import { log as log3 } from "@dxos/log";
var __dxlog_file4 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-pipeline/src/pipeline/message-selector.ts";
var createMessageSelector = (timeframeClock) => {
  return (messages) => {
    for (let i = 0; i < messages.length; i++) {
      const { data: { timeframe } } = messages[i];
      invariant3(timeframe, void 0, {
        F: __dxlog_file4,
        L: 25,
        S: void 0,
        A: [
          "timeframe",
          ""
        ]
      });
      if (!timeframeClock.hasGaps(timeframe)) {
        return i;
      }
    }
    log3("Skipping...", void 0, {
      F: __dxlog_file4,
      L: 33,
      S: void 0,
      C: (f, a) => f(...a)
    });
  };
};

// packages/core/echo/echo-pipeline/src/pipeline/pipeline.ts
function _ts_decorate3(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file5 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-pipeline/src/pipeline/pipeline.ts";
var PipelineState = class {
  constructor(_feeds, _timeframeClock) {
    this._feeds = _feeds;
    this._timeframeClock = _timeframeClock;
    this._ctx = new Context2(void 0, {
      F: __dxlog_file5,
      L: 41
    });
    this.timeframeUpdate = this._timeframeClock.update;
    this.stalled = new Event3();
    this._startTimeframe = new Timeframe2();
    this._reachedTarget = false;
  }
  /**
  * Latest theoretical timeframe based on the last mutation in each feed.
  * NOTE: This might never be reached if the mutation dependencies
  */
  // TODO(dmaretskyi): Rename `totalTimeframe`? or `lastTimeframe`.
  get endTimeframe() {
    return mapFeedIndexesToTimeframe(Array.from(this._feeds.values()).filter((feed) => feed.length > 0).map((feed) => ({
      feedKey: feed.key,
      index: feed.length - 1
    })));
  }
  get startTimeframe() {
    return this._startTimeframe;
  }
  get timeframe() {
    return this._timeframeClock.timeframe;
  }
  get pendingTimeframe() {
    return this._timeframeClock.pendingTimeframe;
  }
  get targetTimeframe() {
    return this._targetTimeframe ? this._targetTimeframe : new Timeframe2();
  }
  get reachedTarget() {
    return this._reachedTarget;
  }
  get feeds() {
    return Array.from(this._feeds.values());
  }
  async waitUntilTimeframe(target) {
    await this._timeframeClock.waitUntilReached(target);
  }
  setTargetTimeframe(target) {
    this._targetTimeframe = target;
  }
  /**
  * Wait until the pipeline processes all messages in the feed and reaches the target timeframe if that is set.
  *
  * This function will resolve immediately if the pipeline is stalled.
  *
  * @param timeout Timeout in milliseconds to specify the maximum wait time.
  */
  async waitUntilReachedTargetTimeframe({ ctx = new Context2(void 0, {
    F: __dxlog_file5,
    L: 129
  }), timeout, breakOnStall = true } = {}) {
    log4("waitUntilReachedTargetTimeframe", {
      timeout,
      current: this.timeframe,
      target: this.targetTimeframe
    }, {
      F: __dxlog_file5,
      L: 133,
      S: this,
      C: (f, a) => f(...a)
    });
    this._reachedTargetPromise ??= Promise.race([
      this._timeframeClock.update.waitForCondition(() => {
        return Timeframe2.dependencies(this.targetTimeframe, this.timeframe).isEmpty();
      }),
      ...breakOnStall ? [
        this.stalled.discardParameter().waitForCount(1)
      ] : []
    ]);
    let done = false;
    if (timeout) {
      return Promise.race([
        rejectOnDispose(ctx),
        rejectOnDispose(this._ctx),
        this._reachedTargetPromise.then(() => {
          done = true;
          this._reachedTarget = true;
        }),
        sleepWithContext(this._ctx, timeout).then(() => {
          if (done) {
            return;
          }
          log4.warn("waitUntilReachedTargetTimeframe timed out", {
            timeout,
            current: this.timeframe,
            target: this.targetTimeframe,
            dependencies: Timeframe2.dependencies(this.targetTimeframe, this.timeframe)
          }, {
            F: __dxlog_file5,
            L: 161,
            S: this,
            C: (f, a) => f(...a)
          });
        })
      ]);
    } else {
      return this._reachedTargetPromise;
    }
  }
};
var Pipeline = class {
  constructor() {
    this._timeframeClock = new TimeframeClock(new Timeframe2());
    this._feeds = new ComplexMap3(PublicKey3.hash);
    // External state accessor.
    this._state = new PipelineState(this._feeds, this._timeframeClock);
    // Waits for the message consumer to process the message and yield control back to the pipeline.
    this._processingTrigger = new Trigger().wake();
    this._pauseTrigger = new Trigger().wake();
    // Pending downloads.
    this._downloads = new ComplexMap3((value) => PublicKey3.hash(value.key));
    this._isStopping = false;
    this._isStarted = false;
    this._isBeingConsumed = false;
    this._isPaused = false;
  }
  get state() {
    return this._state;
  }
  get writer() {
    invariant4(this._writer, "Writer not set.", {
      F: __dxlog_file5,
      L: 243,
      S: this,
      A: [
        "this._writer",
        "'Writer not set.'"
      ]
    });
    return this._writer;
  }
  hasFeed(feedKey) {
    return this._feeds.has(feedKey);
  }
  getFeeds() {
    return this._feedSetIterator.feeds;
  }
  // NOTE: This cannot be synchronized with `stop` because stop waits for the mutation processing to complete,
  // which might be opening feeds during the mutation processing, which w
  async addFeed(feed) {
    this._feeds.set(feed.key, feed);
    if (this._feedSetIterator) {
      await this._feedSetIterator.addFeed(feed);
    }
    if (this._isStarted && !this._isPaused) {
      this._setFeedDownloadState(feed);
    }
  }
  setWriteFeed(feed) {
    invariant4(!this._writer, "Writer already set.", {
      F: __dxlog_file5,
      L: 270,
      S: this,
      A: [
        "!this._writer",
        "'Writer already set.'"
      ]
    });
    invariant4(feed.properties.writable, "Feed must be writable.", {
      F: __dxlog_file5,
      L: 271,
      S: this,
      A: [
        "feed.properties.writable",
        "'Feed must be writable.'"
      ]
    });
    this._writer = createMappedFeedWriter((payload) => ({
      timeframe: this._timeframeClock.timeframe,
      payload
    }), feed.createFeedWriter());
  }
  async start() {
    invariant4(!this._isStarted, "Pipeline is already started.", {
      F: __dxlog_file5,
      L: 284,
      S: this,
      A: [
        "!this._isStarted",
        "'Pipeline is already started.'"
      ]
    });
    log4("starting...", void 0, {
      F: __dxlog_file5,
      L: 285,
      S: this,
      C: (f, a) => f(...a)
    });
    await this._initIterator();
    await this._feedSetIterator.open();
    this._isStarted = true;
    log4("started", void 0, {
      F: __dxlog_file5,
      L: 289,
      S: this,
      C: (f, a) => f(...a)
    });
    if (!this._isPaused) {
      for (const feed of this._feeds.values()) {
        this._setFeedDownloadState(feed);
      }
    }
  }
  async stop() {
    log4("stopping...", void 0, {
      F: __dxlog_file5,
      L: 300,
      S: this,
      C: (f, a) => f(...a)
    });
    this._isStopping = true;
    for (const [feed, handle] of this._downloads.entries()) {
      feed.undownload(handle);
    }
    this._downloads.clear();
    await this._feedSetIterator?.close();
    await this._processingTrigger.wait();
    await this._state._ctx.dispose();
    this._state._ctx = new Context2(void 0, {
      F: __dxlog_file5,
      L: 309
    });
    this._state._reachedTargetPromise = void 0;
    this._state._reachedTarget = false;
    this._isStarted = false;
    log4("stopped", void 0, {
      F: __dxlog_file5,
      L: 313,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  /**
  * @param timeframe Timeframe of already processed messages.
  *  The pipeline will start processing messages AFTER this timeframe.
  */
  async setCursor(timeframe) {
    invariant4(!this._isStarted || this._isPaused, "Invalid state.", {
      F: __dxlog_file5,
      L: 322,
      S: this,
      A: [
        "!this._isStarted || this._isPaused",
        "'Invalid state.'"
      ]
    });
    this._state._startTimeframe = timeframe;
    this._timeframeClock.setTimeframe(timeframe);
    if (this._feedSetIterator) {
      await this._feedSetIterator.close();
      await this._initIterator();
      await this._feedSetIterator.open();
    }
  }
  /**
  * Calling pause while processing will cause a deadlock.
  */
  async pause() {
    if (this._isPaused) {
      return;
    }
    this._pauseTrigger.reset();
    await this._processingTrigger.wait();
    this._isPaused = true;
  }
  async unpause() {
    invariant4(this._isPaused, "Pipeline is not paused.", {
      F: __dxlog_file5,
      L: 351,
      S: this,
      A: [
        "this._isPaused",
        "'Pipeline is not paused.'"
      ]
    });
    this._pauseTrigger.wake();
    this._isPaused = false;
    for (const feed of this._feeds.values()) {
      this._setFeedDownloadState(feed);
    }
  }
  /**
  * Starts to iterate over the ordered messages from the added feeds.
  * Updates the timeframe clock after the message has bee processed.
  */
  async *consume() {
    invariant4(!this._isBeingConsumed, "Pipeline is already being consumed.", {
      F: __dxlog_file5,
      L: 366,
      S: this,
      A: [
        "!this._isBeingConsumed",
        "'Pipeline is already being consumed.'"
      ]
    });
    this._isBeingConsumed = true;
    invariant4(this._feedSetIterator, "Iterator not initialized.", {
      F: __dxlog_file5,
      L: 369,
      S: this,
      A: [
        "this._feedSetIterator",
        "'Iterator not initialized.'"
      ]
    });
    let lastFeedSetIterator = this._feedSetIterator;
    let iterable = lastFeedSetIterator[Symbol.asyncIterator]();
    while (!this._isStopping) {
      await this._pauseTrigger.wait();
      if (lastFeedSetIterator !== this._feedSetIterator) {
        invariant4(this._feedSetIterator, "Iterator not initialized.", {
          F: __dxlog_file5,
          L: 378,
          S: this,
          A: [
            "this._feedSetIterator",
            "'Iterator not initialized.'"
          ]
        });
        lastFeedSetIterator = this._feedSetIterator;
        iterable = lastFeedSetIterator[Symbol.asyncIterator]();
      }
      const { done, value } = await iterable.next();
      if (!done) {
        const block = value ?? failUndefined();
        this._processingTrigger.reset();
        this._timeframeClock.updatePendingTimeframe(PublicKey3.from(block.feedKey), block.seq);
        yield block;
        this._processingTrigger.wake();
        this._timeframeClock.updateTimeframe();
      }
    }
    this._isBeingConsumed = false;
  }
  _setFeedDownloadState(feed) {
    let handle = this._downloads.get(feed);
    if (handle) {
      feed.undownload(handle);
    }
    const timeframe = this._state._startTimeframe;
    const seq = timeframe.get(feed.key) ?? -1;
    log4("download", {
      feed: feed.key.truncate(),
      seq,
      length: feed.length
    }, {
      F: __dxlog_file5,
      L: 407,
      S: this,
      C: (f, a) => f(...a)
    });
    handle = feed.download({
      start: seq + 1,
      linear: true
    }, (err, data) => {
      if (err) {
      } else {
        log4("downloaded", {
          data
        }, {
          F: __dxlog_file5,
          L: 412,
          S: this,
          C: (f, a) => f(...a)
        });
      }
    });
    this._downloads.set(feed, handle);
  }
  async _initIterator() {
    this._feedSetIterator = new FeedSetIterator(createMessageSelector(this._timeframeClock), {
      start: startAfter(this._timeframeClock.timeframe),
      stallTimeout: 1e3
    });
    this._feedSetIterator.stalled.on((iterator) => {
      log4.warn(`Stalled after ${iterator.options.stallTimeout}ms with ${iterator.size} feeds.`, {
        currentTimeframe: this._timeframeClock.timeframe,
        targetTimeframe: this._state.targetTimeframe
      }, {
        F: __dxlog_file5,
        L: 426,
        S: this,
        C: (f, a) => f(...a)
      });
      this._state.stalled.emit();
    });
    for (const feed of this._feeds.values()) {
      await this._feedSetIterator.addFeed(feed);
    }
  }
};
_ts_decorate3([
  synchronized2
], Pipeline.prototype, "start", null);
_ts_decorate3([
  synchronized2
], Pipeline.prototype, "stop", null);
_ts_decorate3([
  synchronized2
], Pipeline.prototype, "setCursor", null);
_ts_decorate3([
  synchronized2
], Pipeline.prototype, "pause", null);
_ts_decorate3([
  synchronized2
], Pipeline.prototype, "unpause", null);

// packages/core/echo/echo-pipeline/src/space/auth.ts
import { runInContext, scheduleTask } from "@dxos/async";
import { Context as Context3 } from "@dxos/context";
import { randomBytes } from "@dxos/crypto";
import { invariant as invariant5 } from "@dxos/invariant";
import { log as log5 } from "@dxos/log";
import { schema as schema3 } from "@dxos/protocols/proto";
import { RpcExtension } from "@dxos/teleport";
var __dxlog_file6 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-pipeline/src/space/auth.ts";
var AuthExtension = class extends RpcExtension {
  constructor(_authParams) {
    super({
      requested: {
        AuthService: schema3.getService("dxos.mesh.teleport.auth.AuthService")
      },
      exposed: {
        AuthService: schema3.getService("dxos.mesh.teleport.auth.AuthService")
      },
      timeout: 60 * 1e3
    }), this._authParams = _authParams, this._ctx = new Context3({
      onError: (err) => {
        log5.catch(err, void 0, {
          F: __dxlog_file6,
          L: 28,
          S: this,
          C: (f, a) => f(...a)
        });
      }
    }, {
      F: __dxlog_file6,
      L: 26
    });
  }
  async getHandlers() {
    return {
      AuthService: {
        authenticate: async ({ challenge }) => {
          try {
            const credential = await this._authParams.provider(challenge);
            if (!credential) {
              throw new Error("auth rejected");
            }
            return {
              credential
            };
          } catch (err) {
            log5.error("failed to generate auth credentials", err, {
              F: __dxlog_file6,
              L: 55,
              S: this,
              C: (f, a) => f(...a)
            });
            throw new Error("auth rejected");
          }
        }
      }
    };
  }
  async onOpen(context) {
    await super.onOpen(context);
    scheduleTask(this._ctx, async () => {
      try {
        const challenge = randomBytes(32);
        const { credential } = await this.rpc.AuthService.authenticate({
          challenge
        });
        invariant5(credential?.length > 0, "invalid credential", {
          F: __dxlog_file6,
          L: 69,
          S: this,
          A: [
            "credential?.length > 0",
            "'invalid credential'"
          ]
        });
        const success = await this._authParams.verifier(challenge, credential);
        invariant5(success, "credential not verified", {
          F: __dxlog_file6,
          L: 71,
          S: this,
          A: [
            "success",
            "'credential not verified'"
          ]
        });
        runInContext(this._ctx, () => this._authParams.onAuthSuccess());
      } catch (err) {
        log5("auth failed", err, {
          F: __dxlog_file6,
          L: 74,
          S: this,
          C: (f, a) => f(...a)
        });
        this.close();
        this._authParams.onAuthFailure();
      }
    });
  }
  async onClose() {
    await this._ctx.dispose();
    await super.onClose();
  }
  async onAbort() {
    await this._ctx.dispose();
    await super.onAbort();
  }
};

// packages/core/echo/echo-pipeline/src/space/space.ts
import { Event as Event4, scheduleMicroTask, synchronized as synchronized3, trackLeaks as trackLeaks2 } from "@dxos/async";
import { Resource } from "@dxos/context";
import { invariant as invariant6 } from "@dxos/invariant";
import { log as log7, logInfo } from "@dxos/log";
import { AdmittedFeed as AdmittedFeed2 } from "@dxos/protocols/proto/dxos/halo/credentials";
import { trace as trace2 } from "@dxos/tracing";
import { Callback as Callback2 } from "@dxos/util";

// packages/core/echo/echo-pipeline/src/space/control-pipeline.ts
import { DeferredTask, sleepWithContext as sleepWithContext2, trackLeaks } from "@dxos/async";
import { Context as Context4 } from "@dxos/context";
import { SpaceStateMachine } from "@dxos/credentials";
import { PublicKey as PublicKey4 } from "@dxos/keys";
import { log as log6 } from "@dxos/log";
import { AdmittedFeed } from "@dxos/protocols/proto/dxos/halo/credentials";
import { Timeframe as Timeframe3 } from "@dxos/timeframe";
import { TimeSeriesCounter, TimeUsageCounter, trace } from "@dxos/tracing";
import { Callback, tracer } from "@dxos/util";
function _ts_decorate4(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file7 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-pipeline/src/space/control-pipeline.ts";
var TIMEFRAME_SAVE_DEBOUNCE_INTERVAL = 500;
var CONTROL_PIPELINE_SNAPSHOT_DELAY = 1e4;
var USE_SNAPSHOTS = true;
var ControlPipeline = class {
  constructor({ spaceKey, genesisFeed, feedProvider, metadataStore }) {
    this._ctx = new Context4(void 0, {
      F: __dxlog_file7,
      L: 47
    });
    this._lastTimeframeSaveTime = Date.now();
    this.onFeedAdmitted = new Callback();
    this._usage = new TimeUsageCounter();
    this._mutations = new TimeSeriesCounter();
    this._snapshotTask = new DeferredTask(this._ctx, async () => {
      await sleepWithContext2(this._ctx, CONTROL_PIPELINE_SNAPSHOT_DELAY);
      await this._saveSnapshot();
    });
    this._spaceKey = spaceKey;
    this._metadata = metadataStore;
    this._pipeline = new Pipeline();
    void this._pipeline.addFeed(genesisFeed);
    this._spaceStateMachine = new SpaceStateMachine(spaceKey);
    this._spaceStateMachine.onFeedAdmitted.set(async (info) => {
      log6("feed admitted", {
        key: info.key
      }, {
        F: __dxlog_file7,
        L: 82,
        S: this,
        C: (f, a) => f(...a)
      });
      if (info.assertion.designation === AdmittedFeed.Designation.CONTROL && !info.key.equals(genesisFeed.key)) {
        queueMicrotask(async () => {
          try {
            const feed = await feedProvider(info.key);
            if (!this._pipeline.hasFeed(feed.key)) {
              await this._pipeline.addFeed(feed);
            }
          } catch (err) {
            log6.catch(err, void 0, {
              F: __dxlog_file7,
              L: 93,
              S: this,
              C: (f, a) => f(...a)
            });
          }
        });
      }
      await this.onFeedAdmitted.callIfSet(info);
    });
    this.onMemberRoleChanged = this._spaceStateMachine.onMemberRoleChanged;
    this.onCredentialProcessed = this._spaceStateMachine.onCredentialProcessed;
    this.onDelegatedInvitation = this._spaceStateMachine.onDelegatedInvitation;
    this.onDelegatedInvitationRemoved = this._spaceStateMachine.onDelegatedInvitationRemoved;
  }
  get spaceState() {
    return this._spaceStateMachine;
  }
  get pipeline() {
    return this._pipeline;
  }
  async setWriteFeed(feed) {
    await this._pipeline.addFeed(feed);
    this._pipeline.setWriteFeed(feed);
  }
  async start() {
    const snapshot = this._metadata.getSpaceControlPipelineSnapshot(this._spaceKey);
    log6("load snapshot", {
      key: this._spaceKey,
      present: !!snapshot,
      tf: snapshot?.timeframe
    }, {
      F: __dxlog_file7,
      L: 123,
      S: this,
      C: (f, a) => f(...a)
    });
    if (USE_SNAPSHOTS && snapshot) {
      await this._processSnapshot(snapshot);
    }
    log6("starting...", void 0, {
      F: __dxlog_file7,
      L: 128,
      S: this,
      C: (f, a) => f(...a)
    });
    setTimeout(async () => {
      void this._consumePipeline(new Context4(void 0, {
        F: __dxlog_file7,
        L: 130
      }));
    });
    await this._pipeline.start();
    log6("started", void 0, {
      F: __dxlog_file7,
      L: 134,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  async _processSnapshot(snapshot) {
    await this._pipeline.setCursor(snapshot.timeframe);
    for (const message of snapshot.messages ?? []) {
      const result = await this._spaceStateMachine.process(message.credential, {
        sourceFeed: message.feedKey,
        skipVerification: true
      });
      if (!result) {
        log6.warn("credential processing failed from snapshot", {
          message
        }, {
          F: __dxlog_file7,
          L: 147,
          S: this,
          C: (f, a) => f(...a)
        });
      }
    }
  }
  async _saveSnapshot() {
    await this._pipeline.pause();
    const snapshot = {
      timeframe: this._pipeline.state.timeframe,
      messages: this._spaceStateMachine.credentialEntries.map((entry) => ({
        feedKey: entry.sourceFeed,
        credential: entry.credential
      }))
    };
    await this._pipeline.unpause();
    log6("save snapshot", {
      key: this._spaceKey,
      snapshot: getSnapshotLoggerContext(snapshot)
    }, {
      F: __dxlog_file7,
      L: 163,
      S: this,
      C: (f, a) => f(...a)
    });
    await this._metadata.setSpaceControlPipelineSnapshot(this._spaceKey, snapshot);
  }
  async _consumePipeline(ctx) {
    for await (const msg of this._pipeline.consume()) {
      const span = this._usage.beginRecording();
      this._mutations.inc();
      try {
        await this._processMessage(ctx, msg);
      } catch (err) {
        log6.catch(err, void 0, {
          F: __dxlog_file7,
          L: 176,
          S: this,
          C: (f, a) => f(...a)
        });
      }
      span.end();
    }
  }
  async _processMessage(ctx, msg) {
    log6("processing", {
      key: msg.feedKey,
      seq: msg.seq
    }, {
      F: __dxlog_file7,
      L: 185,
      S: this,
      C: (f, a) => f(...a)
    });
    if (msg.data.payload.credential) {
      const timer = tracer.mark("dxos.echo.pipeline.control");
      const result = await this._spaceStateMachine.process(msg.data.payload.credential.credential, {
        sourceFeed: PublicKey4.from(msg.feedKey)
      });
      timer.end();
      if (!result) {
        log6.warn("processing failed", {
          msg
        }, {
          F: __dxlog_file7,
          L: 194,
          S: this,
          C: (f, a) => f(...a)
        });
      } else {
        await this._noteTargetStateIfNeeded(this._pipeline.state.pendingTimeframe);
      }
      this._snapshotTask.schedule();
    }
  }
  async _noteTargetStateIfNeeded(timeframe) {
    if (Date.now() - this._lastTimeframeSaveTime > TIMEFRAME_SAVE_DEBOUNCE_INTERVAL) {
      this._lastTimeframeSaveTime = Date.now();
      await this._saveTargetTimeframe(timeframe);
    }
  }
  async stop() {
    log6("stopping...", void 0, {
      F: __dxlog_file7,
      L: 214,
      S: this,
      C: (f, a) => f(...a)
    });
    await this._ctx.dispose();
    await this._pipeline.stop();
    await this._saveTargetTimeframe(this._pipeline.state.timeframe);
    log6("stopped", void 0, {
      F: __dxlog_file7,
      L: 218,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  async _saveTargetTimeframe(timeframe) {
    try {
      const newTimeframe = Timeframe3.merge(this._targetTimeframe ?? new Timeframe3(), timeframe);
      await this._metadata.setSpaceControlLatestTimeframe(this._spaceKey, newTimeframe);
      this._targetTimeframe = newTimeframe;
    } catch (err) {
      log6(err, void 0, {
        F: __dxlog_file7,
        L: 227,
        S: this,
        C: (f, a) => f(...a)
      });
    }
  }
};
_ts_decorate4([
  trace.metricsCounter()
], ControlPipeline.prototype, "_usage", void 0);
_ts_decorate4([
  trace.metricsCounter()
], ControlPipeline.prototype, "_mutations", void 0);
_ts_decorate4([
  trace.span({
    showInBrowserTimeline: true
  })
], ControlPipeline.prototype, "start", null);
_ts_decorate4([
  trace.span()
], ControlPipeline.prototype, "_consumePipeline", null);
_ts_decorate4([
  trace.span()
], ControlPipeline.prototype, "_processMessage", null);
ControlPipeline = _ts_decorate4([
  trace.resource(),
  trackLeaks("start", "stop")
], ControlPipeline);
var getSnapshotLoggerContext = (snapshot) => {
  return snapshot.messages?.map((msg) => {
    const issuer = msg.credential.issuer;
    const subject = msg.credential.subject.id;
    const type = msg.credential.subject.assertion["@type"];
    return {
      issuer,
      subject,
      type
    };
  });
};

// packages/core/echo/echo-pipeline/src/space/space.ts
function _ts_decorate5(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file8 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-pipeline/src/space/space.ts";
var Space = class extends Resource {
  constructor(params) {
    super();
    this.onCredentialProcessed = new Callback2();
    this.stateUpdate = new Event4();
    invariant6(params.spaceKey && params.feedProvider, void 0, {
      F: __dxlog_file8,
      L: 72,
      S: this,
      A: [
        "params.spaceKey && params.feedProvider",
        ""
      ]
    });
    this._id = params.id;
    this._key = params.spaceKey;
    this._genesisFeedKey = params.genesisFeed.key;
    this._feedProvider = params.feedProvider;
    this._controlPipeline = new ControlPipeline({
      spaceKey: params.spaceKey,
      genesisFeed: params.genesisFeed,
      feedProvider: params.feedProvider,
      metadataStore: params.metadataStore
    });
    this._controlPipeline.onFeedAdmitted.set(async (info) => {
      const sparse = info.assertion.designation === AdmittedFeed2.Designation.DATA;
      if (!info.key.equals(params.genesisFeed.key)) {
        scheduleMicroTask(this._ctx, async () => {
          await this.protocol.addFeed(await params.feedProvider(info.key, {
            sparse
          }));
        });
      }
    });
    this._controlPipeline.onCredentialProcessed.set(async (credential) => {
      await this.onCredentialProcessed.callIfSet(credential);
      log7("onCredentialProcessed", {
        credential
      }, {
        F: __dxlog_file8,
        L: 99,
        S: this,
        C: (f, a) => f(...a)
      });
      this.stateUpdate.emit();
    });
    this._controlPipeline.onDelegatedInvitation.set(async (invitation) => {
      log7("onDelegatedInvitation", {
        invitation
      }, {
        F: __dxlog_file8,
        L: 103,
        S: this,
        C: (f, a) => f(...a)
      });
      await params.onDelegatedInvitationStatusChange(invitation, true);
    });
    this._controlPipeline.onDelegatedInvitationRemoved.set(async (invitation) => {
      log7("onDelegatedInvitationRemoved", {
        invitation
      }, {
        F: __dxlog_file8,
        L: 107,
        S: this,
        C: (f, a) => f(...a)
      });
      await params.onDelegatedInvitationStatusChange(invitation, false);
    });
    this._controlPipeline.onMemberRoleChanged.set(async (changedMembers) => {
      log7("onMemberRoleChanged", () => ({
        changedMembers: changedMembers.map((m) => [
          m.key,
          m.role
        ])
      }), {
        F: __dxlog_file8,
        L: 111,
        S: this,
        C: (f, a) => f(...a)
      });
      await params.onMemberRolesChanged(changedMembers);
    });
    this.protocol = params.protocol;
  }
  get id() {
    return this._id;
  }
  get key() {
    return this._key;
  }
  get genesisFeedKey() {
    return this._genesisFeedKey;
  }
  get controlFeedKey() {
    return this._controlFeed?.key;
  }
  get dataFeedKey() {
    return this._dataFeed?.key;
  }
  get spaceState() {
    return this._controlPipeline.spaceState;
  }
  /**
  * @test-only
  */
  get controlPipeline() {
    return this._controlPipeline.pipeline;
  }
  async setControlFeed(feed) {
    invariant6(!this._controlFeed, "Control feed already set.", {
      F: __dxlog_file8,
      L: 155,
      S: this,
      A: [
        "!this._controlFeed",
        "'Control feed already set.'"
      ]
    });
    this._controlFeed = feed;
    await this._controlPipeline.setWriteFeed(feed);
    return this;
  }
  async setDataFeed(feed) {
    invariant6(!this._dataFeed, "Data feed already set.", {
      F: __dxlog_file8,
      L: 162,
      S: this,
      A: [
        "!this._dataFeed",
        "'Data feed already set.'"
      ]
    });
    this._dataFeed = feed;
    return this;
  }
  /**
  * Use for diagnostics.
  */
  getControlFeeds() {
    return Array.from(this._controlPipeline.spaceState.feeds.values());
  }
  async _open(ctx) {
    log7("opening...", void 0, {
      F: __dxlog_file8,
      L: 176,
      S: this,
      C: (f, a) => f(...a)
    });
    await this._controlPipeline.start();
    log7("opened", void 0, {
      F: __dxlog_file8,
      L: 181,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  async startProtocol() {
    invariant6(this.isOpen, void 0, {
      F: __dxlog_file8,
      L: 186,
      S: this,
      A: [
        "this.isOpen",
        ""
      ]
    });
    await this.protocol.start();
    await this.protocol.addFeed(await this._feedProvider(this._genesisFeedKey));
  }
  async _close() {
    log7("closing...", {
      key: this._key
    }, {
      F: __dxlog_file8,
      L: 193,
      S: this,
      C: (f, a) => f(...a)
    });
    await this.protocol.stop();
    await this._controlPipeline.stop();
    log7("closed", void 0, {
      F: __dxlog_file8,
      L: 199,
      S: this,
      C: (f, a) => f(...a)
    });
  }
};
_ts_decorate5([
  trace2.info()
], Space.prototype, "protocol", void 0);
_ts_decorate5([
  trace2.info()
], Space.prototype, "_controlPipeline", void 0);
_ts_decorate5([
  logInfo,
  trace2.info()
], Space.prototype, "id", null);
_ts_decorate5([
  logInfo,
  trace2.info()
], Space.prototype, "key", null);
_ts_decorate5([
  trace2.span()
], Space.prototype, "_open", null);
_ts_decorate5([
  synchronized3
], Space.prototype, "startProtocol", null);
_ts_decorate5([
  synchronized3
], Space.prototype, "_close", null);
Space = _ts_decorate5([
  trackLeaks2("open", "close"),
  trace2.resource()
], Space);

// packages/core/echo/echo-pipeline/src/space/admission-discovery-extension.ts
import { scheduleTask as scheduleTask2 } from "@dxos/async";
import { Context as Context5 } from "@dxos/context";
import { ProtocolError } from "@dxos/protocols";
import { schema as schema4 } from "@dxos/protocols/proto";
import { RpcExtension as RpcExtension2 } from "@dxos/teleport";
var __dxlog_file9 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-pipeline/src/space/admission-discovery-extension.ts";
var CredentialRetrieverExtension = class extends RpcExtension2 {
  constructor(_request, _onResult) {
    super({
      requested: {
        AdmissionDiscoveryService: schema4.getService("dxos.mesh.teleport.AdmissionDiscoveryService")
      }
    }), this._request = _request, this._onResult = _onResult, this._ctx = new Context5(void 0, {
      F: __dxlog_file9,
      L: 26
    });
  }
  async getHandlers() {
    return {};
  }
  async onOpen(context) {
    await super.onOpen(context);
    scheduleTask2(this._ctx, async () => {
      try {
        const result = await this.rpc.AdmissionDiscoveryService.getAdmissionCredential(this._request);
        this._onResult.wake(result.admissionCredential);
      } catch (err) {
        context.close(err);
      }
    });
  }
  async onClose() {
    await this._ctx.dispose();
  }
  async onAbort() {
    await this._ctx.dispose();
  }
};
var CredentialServerExtension = class extends RpcExtension2 {
  constructor(_space) {
    super({
      exposed: {
        AdmissionDiscoveryService: schema4.getService("dxos.mesh.teleport.AdmissionDiscoveryService")
      }
    }), this._space = _space;
  }
  async getHandlers() {
    return {
      AdmissionDiscoveryService: {
        getAdmissionCredential: async (request) => {
          const memberInfo = this._space.spaceState.members.get(request.memberKey);
          if (!memberInfo?.credential) {
            throw new ProtocolError("Space member not found.", request);
          }
          return {
            admissionCredential: memberInfo.credential
          };
        }
      }
    };
  }
};

// packages/core/echo/echo-pipeline/src/space/space-protocol.ts
import { discoveryKey, subtleCrypto as subtleCrypto2 } from "@dxos/crypto";
import { PublicKey as PublicKey5 } from "@dxos/keys";
import { log as log8, logInfo as logInfo2 } from "@dxos/log";
import { MMSTTopology } from "@dxos/network-manager";
import { Teleport } from "@dxos/teleport";
import { BlobSync } from "@dxos/teleport-extension-object-sync";
import { ReplicatorExtension } from "@dxos/teleport-extension-replicator";
import { trace as trace3 } from "@dxos/tracing";
import { CallbackCollection, ComplexMap as ComplexMap4 } from "@dxos/util";
function _ts_decorate6(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file10 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-pipeline/src/space/space-protocol.ts";
var MOCK_AUTH_PROVIDER = async (nonce) => Buffer.from("mock");
var MOCK_AUTH_VERIFIER = async (nonce, credential) => true;
var SpaceProtocol = class {
  constructor({ topic, swarmIdentity, networkManager, onSessionAuth, onAuthFailure, blobStore, disableP2pReplication }) {
    this._feeds = /* @__PURE__ */ new Set();
    this._sessions = new ComplexMap4(PublicKey5.hash);
    // TODO(burdon): Move to config (with sensible defaults).
    this._topology = new MMSTTopology({
      originateConnections: 4,
      maxPeers: 10,
      sampleSize: 20
    });
    this.feedAdded = new CallbackCollection();
    this._spaceKey = topic;
    this._networkManager = networkManager;
    this._swarmIdentity = swarmIdentity;
    this._onSessionAuth = onSessionAuth;
    this._onAuthFailure = onAuthFailure;
    this.blobSync = new BlobSync({
      blobStore
    });
    this._topic = subtleCrypto2.digest("SHA-256", topic.asBuffer()).then(discoveryKey).then(PublicKey5.from);
    this._disableP2pReplication = disableP2pReplication ?? false;
  }
  get sessions() {
    return this._sessions;
  }
  get feeds() {
    return this._feeds;
  }
  get _ownPeerKey() {
    return this._swarmIdentity.peerKey;
  }
  // TODO(burdon): Create abstraction for Space (e.g., add keys and have provider).
  async addFeed(feed) {
    log8("addFeed", {
      key: feed.key
    }, {
      F: __dxlog_file10,
      L: 128,
      S: this,
      C: (f, a) => f(...a)
    });
    this._feeds.add(feed);
    for (const session of this._sessions.values()) {
      session.replicator.addFeed(feed);
    }
    await this.feedAdded.callSerial(feed);
  }
  // TODO(burdon): Rename open? Common open/close interfaces for all services?
  async start() {
    if (this._connection) {
      return;
    }
    const credentials = await this._swarmIdentity.credentialProvider(Buffer.from(""));
    await this.blobSync.open();
    log8("starting...", void 0, {
      F: __dxlog_file10,
      L: 149,
      S: this,
      C: (f, a) => f(...a)
    });
    const topic = await this._topic;
    this._connection = await this._networkManager.joinSwarm({
      protocolProvider: this._createProtocolProvider(credentials),
      topic,
      topology: this._topology,
      label: `swarm ${topic.truncate()} for space ${this._spaceKey.truncate()}`
    });
    log8("started", void 0, {
      F: __dxlog_file10,
      L: 158,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  updateTopology() {
    this._topology.forceUpdate();
  }
  async stop() {
    await this.blobSync.close();
    if (this._connection) {
      log8("stopping...", void 0, {
        F: __dxlog_file10,
        L: 169,
        S: this,
        C: (f, a) => f(...a)
      });
      await this._connection.close();
      log8("stopped", void 0, {
        F: __dxlog_file10,
        L: 171,
        S: this,
        C: (f, a) => f(...a)
      });
    }
  }
  _createProtocolProvider(credentials) {
    return (wireParams) => {
      const session = new SpaceProtocolSession({
        wireParams,
        swarmIdentity: this._swarmIdentity,
        onSessionAuth: this._onSessionAuth,
        onAuthFailure: this._onAuthFailure,
        blobSync: this.blobSync,
        disableP2pReplication: this._disableP2pReplication
      });
      this._sessions.set(wireParams.remotePeerId, session);
      for (const feed of this._feeds) {
        session.replicator.addFeed(feed);
      }
      return session;
    };
  }
};
_ts_decorate6([
  logInfo2,
  trace3.info()
], SpaceProtocol.prototype, "_topic", void 0);
_ts_decorate6([
  trace3.info()
], SpaceProtocol.prototype, "_spaceKey", void 0);
_ts_decorate6([
  logInfo2
], SpaceProtocol.prototype, "_ownPeerKey", null);
SpaceProtocol = _ts_decorate6([
  trace3.resource()
], SpaceProtocol);
var AuthStatus = /* @__PURE__ */ function(AuthStatus2) {
  AuthStatus2["INITIAL"] = "INITIAL";
  AuthStatus2["SUCCESS"] = "SUCCESS";
  AuthStatus2["FAILURE"] = "FAILURE";
  return AuthStatus2;
}({});
var SpaceProtocolSession = class {
  // TODO(dmaretskyi): Allow to pass in extra extensions.
  constructor({ wireParams, swarmIdentity, onSessionAuth, onAuthFailure, blobSync, disableP2pReplication }) {
    // TODO(dmaretskyi): Start with upload=false when switching it on the fly works.
    this.replicator = new ReplicatorExtension().setOptions({
      upload: true
    });
    this._authStatus = "INITIAL";
    this._wireParams = wireParams;
    this._swarmIdentity = swarmIdentity;
    this._onSessionAuth = onSessionAuth;
    this._onAuthFailure = onAuthFailure;
    this._blobSync = blobSync;
    this._teleport = new Teleport(wireParams);
    this._disableP2pReplication = disableP2pReplication ?? false;
  }
  get authStatus() {
    return this._authStatus;
  }
  get stats() {
    return this._teleport.stats;
  }
  get stream() {
    return this._teleport.stream;
  }
  async open(sessionId) {
    await this._teleport.open(sessionId);
    this._teleport.addExtension("dxos.mesh.teleport.auth", new AuthExtension({
      provider: this._swarmIdentity.credentialProvider,
      verifier: this._swarmIdentity.credentialAuthenticator,
      onAuthSuccess: () => {
        log8("Peer authenticated", void 0, {
          F: __dxlog_file10,
          L: 282,
          S: this,
          C: (f, a) => f(...a)
        });
        this._authStatus = "SUCCESS";
        this._onSessionAuth?.(this._teleport);
      },
      onAuthFailure: () => {
        this._authStatus = "FAILURE";
        this._onAuthFailure?.(this._teleport);
      }
    }));
    if (!this._disableP2pReplication) {
      this._teleport.addExtension("dxos.mesh.teleport.replicator", this.replicator);
    }
    this._teleport.addExtension("dxos.mesh.teleport.blobsync", this._blobSync.createExtension());
  }
  async close() {
    log8("close", void 0, {
      F: __dxlog_file10,
      L: 301,
      S: this,
      C: (f, a) => f(...a)
    });
    await this._teleport.close();
  }
  async abort() {
    await this._teleport.abort();
  }
};
_ts_decorate6([
  logInfo2
], SpaceProtocolSession.prototype, "_wireParams", void 0);
_ts_decorate6([
  logInfo2
], SpaceProtocolSession.prototype, "authStatus", null);

// packages/core/echo/echo-pipeline/src/space/space-manager.ts
import { parseAutomergeUrl } from "@automerge/automerge-repo";
import { synchronized as synchronized4, trackLeaks as trackLeaks3, Trigger as Trigger2 } from "@dxos/async";
import { getCredentialAssertion } from "@dxos/credentials";
import { failUndefined as failUndefined2 } from "@dxos/debug";
import { PublicKey as PublicKey6 } from "@dxos/keys";
import { log as log9 } from "@dxos/log";
import { trace as trace4 } from "@dxos/protocols";
import { ComplexMap as ComplexMap5 } from "@dxos/util";
function _ts_decorate7(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file11 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-pipeline/src/space/space-manager.ts";
var SpaceManager = class {
  constructor({ feedStore, networkManager, metadataStore, blobStore, disableP2pReplication }) {
    this._spaces = new ComplexMap5(PublicKey6.hash);
    this._instanceId = PublicKey6.random().toHex();
    this._feedStore = feedStore;
    this._networkManager = networkManager;
    this._metadataStore = metadataStore;
    this._blobStore = blobStore;
    this._disableP2pReplication = disableP2pReplication ?? false;
  }
  // TODO(burdon): Remove.
  get spaces() {
    return this._spaces;
  }
  async open() {
  }
  async close() {
    await Promise.all([
      ...this._spaces.values()
    ].map((space) => space.close()));
  }
  async constructSpace({ metadata, swarmIdentity, onAuthorizedConnection, onAuthFailure, onDelegatedInvitationStatusChange, onMemberRolesChanged, memberKey }) {
    log9.trace("dxos.echo.space-manager.construct-space", trace4.begin({
      id: this._instanceId
    }), {
      F: __dxlog_file11,
      L: 102,
      S: this,
      C: (f, a) => f(...a)
    });
    log9("constructing space...", {
      spaceKey: metadata.genesisFeedKey
    }, {
      F: __dxlog_file11,
      L: 103,
      S: this,
      C: (f, a) => f(...a)
    });
    const genesisFeed = await this._feedStore.openFeed(metadata.genesisFeedKey ?? failUndefined2());
    const spaceKey = metadata.key;
    const spaceId = await createIdFromSpaceKey(spaceKey);
    const protocol = new SpaceProtocol({
      topic: spaceKey,
      swarmIdentity,
      networkManager: this._networkManager,
      onSessionAuth: onAuthorizedConnection,
      onAuthFailure,
      blobStore: this._blobStore,
      disableP2pReplication: this._disableP2pReplication
    });
    const space = new Space({
      id: spaceId,
      spaceKey,
      protocol,
      genesisFeed,
      feedProvider: (feedKey, opts) => this._feedStore.openFeed(feedKey, opts),
      metadataStore: this._metadataStore,
      memberKey,
      onDelegatedInvitationStatusChange,
      onMemberRolesChanged
    });
    this._spaces.set(space.key, space);
    log9.trace("dxos.echo.space-manager.construct-space", trace4.end({
      id: this._instanceId
    }), {
      F: __dxlog_file11,
      L: 133,
      S: this,
      C: (f, a) => f(...a)
    });
    return space;
  }
  async requestSpaceAdmissionCredential(params) {
    const traceKey = "dxos.echo.space-manager.request-space-admission";
    log9.trace(traceKey, trace4.begin({
      id: this._instanceId
    }), {
      F: __dxlog_file11,
      L: 139,
      S: this,
      C: (f, a) => f(...a)
    });
    log9("requesting space admission credential...", {
      spaceKey: params.spaceKey
    }, {
      F: __dxlog_file11,
      L: 140,
      S: this,
      C: (f, a) => f(...a)
    });
    const onCredentialResolved = new Trigger2();
    const protocol = new SpaceProtocol({
      topic: params.spaceKey,
      swarmIdentity: params.swarmIdentity,
      networkManager: this._networkManager,
      onSessionAuth: (session) => {
        session.addExtension("dxos.mesh.teleport.admission-discovery", new CredentialRetrieverExtension({
          spaceKey: params.spaceKey,
          memberKey: params.identityKey
        }, onCredentialResolved));
      },
      onAuthFailure: (session) => session.close(),
      blobStore: this._blobStore,
      disableP2pReplication: this._disableP2pReplication
    });
    try {
      await protocol.start();
      const credential = await onCredentialResolved.wait({
        timeout: params.timeout
      });
      log9.trace(traceKey, trace4.end({
        id: this._instanceId
      }), {
        F: __dxlog_file11,
        L: 164,
        S: this,
        C: (f, a) => f(...a)
      });
      return credential;
    } catch (err) {
      log9.trace(traceKey, trace4.error({
        id: this._instanceId,
        error: err
      }), {
        F: __dxlog_file11,
        L: 167,
        S: this,
        C: (f, a) => f(...a)
      });
      throw err;
    } finally {
      await protocol.stop();
    }
  }
  findSpaceByRootDocumentId(documentId) {
    return [
      ...this._spaces.values()
    ].find((space) => {
      return space.spaceState.credentials.some((credential) => {
        const assertion = getCredentialAssertion(credential);
        if (assertion["@type"] !== "dxos.halo.credentials.Epoch") {
          return false;
        }
        if (!assertion?.automergeRoot) {
          return false;
        }
        return parseAutomergeUrl(assertion.automergeRoot).documentId === documentId;
      });
    });
  }
};
_ts_decorate7([
  synchronized4
], SpaceManager.prototype, "open", null);
_ts_decorate7([
  synchronized4
], SpaceManager.prototype, "close", null);
SpaceManager = _ts_decorate7([
  trackLeaks3("open", "close")
], SpaceManager);

export {
  codec,
  valueEncoding,
  createMappedFeedWriter,
  createIdFromSpaceKey,
  MetadataStore,
  hasInvitationExpired,
  mapTimeframeToFeedIndexes,
  mapFeedIndexesToTimeframe,
  startAfter,
  TimeframeClock,
  Pipeline,
  AuthExtension,
  Space,
  CredentialRetrieverExtension,
  CredentialServerExtension,
  MOCK_AUTH_PROVIDER,
  MOCK_AUTH_VERIFIER,
  SpaceProtocol,
  AuthStatus,
  SpaceProtocolSession,
  SpaceManager
};
//# sourceMappingURL=chunk-35I6ERLG.mjs.map
