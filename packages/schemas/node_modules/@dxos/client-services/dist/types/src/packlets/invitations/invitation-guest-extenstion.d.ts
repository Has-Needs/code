import { type Mutex } from '@dxos/async';
import { Context } from '@dxos/context';
import { type Invitation } from '@dxos/protocols/proto/dxos/client/services';
import { type InvitationHostService } from '@dxos/protocols/proto/dxos/halo/invitations';
import { type ExtensionContext, RpcExtension } from '@dxos/teleport';
import { type FlowLockHolder } from './invitation-state';
type InvitationGuestExtensionCallbacks = {
    onOpen: (ctx: Context, extensionCtx: ExtensionContext) => void;
    onError: (error: Error) => void;
    onStateUpdate: (newState: Invitation.State) => void;
};
/**
 * Guest's side for a connection to a concrete peer in p2p network during invitation.
 */
export declare class InvitationGuestExtension extends RpcExtension<{
    InvitationHostService: InvitationHostService;
}, {
    InvitationHostService: InvitationHostService;
}> implements FlowLockHolder {
    private readonly _invitationFlowMutex;
    private readonly _callbacks;
    private _ctx;
    private _remoteOptions?;
    private _remoteOptionsTrigger;
    /**
     * Held to allow only one invitation flow at a time to be active.
     */
    private _invitationFlowLock;
    constructor(_invitationFlowMutex: Mutex, _callbacks: InvitationGuestExtensionCallbacks);
    hasFlowLock(): boolean;
    protected getHandlers(): Promise<{
        InvitationHostService: InvitationHostService;
    }>;
    onOpen(context: ExtensionContext): Promise<void>;
    onClose(): Promise<void>;
    onAbort(): Promise<void>;
    private _destroy;
}
export {};
//# sourceMappingURL=invitation-guest-extenstion.d.ts.map