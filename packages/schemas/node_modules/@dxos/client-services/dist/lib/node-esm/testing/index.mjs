import { createRequire } from 'node:module';const require = createRequire(import.meta.url);
import {
  ClientServicesHost,
  DataSpaceManager,
  InvitationsHandler,
  InvitationsManager,
  ServiceContext,
  SpaceInvitationProtocol
} from "../chunk-SKGQLRKS.mjs";

// packages/sdk/client-services/src/packlets/testing/credential-utils.ts
import { createCredential } from "@dxos/credentials";
import { PublicKey } from "@dxos/keys";
var createMockCredential = async ({ signer, issuer }) => createCredential({
  signer,
  issuer,
  subject: new PublicKey(Buffer.from("test")),
  assertion: {
    "@type": "example.testing.rpc.MessageWithAny",
    payload: {
      "@type": "google.protobuf.Any",
      value: Buffer.from("test")
    }
  }
});

// packages/sdk/client-services/src/packlets/testing/invitation-utils.ts
import { Trigger } from "@dxos/async";
import { InvitationEncoder } from "@dxos/client-protocol";
import { invariant } from "@dxos/invariant";
import { Invitation } from "@dxos/protocols/proto/dxos/client/services";
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/testing/invitation-utils.ts";
var sanitizeInvitation = (invitation) => {
  return InvitationEncoder.decode(InvitationEncoder.encode(invitation));
};
var performInvitation = ({ host, guest, options, hooks, guestDeviceProfile, codeInputDelay }) => {
  let guestError = false;
  let guestConnected = false;
  let wereConnected = false;
  const hostComplete = new Trigger();
  const guestComplete = new Trigger();
  const authCode = new Trigger();
  void createInvitation(host, options).then((hostObservable) => {
    hostObservable.subscribe(async (hostInvitation) => {
      switch (hostInvitation.state) {
        case Invitation.State.CONNECTING: {
          if (guestConnected) {
            if (wereConnected) {
              hostComplete.wake({
                invitation: hostInvitation
              });
            }
            break;
          }
          guestConnected = true;
          if (hooks?.host?.onConnecting?.(hostObservable)) {
            break;
          }
          const guestObservable = acceptInvitation(guest, hostInvitation, guestDeviceProfile);
          guestObservable.subscribe(async (guestInvitation) => {
            switch (guestInvitation.state) {
              case Invitation.State.CONNECTING: {
                if (hooks?.guest?.onConnecting?.(guestObservable)) {
                  break;
                }
                invariant(hostInvitation.swarmKey.equals(guestInvitation.swarmKey), void 0, {
                  F: __dxlog_file,
                  L: 95,
                  S: void 0,
                  A: [
                    "hostInvitation.swarmKey!.equals(guestInvitation.swarmKey!)",
                    ""
                  ]
                });
                break;
              }
              case Invitation.State.CONNECTED: {
                hooks?.guest?.onConnected?.(guestObservable);
                break;
              }
              case Invitation.State.READY_FOR_AUTHENTICATION: {
                if (hooks?.guest?.onReady?.(guestObservable)) {
                  break;
                }
                const code = await authCode.wait();
                if (codeInputDelay == null) {
                  await guestObservable.authenticate(code);
                } else {
                  setTimeout(async () => {
                    if (!guestError) {
                      await guestObservable.authenticate(code);
                    }
                  }, codeInputDelay);
                }
                break;
              }
              case Invitation.State.AUTHENTICATING: {
                hooks?.guest?.onAuthenticating?.(guestObservable);
                break;
              }
              case Invitation.State.SUCCESS: {
                if (hooks?.guest?.onSuccess?.(guestObservable)) {
                  break;
                }
                guestComplete.wake({
                  invitation: guestInvitation
                });
                break;
              }
              case Invitation.State.CANCELLED: {
                if (hooks?.guest?.onCancelled?.(guestObservable)) {
                  break;
                }
                guestComplete.wake({
                  invitation: guestInvitation
                });
                break;
              }
              case Invitation.State.TIMEOUT: {
                if (hooks?.guest?.onTimeout?.(guestObservable)) {
                  return;
                }
                guestComplete.wake({
                  invitation: guestInvitation
                });
              }
            }
          }, (error) => {
            guestError = true;
            if (hooks?.guest?.onError?.(guestObservable)) {
              return;
            }
            guestComplete.wake({
              error
            });
          });
          break;
        }
        case Invitation.State.CONNECTED: {
          wereConnected = true;
          hooks?.host?.onConnected?.(hostObservable);
          break;
        }
        case Invitation.State.READY_FOR_AUTHENTICATION: {
          if (hooks?.host?.onReady?.(hostObservable)) {
            break;
          }
          if (hostInvitation.authCode) {
            authCode.wake(hostInvitation.authCode);
          }
          break;
        }
        case Invitation.State.AUTHENTICATING: {
          hooks?.host?.onAuthenticating?.(hostObservable);
          break;
        }
        case Invitation.State.SUCCESS: {
          if (hooks?.host?.onSuccess?.(hostObservable)) {
            break;
          }
          hostComplete.wake({
            invitation: hostInvitation
          });
          break;
        }
        case Invitation.State.CANCELLED: {
          if (hooks?.host?.onCancelled?.(hostObservable)) {
            break;
          }
          hostComplete.wake({
            invitation: hostInvitation
          });
          break;
        }
        case Invitation.State.TIMEOUT: {
          if (hooks?.host?.onTimeout?.(hostObservable)) {
            break;
          }
          hostComplete.wake({
            invitation: hostInvitation
          });
          break;
        }
      }
    }, (error) => {
      if (hooks?.host?.onError?.(hostObservable)) {
        return;
      }
      hostComplete.wake({
        error
      });
    });
  });
  return [
    hostComplete.wait(),
    guestComplete.wait()
  ];
};
var createInvitation = async (host, options) => {
  options ??= {
    authMethod: Invitation.AuthMethod.NONE,
    ...options ?? {}
  };
  if (host instanceof ServiceContext) {
    return host.invitationsManager.createInvitation({
      kind: Invitation.Kind.SPACE,
      ...options
    });
  }
  return host.share(options);
};
var acceptInvitation = (guest, invitation, guestDeviceProfile) => {
  invitation = sanitizeInvitation(invitation);
  if (guest instanceof ServiceContext) {
    return guest.invitationsManager.acceptInvitation({
      invitation,
      deviceProfile: guestDeviceProfile
    });
  }
  return guest.join(invitation, guestDeviceProfile);
};

// packages/sdk/client-services/src/packlets/testing/test-builder.ts
import { Context } from "@dxos/context";
import { createCredentialSignerWithChain, CredentialGenerator } from "@dxos/credentials";
import { failUndefined } from "@dxos/debug";
import { EchoHost, MetadataStore, SpaceManager, valueEncoding, MeshEchoReplicator } from "@dxos/echo-pipeline";
import { FeedFactory, FeedStore } from "@dxos/feed-store";
import { Keyring } from "@dxos/keyring";
import { createTestLevel } from "@dxos/kv-store/testing";
import { MemorySignalManager, MemorySignalManagerContext } from "@dxos/messaging";
import { MemoryTransportFactory, SwarmNetworkManager } from "@dxos/network-manager";
import { Invitation as Invitation2 } from "@dxos/protocols/proto/dxos/client/services";
import { createStorage, StorageType } from "@dxos/random-access-storage";
import { BlobStore } from "@dxos/teleport-extension-object-sync";
var __dxlog_file2 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/testing/test-builder.ts";
var createServiceHost = (config, signalManagerContext) => {
  return new ClientServicesHost({
    config,
    signalManager: new MemorySignalManager(signalManagerContext),
    transportFactory: MemoryTransportFactory
  });
};
var createServiceContext = async ({ signalManagerFactory = async () => {
  const signalContext = new MemorySignalManagerContext();
  return new MemorySignalManager(signalContext);
}, storage = createStorage({
  type: StorageType.RAM
}), runtimeParams } = {}) => {
  const signalManager = await signalManagerFactory();
  const networkManager = new SwarmNetworkManager({
    signalManager,
    transportFactory: MemoryTransportFactory
  });
  const level = createTestLevel();
  await level.open();
  return new ServiceContext(storage, level, networkManager, signalManager, void 0, void 0, {
    invitationConnectionDefaultParams: {
      teleport: {
        controlHeartbeatInterval: 200
      }
    },
    ...runtimeParams
  });
};
var createPeers = async (numPeers, signalManagerFactory) => {
  if (!signalManagerFactory) {
    const signalContext = new MemorySignalManagerContext();
    signalManagerFactory = async () => new MemorySignalManager(signalContext);
  }
  return await Promise.all(Array.from(Array(numPeers)).map(async () => {
    const peer = await createServiceContext({
      signalManagerFactory
    });
    await peer.open(new Context(void 0, {
      F: __dxlog_file2,
      L: 70
    }));
    return peer;
  }));
};
var createIdentity = async (peer) => {
  await peer.createIdentity();
  return peer;
};
var TestBuilder = class {
  constructor() {
    this.signalContext = new MemorySignalManagerContext();
    this._ctx = new Context(void 0, {
      F: __dxlog_file2,
      L: 83
    });
  }
  createPeer(peerOptions) {
    const peer = new TestPeer(this.signalContext, peerOptions);
    this._ctx.onDispose(async () => peer.destroy());
    return peer;
  }
  async destroy() {
    await this._ctx.dispose();
  }
};
var TestPeer = class {
  constructor(_signalContext, _opts = {
    dataStore: StorageType.RAM
  }) {
    this._signalContext = _signalContext;
    this._opts = _opts;
    this._props = {};
  }
  get props() {
    return this._props;
  }
  get storage() {
    return this._props.storage ??= createStorage({
      type: this._opts.dataStore
    });
  }
  get keyring() {
    return this._props.keyring ??= new Keyring(this.storage.createDirectory("keyring"));
  }
  get level() {
    return this._props.level ??= createTestLevel();
  }
  get feedStore() {
    return this._props.feedStore ??= new FeedStore({
      factory: new FeedFactory({
        root: this.storage.createDirectory("feeds"),
        signer: this.keyring,
        hypercore: {
          valueEncoding
        }
      })
    });
  }
  get metadataStore() {
    return this._props.metadataStore ??= new MetadataStore(this.storage.createDirectory("metadata"));
  }
  get blobStore() {
    return this._props.blobStore ??= new BlobStore(this.storage.createDirectory("blobs"));
  }
  get networkManager() {
    return this._props.networkManager ??= new SwarmNetworkManager({
      signalManager: new MemorySignalManager(this._signalContext),
      transportFactory: MemoryTransportFactory
    });
  }
  get spaceManager() {
    return this._props.spaceManager ??= new SpaceManager({
      feedStore: this.feedStore,
      networkManager: this.networkManager,
      metadataStore: this.metadataStore,
      blobStore: this.blobStore
    });
  }
  get identity() {
    return this._props.signingContext ?? failUndefined();
  }
  get echoHost() {
    return this._props.echoHost ??= new EchoHost({
      kv: this.level
    });
  }
  get meshEchoReplicator() {
    return this._props.meshEchoReplicator ??= new MeshEchoReplicator();
  }
  get dataSpaceManager() {
    return this._props.dataSpaceManager ??= new DataSpaceManager({
      spaceManager: this.spaceManager,
      metadataStore: this.metadataStore,
      keyring: this.keyring,
      signingContext: this.identity,
      feedStore: this.feedStore,
      echoHost: this.echoHost,
      invitationsManager: this.invitationsManager,
      edgeConnection: void 0,
      meshReplicator: this.meshEchoReplicator,
      echoEdgeReplicator: void 0,
      runtimeParams: this._opts.dataSpaceParams
    });
  }
  get invitationsManager() {
    return this._props.invitationsManager ??= new InvitationsManager(new InvitationsHandler(this.networkManager), (invitation) => {
      if (invitation.kind === Invitation2.Kind.SPACE) {
        return new SpaceInvitationProtocol(this.dataSpaceManager, this.identity, this.keyring, invitation.spaceKey);
      } else {
        throw new Error("not implemented");
      }
    }, this.metadataStore);
  }
  async createIdentity() {
    this._props.signingContext ??= await createSigningContext(this.keyring);
    this.networkManager.setPeerInfo({
      identityKey: this._props.signingContext.identityKey.toHex(),
      peerKey: this._props.signingContext.deviceKey.toHex()
    });
  }
  async destroy() {
    await this.level.close();
    await this.storage.reset();
  }
};
var createSigningContext = async (keyring) => {
  const identityKey = await keyring.createKey();
  const deviceKey = await keyring.createKey();
  return {
    identityKey,
    deviceKey,
    credentialSigner: createCredentialSignerWithChain(keyring, {
      credential: await new CredentialGenerator(keyring, identityKey, deviceKey).createDeviceAuthorization(deviceKey)
    }, deviceKey),
    recordCredential: async () => {
    },
    getProfile: () => void 0
  };
};
export {
  TestBuilder,
  TestPeer,
  acceptInvitation,
  createIdentity,
  createInvitation,
  createMockCredential,
  createPeers,
  createServiceContext,
  createServiceHost,
  createSigningContext,
  performInvitation,
  sanitizeInvitation
};
//# sourceMappingURL=index.mjs.map
