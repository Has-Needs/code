{
  "version": 3,
  "sources": ["../../../src/packlets/worker/worker-runtime.ts", "../../../src/packlets/worker/worker-session.ts"],
  "sourcesContent": ["//\n// Copyright 2022 DXOS.org\n//\n\nimport { Trigger } from '@dxos/async';\nimport { DEFAULT_WORKER_BROADCAST_CHANNEL } from '@dxos/client-protocol';\nimport { type Config } from '@dxos/config';\nimport { Context } from '@dxos/context';\nimport { invariant } from '@dxos/invariant';\nimport { log } from '@dxos/log';\nimport {\n  MemorySignalManager,\n  MemorySignalManagerContext,\n  WebsocketSignalManager,\n  setIdentityTags,\n} from '@dxos/messaging';\nimport { RtcTransportProxyFactory } from '@dxos/network-manager';\nimport { type RpcPort } from '@dxos/rpc';\nimport { type MaybePromise } from '@dxos/util';\n\nimport { WorkerSession } from './worker-session';\nimport { ClientServicesHost } from '../services';\n\n// NOTE: Keep as RpcPorts to avoid dependency on @dxos/rpc-tunnel so we don't depend on browser-specific apis.\nexport type CreateSessionParams = {\n  appPort: RpcPort;\n  systemPort: RpcPort;\n  shellPort?: RpcPort;\n};\n\nexport type WorkerRuntimeOptions = {\n  channel?: string;\n  configProvider: () => MaybePromise<Config>;\n  acquireLock: () => Promise<void>;\n  releaseLock: () => void;\n  onStop?: () => Promise<void>;\n};\n\n/**\n * Runtime for the shared worker.\n * Manages connections from proxies (in tabs).\n * Tabs make requests to the `ClientServicesHost`, and provide a WebRTC gateway.\n */\nexport class WorkerRuntime {\n  private readonly _configProvider: () => MaybePromise<Config>;\n  private readonly _acquireLock: () => Promise<void>;\n  private readonly _releaseLock: () => void;\n  private readonly _onStop?: () => Promise<void>;\n  private readonly _transportFactory = new RtcTransportProxyFactory();\n  private readonly _ready = new Trigger<Error | undefined>();\n  private readonly _sessions = new Set<WorkerSession>();\n  private readonly _clientServices!: ClientServicesHost;\n  private readonly _channel: string;\n  private _broadcastChannel?: BroadcastChannel;\n  private _sessionForNetworking?: WorkerSession; // TODO(burdon): Expose to client QueryStatusResponse.\n  private _config!: Config;\n  private _signalMetadataTags: any = { runtime: 'worker-runtime' };\n  private _signalTelemetryEnabled: boolean = false;\n\n  constructor({\n    channel = DEFAULT_WORKER_BROADCAST_CHANNEL,\n    configProvider,\n    acquireLock,\n    releaseLock,\n    onStop,\n  }: WorkerRuntimeOptions) {\n    this._configProvider = configProvider;\n    this._acquireLock = acquireLock;\n    this._releaseLock = releaseLock;\n    this._onStop = onStop;\n    this._channel = channel;\n    this._clientServices = new ClientServicesHost({\n      callbacks: {\n        onReset: async () => this.stop(),\n      },\n    });\n  }\n\n  get host() {\n    return this._clientServices;\n  }\n\n  async start(): Promise<void> {\n    log('starting...');\n    try {\n      this._broadcastChannel = new BroadcastChannel(this._channel);\n      this._broadcastChannel.postMessage({ action: 'stop' });\n      this._broadcastChannel.onmessage = async (event) => {\n        if (event.data?.action === 'stop') {\n          await this.stop();\n        }\n      };\n\n      await this._acquireLock();\n      this._config = await this._configProvider();\n      const signals = this._config.get('runtime.services.signaling');\n      this._clientServices.initialize({\n        config: this._config,\n        signalManager: this._config.get('runtime.client.edgeFeatures')?.signaling\n          ? undefined\n          : signals\n            ? new WebsocketSignalManager(signals, () => (this._signalTelemetryEnabled ? this._signalMetadataTags : {}))\n            : new MemorySignalManager(new MemorySignalManagerContext()), // TODO(dmaretskyi): Inject this context.\n        transportFactory: this._transportFactory,\n      });\n\n      await this._clientServices.open(new Context());\n      this._ready.wake(undefined);\n      log('started');\n      setIdentityTags({\n        identityService: this._clientServices.services.IdentityService!,\n        devicesService: this._clientServices.services.DevicesService!,\n        setTag: (k: string, v: string) => {\n          this._signalMetadataTags[k] = v;\n        },\n      });\n    } catch (err: any) {\n      this._ready.wake(err);\n      log.error('starting', err);\n    }\n  }\n\n  async stop(): Promise<void> {\n    // Release the lock to notify remote clients that the worker is terminating.\n    this._releaseLock();\n    this._broadcastChannel?.close();\n    this._broadcastChannel = undefined;\n    await this._clientServices.close();\n    await this._onStop?.();\n  }\n\n  /**\n   * Create a new session.\n   */\n  async createSession({ appPort, systemPort, shellPort }: CreateSessionParams): Promise<void> {\n    const session = new WorkerSession({\n      serviceHost: this._clientServices,\n      appPort,\n      systemPort,\n      shellPort,\n      readySignal: this._ready,\n    });\n\n    // When tab is closed or client is destroyed.\n    session.onClose.set(async () => {\n      this._sessions.delete(session);\n      if (this._sessions.size === 0) {\n        // Terminate the worker when all sessions are closed.\n        await this.stop();\n      } else {\n        this._reconnectWebrtc();\n      }\n    });\n\n    await session.open();\n    // A worker can only service one origin currently\n    invariant(\n      !this._signalMetadataTags.origin || this._signalMetadataTags.origin === session.origin,\n      `worker origin changed from ${this._signalMetadataTags.origin} to ${session.origin}?`,\n    );\n    if (session.observabilityGroup) {\n      this._signalMetadataTags.group = session.observabilityGroup;\n    }\n    this._signalTelemetryEnabled = session.signalTelemetryEnabled ?? false;\n    this._signalMetadataTags.origin = session.origin;\n    this._sessions.add(session);\n\n    this._reconnectWebrtc();\n  }\n\n  /**\n   * Selects one of the existing session for WebRTC networking.\n   */\n  private _reconnectWebrtc(): void {\n    log('reconnecting webrtc...');\n    // Check if current session is already closed.\n    if (this._sessionForNetworking) {\n      if (!this._sessions.has(this._sessionForNetworking)) {\n        this._sessionForNetworking = undefined;\n      }\n    }\n\n    // Select existing session.\n    if (!this._sessionForNetworking) {\n      const selected = Array.from(this._sessions).find((session) => session.bridgeService);\n      if (selected) {\n        this._sessionForNetworking = selected;\n        this._transportFactory.setBridgeService(selected.bridgeService);\n      } else {\n        this._transportFactory.setBridgeService(undefined);\n      }\n    }\n  }\n}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { asyncTimeout, Trigger } from '@dxos/async';\nimport {\n  iframeServiceBundle,\n  type IframeServiceBundle,\n  PROXY_CONNECTION_TIMEOUT,\n  workerServiceBundle,\n} from '@dxos/client-protocol';\nimport { invariant } from '@dxos/invariant';\nimport { log, logInfo } from '@dxos/log';\nimport { type BridgeService } from '@dxos/protocols/proto/dxos/mesh/bridge';\nimport { createProtoRpcPeer, type ProtoRpcPeer, type RpcPort } from '@dxos/rpc';\nimport { Callback, type MaybePromise } from '@dxos/util';\n\nimport { type ClientServicesHost, ClientRpcServer, type ClientRpcServerParams } from '../services';\n\nexport type WorkerSessionParams = {\n  serviceHost: ClientServicesHost;\n  systemPort: RpcPort;\n  appPort: RpcPort;\n  // TODO(wittjosiah): Remove shellPort.\n  shellPort?: RpcPort;\n  readySignal: Trigger<Error | undefined>;\n};\n\n/**\n * Represents a tab connection within the worker.\n */\nexport class WorkerSession {\n  private readonly _clientRpc: ClientRpcServer;\n  private readonly _shellClientRpc?: ClientRpcServer;\n  private readonly _iframeRpc: ProtoRpcPeer<IframeServiceBundle>;\n  private readonly _startTrigger = new Trigger();\n  private readonly _serviceHost: ClientServicesHost;\n\n  public readonly onClose = new Callback<() => Promise<void>>();\n\n  @logInfo\n  public origin?: string;\n\n  // TODO(nf): factor out?\n  public observabilityGroup?: string;\n  public signalTelemetryEnabled?: boolean;\n\n  @logInfo\n  public lockKey?: string;\n\n  public bridgeService?: BridgeService;\n\n  constructor({ serviceHost, systemPort, appPort, shellPort, readySignal }: WorkerSessionParams) {\n    invariant(serviceHost);\n    this._serviceHost = serviceHost;\n\n    const middleware: Pick<ClientRpcServerParams, 'handleCall' | 'handleStream'> = {\n      handleCall: async (method, params, handler) => {\n        const error = await readySignal.wait({ timeout: PROXY_CONNECTION_TIMEOUT });\n        if (error) {\n          throw error;\n        }\n\n        return handler(method, params);\n      },\n      handleStream: async (method, params, handler) => {\n        const error = await readySignal.wait({ timeout: PROXY_CONNECTION_TIMEOUT });\n        if (error) {\n          throw error;\n        }\n\n        return handler(method, params);\n      },\n    };\n\n    this._clientRpc = new ClientRpcServer({\n      serviceRegistry: this._serviceHost.serviceRegistry,\n      port: appPort,\n      ...middleware,\n    });\n\n    this._shellClientRpc = shellPort\n      ? new ClientRpcServer({\n          serviceRegistry: this._serviceHost.serviceRegistry,\n          port: shellPort,\n          ...middleware,\n        })\n      : undefined;\n\n    this._iframeRpc = createProtoRpcPeer({\n      requested: iframeServiceBundle,\n      exposed: workerServiceBundle,\n      handlers: {\n        WorkerService: {\n          start: async (request) => {\n            this.origin = request.origin;\n            this.lockKey = request.lockKey;\n            this.observabilityGroup = request.observabilityGroup;\n            this.signalTelemetryEnabled = request.signalTelemetryEnabled;\n            this._startTrigger.wake();\n          },\n\n          stop: async () => {\n            setTimeout(async () => {\n              try {\n                await this.close();\n              } catch (err: any) {\n                log.catch(err);\n              }\n            });\n          },\n        },\n      },\n      port: systemPort,\n      timeout: 1_000, // With low timeout heartbeat may fail if the tab's thread is saturated.\n    });\n\n    this.bridgeService = this._iframeRpc.rpc.BridgeService;\n  }\n\n  async open(): Promise<void> {\n    log.info('opening...');\n    await Promise.all([this._clientRpc.open(), this._iframeRpc.open(), this._maybeOpenShell()]);\n\n    // Wait until the worker's RPC service has started.\n    await this._startTrigger.wait({ timeout: PROXY_CONNECTION_TIMEOUT });\n\n    // TODO(burdon): Comment required.\n    if (this.lockKey) {\n      void this._afterLockReleases(this.lockKey, () => this.close());\n    }\n\n    log.info('opened');\n  }\n\n  async close(): Promise<void> {\n    log.info('closing...');\n    try {\n      await this.onClose.callIfSet();\n    } catch (err: any) {\n      log.catch(err);\n    }\n\n    await Promise.all([this._clientRpc.close(), this._iframeRpc.close()]);\n    log.info('closed');\n  }\n\n  private async _maybeOpenShell(): Promise<void> {\n    try {\n      this._shellClientRpc && (await asyncTimeout(this._shellClientRpc.open(), 1_000));\n    } catch {\n      log.info('No shell connected.');\n    }\n  }\n\n  private _afterLockReleases(lockKey: string, callback: () => MaybePromise<void>): Promise<void> {\n    return navigator.locks\n      .request(lockKey, () => {\n        // No-op.\n      })\n      .then(callback);\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA,SAASA,WAAAA,gBAAe;AACxB,SAASC,wCAAwC;AAEjD,SAASC,eAAe;AACxB,SAASC,aAAAA,kBAAiB;AAC1B,SAASC,OAAAA,YAAW;AACpB,SACEC,qBACAC,4BACAC,wBACAC,uBACK;AACP,SAASC,gCAAgC;;;ACZzC,SAASC,cAAcC,eAAe;AACtC,SACEC,qBAEAC,0BACAC,2BACK;AACP,SAASC,iBAAiB;AAC1B,SAASC,KAAKC,eAAe;AAE7B,SAASC,0BAA2D;AACpE,SAASC,gBAAmC;;;;;;;;AAgBrC,IAAMC,gBAAN,MAAMA;EAqBX,YAAY,EAAEC,aAAaC,YAAYC,SAASC,WAAWC,YAAW,GAAyB;AAjB9EC,yBAAgB,IAAIC,QAAAA;AAGrBC,mBAAU,IAAIC,SAAAA;AAe5BC,cAAUT,aAAAA,QAAAA;;;;;;;;;AACV,SAAKU,eAAeV;AAEpB,UAAMW,aAAyE;MAC7EC,YAAY,OAAOC,QAAQC,QAAQC,YAAAA;AACjC,cAAMC,QAAQ,MAAMZ,YAAYa,KAAK;UAAEC,SAASC;QAAyB,CAAA;AACzE,YAAIH,OAAO;AACT,gBAAMA;QACR;AAEA,eAAOD,QAAQF,QAAQC,MAAAA;MACzB;MACAM,cAAc,OAAOP,QAAQC,QAAQC,YAAAA;AACnC,cAAMC,QAAQ,MAAMZ,YAAYa,KAAK;UAAEC,SAASC;QAAyB,CAAA;AACzE,YAAIH,OAAO;AACT,gBAAMA;QACR;AAEA,eAAOD,QAAQF,QAAQC,MAAAA;MACzB;IACF;AAEA,SAAKO,aAAa,IAAIC,gBAAgB;MACpCC,iBAAiB,KAAKb,aAAaa;MACnCC,MAAMtB;MACN,GAAGS;IACL,CAAA;AAEA,SAAKc,kBAAkBtB,YACnB,IAAImB,gBAAgB;MAClBC,iBAAiB,KAAKb,aAAaa;MACnCC,MAAMrB;MACN,GAAGQ;IACL,CAAA,IACAe;AAEJ,SAAKC,aAAaC,mBAAmB;MACnCC,WAAWC;MACXC,SAASC;MACTC,UAAU;QACRC,eAAe;UACbC,OAAO,OAAOC,YAAAA;AACZ,iBAAKC,SAASD,QAAQC;AACtB,iBAAKC,UAAUF,QAAQE;AACvB,iBAAKC,qBAAqBH,QAAQG;AAClC,iBAAKC,yBAAyBJ,QAAQI;AACtC,iBAAKnC,cAAcoC,KAAI;UACzB;UAEAC,MAAM,YAAA;AACJC,uBAAW,YAAA;AACT,kBAAI;AACF,sBAAM,KAAKC,MAAK;cAClB,SAASC,KAAU;AACjBC,oBAAIC,MAAMF,KAAAA,QAAAA;;;;;;cACZ;YACF,CAAA;UACF;QACF;MACF;MACArB,MAAMvB;MACNiB,SAAS;IACX,CAAA;AAEA,SAAK8B,gBAAgB,KAAKrB,WAAWsB,IAAIC;EAC3C;EAEA,MAAMC,OAAsB;AAC1BL,QAAIM,KAAK,cAAA,QAAA;;;;;;AACT,UAAMC,QAAQC,IAAI;MAAC,KAAKjC,WAAW8B,KAAI;MAAI,KAAKxB,WAAWwB,KAAI;MAAI,KAAKI,gBAAe;KAAG;AAG1F,UAAM,KAAKlD,cAAcY,KAAK;MAAEC,SAASC;IAAyB,CAAA;AAGlE,QAAI,KAAKmB,SAAS;AAChB,WAAK,KAAKkB,mBAAmB,KAAKlB,SAAS,MAAM,KAAKM,MAAK,CAAA;IAC7D;AAEAE,QAAIM,KAAK,UAAA,QAAA;;;;;;EACX;EAEA,MAAMR,QAAuB;AAC3BE,QAAIM,KAAK,cAAA,QAAA;;;;;;AACT,QAAI;AACF,YAAM,KAAK7C,QAAQkD,UAAS;IAC9B,SAASZ,KAAU;AACjBC,UAAIC,MAAMF,KAAAA,QAAAA;;;;;;IACZ;AAEA,UAAMQ,QAAQC,IAAI;MAAC,KAAKjC,WAAWuB,MAAK;MAAI,KAAKjB,WAAWiB,MAAK;KAAG;AACpEE,QAAIM,KAAK,UAAA,QAAA;;;;;;EACX;EAEA,MAAcG,kBAAiC;AAC7C,QAAI;AACF,WAAK9B,mBAAoB,MAAMiC,aAAa,KAAKjC,gBAAgB0B,KAAI,GAAI,GAAA;IAC3E,QAAQ;AACNL,UAAIM,KAAK,uBAAA,QAAA;;;;;;IACX;EACF;EAEQI,mBAAmBlB,SAAiBqB,UAAmD;AAC7F,WAAOC,UAAUC,MACdzB,QAAQE,SAAS,MAAA;IAElB,CAAA,EACCwB,KAAKH,QAAAA;EACV;AACF;;;;;;;;;;ADvHO,IAAMI,gBAAN,MAAMA;EAgBX,YAAY,EACVC,UAAUC,kCACVC,gBACAC,aACAC,aACAC,OAAM,GACiB;AAjBRC,6BAAoB,IAAIC,yBAAAA;AACxBC,kBAAS,IAAIC,SAAAA;AACbC,qBAAY,oBAAIC,IAAAA;AAMzBC,+BAA2B;MAAEC,SAAS;IAAiB;AACvDC,mCAAmC;AASzC,SAAKC,kBAAkBb;AACvB,SAAKc,eAAeb;AACpB,SAAKc,eAAeb;AACpB,SAAKc,UAAUb;AACf,SAAKc,WAAWnB;AAChB,SAAKoB,kBAAkB,IAAIC,mBAAmB;MAC5CC,WAAW;QACTC,SAAS,YAAY,KAAKC,KAAI;MAChC;IACF,CAAA;EACF;EAEA,IAAIC,OAAO;AACT,WAAO,KAAKL;EACd;EAEA,MAAMM,QAAuB;AAC3BC,IAAAA,KAAI,eAAA,QAAA;;;;;;AACJ,QAAI;AACF,WAAKC,oBAAoB,IAAIC,iBAAiB,KAAKV,QAAQ;AAC3D,WAAKS,kBAAkBE,YAAY;QAAEC,QAAQ;MAAO,CAAA;AACpD,WAAKH,kBAAkBI,YAAY,OAAOC,UAAAA;AACxC,YAAIA,MAAMC,MAAMH,WAAW,QAAQ;AACjC,gBAAM,KAAKP,KAAI;QACjB;MACF;AAEA,YAAM,KAAKR,aAAY;AACvB,WAAKmB,UAAU,MAAM,KAAKpB,gBAAe;AACzC,YAAMqB,UAAU,KAAKD,QAAQE,IAAI,4BAAA;AACjC,WAAKjB,gBAAgBkB,WAAW;QAC9BC,QAAQ,KAAKJ;QACbK,eAAe,KAAKL,QAAQE,IAAI,6BAAA,GAAgCI,YAC5DC,SACAN,UACE,IAAIO,uBAAuBP,SAAS,MAAO,KAAKtB,0BAA0B,KAAKF,sBAAsB,CAAC,CAAA,IACtG,IAAIgC,oBAAoB,IAAIC,2BAAAA,CAAAA;QAClCC,kBAAkB,KAAKxC;MACzB,CAAA;AAEA,YAAM,KAAKc,gBAAgB2B,KAAK,IAAIC,QAAAA,QAAAA;;;;AACpC,WAAKxC,OAAOyC,KAAKP,MAAAA;AACjBf,MAAAA,KAAI,WAAA,QAAA;;;;;;AACJuB,sBAAgB;QACdC,iBAAiB,KAAK/B,gBAAgBgC,SAASC;QAC/CC,gBAAgB,KAAKlC,gBAAgBgC,SAASG;QAC9CC,QAAQ,CAACC,GAAWC,MAAAA;AAClB,eAAK9C,oBAAoB6C,CAAAA,IAAKC;QAChC;MACF,CAAA;IACF,SAASC,KAAU;AACjB,WAAKnD,OAAOyC,KAAKU,GAAAA;AACjBhC,MAAAA,KAAIiC,MAAM,YAAYD,KAAAA;;;;;;IACxB;EACF;EAEA,MAAMnC,OAAsB;AAE1B,SAAKP,aAAY;AACjB,SAAKW,mBAAmBiC,MAAAA;AACxB,SAAKjC,oBAAoBc;AACzB,UAAM,KAAKtB,gBAAgByC,MAAK;AAChC,UAAM,KAAK3C,UAAO;EACpB;;;;EAKA,MAAM4C,cAAc,EAAEC,SAASC,YAAYC,UAAS,GAAwC;AAC1F,UAAMC,UAAU,IAAIC,cAAc;MAChCC,aAAa,KAAKhD;MAClB2C;MACAC;MACAC;MACAI,aAAa,KAAK7D;IACpB,CAAA;AAGA0D,YAAQI,QAAQC,IAAI,YAAA;AAClB,WAAK7D,UAAU8D,OAAON,OAAAA;AACtB,UAAI,KAAKxD,UAAU+D,SAAS,GAAG;AAE7B,cAAM,KAAKjD,KAAI;MACjB,OAAO;AACL,aAAKkD,iBAAgB;MACvB;IACF,CAAA;AAEA,UAAMR,QAAQnB,KAAI;AAElB4B,IAAAA,WACE,CAAC,KAAK/D,oBAAoBgE,UAAU,KAAKhE,oBAAoBgE,WAAWV,QAAQU,QAChF,8BAA8B,KAAKhE,oBAAoBgE,MAAM,OAAOV,QAAQU,MAAM,KAAG;;;;;;;;;AAEvF,QAAIV,QAAQW,oBAAoB;AAC9B,WAAKjE,oBAAoBkE,QAAQZ,QAAQW;IAC3C;AACA,SAAK/D,0BAA0BoD,QAAQa,0BAA0B;AACjE,SAAKnE,oBAAoBgE,SAASV,QAAQU;AAC1C,SAAKlE,UAAUsE,IAAId,OAAAA;AAEnB,SAAKQ,iBAAgB;EACvB;;;;EAKQA,mBAAyB;AAC/B/C,IAAAA,KAAI,0BAAA,QAAA;;;;;;AAEJ,QAAI,KAAKsD,uBAAuB;AAC9B,UAAI,CAAC,KAAKvE,UAAUwE,IAAI,KAAKD,qBAAqB,GAAG;AACnD,aAAKA,wBAAwBvC;MAC/B;IACF;AAGA,QAAI,CAAC,KAAKuC,uBAAuB;AAC/B,YAAME,WAAWC,MAAMC,KAAK,KAAK3E,SAAS,EAAE4E,KAAK,CAACpB,YAAYA,QAAQqB,aAAa;AACnF,UAAIJ,UAAU;AACZ,aAAKF,wBAAwBE;AAC7B,aAAK7E,kBAAkBkF,iBAAiBL,SAASI,aAAa;MAChE,OAAO;AACL,aAAKjF,kBAAkBkF,iBAAiB9C,MAAAA;MAC1C;IACF;EACF;AACF;",
  "names": ["Trigger", "DEFAULT_WORKER_BROADCAST_CHANNEL", "Context", "invariant", "log", "MemorySignalManager", "MemorySignalManagerContext", "WebsocketSignalManager", "setIdentityTags", "RtcTransportProxyFactory", "asyncTimeout", "Trigger", "iframeServiceBundle", "PROXY_CONNECTION_TIMEOUT", "workerServiceBundle", "invariant", "log", "logInfo", "createProtoRpcPeer", "Callback", "WorkerSession", "serviceHost", "systemPort", "appPort", "shellPort", "readySignal", "_startTrigger", "Trigger", "onClose", "Callback", "invariant", "_serviceHost", "middleware", "handleCall", "method", "params", "handler", "error", "wait", "timeout", "PROXY_CONNECTION_TIMEOUT", "handleStream", "_clientRpc", "ClientRpcServer", "serviceRegistry", "port", "_shellClientRpc", "undefined", "_iframeRpc", "createProtoRpcPeer", "requested", "iframeServiceBundle", "exposed", "workerServiceBundle", "handlers", "WorkerService", "start", "request", "origin", "lockKey", "observabilityGroup", "signalTelemetryEnabled", "wake", "stop", "setTimeout", "close", "err", "log", "catch", "bridgeService", "rpc", "BridgeService", "open", "info", "Promise", "all", "_maybeOpenShell", "_afterLockReleases", "callIfSet", "asyncTimeout", "callback", "navigator", "locks", "then", "WorkerRuntime", "channel", "DEFAULT_WORKER_BROADCAST_CHANNEL", "configProvider", "acquireLock", "releaseLock", "onStop", "_transportFactory", "RtcTransportProxyFactory", "_ready", "Trigger", "_sessions", "Set", "_signalMetadataTags", "runtime", "_signalTelemetryEnabled", "_configProvider", "_acquireLock", "_releaseLock", "_onStop", "_channel", "_clientServices", "ClientServicesHost", "callbacks", "onReset", "stop", "host", "start", "log", "_broadcastChannel", "BroadcastChannel", "postMessage", "action", "onmessage", "event", "data", "_config", "signals", "get", "initialize", "config", "signalManager", "signaling", "undefined", "WebsocketSignalManager", "MemorySignalManager", "MemorySignalManagerContext", "transportFactory", "open", "Context", "wake", "setIdentityTags", "identityService", "services", "IdentityService", "devicesService", "DevicesService", "setTag", "k", "v", "err", "error", "close", "createSession", "appPort", "systemPort", "shellPort", "session", "WorkerSession", "serviceHost", "readySignal", "onClose", "set", "delete", "size", "_reconnectWebrtc", "invariant", "origin", "observabilityGroup", "group", "signalTelemetryEnabled", "add", "_sessionForNetworking", "has", "selected", "Array", "from", "find", "bridgeService", "setBridgeService"]
}
