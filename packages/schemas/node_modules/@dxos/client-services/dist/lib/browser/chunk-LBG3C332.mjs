import "@dxos/node-std/globals";

// packages/sdk/client-services/src/packlets/devtools/feeds.ts
import { SubscriptionList } from "@dxos/async";
import { Stream } from "@dxos/codec-protobuf/stream";
import { FeedIterator } from "@dxos/feed-store";
import { PublicKey } from "@dxos/keys";
import { log } from "@dxos/log";
import { ComplexMap } from "@dxos/util";
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/devtools/feeds.ts";
var subscribeToFeeds = ({ feedStore, spaceManager }, { feedKeys }) => {
  return new Stream(({ next }) => {
    const subscriptions = new SubscriptionList();
    const feedMap = new ComplexMap(PublicKey.hash);
    const update = () => {
      const { feeds } = feedStore;
      feeds.filter((feed) => !feedKeys?.length || feedKeys.some((feedKey) => feedKey.equals(feed.key))).forEach((feed) => {
        if (!feedMap.has(feed.key)) {
          feedMap.set(feed.key, {
            feed
          });
          feed.on("close", update);
          subscriptions.add(() => feed.off("close", update));
        }
        if (!feedMap.get(feed.key)?.owner) {
          feedMap.get(feed.key).owner = findFeedOwner(spaceManager, feed.key);
        }
      });
      next({
        feeds: Array.from(feedMap.values()).map(({ feed, owner }) => ({
          feedKey: feed.key,
          length: feed.properties.length,
          bytes: feed.core.byteLength,
          downloaded: feed.core.bitfield?.data.toBuffer() ?? new Uint8Array(),
          owner
        }))
      });
    };
    subscriptions.add(feedStore.feedOpened.on(update));
    update();
    return () => {
      subscriptions.clear();
    };
  });
};
var findFeedOwner = (spaceManager, feedKey) => {
  const feedInfo = [
    ...spaceManager.spaces.values()
  ].flatMap((space) => [
    ...space.spaceState.feeds.values()
  ]).find((feed) => feed.key.equals(feedKey));
  log("feeds", {
    feedInfo,
    key: feedKey.truncate(),
    allSpaces: spaceManager.spaces.size
  }, {
    F: __dxlog_file,
    L: 75,
    S: void 0,
    C: (f, a) => f(...a)
  });
  if (!feedInfo) {
    return void 0;
  }
  return {
    identity: feedInfo.assertion.identityKey,
    device: feedInfo.assertion.deviceKey
  };
};
var subscribeToFeedBlocks = ({ feedStore }, { feedKey, maxBlocks = 10 }) => {
  return new Stream(({ next }) => {
    if (!feedKey) {
      return;
    }
    const subscriptions = new SubscriptionList();
    const timeout = setTimeout(async () => {
      const feed = feedStore.getFeed(feedKey);
      if (!feed) {
        return;
      }
      const update = async () => {
        if (!feed.properties.length) {
          next({
            blocks: []
          });
          return;
        }
        const iterator = new FeedIterator(feed);
        await iterator.open();
        const blocks = [];
        for await (const block of iterator) {
          blocks.push(block);
          if (blocks.length >= feed.properties.length) {
            break;
          }
        }
        next({
          blocks: blocks.slice(-maxBlocks)
        });
        await iterator.close();
      };
      feed.on("append", update);
      subscriptions.add(() => feed.off("append", update));
      feed.on("truncate", update);
      subscriptions.add(() => feed.off("truncate", update));
      await update();
    });
    return () => {
      subscriptions.clear();
      clearTimeout(timeout);
    };
  });
};

// packages/sdk/client-services/src/packlets/devtools/network.ts
import { Stream as Stream2 } from "@dxos/codec-protobuf/stream";
import { Context } from "@dxos/context";
import { PublicKey as PublicKey2 } from "@dxos/keys";
var __dxlog_file2 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/devtools/network.ts";
var subscribeToNetworkStatus = ({ signalManager }) => new Stream2(({ next, close }) => {
  const update = () => {
    try {
      const status = signalManager.getStatus?.();
      next({
        servers: status
      });
    } catch (err) {
      close(err);
    }
  };
  signalManager.statusChanged?.on(() => update());
  update();
});
var subscribeToSignal = ({ signalManager }) => new Stream2(({ next }) => {
  const ctx = new Context(void 0, {
    F: __dxlog_file2,
    L: 36
  });
  signalManager.onMessage.on(ctx, (message) => {
    next({
      message: {
        author: PublicKey2.from(message.author.peerKey).asUint8Array(),
        recipient: PublicKey2.from(message.recipient.peerKey).asUint8Array(),
        payload: message.payload
      },
      receivedAt: /* @__PURE__ */ new Date()
    });
  });
  signalManager.swarmEvent.on(ctx, (swarmEvent) => {
    next({
      swarmEvent: swarmEvent.peerAvailable ? {
        peerAvailable: {
          peer: PublicKey2.from(swarmEvent.peerAvailable.peer.peerKey).asUint8Array(),
          since: swarmEvent.peerAvailable.since
        }
      } : {
        peerLeft: {
          peer: PublicKey2.from(swarmEvent.peerLeft.peer.peerKey).asUint8Array()
        }
      },
      topic: swarmEvent.topic.asUint8Array(),
      receivedAt: /* @__PURE__ */ new Date()
    });
  });
  return () => {
    return ctx.dispose();
  };
});
var subscribeToNetworkTopics = ({ networkManager }) => new Stream2(({ next, close }) => {
  const update = () => {
    try {
      const topics = networkManager.topics;
      const labeledTopics = topics.map((topic) => ({
        topic,
        label: networkManager.getSwarm(topic)?.label ?? topic.toHex()
      }));
      next({
        topics: labeledTopics
      });
    } catch (err) {
      close(err);
    }
  };
  networkManager.topicsUpdated.on(update);
  update();
});
var subscribeToSwarmInfo = ({ networkManager }) => new Stream2(({ next }) => {
  const update = () => {
    const info = networkManager.connectionLog?.swarms;
    if (info) {
      next({
        data: info
      });
    }
  };
  networkManager.connectionLog?.update.on(update);
  update();
});
var getNetworkPeers = ({ networkManager }, request) => {
  if (!request.topic) {
    throw new Error("Expected a network topic");
  }
  const map = networkManager.getSwarmMap(PublicKey2.from(request.topic));
  return {
    peers: map?.peers.map((peer) => ({
      ...peer,
      connections: peer.connections.map((connection) => connection.asUint8Array())
    }))
  };
};

// packages/sdk/client-services/src/packlets/devtools/spaces.ts
import { Stream as Stream3 } from "@dxos/codec-protobuf/stream";
var subscribeToSpaces = (context, { spaceKeys = [] }) => {
  return new Stream3(({ next }) => {
    let unsubscribe;
    const update = async () => {
      const spaces = [
        ...context.spaceManager.spaces.values()
      ];
      const filteredSpaces = spaces.filter((space) => !spaceKeys?.length || spaceKeys.some((spaceKey) => spaceKey.equals(space.key)));
      next({
        spaces: filteredSpaces.map((space) => {
          const spaceMetadata = context.metadataStore.spaces.find((spaceMetadata2) => spaceMetadata2.key.equals(space.key));
          return {
            key: space.key,
            isOpen: space.isOpen,
            timeframe: spaceMetadata?.dataTimeframe,
            genesisFeed: space.genesisFeedKey,
            controlFeed: space.controlFeedKey,
            dataFeed: space.dataFeedKey
          };
        })
      });
    };
    const timeout = setTimeout(async () => {
      await context.initialized.wait();
      unsubscribe = context.dataSpaceManager.updated.on(() => update());
      await update();
    });
    return () => {
      unsubscribe?.();
      clearTimeout(timeout);
    };
  });
};

// packages/sdk/client-services/src/packlets/devtools/devtools.ts
import { Event as AsyncEvent } from "@dxos/async";
import { Stream as Stream6 } from "@dxos/codec-protobuf/stream";

// packages/sdk/client-services/src/packlets/devtools/keys.ts
import { scheduleTask } from "@dxos/async";
import { Stream as Stream4 } from "@dxos/codec-protobuf/stream";
var subscribeToKeyringKeys = ({ keyring }) => new Stream4(({ next, ctx }) => {
  const update = async () => {
    next({
      keys: await keyring.list()
    });
  };
  keyring.keysUpdate.on(ctx, update);
  scheduleTask(ctx, update);
});

// packages/sdk/client-services/src/packlets/devtools/metadata.ts
import { Stream as Stream5 } from "@dxos/codec-protobuf/stream";
var subscribeToMetadata = ({ context }) => new Stream5(({ next, ctx }) => {
  context.metadataStore.update.on(ctx, (data) => next({
    metadata: data
  }));
  next({
    metadata: context.metadataStore.metadata
  });
});

// packages/sdk/client-services/src/packlets/devtools/devtools.ts
var DevtoolsHostEvents = class {
  constructor() {
    this.ready = new AsyncEvent();
  }
};
var DevtoolsServiceImpl = class {
  constructor(params) {
    this.params = params;
  }
  events(request) {
    return new Stream6(({ next }) => {
      this.params.events.ready.on(() => {
        next({
          ready: {}
        });
      });
    });
  }
  async getConfig(request) {
    return {
      config: JSON.stringify(this.params.config.values)
    };
  }
  async getStorageInfo() {
    const storageUsage = await this.params.context.storage.getDiskInfo?.() ?? {
      used: 0
    };
    const navigatorInfo = typeof navigator === "object" ? await navigator.storage.estimate() : void 0;
    return {
      type: this.params.context.storage.type,
      storageUsage: storageUsage.used,
      originUsage: navigatorInfo?.usage ?? 0,
      usageQuota: navigatorInfo?.quota ?? 0
    };
  }
  async getBlobs() {
    return {
      blobs: await this.params.context.blobStore.list()
    };
  }
  async getSnapshots() {
    return {
      snapshots: []
    };
  }
  resetStorage(request) {
    throw new Error();
  }
  enableDebugLogging(request) {
    throw new Error();
  }
  disableDebugLogging(request) {
    throw new Error();
  }
  subscribeToKeyringKeys(request) {
    return subscribeToKeyringKeys({
      keyring: this.params.context.keyring
    });
  }
  subscribeToCredentialMessages(request) {
    throw new Error();
  }
  subscribeToSpaces(request) {
    return subscribeToSpaces(this.params.context, request);
  }
  subscribeToItems(request) {
    throw new Error();
  }
  subscribeToFeeds(request) {
    return subscribeToFeeds(this.params.context, request);
  }
  subscribeToFeedBlocks(request) {
    return subscribeToFeedBlocks({
      feedStore: this.params.context.feedStore
    }, request);
  }
  getSpaceSnapshot(request) {
    throw new Error();
  }
  saveSpaceSnapshot(request) {
    throw new Error();
  }
  clearSnapshots(request) {
    throw new Error();
  }
  getNetworkPeers(request) {
    throw new Error();
  }
  subscribeToNetworkTopics(request) {
    throw new Error();
  }
  subscribeToSignalStatus(request) {
    return subscribeToNetworkStatus({
      signalManager: this.params.context.signalManager
    });
  }
  subscribeToSignal() {
    return subscribeToSignal({
      signalManager: this.params.context.signalManager
    });
  }
  subscribeToSwarmInfo() {
    return subscribeToSwarmInfo({
      networkManager: this.params.context.networkManager
    });
  }
  subscribeToMetadata() {
    return subscribeToMetadata({
      context: this.params.context
    });
  }
};

// packages/sdk/client-services/src/packlets/diagnostics/diagnostics.ts
import { asyncTimeout } from "@dxos/async";
import { getFirstStreamValue } from "@dxos/codec-protobuf";
import { createDidFromIdentityKey, credentialTypeFilter } from "@dxos/credentials";
import { invariant } from "@dxos/invariant";
import { STORAGE_VERSION } from "@dxos/protocols";
import { SpaceMember } from "@dxos/protocols/proto/dxos/client/services";
import { TRACE_PROCESSOR } from "@dxos/tracing";

// packages/sdk/client-services/src/version.ts
var DXOS_VERSION = "0.8.3";

// packages/sdk/client-services/src/packlets/services/platform.ts
import { Platform } from "@dxos/protocols/proto/dxos/client/services";
var getPlatform = () => {
  if (process.browser) {
    if (typeof window !== "undefined") {
      const { userAgent } = window.navigator;
      return {
        type: Platform.PLATFORM_TYPE.BROWSER,
        userAgent,
        uptime: Math.floor((Date.now() - window.performance.timeOrigin) / 1e3)
      };
    } else {
      return {
        type: Platform.PLATFORM_TYPE.SHARED_WORKER,
        uptime: Math.floor((Date.now() - performance.timeOrigin) / 1e3)
      };
    }
  } else {
    const { platform: platform2, version, arch } = process;
    return {
      type: Platform.PLATFORM_TYPE.NODE,
      platform: platform2,
      arch,
      runtime: version,
      uptime: Math.floor(process.uptime()),
      memory: process.memoryUsage()
    };
  }
};

// packages/sdk/client-services/src/packlets/diagnostics/diagnostics.ts
var __dxlog_file3 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/diagnostics/diagnostics.ts";
var DEFAULT_TIMEOUT = 1e3;
var createDiagnostics = async (clientServices, serviceContext, config) => {
  const diagnostics = {
    created: (/* @__PURE__ */ new Date()).toISOString(),
    platform: getPlatform(),
    client: {
      version: DXOS_VERSION,
      storage: {
        version: STORAGE_VERSION
      }
    },
    trace: TRACE_PROCESSOR.getDiagnostics()
  };
  await Promise.all([
    (async () => {
      invariant(clientServices.LoggingService, "SystemService is not available.", {
        F: __dxlog_file3,
        L: 110,
        S: void 0,
        A: [
          "clientServices.LoggingService",
          "'SystemService is not available.'"
        ]
      });
      diagnostics.metrics = await getFirstStreamValue(clientServices.LoggingService.queryMetrics({}), {
        timeout: DEFAULT_TIMEOUT
      }).catch(() => void 0);
    })(),
    (async () => {
      diagnostics.storage = await asyncTimeout(getStorageDiagnostics(), DEFAULT_TIMEOUT).catch(() => void 0);
    })(),
    async () => {
      const identity = serviceContext.identityManager.identity;
      if (identity) {
        diagnostics.identity = {
          did: identity.did,
          identityKey: identity.identityKey,
          spaceKey: identity.space.key,
          profile: identity.profileDocument
        };
        const { devices } = await getFirstStreamValue(clientServices.DevicesService.queryDevices(), {
          timeout: DEFAULT_TIMEOUT
        }).catch(() => void 0) ?? {};
        diagnostics.devices = devices;
        if (serviceContext.dataSpaceManager) {
          diagnostics.spaces = await Promise.all(Array.from(serviceContext.dataSpaceManager.spaces.values()).map((space) => getSpaceStats(space)) ?? []);
        }
        const { feeds = [] } = await getFirstStreamValue(clientServices.DevtoolsHost.subscribeToFeeds({}), {
          timeout: DEFAULT_TIMEOUT
        }).catch(() => void 0) ?? {};
        diagnostics.feeds = feeds.map(({ feedKey, bytes, length }) => ({
          feedKey,
          bytes,
          length
        }));
        const status = await getFirstStreamValue(clientServices.NetworkService.queryStatus(), {
          timeout: DEFAULT_TIMEOUT
        }).catch(() => void 0);
        diagnostics.networkStatus = status;
        diagnostics.swarms = serviceContext.networkManager.connectionLog?.swarms;
      }
    }
  ]);
  diagnostics.config = config.values;
  return diagnostics;
};
var getSpaceStats = async (space) => {
  const stats = {
    key: space.key,
    metrics: space.metrics,
    epochs: space.inner.spaceState.credentials.filter(credentialTypeFilter("dxos.halo.credentials.Epoch")).map((credential) => ({
      ...credential.subject.assertion,
      id: credential.id
    })),
    members: await Promise.all(Array.from(space.inner.spaceState.members.values()).map(async (member) => ({
      role: member.role,
      identity: {
        did: await createDidFromIdentityKey(member.key),
        identityKey: member.key,
        profile: {
          displayName: member.assertion.profile?.displayName
        }
      },
      presence: space.presence.getPeersOnline().filter(({ identityKey }) => identityKey.equals(member.key)).length > 0 ? SpaceMember.PresenceState.ONLINE : SpaceMember.PresenceState.OFFLINE
    }))),
    pipeline: {
      // TODO(burdon): Pick properties from credentials if needed.
      currentEpoch: space.automergeSpaceState.lastEpoch,
      appliedEpoch: space.automergeSpaceState.lastEpoch,
      controlFeeds: space.inner.controlPipeline.state.feeds.map((feed) => feed.key),
      currentControlTimeframe: space.inner.controlPipeline.state.timeframe,
      targetControlTimeframe: space.inner.controlPipeline.state.targetTimeframe,
      totalControlTimeframe: space.inner.controlPipeline.state.endTimeframe
    }
  };
  if (stats.metrics) {
    const { open, ready } = stats.metrics;
    stats.metrics.startupTime = open && ready && ready.getTime() - open.getTime();
  }
  return stats;
};
var getStorageDiagnostics = async () => {
  if (typeof navigator === "undefined" || !navigator.storage) {
    return void 0;
  }
  const map = /* @__PURE__ */ new Map();
  const dir = await navigator.storage.getDirectory();
  for await (const filename of dir?.keys()) {
    const idx = filename.indexOf("-", filename.indexOf("-") + 1);
    if (idx === -1) {
      continue;
    }
    map.set(filename.slice(0, idx), (map.get(filename.slice(0, idx)) ?? 0) + 1);
  }
  return Array.from(map.entries()).sort((a, b) => b[1] - a[1]).map(([file, count]) => ({
    file,
    count
  }));
};

// packages/sdk/client-services/src/packlets/diagnostics/browser-diagnostics-broadcast.ts
import { Trigger } from "@dxos/async";
import { log as log2 } from "@dxos/log";
var __dxlog_file4 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/diagnostics/browser-diagnostics-broadcast.ts";
var CHANNEL_NAME = "dxos.diagnostics.broadcast";
var createCollectDiagnosticsBroadcastSender = () => {
  return {
    broadcastDiagnosticsRequest: async () => {
      let expectedResponse = "probe-ack";
      let channel;
      try {
        const trigger = new Trigger();
        channel = new BroadcastChannel(CHANNEL_NAME);
        channel.onmessage = (msg) => {
          if (expectedResponse === msg.data.type) {
            trigger.wake(msg.data);
          }
        };
        channel.postMessage({
          type: "probe"
        });
        await trigger.wait({
          timeout: 200
        });
        expectedResponse = "receive-diagnostics";
        trigger.reset();
        channel.postMessage({
          type: "request-diagnostics"
        });
        const diagnostics = await trigger.wait({
          timeout: 5e3
        });
        return diagnostics.payload;
      } catch (e) {
        const errorDescription = e instanceof Error ? e.message : JSON.stringify(e);
        return {
          expectedResponse,
          errorDescription
        };
      } finally {
        safeClose(channel);
      }
    }
  };
};
var createCollectDiagnosticsBroadcastHandler = (systemService) => {
  let channel;
  return {
    start: () => {
      channel = new BroadcastChannel(CHANNEL_NAME);
      channel.onmessage = async (message) => {
        try {
          if (message.data.type === "probe") {
            channel?.postMessage({
              type: "probe-ack"
            });
          } else if (message.data.type === "request-diagnostics") {
            const diagnostics = await systemService.getDiagnostics({});
            channel?.postMessage({
              type: "receive-diagnostics",
              payload: diagnostics
            });
          }
        } catch (error) {
          log2.catch(error, void 0, {
            F: __dxlog_file4,
            L: 77,
            S: void 0,
            C: (f, a) => f(...a)
          });
        }
      };
    },
    stop: () => {
      safeClose(channel);
      channel = void 0;
    }
  };
};
var safeClose = (channel) => {
  try {
    channel?.close();
  } catch (e) {
  }
};

// packages/sdk/client-services/src/packlets/diagnostics/diagnostics-collector.ts
import { ClientServicesProviderResource } from "@dxos/client-protocol";
import { ConfigResource } from "@dxos/config";
import { GetDiagnosticsRequest } from "@dxos/protocols/proto/dxos/client/services";
import { TRACE_PROCESSOR as TRACE_PROCESSOR2 } from "@dxos/tracing";
import { jsonKeyReplacer, isNonNullable } from "@dxos/util";
var GET_DIAGNOSTICS_RPC_TIMEOUT = 1e4;
var DiagnosticsCollector = class {
  static {
    this.broadcastSender = createCollectDiagnosticsBroadcastSender();
  }
  static async collect(config = findConfigs(), services = findSystemServiceProvider(), options = {}) {
    const serviceDiagnostics = await services?.services?.SystemService?.getDiagnostics({
      keys: options.humanize ? GetDiagnosticsRequest.KEY_OPTION.HUMANIZE : options.truncate ? GetDiagnosticsRequest.KEY_OPTION.TRUNCATE : void 0
    }, {
      timeout: GET_DIAGNOSTICS_RPC_TIMEOUT
    });
    const clientDiagnostics = {
      config,
      trace: TRACE_PROCESSOR2.getDiagnostics()
    };
    const diagnostics = serviceDiagnostics != null ? {
      client: clientDiagnostics,
      services: serviceDiagnostics
    } : {
      client: clientDiagnostics,
      broadcast: await this.broadcastSender.broadcastDiagnosticsRequest()
    };
    return JSON.parse(JSON.stringify(diagnostics, jsonKeyReplacer(options)));
  }
};
var findSystemServiceProvider = () => {
  const serviceProviders = TRACE_PROCESSOR2.findResourcesByAnnotation(ClientServicesProviderResource);
  const providerResource = serviceProviders.find((r) => r.instance.deref()?.services?.SystemService != null);
  return providerResource?.instance?.deref() ?? null;
};
var findConfigs = () => {
  const configs = TRACE_PROCESSOR2.findResourcesByAnnotation(ConfigResource);
  return configs.map((r) => r.instance.deref()).filter(isNonNullable);
};

// packages/sdk/client-services/src/packlets/identity/authenticator.ts
import { Trigger as Trigger2 } from "@dxos/async";
import { Context as Context2 } from "@dxos/context";
import { verifyCredential } from "@dxos/credentials";
import { log as log3 } from "@dxos/log";
import { schema } from "@dxos/protocols/proto";
var __dxlog_file5 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/identity/authenticator.ts";
var Credential = schema.getCodecForType("dxos.halo.credentials.Credential");
var createAuthProvider = (signer) => async (nonce) => {
  const credential = await signer.createCredential({
    assertion: {
      "@type": "dxos.halo.credentials.Auth"
    },
    subject: signer.getIssuer(),
    nonce
  });
  return Credential.encode(credential);
};
var TrustedKeySetAuthVerifier = class {
  constructor(_params) {
    this._params = _params;
    this._ctx = new Context2(void 0, {
      F: __dxlog_file5,
      L: 45
    });
  }
  async close() {
    await this._ctx.dispose();
  }
  get verifier() {
    return async (nonce, auth) => {
      const credential = Credential.decode(auth);
      log3("authenticating...", {
        credential
      }, {
        F: __dxlog_file5,
        L: 56,
        S: this,
        C: (f, a) => f(...a)
      });
      const result = await verifyCredential(credential);
      if (result.kind === "fail") {
        log3("Invalid credential", {
          result
        }, {
          F: __dxlog_file5,
          L: 60,
          S: this,
          C: (f, a) => f(...a)
        });
        return false;
      }
      if (!credential.proof.nonce || !Buffer.from(nonce).equals(credential.proof.nonce)) {
        log3("Invalid nonce", {
          nonce,
          credential
        }, {
          F: __dxlog_file5,
          L: 65,
          S: this,
          C: (f, a) => f(...a)
        });
        return false;
      }
      if (this._isTrustedKey(credential.issuer)) {
        log3("key is trusted -- auth success", {
          key: credential.issuer
        }, {
          F: __dxlog_file5,
          L: 70,
          S: this,
          C: (f, a) => f(...a)
        });
        return true;
      }
      const trigger = new Trigger2();
      this._ctx.onDispose(() => {
        trigger.wake(false);
      });
      const clear = this._params.update.on(this._ctx, () => {
        if (this._isTrustedKey(credential.issuer)) {
          log3("auth success", {
            key: credential.issuer
          }, {
            F: __dxlog_file5,
            L: 81,
            S: this,
            C: (f, a) => f(...a)
          });
          trigger.wake(true);
        } else {
          log3("key is not currently in trusted set, waiting...", {
            key: credential.issuer,
            trusted: [
              ...this._params.trustedKeysProvider()
            ]
          }, {
            F: __dxlog_file5,
            L: 84,
            S: this,
            C: (f, a) => f(...a)
          });
        }
      });
      try {
        return await trigger.wait({
          timeout: this._params.authTimeout
        });
      } catch {
        return false;
      } finally {
        clear();
      }
    };
  }
  _isTrustedKey(deviceKey) {
    const deviceSet = this._params.trustedKeysProvider();
    return deviceSet.has(deviceKey);
  }
};

// packages/sdk/client-services/src/packlets/spaces/edge-feed-replicator.ts
import { decode as decodeCbor, encode as encodeCbor } from "cbor-x";
import { Event, Mutex, scheduleMicroTask } from "@dxos/async";
import { Context as Context3, Resource } from "@dxos/context";
import { EdgeConnectionClosedError, EdgeIdentityChangedError } from "@dxos/edge-client";
import { invariant as invariant2 } from "@dxos/invariant";
import { PublicKey as PublicKey3 } from "@dxos/keys";
import { log as log4, logInfo } from "@dxos/log";
import { EdgeService } from "@dxos/protocols";
import { buf } from "@dxos/protocols/buf";
import { MessageSchema as RouterMessageSchema } from "@dxos/protocols/buf/dxos/edge/messenger_pb";
import { EdgeStatus } from "@dxos/protocols/proto/dxos/client/services";
import { ComplexMap as ComplexMap2, arrayToBuffer, bufferToArray, defaultMap, rangeFromTo } from "@dxos/util";
function _ts_decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function _ts_add_disposable_resource(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = function() {
      try {
        inner.call(this);
      } catch (e) {
        return Promise.reject(e);
      }
    };
    env.stack.push({
      value,
      dispose,
      async
    });
  } else if (async) {
    env.stack.push({
      async: true
    });
  }
  return value;
}
function _ts_dispose_resources(env) {
  var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  };
  return (_ts_dispose_resources = function _ts_dispose_resources5(env2) {
    function fail(e) {
      env2.error = env2.hasError ? new _SuppressedError(e, env2.error, "An error was suppressed during disposal.") : e;
      env2.hasError = true;
    }
    var r, s = 0;
    function next() {
      while (r = env2.stack.pop()) {
        try {
          if (!r.async && s === 1) return s = 0, env2.stack.push(r), Promise.resolve().then(next);
          if (r.dispose) {
            var result = r.dispose.call(r.value);
            if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
              fail(e);
              return next();
            });
          } else s |= 1;
        } catch (e) {
          fail(e);
        }
      }
      if (s === 1) return env2.hasError ? Promise.reject(env2.error) : Promise.resolve();
      if (env2.hasError) throw env2.error;
    }
    return next();
  })(env);
}
var __dxlog_file6 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/spaces/edge-feed-replicator.ts";
var EdgeFeedReplicator = class extends Resource {
  constructor({ messenger, spaceId }) {
    super();
    this._feeds = new ComplexMap2(PublicKey3.hash);
    this._connectionCtx = void 0;
    this._connected = false;
    /**
    * Feed length at service.
    */
    this._remoteLength = new ComplexMap2(PublicKey3.hash);
    /**
    * Protects against concurrent pushes so that remote length is updated consistently.
    */
    this._pushMutex = new ComplexMap2(PublicKey3.hash);
    this._messenger = messenger;
    this._spaceId = spaceId;
  }
  async _open() {
    log4("open", void 0, {
      F: __dxlog_file6,
      L: 57,
      S: this,
      C: (f, a) => f(...a)
    });
    this._ctx.onDispose(this._messenger.onMessage((message) => {
      if (!message.serviceId) {
        return;
      }
      const [service, ...rest] = message.serviceId.split(":");
      if (service !== EdgeService.FEED_REPLICATOR) {
        return;
      }
      const [spaceId] = rest;
      if (spaceId !== this._spaceId) {
        log4("spaceID mismatch", {
          spaceId,
          _spaceId: this._spaceId
        }, {
          F: __dxlog_file6,
          L: 71,
          S: this,
          C: (f, a) => f(...a)
        });
        return;
      }
      const payload = decodeCbor(message.payload.value);
      log4("receive", {
        from: message.source,
        feedKey: payload.feedKey,
        type: payload.type
      }, {
        F: __dxlog_file6,
        L: 76,
        S: this,
        C: (f, a) => f(...a)
      });
      this._onMessage(payload);
    }));
    this._ctx.onDispose(this._messenger.onReconnected(() => {
      scheduleMicroTask(this._ctx, () => this._handleReconnect());
    }));
  }
  async _handleReconnect() {
    await this._resetConnection();
    if (this._messenger.status === EdgeStatus.CONNECTED) {
      this._startReplication();
    }
  }
  async _close() {
    log4("close", void 0, {
      F: __dxlog_file6,
      L: 96,
      S: this,
      C: (f, a) => f(...a)
    });
    await this._resetConnection();
  }
  _startReplication() {
    this._connected = true;
    const connectionCtx = this._createConnectionContext();
    this._connectionCtx = connectionCtx;
    log4("connection context created", void 0, {
      F: __dxlog_file6,
      L: 104,
      S: this,
      C: (f, a) => f(...a)
    });
    scheduleMicroTask(connectionCtx, async () => {
      for (const feed of this._feeds.values()) {
        await this._replicateFeed(connectionCtx, feed);
      }
    });
  }
  async _resetConnection() {
    log4("resetConnection", void 0, {
      F: __dxlog_file6,
      L: 113,
      S: this,
      C: (f, a) => f(...a)
    });
    this._connected = false;
    await this._connectionCtx?.dispose();
    this._connectionCtx = void 0;
    this._remoteLength.clear();
  }
  async addFeed(feed) {
    log4("addFeed", {
      key: feed.key,
      connected: this._connected,
      hasConnectionCtx: !!this._connectionCtx
    }, {
      F: __dxlog_file6,
      L: 121,
      S: this,
      C: (f, a) => f(...a)
    });
    this._feeds.set(feed.key, feed);
    if (this._connected && this._connectionCtx) {
      await this._replicateFeed(this._connectionCtx, feed);
    }
  }
  _getPushMutex(key) {
    return defaultMap(this._pushMutex, key, () => new Mutex());
  }
  async _replicateFeed(ctx, feed) {
    log4("replicateFeed", {
      key: feed.key
    }, {
      F: __dxlog_file6,
      L: 134,
      S: this,
      C: (f, a) => f(...a)
    });
    await this._sendMessage({
      type: "get-metadata",
      feedKey: feed.key.toHex()
    });
    Event.wrap(feed.core, "append").on(ctx, async () => {
      await this._pushBlocksIfNeeded(feed);
    });
  }
  async _sendMessage(message) {
    if (!this._connectionCtx) {
      log4("message dropped because connection was disposed", void 0, {
        F: __dxlog_file6,
        L: 147,
        S: this,
        C: (f, a) => f(...a)
      });
      return;
    }
    if (message.type === "data") {
      log4("sending blocks", {
        feedKey: message.feedKey,
        blocks: message.blocks.map((b) => b.index)
      }, {
        F: __dxlog_file6,
        L: 152,
        S: this,
        C: (f, a) => f(...a)
      });
    }
    invariant2(message.feedKey, void 0, {
      F: __dxlog_file6,
      L: 158,
      S: this,
      A: [
        "message.feedKey",
        ""
      ]
    });
    const payloadValue = bufferToArray(encodeCbor(message));
    log4("send", {
      type: message.type
    }, {
      F: __dxlog_file6,
      L: 161,
      S: this,
      C: (f, a) => f(...a)
    });
    await this._messenger.send(buf.create(RouterMessageSchema, {
      source: {
        identityKey: this._messenger.identityKey,
        peerKey: this._messenger.peerKey
      },
      serviceId: `${EdgeService.FEED_REPLICATOR}:${this._spaceId}`,
      payload: {
        value: payloadValue
      }
    }));
  }
  _onMessage(message) {
    if (!this._connectionCtx) {
      log4.warn("received message after connection context was disposed", void 0, {
        F: __dxlog_file6,
        L: 176,
        S: this,
        C: (f, a) => f(...a)
      });
      return;
    }
    scheduleMicroTask(this._connectionCtx, async () => {
      switch (message.type) {
        case "metadata": {
          const env = {
            stack: [],
            error: void 0,
            hasError: false
          };
          try {
            const feedKey = PublicKey3.fromHex(message.feedKey);
            const feed = this._feeds.get(feedKey);
            if (!feed) {
              log4.warn("Feed not found", {
                feedKey
              }, {
                F: __dxlog_file6,
                L: 185,
                S: this,
                C: (f, a) => f(...a)
              });
              return;
            }
            const _guard = _ts_add_disposable_resource(env, await this._getPushMutex(feed.key).acquire(), false);
            this._remoteLength.set(feedKey, message.length);
            const logMeta = {
              localLength: feed.length,
              remoteLength: message.length,
              feedKey
            };
            if (message.length > feed.length) {
              log4("requesting missing blocks", logMeta, {
                F: __dxlog_file6,
                L: 195,
                S: this,
                C: (f, a) => f(...a)
              });
              await this._sendMessage({
                type: "request",
                feedKey: feedKey.toHex(),
                range: {
                  from: feed.length,
                  to: message.length
                }
              });
            } else if (message.length < feed.length) {
              log4("pushing blocks to remote", logMeta, {
                F: __dxlog_file6,
                L: 203,
                S: this,
                C: (f, a) => f(...a)
              });
              await this._pushBlocks(feed, message.length, feed.length);
            }
            break;
          } catch (e) {
            env.error = e;
            env.hasError = true;
          } finally {
            _ts_dispose_resources(env);
          }
        }
        case "data": {
          log4("received data", {
            feed: message.feedKey,
            blocks: message.blocks.map((b) => b.index)
          }, {
            F: __dxlog_file6,
            L: 212,
            S: this,
            C: (f, a) => f(...a)
          });
          const feedKey = PublicKey3.fromHex(message.feedKey);
          const feed = this._feeds.get(feedKey);
          if (!feed) {
            log4.warn("Feed not found", {
              feedKey
            }, {
              F: __dxlog_file6,
              L: 217,
              S: this,
              C: (f, a) => f(...a)
            });
            return;
          }
          await this._integrateBlocks(feed, message.blocks);
          break;
        }
        default: {
          log4.warn("Unknown message", {
            ...message
          }, {
            F: __dxlog_file6,
            L: 226,
            S: this,
            C: (f, a) => f(...a)
          });
        }
      }
    });
  }
  async _pushBlocks(feed, from, to) {
    log4("pushing blocks", {
      feed: feed.key.toHex(),
      from,
      to
    }, {
      F: __dxlog_file6,
      L: 233,
      S: this,
      C: (f, a) => f(...a)
    });
    const blocks = await Promise.all(rangeFromTo(from, to).map(async (index) => {
      const data = await feed.get(index, {
        valueEncoding: "binary"
      });
      invariant2(data instanceof Uint8Array, void 0, {
        F: __dxlog_file6,
        L: 238,
        S: this,
        A: [
          "data instanceof Uint8Array",
          ""
        ]
      });
      const proof = await feed.proof(index);
      return {
        index,
        data,
        nodes: proof.nodes,
        signature: proof.signature
      };
    }));
    await this._sendMessage({
      type: "data",
      feedKey: feed.key.toHex(),
      blocks
    });
    this._remoteLength.set(feed.key, to);
  }
  async _integrateBlocks(feed, blocks) {
    log4("integrating blocks", {
      feed: feed.key.toHex(),
      blocks: blocks.length
    }, {
      F: __dxlog_file6,
      L: 259,
      S: this,
      C: (f, a) => f(...a)
    });
    for (const block of blocks) {
      if (feed.has(block.index)) {
        continue;
      }
      const blockBuffer = bufferizeBlock(block);
      await feed.putBuffer(block.index, blockBuffer.data, {
        nodes: blockBuffer.nodes,
        signature: blockBuffer.signature
      }, null);
    }
  }
  async _pushBlocksIfNeeded(feed) {
    const env = {
      stack: [],
      error: void 0,
      hasError: false
    };
    try {
      const _ = _ts_add_disposable_resource(env, await this._getPushMutex(feed.key).acquire(), false);
      if (!this._remoteLength.has(feed.key)) {
        log4("blocks not pushed because remote length is unknown", void 0, {
          F: __dxlog_file6,
          L: 280,
          S: this,
          C: (f, a) => f(...a)
        });
        return;
      }
      const remoteLength = this._remoteLength.get(feed.key);
      if (remoteLength < feed.length) {
        await this._pushBlocks(feed, remoteLength, feed.length);
      }
    } catch (e) {
      env.error = e;
      env.hasError = true;
    } finally {
      _ts_dispose_resources(env);
    }
  }
  _createConnectionContext() {
    const connectionCtx = new Context3({
      onError: async (err) => {
        if (connectionCtx !== this._connectionCtx) {
          return;
        }
        if (err instanceof EdgeIdentityChangedError || err instanceof EdgeConnectionClosedError) {
          log4("resetting on reconnect", void 0, {
            F: __dxlog_file6,
            L: 297,
            S: this,
            C: (f, a) => f(...a)
          });
          await this._resetConnection();
        } else {
          this._ctx.raise(err);
        }
      }
    }, {
      F: __dxlog_file6,
      L: 291
    });
    return connectionCtx;
  }
};
_ts_decorate([
  logInfo
], EdgeFeedReplicator.prototype, "_spaceId", void 0);
var bufferizeBlock = (block) => ({
  index: block.index,
  data: arrayToBuffer(block.data),
  nodes: block.nodes.map((node) => ({
    index: node.index,
    hash: arrayToBuffer(node.hash),
    size: node.size
  })),
  signature: arrayToBuffer(block.signature)
});

// packages/sdk/client-services/src/packlets/spaces/data-space.ts
import { save } from "@automerge/automerge";
import { Event as Event7, Mutex as Mutex2, scheduleTask as scheduleTask4, sleep as sleep3, synchronized as synchronized2, trackLeaks as trackLeaks2 } from "@dxos/async";
import { AUTH_TIMEOUT as AUTH_TIMEOUT2 } from "@dxos/client-protocol";
import { Context as Context6, ContextDisposedError, cancelWithContext as cancelWithContext2 } from "@dxos/context";
import { timed, warnAfterTimeout } from "@dxos/debug";
import { createMappedFeedWriter, FIND_PARAMS as FIND_PARAMS2 } from "@dxos/echo-pipeline";
import { SpaceDocVersion as SpaceDocVersion2 } from "@dxos/echo-protocol";
import { failedInvariant as failedInvariant3, invariant as invariant11 } from "@dxos/invariant";
import { PublicKey as PublicKey8 } from "@dxos/keys";
import { log as log13 } from "@dxos/log";
import { CancelledError, SystemError } from "@dxos/protocols";
import { SpaceState as SpaceState4 } from "@dxos/protocols/proto/dxos/client/services";
import { AdmittedFeed as AdmittedFeed4, SpaceMember as SpaceMember5 } from "@dxos/protocols/proto/dxos/halo/credentials";
import { Timeframe as Timeframe4 } from "@dxos/timeframe";
import { trace as trace5 } from "@dxos/tracing";
import { CallbackCollection, ComplexSet as ComplexSet3 } from "@dxos/util";

// packages/sdk/client-services/src/packlets/spaces/automerge-space-state.ts
import { Event as Event2 } from "@dxos/async";
import { Resource as Resource2 } from "@dxos/context";
import { checkCredentialType } from "@dxos/credentials";
var AutomergeSpaceState = class extends Resource2 {
  constructor(_onNewRoot) {
    super(), this._onNewRoot = _onNewRoot, this.rootUrl = void 0, this.lastEpoch = void 0, this.onNewEpoch = new Event2(), this._isProcessingRootDocs = false;
  }
  async _open(ctx) {
  }
  async _close(ctx) {
    this._isProcessingRootDocs = false;
  }
  async processCredential(credential) {
    if (!checkCredentialType(credential, "dxos.halo.credentials.Epoch")) {
      return;
    }
    this.lastEpoch = credential;
    if (credential.subject.assertion.automergeRoot) {
      this.rootUrl = credential.subject.assertion.automergeRoot;
      if (this._isProcessingRootDocs) {
        this._onNewRoot(this.rootUrl);
      }
    }
    this.onNewEpoch.emit(credential);
  }
  startProcessingRootDocs() {
    if (this._isProcessingRootDocs) {
      return;
    }
    if (this.rootUrl) {
      this._onNewRoot(this.rootUrl);
    }
    this._isProcessingRootDocs = true;
  }
  async ensureEpochInitialized() {
    await this.onNewEpoch.waitForCondition(() => !!this.lastEpoch);
  }
};

// packages/sdk/client-services/src/packlets/spaces/epoch-migrations.ts
import { invariant as invariant3 } from "@dxos/invariant";
import { CreateEpochRequest } from "@dxos/protocols/proto/dxos/client/services";
var __dxlog_file7 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/spaces/epoch-migrations.ts";
var LOAD_DOC_TIMEOUT = 1e4;
var runEpochMigration = async (ctx, context) => {
  switch (context.migration) {
    case CreateEpochRequest.Migration.INIT_AUTOMERGE: {
      const document = context.echoHost.createDoc();
      await context.echoHost.flush();
      return {
        newRoot: document.url
      };
    }
    case CreateEpochRequest.Migration.PRUNE_AUTOMERGE_ROOT_HISTORY: {
      if (!context.currentRoot) {
        throw new Error("Space does not have an automerge root");
      }
      const rootHandle = await context.echoHost.loadDoc(ctx, context.currentRoot, {
        timeout: LOAD_DOC_TIMEOUT
      });
      const newRoot = context.echoHost.createDoc(rootHandle.doc());
      await context.echoHost.flush();
      return {
        newRoot: newRoot.url
      };
    }
    case CreateEpochRequest.Migration.FRAGMENT_AUTOMERGE_ROOT: {
      throw new Error("Migration not available");
    }
    case CreateEpochRequest.Migration.MIGRATE_REFERENCES_TO_DXN: {
      throw new Error("Migration not available");
    }
    // TODO(dmaretskyi): This path doesn't seem to fit here. This is not a migration.
    case CreateEpochRequest.Migration.REPLACE_AUTOMERGE_ROOT: {
      invariant3(context.newAutomergeRoot, void 0, {
        F: __dxlog_file7,
        L: 63,
        S: void 0,
        A: [
          "context.newAutomergeRoot",
          ""
        ]
      });
      await context.echoHost.flush();
      return {
        newRoot: context.newAutomergeRoot
      };
    }
  }
  return {};
};

// packages/sdk/client-services/src/packlets/spaces/notarization-plugin.ts
import { DeferredTask, Event as Event3, scheduleTask as scheduleTask2, sleep, TimeoutError, Trigger as Trigger3, scheduleMicroTask as scheduleMicroTask2 } from "@dxos/async";
import { rejectOnDispose, Resource as Resource3 } from "@dxos/context";
import { verifyCredential as verifyCredential2 } from "@dxos/credentials";
import { invariant as invariant4 } from "@dxos/invariant";
import { PublicKey as PublicKey4 } from "@dxos/keys";
import { logInfo as logInfo2, log as log5 } from "@dxos/log";
import { EdgeCallFailedError } from "@dxos/protocols";
import { schema as schema2 } from "@dxos/protocols/proto";
import { RpcExtension } from "@dxos/teleport";
import { ComplexMap as ComplexMap3, ComplexSet, entry } from "@dxos/util";
function _ts_decorate2(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file8 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/spaces/notarization-plugin.ts";
var DEFAULT_RETRY_TIMEOUT = 1e3;
var DEFAULT_SUCCESS_DELAY = 1e3;
var DEFAULT_NOTARIZE_TIMEOUT = 1e4;
var DEFAULT_ACTIVE_EDGE_POLLING_INTERVAL = 3e3;
var MAX_EDGE_RETRIES = 2;
var WRITER_NOT_SET_ERROR_CODE = "WRITER_NOT_SET";
var credentialCodec = schema2.getCodecForType("dxos.halo.credentials.Credential");
var NotarizationPlugin = class extends Resource3 {
  constructor(params) {
    super();
    this._extensionOpened = new Event3();
    this._extensions = /* @__PURE__ */ new Set();
    this._processedCredentials = new ComplexSet(PublicKey4.hash);
    this._processCredentialsTriggers = new ComplexMap3(PublicKey4.hash);
    this._activeEdgePollingIntervalHandle = void 0;
    this._activeEdgePollingEnabled = false;
    this._spaceId = params.spaceId;
    this._activeEdgePollingInterval = params.activeEdgePollingInterval ?? DEFAULT_ACTIVE_EDGE_POLLING_INTERVAL;
    if (params.edgeClient && params.edgeFeatures?.feedReplicator) {
      this._edgeClient = params.edgeClient;
    }
  }
  setActiveEdgePollingEnabled(enabled) {
    const client = this._edgeClient;
    invariant4(client, void 0, {
      F: __dxlog_file8,
      L: 111,
      S: this,
      A: [
        "client",
        ""
      ]
    });
    this._activeEdgePollingEnabled = enabled;
    if (this.isOpen) {
      if (enabled && !this._activeEdgePollingIntervalHandle) {
        this._startPeriodicEdgePolling(client);
      } else if (!enabled && this._activeEdgePollingIntervalHandle) {
        this._stopPeriodicEdgePolling();
      }
    }
  }
  get hasWriter() {
    return !!this._writer;
  }
  async _open() {
    if (this._edgeClient) {
      if (this._activeEdgePollingEnabled) {
        this._startPeriodicEdgePolling(this._edgeClient);
      }
      if (this._writer) {
        this._notarizePendingEdgeCredentials(this._edgeClient, this._writer);
      }
    }
  }
  async _close() {
    this._stopPeriodicEdgePolling();
    await this._ctx.dispose();
  }
  /**
  * Request credentials to be notarized.
  */
  async notarize({ ctx: opCtx, credentials, timeout = DEFAULT_NOTARIZE_TIMEOUT, retryTimeout = DEFAULT_RETRY_TIMEOUT, successDelay = DEFAULT_SUCCESS_DELAY, edgeRetryJitter }) {
    log5("notarize", {
      credentials
    }, {
      F: __dxlog_file8,
      L: 153,
      S: this,
      C: (f, a) => f(...a)
    });
    invariant4(credentials.every((credential) => credential.id), "Credentials must have an id", {
      F: __dxlog_file8,
      L: 154,
      S: this,
      A: [
        "credentials.every((credential) => credential.id)",
        "'Credentials must have an id'"
      ]
    });
    const errors = new Trigger3();
    const ctx = this._ctx.derive({
      onError: (err) => {
        log5.warn("Notarization error", {
          err
        }, {
          F: __dxlog_file8,
          L: 162,
          S: this,
          C: (f, a) => f(...a)
        });
        void ctx.dispose();
        errors.throw(err);
      }
    });
    opCtx?.onDispose(() => ctx.dispose());
    if (timeout !== 0) {
      this._scheduleTimeout(ctx, errors, timeout);
    }
    const allNotarized = Promise.all(credentials.map((credential) => this._waitUntilProcessed(credential.id)));
    this._tryNotarizeCredentialsWithPeers(ctx, credentials, {
      retryTimeout,
      successDelay
    });
    if (this._edgeClient) {
      this._tryNotarizeCredentialsWithEdge(ctx, this._edgeClient, credentials, {
        retryTimeout,
        successDelay,
        jitter: edgeRetryJitter
      });
    }
    try {
      await Promise.race([
        rejectOnDispose(ctx),
        allNotarized,
        errors.wait()
      ]);
      log5("done", void 0, {
        F: __dxlog_file8,
        L: 187,
        S: this,
        C: (f, a) => f(...a)
      });
    } finally {
      await ctx.dispose();
    }
  }
  _tryNotarizeCredentialsWithPeers(ctx, credentials, { retryTimeout, successDelay }) {
    const peersTried = /* @__PURE__ */ new Set();
    const notarizeTask = new DeferredTask(ctx, async () => {
      try {
        if (this._extensions.size === 0) {
          return;
        }
        const peer = [
          ...this._extensions
        ].find((peer2) => !peersTried.has(peer2));
        if (!peer) {
          log5.info("Exhausted all peers to notarize with", {
            retryIn: retryTimeout
          }, {
            F: __dxlog_file8,
            L: 210,
            S: this,
            C: (f, a) => f(...a)
          });
          peersTried.clear();
          scheduleTask2(ctx, () => notarizeTask.schedule(), retryTimeout);
          return;
        }
        peersTried.add(peer);
        log5("try notarizing", {
          peer: peer.localPeerId,
          credentialId: credentials.map((credential) => credential.id)
        }, {
          F: __dxlog_file8,
          L: 217,
          S: this,
          C: (f, a) => f(...a)
        });
        await peer.rpc.NotarizationService.notarize({
          credentials: credentials.filter((credential) => !this._processedCredentials.has(credential.id))
        });
        log5("success", void 0, {
          F: __dxlog_file8,
          L: 221,
          S: this,
          C: (f, a) => f(...a)
        });
        await sleep(successDelay);
      } catch (err) {
        if (!ctx.disposed && !err.message.includes(WRITER_NOT_SET_ERROR_CODE)) {
          log5.info("error notarizing (recoverable)", err, {
            F: __dxlog_file8,
            L: 226,
            S: this,
            C: (f, a) => f(...a)
          });
        }
        notarizeTask.schedule();
      }
    });
    notarizeTask.schedule();
    this._extensionOpened.on(ctx, () => notarizeTask.schedule());
  }
  _tryNotarizeCredentialsWithEdge(ctx, client, credentials, timeouts) {
    const encodedCredentials = credentials.map((credential) => {
      const binary = credentialCodec.encode(credential);
      return Buffer.from(binary).toString("base64");
    });
    scheduleTask2(ctx, async () => {
      try {
        await client.notarizeCredentials(this._spaceId, {
          credentials: encodedCredentials
        }, {
          retry: {
            count: MAX_EDGE_RETRIES,
            timeout: timeouts.retryTimeout,
            jitter: timeouts.jitter
          }
        });
        log5("edge notarization success", void 0, {
          F: __dxlog_file8,
          L: 254,
          S: this,
          C: (f, a) => f(...a)
        });
      } catch (error) {
        handleEdgeError(error);
      }
    });
  }
  /**
  * Called with credentials arriving from the control pipeline.
  */
  async processCredential(credential) {
    if (!credential.id) {
      return;
    }
    this._processCredentialsTriggers.get(credential.id)?.wake();
    this._processedCredentials.add(credential.id);
    this._processCredentialsTriggers.delete(credential.id);
  }
  setWriter(writer) {
    invariant4(!this._writer, "Writer already set.", {
      F: __dxlog_file8,
      L: 274,
      S: this,
      A: [
        "!this._writer",
        "'Writer already set.'"
      ]
    });
    this._writer = writer;
    if (this._edgeClient && this.isOpen) {
      this._notarizePendingEdgeCredentials(this._edgeClient, writer);
    }
  }
  _startPeriodicEdgePolling(client) {
    this._activeEdgePollingIntervalHandle = setInterval(() => {
      if (this._writer) {
        this._notarizePendingEdgeCredentials(client, this._writer);
      }
    }, this._activeEdgePollingInterval);
  }
  _stopPeriodicEdgePolling() {
    if (this._activeEdgePollingIntervalHandle) {
      clearInterval(this._activeEdgePollingIntervalHandle);
      this._activeEdgePollingIntervalHandle = void 0;
    }
  }
  /**
  * The method is used only for adding agent feeds to spaces.
  * When an agent is created we can admit them into all the existing spaces. In case the operation fails
  * this method will fix it on the next space open.
  * Given how rarely this happens there's no need to poll the endpoint.
  */
  _notarizePendingEdgeCredentials(client, writer) {
    scheduleMicroTask2(this._ctx, async () => {
      try {
        const response = await client.getCredentialsForNotarization(this._spaceId, {
          retry: {
            count: MAX_EDGE_RETRIES
          }
        });
        const credentials = response.awaitingNotarization.credentials;
        if (!credentials.length) {
          log5("edge did not return credentials for notarization", void 0, {
            F: __dxlog_file8,
            L: 311,
            S: this,
            C: (f, a) => f(...a)
          });
          return;
        }
        log5("got edge credentials for notarization", {
          count: credentials.length
        }, {
          F: __dxlog_file8,
          L: 315,
          S: this,
          C: (f, a) => f(...a)
        });
        const decodedCredentials = credentials.map((credential) => {
          const binary = Buffer.from(credential, "base64");
          return credentialCodec.decode(binary);
        });
        await this._notarizeCredentials(writer, decodedCredentials);
        log5.info("notarized edge credentials", {
          count: decodedCredentials.length
        }, {
          F: __dxlog_file8,
          L: 324,
          S: this,
          C: (f, a) => f(...a)
        });
      } catch (error) {
        handleEdgeError(error);
      }
    });
  }
  async _waitUntilProcessed(id) {
    if (this._processedCredentials.has(id)) {
      return;
    }
    await entry(this._processCredentialsTriggers, id).orInsert(new Trigger3()).value.wait();
  }
  /**
  * Requests from other peers to notarize credentials.
  */
  async _onNotarize(request) {
    if (!this._writer) {
      throw new Error(WRITER_NOT_SET_ERROR_CODE);
    }
    await this._notarizeCredentials(this._writer, request.credentials ?? []);
  }
  async _notarizeCredentials(writer, credentials) {
    for (const credential of credentials) {
      invariant4(credential.id, "Credential must have an id", {
        F: __dxlog_file8,
        L: 350,
        S: this,
        A: [
          "credential.id",
          "'Credential must have an id'"
        ]
      });
      if (this._processedCredentials.has(credential.id)) {
        continue;
      }
      const verificationResult = await verifyCredential2(credential);
      if (verificationResult.kind === "fail") {
        throw new Error(`Credential verification failed: ${verificationResult.errors.join("\n")}.`);
      }
      await writer.write(credential);
    }
  }
  createExtension() {
    const extension = new NotarizationTeleportExtension({
      onOpen: async () => {
        log5("extension opened", {
          peer: extension.localPeerId
        }, {
          F: __dxlog_file8,
          L: 365,
          S: this,
          C: (f, a) => f(...a)
        });
        this._extensions.add(extension);
        this._extensionOpened.emit();
      },
      onClose: async () => {
        log5("extension closed", {
          peer: extension.localPeerId
        }, {
          F: __dxlog_file8,
          L: 370,
          S: this,
          C: (f, a) => f(...a)
        });
        this._extensions.delete(extension);
      },
      onNotarize: this._onNotarize.bind(this)
    });
    return extension;
  }
  _scheduleTimeout(ctx, errors, timeout) {
    scheduleTask2(ctx, () => {
      log5.warn("Notarization timeout", {
        timeout,
        peers: Array.from(this._extensions).map((extension) => extension.remotePeerId)
      }, {
        F: __dxlog_file8,
        L: 382,
        S: this,
        C: (f, a) => f(...a)
      });
      void ctx.dispose();
      errors.throw(new TimeoutError(timeout, "Notarization timed out"));
    }, timeout);
  }
};
_ts_decorate2([
  logInfo2
], NotarizationPlugin.prototype, "_spaceId", void 0);
var handleEdgeError = (error) => {
  if (!(error instanceof EdgeCallFailedError) || error.errorData) {
    log5.catch(error, void 0, {
      F: __dxlog_file8,
      L: 396,
      S: void 0,
      C: (f, a) => f(...a)
    });
  } else {
    log5.info("Edge notarization failure", {
      reason: error.reason
    }, {
      F: __dxlog_file8,
      L: 398,
      S: void 0,
      C: (f, a) => f(...a)
    });
  }
};
var NotarizationTeleportExtension = class extends RpcExtension {
  constructor(_params) {
    super({
      requested: {
        NotarizationService: schema2.getService("dxos.mesh.teleport.notarization.NotarizationService")
      },
      exposed: {
        NotarizationService: schema2.getService("dxos.mesh.teleport.notarization.NotarizationService")
      }
    }), this._params = _params;
  }
  async getHandlers() {
    return {
      NotarizationService: {
        notarize: async (request) => {
          await this._params.onNotarize(request);
        }
      }
    };
  }
  async onOpen(ctx) {
    await super.onOpen(ctx);
    await this._params.onOpen();
  }
  async onClose(err) {
    await this._params.onClose();
    await super.onClose(err);
  }
};

// packages/sdk/client-services/src/packlets/identity/identity.ts
import { Event as Event5 } from "@dxos/async";
import { AUTH_TIMEOUT, LOAD_CONTROL_FEEDS_TIMEOUT } from "@dxos/client-protocol";
import { DeviceStateMachine, createCredentialSignerWithKey, createCredentialSignerWithChain, ProfileStateMachine } from "@dxos/credentials";
import { writeMessages as writeMessages3 } from "@dxos/feed-store";
import { invariant as invariant8 } from "@dxos/invariant";
import { PublicKey as PublicKey6 } from "@dxos/keys";
import { log as log10 } from "@dxos/log";
import { AdmittedFeed as AdmittedFeed2 } from "@dxos/protocols/proto/dxos/halo/credentials";
import { Timeframe as Timeframe2 } from "@dxos/timeframe";
import { trace as trace3 } from "@dxos/tracing";
import { ComplexSet as ComplexSet2 } from "@dxos/util";

// packages/sdk/client-services/src/packlets/identity/default-space-state-machine.ts
import { getCredentialAssertion } from "@dxos/credentials";
import { SpaceId } from "@dxos/keys";
import { log as log6 } from "@dxos/log";
var __dxlog_file9 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/identity/default-space-state-machine.ts";
var DefaultSpaceStateMachine = class {
  constructor(_params) {
    this._params = _params;
  }
  get spaceId() {
    return this._spaceId;
  }
  async processCredential(credential) {
    const assertion = getCredentialAssertion(credential);
    switch (assertion["@type"]) {
      case "dxos.halo.credentials.DefaultSpace": {
        if (!credential.subject.id.equals(this._params.identityKey)) {
          log6.warn("Invalid default space credential", {
            expectedIdentity: this._params.identityKey,
            credential
          }, {
            F: __dxlog_file9,
            L: 32,
            S: this,
            C: (f, a) => f(...a)
          });
          return;
        }
        if (!SpaceId.isValid(assertion.spaceId)) {
          log6.warn("Invalid default space id", {
            id: assertion.spaceId
          }, {
            F: __dxlog_file9,
            L: 36,
            S: this,
            C: (f, a) => f(...a)
          });
          return;
        }
        this._spaceId = assertion.spaceId;
        break;
      }
    }
  }
};

// packages/sdk/client-services/src/packlets/spaces/data-space-manager.ts
import { interpretAsDocumentId } from "@automerge/automerge-repo";
import { Event as Event4, synchronized, trackLeaks } from "@dxos/async";
import { PropertiesType, TYPE_PROPERTIES } from "@dxos/client-protocol";
import { Context as Context4, LifecycleState, Resource as Resource4, cancelWithContext } from "@dxos/context";
import { createAdmissionCredentials, getCredentialAssertion as getCredentialAssertion2 } from "@dxos/credentials";
import { DatabaseRoot, findInlineObjectOfType, AuthStatus, CredentialServerExtension, FIND_PARAMS } from "@dxos/echo-pipeline";
import { SpaceDocVersion, createIdFromSpaceKey, encodeReference } from "@dxos/echo-protocol";
import { ObjectId, getTypeReference } from "@dxos/echo-schema";
import { writeMessages } from "@dxos/feed-store";
import { assertArgument, assertState, failedInvariant, invariant as invariant5 } from "@dxos/invariant";
import { PublicKey as PublicKey5 } from "@dxos/keys";
import { log as log7 } from "@dxos/log";
import { AlreadyJoinedError, trace as Trace } from "@dxos/protocols";
import { Invitation, SpaceState } from "@dxos/protocols/proto/dxos/client/services";
import { EdgeReplicationSetting } from "@dxos/protocols/proto/dxos/echo/metadata";
import { SpaceMember as SpaceMember3 } from "@dxos/protocols/proto/dxos/halo/credentials";
import { Gossip, Presence } from "@dxos/teleport-extension-gossip";
import { trace } from "@dxos/tracing";
import { ComplexMap as ComplexMap4, setDeep, deferFunction, forEachAsync } from "@dxos/util";

// packages/sdk/client-services/src/packlets/spaces/genesis.ts
import { createCredential } from "@dxos/credentials";
import { failUndefined } from "@dxos/debug";
import { AdmittedFeed, SpaceMember as SpaceMember2 } from "@dxos/protocols/proto/dxos/halo/credentials";
import { Timeframe } from "@dxos/timeframe";
var spaceGenesis = async (keyring, signingContext, space, automergeRoot) => {
  const credentials = [
    await createCredential({
      signer: keyring,
      issuer: space.key,
      subject: space.key,
      assertion: {
        "@type": "dxos.halo.credentials.SpaceGenesis",
        spaceKey: space.key
      }
    }),
    await createCredential({
      signer: keyring,
      issuer: space.key,
      subject: signingContext.identityKey,
      assertion: {
        "@type": "dxos.halo.credentials.SpaceMember",
        spaceKey: space.key,
        role: SpaceMember2.Role.OWNER,
        profile: signingContext.getProfile(),
        genesisFeedKey: space.controlFeedKey ?? failUndefined()
      }
    }),
    await signingContext.credentialSigner.createCredential({
      subject: space.controlFeedKey ?? failUndefined(),
      assertion: {
        "@type": "dxos.halo.credentials.AdmittedFeed",
        spaceKey: space.key,
        identityKey: signingContext.identityKey,
        deviceKey: signingContext.deviceKey,
        designation: AdmittedFeed.Designation.CONTROL
      }
    }),
    await signingContext.credentialSigner.createCredential({
      subject: space.dataFeedKey ?? failUndefined(),
      assertion: {
        "@type": "dxos.halo.credentials.AdmittedFeed",
        spaceKey: space.key,
        identityKey: signingContext.identityKey,
        deviceKey: signingContext.deviceKey,
        designation: AdmittedFeed.Designation.DATA
      }
    }),
    await signingContext.credentialSigner.createCredential({
      subject: space.key ?? failUndefined(),
      assertion: {
        "@type": "dxos.halo.credentials.Epoch",
        number: 0,
        previousId: void 0,
        timeframe: new Timeframe(),
        snapshotCid: void 0,
        automergeRoot
      }
    })
  ];
  for (const credential of credentials) {
    await space.controlPipeline.writer.write({
      credential: {
        credential
      }
    });
  }
  return credentials;
};

// packages/sdk/client-services/src/packlets/spaces/data-space-manager.ts
function _ts_decorate3(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file10 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/spaces/data-space-manager.ts";
var PRESENCE_ANNOUNCE_INTERVAL = 1e4;
var PRESENCE_OFFLINE_TIMEOUT = 2e4;
var DEFAULT_SPACE_KEY = "__DEFAULT__";
var DataSpaceManager = class extends Resource4 {
  constructor(params) {
    super();
    this.updated = new Event4();
    this._spaces = new ComplexMap4(PublicKey5.hash);
    this._instanceId = PublicKey5.random().toHex();
    this._edgeConnection = void 0;
    this._edgeHttpClient = void 0;
    this._edgeFeatures = void 0;
    this._meshReplicator = void 0;
    this._echoEdgeReplicator = void 0;
    this._runtimeParams = void 0;
    this._spaceManager = params.spaceManager;
    this._metadataStore = params.metadataStore;
    this._keyring = params.keyring;
    this._signingContext = params.signingContext;
    this._feedStore = params.feedStore;
    this._echoHost = params.echoHost;
    this._meshReplicator = params.meshReplicator;
    this._invitationsManager = params.invitationsManager;
    this._edgeConnection = params.edgeConnection;
    this._edgeFeatures = params.edgeFeatures;
    this._echoEdgeReplicator = params.echoEdgeReplicator;
    this._edgeHttpClient = params.edgeHttpClient;
    this._runtimeParams = params.runtimeParams;
    trace.diagnostic({
      id: "spaces",
      name: "Spaces",
      fetch: async () => {
        return Promise.all(Array.from(this._spaces.values()).map(async (space) => {
          const rootUrl = space.automergeSpaceState.rootUrl;
          const rootHandle = rootUrl ? await this._echoHost.automergeRepo.find(rootUrl, FIND_PARAMS) : void 0;
          await rootHandle?.whenReady();
          const rootDoc = rootHandle?.doc();
          const properties = rootDoc && findInlineObjectOfType(rootDoc, TYPE_PROPERTIES);
          return {
            key: space.key.toHex(),
            state: SpaceState[space.state],
            name: properties?.[1].data.name ?? null,
            inlineObjects: rootDoc ? Object.keys(rootDoc.objects ?? {}).length : null,
            linkedObjects: rootDoc ? Object.keys(rootDoc.links ?? {}).length : null,
            credentials: space.inner.spaceState.credentials.length,
            members: space.inner.spaceState.members.size,
            rootUrl
          };
        }));
      }
    });
  }
  // TODO(burdon): Remove.
  get spaces() {
    return this._spaces;
  }
  getSpaceById(spaceId) {
    return [
      ...this._spaces.values()
    ].find((space) => space.id === spaceId);
  }
  async _open() {
    log7("open", void 0, {
      F: __dxlog_file10,
      L: 215,
      S: this,
      C: (f, a) => f(...a)
    });
    log7.trace("dxos.echo.data-space-manager.open", Trace.begin({
      id: this._instanceId
    }), {
      F: __dxlog_file10,
      L: 216,
      S: this,
      C: (f, a) => f(...a)
    });
    log7("metadata loaded", {
      spaces: this._metadataStore.spaces.length
    }, {
      F: __dxlog_file10,
      L: 217,
      S: this,
      C: (f, a) => f(...a)
    });
    await forEachAsync(this._metadataStore.spaces, async (spaceMetadata) => {
      try {
        log7("load space", {
          spaceMetadata
        }, {
          F: __dxlog_file10,
          L: 221,
          S: this,
          C: (f, a) => f(...a)
        });
        await this._constructSpace(spaceMetadata);
      } catch (err) {
        log7.error("Error loading space", {
          spaceMetadata,
          err
        }, {
          F: __dxlog_file10,
          L: 224,
          S: this,
          C: (f, a) => f(...a)
        });
      }
    });
    this.updated.emit();
    log7.trace("dxos.echo.data-space-manager.open", Trace.end({
      id: this._instanceId
    }), {
      F: __dxlog_file10,
      L: 230,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  async _close() {
    log7("close", void 0, {
      F: __dxlog_file10,
      L: 235,
      S: this,
      C: (f, a) => f(...a)
    });
    for (const space of this._spaces.values()) {
      await space.close();
    }
    this._spaces.clear();
  }
  /**
  * Creates a new space writing the genesis credentials to the control feed.
  */
  async createSpace(options = {}) {
    assertArgument(!!options.rootUrl === !!options.documents, "root url must be required when providing documents");
    assertState(this._lifecycleState === LifecycleState.OPEN, "Not open.");
    const spaceKey = await this._keyring.createKey();
    const controlFeedKey = await this._keyring.createKey();
    const dataFeedKey = await this._keyring.createKey();
    const spaceId = await createIdFromSpaceKey(spaceKey);
    const metadata = {
      key: spaceKey,
      genesisFeedKey: controlFeedKey,
      controlFeedKey,
      dataFeedKey,
      state: SpaceState.SPACE_ACTIVE
    };
    log7("creating space...", {
      spaceId,
      spaceKey
    }, {
      F: __dxlog_file10,
      L: 264,
      S: this,
      C: (f, a) => f(...a)
    });
    const documentIdMapping = {};
    if (options.documents) {
      invariant5(Object.keys(options.documents).every((documentId) => /^[a-zA-Z0-9]+$/.test(documentId)), "Invalid document IDs", {
        F: __dxlog_file10,
        L: 269,
        S: this,
        A: [
          "Object.keys(options.documents).every((documentId) => /^[a-zA-Z0-9]+$/.test(documentId))",
          "'Invalid document IDs'"
        ]
      });
      await Promise.all(Object.entries(options.documents).map(async ([documentId, data]) => {
        log7("creating document...", {
          documentId
        }, {
          F: __dxlog_file10,
          L: 276,
          S: this,
          C: (f, a) => f(...a)
        });
        const newDoc = await this._echoHost.createDoc(data, {
          preserveHistory: true
        });
        documentIdMapping[documentId] = newDoc.documentId;
      }));
    }
    log7("opening space...", {
      spaceKey
    }, {
      F: __dxlog_file10,
      L: 283,
      S: this,
      C: (f, a) => f(...a)
    });
    let root;
    if (options.rootUrl) {
      const newRootDocId = documentIdMapping[interpretAsDocumentId(options.rootUrl)] ?? failedInvariant();
      const rootDocHandle = await this._echoHost.loadDoc(Context4.default(void 0, {
        F: __dxlog_file10,
        L: 288
      }), newRootDocId);
      DatabaseRoot.mapLinks(rootDocHandle, documentIdMapping);
      root = await this._echoHost.openSpaceRoot(spaceId, `automerge:${newRootDocId}`);
    } else {
      root = await this._echoHost.createSpaceRoot(spaceKey);
    }
    log7("constructing space...", {
      spaceKey
    }, {
      F: __dxlog_file10,
      L: 296,
      S: this,
      C: (f, a) => f(...a)
    });
    const space = await this._constructSpace(metadata);
    await space.open();
    log7("adding space...", {
      spaceKey
    }, {
      F: __dxlog_file10,
      L: 301,
      S: this,
      C: (f, a) => f(...a)
    });
    const credentials = await spaceGenesis(this._keyring, this._signingContext, space.inner, root.url);
    await this._metadataStore.addSpace(metadata);
    const memberCredential = credentials[1];
    invariant5(getCredentialAssertion2(memberCredential)["@type"] === "dxos.halo.credentials.SpaceMember", void 0, {
      F: __dxlog_file10,
      L: 307,
      S: this,
      A: [
        "getCredentialAssertion(memberCredential)['@type'] === 'dxos.halo.credentials.SpaceMember'",
        ""
      ]
    });
    await this._signingContext.recordCredential(memberCredential);
    await space.initializeDataPipeline();
    log7("space ready.", {
      spaceId,
      spaceKey
    }, {
      F: __dxlog_file10,
      L: 312,
      S: this,
      C: (f, a) => f(...a)
    });
    this.updated.emit();
    return space;
  }
  async isDefaultSpace(space) {
    if (!space.databaseRoot) {
      return false;
    }
    switch (space.databaseRoot.getVersion()) {
      case SpaceDocVersion.CURRENT: {
        if (!space.databaseRoot.handle.isReady()) {
          log7.warn("waiting for space root to be ready", {
            spaceId: space.id
          }, {
            F: __dxlog_file10,
            L: 325,
            S: this,
            C: (f, a) => f(...a)
          });
          await space.databaseRoot.handle.whenReady();
        }
        const [_, properties] = findInlineObjectOfType(space.databaseRoot.doc(), TYPE_PROPERTIES) ?? [];
        return properties?.data?.[DEFAULT_SPACE_KEY] === this._signingContext.identityKey.toHex();
      }
      case SpaceDocVersion.LEGACY: {
        throw new Error("Legacy space version is not supported");
      }
      default:
        log7.warn("unknown space version", {
          version: space.databaseRoot.getVersion(),
          spaceId: space.id
        }, {
          F: __dxlog_file10,
          L: 336,
          S: this,
          C: (f, a) => f(...a)
        });
        return false;
    }
  }
  async createDefaultSpace() {
    const space = await this.createSpace();
    const document = await this._getSpaceRootDocument(space);
    const properties = {
      system: {
        type: encodeReference(getTypeReference(PropertiesType))
      },
      data: {
        [DEFAULT_SPACE_KEY]: this._signingContext.identityKey.toHex()
      },
      meta: {
        keys: []
      }
    };
    const propertiesId = ObjectId.random();
    document.change((doc) => {
      setDeep(doc, [
        "objects",
        propertiesId
      ], properties);
    });
    await this._echoHost.flush();
    return space;
  }
  async _getSpaceRootDocument(space) {
    const automergeIndex = space.automergeSpaceState.rootUrl;
    invariant5(automergeIndex, void 0, {
      F: __dxlog_file10,
      L: 369,
      S: this,
      A: [
        "automergeIndex",
        ""
      ]
    });
    const document = await this._echoHost.automergeRepo.find(automergeIndex, FIND_PARAMS);
    await document.whenReady();
    return document;
  }
  // TODO(burdon): Rename join space.
  async acceptSpace(opts) {
    log7("accept space", {
      opts
    }, {
      F: __dxlog_file10,
      L: 378,
      S: this,
      C: (f, a) => f(...a)
    });
    invariant5(this._lifecycleState === LifecycleState.OPEN, "Not open.", {
      F: __dxlog_file10,
      L: 379,
      S: this,
      A: [
        "this._lifecycleState === LifecycleState.OPEN",
        "'Not open.'"
      ]
    });
    invariant5(!this._spaces.has(opts.spaceKey), "Space already exists.", {
      F: __dxlog_file10,
      L: 380,
      S: this,
      A: [
        "!this._spaces.has(opts.spaceKey)",
        "'Space already exists.'"
      ]
    });
    const metadata = {
      key: opts.spaceKey,
      genesisFeedKey: opts.genesisFeedKey,
      controlTimeframe: opts.controlTimeframe,
      dataTimeframe: opts.dataTimeframe
    };
    const space = await this._constructSpace(metadata);
    await space.open();
    await this._metadataStore.addSpace(metadata);
    space.initializeDataPipelineAsync();
    this.updated.emit();
    return space;
  }
  async admitMember(options) {
    const space = this._spaceManager.spaces.get(options.spaceKey);
    invariant5(space, void 0, {
      F: __dxlog_file10,
      L: 400,
      S: this,
      A: [
        "space",
        ""
      ]
    });
    if (space.spaceState.getMemberRole(options.identityKey) !== SpaceMember3.Role.REMOVED) {
      throw new AlreadyJoinedError();
    }
    const credentials = await createAdmissionCredentials(this._signingContext.credentialSigner, options.identityKey, space.key, space.genesisFeedKey, options.role, space.spaceState.membershipChainHeads, options.profile, options.delegationCredentialId);
    invariant5(credentials[0].credential, void 0, {
      F: __dxlog_file10,
      L: 419,
      S: this,
      A: [
        "credentials[0].credential",
        ""
      ]
    });
    const spaceMemberCredential = credentials[0].credential.credential;
    invariant5(getCredentialAssertion2(spaceMemberCredential)["@type"] === "dxos.halo.credentials.SpaceMember", void 0, {
      F: __dxlog_file10,
      L: 421,
      S: this,
      A: [
        "getCredentialAssertion(spaceMemberCredential)['@type'] === 'dxos.halo.credentials.SpaceMember'",
        ""
      ]
    });
    await writeMessages(space.controlPipeline.writer, credentials);
    return spaceMemberCredential;
  }
  /**
  * Wait until the space data pipeline is fully initialized.
  * Used by invitation handler.
  * TODO(dmaretskyi): Consider removing.
  */
  async waitUntilSpaceReady(spaceKey) {
    await cancelWithContext(this._ctx, this.updated.waitForCondition(() => {
      const space = this._spaces.get(spaceKey);
      return !!space && space.state === SpaceState.SPACE_READY;
    }));
  }
  async requestSpaceAdmissionCredential(spaceKey) {
    return this._spaceManager.requestSpaceAdmissionCredential({
      spaceKey,
      identityKey: this._signingContext.identityKey,
      timeout: 15e3,
      swarmIdentity: {
        identityKey: this._signingContext.identityKey,
        peerKey: this._signingContext.deviceKey,
        credentialProvider: createAuthProvider(this._signingContext.credentialSigner),
        credentialAuthenticator: async () => true
      }
    });
  }
  async setSpaceEdgeReplicationSetting(spaceKey, setting) {
    const space = this._spaces.get(spaceKey);
    invariant5(space, "Space not found.", {
      F: __dxlog_file10,
      L: 458,
      S: this,
      A: [
        "space",
        "'Space not found.'"
      ]
    });
    await this._metadataStore.setSpaceEdgeReplicationSetting(spaceKey, setting);
    if (space.isOpen) {
      switch (setting) {
        case EdgeReplicationSetting.DISABLED:
          await this._echoEdgeReplicator?.disconnectFromSpace(space.id);
          break;
        case EdgeReplicationSetting.ENABLED:
          await this._echoEdgeReplicator?.connectToSpace(space.id);
          break;
      }
    }
    space.stateUpdate.emit();
  }
  async _constructSpace(metadata) {
    log7("construct space", {
      metadata
    }, {
      F: __dxlog_file10,
      L: 477,
      S: this,
      C: (f, a) => f(...a)
    });
    const gossip = new Gossip({
      localPeerId: this._signingContext.deviceKey
    });
    const presence = new Presence({
      announceInterval: this._runtimeParams?.spaceMemberPresenceAnnounceInterval ?? PRESENCE_ANNOUNCE_INTERVAL,
      offlineTimeout: this._runtimeParams?.spaceMemberPresenceOfflineTimeout ?? PRESENCE_OFFLINE_TIMEOUT,
      identityKey: this._signingContext.identityKey,
      gossip
    });
    const controlFeed = metadata.controlFeedKey && await this._feedStore.openFeed(metadata.controlFeedKey, {
      writable: true
    });
    const dataFeed = metadata.dataFeedKey && await this._feedStore.openFeed(metadata.dataFeedKey, {
      writable: true,
      sparse: true
    });
    const space = await this._spaceManager.constructSpace({
      metadata,
      swarmIdentity: {
        identityKey: this._signingContext.identityKey,
        peerKey: this._signingContext.deviceKey,
        credentialProvider: createAuthProvider(this._signingContext.credentialSigner),
        credentialAuthenticator: deferFunction(() => dataSpace.authVerifier.verifier)
      },
      onAuthorizedConnection: (session) => queueMicrotask(async () => {
        try {
          if (!session.isOpen) {
            return;
          }
          session.addExtension("dxos.mesh.teleport.admission-discovery", new CredentialServerExtension(space));
          session.addExtension("dxos.mesh.teleport.gossip", gossip.createExtension({
            remotePeerId: session.remotePeerId
          }));
          session.addExtension("dxos.mesh.teleport.notarization", dataSpace.notarizationPlugin.createExtension());
          await this._connectEchoMeshReplicator(space, session);
        } catch (err) {
          log7.warn("error on authorized connection", {
            err
          }, {
            F: __dxlog_file10,
            L: 519,
            S: this,
            C: (f, a) => f(...a)
          });
          await session.close(err);
        }
      }),
      onAuthFailure: () => {
        log7.warn("auth failure", void 0, {
          F: __dxlog_file10,
          L: 524,
          S: this,
          C: (f, a) => f(...a)
        });
      },
      onMemberRolesChanged: async (members) => {
        if (dataSpace?.state === SpaceState.SPACE_READY) {
          this._handleMemberRoleChanges(presence, space.protocol, members);
        }
      },
      memberKey: this._signingContext.identityKey,
      onDelegatedInvitationStatusChange: (invitation, isActive) => {
        return this._handleInvitationStatusChange(dataSpace, invitation, isActive);
      }
    });
    controlFeed && await space.setControlFeed(controlFeed);
    dataFeed && await space.setDataFeed(dataFeed);
    const dataSpace = new DataSpace({
      inner: space,
      initialState: metadata.state === SpaceState.SPACE_INACTIVE ? SpaceState.SPACE_INACTIVE : SpaceState.SPACE_CLOSED,
      metadataStore: this._metadataStore,
      gossip,
      presence,
      keyring: this._keyring,
      feedStore: this._feedStore,
      echoHost: this._echoHost,
      signingContext: this._signingContext,
      callbacks: {
        beforeReady: async () => {
          log7("before space ready", {
            space: space.key
          }, {
            F: __dxlog_file10,
            L: 551,
            S: this,
            C: (f, a) => f(...a)
          });
        },
        afterReady: async () => {
          log7("after space ready", {
            space: space.key,
            open: this._lifecycleState === LifecycleState.OPEN
          }, {
            F: __dxlog_file10,
            L: 554,
            S: this,
            C: (f, a) => f(...a)
          });
          if (this._lifecycleState === LifecycleState.OPEN) {
            await this._createDelegatedInvitations(dataSpace, [
              ...space.spaceState.invitations.entries()
            ]);
            this._handleMemberRoleChanges(presence, space.protocol, [
              ...space.spaceState.members.values()
            ]);
            this.updated.emit();
          }
        },
        beforeClose: async () => {
          log7("before space close", {
            space: space.key
          }, {
            F: __dxlog_file10,
            L: 562,
            S: this,
            C: (f, a) => f(...a)
          });
        }
      },
      cache: metadata.cache,
      edgeConnection: this._edgeConnection,
      edgeHttpClient: this._edgeHttpClient,
      edgeFeatures: this._edgeFeatures,
      activeEdgeNotarizationPollingInterval: this._runtimeParams?.activeEdgeNotarizationPollingInterval
    });
    dataSpace.postOpen.append(async () => {
      const setting = dataSpace.getEdgeReplicationSetting();
      if (!setting || setting === EdgeReplicationSetting.ENABLED) {
        await this._echoEdgeReplicator?.connectToSpace(dataSpace.id);
      } else if (this._echoEdgeReplicator) {
        log7("not connecting EchoEdgeReplicator because of EdgeReplicationSetting", {
          spaceId: dataSpace.id
        }, {
          F: __dxlog_file10,
          L: 576,
          S: this,
          C: (f, a) => f(...a)
        });
      }
    });
    dataSpace.preClose.append(async () => {
      const setting = dataSpace.getEdgeReplicationSetting();
      if (!setting || setting === EdgeReplicationSetting.ENABLED) {
        await this._echoEdgeReplicator?.disconnectFromSpace(dataSpace.id);
      }
    });
    presence.newPeer.on((peerState) => {
      if (dataSpace.state === SpaceState.SPACE_READY) {
        this._handleNewPeerConnected(space, peerState);
      }
    });
    if (metadata.controlTimeframe) {
      dataSpace.inner.controlPipeline.state.setTargetTimeframe(metadata.controlTimeframe);
    }
    this._spaces.set(metadata.key, dataSpace);
    return dataSpace;
  }
  async _connectEchoMeshReplicator(space, session) {
    const replicator = this._meshReplicator;
    if (!replicator) {
      log7.warn("p2p automerge replication disabled", {
        space: space.key
      }, {
        F: __dxlog_file10,
        L: 603,
        S: this,
        C: (f, a) => f(...a)
      });
      return;
    }
    await replicator.authorizeDevice(space.key, session.remotePeerId);
    if (session.isOpen) {
      session.addExtension("dxos.mesh.teleport.automerge", replicator.createExtension());
    }
  }
  _handleMemberRoleChanges(presence, spaceProtocol, memberInfo) {
    let closedSessions = 0;
    for (const member of memberInfo) {
      if (member.key.equals(presence.getLocalState().identityKey)) {
        continue;
      }
      const peers = presence.getPeersByIdentityKey(member.key);
      const sessions = peers.map((p) => p.peerId && spaceProtocol.sessions.get(p.peerId));
      const sessionsToClose = sessions.filter((s) => {
        return (s && member.role === SpaceMember3.Role.REMOVED !== (s.authStatus === AuthStatus.FAILURE)) ?? false;
      });
      sessionsToClose.forEach((session) => {
        void session.close().catch(log7.error);
      });
      closedSessions += sessionsToClose.length;
    }
    log7("processed member role changes", {
      roleChangeCount: memberInfo.length,
      peersOnline: presence.getPeersOnline().length,
      closedSessions
    }, {
      F: __dxlog_file10,
      L: 629,
      S: this,
      C: (f, a) => f(...a)
    });
    spaceProtocol.updateTopology();
  }
  _handleNewPeerConnected(space, peerState) {
    const role = space.spaceState.getMemberRole(peerState.identityKey);
    if (role === SpaceMember3.Role.REMOVED) {
      const session = peerState.peerId && space.protocol.sessions.get(peerState.peerId);
      if (session != null) {
        log7("closing a session with a removed peer", {
          peerId: peerState.peerId
        }, {
          F: __dxlog_file10,
          L: 643,
          S: this,
          C: (f, a) => f(...a)
        });
        void session.close().catch(log7.error);
      }
    }
  }
  async _handleInvitationStatusChange(dataSpace, delegatedInvitation, isActive) {
    if (dataSpace?.state !== SpaceState.SPACE_READY) {
      return;
    }
    if (isActive) {
      await this._createDelegatedInvitations(dataSpace, [
        [
          delegatedInvitation.credentialId,
          delegatedInvitation.invitation
        ]
      ]);
    } else {
      await this._invitationsManager.cancelInvitation(delegatedInvitation.invitation);
    }
  }
  async _createDelegatedInvitations(space, invitations) {
    const tasks = invitations.map(([credentialId, invitation]) => {
      return this._invitationsManager.createInvitation({
        type: Invitation.Type.DELEGATED,
        kind: Invitation.Kind.SPACE,
        spaceKey: space.key,
        authMethod: invitation.authMethod,
        invitationId: invitation.invitationId,
        swarmKey: invitation.swarmKey,
        guestKeypair: invitation.guestKey ? {
          publicKey: invitation.guestKey
        } : void 0,
        lifetime: invitation.expiresOn ? (invitation.expiresOn.getTime() - Date.now()) / 1e3 : void 0,
        multiUse: invitation.multiUse,
        delegationCredentialId: credentialId,
        persistent: false
      });
    });
    await Promise.all(tasks);
  }
};
_ts_decorate3([
  synchronized
], DataSpaceManager.prototype, "_open", null);
_ts_decorate3([
  synchronized
], DataSpaceManager.prototype, "_close", null);
_ts_decorate3([
  synchronized
], DataSpaceManager.prototype, "createSpace", null);
_ts_decorate3([
  synchronized
], DataSpaceManager.prototype, "acceptSpace", null);
DataSpaceManager = _ts_decorate3([
  trackLeaks("open", "close")
], DataSpaceManager);

// packages/sdk/client-services/src/packlets/spaces/spaces-service.ts
import { SubscriptionList as SubscriptionList2, UpdateScheduler, scheduleTask as scheduleTask3 } from "@dxos/async";
import { Stream as Stream7 } from "@dxos/codec-protobuf/stream";
import { createAdmissionCredentials as createAdmissionCredentials2, createDidFromIdentityKey as createDidFromIdentityKey2, getCredentialAssertion as getCredentialAssertion3 } from "@dxos/credentials";
import { raise } from "@dxos/debug";
import { writeMessages as writeMessages2 } from "@dxos/feed-store";
import { assertArgument as assertArgument4, assertState as assertState3, invariant as invariant7 } from "@dxos/invariant";
import { SpaceId as SpaceId2 } from "@dxos/keys";
import { log as log9 } from "@dxos/log";
import { encodeError, ApiError, AuthorizationError, IdentityNotInitializedError, SpaceNotFoundError } from "@dxos/protocols";
import { SpaceMember as SpaceMember4, SpaceState as SpaceState2 } from "@dxos/protocols/proto/dxos/client/services";
import { trace as trace2 } from "@dxos/tracing";

// packages/sdk/client-services/src/packlets/space-export/space-archive-writer.ts
import { Resource as Resource5 } from "@dxos/context";
import { assertArgument as assertArgument2, assertState as assertState2 } from "@dxos/invariant";
import { SpaceArchiveFileStructure, SpaceArchiveVersion } from "@dxos/protocols";
var CURRENT_VERSION = SpaceArchiveVersion.V1;
var SpaceArchiveWriter = class extends Resource5 {
  constructor() {
    super(...arguments);
    this._meta = void 0;
    this._currentRootUrl = void 0;
  }
  async _open(ctx) {
    this._tar = await import("@obsidize/tar-browserify");
  }
  async _close() {
    return Promise.resolve();
  }
  async begin(meta) {
    assertState2(this._tar, "Not open");
    assertState2(!this._meta, "Already started");
    this._meta = meta;
    this._archive = new this._tar.Archive();
  }
  async setCurrentRootUrl(url) {
    assertArgument2(url.startsWith("automerge:"), "Invalid root URL");
    assertState2(this._tar, "Not open");
    assertState2(this._meta, "Not started");
    this._currentRootUrl = url;
  }
  async writeDocument(documentId, data) {
    assertArgument2(!documentId.startsWith("automerge:"), "Invalid document ID");
    assertState2(this._archive, "Not open");
    this._archive.addBinaryFile(`${SpaceArchiveFileStructure.documents}/${documentId}.bin`, data);
  }
  async finish() {
    assertState2(this._archive, "Not open");
    assertState2(this._meta, "Not started");
    assertState2(this._currentRootUrl, "No root URL set");
    const metadata = {
      version: CURRENT_VERSION,
      createdAt: Date.now(),
      exportedBy: this._meta.exportedBy,
      originalSpaceId: this._meta.spaceId,
      echo: {
        currentRootUrl: this._currentRootUrl
      }
    };
    this._archive.addTextFile(SpaceArchiveFileStructure.metadata, JSON.stringify(metadata));
    const binary = this._archive.toUint8Array();
    return {
      filename: `${this._meta.spaceId}.tar`,
      contents: binary
    };
  }
};

// packages/sdk/client-services/src/packlets/space-export/space-archive-reader.ts
import { assertArgument as assertArgument3, failedInvariant as failedInvariant2, invariant as invariant6 } from "@dxos/invariant";
import { log as log8 } from "@dxos/log";
import { SpaceArchiveFileStructure as SpaceArchiveFileStructure2 } from "@dxos/protocols";
var __dxlog_file11 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/space-export/space-archive-reader.ts";
var extractSpaceArchive = async (archive) => {
  const { Archive } = await import("@obsidize/tar-browserify");
  const { entries } = await Archive.extract(archive.contents);
  const metadataEntry = entries.find((entry2) => entry2.fileName === SpaceArchiveFileStructure2.metadata);
  assertArgument3(metadataEntry, "Metadata entry not found");
  const metadata = JSON.parse(metadataEntry.getContentAsText());
  const documents = {};
  for (const entry2 of entries.filter((entry3) => entry3.fileName.startsWith(`${SpaceArchiveFileStructure2.documents}/`))) {
    const documentId = entry2.fileName.replace(`${SpaceArchiveFileStructure2.documents}/`, "").replace(/\.bin$/, "");
    invariant6(!documentId.includes("/"), void 0, {
      F: __dxlog_file11,
      L: 28,
      S: void 0,
      A: [
        "!documentId.includes('/')",
        ""
      ]
    });
    documents[documentId] = entry2.content ?? failedInvariant2();
  }
  log8.info("extracted space archive", {
    metadata,
    documents
  }, {
    F: __dxlog_file11,
    L: 32,
    S: void 0,
    C: (f, a) => f(...a)
  });
  return {
    metadata,
    documents
  };
};

// packages/sdk/client-services/src/packlets/spaces/spaces-service.ts
function _ts_add_disposable_resource2(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = function() {
      try {
        inner.call(this);
      } catch (e) {
        return Promise.reject(e);
      }
    };
    env.stack.push({
      value,
      dispose,
      async
    });
  } else if (async) {
    env.stack.push({
      async: true
    });
  }
  return value;
}
function _ts_dispose_resources2(env) {
  var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  };
  return (_ts_dispose_resources2 = function _ts_dispose_resources5(env2) {
    function fail(e) {
      env2.error = env2.hasError ? new _SuppressedError(e, env2.error, "An error was suppressed during disposal.") : e;
      env2.hasError = true;
    }
    var r, s = 0;
    function next() {
      while (r = env2.stack.pop()) {
        try {
          if (!r.async && s === 1) return s = 0, env2.stack.push(r), Promise.resolve().then(next);
          if (r.dispose) {
            var result = r.dispose.call(r.value);
            if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
              fail(e);
              return next();
            });
          } else s |= 1;
        } catch (e) {
          fail(e);
        }
      }
      if (s === 1) return env2.hasError ? Promise.reject(env2.error) : Promise.resolve();
      if (env2.hasError) throw env2.error;
    }
    return next();
  })(env);
}
var __dxlog_file12 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/spaces/spaces-service.ts";
var SpacesServiceImpl = class {
  constructor(_identityManager, _spaceManager, _getDataSpaceManager) {
    this._identityManager = _identityManager;
    this._spaceManager = _spaceManager;
    this._getDataSpaceManager = _getDataSpaceManager;
  }
  async createSpace() {
    this._requireIdentity();
    const dataSpaceManager = await this._getDataSpaceManager();
    const space = await dataSpaceManager.createSpace();
    await this._updateMetrics();
    return this._serializeSpace(space);
  }
  async updateSpace({ spaceKey, state, edgeReplication }) {
    const dataSpaceManager = await this._getDataSpaceManager();
    const space = dataSpaceManager.spaces.get(spaceKey) ?? raise(new SpaceNotFoundError(spaceKey));
    if (state) {
      switch (state) {
        case SpaceState2.SPACE_ACTIVE:
          await space.activate();
          break;
        case SpaceState2.SPACE_INACTIVE:
          await space.deactivate();
          break;
        default:
          throw new ApiError("Invalid space state");
      }
    }
    if (edgeReplication !== void 0) {
      await dataSpaceManager.setSpaceEdgeReplicationSetting(spaceKey, edgeReplication);
    }
  }
  async updateMemberRole(request) {
    const identity = this._requireIdentity();
    const space = this._spaceManager.spaces.get(request.spaceKey);
    if (space == null) {
      throw new SpaceNotFoundError(request.spaceKey);
    }
    if (!space.spaceState.hasMembershipManagementPermission(identity.identityKey)) {
      throw new AuthorizationError("No member management permission.", {
        spaceKey: space.key,
        role: space.spaceState.getMemberRole(identity.identityKey)
      });
    }
    const credentials = await createAdmissionCredentials2(identity.getIdentityCredentialSigner(), request.memberKey, space.key, space.genesisFeedKey, request.newRole, space.spaceState.membershipChainHeads);
    invariant7(credentials[0].credential, void 0, {
      F: __dxlog_file12,
      L: 119,
      S: this,
      A: [
        "credentials[0].credential",
        ""
      ]
    });
    const spaceMemberCredential = credentials[0].credential.credential;
    invariant7(getCredentialAssertion3(spaceMemberCredential)["@type"] === "dxos.halo.credentials.SpaceMember", void 0, {
      F: __dxlog_file12,
      L: 121,
      S: this,
      A: [
        "getCredentialAssertion(spaceMemberCredential)['@type'] === 'dxos.halo.credentials.SpaceMember'",
        ""
      ]
    });
    await writeMessages2(space.controlPipeline.writer, credentials);
  }
  querySpaces() {
    return new Stream7(({ next, ctx }) => {
      const scheduler = new UpdateScheduler(ctx, async () => {
        const dataSpaceManager = await this._getDataSpaceManager();
        const spaces = await Promise.all(Array.from(dataSpaceManager.spaces.values()).map((space) => this._serializeSpace(space)));
        log9("update", () => ({
          ids: spaces.map((space) => space.id)
        }), {
          F: __dxlog_file12,
          L: 134,
          S: this,
          C: (f, a) => f(...a)
        });
        await this._updateMetrics();
        next({
          spaces
        });
      }, {
        maxFrequency: false ? void 0 : 2
      });
      scheduleTask3(ctx, async () => {
        const dataSpaceManager = await this._getDataSpaceManager();
        const subscriptions = new SubscriptionList2();
        ctx.onDispose(() => subscriptions.clear());
        const subscribeSpaces = () => {
          subscriptions.clear();
          for (const space of dataSpaceManager.spaces.values()) {
            let lastState;
            subscriptions.add(space.stateUpdate.on(ctx, () => {
              if (space.state !== lastState) {
                scheduler.forceTrigger();
              } else {
                scheduler.trigger();
              }
              lastState = space.state;
            }));
            subscriptions.add(space.presence.updated.on(ctx, () => scheduler.trigger()));
            subscriptions.add(space.automergeSpaceState.onNewEpoch.on(ctx, () => scheduler.trigger()));
            subscriptions.add(space.inner.controlPipeline.state.timeframeUpdate.on(ctx, () => scheduler.trigger()));
          }
        };
        dataSpaceManager.updated.on(ctx, () => {
          subscribeSpaces();
          scheduler.trigger();
        });
        subscribeSpaces();
        scheduler.trigger();
      });
      if (!this._identityManager.identity) {
        next({
          spaces: []
        });
      }
    });
  }
  async postMessage({ spaceKey, channel, message }) {
    const dataSpaceManager = await this._getDataSpaceManager();
    const space = dataSpaceManager.spaces.get(spaceKey) ?? raise(new SpaceNotFoundError(spaceKey));
    await space.postMessage(getChannelId(channel), message);
  }
  subscribeMessages({ spaceKey, channel }) {
    return new Stream7(({ ctx, next }) => {
      scheduleTask3(ctx, async () => {
        const dataSpaceManager = await this._getDataSpaceManager();
        const space = dataSpaceManager.spaces.get(spaceKey) ?? raise(new SpaceNotFoundError(spaceKey));
        const handle = space.listen(getChannelId(channel), (message) => {
          next(message);
        });
        ctx.onDispose(() => handle.unsubscribe());
      });
    });
  }
  queryCredentials({ spaceKey, noTail }) {
    return new Stream7(({ ctx, next, close }) => {
      const space = this._spaceManager.spaces.get(spaceKey) ?? raise(new SpaceNotFoundError(spaceKey));
      const processor = {
        processCredential: async (credential) => {
          next(credential);
        }
      };
      ctx.onDispose(() => space.spaceState.removeCredentialProcessor(processor));
      scheduleTask3(ctx, async () => {
        await space.spaceState.addCredentialProcessor(processor);
        if (noTail) {
          close();
        }
      });
    });
  }
  async writeCredentials({ spaceKey, credentials }) {
    const space = this._spaceManager.spaces.get(spaceKey) ?? raise(new SpaceNotFoundError(spaceKey));
    for (const credential of credentials ?? []) {
      if (credential.proof) {
        await space.controlPipeline.writer.write({
          credential: {
            credential
          }
        });
      } else {
        invariant7(!credential.id, "Id on unsigned credentials is not allowed", {
          F: __dxlog_file12,
          L: 232,
          S: this,
          A: [
            "!credential.id",
            "'Id on unsigned credentials is not allowed'"
          ]
        });
        invariant7(this._identityManager.identity, "Identity is not available", {
          F: __dxlog_file12,
          L: 233,
          S: this,
          A: [
            "this._identityManager.identity",
            "'Identity is not available'"
          ]
        });
        const signer = this._identityManager.identity.getIdentityCredentialSigner();
        invariant7(credential.issuer.equals(signer.getIssuer()), void 0, {
          F: __dxlog_file12,
          L: 235,
          S: this,
          A: [
            "credential.issuer.equals(signer.getIssuer())",
            ""
          ]
        });
        const signedCredential = await signer.createCredential({
          subject: credential.subject.id,
          assertion: credential.subject.assertion
        });
        await space.controlPipeline.writer.write({
          credential: {
            credential: signedCredential
          }
        });
      }
    }
  }
  async createEpoch({ spaceKey, migration, automergeRootUrl }) {
    const dataSpaceManager = await this._getDataSpaceManager();
    const space = dataSpaceManager.spaces.get(spaceKey) ?? raise(new SpaceNotFoundError(spaceKey));
    const result = await space.createEpoch({
      migration,
      newAutomergeRoot: automergeRootUrl
    });
    return {
      epochCredential: result?.credential,
      controlTimeframe: result?.timeframe
    };
  }
  async admitContact(request) {
    const dataSpaceManager = await this._getDataSpaceManager();
    await dataSpaceManager.admitMember({
      spaceKey: request.spaceKey,
      identityKey: request.contact.identityKey,
      role: request.role
    });
  }
  async joinBySpaceKey({ spaceKey }) {
    const dataSpaceManager = await this._getDataSpaceManager();
    const credential = await dataSpaceManager.requestSpaceAdmissionCredential(spaceKey);
    return this._joinByAdmission({
      credential
    });
  }
  async exportSpace(request) {
    const env = {
      stack: [],
      error: void 0,
      hasError: false
    };
    try {
      const writer = _ts_add_disposable_resource2(env, await new SpaceArchiveWriter().open(), true);
      assertArgument4(SpaceId2.isValid(request.spaceId), "Invalid space ID");
      const dataSpaceManager = await this._getDataSpaceManager();
      const space = dataSpaceManager.getSpaceById(request.spaceId) ?? raise(new Error("Space not found"));
      await writer.begin({
        spaceId: space.id
      });
      const rootUrl = space.automergeSpaceState.lastEpoch?.subject.assertion.automergeRoot;
      assertState3(rootUrl, "Space does not have a root URL");
      await writer.setCurrentRootUrl(rootUrl);
      for await (const [documentId, data] of space.getAllDocuments()) {
        await writer.writeDocument(documentId, data);
      }
      const archive = await writer.finish();
      return {
        archive
      };
    } catch (e) {
      env.error = e;
      env.hasError = true;
    } finally {
      const result = _ts_dispose_resources2(env);
      if (result) await result;
    }
  }
  async importSpace(request) {
    const dataSpaceManager = await this._getDataSpaceManager();
    const extracted = await extractSpaceArchive(request.archive);
    invariant7(extracted.metadata.echo?.currentRootUrl, "Space archive does not contain a root URL", {
      F: __dxlog_file12,
      L: 289,
      S: this,
      A: [
        "extracted.metadata.echo?.currentRootUrl",
        "'Space archive does not contain a root URL'"
      ]
    });
    const space = await dataSpaceManager.createSpace({
      documents: extracted.documents,
      rootUrl: extracted.metadata.echo?.currentRootUrl
    });
    await this._updateMetrics();
    return {
      newSpaceId: space.id
    };
  }
  async _joinByAdmission({ credential }) {
    const assertion = getCredentialAssertion3(credential);
    invariant7(assertion["@type"] === "dxos.halo.credentials.SpaceMember", "Invalid credential", {
      F: __dxlog_file12,
      L: 300,
      S: this,
      A: [
        "assertion['@type'] === 'dxos.halo.credentials.SpaceMember'",
        "'Invalid credential'"
      ]
    });
    const myIdentity = this._identityManager.identity;
    invariant7(myIdentity && credential.subject.id.equals(myIdentity.identityKey), void 0, {
      F: __dxlog_file12,
      L: 302,
      S: this,
      A: [
        "myIdentity && credential.subject.id.equals(myIdentity.identityKey)",
        ""
      ]
    });
    const dataSpaceManager = await this._getDataSpaceManager();
    let dataSpace = dataSpaceManager.spaces.get(assertion.spaceKey);
    if (!dataSpace) {
      dataSpace = await dataSpaceManager.acceptSpace({
        spaceKey: assertion.spaceKey,
        genesisFeedKey: assertion.genesisFeedKey
      });
      await myIdentity.controlPipeline.writer.write({
        credential: {
          credential
        }
      });
    }
    return {
      space: await this._serializeSpace(dataSpace)
    };
  }
  async _serializeSpace(space) {
    return {
      id: space.id,
      spaceKey: space.key,
      state: space.state,
      error: space.error ? encodeError(space.error) : void 0,
      pipeline: {
        currentEpoch: space.automergeSpaceState.lastEpoch,
        appliedEpoch: space.automergeSpaceState.lastEpoch,
        controlFeeds: space.inner.controlPipeline.state.feeds.map((feed) => feed.key),
        currentControlTimeframe: space.inner.controlPipeline.state.timeframe,
        targetControlTimeframe: space.inner.controlPipeline.state.targetTimeframe,
        totalControlTimeframe: space.inner.controlPipeline.state.endTimeframe,
        dataFeeds: void 0,
        startDataTimeframe: void 0,
        currentDataTimeframe: void 0,
        targetDataTimeframe: void 0,
        totalDataTimeframe: void 0,
        spaceRootUrl: space.databaseRoot?.url
      },
      members: await Promise.all(Array.from(space.inner.spaceState.members.values()).map(async (member) => {
        const peers = space.presence.getPeersOnline().filter(({ identityKey }) => identityKey.equals(member.key));
        const isMe = this._identityManager.identity?.identityKey.equals(member.key);
        if (isMe) {
          peers.push(space.presence.getLocalState());
        }
        return {
          identity: {
            did: await createDidFromIdentityKey2(member.key),
            identityKey: member.key,
            profile: member.profile ?? {}
          },
          role: member.role,
          presence: peers.length > 0 ? SpaceMember4.PresenceState.ONLINE : SpaceMember4.PresenceState.OFFLINE,
          peerStates: peers
        };
      })),
      creator: space.inner.spaceState.creator?.key,
      cache: space.cache,
      metrics: space.metrics,
      edgeReplication: space.getEdgeReplicationSetting()
    };
  }
  _requireIdentity() {
    if (!this._identityManager.identity) {
      throw new IdentityNotInitializedError("This device has no HALO identity available. See https://docs.dxos.org/guide/platform/halo");
    }
    return this._identityManager.identity;
  }
  async _updateMetrics() {
    const dataSpaceManager = await this._getDataSpaceManager();
    const identity = this._identityManager.identity?.identityKey.truncate();
    if (identity) {
      trace2.metrics.gauge("dxos.echo.space.count", dataSpaceManager.spaces.size, {
        tags: {
          identity
        }
      });
    }
  }
};
var getChannelId = (channel) => `user-channel/${channel}`;

// packages/sdk/client-services/src/packlets/identity/identity.ts
function _ts_decorate4(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file13 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/identity/identity.ts";
var Identity = class {
  constructor(params) {
    this._edgeFeedReplicator = void 0;
    this.stateUpdate = new Event5();
    this._onFeedAdded = async (feed) => {
      await this._edgeFeedReplicator.addFeed(feed);
    };
    this.space = params.space;
    this._signer = params.signer;
    this._presence = params.presence;
    this.did = params.did;
    this.identityKey = params.identityKey;
    this.deviceKey = params.deviceKey;
    log10.trace("dxos.halo.device", {
      deviceKey: params.deviceKey
    }, {
      F: __dxlog_file13,
      L: 82,
      S: this,
      C: (f, a) => f(...a)
    });
    this._deviceStateMachine = new DeviceStateMachine({
      identityKey: this.identityKey,
      deviceKey: this.deviceKey,
      onUpdate: () => this.stateUpdate.emit()
    });
    this._profileStateMachine = new ProfileStateMachine({
      identityKey: this.identityKey,
      onUpdate: () => this.stateUpdate.emit()
    });
    this._defaultSpaceStateMachine = new DefaultSpaceStateMachine({
      identityKey: this.identityKey,
      onUpdate: () => this.stateUpdate.emit()
    });
    this.authVerifier = new TrustedKeySetAuthVerifier({
      trustedKeysProvider: () => new ComplexSet2(PublicKey6.hash, this.authorizedDeviceKeys.keys()),
      update: this.stateUpdate,
      authTimeout: AUTH_TIMEOUT
    });
    if (params.edgeConnection && params.edgeFeatures?.feedReplicator) {
      this._edgeFeedReplicator = new EdgeFeedReplicator({
        messenger: params.edgeConnection,
        spaceId: this.space.id
      });
    }
  }
  // TODO(burdon): Expose state object?
  get authorizedDeviceKeys() {
    return this._deviceStateMachine.authorizedDeviceKeys;
  }
  get defaultSpaceId() {
    return this._defaultSpaceStateMachine.spaceId;
  }
  async open(ctx) {
    await this._presence?.open();
    await this.space.spaceState.addCredentialProcessor(this._deviceStateMachine);
    await this.space.spaceState.addCredentialProcessor(this._profileStateMachine);
    await this.space.spaceState.addCredentialProcessor(this._defaultSpaceStateMachine);
    if (this._edgeFeedReplicator) {
      this.space.protocol.feedAdded.append(this._onFeedAdded);
    }
    await this.space.open(ctx);
  }
  async joinNetwork() {
    await this.space.startProtocol();
    await this._edgeFeedReplicator?.open();
  }
  async close(ctx) {
    await this._presence?.close();
    await this.authVerifier.close();
    await this.space.spaceState.removeCredentialProcessor(this._defaultSpaceStateMachine);
    await this.space.spaceState.removeCredentialProcessor(this._profileStateMachine);
    await this.space.spaceState.removeCredentialProcessor(this._deviceStateMachine);
    if (this._edgeFeedReplicator) {
      this.space.protocol.feedAdded.remove(this._onFeedAdded);
    }
    await this._edgeFeedReplicator?.close();
    await this.space.close();
  }
  async ready() {
    await this._deviceStateMachine.deviceChainReady.wait();
    await this.controlPipeline.state.waitUntilReachedTargetTimeframe({
      timeout: LOAD_CONTROL_FEEDS_TIMEOUT
    });
  }
  get profileDocument() {
    return this._profileStateMachine.profile;
  }
  /**
  * @test-only
  */
  get controlPipeline() {
    return this.space.controlPipeline;
  }
  get haloSpaceId() {
    return this.space.id;
  }
  get haloSpaceKey() {
    return this.space.key;
  }
  get haloGenesisFeedKey() {
    return this.space.genesisFeedKey;
  }
  get deviceCredentialChain() {
    return this._deviceStateMachine.deviceCredentialChain;
  }
  get presence() {
    return this._presence;
  }
  get signer() {
    return this._signer;
  }
  /**
  * Issues credentials as identity.
  * Requires identity to be ready.
  */
  getIdentityCredentialSigner() {
    invariant8(this._deviceStateMachine.deviceCredentialChain, "Device credential chain is not ready.", {
      F: __dxlog_file13,
      L: 198,
      S: this,
      A: [
        "this._deviceStateMachine.deviceCredentialChain",
        "'Device credential chain is not ready.'"
      ]
    });
    return createCredentialSignerWithChain(this._signer, this._deviceStateMachine.deviceCredentialChain, this.deviceKey);
  }
  /**
  * Issues credentials as device.
  */
  getDeviceCredentialSigner() {
    return createCredentialSignerWithKey(this._signer, this.deviceKey);
  }
  async updateDefaultSpace(spaceId) {
    const credential = await this.getDeviceCredentialSigner().createCredential({
      subject: this.identityKey,
      assertion: {
        "@type": "dxos.halo.credentials.DefaultSpace",
        spaceId
      }
    });
    const receipt = await this.controlPipeline.writer.write({
      credential: {
        credential
      }
    });
    await this.controlPipeline.state.waitUntilTimeframe(new Timeframe2([
      [
        receipt.feedKey,
        receipt.seq
      ]
    ]));
  }
  async admitDevice({ deviceKey, controlFeedKey, dataFeedKey }) {
    log10("Admitting device:", {
      identityKey: this.identityKey,
      hostDevice: this.deviceKey,
      deviceKey,
      controlFeedKey,
      dataFeedKey
    }, {
      F: __dxlog_file13,
      L: 223,
      S: this,
      C: (f, a) => f(...a)
    });
    const signer = this.getIdentityCredentialSigner();
    const deviceCredential = await signer.createCredential({
      subject: deviceKey,
      assertion: {
        "@type": "dxos.halo.credentials.AuthorizedDevice",
        identityKey: this.identityKey,
        deviceKey
      }
    });
    await writeMessages3(this.controlPipeline.writer, [
      deviceCredential,
      await signer.createCredential({
        subject: controlFeedKey,
        assertion: {
          "@type": "dxos.halo.credentials.AdmittedFeed",
          spaceKey: this.haloSpaceKey,
          deviceKey,
          identityKey: this.identityKey,
          designation: AdmittedFeed2.Designation.CONTROL
        }
      }),
      await signer.createCredential({
        subject: dataFeedKey,
        assertion: {
          "@type": "dxos.halo.credentials.AdmittedFeed",
          spaceKey: this.haloSpaceKey,
          deviceKey,
          identityKey: this.identityKey,
          designation: AdmittedFeed2.Designation.DATA
        }
      })
    ].map((credential) => ({
      credential: {
        credential
      }
    })));
    return deviceCredential;
  }
};
_ts_decorate4([
  trace3.span()
], Identity.prototype, "open", null);
_ts_decorate4([
  trace3.span()
], Identity.prototype, "close", null);
Identity = _ts_decorate4([
  trace3.resource()
], Identity);

// packages/sdk/client-services/src/packlets/identity/identity-manager.ts
import platform from "platform";
import { Event as Event6 } from "@dxos/async";
import { Context as Context5 } from "@dxos/context";
import { createCredentialSignerWithKey as createCredentialSignerWithKey2, createDidFromIdentityKey as createDidFromIdentityKey3, CredentialGenerator } from "@dxos/credentials";
import { invariant as invariant9 } from "@dxos/invariant";
import { PublicKey as PublicKey7 } from "@dxos/keys";
import { log as log11 } from "@dxos/log";
import { trace as trace4 } from "@dxos/protocols";
import { Device, DeviceKind } from "@dxos/protocols/proto/dxos/client/services";
import { AdmittedFeed as AdmittedFeed3, DeviceType } from "@dxos/protocols/proto/dxos/halo/credentials";
import { Gossip as Gossip2, Presence as Presence2 } from "@dxos/teleport-extension-gossip";
import { Timeframe as Timeframe3 } from "@dxos/timeframe";
import { trace as Trace2 } from "@dxos/tracing";
import { isNode, deferFunction as deferFunction2 } from "@dxos/util";
function _ts_decorate5(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file14 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/identity/identity-manager.ts";
var DEVICE_PRESENCE_ANNOUNCE_INTERVAL = 1e4;
var DEVICE_PRESENCE_OFFLINE_TIMEOUT = 2e4;
var IdentityManager = class {
  // TODO(dmaretskyi): Perhaps this should take/generate the peerKey outside of an initialized identity.
  constructor(params) {
    this.stateUpdate = new Event6();
    this._metadataStore = params.metadataStore;
    this._keyring = params.keyring;
    this._feedStore = params.feedStore;
    this._spaceManager = params.spaceManager;
    this._edgeConnection = params.edgeConnection;
    this._edgeFeatures = params.edgeFeatures;
    this._devicePresenceAnnounceInterval = params.devicePresenceAnnounceInterval ?? DEVICE_PRESENCE_ANNOUNCE_INTERVAL;
    this._devicePresenceOfflineTimeout = params.devicePresenceOfflineTimeout ?? DEVICE_PRESENCE_OFFLINE_TIMEOUT;
  }
  get identity() {
    return this._identity;
  }
  async open(ctx) {
    const traceId = PublicKey7.random().toHex();
    log11.trace("dxos.halo.identity-manager.open", trace4.begin({
      id: traceId
    }), {
      F: __dxlog_file14,
      L: 116,
      S: this,
      C: (f, a) => f(...a)
    });
    const identityRecord = this._metadataStore.getIdentityRecord();
    log11("identity record", {
      identityRecord
    }, {
      F: __dxlog_file14,
      L: 119,
      S: this,
      C: (f, a) => f(...a)
    });
    if (identityRecord) {
      this._identity = await this._constructIdentity(identityRecord);
      await this._identity.open(ctx);
      await this._identity.ready();
      log11.trace("dxos.halo.identity", {
        identityKey: identityRecord.identityKey,
        displayName: this._identity.profileDocument?.displayName
      }, {
        F: __dxlog_file14,
        L: 124,
        S: this,
        C: (f, a) => f(...a)
      });
      this.stateUpdate.emit();
    }
    log11.trace("dxos.halo.identity-manager.open", trace4.end({
      id: traceId
    }), {
      F: __dxlog_file14,
      L: 131,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  async close() {
    await this._identity?.close(new Context5(void 0, {
      F: __dxlog_file14,
      L: 135
    }));
  }
  async createIdentity({ profile, deviceProfile } = {}) {
    invariant9(!this._identity, "Identity already exists.", {
      F: __dxlog_file14,
      L: 140,
      S: this,
      A: [
        "!this._identity",
        "'Identity already exists.'"
      ]
    });
    log11("creating identity...", void 0, {
      F: __dxlog_file14,
      L: 141,
      S: this,
      C: (f, a) => f(...a)
    });
    const controlFeedKey = await this._keyring.createKey();
    const identityRecord = {
      identityKey: await this._keyring.createKey(),
      deviceKey: await this._keyring.createKey(),
      haloSpace: {
        key: await this._keyring.createKey(),
        genesisFeedKey: controlFeedKey,
        controlFeedKey,
        dataFeedKey: await this._keyring.createKey()
      }
    };
    const identity = await this._constructIdentity(identityRecord);
    await identity.open(new Context5(void 0, {
      F: __dxlog_file14,
      L: 156
    }));
    {
      const generator = new CredentialGenerator(this._keyring, identityRecord.identityKey, identityRecord.deviceKey);
      invariant9(identityRecord.haloSpace.genesisFeedKey, "Genesis feed key is required.", {
        F: __dxlog_file14,
        L: 160,
        S: this,
        A: [
          "identityRecord.haloSpace.genesisFeedKey",
          "'Genesis feed key is required.'"
        ]
      });
      invariant9(identityRecord.haloSpace.dataFeedKey, "Data feed key is required.", {
        F: __dxlog_file14,
        L: 161,
        S: this,
        A: [
          "identityRecord.haloSpace.dataFeedKey",
          "'Data feed key is required.'"
        ]
      });
      const credentials = [
        // Space genesis.
        ...await generator.createSpaceGenesis(identityRecord.haloSpace.key, identityRecord.haloSpace.genesisFeedKey),
        // Feed admission.
        await generator.createFeedAdmission(identityRecord.haloSpace.key, identityRecord.haloSpace.dataFeedKey, AdmittedFeed3.Designation.DATA)
      ];
      if (profile) {
        credentials.push(await generator.createProfileCredential(profile));
      }
      credentials.push(await generator.createDeviceAuthorization(identityRecord.deviceKey));
      credentials.push(await generator.createDeviceProfile({
        ...this.createDefaultDeviceProfile(),
        ...deviceProfile
      }));
      for (const credential of credentials) {
        await identity.controlPipeline.writer.write({
          credential: {
            credential
          }
        });
      }
    }
    await this._metadataStore.setIdentityRecord(identityRecord);
    this._identity = identity;
    await this._identity.ready();
    log11.trace("dxos.halo.identity", {
      identityKey: identityRecord.identityKey,
      displayName: this._identity.profileDocument?.displayName
    }, {
      F: __dxlog_file14,
      L: 199,
      S: this,
      C: (f, a) => f(...a)
    });
    this.stateUpdate.emit();
    log11("created identity", {
      identityKey: identity.identityKey,
      deviceKey: identity.deviceKey,
      profile: identity.profileDocument
    }, {
      F: __dxlog_file14,
      L: 205,
      S: this,
      C: (f, a) => f(...a)
    });
    return identity;
  }
  // TODO(nf): receive platform info rather than generating it here.
  createDefaultDeviceProfile() {
    let type;
    if (isNode()) {
      type = DeviceType.AGENT;
    } else {
      if (platform.name?.startsWith("iOS") || platform.name?.startsWith("Android")) {
        type = DeviceType.MOBILE;
      } else if (globalThis.__args) {
        type = DeviceType.NATIVE;
      } else {
        type = DeviceType.BROWSER;
      }
    }
    return {
      type,
      platform: platform.name,
      platformVersion: platform.version,
      architecture: typeof platform.os?.architecture === "number" ? String(platform.os.architecture) : void 0,
      os: platform.os?.family,
      osVersion: platform.os?.version
    };
  }
  /**
  * Prepare an identity object as the first step of acceptIdentity flow.
  */
  async prepareIdentity(params) {
    log11("accepting identity", {
      params
    }, {
      F: __dxlog_file14,
      L: 244,
      S: this,
      C: (f, a) => f(...a)
    });
    invariant9(!this._identity, "Identity already exists.", {
      F: __dxlog_file14,
      L: 245,
      S: this,
      A: [
        "!this._identity",
        "'Identity already exists.'"
      ]
    });
    const identityRecord = {
      identityKey: params.identityKey,
      deviceKey: params.deviceKey,
      haloSpace: {
        key: params.haloSpaceKey,
        genesisFeedKey: params.haloGenesisFeedKey,
        controlFeedKey: params.controlFeedKey,
        dataFeedKey: params.dataFeedKey,
        controlTimeframe: params.controlTimeframe
      }
    };
    const identity = await this._constructIdentity(identityRecord);
    await identity.open(new Context5(void 0, {
      F: __dxlog_file14,
      L: 259
    }));
    return {
      identity,
      identityRecord
    };
  }
  /**
  * Accept an existing identity. Expects its device key to be authorized (now or later).
  */
  async acceptIdentity(identity, identityRecord, profile) {
    this._identity = identity;
    await this._identity.ready();
    await this._metadataStore.setIdentityRecord(identityRecord);
    log11.trace("dxos.halo.identity", {
      identityKey: this._identity.identityKey,
      displayName: this._identity.profileDocument?.displayName
    }, {
      F: __dxlog_file14,
      L: 277,
      S: this,
      C: (f, a) => f(...a)
    });
    await this.updateDeviceProfile({
      ...this.createDefaultDeviceProfile(),
      ...profile
    });
    this.stateUpdate.emit();
    log11("accepted identity", {
      identityKey: identity.identityKey,
      deviceKey: identity.deviceKey
    }, {
      F: __dxlog_file14,
      L: 288,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  /**
  * Update the profile document of an existing identity.
  */
  async updateProfile(profile) {
    invariant9(this._identity, "Identity not initialized.", {
      F: __dxlog_file14,
      L: 295,
      S: this,
      A: [
        "this._identity",
        "'Identity not initialized.'"
      ]
    });
    const credential = await this._identity.getIdentityCredentialSigner().createCredential({
      subject: this._identity.identityKey,
      assertion: {
        "@type": "dxos.halo.credentials.IdentityProfile",
        profile
      }
    });
    const receipt = await this._identity.controlPipeline.writer.write({
      credential: {
        credential
      }
    });
    await this._identity.controlPipeline.state.waitUntilTimeframe(new Timeframe3([
      [
        receipt.feedKey,
        receipt.seq
      ]
    ]));
    this.stateUpdate.emit();
    return profile;
  }
  async updateDeviceProfile(profile) {
    invariant9(this._identity, "Identity not initialized.", {
      F: __dxlog_file14,
      L: 312,
      S: this,
      A: [
        "this._identity",
        "'Identity not initialized.'"
      ]
    });
    const credential = await this._identity.getDeviceCredentialSigner().createCredential({
      subject: this._identity.deviceKey,
      assertion: {
        "@type": "dxos.halo.credentials.DeviceProfile",
        profile
      }
    });
    const receipt = await this._identity.controlPipeline.writer.write({
      credential: {
        credential
      }
    });
    await this._identity.controlPipeline.state.waitUntilTimeframe(new Timeframe3([
      [
        receipt.feedKey,
        receipt.seq
      ]
    ]));
    this.stateUpdate.emit();
    return {
      deviceKey: this._identity.deviceKey,
      kind: DeviceKind.CURRENT,
      presence: Device.PresenceState.ONLINE,
      profile
    };
  }
  async _constructIdentity(identityRecord) {
    invariant9(!this._identity, void 0, {
      F: __dxlog_file14,
      L: 338,
      S: this,
      A: [
        "!this._identity",
        ""
      ]
    });
    log11("constructing identity", {
      identityRecord
    }, {
      F: __dxlog_file14,
      L: 339,
      S: this,
      C: (f, a) => f(...a)
    });
    const gossip = new Gossip2({
      localPeerId: identityRecord.deviceKey
    });
    const presence = new Presence2({
      announceInterval: this._devicePresenceAnnounceInterval,
      offlineTimeout: this._devicePresenceOfflineTimeout,
      identityKey: identityRecord.deviceKey,
      gossip
    });
    invariant9(identityRecord.haloSpace.controlFeedKey, void 0, {
      F: __dxlog_file14,
      L: 352,
      S: this,
      A: [
        "identityRecord.haloSpace.controlFeedKey",
        ""
      ]
    });
    const controlFeed = await this._feedStore.openFeed(identityRecord.haloSpace.controlFeedKey, {
      writable: true
    });
    invariant9(identityRecord.haloSpace.dataFeedKey, void 0, {
      F: __dxlog_file14,
      L: 356,
      S: this,
      A: [
        "identityRecord.haloSpace.dataFeedKey",
        ""
      ]
    });
    const dataFeed = await this._feedStore.openFeed(identityRecord.haloSpace.dataFeedKey, {
      writable: true,
      sparse: true
    });
    const space = await this._constructSpace({
      spaceRecord: identityRecord.haloSpace,
      swarmIdentity: {
        identityKey: identityRecord.identityKey,
        peerKey: identityRecord.deviceKey,
        credentialProvider: createAuthProvider(createCredentialSignerWithKey2(this._keyring, identityRecord.deviceKey)),
        credentialAuthenticator: deferFunction2(() => identity.authVerifier.verifier)
      },
      gossip,
      identityKey: identityRecord.identityKey
    });
    await space.setControlFeed(controlFeed);
    await space.setDataFeed(dataFeed);
    const did = await createDidFromIdentityKey3(identityRecord.identityKey);
    const identity = new Identity({
      space,
      presence,
      signer: this._keyring,
      did,
      identityKey: identityRecord.identityKey,
      deviceKey: identityRecord.deviceKey,
      edgeConnection: this._edgeConnection,
      edgeFeatures: this._edgeFeatures
    });
    log11("done", {
      identityKey: identityRecord.identityKey
    }, {
      F: __dxlog_file14,
      L: 387,
      S: this,
      C: (f, a) => f(...a)
    });
    if (identityRecord.haloSpace.controlTimeframe) {
      identity.controlPipeline.state.setTargetTimeframe(identityRecord.haloSpace.controlTimeframe);
    }
    identity.stateUpdate.on(() => this.stateUpdate.emit());
    return identity;
  }
  async _constructSpace({ spaceRecord, swarmIdentity, identityKey, gossip }) {
    return this._spaceManager.constructSpace({
      metadata: {
        key: spaceRecord.key,
        genesisFeedKey: spaceRecord.genesisFeedKey
      },
      swarmIdentity,
      onAuthorizedConnection: (session) => {
        session.addExtension("dxos.mesh.teleport.gossip", gossip.createExtension({
          remotePeerId: session.remotePeerId
        }));
      },
      onAuthFailure: () => {
        log11.warn("auth failure", void 0, {
          F: __dxlog_file14,
          L: 412,
          S: this,
          C: (f, a) => f(...a)
        });
      },
      memberKey: identityKey,
      onDelegatedInvitationStatusChange: async () => {
      },
      onMemberRolesChanged: async () => {
      }
    });
  }
};
_ts_decorate5([
  Trace2.span({
    showInBrowserTimeline: true
  })
], IdentityManager.prototype, "open", null);
IdentityManager = _ts_decorate5([
  Trace2.resource()
], IdentityManager);

// packages/sdk/client-services/src/packlets/identity/identity-service.ts
import { Trigger as Trigger4, sleep as sleep2 } from "@dxos/async";
import { Stream as Stream8 } from "@dxos/codec-protobuf/stream";
import { Resource as Resource6 } from "@dxos/context";
import { createCredential as createCredential2, signPresentation } from "@dxos/credentials";
import { invariant as invariant10 } from "@dxos/invariant";
import { log as log12 } from "@dxos/log";
import { SpaceState as SpaceState3 } from "@dxos/protocols/proto/dxos/client/services";
import { safeAwaitAll } from "@dxos/util";
var __dxlog_file15 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/identity/identity-service.ts";
var DEFAULT_SPACE_SEARCH_TIMEOUT = 1e4;
var IdentityServiceImpl = class extends Resource6 {
  constructor(_identityManager, _recoveryManager, _keyring, _dataSpaceManagerProvider, _createIdentity, _onProfileUpdate) {
    super(), this._identityManager = _identityManager, this._recoveryManager = _recoveryManager, this._keyring = _keyring, this._dataSpaceManagerProvider = _dataSpaceManagerProvider, this._createIdentity = _createIdentity, this._onProfileUpdate = _onProfileUpdate;
  }
  async _open() {
    const identity = this._identityManager.identity;
    if (identity && !identity.defaultSpaceId) {
      await this._fixIdentityWithoutDefaultSpace(identity);
    }
  }
  async createIdentity(request) {
    await this._createIdentity({
      profile: request.profile,
      deviceProfile: request.deviceProfile
    });
    const dataSpaceManager = this._dataSpaceManagerProvider();
    await this._createDefaultSpace(dataSpaceManager);
    return this._getIdentity();
  }
  async _createDefaultSpace(dataSpaceManager) {
    const space = await dataSpaceManager.createDefaultSpace();
    const identity = this._identityManager.identity;
    invariant10(identity, void 0, {
      F: __dxlog_file15,
      L: 61,
      S: this,
      A: [
        "identity",
        ""
      ]
    });
    await identity.updateDefaultSpace(space.id);
  }
  queryIdentity() {
    return new Stream8(({ next }) => {
      const emitNext = () => next({
        identity: this._getIdentity()
      });
      emitNext();
      return this._identityManager.stateUpdate.on(emitNext);
    });
  }
  _getIdentity() {
    if (!this._identityManager.identity) {
      return void 0;
    }
    return {
      did: this._identityManager.identity.did,
      identityKey: this._identityManager.identity.identityKey,
      spaceKey: this._identityManager.identity.space.key,
      profile: this._identityManager.identity.profileDocument
    };
  }
  async updateProfile(profile) {
    invariant10(this._identityManager.identity, "Identity not initialized.", {
      F: __dxlog_file15,
      L: 88,
      S: this,
      A: [
        "this._identityManager.identity",
        "'Identity not initialized.'"
      ]
    });
    await this._identityManager.updateProfile(profile);
    await this._onProfileUpdate?.(this._identityManager.identity.profileDocument);
    return this._getIdentity();
  }
  async createRecoveryCredential(request) {
    return this._recoveryManager.createRecoveryCredential(request);
  }
  async requestRecoveryChallenge() {
    return this._recoveryManager.requestRecoveryChallenge();
  }
  async recoverIdentity(request) {
    if (request.recoveryCode) {
      await this._recoveryManager.recoverIdentity({
        recoveryCode: request.recoveryCode
      });
    } else if (request.external) {
      await this._recoveryManager.recoverIdentityWithExternalSignature(request.external);
    } else if (request.token) {
      await this._recoveryManager.recoverIdentityWithToken({
        token: request.token
      });
    } else {
      throw new Error("Invalid request.");
    }
    return this._getIdentity();
  }
  // TODO(burdon): Rename createPresentation?
  async signPresentation({ presentation, nonce }) {
    invariant10(this._identityManager.identity, "Identity not initialized.", {
      F: __dxlog_file15,
      L: 118,
      S: this,
      A: [
        "this._identityManager.identity",
        "'Identity not initialized.'"
      ]
    });
    return await signPresentation({
      presentation,
      signer: this._keyring,
      signerKey: this._identityManager.identity.deviceKey,
      chain: this._identityManager.identity.deviceCredentialChain,
      nonce
    });
  }
  async createAuthCredential() {
    const identity = this._identityManager.identity;
    invariant10(identity, "Identity not initialized.", {
      F: __dxlog_file15,
      L: 132,
      S: this,
      A: [
        "identity",
        "'Identity not initialized.'"
      ]
    });
    return await createCredential2({
      assertion: {
        "@type": "dxos.halo.credentials.Auth"
      },
      issuer: identity.identityKey,
      subject: identity.identityKey,
      chain: identity.deviceCredentialChain,
      signingKey: identity.deviceKey,
      signer: this._keyring
    });
  }
  async _fixIdentityWithoutDefaultSpace(identity) {
    let recodedDefaultSpace = false;
    let foundDefaultSpace = false;
    const dataSpaceManager = this._dataSpaceManagerProvider();
    const recordedDefaultSpaceTrigger = new Trigger4();
    const allProcessed = safeAwaitAll(dataSpaceManager.spaces.values(), async (space) => {
      if (space.state === SpaceState3.SPACE_CLOSED) {
        await space.open();
        const requiresMigration = space.stateUpdate.waitForCondition(() => space.state === SpaceState3.SPACE_REQUIRES_MIGRATION);
        await Promise.race([
          space.initializeDataPipeline(),
          requiresMigration
        ]);
      }
      if (await dataSpaceManager.isDefaultSpace(space)) {
        if (foundDefaultSpace) {
          log12.warn("Multiple default spaces found. Using the first one.", {
            duplicate: space.id
          }, {
            F: __dxlog_file15,
            L: 166,
            S: this,
            C: (f, a) => f(...a)
          });
          return;
        }
        foundDefaultSpace = true;
        await identity.updateDefaultSpace(space.id);
        recodedDefaultSpace = true;
        recordedDefaultSpaceTrigger.wake();
      }
    }, (err) => {
      log12.catch(err, void 0, {
        F: __dxlog_file15,
        L: 177,
        S: this,
        C: (f, a) => f(...a)
      });
    });
    await Promise.race([
      allProcessed,
      recordedDefaultSpaceTrigger.wait(),
      sleep2(DEFAULT_SPACE_SEARCH_TIMEOUT)
    ]);
    if (!recodedDefaultSpace) {
      await this._createDefaultSpace(dataSpaceManager);
    }
  }
};

// packages/sdk/client-services/src/packlets/spaces/data-space.ts
function _ts_decorate6(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function _ts_add_disposable_resource3(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = function() {
      try {
        inner.call(this);
      } catch (e) {
        return Promise.reject(e);
      }
    };
    env.stack.push({
      value,
      dispose,
      async
    });
  } else if (async) {
    env.stack.push({
      async: true
    });
  }
  return value;
}
function _ts_dispose_resources3(env) {
  var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  };
  return (_ts_dispose_resources3 = function _ts_dispose_resources5(env2) {
    function fail(e) {
      env2.error = env2.hasError ? new _SuppressedError(e, env2.error, "An error was suppressed during disposal.") : e;
      env2.hasError = true;
    }
    var r, s = 0;
    function next() {
      while (r = env2.stack.pop()) {
        try {
          if (!r.async && s === 1) return s = 0, env2.stack.push(r), Promise.resolve().then(next);
          if (r.dispose) {
            var result = r.dispose.call(r.value);
            if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
              fail(e);
              return next();
            });
          } else s |= 1;
        } catch (e) {
          fail(e);
        }
      }
      if (s === 1) return env2.hasError ? Promise.reject(env2.error) : Promise.resolve();
      if (env2.hasError) throw env2.error;
    }
    return next();
  })(env);
}
var __dxlog_file16 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/spaces/data-space.ts";
var DataSpace = class {
  constructor(params) {
    this._ctx = new Context6(void 0, {
      F: __dxlog_file16,
      L: 100
    });
    this._cache = void 0;
    this._edgeFeedReplicator = void 0;
    // TODO(dmaretskyi): Move into Space?
    this._automergeSpaceState = new AutomergeSpaceState((rootUrl) => this._onNewAutomergeRoot(rootUrl));
    this._epochProcessingMutex = new Mutex2();
    this._state = SpaceState4.SPACE_CLOSED;
    this._databaseRoot = null;
    /**
    * Error for _state === SpaceState.SPACE_ERROR.
    */
    this.error = void 0;
    this.stateUpdate = new Event7();
    this.postOpen = new CallbackCollection();
    this.preClose = new CallbackCollection();
    this.metrics = {};
    this._onFeedAdded = async (feed) => {
      await this._edgeFeedReplicator.addFeed(feed);
    };
    this._inner = params.inner;
    this._inner.stateUpdate.on(this._ctx, () => this.stateUpdate.emit());
    this._gossip = params.gossip;
    this._presence = params.presence;
    this._keyring = params.keyring;
    this._feedStore = params.feedStore;
    this._metadataStore = params.metadataStore;
    this._signingContext = params.signingContext;
    this._callbacks = params.callbacks ?? {};
    this._echoHost = params.echoHost;
    this._notarizationPlugin = new NotarizationPlugin({
      spaceId: this._inner.id,
      edgeClient: params.edgeHttpClient,
      edgeFeatures: params.edgeFeatures,
      activeEdgePollingInterval: params.activeEdgeNotarizationPollingInterval
    });
    this.authVerifier = new TrustedKeySetAuthVerifier({
      trustedKeysProvider: () => new ComplexSet3(PublicKey8.hash, Array.from(this._inner.spaceState.members.values()).filter((member) => member.role !== SpaceMember5.Role.REMOVED).map((member) => member.key)),
      update: this._inner.stateUpdate,
      authTimeout: AUTH_TIMEOUT2
    });
    this._cache = params.cache;
    if (params.edgeConnection && params.edgeFeatures?.feedReplicator) {
      this._edgeFeedReplicator = new EdgeFeedReplicator({
        messenger: params.edgeConnection,
        spaceId: this.id
      });
    }
    this._state = params.initialState;
    log13("new state", {
      state: SpaceState4[this._state]
    }, {
      F: __dxlog_file16,
      L: 176,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  get id() {
    return this._inner.id;
  }
  get key() {
    return this._inner.key;
  }
  get isOpen() {
    return this._inner.isOpen;
  }
  get state() {
    return this._state;
  }
  // TODO(burdon): Can we mark this for debugging only?
  get inner() {
    return this._inner;
  }
  get presence() {
    return this._presence;
  }
  get notarizationPlugin() {
    return this._notarizationPlugin;
  }
  get cache() {
    return this._cache;
  }
  get automergeSpaceState() {
    return this._automergeSpaceState;
  }
  get databaseRoot() {
    return this._databaseRoot;
  }
  get _automergeInfo() {
    return {
      rootUrl: this._automergeSpaceState.rootUrl,
      lastEpoch: this._automergeSpaceState.lastEpoch
    };
  }
  async open() {
    if (this._state === SpaceState4.SPACE_CLOSED) {
      await this._open();
    }
  }
  async _open() {
    await this._presence.open();
    await this._gossip.open();
    await this._notarizationPlugin.open();
    await this._inner.spaceState.addCredentialProcessor(this._notarizationPlugin);
    await this._automergeSpaceState.open();
    await this._inner.spaceState.addCredentialProcessor(this._automergeSpaceState);
    if (this._edgeFeedReplicator) {
      this.inner.protocol.feedAdded.append(this._onFeedAdded);
    }
    await this._inner.open(new Context6(void 0, {
      F: __dxlog_file16,
      L: 250
    }));
    await this._inner.startProtocol();
    await this._edgeFeedReplicator?.open();
    this._state = SpaceState4.SPACE_CONTROL_ONLY;
    log13("new state", {
      state: SpaceState4[this._state]
    }, {
      F: __dxlog_file16,
      L: 256,
      S: this,
      C: (f, a) => f(...a)
    });
    this.stateUpdate.emit();
    this.metrics = {};
    this.metrics.open = /* @__PURE__ */ new Date();
    await this.postOpen.callSerial();
  }
  async close() {
    await this._close();
  }
  async _close() {
    await this._callbacks.beforeClose?.();
    await this.preClose.callSerial();
    this._state = SpaceState4.SPACE_CLOSED;
    log13("new state", {
      state: SpaceState4[this._state]
    }, {
      F: __dxlog_file16,
      L: 275,
      S: this,
      C: (f, a) => f(...a)
    });
    await this._ctx.dispose();
    this._ctx = new Context6(void 0, {
      F: __dxlog_file16,
      L: 277
    });
    if (this._edgeFeedReplicator) {
      this.inner.protocol.feedAdded.remove(this._onFeedAdded);
    }
    await this._edgeFeedReplicator?.close();
    await this.authVerifier.close();
    await this._inner.close();
    await this._inner.spaceState.removeCredentialProcessor(this._automergeSpaceState);
    await this._automergeSpaceState.close();
    await this._inner.spaceState.removeCredentialProcessor(this._notarizationPlugin);
    await this._notarizationPlugin.close();
    await this._presence.close();
    await this._gossip.close();
  }
  async postMessage(channel, message) {
    return this._gossip.postMessage(channel, message);
  }
  listen(channel, callback) {
    return this._gossip.listen(channel, callback);
  }
  /**
  * Initialize the data pipeline in a separate task.
  */
  initializeDataPipelineAsync() {
    scheduleTask4(this._ctx, async () => {
      try {
        this.metrics.pipelineInitBegin = /* @__PURE__ */ new Date();
        await this.initializeDataPipeline();
      } catch (err) {
        if (err instanceof CancelledError || err instanceof ContextDisposedError) {
          log13("data pipeline initialization cancelled", err, {
            F: __dxlog_file16,
            L: 315,
            S: this,
            C: (f, a) => f(...a)
          });
          return;
        }
        log13.error("Error initializing data pipeline", err, {
          F: __dxlog_file16,
          L: 319,
          S: this,
          C: (f, a) => f(...a)
        });
        this._state = SpaceState4.SPACE_ERROR;
        log13("new state", {
          state: SpaceState4[this._state]
        }, {
          F: __dxlog_file16,
          L: 321,
          S: this,
          C: (f, a) => f(...a)
        });
        this.error = err;
        this.stateUpdate.emit();
      } finally {
        this.metrics.ready = /* @__PURE__ */ new Date();
      }
    });
  }
  async initializeDataPipeline() {
    if (this._state !== SpaceState4.SPACE_CONTROL_ONLY) {
      throw new SystemError("Invalid operation");
    }
    this._state = SpaceState4.SPACE_INITIALIZING;
    log13("new state", {
      state: SpaceState4[this._state]
    }, {
      F: __dxlog_file16,
      L: 337,
      S: this,
      C: (f, a) => f(...a)
    });
    log13("initializing control pipeline", void 0, {
      F: __dxlog_file16,
      L: 339,
      S: this,
      C: (f, a) => f(...a)
    });
    await this._initializeAndReadControlPipeline();
    await sleep3(1);
    const ready = this.stateUpdate.waitForCondition(() => this._state === SpaceState4.SPACE_READY);
    log13("initializing automerge root", void 0, {
      F: __dxlog_file16,
      L: 347,
      S: this,
      C: (f, a) => f(...a)
    });
    this._automergeSpaceState.startProcessingRootDocs();
    log13("waiting for space to be ready", void 0, {
      F: __dxlog_file16,
      L: 351,
      S: this,
      C: (f, a) => f(...a)
    });
    await ready;
    log13("space is ready", void 0, {
      F: __dxlog_file16,
      L: 353,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  async *getAllDocuments() {
    invariant11(this._databaseRoot, "Space is not ready", {
      F: __dxlog_file16,
      L: 357,
      S: this,
      A: [
        "this._databaseRoot",
        "'Space is not ready'"
      ]
    });
    const doc = this._databaseRoot.doc() ?? failedInvariant3();
    const root = save(doc);
    yield [
      this._databaseRoot.documentId,
      root
    ];
    for (const documentUrl of this._databaseRoot.getAllLinkedDocuments()) {
      const data = await this._echoHost.exportDoc(Context6.default(void 0, {
        F: __dxlog_file16,
        L: 363
      }), documentUrl);
      yield [
        documentUrl.replace(/^automerge:/, ""),
        data
      ];
    }
  }
  async _enterReadyState() {
    await this._callbacks.beforeReady?.();
    this._state = SpaceState4.SPACE_READY;
    log13("new state", {
      state: SpaceState4[this._state]
    }, {
      F: __dxlog_file16,
      L: 372,
      S: this,
      C: (f, a) => f(...a)
    });
    this.stateUpdate.emit();
    await this._callbacks.afterReady?.();
  }
  async _initializeAndReadControlPipeline() {
    await this._inner.controlPipeline.state.waitUntilReachedTargetTimeframe({
      ctx: this._ctx,
      timeout: 1e4,
      breakOnStall: false
    });
    this.metrics.controlPipelineReady = /* @__PURE__ */ new Date();
    await this._createWritableFeeds();
    log13("writable feeds created", void 0, {
      F: __dxlog_file16,
      L: 389,
      S: this,
      C: (f, a) => f(...a)
    });
    this.stateUpdate.emit();
    if (!this.notarizationPlugin.hasWriter) {
      this.notarizationPlugin.setWriter(createMappedFeedWriter((credential) => ({
        credential: {
          credential
        }
      }), this._inner.controlPipeline.writer));
    }
  }
  async _createWritableFeeds() {
    const credentials = [];
    if (!this.inner.controlFeedKey) {
      const controlFeed = await this._feedStore.openFeed(await this._keyring.createKey(), {
        writable: true
      });
      await this.inner.setControlFeed(controlFeed);
      credentials.push(await this._signingContext.credentialSigner.createCredential({
        subject: controlFeed.key,
        assertion: {
          "@type": "dxos.halo.credentials.AdmittedFeed",
          spaceKey: this.key,
          deviceKey: this._signingContext.deviceKey,
          identityKey: this._signingContext.identityKey,
          designation: AdmittedFeed4.Designation.CONTROL
        }
      }));
    }
    if (!this.inner.dataFeedKey) {
      const dataFeed = await this._feedStore.openFeed(await this._keyring.createKey(), {
        writable: true,
        sparse: true
      });
      await this.inner.setDataFeed(dataFeed);
      credentials.push(await this._signingContext.credentialSigner.createCredential({
        subject: dataFeed.key,
        assertion: {
          "@type": "dxos.halo.credentials.AdmittedFeed",
          spaceKey: this.key,
          deviceKey: this._signingContext.deviceKey,
          identityKey: this._signingContext.identityKey,
          designation: AdmittedFeed4.Designation.DATA
        }
      }));
    }
    if (credentials.length > 0) {
      try {
        log13("will notarize credentials for feed admission", {
          count: credentials.length
        }, {
          F: __dxlog_file16,
          L: 447,
          S: this,
          C: (f, a) => f(...a)
        });
        await this.notarizationPlugin.notarize({
          ctx: this._ctx,
          credentials,
          timeout: 0
        });
        log13("credentials notarized", void 0, {
          F: __dxlog_file16,
          L: 451,
          S: this,
          C: (f, a) => f(...a)
        });
      } catch (err) {
        log13.error("error notarizing credentials for feed admission", err, {
          F: __dxlog_file16,
          L: 453,
          S: this,
          C: (f, a) => f(...a)
        });
        throw err;
      }
      await this._metadataStore.setWritableFeedKeys(this.key, this.inner.controlFeedKey, this.inner.dataFeedKey);
    }
  }
  _onNewAutomergeRoot(rootUrl) {
    log13("loading automerge root doc for space", {
      space: this.key,
      rootUrl
    }, {
      F: __dxlog_file16,
      L: 463,
      S: this,
      C: (f, a) => f(...a)
    });
    let handle;
    queueMicrotask(async () => {
      try {
        const env = {
          stack: [],
          error: void 0,
          hasError: false
        };
        try {
          await warnAfterTimeout(5e3, "Automerge root doc load timeout (DataSpace)", async () => {
            handle = await cancelWithContext2(this._ctx, this._echoHost.automergeRepo.find(rootUrl, FIND_PARAMS2));
            await cancelWithContext2(this._ctx, handle.whenReady());
          });
          if (this._ctx.disposed) {
            return;
          }
          const _guard = _ts_add_disposable_resource3(env, await this._epochProcessingMutex.acquire(), false);
          const doc = handle.doc() ?? failedInvariant3();
          if (!doc.access?.spaceKey) {
            handle.change((doc2) => {
              doc2.access = {
                spaceKey: this.key.toHex()
              };
            });
          }
          const root = await this._echoHost.openSpaceRoot(this.id, handle.url);
          this._databaseRoot = root;
          if (root.getVersion() !== SpaceDocVersion2.CURRENT) {
            this._state = SpaceState4.SPACE_REQUIRES_MIGRATION;
            this.stateUpdate.emit();
          } else if (this._state !== SpaceState4.SPACE_READY) {
            await this._enterReadyState();
          } else {
            this.stateUpdate.emit();
          }
        } catch (e) {
          env.error = e;
          env.hasError = true;
        } finally {
          _ts_dispose_resources3(env);
        }
      } catch (err) {
        if (err instanceof ContextDisposedError) {
          return;
        }
        log13.warn("error loading automerge root doc", {
          space: this.key,
          rootUrl,
          err
        }, {
          F: __dxlog_file16,
          L: 510,
          S: this,
          C: (f, a) => f(...a)
        });
      }
    });
  }
  // TODO(dmaretskyi): Use profile from signing context.
  async updateOwnProfile(profile) {
    const credential = await this._signingContext.credentialSigner.createCredential({
      subject: this._signingContext.identityKey,
      assertion: {
        "@type": "dxos.halo.credentials.MemberProfile",
        profile
      }
    });
    await this.inner.controlPipeline.writer.write({
      credential: {
        credential
      }
    });
  }
  async createEpoch(options) {
    const ctx = this._ctx.derive();
    if (!options?.migration) {
      return null;
    }
    const { newRoot } = await runEpochMigration(ctx, {
      echoHost: this._echoHost,
      spaceId: this.id,
      spaceKey: this.key,
      migration: options.migration,
      currentRoot: this._automergeSpaceState.rootUrl ?? null,
      newAutomergeRoot: options.newAutomergeRoot
    });
    const epoch = {
      previousId: this._automergeSpaceState.lastEpoch?.id,
      number: (this._automergeSpaceState.lastEpoch?.subject.assertion.number ?? -1) + 1,
      timeframe: this._automergeSpaceState.lastEpoch?.subject.assertion.timeframe ?? new Timeframe4(),
      automergeRoot: newRoot ?? this._automergeSpaceState.rootUrl
    };
    const credential = await this._signingContext.credentialSigner.createCredential({
      subject: this.key,
      assertion: {
        "@type": "dxos.halo.credentials.Epoch",
        ...epoch
      }
    });
    const receipt = await this.inner.controlPipeline.writer.write({
      credential: {
        credential
      }
    });
    const timeframe = new Timeframe4([
      [
        receipt.feedKey,
        receipt.seq
      ]
    ]);
    await this.inner.controlPipeline.state.waitUntilTimeframe(timeframe);
    await this._echoHost.updateIndexes();
    return {
      credential,
      timeframe
    };
  }
  async activate() {
    if (![
      SpaceState4.SPACE_CLOSED,
      SpaceState4.SPACE_INACTIVE
    ].includes(this._state)) {
      return;
    }
    await this._metadataStore.setSpaceState(this.key, SpaceState4.SPACE_ACTIVE);
    await this._open();
    this.initializeDataPipelineAsync();
  }
  async deactivate() {
    if (this._state === SpaceState4.SPACE_INACTIVE) {
      return;
    }
    await this._metadataStore.setSpaceState(this.key, SpaceState4.SPACE_INACTIVE);
    if (this._state !== SpaceState4.SPACE_CLOSED) {
      await this._close();
    }
    this._state = SpaceState4.SPACE_INACTIVE;
    log13("new state", {
      state: SpaceState4[this._state]
    }, {
      F: __dxlog_file16,
      L: 592,
      S: this,
      C: (f, a) => f(...a)
    });
    this.stateUpdate.emit();
  }
  getEdgeReplicationSetting() {
    return this._metadataStore.getSpaceEdgeReplicationSetting(this.key);
  }
};
_ts_decorate6([
  trace5.info()
], DataSpace.prototype, "_inner", void 0);
_ts_decorate6([
  trace5.info()
], DataSpace.prototype, "id", null);
_ts_decorate6([
  trace5.info()
], DataSpace.prototype, "key", null);
_ts_decorate6([
  trace5.info({
    enum: SpaceState4
  })
], DataSpace.prototype, "state", null);
_ts_decorate6([
  trace5.info({
    depth: null
  })
], DataSpace.prototype, "_automergeInfo", null);
_ts_decorate6([
  synchronized2
], DataSpace.prototype, "open", null);
_ts_decorate6([
  synchronized2
], DataSpace.prototype, "close", null);
_ts_decorate6([
  trace5.span({
    showInBrowserTimeline: true
  })
], DataSpace.prototype, "initializeDataPipeline", null);
_ts_decorate6([
  trace5.span({
    showInBrowserTimeline: true
  })
], DataSpace.prototype, "_initializeAndReadControlPipeline", null);
_ts_decorate6([
  timed(1e4)
], DataSpace.prototype, "_createWritableFeeds", null);
_ts_decorate6([
  synchronized2
], DataSpace.prototype, "activate", null);
_ts_decorate6([
  synchronized2
], DataSpace.prototype, "deactivate", null);
DataSpace = _ts_decorate6([
  trackLeaks2("open", "close"),
  trace5.resource()
], DataSpace);

// packages/sdk/client-services/src/packlets/invitations/device-invitation-protocol.ts
import { getCredentialAssertion as getCredentialAssertion4 } from "@dxos/credentials";
import { invariant as invariant12 } from "@dxos/invariant";
import { AlreadyJoinedError as AlreadyJoinedError2 } from "@dxos/protocols";
import { Invitation as Invitation2 } from "@dxos/protocols/proto/dxos/client/services";
var __dxlog_file17 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/device-invitation-protocol.ts";
var DeviceInvitationProtocol = class {
  constructor(_keyring, _getIdentity, _acceptIdentity) {
    this._keyring = _keyring;
    this._getIdentity = _getIdentity;
    this._acceptIdentity = _acceptIdentity;
  }
  toJSON() {
    return {
      kind: "device"
    };
  }
  checkCanInviteNewMembers() {
    return void 0;
  }
  getInvitationContext() {
    return {
      kind: Invitation2.Kind.DEVICE
    };
  }
  async delegate() {
    throw new Error("delegation not supported");
  }
  async cancelDelegation() {
    throw new Error("delegation not supported");
  }
  async admit(_, request) {
    invariant12(request.device, void 0, {
      F: __dxlog_file17,
      L: 53,
      S: this,
      A: [
        "request.device",
        ""
      ]
    });
    const identity = this._getIdentity();
    const credential = await identity.admitDevice(request.device);
    invariant12(getCredentialAssertion4(credential)["@type"] === "dxos.halo.credentials.AuthorizedDevice", void 0, {
      F: __dxlog_file17,
      L: 56,
      S: this,
      A: [
        "getCredentialAssertion(credential)['@type'] === 'dxos.halo.credentials.AuthorizedDevice'",
        ""
      ]
    });
    return {
      device: {
        identityKey: identity.identityKey,
        haloSpaceKey: identity.haloSpaceKey,
        genesisFeedKey: identity.haloGenesisFeedKey,
        controlTimeframe: identity.controlPipeline.state.timeframe,
        credential
      }
    };
  }
  checkInvitation(invitation) {
    try {
      const identity = this._getIdentity();
      if (identity) {
        return new AlreadyJoinedError2("Currently only one identity per client is supported.");
      }
    } catch {
    }
  }
  createIntroduction() {
    return {};
  }
  async createAdmissionRequest(deviceProfile) {
    const deviceKey = await this._keyring.createKey();
    const controlFeedKey = await this._keyring.createKey();
    const dataFeedKey = await this._keyring.createKey();
    return {
      device: {
        deviceKey,
        controlFeedKey,
        dataFeedKey,
        profile: deviceProfile
      }
    };
  }
  async accept(response, request) {
    invariant12(response.device, void 0, {
      F: __dxlog_file17,
      L: 100,
      S: this,
      A: [
        "response.device",
        ""
      ]
    });
    const { identityKey, haloSpaceKey, genesisFeedKey, controlTimeframe } = response.device;
    invariant12(request.device, void 0, {
      F: __dxlog_file17,
      L: 103,
      S: this,
      A: [
        "request.device",
        ""
      ]
    });
    const { deviceKey, controlFeedKey, dataFeedKey, profile } = request.device;
    await this._acceptIdentity({
      identityKey,
      deviceKey,
      haloSpaceKey,
      haloGenesisFeedKey: genesisFeedKey,
      controlFeedKey,
      dataFeedKey,
      controlTimeframe,
      deviceProfile: profile,
      authorizedDeviceCredential: response.device.credential
    });
    return {
      identityKey
    };
  }
};

// packages/sdk/client-services/src/packlets/invitations/invitations-handler.ts
import { scheduleTask as scheduleTask7, TimeoutError as TimeoutError2 } from "@dxos/async";
import { INVITATION_TIMEOUT, getExpirationTime } from "@dxos/client-protocol";
import { ContextDisposedError as ContextDisposedError3 } from "@dxos/context";
import { createKeyPair, sign as sign2 } from "@dxos/crypto";
import { invariant as invariant17 } from "@dxos/invariant";
import { PublicKey as PublicKey11 } from "@dxos/keys";
import { log as log19 } from "@dxos/log";
import { createTeleportProtocolFactory } from "@dxos/network-manager";
import { InvalidInvitationError, InvalidInvitationExtensionRoleError as InvalidInvitationExtensionRoleError3, trace as trace7 } from "@dxos/protocols";
import { Invitation as Invitation7 } from "@dxos/protocols/proto/dxos/client/services";
import { AuthenticationResponse as AuthenticationResponse2 } from "@dxos/protocols/proto/dxos/halo/invitations";
import { InvitationOptions as InvitationOptions4 } from "@dxos/protocols/proto/dxos/halo/invitations";
import { trace as _trace } from "@dxos/tracing";
import { ComplexSet as ComplexSet5 } from "@dxos/util";

// packages/sdk/client-services/src/packlets/invitations/edge-invitation-handler.ts
import { scheduleMicroTask as scheduleMicroTask3, scheduleTask as scheduleTask5 } from "@dxos/async";
import { sign } from "@dxos/crypto";
import { invariant as invariant13 } from "@dxos/invariant";
import { SpaceId as SpaceId3 } from "@dxos/keys";
import { log as log14 } from "@dxos/log";
import { EdgeAuthChallengeError, EdgeCallFailedError as EdgeCallFailedError2 } from "@dxos/protocols";
import { schema as schema3 } from "@dxos/protocols/proto";
import { Invitation as Invitation4 } from "@dxos/protocols/proto/dxos/client/services";

// packages/sdk/client-services/src/packlets/invitations/utils.ts
import { cancelWithContext as cancelWithContext3, ContextDisposedError as ContextDisposedError2 } from "@dxos/context";
import { Invitation as Invitation3 } from "@dxos/protocols/proto/dxos/client/services";
var stateToString = (state) => {
  return Object.entries(Invitation3.State).find(([key, val]) => val === state)?.[0] ?? "unknown";
};
var computeExpirationTime = (invitation) => {
  if (!invitation.lifetime) {
    return;
  }
  return new Date((invitation.created?.getTime() ?? Date.now()) + invitation.lifetime * 1e3);
};
var tryAcquireBeforeContextDisposed = async (ctx, mutex) => {
  let guard;
  return cancelWithContext3(ctx, (async () => {
    guard = await mutex.acquire();
    if (ctx.disposed) {
      guard.release();
      guard = void 0;
      throw new ContextDisposedError2();
    }
    return guard;
  })());
};

// packages/sdk/client-services/src/packlets/invitations/edge-invitation-handler.ts
var __dxlog_file18 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/edge-invitation-handler.ts";
var MAX_RETRIES_PER_INVITATION = 5;
var DEFAULT_REQUEST_RETRY_INTERVAL_MS = 3e3;
var DEFAULT_REQUEST_RETRY_JITTER_MS = 500;
var EdgeInvitationHandler = class {
  constructor(config, _client, _callbacks) {
    this._client = _client;
    this._callbacks = _callbacks;
    this._retryInterval = config?.retryInterval ?? DEFAULT_REQUEST_RETRY_INTERVAL_MS;
    this._retryJitter = config?.retryJitter ?? DEFAULT_REQUEST_RETRY_JITTER_MS;
  }
  handle(ctx, guardedState, protocol, deviceProfile) {
    if (!this._client) {
      log14("edge disabled", void 0, {
        F: __dxlog_file18,
        L: 66,
        S: this,
        C: (f, a) => f(...a)
      });
      return;
    }
    const invitation = guardedState.current;
    const spaceId = invitation.spaceId;
    const canBeHandledByEdge = invitation.authMethod !== Invitation4.AuthMethod.SHARED_SECRET && invitation.type === Invitation4.Type.DELEGATED && invitation.kind === Invitation4.Kind.SPACE && spaceId != null && SpaceId3.isValid(spaceId);
    if (!canBeHandledByEdge) {
      log14("invitation could not be handled by edge", {
        invitation
      }, {
        F: __dxlog_file18,
        L: 80,
        S: this,
        C: (f, a) => f(...a)
      });
      return;
    }
    ctx.onDispose(() => {
      this._flowLock?.release();
      this._flowLock = void 0;
    });
    let requestCount = 0;
    const tryHandleInvitation = async () => {
      requestCount++;
      const admissionRequest = await protocol.createAdmissionRequest(deviceProfile);
      if (admissionRequest.space) {
        try {
          await this._handleSpaceInvitationFlow(ctx, guardedState, admissionRequest.space, spaceId);
        } catch (error) {
          if (error instanceof EdgeCallFailedError2) {
            log14.info("join space with edge unsuccessful", {
              reason: error.message,
              retryable: error.isRetryable,
              after: error.retryAfterMs ?? this._calculateNextRetryMs()
            }, {
              F: __dxlog_file18,
              L: 98,
              S: this,
              C: (f, a) => f(...a)
            });
            if (error.isRetryable && requestCount < MAX_RETRIES_PER_INVITATION) {
              scheduleTask5(ctx, tryHandleInvitation, error.retryAfterMs ?? this._calculateNextRetryMs());
            }
          } else if (requestCount < MAX_RETRIES_PER_INVITATION) {
            log14.info("failed to handle invitation with edge", {
              error
            }, {
              F: __dxlog_file18,
              L: 107,
              S: this,
              C: (f, a) => f(...a)
            });
            scheduleTask5(ctx, tryHandleInvitation, this._calculateNextRetryMs());
          }
        }
      }
    };
    scheduleMicroTask3(ctx, tryHandleInvitation);
  }
  async _handleSpaceInvitationFlow(ctx, guardedState, admissionRequest, spaceId) {
    try {
      log14("edge invitation flow", void 0, {
        F: __dxlog_file18,
        L: 123,
        S: this,
        C: (f, a) => f(...a)
      });
      this._flowLock = await tryAcquireBeforeContextDisposed(ctx, guardedState.mutex);
      log14.verbose("edge invitation flow acquired the lock", void 0, {
        F: __dxlog_file18,
        L: 125,
        S: this,
        C: (f, a) => f(...a)
      });
      guardedState.set(this, Invitation4.State.CONNECTING);
      const response = await this._joinSpaceByInvitation(guardedState, spaceId, {
        identityKey: admissionRequest.identityKey.toHex(),
        invitationId: guardedState.current.invitationId
      });
      const admissionResponse = await this._mapToAdmissionResponse(response);
      await this._callbacks.onInvitationSuccess(admissionResponse, {
        space: admissionRequest
      });
    } catch (error) {
      guardedState.set(this, Invitation4.State.ERROR);
      throw error;
    } finally {
      this._flowLock?.release();
      this._flowLock = void 0;
    }
  }
  async _mapToAdmissionResponse(edgeResponse) {
    const credentialBytes = Buffer.from(edgeResponse.spaceMemberCredential, "base64");
    const codec = schema3.getCodecForType("dxos.halo.credentials.Credential");
    return {
      space: {
        credential: codec.decode(credentialBytes)
      }
    };
  }
  async _joinSpaceByInvitation(guardedState, spaceId, request) {
    invariant13(this._client, void 0, {
      F: __dxlog_file18,
      L: 160,
      S: this,
      A: [
        "this._client",
        ""
      ]
    });
    try {
      return await this._client.joinSpaceByInvitation(spaceId, request);
    } catch (error) {
      if (error instanceof EdgeAuthChallengeError) {
        const publicKey = guardedState.current.guestKeypair?.publicKey;
        const privateKey = guardedState.current.guestKeypair?.privateKey;
        if (!privateKey || !publicKey) {
          throw error;
        }
        const signature = sign(Buffer.from(error.challenge, "base64"), privateKey);
        return this._client.joinSpaceByInvitation(spaceId, {
          ...request,
          signature: Buffer.from(signature).toString("base64")
        });
      } else {
        throw error;
      }
    }
  }
  hasFlowLock() {
    return this._flowLock != null;
  }
  _calculateNextRetryMs() {
    return this._retryInterval + Math.random() * this._retryJitter;
  }
};

// packages/sdk/client-services/src/packlets/invitations/invitation-guest-extenstion.ts
import { Trigger as Trigger5 } from "@dxos/async";
import { cancelWithContext as cancelWithContext4, Context as Context7 } from "@dxos/context";
import { invariant as invariant14 } from "@dxos/invariant";
import { log as log15 } from "@dxos/log";
import { InvalidInvitationExtensionRoleError } from "@dxos/protocols";
import { schema as schema4 } from "@dxos/protocols/proto";
import { InvitationOptions } from "@dxos/protocols/proto/dxos/halo/invitations";
import { RpcExtension as RpcExtension2 } from "@dxos/teleport";
var __dxlog_file19 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/invitation-guest-extenstion.ts";
var OPTIONS_TIMEOUT = 1e4;
var InvitationGuestExtension = class extends RpcExtension2 {
  constructor(_invitationFlowMutex, _callbacks) {
    super({
      requested: {
        InvitationHostService: schema4.getService("dxos.halo.invitations.InvitationHostService")
      },
      exposed: {
        InvitationHostService: schema4.getService("dxos.halo.invitations.InvitationHostService")
      }
    }), this._invitationFlowMutex = _invitationFlowMutex, this._callbacks = _callbacks, this._ctx = new Context7(void 0, {
      F: __dxlog_file19,
      L: 38
    }), this._remoteOptionsTrigger = new Trigger5(), this._invitationFlowLock = null;
  }
  hasFlowLock() {
    return this._invitationFlowLock != null;
  }
  async getHandlers() {
    return {
      InvitationHostService: {
        options: async (options) => {
          invariant14(!this._remoteOptions, "Remote options already set.", {
            F: __dxlog_file19,
            L: 68,
            S: this,
            A: [
              "!this._remoteOptions",
              "'Remote options already set.'"
            ]
          });
          this._remoteOptions = options;
          this._remoteOptionsTrigger.wake();
        },
        introduce: () => {
          throw new Error("Method not allowed.");
        },
        authenticate: () => {
          throw new Error("Method not allowed.");
        },
        admit: () => {
          throw new Error("Method not allowed.");
        }
      }
    };
  }
  async onOpen(context) {
    await super.onOpen(context);
    try {
      log15.verbose("guest acquire lock", void 0, {
        F: __dxlog_file19,
        L: 89,
        S: this,
        C: (f, a) => f(...a)
      });
      this._invitationFlowLock = await tryAcquireBeforeContextDisposed(this._ctx, this._invitationFlowMutex);
      log15.verbose("guest lock acquired", void 0, {
        F: __dxlog_file19,
        L: 91,
        S: this,
        C: (f, a) => f(...a)
      });
      await cancelWithContext4(this._ctx, this.rpc.InvitationHostService.options({
        role: InvitationOptions.Role.GUEST
      }));
      log15.verbose("options sent", void 0, {
        F: __dxlog_file19,
        L: 96,
        S: this,
        C: (f, a) => f(...a)
      });
      await cancelWithContext4(this._ctx, this._remoteOptionsTrigger.wait({
        timeout: OPTIONS_TIMEOUT
      }));
      log15.verbose("options received", void 0, {
        F: __dxlog_file19,
        L: 98,
        S: this,
        C: (f, a) => f(...a)
      });
      if (this._remoteOptions?.role !== InvitationOptions.Role.HOST) {
        throw new InvalidInvitationExtensionRoleError(void 0, {
          expected: InvitationOptions.Role.HOST,
          remoteOptions: this._remoteOptions,
          remotePeerId: context.remotePeerId
        });
      }
      this._callbacks.onOpen(this._ctx, context);
    } catch (err) {
      if (this._invitationFlowLock != null) {
        this._callbacks.onError(err);
      }
      if (!this._ctx.disposed) {
        context.close(err);
      }
    }
  }
  async onClose() {
    await this._destroy();
  }
  async onAbort() {
    await this._destroy();
  }
  async _destroy() {
    await this._ctx.dispose();
    if (this._invitationFlowLock != null) {
      this._invitationFlowLock.release();
      this._invitationFlowLock = null;
      log15.verbose("invitation flow lock released", void 0, {
        F: __dxlog_file19,
        L: 131,
        S: this,
        C: (f, a) => f(...a)
      });
    }
  }
};

// packages/sdk/client-services/src/packlets/invitations/invitation-host-extension.ts
import { Trigger as Trigger6, scheduleTask as scheduleTask6 } from "@dxos/async";
import { cancelWithContext as cancelWithContext5, Context as Context8 } from "@dxos/context";
import { randomBytes, verify } from "@dxos/crypto";
import { invariant as invariant15, InvariantViolation } from "@dxos/invariant";
import { PublicKey as PublicKey9 } from "@dxos/keys";
import { log as log16 } from "@dxos/log";
import { InvalidInvitationExtensionRoleError as InvalidInvitationExtensionRoleError2, trace as trace6 } from "@dxos/protocols";
import { schema as schema5 } from "@dxos/protocols/proto";
import { Invitation as Invitation5 } from "@dxos/protocols/proto/dxos/client/services";
import { AuthenticationResponse, InvitationOptions as InvitationOptions2 } from "@dxos/protocols/proto/dxos/halo/invitations";
import { RpcExtension as RpcExtension3 } from "@dxos/teleport";
var __dxlog_file20 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/invitation-host-extension.ts";
var OPTIONS_TIMEOUT2 = 1e4;
var MAX_OTP_ATTEMPTS = 3;
var InvitationHostExtension = class extends RpcExtension3 {
  constructor(_invitationFlowMutex, _callbacks) {
    super({
      requested: {
        InvitationHostService: schema5.getService("dxos.halo.invitations.InvitationHostService")
      },
      exposed: {
        InvitationHostService: schema5.getService("dxos.halo.invitations.InvitationHostService")
      }
    }), this._invitationFlowMutex = _invitationFlowMutex, this._callbacks = _callbacks, this._ctx = new Context8(void 0, {
      F: __dxlog_file20,
      L: 57
    }), this._remoteOptionsTrigger = new Trigger6(), this._challenge = void 0, this.guestProfile = void 0, this.authenticationPassed = false, this.authenticationRetry = 0, this.completedTrigger = new Trigger6(), this._invitationFlowLock = null;
  }
  hasFlowLock() {
    return this._invitationFlowLock != null;
  }
  async getHandlers() {
    return {
      // TODO(dmaretskyi): For now this is just forwarding the data to callbacks since we don't have session-specific logic.
      // Perhaps in the future we will have more complex logic here.
      InvitationHostService: {
        options: async (options) => {
          invariant15(!this._remoteOptions, "Remote options already set.", {
            F: __dxlog_file20,
            L: 106,
            S: this,
            A: [
              "!this._remoteOptions",
              "'Remote options already set.'"
            ]
          });
          this._remoteOptions = options;
          this._remoteOptionsTrigger.wake();
        },
        introduce: async (request) => {
          const { profile, invitationId } = request;
          const traceId = PublicKey9.random().toHex();
          log16.trace("dxos.sdk.invitation-handler.host.introduce", trace6.begin({
            id: traceId
          }), {
            F: __dxlog_file20,
            L: 114,
            S: this,
            C: (f, a) => f(...a)
          });
          const invitation = this._requireActiveInvitation();
          this._assertInvitationState(Invitation5.State.CONNECTED);
          if (invitationId !== invitation?.invitationId) {
            log16.warn("incorrect invitationId", {
              expected: invitation.invitationId,
              actual: invitationId
            }, {
              F: __dxlog_file20,
              L: 119,
              S: this,
              C: (f, a) => f(...a)
            });
            this._callbacks.onError(new Error("Incorrect invitationId."));
            scheduleTask6(this._ctx, () => this.close());
            return {
              authMethod: Invitation5.AuthMethod.NONE
            };
          }
          log16.verbose("guest introduced themselves", {
            guestProfile: profile
          }, {
            F: __dxlog_file20,
            L: 128,
            S: this,
            C: (f, a) => f(...a)
          });
          this.guestProfile = profile;
          this._callbacks.onStateUpdate(Invitation5.State.READY_FOR_AUTHENTICATION);
          this._challenge = invitation.authMethod === Invitation5.AuthMethod.KNOWN_PUBLIC_KEY ? randomBytes(32) : void 0;
          log16.trace("dxos.sdk.invitation-handler.host.introduce", trace6.end({
            id: traceId
          }), {
            F: __dxlog_file20,
            L: 134,
            S: this,
            C: (f, a) => f(...a)
          });
          return {
            authMethod: invitation.authMethod,
            challenge: this._challenge
          };
        },
        authenticate: async ({ authCode: code, signedChallenge }) => {
          const traceId = PublicKey9.random().toHex();
          log16.trace("dxos.sdk.invitation-handler.host.authenticate", trace6.begin({
            id: traceId
          }), {
            F: __dxlog_file20,
            L: 143,
            S: this,
            C: (f, a) => f(...a)
          });
          const invitation = this._requireActiveInvitation();
          log16.verbose("received authentication request", {
            authCode: code
          }, {
            F: __dxlog_file20,
            L: 146,
            S: this,
            C: (f, a) => f(...a)
          });
          let status = AuthenticationResponse.Status.OK;
          this._assertInvitationState([
            Invitation5.State.AUTHENTICATING,
            Invitation5.State.READY_FOR_AUTHENTICATION
          ]);
          this._callbacks.onStateUpdate(Invitation5.State.AUTHENTICATING);
          switch (invitation.authMethod) {
            case Invitation5.AuthMethod.NONE: {
              log16("authentication not required", void 0, {
                F: __dxlog_file20,
                L: 154,
                S: this,
                C: (f, a) => f(...a)
              });
              return {
                status: AuthenticationResponse.Status.OK
              };
            }
            case Invitation5.AuthMethod.SHARED_SECRET: {
              if (invitation.authCode) {
                if (this.authenticationRetry++ > MAX_OTP_ATTEMPTS) {
                  status = AuthenticationResponse.Status.INVALID_OPT_ATTEMPTS;
                } else if (code !== invitation.authCode) {
                  status = AuthenticationResponse.Status.INVALID_OTP;
                } else {
                  this.authenticationPassed = true;
                }
              }
              break;
            }
            case Invitation5.AuthMethod.KNOWN_PUBLIC_KEY: {
              if (!invitation.guestKeypair) {
                status = AuthenticationResponse.Status.INTERNAL_ERROR;
                break;
              }
              const isSignatureValid = this._challenge && verify(this._challenge, Buffer.from(signedChallenge ?? []), invitation.guestKeypair.publicKey.asBuffer());
              if (isSignatureValid) {
                this.authenticationPassed = true;
              } else {
                status = AuthenticationResponse.Status.INVALID_SIGNATURE;
              }
              break;
            }
            default: {
              log16.error("invalid authentication method", {
                authMethod: invitation.authMethod
              }, {
                F: __dxlog_file20,
                L: 192,
                S: this,
                C: (f, a) => f(...a)
              });
              status = AuthenticationResponse.Status.INTERNAL_ERROR;
              break;
            }
          }
          if (![
            AuthenticationResponse.Status.OK,
            AuthenticationResponse.Status.INVALID_OTP
          ].includes(status)) {
            this._callbacks.onError(new Error(`Authentication failed, with status=${status}`));
            scheduleTask6(this._ctx, () => this.close());
            return {
              status
            };
          }
          log16.trace("dxos.sdk.invitation-handler.host.authenticate", trace6.end({
            id: traceId,
            data: {
              status
            }
          }), {
            F: __dxlog_file20,
            L: 204,
            S: this,
            C: (f, a) => f(...a)
          });
          return {
            status
          };
        },
        admit: async (request) => {
          const traceId = PublicKey9.random().toHex();
          log16.trace("dxos.sdk.invitation-handler.host.admit", trace6.begin({
            id: traceId
          }), {
            F: __dxlog_file20,
            L: 210,
            S: this,
            C: (f, a) => f(...a)
          });
          const invitation = this._requireActiveInvitation();
          try {
            if (isAuthenticationRequired(invitation)) {
              this._assertInvitationState(Invitation5.State.AUTHENTICATING);
              if (!this.authenticationPassed) {
                throw new Error("Not authenticated");
              }
            }
            const response = await this._callbacks.admit(request);
            log16.trace("dxos.sdk.invitation-handler.host.admit", trace6.end({
              id: traceId
            }), {
              F: __dxlog_file20,
              L: 224,
              S: this,
              C: (f, a) => f(...a)
            });
            return response;
          } catch (err) {
            this._callbacks.onError(err);
            throw err;
          }
        }
      }
    };
  }
  async onOpen(context) {
    await super.onOpen(context);
    try {
      log16.verbose("host acquire lock", void 0, {
        F: __dxlog_file20,
        L: 239,
        S: this,
        C: (f, a) => f(...a)
      });
      this._invitationFlowLock = await tryAcquireBeforeContextDisposed(this._ctx, this._invitationFlowMutex);
      log16.verbose("host lock acquired", void 0, {
        F: __dxlog_file20,
        L: 241,
        S: this,
        C: (f, a) => f(...a)
      });
      this._callbacks.onStateUpdate(Invitation5.State.CONNECTING);
      await this.rpc.InvitationHostService.options({
        role: InvitationOptions2.Role.HOST
      });
      log16.verbose("options sent", void 0, {
        F: __dxlog_file20,
        L: 244,
        S: this,
        C: (f, a) => f(...a)
      });
      await cancelWithContext5(this._ctx, this._remoteOptionsTrigger.wait({
        timeout: OPTIONS_TIMEOUT2
      }));
      log16.verbose("options received", void 0, {
        F: __dxlog_file20,
        L: 246,
        S: this,
        C: (f, a) => f(...a)
      });
      if (this._remoteOptions?.role !== InvitationOptions2.Role.GUEST) {
        throw new InvalidInvitationExtensionRoleError2(void 0, {
          expected: InvitationOptions2.Role.GUEST,
          remoteOptions: this._remoteOptions,
          remotePeerId: context.remotePeerId
        });
      }
      this._callbacks.onStateUpdate(Invitation5.State.CONNECTED);
      this._callbacks.onOpen(this._ctx, context);
    } catch (err) {
      if (this._invitationFlowLock != null) {
        this._callbacks.onError(err);
      }
      if (!this._ctx.disposed) {
        context.close(err);
      }
    }
  }
  _requireActiveInvitation() {
    const invitation = this._callbacks.activeInvitation;
    if (invitation == null) {
      scheduleTask6(this._ctx, () => this.close());
      throw new Error("Active invitation not found");
    }
    return invitation;
  }
  _assertInvitationState(stateOrMany) {
    const invitation = this._requireActiveInvitation();
    const validStates = Array.isArray(stateOrMany) ? stateOrMany : [
      stateOrMany
    ];
    if (!validStates.includes(invitation.state)) {
      scheduleTask6(this._ctx, () => this.close());
      throw new InvariantViolation(`Expected ${stateToString(invitation.state)} to be one of [${validStates.map(stateToString).join(", ")}]`);
    }
  }
  async onClose() {
    await this._destroy();
  }
  async onAbort() {
    await this._destroy();
  }
  async _destroy() {
    await this._ctx.dispose();
    if (this._invitationFlowLock != null) {
      this._invitationFlowLock?.release();
      this._invitationFlowLock = null;
      log16.verbose("invitation flow lock released", void 0, {
        F: __dxlog_file20,
        L: 299,
        S: this,
        C: (f, a) => f(...a)
      });
    }
  }
};
var isAuthenticationRequired = (invitation) => invitation.authMethod !== Invitation5.AuthMethod.NONE;

// packages/sdk/client-services/src/packlets/invitations/invitation-state.ts
import { Mutex as Mutex3 } from "@dxos/async";
import { log as log17 } from "@dxos/log";
import { Invitation as Invitation6 } from "@dxos/protocols/proto/dxos/client/services";
var __dxlog_file21 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/invitation-state.ts";
var createGuardedInvitationState = (ctx, invitation, stream) => {
  const mutex = new Mutex3();
  let lastActiveLockHolder = null;
  let currentInvitation = {
    ...invitation
  };
  const isStateChangeAllowed = (lockHolder) => {
    if (ctx.disposed || lockHolder !== null && mutex.isLocked() && !lockHolder.hasFlowLock()) {
      return false;
    }
    return lockHolder == null || lastActiveLockHolder !== lockHolder || isNonTerminalState(currentInvitation.state);
  };
  return {
    mutex,
    get current() {
      return currentInvitation;
    },
    // disposing context prevents any further state updates
    complete: (newState) => {
      logStateUpdate(currentInvitation, void 0, invitation.state);
      currentInvitation = {
        ...currentInvitation,
        ...newState
      };
      stream.next(currentInvitation);
      return ctx.dispose();
    },
    set: (lockHolder, newState) => {
      if (isStateChangeAllowed(lockHolder)) {
        logStateUpdate(currentInvitation, lockHolder, newState);
        currentInvitation = {
          ...currentInvitation,
          state: newState
        };
        stream.next(currentInvitation);
        lastActiveLockHolder = lockHolder;
        return true;
      }
      return false;
    },
    error: (lockHolder, error) => {
      if (isStateChangeAllowed(lockHolder)) {
        logStateUpdate(currentInvitation, lockHolder, Invitation6.State.ERROR, error);
        currentInvitation = {
          ...currentInvitation,
          state: Invitation6.State.ERROR
        };
        stream.next(currentInvitation);
        stream.error(error);
        lastActiveLockHolder = lockHolder;
        return true;
      }
      return false;
    }
  };
};
var logStateUpdate = (invitation, actor, newState, error) => {
  const logContext = {
    invitationId: invitation.invitationId,
    actor: actor?.constructor.name,
    newState: stateToString(newState),
    oldState: stateToString(invitation.state),
    error: error?.message,
    errorStack: error?.stack
  };
  if (isNonTerminalState(newState)) {
    log17.verbose("dxos.sdk.invitations-handler.state.update", logContext, {
      F: __dxlog_file21,
      L: 98,
      S: void 0,
      C: (f, a) => f(...a)
    });
  } else {
    log17.info("dxos.sdk.invitations-handler.state.update", logContext, {
      F: __dxlog_file21,
      L: 100,
      S: void 0,
      C: (f, a) => f(...a)
    });
  }
};
var isNonTerminalState = (currentState) => {
  return ![
    Invitation6.State.SUCCESS,
    Invitation6.State.ERROR,
    Invitation6.State.CANCELLED,
    Invitation6.State.TIMEOUT,
    Invitation6.State.EXPIRED
  ].includes(currentState);
};

// packages/sdk/client-services/src/packlets/invitations/invitation-topology.ts
import { invariant as invariant16 } from "@dxos/invariant";
import { PublicKey as PublicKey10 } from "@dxos/keys";
import { log as log18 } from "@dxos/log";
import { InvitationOptions as InvitationOptions3 } from "@dxos/protocols/proto/dxos/halo/invitations";
import { ComplexSet as ComplexSet4 } from "@dxos/util";
var __dxlog_file22 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/invitation-topology.ts";
var InvitationTopology = class {
  constructor(_role) {
    this._role = _role;
    this._seenPeers = new ComplexSet4(PublicKey10.hash);
  }
  init(controller) {
    invariant16(!this._controller, "Already initialized.", {
      F: __dxlog_file22,
      L: 42,
      S: this,
      A: [
        "!this._controller",
        "'Already initialized.'"
      ]
    });
    this._controller = controller;
  }
  update() {
    invariant16(this._controller, "Not initialized.", {
      F: __dxlog_file22,
      L: 47,
      S: this,
      A: [
        "this._controller",
        "'Not initialized.'"
      ]
    });
    const { ownPeerId, candidates, connected, allPeers } = this._controller.getState();
    if (this._role === InvitationOptions3.Role.GUEST) {
      return;
    }
    if (connected.length > 0) {
      connected.forEach((c) => this._seenPeers.add(c));
      return;
    }
    const firstUnknownPeer = candidates.find((peerId) => !this._seenPeers.has(peerId));
    this._seenPeers = new ComplexSet4(PublicKey10.hash, allPeers.filter((peerId) => this._seenPeers.has(peerId)));
    if (firstUnknownPeer != null) {
      log18("invitation connect", {
        ownPeerId,
        remotePeerId: firstUnknownPeer
      }, {
        F: __dxlog_file22,
        L: 69,
        S: this,
        C: (f, a) => f(...a)
      });
      this._controller.connect(firstUnknownPeer);
      this._seenPeers.add(firstUnknownPeer);
    }
  }
  async onOffer(peer) {
    invariant16(this._controller, "Not initialized.", {
      F: __dxlog_file22,
      L: 76,
      S: this,
      A: [
        "this._controller",
        "'Not initialized.'"
      ]
    });
    return !this._seenPeers.has(peer);
  }
  async destroy() {
    this._seenPeers.clear();
  }
  toString() {
    return `InvitationTopology(${this._role === InvitationOptions3.Role.GUEST ? "guest" : "host"})`;
  }
};

// packages/sdk/client-services/src/packlets/invitations/invitations-handler.ts
var __dxlog_file23 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/invitations-handler.ts";
var metrics = _trace.metrics;
var MAX_DELEGATED_INVITATION_HOST_TRIES = 3;
var InvitationsHandler = class {
  /**
  * @internal
  */
  constructor(_networkManager, _edgeClient, _connectionParams) {
    this._networkManager = _networkManager;
    this._edgeClient = _edgeClient;
    this._connectionParams = _connectionParams;
  }
  handleInvitationFlow(ctx, stream, protocol, invitation) {
    log19.verbose("dxos.sdk.invitations-handler.handleInvitationFlow", {
      state: invitation.state,
      invitationId: invitation.invitationId,
      kind: invitation.kind,
      type: invitation.type
    }, {
      F: __dxlog_file23,
      L: 83,
      S: this,
      C: (f, a) => f(...a)
    });
    metrics.increment("dxos.invitation.host");
    const guardedState = createGuardedInvitationState(ctx, invitation, stream);
    const createExtension = () => {
      const extension = new InvitationHostExtension(guardedState.mutex, {
        get activeInvitation() {
          return ctx.disposed ? null : guardedState.current;
        },
        onStateUpdate: (newState) => {
          if (newState !== Invitation7.State.ERROR && newState !== Invitation7.State.TIMEOUT) {
            guardedState.set(extension, newState);
          }
          return guardedState.current;
        },
        admit: async (admissionRequest) => {
          try {
            log19.verbose("dxos.sdk.invitations-handler.host.admit", {
              invitationId: invitation.invitationId,
              ...protocol.toJSON()
            }, {
              F: __dxlog_file23,
              L: 107,
              S: this,
              C: (f, a) => f(...a)
            });
            const deviceKey = admissionRequest.device?.deviceKey ?? admissionRequest.space?.deviceKey;
            invariant17(deviceKey, void 0, {
              F: __dxlog_file23,
              L: 112,
              S: this,
              A: [
                "deviceKey",
                ""
              ]
            });
            const admissionResponse = await protocol.admit(invitation, admissionRequest, extension.guestProfile);
            extension.completedTrigger.wake(deviceKey);
            return admissionResponse;
          } catch (err) {
            guardedState.error(extension, err);
            throw err;
          }
        },
        onOpen: (connectionCtx, extensionsCtx) => {
          let admitted = false;
          connectionCtx.onDispose(() => {
            if (!admitted) {
              guardedState.set(extension, Invitation7.State.CONNECTING);
            }
          });
          scheduleTask7(connectionCtx, async () => {
            const traceId = PublicKey11.random().toHex();
            try {
              log19.trace("dxos.sdk.invitations-handler.host.onOpen", trace7.begin({
                id: traceId
              }), {
                F: __dxlog_file23,
                L: 137,
                S: this,
                C: (f, a) => f(...a)
              });
              log19.verbose("connected", {
                ...protocol.toJSON()
              }, {
                F: __dxlog_file23,
                L: 138,
                S: this,
                C: (f, a) => f(...a)
              });
              const deviceKey = await extension.completedTrigger.wait({
                timeout: invitation.timeout
              });
              log19.verbose("admitted guest", {
                guest: deviceKey,
                ...protocol.toJSON()
              }, {
                F: __dxlog_file23,
                L: 140,
                S: this,
                C: (f, a) => f(...a)
              });
              guardedState.set(extension, Invitation7.State.SUCCESS);
              metrics.increment("dxos.invitation.success");
              log19.trace("dxos.sdk.invitations-handler.host.onOpen", trace7.end({
                id: traceId
              }), {
                F: __dxlog_file23,
                L: 143,
                S: this,
                C: (f, a) => f(...a)
              });
              admitted = true;
              if (!invitation.multiUse) {
                await ctx.dispose();
              }
            } catch (err) {
              const stateChanged = guardedState.set(extension, Invitation7.State.CONNECTING);
              if (err instanceof TimeoutError2) {
                if (stateChanged) {
                  metrics.increment("dxos.invitation.timeout");
                  log19.verbose("timeout", {
                    ...protocol.toJSON()
                  }, {
                    F: __dxlog_file23,
                    L: 154,
                    S: this,
                    C: (f, a) => f(...a)
                  });
                }
              } else {
                if (stateChanged) {
                  metrics.increment("dxos.invitation.failed");
                  log19.error("failed", err, {
                    F: __dxlog_file23,
                    L: 159,
                    S: this,
                    C: (f, a) => f(...a)
                  });
                }
              }
              log19.trace("dxos.sdk.invitations-handler.host.onOpen", trace7.error({
                id: traceId,
                error: err
              }), {
                F: __dxlog_file23,
                L: 162,
                S: this,
                C: (f, a) => f(...a)
              });
              extensionsCtx.close(err);
            }
          });
        },
        onError: (err) => {
          const stateChanged = guardedState.set(extension, Invitation7.State.CONNECTING);
          if (err instanceof InvalidInvitationExtensionRoleError3) {
            log19("invalid role", {
              ...err.context
            }, {
              F: __dxlog_file23,
              L: 171,
              S: this,
              C: (f, a) => f(...a)
            });
            return;
          }
          if (err instanceof TimeoutError2) {
            if (stateChanged) {
              metrics.increment("dxos.invitation.timeout");
              log19.verbose("timeout", {
                err
              }, {
                F: __dxlog_file23,
                L: 177,
                S: this,
                C: (f, a) => f(...a)
              });
            }
          } else {
            if (stateChanged) {
              metrics.increment("dxos.invitation.failed");
              log19.error("failed", err, {
                F: __dxlog_file23,
                L: 182,
                S: this,
                C: (f, a) => f(...a)
              });
            }
          }
        }
      });
      return extension;
    };
    const expiresOn = getExpirationTime(invitation);
    if (expiresOn) {
      if (expiresOn.getTime() < Date.now()) {
        log19.warn("invitation has already expired", void 0, {
          F: __dxlog_file23,
          L: 194,
          S: this,
          C: (f, a) => f(...a)
        });
        guardedState.set(null, Invitation7.State.EXPIRED);
        void ctx.dispose().catch((err) => log19.catch(err, void 0, {
          F: __dxlog_file23,
          L: 196,
          S: this,
          C: (f, a) => f(...a)
        }));
        return;
      }
      scheduleTask7(ctx, async () => {
        await swarmConnection.close();
        guardedState.set(null, Invitation7.State.EXPIRED);
        metrics.increment("dxos.invitation.expired");
        await ctx.dispose();
      }, expiresOn.getTime() - Date.now());
    }
    let swarmConnection;
    scheduleTask7(ctx, async () => {
      swarmConnection = await this._joinSwarm(ctx, invitation, InvitationOptions4.Role.HOST, createExtension);
      guardedState.set(null, Invitation7.State.CONNECTING);
    });
  }
  acceptInvitation(ctx, stream, protocol, invitation, otpEnteredTrigger, deviceProfile) {
    log19.verbose("dxos.sdk.invitations-handler.acceptInvitation", {
      state: invitation.state,
      invitationId: invitation.invitationId,
      kind: invitation.kind,
      type: invitation.type
    }, {
      F: __dxlog_file23,
      L: 227,
      S: this,
      C: (f, a) => f(...a)
    });
    const { timeout = INVITATION_TIMEOUT } = invitation;
    if (deviceProfile) {
      invariant17(invitation.kind === Invitation7.Kind.DEVICE, "deviceProfile provided for non-device invitation", {
        F: __dxlog_file23,
        L: 236,
        S: this,
        A: [
          "invitation.kind === Invitation.Kind.DEVICE",
          "'deviceProfile provided for non-device invitation'"
        ]
      });
    }
    const triedPeersIds = new ComplexSet5(PublicKey11.hash);
    const guardedState = createGuardedInvitationState(ctx, invitation, stream);
    const shouldCancelInvitationFlow = (extension) => {
      const isLockedByAnotherConnection = guardedState.mutex.isLocked() && !extension.hasFlowLock();
      log19("should cancel invitation flow", {
        isLockedByAnotherConnection,
        invitationType: Invitation7.Type.DELEGATED,
        triedPeers: triedPeersIds.size
      }, {
        F: __dxlog_file23,
        L: 244,
        S: this,
        C: (f, a) => f(...a)
      });
      if (isLockedByAnotherConnection) {
        return false;
      }
      return invitation.type !== Invitation7.Type.DELEGATED || triedPeersIds.size >= MAX_DELEGATED_INVITATION_HOST_TRIES;
    };
    let admitted = false;
    const createExtension = () => {
      const extension = new InvitationGuestExtension(guardedState.mutex, {
        onStateUpdate: (newState) => {
          guardedState.set(extension, newState);
        },
        onOpen: (connectionCtx, extensionCtx) => {
          triedPeersIds.add(extensionCtx.remotePeerId);
          if (admitted) {
            extensionCtx.close();
            return;
          }
          connectionCtx.onDispose(async () => {
            log19.verbose("extension disposed", {
              admitted,
              currentState: guardedState.current.state
            }, {
              F: __dxlog_file23,
              L: 272,
              S: this,
              C: (f, a) => f(...a)
            });
            if (!admitted) {
              guardedState.error(extension, new ContextDisposedError3());
              if (shouldCancelInvitationFlow(extension)) {
                await ctx.dispose();
              }
            }
          });
          scheduleTask7(connectionCtx, async () => {
            const traceId = PublicKey11.random().toHex();
            try {
              log19.trace("dxos.sdk.invitations-handler.guest.onOpen", trace7.begin({
                id: traceId
              }), {
                F: __dxlog_file23,
                L: 284,
                S: this,
                C: (f, a) => f(...a)
              });
              scheduleTask7(connectionCtx, () => {
                guardedState.set(extension, Invitation7.State.TIMEOUT);
                extensionCtx.close();
              }, timeout);
              log19.verbose("dxos.sdk.invitations-handler.guest.connected", {
                ...protocol.toJSON()
              }, {
                F: __dxlog_file23,
                L: 295,
                S: this,
                C: (f, a) => f(...a)
              });
              guardedState.set(extension, Invitation7.State.CONNECTED);
              log19.verbose("dxos.sdk.invitations-handler.guest.introduce", {
                invitationId: invitation.invitationId,
                ...protocol.toJSON()
              }, {
                F: __dxlog_file23,
                L: 299,
                S: this,
                C: (f, a) => f(...a)
              });
              const introductionResponse = await extension.rpc.InvitationHostService.introduce({
                invitationId: invitation.invitationId,
                ...protocol.createIntroduction()
              });
              log19.verbose("dxos.sdk.invitations-handler.guest.introduce-response", {
                invitationId: invitation.invitationId,
                ...protocol.toJSON(),
                authMethod: introductionResponse.authMethod
              }, {
                F: __dxlog_file23,
                L: 307,
                S: this,
                C: (f, a) => f(...a)
              });
              invitation.authMethod = introductionResponse.authMethod;
              if (isAuthenticationRequired(invitation)) {
                switch (invitation.authMethod) {
                  case Invitation7.AuthMethod.SHARED_SECRET:
                    await this._handleGuestOtpAuth(extension, (state) => guardedState.set(extension, state), otpEnteredTrigger, {
                      timeout
                    });
                    break;
                  case Invitation7.AuthMethod.KNOWN_PUBLIC_KEY:
                    await this._handleGuestKpkAuth(extension, (state) => guardedState.set(extension, state), invitation, introductionResponse);
                    break;
                }
              }
              log19.verbose("dxos.sdk.invitations-handler.guest.request-admission", {
                invitationId: invitation.invitationId,
                ...protocol.toJSON()
              }, {
                F: __dxlog_file23,
                L: 337,
                S: this,
                C: (f, a) => f(...a)
              });
              const admissionRequest = await protocol.createAdmissionRequest(deviceProfile);
              const admissionResponse = await extension.rpc.InvitationHostService.admit(admissionRequest);
              admitted = true;
              const result = await protocol.accept(admissionResponse, admissionRequest);
              log19.verbose("dxos.sdk.invitations-handler.guest.admitted-by-host", {
                invitationId: invitation.invitationId,
                ...protocol.toJSON()
              }, {
                F: __dxlog_file23,
                L: 351,
                S: this,
                C: (f, a) => f(...a)
              });
              guardedState.complete({
                ...guardedState.current,
                ...result,
                state: Invitation7.State.SUCCESS
              });
              log19.trace("dxos.sdk.invitations-handler.guest.onOpen", trace7.end({
                id: traceId
              }), {
                F: __dxlog_file23,
                L: 360,
                S: this,
                C: (f, a) => f(...a)
              });
            } catch (err) {
              if (err instanceof TimeoutError2) {
                log19.verbose("timeout", {
                  ...protocol.toJSON()
                }, {
                  F: __dxlog_file23,
                  L: 363,
                  S: this,
                  C: (f, a) => f(...a)
                });
                guardedState.set(extension, Invitation7.State.TIMEOUT);
              } else {
                log19.verbose("auth failed", err, {
                  F: __dxlog_file23,
                  L: 366,
                  S: this,
                  C: (f, a) => f(...a)
                });
                guardedState.error(extension, err);
              }
              extensionCtx.close(err);
              log19.trace("dxos.sdk.invitations-handler.guest.onOpen", trace7.error({
                id: traceId,
                error: err
              }), {
                F: __dxlog_file23,
                L: 370,
                S: this,
                C: (f, a) => f(...a)
              });
            }
          });
        },
        onError: (err) => {
          if (err instanceof InvalidInvitationExtensionRoleError3) {
            return;
          }
          if (err instanceof TimeoutError2) {
            log19.verbose("timeout", {
              ...protocol.toJSON()
            }, {
              F: __dxlog_file23,
              L: 379,
              S: this,
              C: (f, a) => f(...a)
            });
            guardedState.set(extension, Invitation7.State.TIMEOUT);
          } else {
            log19.verbose("auth failed", err, {
              F: __dxlog_file23,
              L: 382,
              S: this,
              C: (f, a) => f(...a)
            });
            guardedState.error(extension, err);
          }
        }
      });
      return extension;
    };
    const edgeInvitationHandler = new EdgeInvitationHandler(this._connectionParams?.edgeInvitations, this._edgeClient, {
      onInvitationSuccess: async (admissionResponse, admissionRequest) => {
        const result = await protocol.accept(admissionResponse, admissionRequest);
        log19.info("admitted by edge", {
          ...protocol.toJSON()
        }, {
          F: __dxlog_file23,
          L: 394,
          S: this,
          C: (f, a) => f(...a)
        });
        guardedState.complete({
          ...guardedState.current,
          ...result,
          state: Invitation7.State.SUCCESS
        });
      }
    });
    edgeInvitationHandler.handle(ctx, guardedState, protocol, deviceProfile);
    scheduleTask7(ctx, async () => {
      const error = checkInvitation(protocol, invitation);
      if (error) {
        stream.error(error);
        await ctx.dispose();
      } else {
        invariant17(invitation.swarmKey, void 0, {
          F: __dxlog_file23,
          L: 406,
          S: this,
          A: [
            "invitation.swarmKey",
            ""
          ]
        });
        const timeoutInactive = () => {
          if (guardedState.mutex.isLocked()) {
            scheduleTask7(ctx, timeoutInactive, timeout);
          } else {
            guardedState.set(null, Invitation7.State.TIMEOUT);
          }
        };
        scheduleTask7(ctx, timeoutInactive, timeout);
        await this._joinSwarm(ctx, invitation, InvitationOptions4.Role.GUEST, createExtension);
        guardedState.set(null, Invitation7.State.CONNECTING);
      }
    });
  }
  async _joinSwarm(ctx, invitation, role, extensionFactory) {
    let label;
    if (role === InvitationOptions4.Role.GUEST) {
      label = "invitation guest";
    } else if (invitation.kind === Invitation7.Kind.DEVICE) {
      label = "invitation host for device";
    } else {
      label = `invitation host for space ${invitation.spaceKey?.truncate()}`;
    }
    const swarmConnection = await this._networkManager.joinSwarm({
      topic: invitation.swarmKey,
      protocolProvider: createTeleportProtocolFactory(async (teleport) => {
        teleport.addExtension("dxos.halo.invitations", extensionFactory());
      }, this._connectionParams?.teleport),
      topology: new InvitationTopology(role),
      label
    });
    ctx.onDispose(() => swarmConnection.close());
    return swarmConnection;
  }
  async _handleGuestOtpAuth(extension, setState, authenticated, options) {
    for (let attempt = 1; attempt <= MAX_OTP_ATTEMPTS; attempt++) {
      log19("guest waiting for authentication code...", void 0, {
        F: __dxlog_file23,
        L: 458,
        S: this,
        C: (f, a) => f(...a)
      });
      setState(Invitation7.State.READY_FOR_AUTHENTICATION);
      const authCode = await authenticated.wait(options);
      log19("sending authentication request", void 0, {
        F: __dxlog_file23,
        L: 462,
        S: this,
        C: (f, a) => f(...a)
      });
      setState(Invitation7.State.AUTHENTICATING);
      const response = await extension.rpc.InvitationHostService.authenticate({
        authCode
      });
      if (response.status === void 0 || response.status === AuthenticationResponse2.Status.OK) {
        break;
      }
      if (response.status === AuthenticationResponse2.Status.INVALID_OTP) {
        if (attempt === MAX_OTP_ATTEMPTS) {
          throw new Error(`Maximum retry attempts: ${MAX_OTP_ATTEMPTS}`);
        } else {
          log19("retrying invalid code", {
            attempt
          }, {
            F: __dxlog_file23,
            L: 473,
            S: this,
            C: (f, a) => f(...a)
          });
          authenticated.reset();
        }
      }
    }
  }
  async _handleGuestKpkAuth(extension, setState, invitation, introductionResponse) {
    if (invitation.guestKeypair?.privateKey == null) {
      throw new Error("keypair missing in the invitation");
    }
    if (introductionResponse.challenge == null) {
      throw new Error("challenge missing in the introduction");
    }
    log19("sending authentication request", void 0, {
      F: __dxlog_file23,
      L: 492,
      S: this,
      C: (f, a) => f(...a)
    });
    const signature = sign2(Buffer.from(introductionResponse.challenge), invitation.guestKeypair.privateKey);
    const response = await extension.rpc.InvitationHostService.authenticate({
      signedChallenge: signature
    });
    if (response.status !== AuthenticationResponse2.Status.OK) {
      throw new Error(`Authentication failed with code: ${response.status}`);
    }
  }
};
var checkInvitation = (protocol, invitation) => {
  const expiresOn = getExpirationTime(invitation);
  if (expiresOn && expiresOn.getTime() < Date.now()) {
    return new InvalidInvitationError("Invitation already expired.");
  }
  return protocol.checkInvitation(invitation);
};
var createAdmissionKeypair = () => {
  const keypair = createKeyPair();
  return {
    publicKey: PublicKey11.from(keypair.publicKey),
    privateKey: keypair.secretKey
  };
};

// packages/sdk/client-services/src/packlets/invitations/invitations-service.ts
import { Stream as Stream9 } from "@dxos/codec-protobuf/stream";
import { QueryInvitationsResponse } from "@dxos/protocols/proto/dxos/client/services";
import { trace as trace8 } from "@dxos/tracing";
var InvitationsServiceImpl = class {
  constructor(_invitationsManager) {
    this._invitationsManager = _invitationsManager;
  }
  // TODO(burdon): Guest/host label.
  getLoggingContext() {
    return {};
  }
  createInvitation(options) {
    return new Stream9(({ next, close }) => {
      void this._invitationsManager.createInvitation(options).then((invitation) => {
        trace8.metrics.increment("dxos.invitation.created");
        invitation.subscribe(next, close, close);
      }).catch(close);
    });
  }
  acceptInvitation(request) {
    const invitation = this._invitationsManager.acceptInvitation(request);
    return new Stream9(({ next, close }) => {
      invitation.subscribe(next, close, close);
    });
  }
  async authenticate(request) {
    return this._invitationsManager.authenticate(request);
  }
  async cancelInvitation(request) {
    return this._invitationsManager.cancelInvitation(request);
  }
  queryInvitations() {
    return new Stream9(({ next, ctx }) => {
      this._invitationsManager.invitationCreated.on(ctx, (invitation) => {
        next({
          action: QueryInvitationsResponse.Action.ADDED,
          type: QueryInvitationsResponse.Type.CREATED,
          invitations: [
            invitation
          ]
        });
      });
      this._invitationsManager.invitationAccepted.on(ctx, (invitation) => {
        next({
          action: QueryInvitationsResponse.Action.ADDED,
          type: QueryInvitationsResponse.Type.ACCEPTED,
          invitations: [
            invitation
          ]
        });
      });
      this._invitationsManager.removedCreated.on(ctx, (invitation) => {
        next({
          action: QueryInvitationsResponse.Action.REMOVED,
          type: QueryInvitationsResponse.Type.CREATED,
          invitations: [
            invitation
          ]
        });
      });
      this._invitationsManager.removedAccepted.on(ctx, (invitation) => {
        next({
          action: QueryInvitationsResponse.Action.REMOVED,
          type: QueryInvitationsResponse.Type.ACCEPTED,
          invitations: [
            invitation
          ]
        });
      });
      this._invitationsManager.saved.on(ctx, (invitation) => {
        next({
          action: QueryInvitationsResponse.Action.SAVED,
          type: QueryInvitationsResponse.Type.CREATED,
          invitations: [
            invitation
          ]
        });
      });
      next({
        action: QueryInvitationsResponse.Action.ADDED,
        type: QueryInvitationsResponse.Type.CREATED,
        invitations: this._invitationsManager.getCreatedInvitations(),
        existing: true
      });
      next({
        action: QueryInvitationsResponse.Action.ADDED,
        type: QueryInvitationsResponse.Type.ACCEPTED,
        invitations: this._invitationsManager.getAcceptedInvitations(),
        existing: true
      });
      this._invitationsManager.onPersistentInvitationsLoaded(ctx, () => {
        next({
          action: QueryInvitationsResponse.Action.LOAD_COMPLETE,
          type: QueryInvitationsResponse.Type.CREATED
        });
      });
    });
  }
};

// packages/sdk/client-services/src/packlets/invitations/space-invitation-protocol.ts
import { createCancelDelegatedSpaceInvitationCredential, createDelegatedSpaceInvitationCredential, getCredentialAssertion as getCredentialAssertion5 } from "@dxos/credentials";
import { writeMessages as writeMessages4 } from "@dxos/feed-store";
import { invariant as invariant18 } from "@dxos/invariant";
import { log as log20 } from "@dxos/log";
import { AlreadyJoinedError as AlreadyJoinedError3, AuthorizationError as AuthorizationError2, InvalidInvitationError as InvalidInvitationError2, SpaceNotFoundError as SpaceNotFoundError2 } from "@dxos/protocols";
import { Invitation as Invitation8 } from "@dxos/protocols/proto/dxos/client/services";
import { SpaceMember as SpaceMember6 } from "@dxos/protocols/proto/dxos/halo/credentials";
var __dxlog_file24 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/space-invitation-protocol.ts";
var SpaceInvitationProtocol = class {
  constructor(_spaceManager, _signingContext, _keyring, _spaceKey) {
    this._spaceManager = _spaceManager;
    this._signingContext = _signingContext;
    this._keyring = _keyring;
    this._spaceKey = _spaceKey;
  }
  toJSON() {
    return {
      kind: "space",
      deviceKey: this._signingContext.deviceKey,
      spaceKey: this._spaceKey
    };
  }
  checkCanInviteNewMembers() {
    if (this._spaceKey == null) {
      return new InvalidInvitationError2("No spaceKey was provided for a space invitation.");
    }
    const space = this._spaceManager.spaces.get(this._spaceKey);
    if (space == null) {
      return new SpaceNotFoundError2(this._spaceKey);
    }
    if (!space?.inner.spaceState.hasMembershipManagementPermission(this._signingContext.identityKey)) {
      return new AuthorizationError2("No member management permission.");
    }
    return void 0;
  }
  getInvitationContext() {
    invariant18(this._spaceKey, void 0, {
      F: __dxlog_file24,
      L: 65,
      S: this,
      A: [
        "this._spaceKey",
        ""
      ]
    });
    const space = this._spaceManager.spaces.get(this._spaceKey);
    invariant18(space, void 0, {
      F: __dxlog_file24,
      L: 67,
      S: this,
      A: [
        "space",
        ""
      ]
    });
    return {
      kind: Invitation8.Kind.SPACE,
      spaceKey: this._spaceKey,
      spaceId: space.id
    };
  }
  async admit(invitation, request, guestProfile) {
    invariant18(this._spaceKey && request.space, void 0, {
      F: __dxlog_file24,
      L: 80,
      S: this,
      A: [
        "this._spaceKey && request.space",
        ""
      ]
    });
    log20("writing guest credentials", {
      host: this._signingContext.deviceKey,
      guest: request.space.deviceKey
    }, {
      F: __dxlog_file24,
      L: 81,
      S: this,
      C: (f, a) => f(...a)
    });
    const spaceMemberCredential = await this._spaceManager.admitMember({
      spaceKey: this._spaceKey,
      identityKey: request.space.identityKey,
      role: invitation.role ?? SpaceMember6.Role.ADMIN,
      profile: guestProfile,
      delegationCredentialId: invitation.delegationCredentialId
    });
    const space = this._spaceManager.spaces.get(this._spaceKey);
    return {
      space: {
        credential: spaceMemberCredential,
        controlTimeframe: space?.inner.controlPipeline.state.timeframe
      }
    };
  }
  async delegate(invitation) {
    invariant18(this._spaceKey, void 0, {
      F: __dxlog_file24,
      L: 101,
      S: this,
      A: [
        "this._spaceKey",
        ""
      ]
    });
    const space = this._spaceManager.spaces.get(this._spaceKey);
    invariant18(space, void 0, {
      F: __dxlog_file24,
      L: 103,
      S: this,
      A: [
        "space",
        ""
      ]
    });
    if (invitation.authMethod === Invitation8.AuthMethod.KNOWN_PUBLIC_KEY) {
      invariant18(invitation.guestKeypair?.publicKey, void 0, {
        F: __dxlog_file24,
        L: 105,
        S: this,
        A: [
          "invitation.guestKeypair?.publicKey",
          ""
        ]
      });
    }
    log20("writing delegate space invitation", {
      host: this._signingContext.deviceKey,
      id: invitation.invitationId
    }, {
      F: __dxlog_file24,
      L: 108,
      S: this,
      C: (f, a) => f(...a)
    });
    const credential = await createDelegatedSpaceInvitationCredential(this._signingContext.credentialSigner, space.key, {
      invitationId: invitation.invitationId,
      authMethod: invitation.authMethod,
      swarmKey: invitation.swarmKey,
      role: invitation.role ?? SpaceMember6.Role.ADMIN,
      expiresOn: computeExpirationTime(invitation),
      multiUse: invitation.multiUse ?? false,
      guestKey: invitation.authMethod === Invitation8.AuthMethod.KNOWN_PUBLIC_KEY ? invitation.guestKeypair.publicKey : void 0
    });
    invariant18(credential.credential, void 0, {
      F: __dxlog_file24,
      L: 126,
      S: this,
      A: [
        "credential.credential",
        ""
      ]
    });
    await writeMessages4(space.inner.controlPipeline.writer, [
      credential
    ]);
    return credential.credential.credential.id;
  }
  async cancelDelegation(invitation) {
    invariant18(this._spaceKey, void 0, {
      F: __dxlog_file24,
      L: 132,
      S: this,
      A: [
        "this._spaceKey",
        ""
      ]
    });
    invariant18(invitation.type === Invitation8.Type.DELEGATED && invitation.delegationCredentialId, void 0, {
      F: __dxlog_file24,
      L: 133,
      S: this,
      A: [
        "invitation.type === Invitation.Type.DELEGATED && invitation.delegationCredentialId",
        ""
      ]
    });
    const space = this._spaceManager.spaces.get(this._spaceKey);
    invariant18(space, void 0, {
      F: __dxlog_file24,
      L: 135,
      S: this,
      A: [
        "space",
        ""
      ]
    });
    log20("cancelling delegated space invitation", {
      host: this._signingContext.deviceKey,
      id: invitation.invitationId
    }, {
      F: __dxlog_file24,
      L: 137,
      S: this,
      C: (f, a) => f(...a)
    });
    const credential = await createCancelDelegatedSpaceInvitationCredential(this._signingContext.credentialSigner, space.key, invitation.delegationCredentialId);
    invariant18(credential.credential, void 0, {
      F: __dxlog_file24,
      L: 144,
      S: this,
      A: [
        "credential.credential",
        ""
      ]
    });
    await writeMessages4(space.inner.controlPipeline.writer, [
      credential
    ]);
  }
  checkInvitation(invitation) {
    if (invitation.spaceKey == null) {
      return new InvalidInvitationError2("No spaceKey was provided for a space invitation.");
    }
    if (this._spaceManager.spaces.has(invitation.spaceKey)) {
      return new AlreadyJoinedError3("Already joined space.");
    }
  }
  createIntroduction() {
    return {
      profile: this._signingContext.getProfile()
    };
  }
  async createAdmissionRequest() {
    const controlFeedKey = await this._keyring.createKey();
    const dataFeedKey = await this._keyring.createKey();
    return {
      space: {
        identityKey: this._signingContext.identityKey,
        deviceKey: this._signingContext.deviceKey,
        controlFeedKey,
        dataFeedKey
      }
    };
  }
  async accept(response) {
    invariant18(response.space, void 0, {
      F: __dxlog_file24,
      L: 179,
      S: this,
      A: [
        "response.space",
        ""
      ]
    });
    const { credential, controlTimeframe, dataTimeframe } = response.space;
    const assertion = getCredentialAssertion5(credential);
    invariant18(assertion["@type"] === "dxos.halo.credentials.SpaceMember", "Invalid credential", {
      F: __dxlog_file24,
      L: 182,
      S: this,
      A: [
        "assertion['@type'] === 'dxos.halo.credentials.SpaceMember'",
        "'Invalid credential'"
      ]
    });
    invariant18(credential.subject.id.equals(this._signingContext.identityKey), void 0, {
      F: __dxlog_file24,
      L: 183,
      S: this,
      A: [
        "credential.subject.id.equals(this._signingContext.identityKey)",
        ""
      ]
    });
    if (this._spaceManager.spaces.has(assertion.spaceKey)) {
      throw new AlreadyJoinedError3("Already joined space.");
    }
    await this._spaceManager.acceptSpace({
      spaceKey: assertion.spaceKey,
      genesisFeedKey: assertion.genesisFeedKey,
      controlTimeframe,
      dataTimeframe
    });
    await this._signingContext.recordCredential(credential);
    return {
      spaceKey: assertion.spaceKey
    };
  }
};

// packages/sdk/client-services/src/packlets/invitations/invitations-manager.ts
import { Event as Event8, PushStream, TimeoutError as TimeoutError3, Trigger as Trigger7 } from "@dxos/async";
import { AuthenticatingInvitation, AUTHENTICATION_CODE_LENGTH, CancellableInvitation, INVITATION_TIMEOUT as INVITATION_TIMEOUT2 } from "@dxos/client-protocol";
import { Context as Context9 } from "@dxos/context";
import { generatePasscode } from "@dxos/credentials";
import { hasInvitationExpired } from "@dxos/echo-pipeline";
import { invariant as invariant19 } from "@dxos/invariant";
import { PublicKey as PublicKey12 } from "@dxos/keys";
import { log as log21 } from "@dxos/log";
import { Invitation as Invitation9 } from "@dxos/protocols/proto/dxos/client/services";
import { SpaceMember as SpaceMember7 } from "@dxos/protocols/proto/dxos/halo/credentials";
var __dxlog_file25 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/invitations-manager.ts";
var InvitationsManager = class {
  constructor(_invitationsHandler, _getHandler, _metadataStore) {
    this._invitationsHandler = _invitationsHandler;
    this._getHandler = _getHandler;
    this._metadataStore = _metadataStore;
    this._createInvitations = /* @__PURE__ */ new Map();
    this._acceptInvitations = /* @__PURE__ */ new Map();
    this.invitationCreated = new Event8();
    this.invitationAccepted = new Event8();
    this.removedCreated = new Event8();
    this.removedAccepted = new Event8();
    this.saved = new Event8();
    this._persistentInvitationsLoadedEvent = new Event8();
    this._persistentInvitationsLoaded = false;
  }
  async createInvitation(options) {
    if (options.invitationId) {
      const existingInvitation = this._createInvitations.get(options.invitationId);
      if (existingInvitation) {
        return existingInvitation;
      }
    }
    const handler = this._getHandler(options);
    const invitationError = handler.checkCanInviteNewMembers();
    if (invitationError != null) {
      throw invitationError;
    }
    const invitation = this._createInvitation(handler, options);
    const { ctx, stream, observableInvitation } = this._createObservableInvitation(handler, invitation);
    this._createInvitations.set(invitation.invitationId, observableInvitation);
    this.invitationCreated.emit(invitation);
    this._onInvitationComplete(observableInvitation, async () => {
      this._createInvitations.delete(observableInvitation.get().invitationId);
      this.removedCreated.emit(observableInvitation.get());
      if (observableInvitation.get().persistent) {
        await this._safeDeleteInvitation(observableInvitation.get());
      }
    });
    try {
      await this._persistIfRequired(handler, stream, invitation);
    } catch (err) {
      log21.catch(err, void 0, {
        F: __dxlog_file25,
        L: 82,
        S: this,
        C: (f, a) => f(...a)
      });
      await observableInvitation.cancel();
      return observableInvitation;
    }
    this._invitationsHandler.handleInvitationFlow(ctx, stream, handler, observableInvitation.get());
    return observableInvitation;
  }
  async loadPersistentInvitations() {
    if (this._persistentInvitationsLoaded) {
      const invitations = this.getCreatedInvitations().filter((i) => i.persistent);
      return {
        invitations
      };
    }
    try {
      const persistentInvitations = this._metadataStore.getInvitations();
      const freshInvitations = persistentInvitations.filter((invitation) => !hasInvitationExpired(invitation));
      const loadTasks = freshInvitations.map((persistentInvitation) => {
        invariant19(!this._createInvitations.get(persistentInvitation.invitationId), "invitation already exists", {
          F: __dxlog_file25,
          L: 103,
          S: this,
          A: [
            "!this._createInvitations.get(persistentInvitation.invitationId)",
            "'invitation already exists'"
          ]
        });
        return this.createInvitation({
          ...persistentInvitation,
          persistent: false
        });
      });
      const cInvitations = await Promise.all(loadTasks);
      return {
        invitations: cInvitations.map((invitation) => invitation.get())
      };
    } catch (err) {
      log21.catch(err, void 0, {
        F: __dxlog_file25,
        L: 110,
        S: this,
        C: (f, a) => f(...a)
      });
      return {
        invitations: []
      };
    } finally {
      this._persistentInvitationsLoadedEvent.emit();
      this._persistentInvitationsLoaded = true;
    }
  }
  acceptInvitation(request) {
    const options = request.invitation;
    const existingInvitation = this._acceptInvitations.get(options.invitationId);
    if (existingInvitation) {
      return existingInvitation;
    }
    const handler = this._getHandler(options);
    const { ctx, invitation, stream, otpEnteredTrigger } = this._createObservableAcceptingInvitation(handler, options);
    this._invitationsHandler.acceptInvitation(ctx, stream, handler, options, otpEnteredTrigger, request.deviceProfile);
    this._acceptInvitations.set(invitation.get().invitationId, invitation);
    this.invitationAccepted.emit(invitation.get());
    this._onInvitationComplete(invitation, () => {
      this._acceptInvitations.delete(invitation.get().invitationId);
      this.removedAccepted.emit(invitation.get());
    });
    return invitation;
  }
  async authenticate({ invitationId, authCode }) {
    log21("authenticating...", void 0, {
      F: __dxlog_file25,
      L: 140,
      S: this,
      C: (f, a) => f(...a)
    });
    invariant19(invitationId, void 0, {
      F: __dxlog_file25,
      L: 141,
      S: this,
      A: [
        "invitationId",
        ""
      ]
    });
    const observable = this._acceptInvitations.get(invitationId);
    if (!observable) {
      log21.warn("invalid invitation", {
        invitationId
      }, {
        F: __dxlog_file25,
        L: 144,
        S: this,
        C: (f, a) => f(...a)
      });
    } else {
      await observable.authenticate(authCode);
    }
  }
  async cancelInvitation({ invitationId }) {
    log21("cancelInvitation...", {
      invitationId
    }, {
      F: __dxlog_file25,
      L: 151,
      S: this,
      C: (f, a) => f(...a)
    });
    invariant19(invitationId, void 0, {
      F: __dxlog_file25,
      L: 152,
      S: this,
      A: [
        "invitationId",
        ""
      ]
    });
    const created = this._createInvitations.get(invitationId);
    if (created) {
      if (created.get().persistent) {
        await this._metadataStore.removeInvitation(invitationId);
      }
      if (created.get().type === Invitation9.Type.DELEGATED) {
        const handler = this._getHandler(created.get());
        await handler.cancelDelegation(created.get());
      }
      await created.cancel();
      this._createInvitations.delete(invitationId);
      this.removedCreated.emit(created.get());
      return;
    }
    const accepted = this._acceptInvitations.get(invitationId);
    if (accepted) {
      await accepted.cancel();
      this._acceptInvitations.delete(invitationId);
      this.removedAccepted.emit(accepted.get());
    }
  }
  getCreatedInvitations() {
    return [
      ...this._createInvitations.values()
    ].map((i) => i.get());
  }
  getAcceptedInvitations() {
    return [
      ...this._acceptInvitations.values()
    ].map((i) => i.get());
  }
  onPersistentInvitationsLoaded(ctx, callback) {
    if (this._persistentInvitationsLoaded) {
      callback();
    } else {
      this._persistentInvitationsLoadedEvent.once(ctx, () => callback());
    }
  }
  _createInvitation(protocol, _options) {
    const { invitationId = PublicKey12.random().toHex(), type = Invitation9.Type.INTERACTIVE, authMethod = Invitation9.AuthMethod.SHARED_SECRET, state = Invitation9.State.INIT, timeout = INVITATION_TIMEOUT2, swarmKey = PublicKey12.random(), persistent = _options?.authMethod !== Invitation9.AuthMethod.KNOWN_PUBLIC_KEY, created = /* @__PURE__ */ new Date(), guestKeypair = void 0, role = SpaceMember7.Role.ADMIN, lifetime = 86400 * 7, multiUse = false, ...options } = _options ?? {};
    const authCode = options?.authCode ?? (authMethod === Invitation9.AuthMethod.SHARED_SECRET ? generatePasscode(AUTHENTICATION_CODE_LENGTH) : void 0);
    return {
      invitationId,
      type,
      authMethod,
      state,
      swarmKey,
      authCode,
      timeout,
      persistent: persistent && type !== Invitation9.Type.DELEGATED,
      guestKeypair: guestKeypair ?? (authMethod === Invitation9.AuthMethod.KNOWN_PUBLIC_KEY ? createAdmissionKeypair() : void 0),
      created,
      lifetime,
      role,
      multiUse,
      delegationCredentialId: options?.delegationCredentialId,
      ...options,
      ...protocol.getInvitationContext()
    };
  }
  _createObservableInvitation(handler, invitation) {
    const stream = new PushStream();
    const ctx = new Context9({
      onError: (err) => {
        stream.error(err);
        void ctx.dispose();
      }
    }, {
      F: __dxlog_file25,
      L: 239
    });
    ctx.onDispose(() => {
      log21("complete", {
        ...handler.toJSON()
      }, {
        F: __dxlog_file25,
        L: 246,
        S: this,
        C: (f, a) => f(...a)
      });
      stream.complete();
    });
    const observableInvitation = new CancellableInvitation({
      initialInvitation: invitation,
      subscriber: stream.observable,
      onCancel: async () => {
        stream.next({
          ...invitation,
          state: Invitation9.State.CANCELLED
        });
        await ctx.dispose();
      }
    });
    return {
      ctx,
      stream,
      observableInvitation
    };
  }
  _createObservableAcceptingInvitation(handler, initialState) {
    const otpEnteredTrigger = new Trigger7();
    const stream = new PushStream();
    const ctx = new Context9({
      onError: (err) => {
        if (err instanceof TimeoutError3) {
          log21("timeout", {
            ...handler.toJSON()
          }, {
            F: __dxlog_file25,
            L: 274,
            S: this,
            C: (f, a) => f(...a)
          });
          stream.next({
            ...initialState,
            state: Invitation9.State.TIMEOUT
          });
        } else {
          log21.warn("auth failed", err, {
            F: __dxlog_file25,
            L: 277,
            S: this,
            C: (f, a) => f(...a)
          });
          stream.next({
            ...initialState,
            state: Invitation9.State.ERROR
          });
        }
        void ctx.dispose();
      }
    }, {
      F: __dxlog_file25,
      L: 271
    });
    ctx.onDispose(() => {
      log21("complete", {
        ...handler.toJSON()
      }, {
        F: __dxlog_file25,
        L: 284,
        S: this,
        C: (f, a) => f(...a)
      });
      stream.complete();
    });
    const invitation = new AuthenticatingInvitation({
      initialInvitation: initialState,
      subscriber: stream.observable,
      onCancel: async () => {
        stream.next({
          ...initialState,
          state: Invitation9.State.CANCELLED
        });
        await ctx.dispose();
      },
      onAuthenticate: async (code) => {
        otpEnteredTrigger.wake(code);
      }
    });
    return {
      ctx,
      invitation,
      stream,
      otpEnteredTrigger
    };
  }
  async _persistIfRequired(handler, changeStream, invitation) {
    if (invitation.type === Invitation9.Type.DELEGATED && invitation.delegationCredentialId == null) {
      const delegationCredentialId = await handler.delegate(invitation);
      changeStream.next({
        ...invitation,
        delegationCredentialId
      });
    } else if (invitation.persistent) {
      await this._metadataStore.addInvitation(invitation);
      this.saved.emit(invitation);
    }
  }
  async _safeDeleteInvitation(invitation) {
    try {
      await this._metadataStore.removeInvitation(invitation.invitationId);
    } catch (err) {
      log21.catch(err, void 0, {
        F: __dxlog_file25,
        L: 320,
        S: this,
        C: (f, a) => f(...a)
      });
    }
  }
  _onInvitationComplete(invitation, callback) {
    invitation.subscribe(() => {
    }, () => {
    }, callback);
  }
};

// packages/sdk/client-services/src/packlets/locks/browser.ts
import { asyncTimeout as asyncTimeout2, Trigger as Trigger8 } from "@dxos/async";
import { RESOURCE_LOCK_TIMEOUT } from "@dxos/client-protocol";
import { log as log22, logInfo as logInfo3 } from "@dxos/log";
function _ts_decorate7(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file26 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/locks/browser.ts";
var Lock = class {
  constructor({ lockKey, onAcquire, onRelease }) {
    this._broadcastChannel = new BroadcastChannel("vault-resource-lock");
    this._releaseTrigger = new Trigger8();
    this._lockKey = lockKey;
    this._onAcquire = onAcquire;
    this._onRelease = onRelease;
    this._broadcastChannel.onmessage = this._onMessage.bind(this);
  }
  get lockKey() {
    return this._lockKey;
  }
  async acquire() {
    this._broadcastChannel.postMessage({
      message: "acquiring"
    });
    try {
      log22("aquiring lock...", void 0, {
        F: __dxlog_file26,
        L: 42,
        S: this,
        C: (f, a) => f(...a)
      });
      await asyncTimeout2(this._requestLock(), RESOURCE_LOCK_TIMEOUT);
      log22("acquired lock", void 0, {
        F: __dxlog_file26,
        L: 44,
        S: this,
        C: (f, a) => f(...a)
      });
    } catch {
      log22("stealing lock...", void 0, {
        F: __dxlog_file26,
        L: 46,
        S: this,
        C: (f, a) => f(...a)
      });
      await this._requestLock(true);
      log22("stolen lock", void 0, {
        F: __dxlog_file26,
        L: 48,
        S: this,
        C: (f, a) => f(...a)
      });
    }
  }
  async release() {
    this._releaseTrigger.wake();
  }
  _onMessage(event) {
    if (event.data.message === "acquiring") {
      this._releaseTrigger.wake();
    }
  }
  async _requestLock(steal = false) {
    log22("requesting lock...", {
      steal
    }, {
      F: __dxlog_file26,
      L: 63,
      S: this,
      C: (f, a) => f(...a)
    });
    const acquired = new Trigger8();
    void navigator.locks.request(this._lockKey, {
      steal
    }, async () => {
      await this._onAcquire?.();
      acquired.wake();
      this._releaseTrigger = new Trigger8();
      await this._releaseTrigger.wait();
      log22("releasing lock...", void 0, {
        F: __dxlog_file26,
        L: 72,
        S: this,
        C: (f, a) => f(...a)
      });
      await this._onRelease?.();
      log22("released lock", void 0, {
        F: __dxlog_file26,
        L: 74,
        S: this,
        C: (f, a) => f(...a)
      });
    }).catch(async () => {
      await this._onRelease?.();
    });
    await acquired.wait();
    log22("recieved lock", {
      steal
    }, {
      F: __dxlog_file26,
      L: 81,
      S: this,
      C: (f, a) => f(...a)
    });
  }
};
_ts_decorate7([
  logInfo3
], Lock.prototype, "lockKey", null);
var isLocked = (lockPath) => {
  throw new Error("Not implemented");
};

// packages/sdk/client-services/src/packlets/services/client-rpc-server.ts
import { Stream as Stream10 } from "@dxos/codec-protobuf";
import { raise as raise2 } from "@dxos/debug";
import { parseMethodName, RpcPeer } from "@dxos/rpc";
import { MapCounter, trace as trace9 } from "@dxos/tracing";
function _ts_decorate8(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var ClientRpcServer = class {
  constructor(params) {
    this._handlerCache = /* @__PURE__ */ new Map();
    this._callMetrics = new MapCounter();
    const { serviceRegistry, handleCall, handleStream, ...rpcOptions } = params;
    this._handleCall = handleCall;
    this._handleStream = handleStream;
    this._serviceRegistry = serviceRegistry;
    this._rpcPeer = new RpcPeer({
      ...rpcOptions,
      callHandler: (method, params2) => {
        const [serviceName, methodName] = parseMethodName(method);
        const handler = (method2, params3) => this._getServiceHandler(serviceName).call(method2, params3);
        this._callMetrics.inc(`${serviceName}.${methodName} request`);
        if (this._handleCall) {
          return this._handleCall(methodName, params2, handler);
        } else {
          return handler(methodName, params2);
        }
      },
      streamHandler: (method, params2) => {
        const [serviceName, methodName] = parseMethodName(method);
        const handler = (method2, params3) => this._getServiceHandler(serviceName).callStream(method2, params3);
        this._callMetrics.inc(`${serviceName}.${methodName} request stream`);
        if (this._handleStream) {
          return Stream10.map(Stream10.unwrapPromise(this._handleStream(methodName, params2, handler)), (data) => {
            this._callMetrics.inc(`${serviceName}.${methodName} response stream`);
            return data;
          });
        } else {
          return handler(methodName, params2);
        }
      }
    });
  }
  get _services() {
    return Object.keys(this._serviceRegistry.services);
  }
  async open() {
    await this._rpcPeer.open();
  }
  async close() {
    await this._rpcPeer.close();
  }
  _getServiceHandler(serviceName) {
    if (!this._handlerCache.has(serviceName)) {
      const [key, descriptor] = Object.entries(this._serviceRegistry.descriptors).find(([key2, descriptor2]) => descriptor2.name === serviceName) ?? raise2(new Error(`Service not available: ${serviceName}`));
      const service = this._serviceRegistry.services[key];
      if (!service) {
        throw new Error(`Service not available: ${serviceName}`);
      }
      this._handlerCache.set(serviceName, descriptor.createServer(service));
    }
    return this._handlerCache.get(serviceName);
  }
};
_ts_decorate8([
  trace9.metricsCounter()
], ClientRpcServer.prototype, "_callMetrics", void 0);
_ts_decorate8([
  trace9.info()
], ClientRpcServer.prototype, "_services", null);
ClientRpcServer = _ts_decorate8([
  trace9.resource()
], ClientRpcServer);

// packages/sdk/client-services/src/packlets/agents/edge-agent-manager.ts
import { DeferredTask as DeferredTask2, Event as Event9, scheduleTask as scheduleTask8, synchronized as synchronized3 } from "@dxos/async";
import { Resource as Resource7 } from "@dxos/context";
import { invariant as invariant20 } from "@dxos/invariant";
import { PublicKey as PublicKey13 } from "@dxos/keys";
import { log as log23 } from "@dxos/log";
import { EdgeAgentStatus, EdgeCallFailedError as EdgeCallFailedError3 } from "@dxos/protocols";
import { SpaceState as SpaceState5 } from "@dxos/protocols/proto/dxos/client/services";
import { EdgeReplicationSetting as EdgeReplicationSetting2 } from "@dxos/protocols/proto/dxos/echo/metadata";
function _ts_decorate9(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file27 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/agents/edge-agent-manager.ts";
var AGENT_STATUS_QUERY_RETRY_INTERVAL = 5e3;
var AGENT_STATUS_QUERY_RETRY_JITTER = 1e3;
var AGENT_FEED_ADDED_CHECK_INTERVAL_MS = 3e3;
var EdgeAgentManager = class extends Resource7 {
  constructor(_edgeFeatures, _edgeHttpClient, _dataSpaceManager, _identity) {
    super(), this._edgeFeatures = _edgeFeatures, this._edgeHttpClient = _edgeHttpClient, this._dataSpaceManager = _dataSpaceManager, this._identity = _identity, this.agentStatusChanged = new Event9(), this._lastKnownDeviceCount = 0;
  }
  get agentStatus() {
    return this._agentStatus;
  }
  get agentExists() {
    return this._agentStatus && this._agentStatus !== EdgeAgentStatus.NOT_FOUND;
  }
  async createAgent() {
    invariant20(this.isOpen, void 0, {
      F: __dxlog_file27,
      L: 54,
      S: this,
      A: [
        "this.isOpen",
        ""
      ]
    });
    invariant20(this._edgeHttpClient, void 0, {
      F: __dxlog_file27,
      L: 55,
      S: this,
      A: [
        "this._edgeHttpClient",
        ""
      ]
    });
    invariant20(this._edgeFeatures?.agents, void 0, {
      F: __dxlog_file27,
      L: 56,
      S: this,
      A: [
        "this._edgeFeatures?.agents",
        ""
      ]
    });
    const response = await this._edgeHttpClient.createAgent({
      identityKey: this._identity.identityKey.toHex(),
      haloSpaceId: this._identity.haloSpaceId,
      haloSpaceKey: this._identity.haloSpaceKey.toHex()
    });
    const deviceKey = PublicKey13.fromHex(response.deviceKey);
    if (await this._identity.authorizedDeviceKeys.has(deviceKey)) {
      log23.info("agent was already added to HALO, ignoring response", {
        response
      }, {
        F: __dxlog_file27,
        L: 67,
        S: this,
        C: (f, a) => f(...a)
      });
      this._updateStatus(EdgeAgentStatus.ACTIVE, deviceKey);
      return;
    }
    await this._identity.admitDevice({
      deviceKey,
      controlFeedKey: PublicKey13.fromHex(response.feedKey),
      // TODO: agents don't have data feed, should be removed
      dataFeedKey: PublicKey13.random()
    });
    log23("agent created", response, {
      F: __dxlog_file27,
      L: 79,
      S: this,
      C: (f, a) => f(...a)
    });
    this._updateStatus(EdgeAgentStatus.ACTIVE, deviceKey);
  }
  async _open() {
    const isEnabled = this._edgeHttpClient && this._edgeFeatures?.agents;
    log23("edge agent manager open", {
      isEnabled
    }, {
      F: __dxlog_file27,
      L: 87,
      S: this,
      C: (f, a) => f(...a)
    });
    if (!isEnabled) {
      return;
    }
    this._lastKnownDeviceCount = this._identity.authorizedDeviceKeys.size;
    this._fetchAgentStatusTask = new DeferredTask2(this._ctx, async () => {
      await this._fetchAgentStatus();
    });
    this._fetchAgentStatusTask.schedule();
    this._dataSpaceManager.updated.on(this._ctx, () => {
      if (this._agentDeviceKey) {
        this._ensureAgentIsInSpaces(this._agentDeviceKey);
      }
    });
    this._identity.stateUpdate.on(this._ctx, () => {
      const maybeAgentWasCreated = this._identity.authorizedDeviceKeys.size > this._lastKnownDeviceCount;
      if (this.agentExists || !maybeAgentWasCreated) {
        return;
      }
      this._lastKnownDeviceCount = this._identity.authorizedDeviceKeys.size;
      this._fetchAgentStatusTask?.schedule();
    });
  }
  async _close() {
    this._fetchAgentStatusTask = void 0;
    this._lastKnownDeviceCount = 0;
  }
  async _fetchAgentStatus() {
    invariant20(this._edgeHttpClient, void 0, {
      F: __dxlog_file27,
      L: 121,
      S: this,
      A: [
        "this._edgeHttpClient",
        ""
      ]
    });
    try {
      log23("fetching agent status", void 0, {
        F: __dxlog_file27,
        L: 123,
        S: this,
        C: (f, a) => f(...a)
      });
      const { agent } = await this._edgeHttpClient.getAgentStatus({
        ownerIdentityKey: this._identity.identityKey
      });
      const wasAgentCreatedDuringQuery = this._agentStatus === EdgeAgentStatus.ACTIVE;
      if (!wasAgentCreatedDuringQuery) {
        const deviceKey = agent.deviceKey ? PublicKey13.fromHex(agent.deviceKey) : void 0;
        this._updateStatus(agent.status, deviceKey);
      }
    } catch (err) {
      if (err instanceof EdgeCallFailedError3) {
        if (!err.isRetryable) {
          log23.warn("non retryable error on agent status fetch attempt", {
            err
          }, {
            F: __dxlog_file27,
            L: 133,
            S: this,
            C: (f, a) => f(...a)
          });
          return;
        }
      }
      const retryAfterMs = AGENT_STATUS_QUERY_RETRY_INTERVAL + Math.random() * AGENT_STATUS_QUERY_RETRY_JITTER;
      log23.info("agent status fetching failed", {
        err,
        retryAfterMs
      }, {
        F: __dxlog_file27,
        L: 138,
        S: this,
        C: (f, a) => f(...a)
      });
      scheduleTask8(this._ctx, () => this._fetchAgentStatusTask?.schedule(), retryAfterMs);
    }
  }
  /**
  * We don't want notarization plugin to always actively poll edge looking for credentials to notarize,
  * because most of the time we'll be getting an empty response.
  * Instead, we stay in active polling mode while there are spaces where we don't see our agent's feed.
  */
  _ensureAgentIsInSpaces(agentDeviceKey) {
    let activePollingEnabled = false;
    for (const space of this._dataSpaceManager.spaces.values()) {
      if (space.getEdgeReplicationSetting() === EdgeReplicationSetting2.DISABLED) {
        space.notarizationPlugin.setActiveEdgePollingEnabled(false);
        continue;
      }
      if ([
        SpaceState5.SPACE_INACTIVE,
        SpaceState5.SPACE_CLOSED
      ].includes(space.state)) {
        space.notarizationPlugin.setActiveEdgePollingEnabled(false);
        continue;
      }
      const agentFeedNeedsNotarization = ![
        ...space.inner.spaceState.feeds.values()
      ].some((feed) => feed.assertion.deviceKey.equals(agentDeviceKey));
      space.notarizationPlugin.setActiveEdgePollingEnabled(agentFeedNeedsNotarization);
      activePollingEnabled = activePollingEnabled || agentFeedNeedsNotarization;
      log23.info("set active edge polling", {
        enabled: agentFeedNeedsNotarization,
        spaceId: space.id
      }, {
        F: __dxlog_file27,
        L: 165,
        S: this,
        C: (f, a) => f(...a)
      });
    }
    if (activePollingEnabled) {
      scheduleTask8(this._ctx, () => this._ensureAgentIsInSpaces(agentDeviceKey), AGENT_FEED_ADDED_CHECK_INTERVAL_MS);
    }
  }
  _updateStatus(status, deviceKey) {
    this._agentStatus = status;
    this._agentDeviceKey = deviceKey;
    this.agentStatusChanged.emit(status);
    if (deviceKey) {
      this._ensureAgentIsInSpaces(deviceKey);
    }
    log23.info("agent status update", {
      status
    }, {
      F: __dxlog_file27,
      L: 181,
      S: this,
      C: (f, a) => f(...a)
    });
  }
};
_ts_decorate9([
  synchronized3
], EdgeAgentManager.prototype, "createAgent", null);

// packages/sdk/client-services/src/packlets/agents/edge-agent-service.ts
import { Stream as Stream11 } from "@dxos/codec-protobuf/stream";
import { EdgeAgentStatus as EdgeAgentStatus2 } from "@dxos/protocols";
import { QueryAgentStatusResponse, EdgeStatus as EdgeStatus2 } from "@dxos/protocols/proto/dxos/client/services";
var EdgeAgentServiceImpl = class {
  constructor(_agentManagerProvider, _edgeConnection) {
    this._agentManagerProvider = _agentManagerProvider;
    this._edgeConnection = _edgeConnection;
  }
  // TODO(mykola): Reconcile with NetworkService.queryStatus.
  queryEdgeStatus() {
    return new Stream11(({ ctx, next }) => {
      const update = () => {
        next({
          status: this._edgeConnection?.status ?? EdgeStatus2.NOT_CONNECTED
        });
      };
      this._edgeConnection?.statusChanged.on(ctx, update);
      update();
    });
  }
  async createAgent() {
    return (await this._agentManagerProvider()).createAgent();
  }
  queryAgentStatus() {
    return new Stream11(({ ctx, next }) => {
      next({
        status: QueryAgentStatusResponse.AgentStatus.UNKNOWN
      });
      void this._agentManagerProvider().then((agentManager) => {
        next({
          status: mapStatus(agentManager.agentStatus)
        });
        agentManager.agentStatusChanged.on(ctx, (newStatus) => {
          next({
            status: mapStatus(newStatus)
          });
        });
      });
    });
  }
};
var mapStatus = (agentStatus) => {
  switch (agentStatus) {
    case EdgeAgentStatus2.ACTIVE:
      return QueryAgentStatusResponse.AgentStatus.ACTIVE;
    case EdgeAgentStatus2.INACTIVE:
      return QueryAgentStatusResponse.AgentStatus.INACTIVE;
    case EdgeAgentStatus2.NOT_FOUND:
      return QueryAgentStatusResponse.AgentStatus.NOT_FOUND;
    case void 0:
      return QueryAgentStatusResponse.AgentStatus.UNKNOWN;
  }
};

// packages/sdk/client-services/src/packlets/services/service-context.ts
import { Mutex as Mutex4, Trigger as Trigger9 } from "@dxos/async";
import { Context as Context10, Resource as Resource8 } from "@dxos/context";
import { getCredentialAssertion as getCredentialAssertion6 } from "@dxos/credentials";
import { failUndefined as failUndefined2, warnAfterTimeout as warnAfterTimeout2 } from "@dxos/debug";
import { EchoEdgeReplicator, EchoHost, MeshEchoReplicator, MetadataStore, SpaceManager, valueEncoding } from "@dxos/echo-pipeline";
import { createChainEdgeIdentity, createEphemeralEdgeIdentity } from "@dxos/edge-client";
import { FeedFactory, FeedStore } from "@dxos/feed-store";
import { invariant as invariant22 } from "@dxos/invariant";
import { Keyring } from "@dxos/keyring";
import { PublicKey as PublicKey15 } from "@dxos/keys";
import { log as log25 } from "@dxos/log";
import { InvalidStorageVersionError, STORAGE_VERSION as STORAGE_VERSION2, trace as trace10 } from "@dxos/protocols";
import { Invitation as Invitation10 } from "@dxos/protocols/proto/dxos/client/services";
import { BlobStore } from "@dxos/teleport-extension-object-sync";
import { trace as Trace3 } from "@dxos/tracing";
import { safeInstanceof } from "@dxos/util";

// packages/sdk/client-services/src/packlets/identity/identity-recovery-manager.ts
import { generateSeedPhrase, keyPairFromSeedPhrase } from "@dxos/credentials";
import { sign as sign3 } from "@dxos/crypto";
import { invariant as invariant21 } from "@dxos/invariant";
import { PublicKey as PublicKey14 } from "@dxos/keys";
import { log as log24 } from "@dxos/log";
import { EdgeAuthChallengeError as EdgeAuthChallengeError2 } from "@dxos/protocols";
import { schema as schema6 } from "@dxos/protocols/proto";
import { Timeframe as Timeframe5 } from "@dxos/timeframe";
var __dxlog_file28 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/identity/identity-recovery-manager.ts";
var EdgeIdentityRecoveryManager = class {
  constructor(_keyring, _edgeClient, _identityProvider, _acceptRecoveredIdentity) {
    this._keyring = _keyring;
    this._edgeClient = _edgeClient;
    this._identityProvider = _identityProvider;
    this._acceptRecoveredIdentity = _acceptRecoveredIdentity;
  }
  async createRecoveryCredential({ data }) {
    const identity = this._identityProvider();
    invariant21(identity, void 0, {
      F: __dxlog_file28,
      L: 39,
      S: this,
      A: [
        "identity",
        ""
      ]
    });
    let recoveryKey;
    let lookupKey;
    let algorithm;
    let recoveryCode;
    if (data) {
      recoveryKey = data.recoveryKey;
      lookupKey = data.lookupKey;
      algorithm = data.algorithm;
    } else {
      recoveryCode = generateSeedPhrase();
      const keypair = keyPairFromSeedPhrase(recoveryCode);
      recoveryKey = PublicKey14.from(keypair.publicKey);
      lookupKey = PublicKey14.from(keypair.publicKey);
      algorithm = "ED25519";
    }
    const identityKey = identity.identityKey;
    const credential = await identity.getIdentityCredentialSigner().createCredential({
      subject: identityKey,
      assertion: {
        "@type": "dxos.halo.credentials.IdentityRecovery",
        recoveryKey,
        identityKey,
        algorithm,
        lookupKey
      }
    });
    const receipt = await identity.controlPipeline.writer.write({
      credential: {
        credential
      }
    });
    await identity.controlPipeline.state.waitUntilTimeframe(new Timeframe5([
      [
        receipt.feedKey,
        receipt.seq
      ]
    ]));
    return {
      recoveryCode
    };
  }
  async requestRecoveryChallenge() {
    invariant21(this._edgeClient, "Not connected to EDGE.", {
      F: __dxlog_file28,
      L: 76,
      S: this,
      A: [
        "this._edgeClient",
        "'Not connected to EDGE.'"
      ]
    });
    const deviceKey = await this._keyring.createKey();
    const controlFeedKey = await this._keyring.createKey();
    const request = {
      deviceKey: deviceKey.toHex(),
      controlFeedKey: controlFeedKey.toHex()
    };
    try {
      await this._edgeClient.recoverIdentity(request);
      throw new Error("No challenge received.");
    } catch (error) {
      if (!(error instanceof EdgeAuthChallengeError2)) {
        throw error;
      }
      return {
        deviceKey,
        controlFeedKey,
        challenge: error.challenge
      };
    }
  }
  async recoverIdentityWithExternalSignature({ lookupKey, deviceKey, controlFeedKey, signature, clientDataJson, authenticatorData }) {
    invariant21(this._edgeClient, "Not connected to EDGE.", {
      F: __dxlog_file28,
      L: 108,
      S: this,
      A: [
        "this._edgeClient",
        "'Not connected to EDGE.'"
      ]
    });
    const request = {
      lookupKey: lookupKey.toHex(),
      deviceKey: deviceKey.toHex(),
      controlFeedKey: controlFeedKey.toHex(),
      signature: clientDataJson && authenticatorData ? {
        signature: Buffer.from(signature).toString("base64"),
        clientDataJson: Buffer.from(clientDataJson).toString("base64"),
        authenticatorData: Buffer.from(authenticatorData).toString("base64")
      } : Buffer.from(signature).toString("base64")
    };
    const response = await this._edgeClient.recoverIdentity(request);
    await this._acceptRecoveredIdentity({
      authorizedDeviceCredential: decodeCredential(response.deviceAuthCredential),
      haloGenesisFeedKey: PublicKey14.fromHex(response.genesisFeedKey),
      haloSpaceKey: PublicKey14.fromHex(response.haloSpaceKey),
      identityKey: PublicKey14.fromHex(response.identityKey),
      deviceKey,
      controlFeedKey,
      dataFeedKey: await this._keyring.createKey()
    });
  }
  /**
  * Recovery identity using an opaque token sent to the user's email.
  */
  async recoverIdentityWithToken({ token }) {
    invariant21(this._edgeClient, "Not connected to EDGE.", {
      F: __dxlog_file28,
      L: 141,
      S: this,
      A: [
        "this._edgeClient",
        "'Not connected to EDGE.'"
      ]
    });
    const deviceKey = await this._keyring.createKey();
    const controlFeedKey = await this._keyring.createKey();
    const request = {
      deviceKey: deviceKey.toHex(),
      controlFeedKey: controlFeedKey.toHex(),
      token
    };
    const response = await this._edgeClient.recoverIdentity(request);
    await this._acceptRecoveredIdentity({
      authorizedDeviceCredential: decodeCredential(response.deviceAuthCredential),
      haloGenesisFeedKey: PublicKey14.fromHex(response.genesisFeedKey),
      haloSpaceKey: PublicKey14.fromHex(response.haloSpaceKey),
      identityKey: PublicKey14.fromHex(response.identityKey),
      deviceKey,
      controlFeedKey,
      dataFeedKey: await this._keyring.createKey()
    });
  }
  async recoverIdentity({ recoveryCode }) {
    invariant21(this._edgeClient, "Not connected to EDGE.", {
      F: __dxlog_file28,
      L: 165,
      S: this,
      A: [
        "this._edgeClient",
        "'Not connected to EDGE.'"
      ]
    });
    const recoveryKeypair = keyPairFromSeedPhrase(recoveryCode);
    const recoveryKey = PublicKey14.from(recoveryKeypair.publicKey);
    const deviceKey = await this._keyring.createKey();
    const controlFeedKey = await this._keyring.createKey();
    const request = {
      lookupKey: recoveryKey.toHex(),
      deviceKey: deviceKey.toHex(),
      controlFeedKey: controlFeedKey.toHex()
    };
    let response;
    try {
      response = await this._edgeClient.recoverIdentity(request);
    } catch (error) {
      if (!(error instanceof EdgeAuthChallengeError2)) {
        throw error;
      }
      const signature = sign3(Buffer.from(error.challenge, "base64"), recoveryKeypair.secretKey);
      response = await this._edgeClient.recoverIdentity({
        ...request,
        signature: Buffer.from(signature).toString("base64")
      });
    }
    log24.info("recovering identity", response, {
      F: __dxlog_file28,
      L: 191,
      S: this,
      C: (f, a) => f(...a)
    });
    await this._acceptRecoveredIdentity({
      authorizedDeviceCredential: decodeCredential(response.deviceAuthCredential),
      haloGenesisFeedKey: PublicKey14.fromHex(response.genesisFeedKey),
      haloSpaceKey: PublicKey14.fromHex(response.haloSpaceKey),
      identityKey: PublicKey14.fromHex(response.identityKey),
      deviceKey,
      controlFeedKey,
      dataFeedKey: await this._keyring.createKey()
    });
  }
};
var decodeCredential = (credentialBase64) => {
  const credentialBytes = Buffer.from(credentialBase64, "base64");
  const codec = schema6.getCodecForType("dxos.halo.credentials.Credential");
  return codec.decode(credentialBytes);
};

// packages/sdk/client-services/src/packlets/services/service-context.ts
function _ts_decorate10(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function _ts_add_disposable_resource4(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = function() {
      try {
        inner.call(this);
      } catch (e) {
        return Promise.reject(e);
      }
    };
    env.stack.push({
      value,
      dispose,
      async
    });
  } else if (async) {
    env.stack.push({
      async: true
    });
  }
  return value;
}
function _ts_dispose_resources4(env) {
  var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  };
  return (_ts_dispose_resources4 = function _ts_dispose_resources5(env2) {
    function fail(e) {
      env2.error = env2.hasError ? new _SuppressedError(e, env2.error, "An error was suppressed during disposal.") : e;
      env2.hasError = true;
    }
    var r, s = 0;
    function next() {
      while (r = env2.stack.pop()) {
        try {
          if (!r.async && s === 1) return s = 0, env2.stack.push(r), Promise.resolve().then(next);
          if (r.dispose) {
            var result = r.dispose.call(r.value);
            if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
              fail(e);
              return next();
            });
          } else s |= 1;
        } catch (e) {
          fail(e);
        }
      }
      if (s === 1) return env2.hasError ? Promise.reject(env2.error) : Promise.resolve();
      if (env2.hasError) throw env2.error;
    }
    return next();
  })(env);
}
var __dxlog_file29 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/services/service-context.ts";
var ServiceContext = class extends Resource8 {
  constructor(storage, level, networkManager, signalManager, _edgeConnection, _edgeHttpClient, _runtimeParams, _edgeFeatures) {
    super(), this.storage = storage, this.level = level, this.networkManager = networkManager, this.signalManager = signalManager, this._edgeConnection = _edgeConnection, this._edgeHttpClient = _edgeHttpClient, this._runtimeParams = _runtimeParams, this._edgeFeatures = _edgeFeatures, this._edgeIdentityUpdateMutex = new Mutex4(), this.initialized = new Trigger9(), this._meshReplicator = void 0, this._echoEdgeReplicator = void 0, this._handlerFactories = /* @__PURE__ */ new Map(), this._instanceId = PublicKey15.random().toHex();
    this.metadataStore = new MetadataStore(storage.createDirectory("metadata"));
    this.blobStore = new BlobStore(storage.createDirectory("blobs"));
    this.keyring = new Keyring(storage.createDirectory("keyring"));
    this.feedStore = new FeedStore({
      factory: new FeedFactory({
        root: storage.createDirectory("feeds"),
        signer: this.keyring,
        hypercore: {
          valueEncoding,
          stats: true
        }
      })
    });
    this.spaceManager = new SpaceManager({
      feedStore: this.feedStore,
      networkManager: this.networkManager,
      blobStore: this.blobStore,
      metadataStore: this.metadataStore,
      disableP2pReplication: this._runtimeParams?.disableP2pReplication
    });
    this.identityManager = new IdentityManager({
      metadataStore: this.metadataStore,
      keyring: this.keyring,
      feedStore: this.feedStore,
      spaceManager: this.spaceManager,
      devicePresenceOfflineTimeout: this._runtimeParams?.devicePresenceOfflineTimeout,
      devicePresenceAnnounceInterval: this._runtimeParams?.devicePresenceAnnounceInterval,
      edgeConnection: this._edgeConnection,
      edgeFeatures: this._edgeFeatures
    });
    this.recoveryManager = new EdgeIdentityRecoveryManager(this.keyring, this._edgeHttpClient, () => this.identityManager.identity, this._acceptIdentity.bind(this));
    this.echoHost = new EchoHost({
      kv: this.level,
      peerIdProvider: () => this.identityManager.identity?.deviceKey?.toHex(),
      getSpaceKeyByRootDocumentId: (documentId) => this.spaceManager.findSpaceByRootDocumentId(documentId)?.key,
      indexing: {
        vector: this._runtimeParams?.enableVectorIndexing
      }
    });
    this._meshReplicator = new MeshEchoReplicator();
    this.invitations = new InvitationsHandler(this.networkManager, this._edgeHttpClient, _runtimeParams?.invitationConnectionDefaultParams);
    this.invitationsManager = new InvitationsManager(this.invitations, (invitation) => this.getInvitationHandler(invitation), this.metadataStore);
    this._handlerFactories.set(Invitation10.Kind.DEVICE, () => new DeviceInvitationProtocol(this.keyring, () => this.identityManager.identity ?? failUndefined2(), this._acceptIdentity.bind(this)));
    if (!this._runtimeParams?.disableP2pReplication) {
      this._meshReplicator = new MeshEchoReplicator();
    }
    if (this._edgeConnection && this._edgeFeatures?.echoReplicator) {
      this._echoEdgeReplicator = new EchoEdgeReplicator({
        edgeConnection: this._edgeConnection
      });
    }
  }
  async _open(ctx) {
    await this._checkStorageVersion();
    log25("opening...", void 0, {
      F: __dxlog_file29,
      L: 203,
      S: this,
      C: (f, a) => f(...a)
    });
    log25.trace("dxos.sdk.service-context.open", trace10.begin({
      id: this._instanceId
    }), {
      F: __dxlog_file29,
      L: 204,
      S: this,
      C: (f, a) => f(...a)
    });
    await this.identityManager.open(ctx);
    await this._setNetworkIdentity();
    await this._edgeConnection?.open();
    await this.signalManager.open();
    await this.networkManager.open();
    await this.echoHost.open(ctx);
    if (this._meshReplicator) {
      await this.echoHost.addReplicator(this._meshReplicator);
    }
    if (this._echoEdgeReplicator) {
      await this.echoHost.addReplicator(this._echoEdgeReplicator);
    }
    await this.metadataStore.load();
    await this.spaceManager.open();
    if (this.identityManager.identity) {
      await this.identityManager.identity.joinNetwork();
      await this._initialize(ctx);
    }
    const loadedInvitations = await this.invitationsManager.loadPersistentInvitations();
    log25("loaded persistent invitations", {
      count: loadedInvitations.invitations?.length
    }, {
      F: __dxlog_file29,
      L: 232,
      S: this,
      C: (f, a) => f(...a)
    });
    log25.trace("dxos.sdk.service-context.open", trace10.end({
      id: this._instanceId
    }), {
      F: __dxlog_file29,
      L: 234,
      S: this,
      C: (f, a) => f(...a)
    });
    log25("opened", void 0, {
      F: __dxlog_file29,
      L: 235,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  async _close(ctx) {
    log25("closing...", void 0, {
      F: __dxlog_file29,
      L: 239,
      S: this,
      C: (f, a) => f(...a)
    });
    if (this._deviceSpaceSync && this.identityManager.identity) {
      await this.identityManager.identity.space.spaceState.removeCredentialProcessor(this._deviceSpaceSync);
    }
    await this.dataSpaceManager?.close();
    await this.edgeAgentManager?.close();
    await this.identityManager.close();
    await this.spaceManager.close();
    await this.feedStore.close();
    await this.metadataStore.close();
    await this.echoHost.close(ctx);
    await this.networkManager.close();
    await this.signalManager.close();
    await this._edgeConnection?.close();
    log25("closed", void 0, {
      F: __dxlog_file29,
      L: 255,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  async createIdentity(params = {}) {
    const identity = await this.identityManager.createIdentity(params);
    await this._setNetworkIdentity();
    await identity.joinNetwork();
    await this._initialize(new Context10(void 0, {
      F: __dxlog_file29,
      L: 262
    }));
    return identity;
  }
  getInvitationHandler(invitation) {
    if (this.identityManager.identity == null && invitation.kind === Invitation10.Kind.SPACE) {
      throw new Error("Identity must be created before joining a space.");
    }
    const factory = this._handlerFactories.get(invitation.kind);
    invariant22(factory, `Unknown invitation kind: ${invitation.kind}`, {
      F: __dxlog_file29,
      L: 271,
      S: this,
      A: [
        "factory",
        "`Unknown invitation kind: ${invitation.kind}`"
      ]
    });
    return factory(invitation);
  }
  async broadcastProfileUpdate(profile) {
    if (!profile || !this.dataSpaceManager) {
      return;
    }
    for (const space of this.dataSpaceManager.spaces.values()) {
      await space.updateOwnProfile(profile);
    }
  }
  async _acceptIdentity(params) {
    const { identity, identityRecord } = await this.identityManager.prepareIdentity(params);
    await this._setNetworkIdentity({
      deviceCredential: params.authorizedDeviceCredential
    });
    await identity.joinNetwork();
    await this.identityManager.acceptIdentity(identity, identityRecord, params.deviceProfile);
    await this._initialize(new Context10(void 0, {
      F: __dxlog_file29,
      L: 290
    }));
    return identity;
  }
  async _checkStorageVersion() {
    await this.metadataStore.load();
    if (this.metadataStore.version !== STORAGE_VERSION2) {
      throw new InvalidStorageVersionError(STORAGE_VERSION2, this.metadataStore.version);
    }
  }
  // Called when identity is created.
  async _initialize(ctx) {
    log25("initializing spaces...", void 0, {
      F: __dxlog_file29,
      L: 305,
      S: this,
      C: (f, a) => f(...a)
    });
    const identity = this.identityManager.identity ?? failUndefined2();
    const signingContext = {
      credentialSigner: identity.getIdentityCredentialSigner(),
      identityKey: identity.identityKey,
      deviceKey: identity.deviceKey,
      getProfile: () => identity.profileDocument,
      recordCredential: async (credential) => {
        await identity.controlPipeline.writer.write({
          credential: {
            credential
          }
        });
      }
    };
    this.dataSpaceManager = new DataSpaceManager({
      spaceManager: this.spaceManager,
      metadataStore: this.metadataStore,
      keyring: this.keyring,
      signingContext,
      feedStore: this.feedStore,
      echoHost: this.echoHost,
      invitationsManager: this.invitationsManager,
      edgeConnection: this._edgeConnection,
      edgeHttpClient: this._edgeHttpClient,
      echoEdgeReplicator: this._echoEdgeReplicator,
      meshReplicator: this._meshReplicator,
      runtimeParams: this._runtimeParams,
      edgeFeatures: this._edgeFeatures
    });
    await this.dataSpaceManager.open();
    this.edgeAgentManager = new EdgeAgentManager(this._edgeFeatures, this._edgeHttpClient, this.dataSpaceManager, identity);
    await this.edgeAgentManager.open();
    this._handlerFactories.set(Invitation10.Kind.SPACE, (invitation) => {
      invariant22(this.dataSpaceManager, "dataSpaceManager not initialized yet", {
        F: __dxlog_file29,
        L: 343,
        S: this,
        A: [
          "this.dataSpaceManager",
          "'dataSpaceManager not initialized yet'"
        ]
      });
      return new SpaceInvitationProtocol(this.dataSpaceManager, signingContext, this.keyring, invitation.spaceKey);
    });
    this.initialized.wake();
    this._deviceSpaceSync = {
      processCredential: async (credential) => {
        const assertion = getCredentialAssertion6(credential);
        if (assertion["@type"] !== "dxos.halo.credentials.SpaceMember") {
          return;
        }
        if (assertion.spaceKey.equals(identity.space.key)) {
          return;
        }
        if (!this.dataSpaceManager) {
          log25("dataSpaceManager not initialized yet, ignoring space admission", {
            details: assertion
          }, {
            F: __dxlog_file29,
            L: 359,
            S: this,
            C: (f, a) => f(...a)
          });
          return;
        }
        if (this.dataSpaceManager.spaces.has(assertion.spaceKey)) {
          log25("space already exists, ignoring space admission", {
            details: assertion
          }, {
            F: __dxlog_file29,
            L: 363,
            S: this,
            C: (f, a) => f(...a)
          });
          return;
        }
        try {
          log25("accepting space recorded in halo", {
            details: assertion
          }, {
            F: __dxlog_file29,
            L: 368,
            S: this,
            C: (f, a) => f(...a)
          });
          await this.dataSpaceManager.acceptSpace({
            spaceKey: assertion.spaceKey,
            genesisFeedKey: assertion.genesisFeedKey
          });
        } catch (err) {
          log25.catch(err, void 0, {
            F: __dxlog_file29,
            L: 374,
            S: this,
            C: (f, a) => f(...a)
          });
        }
      }
    };
    await identity.space.spaceState.addCredentialProcessor(this._deviceSpaceSync);
  }
  async _setNetworkIdentity(params) {
    const env = {
      stack: [],
      error: void 0,
      hasError: false
    };
    try {
      const _ = _ts_add_disposable_resource4(env, await this._edgeIdentityUpdateMutex.acquire(), false);
      let edgeIdentity;
      const identity = this.identityManager.identity;
      if (identity) {
        log25("setting identity on edge connection", {
          identity: identity.identityKey.toHex(),
          swarms: this.networkManager.topics
        }, {
          F: __dxlog_file29,
          L: 388,
          S: this,
          C: (f, a) => f(...a)
        });
        if (params?.deviceCredential) {
          edgeIdentity = await createChainEdgeIdentity(identity.signer, identity.identityKey, identity.deviceKey, params?.deviceCredential && {
            credential: params.deviceCredential
          }, []);
        } else {
          await warnAfterTimeout2(1e4, "Waiting for identity to be ready for edge connection", async () => {
            await identity.ready();
          });
          invariant22(identity.deviceCredentialChain, void 0, {
            F: __dxlog_file29,
            L: 407,
            S: this,
            A: [
              "identity.deviceCredentialChain",
              ""
            ]
          });
          edgeIdentity = await createChainEdgeIdentity(identity.signer, identity.identityKey, identity.deviceKey, identity.deviceCredentialChain, []);
        }
      } else {
        edgeIdentity = await createEphemeralEdgeIdentity();
      }
      this._edgeConnection?.setIdentity(edgeIdentity);
      this._edgeHttpClient?.setIdentity(edgeIdentity);
      this.networkManager.setPeerInfo({
        identityKey: edgeIdentity.identityKey,
        peerKey: edgeIdentity.peerKey
      });
    } catch (e) {
      env.error = e;
      env.hasError = true;
    } finally {
      _ts_dispose_resources4(env);
    }
  }
};
_ts_decorate10([
  Trace3.span()
], ServiceContext.prototype, "_open", null);
_ts_decorate10([
  Trace3.span()
], ServiceContext.prototype, "_initialize", null);
ServiceContext = _ts_decorate10([
  safeInstanceof("dxos.client-services.ServiceContext"),
  Trace3.resource()
], ServiceContext);

// packages/sdk/client-services/src/packlets/services/service-registry.ts
var ServiceRegistry = class {
  // prettier-ignore
  constructor(_serviceBundle, _handlers = {}) {
    this._serviceBundle = _serviceBundle;
    this._handlers = _handlers;
  }
  get descriptors() {
    return this._serviceBundle;
  }
  get services() {
    return this._handlers;
  }
  setServices(services) {
    this._handlers = services;
  }
  addService(name, service) {
    this._handlers[name] = service;
  }
  removeService(name) {
    delete this._handlers[name];
  }
};

// packages/sdk/client-services/src/packlets/storage/storage.ts
import { InvalidConfigError } from "@dxos/protocols";
import { Runtime as Runtime2 } from "@dxos/protocols/proto/dxos/config";
import { createStorage, StorageType } from "@dxos/random-access-storage";

// packages/sdk/client-services/src/packlets/storage/util.ts
import { DX_DATA } from "@dxos/client-protocol";
import { Runtime } from "@dxos/protocols/proto/dxos/config";
import { isNode as isNode2 } from "@dxos/util";
var getRootPath = (config) => {
  const { dataRoot = isNode2() ? DX_DATA : "dxos/storage" } = config ?? {};
  return `${dataRoot}/`;
};
var isPersistent = (config) => {
  const { persistent = false } = config ?? {};
  return config.dataStore !== void 0 && config.dataStore !== Runtime.Client.Storage.StorageDriver.RAM || persistent;
};

// packages/sdk/client-services/src/packlets/storage/storage.ts
var StorageDriver = Runtime2.Client.Storage.StorageDriver;
var createStorageObjects = (config) => {
  const { persistent = false, keyStore, dataStore } = config ?? {};
  if (persistent && dataStore === StorageDriver.RAM) {
    throw new InvalidConfigError("RAM storage cannot be used in persistent mode.");
  }
  if (!persistent && dataStore !== void 0 && dataStore !== StorageDriver.RAM) {
    throw new InvalidConfigError("Cannot use a persistent storage in not persistent mode.");
  }
  if (persistent && keyStore === StorageDriver.RAM) {
    throw new InvalidConfigError("RAM key storage cannot be used in persistent mode.");
  }
  if (!persistent && keyStore !== StorageDriver.RAM && keyStore !== void 0) {
    throw new InvalidConfigError("Cannot use a persistent key storage in not persistent mode.");
  }
  return {
    storage: createStorage({
      type: persistent ? toStorageType(dataStore) : StorageType.RAM,
      root: getRootPath(config)
    })
  };
};
var toStorageType = (type) => {
  switch (type) {
    case void 0:
      return void 0;
    case StorageDriver.RAM:
      return StorageType.RAM;
    case StorageDriver.CHROME:
      return StorageType.CHROME;
    case StorageDriver.FIREFOX:
      return StorageType.FIREFOX;
    case StorageDriver.IDB:
      return StorageType.IDB;
    case StorageDriver.NODE:
      return StorageType.NODE;
    case StorageDriver.WEBFS:
      return StorageType.WEBFS;
    default:
      throw new Error(`Invalid storage type: ${StorageDriver[type]}`);
  }
};

// packages/sdk/client-services/src/packlets/storage/level.ts
import path from "@dxos/node-std/path";
import { PublicKey as PublicKey16 } from "@dxos/keys";
import { createLevel as createKV } from "@dxos/kv-store";
var createLevel = async (config) => {
  const persistent = isPersistent(config);
  const storagePath = persistent ? path.join(getRootPath(config), "level") : `/tmp/dxos-${PublicKey16.random().toHex()}`;
  const level = createKV(storagePath);
  await level.open();
  return level;
};

// packages/sdk/client-services/src/packlets/storage/profile-archive.ts
import { cbor } from "@automerge/automerge-repo";
import { invariant as invariant23 } from "@dxos/invariant";
import { log as log26 } from "@dxos/log";
import { ProfileArchiveEntryType } from "@dxos/protocols";
import { arrayToBuffer as arrayToBuffer2 } from "@dxos/util";
var __dxlog_file30 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/storage/profile-archive.ts";
var encodeProfileArchive = (profile) => cbor.encode(profile);
var decodeProfileArchive = (data) => cbor.decode(data);
var exportProfileData = async ({ storage, level }) => {
  const archive = {
    storage: [],
    meta: {
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    }
  };
  {
    const directory = await storage.createDirectory();
    const files = await directory.list();
    log26.info("begin exporting files", {
      count: files.length
    }, {
      F: __dxlog_file30,
      L: 31,
      S: void 0,
      C: (f, a) => f(...a)
    });
    for (const filename of files) {
      const file = await directory.getOrCreateFile(filename);
      const { size } = await file.stat();
      const data = await file.read(0, size);
      archive.storage.push({
        type: ProfileArchiveEntryType.FILE,
        key: filename,
        value: data
      });
    }
    log26.info("done exporting files", {
      count: files.length
    }, {
      F: __dxlog_file30,
      L: 42,
      S: void 0,
      C: (f, a) => f(...a)
    });
  }
  {
    log26.info("begin exporting kv pairs", void 0, {
      F: __dxlog_file30,
      L: 46,
      S: void 0,
      C: (f, a) => f(...a)
    });
    const iter = await level.iterator({
      keyEncoding: "binary",
      valueEncoding: "binary"
    });
    let count = 0;
    for await (const [key, value] of iter) {
      archive.storage.push({
        type: ProfileArchiveEntryType.KEY_VALUE,
        key,
        value
      });
      count++;
    }
    log26.info("done exporting kv pairs", {
      count
    }, {
      F: __dxlog_file30,
      L: 57,
      S: void 0,
      C: (f, a) => f(...a)
    });
  }
  return archive;
};
var importProfileData = async ({ storage, level }, archive) => {
  let batch = level.batch();
  let count = 0;
  for (const entry2 of archive.storage) {
    switch (entry2.type) {
      case ProfileArchiveEntryType.FILE: {
        const directory = await storage.createDirectory();
        invariant23(typeof entry2.key === "string", "Invalid key type", {
          F: __dxlog_file30,
          L: 80,
          S: void 0,
          A: [
            "typeof entry.key === 'string'",
            "'Invalid key type'"
          ]
        });
        const file = await directory.getOrCreateFile(entry2.key);
        invariant23(entry2.value instanceof Uint8Array, "Invalid value type", {
          F: __dxlog_file30,
          L: 82,
          S: void 0,
          A: [
            "entry.value instanceof Uint8Array",
            "'Invalid value type'"
          ]
        });
        await file.write(0, arrayToBuffer2(entry2.value));
        await file.close();
        break;
      }
      case ProfileArchiveEntryType.KEY_VALUE: {
        invariant23(entry2.key instanceof Uint8Array, "Invalid key type", {
          F: __dxlog_file30,
          L: 88,
          S: void 0,
          A: [
            "entry.key instanceof Uint8Array",
            "'Invalid key type'"
          ]
        });
        invariant23(entry2.value instanceof Uint8Array, "Invalid value type", {
          F: __dxlog_file30,
          L: 89,
          S: void 0,
          A: [
            "entry.value instanceof Uint8Array",
            "'Invalid value type'"
          ]
        });
        batch.put(entry2.key, entry2.value, {
          keyEncoding: "binary",
          valueEncoding: "binary"
        });
        break;
      }
      default:
        throw new Error(`Invalid entry type: ${entry2.type}`);
    }
    if (++count % 1e3 === 0) {
      await batch.write();
      batch = level.batch();
      log26.info("importing", {
        count,
        total: archive.storage.length,
        progress: `${(count / archive.storage.length * 100).toFixed()}%`
      }, {
        F: __dxlog_file30,
        L: 102,
        S: void 0,
        C: (f, a) => f(...a)
      });
    }
  }
  log26.info("committing changes..", void 0, {
    F: __dxlog_file30,
    L: 110,
    S: void 0,
    C: (f, a) => f(...a)
  });
  await batch.write();
};

// packages/sdk/client-services/src/packlets/services/service-host.ts
import { Event as Event11, synchronized as synchronized4 } from "@dxos/async";
import { clientServiceBundle } from "@dxos/client-protocol";
import { Context as Context11 } from "@dxos/context";
import { EdgeClient, EdgeHttpClient, createStubEdgeIdentity } from "@dxos/edge-client";
import { invariant as invariant25 } from "@dxos/invariant";
import { PublicKey as PublicKey19 } from "@dxos/keys";
import { log as log28 } from "@dxos/log";
import { EdgeSignalManager, WebsocketSignalManager } from "@dxos/messaging";
import { SwarmNetworkManager, createIceProvider, createRtcTransportFactory } from "@dxos/network-manager";
import { trace as trace11 } from "@dxos/protocols";
import { SystemStatus } from "@dxos/protocols/proto/dxos/client/services";
import { TRACE_PROCESSOR as TRACE_PROCESSOR3, trace as Trace4 } from "@dxos/tracing";
import { WebsocketRpcClient } from "@dxos/websocket-rpc";

// packages/sdk/client-services/src/packlets/devices/devices-service.ts
import { SubscriptionList as SubscriptionList3 } from "@dxos/async";
import { Stream as Stream12 } from "@dxos/codec-protobuf/stream";
import { invariant as invariant24 } from "@dxos/invariant";
import { Device as Device2, DeviceKind as DeviceKind2, EdgeStatus as EdgeStatus3 } from "@dxos/protocols/proto/dxos/client/services";
var __dxlog_file31 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/devices/devices-service.ts";
var DevicesServiceImpl = class {
  constructor(_identityManager, _edgeConnection) {
    this._identityManager = _identityManager;
    this._edgeConnection = _edgeConnection;
  }
  async updateDevice(profile) {
    return this._identityManager.updateDeviceProfile(profile);
  }
  queryDevices() {
    return new Stream12(({ next }) => {
      const update = () => {
        const deviceKeys = this._identityManager.identity?.authorizedDeviceKeys;
        if (!deviceKeys) {
          next({
            devices: []
          });
        } else {
          invariant24(this._identityManager.identity?.presence, "presence not present", {
            F: __dxlog_file31,
            L: 37,
            S: this,
            A: [
              "this._identityManager.identity?.presence",
              "'presence not present'"
            ]
          });
          const peers = this._identityManager.identity.presence.getPeersOnline();
          next({
            devices: Array.from(deviceKeys.entries()).map(([key, profile]) => {
              const isMe = this._identityManager.identity?.deviceKey.equals(key);
              let presence;
              if (isMe) {
                presence = Device2.PresenceState.ONLINE;
              } else if (profile.os?.toUpperCase() === "EDGE") {
                presence = this._edgeConnection?.status === EdgeStatus3.CONNECTED ? Device2.PresenceState.ONLINE : Device2.PresenceState.OFFLINE;
              } else {
                presence = peers.some((peer) => peer.identityKey.equals(key)) ? Device2.PresenceState.ONLINE : Device2.PresenceState.OFFLINE;
              }
              return {
                deviceKey: key,
                kind: this._identityManager.identity?.deviceKey.equals(key) ? DeviceKind2.CURRENT : DeviceKind2.TRUSTED,
                profile,
                presence
              };
            })
          });
        }
      };
      let identitySubscribed = false;
      let presenceSubscribed = false;
      const subscribeIdentity = () => {
        if (!identitySubscribed) {
          this._identityManager.identity?.stateUpdate.on(() => {
            update();
          });
          identitySubscribed = true;
        }
      };
      const subscribePresence = () => {
        if (!presenceSubscribed) {
          this._identityManager.identity?.presence?.updated.on(() => {
            update();
          });
          presenceSubscribed = true;
        }
      };
      const subscriptions = new SubscriptionList3();
      if (this._identityManager.identity) {
        subscribeIdentity();
        subscribePresence();
      }
      subscriptions.add(this._identityManager.stateUpdate.on(() => {
        update();
        if (this._identityManager.identity) {
          subscribeIdentity();
          subscribePresence();
        }
      }));
      update();
      return () => subscriptions.clear();
    });
  }
};

// packages/sdk/client-services/src/packlets/identity/contacts-service.ts
import { scheduleTask as scheduleTask9, UpdateScheduler as UpdateScheduler2, SubscriptionList as SubscriptionList4 } from "@dxos/async";
import { Stream as Stream13 } from "@dxos/codec-protobuf/stream";
import { PublicKey as PublicKey17 } from "@dxos/keys";
import { ComplexMap as ComplexMap5, ComplexSet as ComplexSet6 } from "@dxos/util";
var ContactsServiceImpl = class {
  constructor(_identityManager, _spaceManager, _dataSpaceManagerProvider) {
    this._identityManager = _identityManager;
    this._spaceManager = _spaceManager;
    this._dataSpaceManagerProvider = _dataSpaceManagerProvider;
  }
  async getContacts() {
    const identity = this._identityManager.identity;
    if (identity == null) {
      return {
        contacts: []
      };
    }
    const contacts = [
      ...this._spaceManager.spaces.values()
    ].flatMap((s) => [
      ...s.spaceState.members.values()
    ].map((m) => [
      s.key,
      m
    ])).reduce((acc, v) => {
      const [spaceKey, memberInfo] = v;
      if (memberInfo.key.equals(identity.identityKey)) {
        return acc;
      }
      const existing = acc.get(memberInfo.key);
      if (existing != null) {
        existing.profile ??= memberInfo.profile;
        existing.commonSpaces?.push(spaceKey);
      } else {
        acc.set(memberInfo.key, {
          identityKey: memberInfo.key,
          profile: memberInfo.profile,
          commonSpaces: [
            spaceKey
          ]
        });
      }
      return acc;
    }, new ComplexMap5(PublicKey17.hash));
    return {
      contacts: [
        ...contacts.values()
      ]
    };
  }
  queryContacts() {
    const subscribedSpaceKeySet = new ComplexSet6(PublicKey17.hash);
    return new Stream13(({ next, ctx }) => {
      const pushUpdateTask = new UpdateScheduler2(ctx, async () => {
        const contacts = await this.getContacts();
        next(contacts);
      }, {
        maxFrequency: 2
      });
      scheduleTask9(ctx, async () => {
        const subscriptions = new SubscriptionList4();
        ctx.onDispose(() => subscriptions.clear());
        const subscribeToSpaceAndUpdate = () => {
          const oldSetSize = subscribedSpaceKeySet.size;
          for (const space of this._spaceManager.spaces.values()) {
            if (!subscribedSpaceKeySet.has(space.key)) {
              subscriptions.add(space.stateUpdate.on(ctx, () => pushUpdateTask.trigger()));
              subscribedSpaceKeySet.add(space.key);
            }
          }
          if (oldSetSize !== subscribedSpaceKeySet.size) {
            pushUpdateTask.trigger();
          }
        };
        const unsubscribe = (await this._dataSpaceManagerProvider()).updated.on(ctx, subscribeToSpaceAndUpdate);
        ctx.onDispose(unsubscribe);
        subscribeToSpaceAndUpdate();
      });
    });
  }
};

// packages/sdk/client-services/src/packlets/logging/logging-service.ts
import { Event as Event10 } from "@dxos/async";
import { Stream as Stream14 } from "@dxos/codec-protobuf/stream";
import { PublicKey as PublicKey18 } from "@dxos/keys";
import { getContextFromEntry, log as log27 } from "@dxos/log";
import { QueryLogsRequest } from "@dxos/protocols/proto/dxos/client/services";
import { getDebugName, jsonify, numericalValues, tracer } from "@dxos/util";
var LoggingServiceImpl = class {
  constructor() {
    this._logs = new Event10();
    this._started = Date.now();
    this._sessionId = PublicKey18.random().toHex();
    this._logProcessor = (_config, entry2) => {
      this._logs.emit(entry2);
    };
  }
  async open() {
    log27.runtimeConfig.processors.push(this._logProcessor);
  }
  async close() {
    const index = log27.runtimeConfig.processors.findIndex((processor) => processor === this._logProcessor);
    log27.runtimeConfig.processors.splice(index, 1);
  }
  async controlMetrics({ reset, record }) {
    if (reset) {
      tracer.clear();
    }
    if (record === true) {
      tracer.start();
    } else if (record === false) {
      tracer.stop();
    }
    return {
      recording: tracer.recording
    };
  }
  /**
  * @deprecated (Move to diagnostics).
  */
  queryMetrics({ interval = 5e3 }) {
    const getNumericalValues = (key) => {
      const events = tracer.get(key) ?? [];
      return {
        key,
        stats: numericalValues(events, "duration")
      };
    };
    return new Stream14(({ next }) => {
      const update = () => {
        const metrics2 = {
          timestamp: /* @__PURE__ */ new Date(),
          values: [
            getNumericalValues("dxos.echo.pipeline.control"),
            getNumericalValues("dxos.echo.pipeline.data")
          ].filter(Boolean)
        };
        next({
          timestamp: /* @__PURE__ */ new Date(),
          metrics: metrics2
        });
      };
      update();
      const i = setInterval(update, Math.max(interval, 1e3));
      return () => {
        clearInterval(i);
      };
    });
  }
  queryLogs(request) {
    return new Stream14(({ ctx, next }) => {
      const handler = (entry2) => {
        if (LOG_PROCESSING > 0) {
          return;
        }
        if (entry2.meta?.F.includes("logging-service") || entry2.context && Object.values(entry2.context).some((value) => typeof value === "string" && value.includes("LoggingService"))) {
          return;
        }
        if (!shouldLog(entry2, request)) {
          return;
        }
        const record = {
          ...entry2,
          context: jsonify(getContextFromEntry(entry2)),
          timestamp: /* @__PURE__ */ new Date(),
          meta: {
            // TODO(dmaretskyi): Fix proto.
            file: entry2.meta?.F ?? "",
            line: entry2.meta?.L ?? 0,
            scope: {
              hostSessionId: this._sessionId,
              uptimeSeconds: (Date.now() - this._started) / 1e3,
              name: getDebugName(entry2.meta?.S)
            }
          }
        };
        try {
          LOG_PROCESSING++;
          next(record);
        } finally {
          LOG_PROCESSING--;
        }
      };
      this._logs.on(ctx, handler);
    });
  }
};
var matchFilter = (filter, level, path2, options) => {
  switch (options) {
    case QueryLogsRequest.MatchingOptions.INCLUSIVE:
      return level >= filter.level && (!filter.pattern || path2.includes(filter.pattern));
    case QueryLogsRequest.MatchingOptions.EXPLICIT:
      return level === filter.level && (!filter.pattern || path2.includes(filter.pattern));
  }
};
var shouldLog = (entry2, request) => {
  const options = request.options ?? QueryLogsRequest.MatchingOptions.INCLUSIVE;
  if (request.filters === void 0) {
    return options === QueryLogsRequest.MatchingOptions.INCLUSIVE;
  } else {
    return request.filters.some((filter) => matchFilter(filter, entry2.level, entry2.meta?.F ?? "", options));
  }
};
var LOG_PROCESSING = 0;

// packages/sdk/client-services/src/packlets/network/network-service.ts
import { Stream as Stream15 } from "@dxos/codec-protobuf/stream";
var NetworkServiceImpl = class {
  constructor(networkManager, signalManager, edgeConnection) {
    this.networkManager = networkManager;
    this.signalManager = signalManager;
    this.edgeConnection = edgeConnection;
  }
  queryStatus() {
    return new Stream15(({ ctx, next }) => {
      const update = () => {
        next({
          swarm: this.networkManager.connectionState,
          connectionInfo: this.networkManager.connectionLog?.swarms,
          signaling: this.signalManager.getStatus?.().map(({ host, state }) => ({
            server: host,
            state
          }))
        });
      };
      this.networkManager.connectionStateChanged.on(ctx, () => update());
      this.signalManager.statusChanged?.on(ctx, () => update());
      update();
    });
  }
  async updateConfig(request) {
    await this.networkManager.setConnectionState(request.swarm);
  }
  async joinSwarm(request) {
    return this.signalManager.join(request);
  }
  async leaveSwarm(request) {
    return this.signalManager.leave(request);
  }
  async querySwarm(request) {
    return this.signalManager.query(request);
  }
  subscribeSwarmState(request) {
    return new Stream15(({ ctx, next }) => {
      this.signalManager.swarmState?.on(ctx, (state) => {
        if (request.topic.equals(state.swarmKey)) {
          next(state);
        }
      });
    });
  }
  async sendMessage(message) {
    return this.signalManager.sendMessage(message);
  }
  subscribeMessages(peer) {
    return new Stream15(({ ctx, next }) => {
      this.signalManager.onMessage.on(ctx, (message) => {
        if (message.recipient.peerKey === peer.peerKey) {
          next(message);
        }
      });
    });
  }
};

// packages/sdk/client-services/src/packlets/system/system-service.ts
import { Stream as Stream16 } from "@dxos/codec-protobuf/stream";
import { GetDiagnosticsRequest as GetDiagnosticsRequest2 } from "@dxos/protocols/proto/dxos/client/services";
import { jsonKeyReplacer as jsonKeyReplacer2 } from "@dxos/util";
var SystemServiceImpl = class {
  constructor({ config, statusUpdate, getDiagnostics, onUpdateStatus, getCurrentStatus, onReset }) {
    this._config = config;
    this._statusUpdate = statusUpdate;
    this._getCurrentStatus = getCurrentStatus;
    this._getDiagnostics = getDiagnostics;
    this._onUpdateStatus = onUpdateStatus;
    this._onReset = onReset;
  }
  async getConfig() {
    return (await this._config?.())?.values ?? {};
  }
  /**
  * NOTE: Since this is serialized as a JSON object, we allow the option to serialize keys.
  */
  async getDiagnostics({ keys } = {}) {
    const diagnostics = await this._getDiagnostics();
    return {
      timestamp: /* @__PURE__ */ new Date(),
      diagnostics: JSON.parse(JSON.stringify(diagnostics, jsonKeyReplacer2({
        truncate: keys === GetDiagnosticsRequest2.KEY_OPTION.TRUNCATE,
        humanize: keys === GetDiagnosticsRequest2.KEY_OPTION.HUMANIZE
      })))
    };
  }
  async getPlatform() {
    return getPlatform();
  }
  async updateStatus({ status }) {
    await this._onUpdateStatus(status);
  }
  // TODO(burdon): Standardize interval option in stream request?
  queryStatus({ interval = 3e3 } = {}) {
    return new Stream16(({ next }) => {
      const update = () => {
        next({
          status: this._getCurrentStatus()
        });
      };
      update();
      const unsubscribe = this._statusUpdate.on(() => update());
      const i = setInterval(update, interval);
      return () => {
        clearInterval(i);
        unsubscribe();
      };
    });
  }
  async reset() {
    await this._onReset();
  }
};

// packages/sdk/client-services/src/packlets/services/service-host.ts
function _ts_decorate11(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file32 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/services/service-host.ts";
var ClientServicesHost = class {
  constructor({
    config,
    transportFactory,
    signalManager,
    storage,
    level,
    // TODO(wittjosiah): Turn this on by default.
    lockKey,
    callbacks,
    runtimeParams
  } = {}) {
    this._tracingService = TRACE_PROCESSOR3.createTraceSender();
    this._statusUpdate = new Event11();
    this._edgeConnection = void 0;
    this._edgeHttpClient = void 0;
    this._opening = false;
    this._open = false;
    this._resetting = false;
    this._storage = storage;
    this._level = level;
    this._callbacks = callbacks;
    this._runtimeParams = runtimeParams ?? {};
    if (this._runtimeParams.disableP2pReplication === void 0) {
      this._runtimeParams.disableP2pReplication = config?.get("runtime.client.disableP2pReplication", false);
    }
    if (this._runtimeParams.enableVectorIndexing === void 0) {
      this._runtimeParams.enableVectorIndexing = config?.get("runtime.client.enableVectorIndexing", false);
    }
    if (config) {
      this.initialize({
        config,
        transportFactory,
        signalManager
      });
    }
    if (lockKey) {
      this._resourceLock = new Lock({
        lockKey,
        onAcquire: () => {
          if (!this._opening) {
            void this.open(new Context11(void 0, {
              F: __dxlog_file32,
              L: 141
            }));
          }
        },
        onRelease: () => this.close()
      });
    }
    this._systemService = new SystemServiceImpl({
      config: () => this._config,
      statusUpdate: this._statusUpdate,
      getCurrentStatus: () => this.isOpen && !this._resetting ? SystemStatus.ACTIVE : SystemStatus.INACTIVE,
      getDiagnostics: () => {
        return createDiagnostics(this._serviceRegistry.services, this._serviceContext, this._config);
      },
      onUpdateStatus: async (status) => {
        if (!this.isOpen && status === SystemStatus.ACTIVE) {
          await this._resourceLock?.acquire();
        } else if (this.isOpen && status === SystemStatus.INACTIVE) {
          await this._resourceLock?.release();
        }
      },
      onReset: async () => {
        await this.reset();
      }
    });
    this.diagnosticsBroadcastHandler = createCollectDiagnosticsBroadcastHandler(this._systemService);
    this._loggingService = new LoggingServiceImpl();
    this._serviceRegistry = new ServiceRegistry(clientServiceBundle, {
      SystemService: this._systemService,
      TracingService: this._tracingService
    });
  }
  get isOpen() {
    return this._open;
  }
  get config() {
    return this._config;
  }
  get context() {
    return this._serviceContext;
  }
  get serviceRegistry() {
    return this._serviceRegistry;
  }
  get descriptors() {
    return this._serviceRegistry.descriptors;
  }
  get services() {
    return this._serviceRegistry.services;
  }
  /**
  * Initialize the service host with the config.
  * Config can also be provided in the constructor.
  * Can only be called once.
  */
  initialize({ config, ...options }) {
    invariant25(!this._open, "service host is open", {
      F: __dxlog_file32,
      L: 207,
      S: this,
      A: [
        "!this._open",
        "'service host is open'"
      ]
    });
    log28("initializing...", void 0, {
      F: __dxlog_file32,
      L: 208,
      S: this,
      C: (f, a) => f(...a)
    });
    if (config) {
      invariant25(!this._config, "config already set", {
        F: __dxlog_file32,
        L: 211,
        S: this,
        A: [
          "!this._config",
          "'config already set'"
        ]
      });
      this._config = config;
      if (!this._storage) {
        this._storage = createStorageObjects(config.get("runtime.client.storage", {})).storage;
      }
    }
    if (!options.signalManager) {
      log28.warn("running signaling without telemetry metadata.", void 0, {
        F: __dxlog_file32,
        L: 219,
        S: this,
        C: (f, a) => f(...a)
      });
    }
    const edgeEndpoint = config?.get("runtime.services.edge.url");
    if (edgeEndpoint) {
      this._edgeConnection = new EdgeClient(createStubEdgeIdentity(), {
        socketEndpoint: edgeEndpoint
      });
      this._edgeHttpClient = new EdgeHttpClient(edgeEndpoint);
    }
    const { connectionLog = true, transportFactory = createRtcTransportFactory({
      iceServers: this._config?.get("runtime.services.ice")
    }, this._config?.get("runtime.services.iceProviders") && createIceProvider(this._config.get("runtime.services.iceProviders"))), signalManager = this._edgeConnection && this._config?.get("runtime.client.edgeFeatures")?.signaling ? new EdgeSignalManager({
      edgeConnection: this._edgeConnection
    }) : new WebsocketSignalManager(this._config?.get("runtime.services.signaling") ?? []) } = options;
    this._signalManager = signalManager;
    invariant25(!this._networkManager, "network manager already set", {
      F: __dxlog_file32,
      L: 241,
      S: this,
      A: [
        "!this._networkManager",
        "'network manager already set'"
      ]
    });
    this._networkManager = new SwarmNetworkManager({
      enableDevtoolsLogging: connectionLog,
      transportFactory,
      signalManager,
      peerInfo: this._edgeConnection ? {
        identityKey: this._edgeConnection.identityKey,
        peerKey: this._edgeConnection.peerKey
      } : void 0
    });
    log28("initialized", void 0, {
      F: __dxlog_file32,
      L: 254,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  async open(ctx) {
    if (this._open) {
      return;
    }
    const traceId = PublicKey19.random().toHex();
    log28.trace("dxos.client-services.host.open", trace11.begin({
      id: traceId
    }), {
      F: __dxlog_file32,
      L: 265,
      S: this,
      C: (f, a) => f(...a)
    });
    invariant25(this._config, "config not set", {
      F: __dxlog_file32,
      L: 267,
      S: this,
      A: [
        "this._config",
        "'config not set'"
      ]
    });
    invariant25(this._storage, "storage not set", {
      F: __dxlog_file32,
      L: 268,
      S: this,
      A: [
        "this._storage",
        "'storage not set'"
      ]
    });
    invariant25(this._signalManager, "signal manager not set", {
      F: __dxlog_file32,
      L: 269,
      S: this,
      A: [
        "this._signalManager",
        "'signal manager not set'"
      ]
    });
    invariant25(this._networkManager, "network manager not set", {
      F: __dxlog_file32,
      L: 270,
      S: this,
      A: [
        "this._networkManager",
        "'network manager not set'"
      ]
    });
    this._opening = true;
    log28("opening...", {
      lockKey: this._resourceLock?.lockKey
    }, {
      F: __dxlog_file32,
      L: 273,
      S: this,
      C: (f, a) => f(...a)
    });
    await this._resourceLock?.acquire();
    if (!this._level) {
      this._level = await createLevel(this._config.get("runtime.client.storage", {}));
    }
    await this._level.open();
    await this._loggingService.open();
    this._serviceContext = new ServiceContext(this._storage, this._level, this._networkManager, this._signalManager, this._edgeConnection, this._edgeHttpClient, this._runtimeParams, this._config.get("runtime.client.edgeFeatures"));
    const dataSpaceManagerProvider = async () => {
      await this._serviceContext.initialized.wait();
      return this._serviceContext.dataSpaceManager;
    };
    const agentManagerProvider = async () => {
      await this._serviceContext.initialized.wait();
      return this._serviceContext.edgeAgentManager;
    };
    const identityService = new IdentityServiceImpl(this._serviceContext.identityManager, this._serviceContext.recoveryManager, this._serviceContext.keyring, () => this._serviceContext.dataSpaceManager, (params) => this._createIdentity(params), (profile) => this._serviceContext.broadcastProfileUpdate(profile));
    this._serviceRegistry.setServices({
      SystemService: this._systemService,
      IdentityService: identityService,
      ContactsService: new ContactsServiceImpl(this._serviceContext.identityManager, this._serviceContext.spaceManager, dataSpaceManagerProvider),
      InvitationsService: new InvitationsServiceImpl(this._serviceContext.invitationsManager),
      DevicesService: new DevicesServiceImpl(this._serviceContext.identityManager, this._edgeConnection),
      SpacesService: new SpacesServiceImpl(this._serviceContext.identityManager, this._serviceContext.spaceManager, dataSpaceManagerProvider),
      DataService: this._serviceContext.echoHost.dataService,
      QueryService: this._serviceContext.echoHost.queryService,
      NetworkService: new NetworkServiceImpl(this._serviceContext.networkManager, this._serviceContext.signalManager, this._edgeConnection),
      LoggingService: this._loggingService,
      TracingService: this._tracingService,
      // TODO(burdon): Move to new protobuf definitions.
      DevtoolsHost: new DevtoolsServiceImpl({
        events: new DevtoolsHostEvents(),
        config: this._config,
        context: this._serviceContext
      }),
      EdgeAgentService: new EdgeAgentServiceImpl(agentManagerProvider, this._edgeConnection)
    });
    await this._serviceContext.open(ctx);
    await identityService.open();
    const devtoolsProxy = this._config?.get("runtime.client.devtoolsProxy");
    if (devtoolsProxy) {
      this._devtoolsProxy = new WebsocketRpcClient({
        url: devtoolsProxy,
        requested: {},
        exposed: clientServiceBundle,
        handlers: this.services
      });
      void this._devtoolsProxy.open();
    }
    this.diagnosticsBroadcastHandler.start();
    this._opening = false;
    this._open = true;
    this._statusUpdate.emit();
    const deviceKey = this._serviceContext.identityManager.identity?.deviceKey;
    log28("opened", {
      deviceKey
    }, {
      F: __dxlog_file32,
      L: 374,
      S: this,
      C: (f, a) => f(...a)
    });
    log28.trace("dxos.client-services.host.open", trace11.end({
      id: traceId
    }), {
      F: __dxlog_file32,
      L: 375,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  async close() {
    if (!this._open) {
      return;
    }
    const deviceKey = this._serviceContext.identityManager.identity?.deviceKey;
    log28("closing...", {
      deviceKey
    }, {
      F: __dxlog_file32,
      L: 386,
      S: this,
      C: (f, a) => f(...a)
    });
    this.diagnosticsBroadcastHandler.stop();
    await this._devtoolsProxy?.close();
    this._serviceRegistry.setServices({
      SystemService: this._systemService
    });
    await this._loggingService.close();
    await this._serviceContext.close();
    await this._level?.close();
    this._open = false;
    this._statusUpdate.emit();
    log28("closed", {
      deviceKey
    }, {
      F: __dxlog_file32,
      L: 395,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  async reset() {
    const traceId = PublicKey19.random().toHex();
    log28.trace("dxos.sdk.client-services-host.reset", trace11.begin({
      id: traceId
    }), {
      F: __dxlog_file32,
      L: 400,
      S: this,
      C: (f, a) => f(...a)
    });
    log28.info("resetting...", void 0, {
      F: __dxlog_file32,
      L: 402,
      S: this,
      C: (f, a) => f(...a)
    });
    this._resetting = true;
    this._statusUpdate.emit();
    await this._serviceContext?.close();
    await this._storage.reset();
    log28.info("reset", void 0, {
      F: __dxlog_file32,
      L: 409,
      S: this,
      C: (f, a) => f(...a)
    });
    log28.trace("dxos.sdk.client-services-host.reset", trace11.end({
      id: traceId
    }), {
      F: __dxlog_file32,
      L: 410,
      S: this,
      C: (f, a) => f(...a)
    });
    await this._callbacks?.onReset?.();
  }
  async _createIdentity(params) {
    const identity = await this._serviceContext.createIdentity(params);
    await this._serviceContext.initialized.wait();
    return identity;
  }
};
_ts_decorate11([
  Trace4.info()
], ClientServicesHost.prototype, "_opening", void 0);
_ts_decorate11([
  Trace4.info()
], ClientServicesHost.prototype, "_open", void 0);
_ts_decorate11([
  Trace4.info()
], ClientServicesHost.prototype, "_resetting", void 0);
_ts_decorate11([
  synchronized4,
  Trace4.span()
], ClientServicesHost.prototype, "open", null);
_ts_decorate11([
  synchronized4,
  Trace4.span()
], ClientServicesHost.prototype, "close", null);
ClientServicesHost = _ts_decorate11([
  Trace4.resource()
], ClientServicesHost);

export {
  subscribeToFeeds,
  subscribeToFeedBlocks,
  subscribeToNetworkStatus,
  subscribeToSignal,
  subscribeToNetworkTopics,
  subscribeToSwarmInfo,
  getNetworkPeers,
  subscribeToSpaces,
  DevtoolsHostEvents,
  DevtoolsServiceImpl,
  createDiagnostics,
  createCollectDiagnosticsBroadcastSender,
  createCollectDiagnosticsBroadcastHandler,
  DiagnosticsCollector,
  createAuthProvider,
  TrustedKeySetAuthVerifier,
  EdgeFeedReplicator,
  DataSpace,
  DataSpaceManager,
  SpacesServiceImpl,
  Identity,
  IdentityManager,
  IdentityServiceImpl,
  DeviceInvitationProtocol,
  InvitationsHandler,
  createAdmissionKeypair,
  InvitationsServiceImpl,
  SpaceInvitationProtocol,
  InvitationsManager,
  Lock,
  isLocked,
  ClientRpcServer,
  EdgeAgentManager,
  EdgeAgentServiceImpl,
  ServiceContext,
  ServiceRegistry,
  createStorageObjects,
  createLevel,
  encodeProfileArchive,
  decodeProfileArchive,
  exportProfileData,
  importProfileData,
  ClientServicesHost
};
//# sourceMappingURL=chunk-LBG3C332.mjs.map
