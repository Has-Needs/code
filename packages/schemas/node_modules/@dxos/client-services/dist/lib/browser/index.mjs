import "@dxos/node-std/globals";
import {
  ClientRpcServer,
  ClientServicesHost,
  DataSpace,
  DataSpaceManager,
  DeviceInvitationProtocol,
  DevtoolsHostEvents,
  DevtoolsServiceImpl,
  DiagnosticsCollector,
  EdgeAgentManager,
  EdgeAgentServiceImpl,
  EdgeFeedReplicator,
  Identity,
  IdentityManager,
  IdentityServiceImpl,
  InvitationsHandler,
  InvitationsManager,
  InvitationsServiceImpl,
  Lock,
  ServiceContext,
  ServiceRegistry,
  SpaceInvitationProtocol,
  SpacesServiceImpl,
  TrustedKeySetAuthVerifier,
  createAdmissionKeypair,
  createAuthProvider,
  createCollectDiagnosticsBroadcastHandler,
  createCollectDiagnosticsBroadcastSender,
  createDiagnostics,
  createLevel,
  createStorageObjects,
  decodeProfileArchive,
  encodeProfileArchive,
  exportProfileData,
  getNetworkPeers,
  importProfileData,
  isLocked,
  subscribeToFeedBlocks,
  subscribeToFeeds,
  subscribeToNetworkStatus,
  subscribeToNetworkTopics,
  subscribeToSignal,
  subscribeToSpaces,
  subscribeToSwarmInfo
} from "./chunk-LBG3C332.mjs";

// packages/sdk/client-services/src/packlets/worker/worker-runtime.ts
import { Trigger as Trigger2 } from "@dxos/async";
import { DEFAULT_WORKER_BROADCAST_CHANNEL } from "@dxos/client-protocol";
import { Context } from "@dxos/context";
import { invariant as invariant2 } from "@dxos/invariant";
import { log as log2 } from "@dxos/log";
import { MemorySignalManager, MemorySignalManagerContext, WebsocketSignalManager, setIdentityTags } from "@dxos/messaging";
import { RtcTransportProxyFactory } from "@dxos/network-manager";

// packages/sdk/client-services/src/packlets/worker/worker-session.ts
import { asyncTimeout, Trigger } from "@dxos/async";
import { iframeServiceBundle, PROXY_CONNECTION_TIMEOUT, workerServiceBundle } from "@dxos/client-protocol";
import { invariant } from "@dxos/invariant";
import { log, logInfo } from "@dxos/log";
import { createProtoRpcPeer } from "@dxos/rpc";
import { Callback } from "@dxos/util";
function _ts_decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/worker/worker-session.ts";
var WorkerSession = class {
  constructor({ serviceHost, systemPort, appPort, shellPort, readySignal }) {
    this._startTrigger = new Trigger();
    this.onClose = new Callback();
    invariant(serviceHost, void 0, {
      F: __dxlog_file,
      L: 54,
      S: this,
      A: [
        "serviceHost",
        ""
      ]
    });
    this._serviceHost = serviceHost;
    const middleware = {
      handleCall: async (method, params, handler) => {
        const error = await readySignal.wait({
          timeout: PROXY_CONNECTION_TIMEOUT
        });
        if (error) {
          throw error;
        }
        return handler(method, params);
      },
      handleStream: async (method, params, handler) => {
        const error = await readySignal.wait({
          timeout: PROXY_CONNECTION_TIMEOUT
        });
        if (error) {
          throw error;
        }
        return handler(method, params);
      }
    };
    this._clientRpc = new ClientRpcServer({
      serviceRegistry: this._serviceHost.serviceRegistry,
      port: appPort,
      ...middleware
    });
    this._shellClientRpc = shellPort ? new ClientRpcServer({
      serviceRegistry: this._serviceHost.serviceRegistry,
      port: shellPort,
      ...middleware
    }) : void 0;
    this._iframeRpc = createProtoRpcPeer({
      requested: iframeServiceBundle,
      exposed: workerServiceBundle,
      handlers: {
        WorkerService: {
          start: async (request) => {
            this.origin = request.origin;
            this.lockKey = request.lockKey;
            this.observabilityGroup = request.observabilityGroup;
            this.signalTelemetryEnabled = request.signalTelemetryEnabled;
            this._startTrigger.wake();
          },
          stop: async () => {
            setTimeout(async () => {
              try {
                await this.close();
              } catch (err) {
                log.catch(err, void 0, {
                  F: __dxlog_file,
                  L: 108,
                  S: this,
                  C: (f, a) => f(...a)
                });
              }
            });
          }
        }
      },
      port: systemPort,
      timeout: 1e3
    });
    this.bridgeService = this._iframeRpc.rpc.BridgeService;
  }
  async open() {
    log.info("opening...", void 0, {
      F: __dxlog_file,
      L: 122,
      S: this,
      C: (f, a) => f(...a)
    });
    await Promise.all([
      this._clientRpc.open(),
      this._iframeRpc.open(),
      this._maybeOpenShell()
    ]);
    await this._startTrigger.wait({
      timeout: PROXY_CONNECTION_TIMEOUT
    });
    if (this.lockKey) {
      void this._afterLockReleases(this.lockKey, () => this.close());
    }
    log.info("opened", void 0, {
      F: __dxlog_file,
      L: 133,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  async close() {
    log.info("closing...", void 0, {
      F: __dxlog_file,
      L: 137,
      S: this,
      C: (f, a) => f(...a)
    });
    try {
      await this.onClose.callIfSet();
    } catch (err) {
      log.catch(err, void 0, {
        F: __dxlog_file,
        L: 141,
        S: this,
        C: (f, a) => f(...a)
      });
    }
    await Promise.all([
      this._clientRpc.close(),
      this._iframeRpc.close()
    ]);
    log.info("closed", void 0, {
      F: __dxlog_file,
      L: 145,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  async _maybeOpenShell() {
    try {
      this._shellClientRpc && await asyncTimeout(this._shellClientRpc.open(), 1e3);
    } catch {
      log.info("No shell connected.", void 0, {
        F: __dxlog_file,
        L: 152,
        S: this,
        C: (f, a) => f(...a)
      });
    }
  }
  _afterLockReleases(lockKey, callback) {
    return navigator.locks.request(lockKey, () => {
    }).then(callback);
  }
};
_ts_decorate([
  logInfo
], WorkerSession.prototype, "origin", void 0);
_ts_decorate([
  logInfo
], WorkerSession.prototype, "lockKey", void 0);

// packages/sdk/client-services/src/packlets/worker/worker-runtime.ts
var __dxlog_file2 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/worker/worker-runtime.ts";
var WorkerRuntime = class {
  constructor({ channel = DEFAULT_WORKER_BROADCAST_CHANNEL, configProvider, acquireLock, releaseLock, onStop }) {
    this._transportFactory = new RtcTransportProxyFactory();
    this._ready = new Trigger2();
    this._sessions = /* @__PURE__ */ new Set();
    this._signalMetadataTags = {
      runtime: "worker-runtime"
    };
    this._signalTelemetryEnabled = false;
    this._configProvider = configProvider;
    this._acquireLock = acquireLock;
    this._releaseLock = releaseLock;
    this._onStop = onStop;
    this._channel = channel;
    this._clientServices = new ClientServicesHost({
      callbacks: {
        onReset: async () => this.stop()
      }
    });
  }
  get host() {
    return this._clientServices;
  }
  async start() {
    log2("starting...", void 0, {
      F: __dxlog_file2,
      L: 84,
      S: this,
      C: (f, a) => f(...a)
    });
    try {
      this._broadcastChannel = new BroadcastChannel(this._channel);
      this._broadcastChannel.postMessage({
        action: "stop"
      });
      this._broadcastChannel.onmessage = async (event) => {
        if (event.data?.action === "stop") {
          await this.stop();
        }
      };
      await this._acquireLock();
      this._config = await this._configProvider();
      const signals = this._config.get("runtime.services.signaling");
      this._clientServices.initialize({
        config: this._config,
        signalManager: this._config.get("runtime.client.edgeFeatures")?.signaling ? void 0 : signals ? new WebsocketSignalManager(signals, () => this._signalTelemetryEnabled ? this._signalMetadataTags : {}) : new MemorySignalManager(new MemorySignalManagerContext()),
        transportFactory: this._transportFactory
      });
      await this._clientServices.open(new Context(void 0, {
        F: __dxlog_file2,
        L: 107
      }));
      this._ready.wake(void 0);
      log2("started", void 0, {
        F: __dxlog_file2,
        L: 109,
        S: this,
        C: (f, a) => f(...a)
      });
      setIdentityTags({
        identityService: this._clientServices.services.IdentityService,
        devicesService: this._clientServices.services.DevicesService,
        setTag: (k, v) => {
          this._signalMetadataTags[k] = v;
        }
      });
    } catch (err) {
      this._ready.wake(err);
      log2.error("starting", err, {
        F: __dxlog_file2,
        L: 119,
        S: this,
        C: (f, a) => f(...a)
      });
    }
  }
  async stop() {
    this._releaseLock();
    this._broadcastChannel?.close();
    this._broadcastChannel = void 0;
    await this._clientServices.close();
    await this._onStop?.();
  }
  /**
  * Create a new session.
  */
  async createSession({ appPort, systemPort, shellPort }) {
    const session = new WorkerSession({
      serviceHost: this._clientServices,
      appPort,
      systemPort,
      shellPort,
      readySignal: this._ready
    });
    session.onClose.set(async () => {
      this._sessions.delete(session);
      if (this._sessions.size === 0) {
        await this.stop();
      } else {
        this._reconnectWebrtc();
      }
    });
    await session.open();
    invariant2(!this._signalMetadataTags.origin || this._signalMetadataTags.origin === session.origin, `worker origin changed from ${this._signalMetadataTags.origin} to ${session.origin}?`, {
      F: __dxlog_file2,
      L: 157,
      S: this,
      A: [
        "!this._signalMetadataTags.origin || this._signalMetadataTags.origin === session.origin",
        "`worker origin changed from ${this._signalMetadataTags.origin} to ${session.origin}?`"
      ]
    });
    if (session.observabilityGroup) {
      this._signalMetadataTags.group = session.observabilityGroup;
    }
    this._signalTelemetryEnabled = session.signalTelemetryEnabled ?? false;
    this._signalMetadataTags.origin = session.origin;
    this._sessions.add(session);
    this._reconnectWebrtc();
  }
  /**
  * Selects one of the existing session for WebRTC networking.
  */
  _reconnectWebrtc() {
    log2("reconnecting webrtc...", void 0, {
      F: __dxlog_file2,
      L: 175,
      S: this,
      C: (f, a) => f(...a)
    });
    if (this._sessionForNetworking) {
      if (!this._sessions.has(this._sessionForNetworking)) {
        this._sessionForNetworking = void 0;
      }
    }
    if (!this._sessionForNetworking) {
      const selected = Array.from(this._sessions).find((session) => session.bridgeService);
      if (selected) {
        this._sessionForNetworking = selected;
        this._transportFactory.setBridgeService(selected.bridgeService);
      } else {
        this._transportFactory.setBridgeService(void 0);
      }
    }
  }
};
export {
  ClientRpcServer,
  ClientServicesHost,
  DataSpace,
  DataSpaceManager,
  DeviceInvitationProtocol,
  DevtoolsHostEvents,
  DevtoolsServiceImpl,
  DiagnosticsCollector,
  EdgeAgentManager,
  EdgeAgentServiceImpl,
  EdgeFeedReplicator,
  Identity,
  IdentityManager,
  IdentityServiceImpl,
  InvitationsHandler,
  InvitationsManager,
  InvitationsServiceImpl,
  Lock,
  ServiceContext,
  ServiceRegistry,
  SpaceInvitationProtocol,
  SpacesServiceImpl,
  TrustedKeySetAuthVerifier,
  WorkerRuntime,
  WorkerSession,
  createAdmissionKeypair,
  createAuthProvider,
  createCollectDiagnosticsBroadcastHandler,
  createCollectDiagnosticsBroadcastSender,
  createDiagnostics,
  createLevel,
  createStorageObjects,
  decodeProfileArchive,
  encodeProfileArchive,
  exportProfileData,
  getNetworkPeers,
  importProfileData,
  isLocked,
  subscribeToFeedBlocks,
  subscribeToFeeds,
  subscribeToNetworkStatus,
  subscribeToNetworkTopics,
  subscribeToSignal,
  subscribeToSpaces,
  subscribeToSwarmInfo
};
//# sourceMappingURL=index.mjs.map
