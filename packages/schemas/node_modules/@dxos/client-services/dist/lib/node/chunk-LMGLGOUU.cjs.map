{
  "version": 3,
  "sources": ["../../../src/packlets/devtools/feeds.ts", "../../../src/packlets/devtools/network.ts", "../../../src/packlets/devtools/spaces.ts", "../../../src/packlets/devtools/devtools.ts", "../../../src/packlets/devtools/keys.ts", "../../../src/packlets/devtools/metadata.ts", "../../../src/packlets/diagnostics/diagnostics.ts", "../../../src/version.ts", "../../../src/packlets/services/platform.ts", "../../../src/packlets/diagnostics/diagnostics-broadcast.ts", "../../../src/packlets/diagnostics/diagnostics-collector.ts", "../../../src/packlets/identity/authenticator.ts", "../../../src/packlets/spaces/edge-feed-replicator.ts", "../../../src/packlets/spaces/data-space.ts", "../../../src/packlets/spaces/automerge-space-state.ts", "../../../src/packlets/spaces/epoch-migrations.ts", "../../../src/packlets/spaces/notarization-plugin.ts", "../../../src/packlets/identity/identity.ts", "../../../src/packlets/identity/default-space-state-machine.ts", "../../../src/packlets/spaces/data-space-manager.ts", "../../../src/packlets/spaces/genesis.ts", "../../../src/packlets/spaces/spaces-service.ts", "../../../src/packlets/space-export/space-archive-writer.ts", "../../../src/packlets/space-export/space-archive-reader.ts", "../../../src/packlets/identity/identity-manager.ts", "../../../src/packlets/identity/identity-service.ts", "../../../src/packlets/invitations/device-invitation-protocol.ts", "../../../src/packlets/invitations/invitations-handler.ts", "../../../src/packlets/invitations/edge-invitation-handler.ts", "../../../src/packlets/invitations/utils.ts", "../../../src/packlets/invitations/invitation-guest-extenstion.ts", "../../../src/packlets/invitations/invitation-host-extension.ts", "../../../src/packlets/invitations/invitation-state.ts", "../../../src/packlets/invitations/invitation-topology.ts", "../../../src/packlets/invitations/invitations-service.ts", "../../../src/packlets/invitations/space-invitation-protocol.ts", "../../../src/packlets/invitations/invitations-manager.ts", "../../../src/packlets/locks/node.ts", "../../../src/packlets/services/client-rpc-server.ts", "../../../src/packlets/agents/edge-agent-manager.ts", "../../../src/packlets/agents/edge-agent-service.ts", "../../../src/packlets/services/service-context.ts", "../../../src/packlets/identity/identity-recovery-manager.ts", "../../../src/packlets/services/service-registry.ts", "../../../src/packlets/storage/storage.ts", "../../../src/packlets/storage/util.ts", "../../../src/packlets/storage/level.ts", "../../../src/packlets/storage/profile-archive.ts", "../../../src/packlets/services/service-host.ts", "../../../src/packlets/devices/devices-service.ts", "../../../src/packlets/identity/contacts-service.ts", "../../../src/packlets/logging/logging-service.ts", "../../../src/packlets/network/network-service.ts", "../../../src/packlets/system/system-service.ts"],
  "sourcesContent": ["//\n// Copyright 2021 DXOS.org\n//\n\nimport { SubscriptionList } from '@dxos/async';\nimport { Stream } from '@dxos/codec-protobuf/stream';\nimport { type SpaceManager } from '@dxos/echo-pipeline';\nimport { FeedIterator, type FeedStore, type FeedWrapper } from '@dxos/feed-store';\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport {\n  type SubscribeToFeedsRequest,\n  type SubscribeToFeedsResponse,\n  type SubscribeToFeedBlocksRequest,\n  type SubscribeToFeedBlocksResponse,\n} from '@dxos/protocols/proto/dxos/devtools/host';\nimport { type FeedMessage } from '@dxos/protocols/proto/dxos/echo/feed';\nimport { ComplexMap } from '@dxos/util';\n\ntype FeedInfo = {\n  feed: FeedWrapper<FeedMessage>;\n  owner?: SubscribeToFeedsResponse.FeedOwner;\n};\n\nexport const subscribeToFeeds = (\n  { feedStore, spaceManager }: { feedStore: FeedStore<FeedMessage>; spaceManager: SpaceManager },\n  { feedKeys }: SubscribeToFeedsRequest,\n) => {\n  return new Stream<SubscribeToFeedsResponse>(({ next }) => {\n    const subscriptions = new SubscriptionList();\n    const feedMap = new ComplexMap<PublicKey, FeedInfo>(PublicKey.hash);\n\n    const update = () => {\n      const { feeds } = feedStore;\n      feeds\n        .filter((feed) => !feedKeys?.length || feedKeys.some((feedKey) => feedKey.equals(feed.key)))\n        .forEach((feed) => {\n          if (!feedMap.has(feed.key)) {\n            feedMap.set(feed.key, { feed });\n            feed.on('close', update);\n            subscriptions.add(() => feed.off('close', update));\n          }\n          if (!feedMap.get(feed.key)?.owner) {\n            feedMap.get(feed.key)!.owner = findFeedOwner(spaceManager, feed.key);\n          }\n        });\n\n      next({\n        feeds: Array.from(feedMap.values()).map(({ feed, owner }) => ({\n          feedKey: feed.key,\n          length: feed.properties.length,\n          bytes: feed.core.byteLength,\n          downloaded: feed.core.bitfield?.data.toBuffer() ?? new Uint8Array(),\n          owner,\n        })),\n      });\n    };\n\n    subscriptions.add(feedStore.feedOpened.on(update));\n    update();\n\n    return () => {\n      subscriptions.clear();\n    };\n  });\n};\n\nconst findFeedOwner = (\n  spaceManager: SpaceManager,\n  feedKey: PublicKey,\n): SubscribeToFeedsResponse.FeedOwner | undefined => {\n  const feedInfo = [...spaceManager.spaces.values()]\n    .flatMap((space) => [...space.spaceState.feeds.values()])\n    .find((feed) => feed.key.equals(feedKey));\n  log('feeds', { feedInfo, key: feedKey.truncate(), allSpaces: spaceManager.spaces.size });\n  if (!feedInfo) {\n    return undefined;\n  }\n  return {\n    identity: feedInfo.assertion.identityKey,\n    device: feedInfo.assertion.deviceKey,\n  };\n};\n\nexport const subscribeToFeedBlocks = (\n  { feedStore }: { feedStore: FeedStore<FeedMessage> },\n  { feedKey, maxBlocks = 10 }: SubscribeToFeedBlocksRequest,\n) => {\n  return new Stream<SubscribeToFeedBlocksResponse>(({ next }) => {\n    if (!feedKey) {\n      return;\n    }\n\n    const subscriptions = new SubscriptionList();\n\n    const timeout = setTimeout(async () => {\n      const feed = feedStore.getFeed(feedKey);\n      if (!feed) {\n        return;\n      }\n\n      const update = async () => {\n        if (!feed.properties.length) {\n          next({ blocks: [] });\n          return;\n        }\n\n        const iterator = new FeedIterator(feed);\n        await iterator.open();\n        const blocks = [];\n        for await (const block of iterator) {\n          blocks.push(block);\n          if (blocks.length >= feed.properties.length) {\n            break;\n          }\n        }\n\n        next({\n          blocks: blocks.slice(-maxBlocks),\n        });\n\n        await iterator.close();\n      };\n\n      feed.on('append', update);\n      subscriptions.add(() => feed.off('append', update));\n\n      feed.on('truncate', update);\n      subscriptions.add(() => feed.off('truncate', update));\n      await update();\n    });\n\n    return () => {\n      subscriptions.clear();\n      clearTimeout(timeout);\n    };\n  });\n};\n", "//\n// Copyright 2020 DXOS.org\n//\n\nimport { Stream } from '@dxos/codec-protobuf/stream';\nimport { Context } from '@dxos/context';\nimport { PublicKey } from '@dxos/keys';\nimport { type SignalManager } from '@dxos/messaging';\nimport { type SwarmNetworkManager } from '@dxos/network-manager';\nimport {\n  type GetNetworkPeersRequest,\n  type GetNetworkPeersResponse,\n  type SubscribeToNetworkTopicsResponse,\n  type SubscribeToSignalStatusResponse,\n  type SignalResponse,\n  type SubscribeToSwarmInfoResponse,\n} from '@dxos/protocols/proto/dxos/devtools/host';\n\nexport const subscribeToNetworkStatus = ({ signalManager }: { signalManager: SignalManager }) =>\n  new Stream<SubscribeToSignalStatusResponse>(({ next, close }) => {\n    const update = () => {\n      try {\n        const status = signalManager.getStatus?.();\n        next({ servers: status });\n      } catch (err: any) {\n        close(err);\n      }\n    };\n\n    signalManager.statusChanged?.on(() => update());\n    update();\n  });\n\nexport const subscribeToSignal = ({ signalManager }: { signalManager: SignalManager }) =>\n  new Stream<SignalResponse>(({ next }) => {\n    const ctx = new Context();\n    signalManager.onMessage.on(ctx, (message) => {\n      next({\n        message: {\n          author: PublicKey.from(message.author.peerKey).asUint8Array(),\n          recipient: PublicKey.from(message.recipient.peerKey).asUint8Array(),\n          payload: message.payload,\n        },\n        receivedAt: new Date(),\n      });\n    });\n    signalManager.swarmEvent.on(ctx, (swarmEvent) => {\n      next({\n        swarmEvent: swarmEvent.peerAvailable\n          ? {\n              peerAvailable: {\n                peer: PublicKey.from(swarmEvent.peerAvailable.peer.peerKey).asUint8Array(),\n                since: swarmEvent.peerAvailable.since,\n              },\n            }\n          : { peerLeft: { peer: PublicKey.from(swarmEvent.peerLeft!.peer.peerKey).asUint8Array() } },\n        topic: swarmEvent.topic.asUint8Array(),\n        receivedAt: new Date(),\n      });\n    });\n    return () => {\n      return ctx.dispose();\n    };\n  });\n\nexport const subscribeToNetworkTopics = ({ networkManager }: { networkManager: SwarmNetworkManager }) =>\n  new Stream<SubscribeToNetworkTopicsResponse>(({ next, close }) => {\n    const update = () => {\n      try {\n        const topics = networkManager.topics;\n        const labeledTopics = topics.map((topic) => ({\n          topic,\n          label: networkManager.getSwarm(topic)?.label ?? topic.toHex(),\n        }));\n        next({ topics: labeledTopics });\n      } catch (err: any) {\n        close(err);\n      }\n    };\n    networkManager.topicsUpdated.on(update);\n\n    update();\n  });\n\nexport const subscribeToSwarmInfo = ({ networkManager }: { networkManager: SwarmNetworkManager }) =>\n  new Stream<SubscribeToSwarmInfoResponse>(({ next }) => {\n    const update = () => {\n      const info = networkManager.connectionLog?.swarms;\n      if (info) {\n        next({ data: info });\n      }\n    };\n    networkManager.connectionLog?.update.on(update);\n    update();\n  });\n\nexport const getNetworkPeers = (\n  { networkManager }: { networkManager: SwarmNetworkManager },\n  request: GetNetworkPeersRequest,\n): GetNetworkPeersResponse => {\n  if (!request.topic) {\n    throw new Error('Expected a network topic');\n  }\n\n  const map = networkManager.getSwarmMap(PublicKey.from(request.topic));\n  return {\n    peers: map?.peers.map((peer) => ({\n      ...peer,\n      connections: peer.connections.map((connection) => connection.asUint8Array()),\n    })),\n  };\n};\n", "//\n// Copyright 2020 DXOS.org\n//\n\nimport { Stream } from '@dxos/codec-protobuf/stream';\nimport { type Space } from '@dxos/echo-pipeline';\nimport {\n  type SubscribeToSpacesRequest,\n  type SubscribeToSpacesResponse,\n} from '@dxos/protocols/proto/dxos/devtools/host';\nimport { type SpaceMetadata } from '@dxos/protocols/proto/dxos/echo/metadata';\n\nimport { type ServiceContext } from '../services';\n\nexport const subscribeToSpaces = (context: ServiceContext, { spaceKeys = [] }: SubscribeToSpacesRequest) => {\n  return new Stream<SubscribeToSpacesResponse>(({ next }) => {\n    let unsubscribe: () => void;\n\n    const update = async () => {\n      const spaces: Space[] = [...context.spaceManager!.spaces.values()];\n      const filteredSpaces = spaces.filter(\n        (space) => !spaceKeys?.length || spaceKeys.some((spaceKey) => spaceKey.equals(space.key)),\n      );\n\n      next({\n        spaces: filteredSpaces.map((space): SubscribeToSpacesResponse.SpaceInfo => {\n          const spaceMetadata = context.metadataStore.spaces.find((spaceMetadata: SpaceMetadata) =>\n            spaceMetadata.key.equals(space.key),\n          );\n\n          return {\n            key: space.key,\n            isOpen: space.isOpen,\n            timeframe: spaceMetadata?.dataTimeframe,\n            genesisFeed: space.genesisFeedKey,\n            controlFeed: space.controlFeedKey!, // TODO(dmaretskyi): Those keys may be missing.\n            dataFeed: space.dataFeedKey!,\n          };\n        }),\n      });\n    };\n\n    const timeout = setTimeout(async () => {\n      await context.initialized.wait();\n      unsubscribe = context.dataSpaceManager!.updated.on(() => update());\n\n      // Send initial spaces.\n      await update();\n    });\n\n    return () => {\n      unsubscribe?.();\n      clearTimeout(timeout);\n    };\n  });\n};\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { Event as AsyncEvent } from '@dxos/async';\nimport { Stream } from '@dxos/codec-protobuf/stream';\nimport { type Config } from '@dxos/config';\nimport {\n  type ClearSnapshotsRequest,\n  type DevtoolsHost, // TODO(burdon): Rename DevtoolsService\n  type EnableDebugLoggingRequest,\n  type EnableDebugLoggingResponse,\n  type Event,\n  type GetConfigResponse,\n  type GetNetworkPeersRequest,\n  type GetNetworkPeersResponse,\n  type GetSpaceSnapshotRequest,\n  type GetSpaceSnapshotResponse,\n  type ResetStorageRequest,\n  type SaveSpaceSnapshotRequest,\n  type SaveSpaceSnapshotResponse,\n  type SubscribeToCredentialMessagesRequest,\n  type SubscribeToCredentialMessagesResponse,\n  type SubscribeToFeedBlocksRequest,\n  type SubscribeToFeedBlocksResponse,\n  type SubscribeToFeedsRequest,\n  type SubscribeToFeedsResponse,\n  type SubscribeToItemsRequest,\n  type SubscribeToItemsResponse,\n  type SubscribeToKeyringKeysRequest,\n  type SubscribeToKeyringKeysResponse,\n  type SubscribeToNetworkTopicsResponse,\n  type SubscribeToSpacesRequest,\n  type SubscribeToSpacesResponse,\n  type SubscribeToSignalStatusResponse,\n  type SignalResponse,\n  type SubscribeToSwarmInfoResponse,\n  type StorageInfo,\n  type GetSnapshotsResponse,\n  type SubscribeToMetadataResponse,\n  type GetBlobsResponse,\n} from '@dxos/protocols/proto/dxos/devtools/host';\n\nimport { subscribeToFeedBlocks, subscribeToFeeds } from './feeds';\nimport { subscribeToKeyringKeys } from './keys';\nimport { subscribeToMetadata } from './metadata';\nimport { subscribeToNetworkStatus, subscribeToSignal, subscribeToSwarmInfo } from './network';\nimport { subscribeToSpaces } from './spaces';\nimport { type ServiceContext } from '../services';\n\nexport class DevtoolsHostEvents {\n  readonly ready = new AsyncEvent();\n}\n\nexport type DevtoolsServiceParams = {\n  events: DevtoolsHostEvents;\n  config: Config;\n  context: ServiceContext;\n};\n\n/**\n * @deprecated\n */\nexport class DevtoolsServiceImpl implements DevtoolsHost {\n  constructor(private readonly params: DevtoolsServiceParams) {}\n\n  events(request: void): Stream<Event> {\n    return new Stream<Event>(({ next }) => {\n      this.params.events.ready.on(() => {\n        next({ ready: {} });\n      });\n    });\n  }\n\n  async getConfig(request: void): Promise<GetConfigResponse> {\n    return { config: JSON.stringify(this.params.config.values) }; // 😨\n  }\n\n  async getStorageInfo(): Promise<StorageInfo> {\n    const storageUsage = (await this.params.context.storage.getDiskInfo?.()) ?? { used: 0 };\n\n    const navigatorInfo = typeof navigator === 'object' ? await navigator.storage.estimate() : undefined;\n\n    return {\n      type: this.params.context.storage.type,\n      storageUsage: storageUsage.used,\n      originUsage: navigatorInfo?.usage ?? 0,\n      usageQuota: navigatorInfo?.quota ?? 0,\n    };\n  }\n\n  async getBlobs(): Promise<GetBlobsResponse> {\n    return {\n      blobs: await this.params.context.blobStore.list(),\n    };\n  }\n\n  async getSnapshots(): Promise<GetSnapshotsResponse> {\n    return {\n      snapshots: [],\n    };\n  }\n\n  resetStorage(request: ResetStorageRequest): Promise<void> {\n    throw new Error();\n  }\n\n  enableDebugLogging(request: EnableDebugLoggingRequest): Promise<EnableDebugLoggingResponse> {\n    throw new Error();\n  }\n\n  disableDebugLogging(request: EnableDebugLoggingRequest): Promise<EnableDebugLoggingResponse> {\n    throw new Error();\n  }\n\n  subscribeToKeyringKeys(request: SubscribeToKeyringKeysRequest): Stream<SubscribeToKeyringKeysResponse> {\n    return subscribeToKeyringKeys({ keyring: this.params.context.keyring });\n  }\n\n  subscribeToCredentialMessages(\n    request: SubscribeToCredentialMessagesRequest,\n  ): Stream<SubscribeToCredentialMessagesResponse> {\n    throw new Error();\n  }\n\n  subscribeToSpaces(request: SubscribeToSpacesRequest): Stream<SubscribeToSpacesResponse> {\n    return subscribeToSpaces(this.params.context, request);\n  }\n\n  subscribeToItems(request: SubscribeToItemsRequest): Stream<SubscribeToItemsResponse> {\n    throw new Error();\n  }\n\n  subscribeToFeeds(request: SubscribeToFeedsRequest): Stream<SubscribeToFeedsResponse> {\n    return subscribeToFeeds(this.params.context, request);\n  }\n\n  subscribeToFeedBlocks(request: SubscribeToFeedBlocksRequest): Stream<SubscribeToFeedBlocksResponse> {\n    return subscribeToFeedBlocks({ feedStore: this.params.context.feedStore }, request);\n  }\n\n  getSpaceSnapshot(request: GetSpaceSnapshotRequest): Promise<GetSpaceSnapshotResponse> {\n    throw new Error();\n  }\n\n  saveSpaceSnapshot(request: SaveSpaceSnapshotRequest): Promise<SaveSpaceSnapshotResponse> {\n    throw new Error();\n  }\n\n  clearSnapshots(request: ClearSnapshotsRequest): Promise<void> {\n    throw new Error();\n  }\n\n  getNetworkPeers(request: GetNetworkPeersRequest): Promise<GetNetworkPeersResponse> {\n    throw new Error();\n  }\n\n  subscribeToNetworkTopics(request: void): Stream<SubscribeToNetworkTopicsResponse> {\n    throw new Error();\n  }\n\n  subscribeToSignalStatus(request: void): Stream<SubscribeToSignalStatusResponse> {\n    return subscribeToNetworkStatus({ signalManager: this.params.context.signalManager });\n  }\n\n  subscribeToSignal(): Stream<SignalResponse> {\n    return subscribeToSignal({ signalManager: this.params.context.signalManager });\n  }\n\n  subscribeToSwarmInfo(): Stream<SubscribeToSwarmInfoResponse> {\n    return subscribeToSwarmInfo({ networkManager: this.params.context.networkManager });\n  }\n\n  subscribeToMetadata(): Stream<SubscribeToMetadataResponse> {\n    return subscribeToMetadata({ context: this.params.context });\n  }\n}\n", "//\n// Copyright 2020 DXOS.org\n//\n\nimport { scheduleTask } from '@dxos/async';\nimport { Stream } from '@dxos/codec-protobuf/stream';\nimport { type Keyring } from '@dxos/keyring';\nimport { type SubscribeToKeyringKeysResponse } from '@dxos/protocols/proto/dxos/devtools/host';\n\nexport const subscribeToKeyringKeys = ({ keyring }: { keyring: Keyring }) =>\n  new Stream<SubscribeToKeyringKeysResponse>(({ next, ctx }) => {\n    const update = async () => {\n      next({\n        keys: await keyring.list(),\n      });\n    };\n    keyring.keysUpdate.on(ctx, update);\n    scheduleTask(ctx, update);\n  });\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { Stream } from '@dxos/codec-protobuf/stream';\nimport { type SubscribeToMetadataResponse } from '@dxos/protocols/proto/dxos/devtools/host';\n\nimport { type ServiceContext } from '../services';\n\nexport const subscribeToMetadata = ({ context }: { context: ServiceContext }) =>\n  new Stream<SubscribeToMetadataResponse>(({ next, ctx }) => {\n    context.metadataStore.update.on(ctx, (data) => next({ metadata: data }));\n    next({ metadata: context.metadataStore.metadata });\n  });\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { asyncTimeout } from '@dxos/async';\nimport { type ClientServices } from '@dxos/client-protocol';\nimport { getFirstStreamValue } from '@dxos/codec-protobuf';\nimport { type Config, type ConfigProto } from '@dxos/config';\nimport { createDidFromIdentityKey, credentialTypeFilter } from '@dxos/credentials';\nimport { invariant } from '@dxos/invariant';\nimport { type PublicKey } from '@dxos/keys';\nimport { STORAGE_VERSION } from '@dxos/protocols';\nimport {\n  SpaceMember,\n  type Device,\n  type Identity,\n  type LogEntry,\n  type Metrics,\n  type NetworkStatus,\n  type Platform,\n  type Space as SpaceProto,\n} from '@dxos/protocols/proto/dxos/client/services';\nimport { type SubscribeToFeedsResponse } from '@dxos/protocols/proto/dxos/devtools/host';\nimport { type SwarmInfo } from '@dxos/protocols/proto/dxos/devtools/swarm';\nimport { type Epoch } from '@dxos/protocols/proto/dxos/halo/credentials';\nimport { type Resource, type Span } from '@dxos/protocols/proto/dxos/tracing';\nimport { TRACE_PROCESSOR } from '@dxos/tracing';\n\nimport { DXOS_VERSION } from '../../version';\nimport { type ServiceContext } from '../services';\nimport { getPlatform } from '../services/platform';\nimport { type DataSpace } from '../spaces';\n\nconst DEFAULT_TIMEOUT = 1_000;\n\nexport type Diagnostics = {\n  client: {\n    config: ConfigProto;\n    trace: TraceDiagnostic;\n  };\n  services: {\n    trace: TraceDiagnostic;\n    created: string;\n    platform: Platform;\n    config?: ConfigProto;\n    client: {\n      version: string;\n      storage: {\n        version: number;\n      };\n    };\n    identity?: Identity;\n    devices?: Device[];\n    spaces?: SpaceStats[];\n    networkStatus?: NetworkStatus;\n    swarms?: SwarmInfo[];\n    feeds?: Partial<SubscribeToFeedsResponse.Feed>[];\n    metrics?: Metrics;\n    storage?: { file: string; count: number }[];\n  };\n};\n\nexport type TraceDiagnostic = {\n  resources: Record<string, Resource>;\n  spans: Span[];\n  logs: LogEntry[];\n};\n\n// TODO(burdon): Normalize for ECHO/HALO.\nexport type SpaceStats = {\n  key: PublicKey;\n  properties?: {\n    name: string;\n  };\n  db?: {\n    objects: number;\n  };\n  metrics?: SpaceProto.Metrics & {\n    startupTime?: number;\n  };\n  epochs?: (Epoch & { id?: PublicKey })[];\n  members?: SpaceMember[];\n  pipeline?: SpaceProto.PipelineState;\n};\n\n/**\n * Create diagnostics to provide snapshot of current system state.\n */\nexport const createDiagnostics = async (\n  clientServices: Partial<ClientServices>,\n  serviceContext: ServiceContext,\n  config: Config,\n): Promise<Diagnostics['services']> => {\n  const diagnostics: Diagnostics['services'] = {\n    created: new Date().toISOString(),\n    platform: getPlatform(),\n    client: {\n      version: DXOS_VERSION,\n      storage: {\n        version: STORAGE_VERSION,\n      },\n    },\n    trace: TRACE_PROCESSOR.getDiagnostics(),\n  };\n\n  await Promise.all([\n    (async () => {\n      // Trace metrics.\n      // TODO(burdon): Move here from logging service?\n      invariant(clientServices.LoggingService, 'SystemService is not available.');\n      diagnostics.metrics = await getFirstStreamValue(clientServices.LoggingService.queryMetrics({}), {\n        timeout: DEFAULT_TIMEOUT,\n      }).catch(() => undefined);\n    })(),\n    (async () => {\n      diagnostics.storage = await asyncTimeout(getStorageDiagnostics(), DEFAULT_TIMEOUT).catch(() => undefined);\n    })(),\n    async () => {\n      const identity = serviceContext.identityManager.identity;\n      if (identity) {\n        // Identity.\n        diagnostics.identity = {\n          did: identity.did,\n          identityKey: identity.identityKey,\n          spaceKey: identity.space.key,\n          profile: identity.profileDocument,\n        };\n\n        // Devices.\n        const { devices } =\n          (await getFirstStreamValue(clientServices.DevicesService!.queryDevices(), {\n            timeout: DEFAULT_TIMEOUT,\n          }).catch(() => undefined)) ?? {};\n        diagnostics.devices = devices;\n\n        // TODO(dmaretskyi): Add metrics for halo space.\n\n        // Spaces.\n        if (serviceContext.dataSpaceManager) {\n          diagnostics.spaces = await Promise.all(\n            Array.from(serviceContext.dataSpaceManager.spaces.values()).map((space) => getSpaceStats(space)) ?? [],\n          );\n        }\n\n        // Feeds.\n        const { feeds = [] } =\n          (await getFirstStreamValue(clientServices.DevtoolsHost!.subscribeToFeeds({}), {\n            timeout: DEFAULT_TIMEOUT,\n          }).catch(() => undefined)) ?? {};\n        diagnostics.feeds = feeds.map(({ feedKey, bytes, length }) => ({ feedKey, bytes, length }));\n\n        // Signal servers.\n\n        const status = await getFirstStreamValue(clientServices.NetworkService!.queryStatus(), {\n          timeout: DEFAULT_TIMEOUT,\n        }).catch(() => undefined);\n        diagnostics.networkStatus = status;\n\n        // Networking.\n\n        diagnostics.swarms = serviceContext.networkManager.connectionLog?.swarms;\n      }\n    },\n  ]);\n\n  diagnostics.config = config.values;\n\n  return diagnostics;\n};\n\nconst getSpaceStats = async (space: DataSpace): Promise<SpaceStats> => {\n  const stats: SpaceStats = {\n    key: space.key,\n    metrics: space.metrics,\n\n    epochs: space.inner.spaceState.credentials\n      .filter(credentialTypeFilter('dxos.halo.credentials.Epoch'))\n      .map((credential) => ({\n        ...credential.subject.assertion,\n        id: credential.id,\n      })),\n\n    members: await Promise.all(\n      Array.from(space.inner.spaceState.members.values()).map(async (member) => ({\n        role: member.role,\n        identity: {\n          did: await createDidFromIdentityKey(member.key),\n          identityKey: member.key,\n          profile: {\n            displayName: member.assertion.profile?.displayName,\n          },\n        },\n        presence:\n          space.presence.getPeersOnline().filter(({ identityKey }) => identityKey.equals(member.key)).length > 0\n            ? SpaceMember.PresenceState.ONLINE\n            : SpaceMember.PresenceState.OFFLINE,\n      })),\n    ),\n\n    pipeline: {\n      // TODO(burdon): Pick properties from credentials if needed.\n      currentEpoch: space.automergeSpaceState.lastEpoch,\n      appliedEpoch: space.automergeSpaceState.lastEpoch,\n\n      controlFeeds: space.inner.controlPipeline.state.feeds.map((feed) => feed.key),\n      currentControlTimeframe: space.inner.controlPipeline.state.timeframe,\n      targetControlTimeframe: space.inner.controlPipeline.state.targetTimeframe,\n      totalControlTimeframe: space.inner.controlPipeline.state.endTimeframe,\n    },\n  };\n\n  // TODO(burdon): Factor out.\n  if (stats.metrics) {\n    const { open, ready } = stats.metrics;\n    stats.metrics.startupTime = open && ready && ready.getTime() - open.getTime();\n  }\n\n  return stats;\n};\n\nconst getStorageDiagnostics = async () => {\n  if (typeof navigator === 'undefined' || !navigator.storage) {\n    return undefined;\n  }\n  const map = new Map();\n  const dir = await navigator.storage.getDirectory();\n  for await (const filename of (dir as any)?.keys()) {\n    const idx = filename.indexOf('-', filename.indexOf('-') + 1);\n    if (idx === -1) {\n      continue;\n    }\n\n    map.set(filename.slice(0, idx), (map.get(filename.slice(0, idx)) ?? 0) + 1);\n  }\n\n  return Array.from(map.entries())\n    .sort((a, b) => b[1] - a[1])\n    .map(([file, count]) => ({ file, count }));\n};\n", "//\n// Copyright 2023 DXOS.org\n//\n\nexport const DXOS_VERSION = '0.8.3'; // {x-release-please-version}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { Platform } from '@dxos/protocols/proto/dxos/client/services';\n\nexport const getPlatform = (): Platform => {\n  if ((process as any).browser) {\n    if (typeof window !== 'undefined') {\n      // Browser.\n      const { userAgent } = window.navigator;\n      return {\n        type: Platform.PLATFORM_TYPE.BROWSER,\n        userAgent,\n        uptime: Math.floor((Date.now() - window.performance.timeOrigin) / 1_000),\n      };\n    } else {\n      // Shared worker.\n      return {\n        type: Platform.PLATFORM_TYPE.SHARED_WORKER,\n        uptime: Math.floor((Date.now() - performance.timeOrigin) / 1_000),\n      };\n    }\n  } else {\n    // Node.\n    const { platform, version, arch } = process;\n    return {\n      type: Platform.PLATFORM_TYPE.NODE,\n      platform,\n      arch,\n      runtime: version,\n      uptime: Math.floor(process.uptime()),\n      memory: process.memoryUsage(),\n    };\n  }\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { type SystemService } from '@dxos/protocols/proto/dxos/client/services';\n\nimport {\n  type CollectDiagnosticsBroadcastSender,\n  type CollectDiagnosticsBroadcastHandler,\n} from './diagnostics-collector';\n\nexport const createCollectDiagnosticsBroadcastSender = (): CollectDiagnosticsBroadcastSender => {\n  return { broadcastDiagnosticsRequest: async () => undefined };\n};\n\nexport const createCollectDiagnosticsBroadcastHandler = (_: SystemService): CollectDiagnosticsBroadcastHandler => {\n  return {\n    start: () => {},\n    stop: () => {},\n  };\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { type ClientServicesProvider, ClientServicesProviderResource } from '@dxos/client-protocol';\nimport { type Config, ConfigResource } from '@dxos/config';\nimport { GetDiagnosticsRequest } from '@dxos/protocols/proto/dxos/client/services';\nimport { TRACE_PROCESSOR } from '@dxos/tracing';\nimport { type JsonKeyOptions, jsonKeyReplacer, isNonNullable } from '@dxos/util';\n\nimport { createCollectDiagnosticsBroadcastSender } from './diagnostics-broadcast';\n\nconst GET_DIAGNOSTICS_RPC_TIMEOUT = 10_000;\n\nexport interface CollectDiagnosticsBroadcastSender {\n  broadcastDiagnosticsRequest(): any;\n}\n\nexport interface CollectDiagnosticsBroadcastHandler {\n  start(): void;\n  stop(): void;\n}\n\nexport class DiagnosticsCollector {\n  private static broadcastSender = createCollectDiagnosticsBroadcastSender();\n\n  public static async collect(\n    config: Config | Config[] = findConfigs(),\n    services: ClientServicesProvider | null = findSystemServiceProvider(),\n    options: JsonKeyOptions = {},\n  ): Promise<any> {\n    const serviceDiagnostics = await services?.services?.SystemService?.getDiagnostics(\n      {\n        keys: options.humanize\n          ? GetDiagnosticsRequest.KEY_OPTION.HUMANIZE\n          : options.truncate\n            ? GetDiagnosticsRequest.KEY_OPTION.TRUNCATE\n            : undefined,\n      },\n      { timeout: GET_DIAGNOSTICS_RPC_TIMEOUT },\n    );\n\n    const clientDiagnostics = {\n      config,\n      trace: TRACE_PROCESSOR.getDiagnostics(),\n    };\n\n    const diagnostics =\n      serviceDiagnostics != null\n        ? { client: clientDiagnostics, services: serviceDiagnostics }\n        : {\n            client: clientDiagnostics,\n            broadcast: await this.broadcastSender.broadcastDiagnosticsRequest(),\n          };\n\n    return JSON.parse(JSON.stringify(diagnostics, jsonKeyReplacer(options)));\n  }\n}\n\nconst findSystemServiceProvider = (): ClientServicesProvider | null => {\n  const serviceProviders = TRACE_PROCESSOR.findResourcesByAnnotation(ClientServicesProviderResource);\n  const providerResource = serviceProviders.find((r) => r.instance.deref()?.services?.SystemService != null);\n  return providerResource?.instance?.deref() ?? null;\n};\n\nconst findConfigs = (): Config[] => {\n  const configs = TRACE_PROCESSOR.findResourcesByAnnotation(ConfigResource);\n  return configs.map((r) => r.instance.deref()).filter(isNonNullable);\n};\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { type Event, Trigger } from '@dxos/async';\nimport { Context } from '@dxos/context';\nimport { verifyCredential, type CredentialSigner } from '@dxos/credentials';\nimport { type AuthProvider, type AuthVerifier } from '@dxos/echo-pipeline';\nimport { type PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { schema } from '@dxos/protocols/proto';\nimport { type ComplexSet } from '@dxos/util';\n\nconst Credential = schema.getCodecForType('dxos.halo.credentials.Credential');\n\nexport const createAuthProvider =\n  (signer: CredentialSigner): AuthProvider =>\n  async (nonce) => {\n    const credential = await signer.createCredential({\n      assertion: {\n        '@type': 'dxos.halo.credentials.Auth',\n      },\n      subject: signer.getIssuer(),\n      nonce,\n    });\n\n    return Credential.encode(credential);\n  };\n\nexport type TrustedKeySetAuthVerifierParams = {\n  // TODO(dmaretskyi): Change to `isTrusted: (key) => bool`.\n  trustedKeysProvider: () => ComplexSet<PublicKey>;\n  update: Event<void>;\n  /**\n   * Timeout to wait for the device key to be added to the trusted set.\n   */\n  authTimeout: number;\n};\n\n/**\n * Verifies credentials of another member in the space based on a set of trusted key.\n * Will wait up to `authTimeout` for the key to be added to the trusted set.\n */\nexport class TrustedKeySetAuthVerifier {\n  private _ctx = new Context();\n\n  constructor(private readonly _params: TrustedKeySetAuthVerifierParams) {}\n\n  async close(): Promise<void> {\n    await this._ctx.dispose();\n  }\n\n  get verifier(): AuthVerifier {\n    return async (nonce, auth) => {\n      const credential = Credential.decode(auth);\n      log('authenticating...', { credential });\n\n      const result = await verifyCredential(credential);\n      if (result.kind === 'fail') {\n        log('Invalid credential', { result });\n        return false;\n      }\n\n      if (!credential.proof!.nonce || !Buffer.from(nonce).equals(credential.proof!.nonce)) {\n        log('Invalid nonce', { nonce, credential });\n        return false;\n      }\n\n      if (this._isTrustedKey(credential.issuer)) {\n        log('key is trusted -- auth success', { key: credential.issuer });\n        return true;\n      }\n\n      const trigger = new Trigger<boolean>();\n      this._ctx.onDispose(() => {\n        trigger.wake(false);\n      });\n\n      const clear = this._params.update.on(this._ctx, () => {\n        if (this._isTrustedKey(credential.issuer)) {\n          log('auth success', { key: credential.issuer });\n          trigger.wake(true);\n        } else {\n          log('key is not currently in trusted set, waiting...', {\n            key: credential.issuer,\n            trusted: [...this._params.trustedKeysProvider()],\n          });\n        }\n      });\n\n      try {\n        return await trigger.wait({ timeout: this._params.authTimeout });\n      } catch {\n        return false;\n      } finally {\n        clear();\n      }\n    };\n  }\n\n  private _isTrustedKey(deviceKey: PublicKey): boolean {\n    const deviceSet = this._params.trustedKeysProvider();\n    return deviceSet.has(deviceKey);\n  }\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { decode as decodeCbor, encode as encodeCbor } from 'cbor-x';\n\nimport { Event, Mutex, scheduleMicroTask } from '@dxos/async';\nimport { Context, Resource } from '@dxos/context';\nimport { type EdgeConnection } from '@dxos/edge-client';\nimport { EdgeConnectionClosedError, EdgeIdentityChangedError } from '@dxos/edge-client';\nimport { type FeedWrapper } from '@dxos/feed-store';\nimport { invariant } from '@dxos/invariant';\nimport { PublicKey, type SpaceId } from '@dxos/keys';\nimport { log, logInfo } from '@dxos/log';\nimport { EdgeService } from '@dxos/protocols';\nimport { buf } from '@dxos/protocols/buf';\nimport {\n  MessageSchema as RouterMessageSchema,\n  type Message as RouterMessage,\n} from '@dxos/protocols/buf/dxos/edge/messenger_pb';\nimport type { FeedBlock, ProtocolMessage } from '@dxos/protocols/feed-replication';\nimport { EdgeStatus } from '@dxos/protocols/proto/dxos/client/services';\nimport { ComplexMap, arrayToBuffer, bufferToArray, defaultMap, rangeFromTo } from '@dxos/util';\n\nexport type EdgeFeedReplicatorParams = {\n  messenger: EdgeConnection;\n  spaceId: SpaceId;\n};\n\nexport class EdgeFeedReplicator extends Resource {\n  private readonly _messenger: EdgeConnection;\n\n  @logInfo\n  private readonly _spaceId: SpaceId;\n\n  private readonly _feeds = new ComplexMap<PublicKey, FeedWrapper<any>>(PublicKey.hash);\n\n  private _connectionCtx?: Context = undefined;\n  private _connected = false;\n  /**\n   * Feed length at service.\n   */\n  private _remoteLength = new ComplexMap<PublicKey, number>(PublicKey.hash);\n\n  /**\n   * Protects against concurrent pushes so that remote length is updated consistently.\n   */\n  private _pushMutex = new ComplexMap<PublicKey, Mutex>(PublicKey.hash);\n\n  constructor({ messenger, spaceId }: EdgeFeedReplicatorParams) {\n    super();\n    this._messenger = messenger;\n    this._spaceId = spaceId;\n  }\n\n  protected override async _open(): Promise<void> {\n    log('open');\n    // TODO: handle reconnects\n    this._ctx.onDispose(\n      this._messenger.onMessage((message: RouterMessage) => {\n        if (!message.serviceId) {\n          return;\n        }\n        const [service, ...rest] = message.serviceId.split(':');\n        if (service !== EdgeService.FEED_REPLICATOR) {\n          return;\n        }\n\n        const [spaceId] = rest;\n        if (spaceId !== this._spaceId) {\n          log('spaceID mismatch', { spaceId, _spaceId: this._spaceId });\n          return;\n        }\n\n        const payload = decodeCbor(message.payload!.value) as ProtocolMessage;\n        log('receive', { from: message.source, feedKey: payload.feedKey, type: payload.type });\n        this._onMessage(payload);\n      }),\n    );\n\n    this._ctx.onDispose(\n      this._messenger.onReconnected(() => {\n        scheduleMicroTask(this._ctx, () => this._handleReconnect());\n      }),\n    );\n  }\n\n  private async _handleReconnect(): Promise<void> {\n    await this._resetConnection();\n    if (this._messenger.status === EdgeStatus.CONNECTED) {\n      this._startReplication();\n    }\n  }\n\n  protected override async _close(): Promise<void> {\n    log('close');\n    await this._resetConnection();\n  }\n\n  private _startReplication(): void {\n    this._connected = true;\n    const connectionCtx = this._createConnectionContext();\n    this._connectionCtx = connectionCtx;\n    log('connection context created');\n    scheduleMicroTask(connectionCtx, async () => {\n      for (const feed of this._feeds.values()) {\n        await this._replicateFeed(connectionCtx, feed);\n      }\n    });\n  }\n\n  private async _resetConnection(): Promise<void> {\n    log('resetConnection');\n    this._connected = false;\n    await this._connectionCtx?.dispose();\n    this._connectionCtx = undefined;\n    this._remoteLength.clear();\n  }\n\n  async addFeed(feed: FeedWrapper<any>): Promise<void> {\n    log('addFeed', { key: feed.key, connected: this._connected, hasConnectionCtx: !!this._connectionCtx });\n    this._feeds.set(feed.key, feed);\n\n    if (this._connected && this._connectionCtx) {\n      await this._replicateFeed(this._connectionCtx, feed);\n    }\n  }\n\n  private _getPushMutex(key: PublicKey): Mutex {\n    return defaultMap(this._pushMutex, key, () => new Mutex());\n  }\n\n  private async _replicateFeed(ctx: Context, feed: FeedWrapper<any>): Promise<void> {\n    log('replicateFeed', { key: feed.key });\n    await this._sendMessage({\n      type: 'get-metadata',\n      feedKey: feed.key.toHex(),\n    });\n\n    Event.wrap(feed.core as any, 'append').on(ctx, async () => {\n      await this._pushBlocksIfNeeded(feed);\n    });\n  }\n\n  private async _sendMessage(message: ProtocolMessage): Promise<void> {\n    if (!this._connectionCtx) {\n      log('message dropped because connection was disposed');\n      return;\n    }\n\n    if (message.type === 'data') {\n      log('sending blocks', {\n        feedKey: message.feedKey,\n        blocks: message.blocks.map((b) => b.index),\n      });\n    }\n\n    invariant(message.feedKey);\n    const payloadValue = bufferToArray(encodeCbor(message));\n\n    log('send', { type: message.type });\n    await this._messenger.send(\n      buf.create(RouterMessageSchema, {\n        source: {\n          identityKey: this._messenger.identityKey,\n          peerKey: this._messenger.peerKey,\n        },\n        serviceId: `${EdgeService.FEED_REPLICATOR}:${this._spaceId}`,\n        payload: { value: payloadValue },\n      }),\n    );\n  }\n\n  private _onMessage(message: ProtocolMessage): void {\n    if (!this._connectionCtx) {\n      log.warn('received message after connection context was disposed');\n      return;\n    }\n    scheduleMicroTask(this._connectionCtx, async () => {\n      switch (message.type) {\n        case 'metadata': {\n          const feedKey = PublicKey.fromHex(message.feedKey);\n          const feed = this._feeds.get(feedKey);\n          if (!feed) {\n            log.warn('Feed not found', { feedKey });\n            return;\n          }\n\n          using _guard = await this._getPushMutex(feed.key).acquire();\n\n          this._remoteLength.set(feedKey, message.length);\n\n          const logMeta = { localLength: feed.length, remoteLength: message.length, feedKey };\n          if (message.length > feed.length) {\n            log('requesting missing blocks', logMeta);\n\n            await this._sendMessage({\n              type: 'request',\n              feedKey: feedKey.toHex(),\n              range: { from: feed.length, to: message.length },\n            });\n          } else if (message.length < feed.length) {\n            log('pushing blocks to remote', logMeta);\n\n            await this._pushBlocks(feed, message.length, feed.length);\n          }\n\n          break;\n        }\n\n        case 'data': {\n          log('received data', { feed: message.feedKey, blocks: message.blocks.map((b) => b.index) });\n\n          const feedKey = PublicKey.fromHex(message.feedKey);\n          const feed = this._feeds.get(feedKey);\n          if (!feed) {\n            log.warn('Feed not found', { feedKey });\n            return;\n          }\n\n          await this._integrateBlocks(feed, message.blocks);\n          break;\n        }\n\n        default: {\n          log.warn('Unknown message', { ...message });\n        }\n      }\n    });\n  }\n\n  private async _pushBlocks(feed: FeedWrapper<any>, from: number, to: number): Promise<void> {\n    log('pushing blocks', { feed: feed.key.toHex(), from, to });\n\n    const blocks: FeedBlock[] = await Promise.all(\n      rangeFromTo(from, to).map(async (index) => {\n        const data = await feed.get(index, { valueEncoding: 'binary' });\n        invariant(data instanceof Uint8Array);\n        const proof = await feed.proof(index);\n\n        return {\n          index,\n          data,\n          nodes: proof.nodes,\n          signature: proof.signature,\n        } satisfies FeedBlock;\n      }),\n    );\n\n    await this._sendMessage({\n      type: 'data',\n      feedKey: feed.key.toHex(),\n      blocks,\n    });\n    this._remoteLength.set(feed.key, to);\n  }\n\n  private async _integrateBlocks(feed: FeedWrapper<any>, blocks: FeedBlock[]): Promise<void> {\n    log('integrating blocks', { feed: feed.key.toHex(), blocks: blocks.length });\n\n    for (const block of blocks) {\n      if (feed.has(block.index)) {\n        continue;\n      }\n      const blockBuffer = bufferizeBlock(block);\n\n      await feed.putBuffer(\n        block.index,\n        blockBuffer.data,\n        { nodes: blockBuffer.nodes, signature: blockBuffer.signature },\n        null,\n      );\n    }\n  }\n\n  private async _pushBlocksIfNeeded(feed: FeedWrapper<any>): Promise<void> {\n    using _ = await this._getPushMutex(feed.key).acquire();\n\n    if (!this._remoteLength.has(feed.key)) {\n      log('blocks not pushed because remote length is unknown');\n      return;\n    }\n\n    const remoteLength = this._remoteLength.get(feed.key)!;\n    if (remoteLength < feed.length) {\n      await this._pushBlocks(feed, remoteLength, feed.length);\n    }\n  }\n\n  private _createConnectionContext(): Context {\n    const connectionCtx = new Context({\n      onError: async (err: any) => {\n        if (connectionCtx !== this._connectionCtx) {\n          return;\n        }\n        if (err instanceof EdgeIdentityChangedError || err instanceof EdgeConnectionClosedError) {\n          log('resetting on reconnect');\n          await this._resetConnection();\n        } else {\n          this._ctx.raise(err);\n        }\n      },\n    });\n    return connectionCtx;\n  }\n}\n\n// hypercore requires buffers\nconst bufferizeBlock = (block: FeedBlock) => ({\n  index: block.index,\n  data: arrayToBuffer(block.data),\n  nodes: block.nodes.map((node) => ({\n    index: node.index,\n    hash: arrayToBuffer(node.hash),\n    size: node.size,\n  })),\n  signature: arrayToBuffer(block.signature),\n});\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { save } from '@automerge/automerge';\nimport { type DocHandle } from '@automerge/automerge-repo';\n\nimport { Event, Mutex, scheduleTask, sleep, synchronized, trackLeaks } from '@dxos/async';\nimport { AUTH_TIMEOUT } from '@dxos/client-protocol';\nimport { Context, ContextDisposedError, cancelWithContext } from '@dxos/context';\nimport type { SpecificCredential } from '@dxos/credentials';\nimport { timed, warnAfterTimeout } from '@dxos/debug';\nimport {\n  type EchoHost,\n  type DatabaseRoot,\n  createMappedFeedWriter,\n  type MetadataStore,\n  type Space,\n  FIND_PARAMS,\n} from '@dxos/echo-pipeline';\nimport { SpaceDocVersion, type DatabaseDirectory } from '@dxos/echo-protocol';\nimport type { EdgeConnection, EdgeHttpClient } from '@dxos/edge-client';\nimport { type FeedStore, type FeedWrapper } from '@dxos/feed-store';\nimport { failedInvariant, invariant } from '@dxos/invariant';\nimport { type Keyring } from '@dxos/keyring';\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { CancelledError, SystemError } from '@dxos/protocols';\nimport {\n  type CreateEpochRequest,\n  SpaceState,\n  type Space as SpaceProto,\n} from '@dxos/protocols/proto/dxos/client/services';\nimport { type Runtime } from '@dxos/protocols/proto/dxos/config';\nimport { type FeedMessage } from '@dxos/protocols/proto/dxos/echo/feed';\nimport { type SpaceCache } from '@dxos/protocols/proto/dxos/echo/metadata';\nimport {\n  AdmittedFeed,\n  SpaceMember,\n  type Credential,\n  type Epoch,\n  type ProfileDocument,\n} from '@dxos/protocols/proto/dxos/halo/credentials';\nimport { type GossipMessage } from '@dxos/protocols/proto/dxos/mesh/teleport/gossip';\nimport { type Gossip, type Presence } from '@dxos/teleport-extension-gossip';\nimport { Timeframe } from '@dxos/timeframe';\nimport { trace } from '@dxos/tracing';\nimport { CallbackCollection, ComplexSet, type AsyncCallback } from '@dxos/util';\n\nimport { AutomergeSpaceState } from './automerge-space-state';\nimport { type SigningContext } from './data-space-manager';\nimport { EdgeFeedReplicator } from './edge-feed-replicator';\nimport { runEpochMigration } from './epoch-migrations';\nimport { NotarizationPlugin } from './notarization-plugin';\nimport { TrustedKeySetAuthVerifier } from '../identity';\n\nexport type DataSpaceCallbacks = {\n  /**\n   * Called before transitioning to the ready state.\n   */\n  beforeReady?: () => Promise<void>;\n\n  /**\n   * Called after transitioning to the ready state.\n   */\n  afterReady?: () => Promise<void>;\n\n  /**\n   * Called before space gets closed.\n   */\n  beforeClose?: () => Promise<void>;\n};\n\nexport type DataSpaceParams = {\n  initialState: SpaceState;\n  inner: Space;\n  metadataStore: MetadataStore;\n  gossip: Gossip;\n  presence: Presence;\n  keyring: Keyring;\n  feedStore: FeedStore<FeedMessage>;\n  echoHost: EchoHost;\n  signingContext: SigningContext;\n  callbacks?: DataSpaceCallbacks;\n  cache?: SpaceCache;\n  edgeConnection?: EdgeConnection;\n  edgeHttpClient?: EdgeHttpClient;\n  edgeFeatures?: Runtime.Client.EdgeFeatures;\n  activeEdgeNotarizationPollingInterval?: number;\n};\n\nexport type CreateEpochOptions = {\n  migration?: CreateEpochRequest.Migration;\n  newAutomergeRoot?: string;\n};\n\n@trackLeaks('open', 'close')\n@trace.resource()\nexport class DataSpace {\n  private _ctx = new Context();\n  @trace.info()\n  private readonly _inner: Space;\n\n  private readonly _gossip: Gossip;\n  private readonly _presence: Presence;\n  private readonly _keyring: Keyring;\n  private readonly _feedStore: FeedStore<FeedMessage>;\n  private readonly _metadataStore: MetadataStore;\n  private readonly _signingContext: SigningContext;\n  private readonly _notarizationPlugin: NotarizationPlugin;\n  private readonly _callbacks: DataSpaceCallbacks;\n  private readonly _cache?: SpaceCache = undefined;\n  private readonly _echoHost: EchoHost;\n  private readonly _edgeFeedReplicator?: EdgeFeedReplicator = undefined;\n\n  // TODO(dmaretskyi): Move into Space?\n  private readonly _automergeSpaceState = new AutomergeSpaceState((rootUrl) => this._onNewAutomergeRoot(rootUrl));\n\n  private readonly _epochProcessingMutex = new Mutex();\n\n  private _state = SpaceState.SPACE_CLOSED;\n\n  private _databaseRoot: DatabaseRoot | null = null;\n\n  /**\n   * Error for _state === SpaceState.SPACE_ERROR.\n   */\n  public error: Error | undefined = undefined;\n\n  public readonly authVerifier: TrustedKeySetAuthVerifier;\n  public readonly stateUpdate = new Event();\n\n  public readonly postOpen = new CallbackCollection<AsyncCallback<void>>();\n  public readonly preClose = new CallbackCollection<AsyncCallback<void>>();\n\n  public metrics: SpaceProto.Metrics = {};\n\n  constructor(params: DataSpaceParams) {\n    this._inner = params.inner;\n    this._inner.stateUpdate.on(this._ctx, () => this.stateUpdate.emit());\n\n    this._gossip = params.gossip;\n    this._presence = params.presence;\n    this._keyring = params.keyring;\n    this._feedStore = params.feedStore;\n    this._metadataStore = params.metadataStore;\n    this._signingContext = params.signingContext;\n    this._callbacks = params.callbacks ?? {};\n    this._echoHost = params.echoHost;\n    this._notarizationPlugin = new NotarizationPlugin({\n      spaceId: this._inner.id,\n      edgeClient: params.edgeHttpClient,\n      edgeFeatures: params.edgeFeatures,\n      activeEdgePollingInterval: params.activeEdgeNotarizationPollingInterval,\n    });\n\n    this.authVerifier = new TrustedKeySetAuthVerifier({\n      trustedKeysProvider: () =>\n        new ComplexSet(\n          PublicKey.hash,\n          Array.from(this._inner.spaceState.members.values())\n            .filter((member) => member.role !== SpaceMember.Role.REMOVED)\n            .map((member) => member.key),\n        ),\n      update: this._inner.stateUpdate,\n      authTimeout: AUTH_TIMEOUT,\n    });\n\n    this._cache = params.cache;\n\n    if (params.edgeConnection && params.edgeFeatures?.feedReplicator) {\n      this._edgeFeedReplicator = new EdgeFeedReplicator({ messenger: params.edgeConnection, spaceId: this.id });\n    }\n\n    this._state = params.initialState;\n    log('new state', { state: SpaceState[this._state] });\n  }\n\n  @trace.info()\n  get id() {\n    return this._inner.id;\n  }\n\n  @trace.info()\n  get key() {\n    return this._inner.key;\n  }\n\n  get isOpen() {\n    return this._inner.isOpen;\n  }\n\n  @trace.info({ enum: SpaceState })\n  get state(): SpaceState {\n    return this._state;\n  }\n\n  // TODO(burdon): Can we mark this for debugging only?\n  get inner() {\n    return this._inner;\n  }\n\n  get presence() {\n    return this._presence;\n  }\n\n  get notarizationPlugin() {\n    return this._notarizationPlugin;\n  }\n\n  get cache() {\n    return this._cache;\n  }\n\n  get automergeSpaceState() {\n    return this._automergeSpaceState;\n  }\n\n  get databaseRoot(): DatabaseRoot | null {\n    return this._databaseRoot;\n  }\n\n  @trace.info({ depth: null })\n  private get _automergeInfo() {\n    return {\n      rootUrl: this._automergeSpaceState.rootUrl,\n      lastEpoch: this._automergeSpaceState.lastEpoch,\n    };\n  }\n\n  @synchronized\n  async open(): Promise<void> {\n    if (this._state === SpaceState.SPACE_CLOSED) {\n      await this._open();\n    }\n  }\n\n  private async _open(): Promise<void> {\n    await this._presence.open();\n    await this._gossip.open();\n    await this._notarizationPlugin.open();\n    await this._inner.spaceState.addCredentialProcessor(this._notarizationPlugin);\n    await this._automergeSpaceState.open();\n    await this._inner.spaceState.addCredentialProcessor(this._automergeSpaceState);\n\n    if (this._edgeFeedReplicator) {\n      this.inner.protocol.feedAdded.append(this._onFeedAdded);\n    }\n\n    await this._inner.open(new Context());\n    await this._inner.startProtocol();\n\n    await this._edgeFeedReplicator?.open();\n\n    this._state = SpaceState.SPACE_CONTROL_ONLY;\n    log('new state', { state: SpaceState[this._state] });\n    this.stateUpdate.emit();\n    this.metrics = {};\n    this.metrics.open = new Date();\n\n    await this.postOpen.callSerial();\n  }\n\n  @synchronized\n  async close(): Promise<void> {\n    await this._close();\n  }\n\n  private async _close(): Promise<void> {\n    await this._callbacks.beforeClose?.();\n\n    await this.preClose.callSerial();\n\n    this._state = SpaceState.SPACE_CLOSED;\n    log('new state', { state: SpaceState[this._state] });\n    await this._ctx.dispose();\n    this._ctx = new Context();\n\n    if (this._edgeFeedReplicator) {\n      this.inner.protocol.feedAdded.remove(this._onFeedAdded);\n    }\n\n    await this._edgeFeedReplicator?.close();\n\n    await this.authVerifier.close();\n\n    await this._inner.close();\n    await this._inner.spaceState.removeCredentialProcessor(this._automergeSpaceState);\n    await this._automergeSpaceState.close();\n    await this._inner.spaceState.removeCredentialProcessor(this._notarizationPlugin);\n    await this._notarizationPlugin.close();\n\n    await this._presence.close();\n    await this._gossip.close();\n  }\n\n  async postMessage(channel: string, message: any): Promise<void> {\n    return this._gossip.postMessage(channel, message);\n  }\n\n  listen(channel: string, callback: (message: GossipMessage) => void): { unsubscribe: () => void } {\n    return this._gossip.listen(channel, callback);\n  }\n\n  /**\n   * Initialize the data pipeline in a separate task.\n   */\n  initializeDataPipelineAsync(): void {\n    scheduleTask(this._ctx, async () => {\n      try {\n        this.metrics.pipelineInitBegin = new Date();\n        await this.initializeDataPipeline();\n      } catch (err) {\n        if (err instanceof CancelledError || err instanceof ContextDisposedError) {\n          log('data pipeline initialization cancelled', err);\n          return;\n        }\n\n        log.error('Error initializing data pipeline', err);\n        this._state = SpaceState.SPACE_ERROR;\n        log('new state', { state: SpaceState[this._state] });\n        this.error = err as Error;\n        this.stateUpdate.emit();\n      } finally {\n        this.metrics.ready = new Date();\n      }\n    });\n  }\n\n  @trace.span({ showInBrowserTimeline: true })\n  async initializeDataPipeline(): Promise<void> {\n    if (this._state !== SpaceState.SPACE_CONTROL_ONLY) {\n      throw new SystemError('Invalid operation');\n    }\n\n    this._state = SpaceState.SPACE_INITIALIZING;\n    log('new state', { state: SpaceState[this._state] });\n\n    log('initializing control pipeline');\n    await this._initializeAndReadControlPipeline();\n\n    // Allow other tasks to run before loading the data pipeline.\n    await sleep(1);\n\n    const ready = this.stateUpdate.waitForCondition(() => this._state === SpaceState.SPACE_READY);\n\n    log('initializing automerge root');\n    this._automergeSpaceState.startProcessingRootDocs();\n\n    // TODO(dmaretskyi): Change so `initializeDataPipeline` doesn't wait for the space to be READY, but rather any state with a valid root.\n    log('waiting for space to be ready');\n    await ready;\n    log('space is ready');\n  }\n\n  async *getAllDocuments(): AsyncIterable<[string, Uint8Array]> {\n    invariant(this._databaseRoot, 'Space is not ready');\n    const doc = this._databaseRoot.doc() ?? failedInvariant();\n    const root = save(doc);\n    yield [this._databaseRoot.documentId, root];\n\n    for (const documentUrl of this._databaseRoot.getAllLinkedDocuments()) {\n      const data = await this._echoHost.exportDoc(Context.default(), documentUrl);\n      yield [documentUrl.replace(/^automerge:/, ''), data];\n    }\n  }\n\n  private async _enterReadyState(): Promise<void> {\n    await this._callbacks.beforeReady?.();\n\n    this._state = SpaceState.SPACE_READY;\n    log('new state', { state: SpaceState[this._state] });\n    this.stateUpdate.emit();\n\n    await this._callbacks.afterReady?.();\n  }\n\n  @trace.span({ showInBrowserTimeline: true })\n  private async _initializeAndReadControlPipeline(): Promise<void> {\n    await this._inner.controlPipeline.state.waitUntilReachedTargetTimeframe({\n      ctx: this._ctx,\n      timeout: 10_000,\n      breakOnStall: false,\n    });\n\n    this.metrics.controlPipelineReady = new Date();\n\n    await this._createWritableFeeds();\n    log('writable feeds created');\n    this.stateUpdate.emit();\n\n    if (!this.notarizationPlugin.hasWriter) {\n      this.notarizationPlugin.setWriter(\n        createMappedFeedWriter<Credential, FeedMessage.Payload>(\n          (credential) => ({\n            credential: { credential },\n          }),\n          this._inner.controlPipeline.writer,\n        ),\n      );\n    }\n  }\n\n  @timed(10_000)\n  private async _createWritableFeeds(): Promise<void> {\n    const credentials: Credential[] = [];\n    if (!this.inner.controlFeedKey) {\n      const controlFeed = await this._feedStore.openFeed(await this._keyring.createKey(), { writable: true });\n      await this.inner.setControlFeed(controlFeed);\n\n      credentials.push(\n        await this._signingContext.credentialSigner.createCredential({\n          subject: controlFeed.key,\n          assertion: {\n            '@type': 'dxos.halo.credentials.AdmittedFeed',\n            spaceKey: this.key,\n            deviceKey: this._signingContext.deviceKey,\n            identityKey: this._signingContext.identityKey,\n            designation: AdmittedFeed.Designation.CONTROL,\n          },\n        }),\n      );\n    }\n    if (!this.inner.dataFeedKey) {\n      const dataFeed = await this._feedStore.openFeed(await this._keyring.createKey(), {\n        writable: true,\n        sparse: true,\n      });\n      await this.inner.setDataFeed(dataFeed);\n\n      credentials.push(\n        await this._signingContext.credentialSigner.createCredential({\n          subject: dataFeed.key,\n          assertion: {\n            '@type': 'dxos.halo.credentials.AdmittedFeed',\n            spaceKey: this.key,\n            deviceKey: this._signingContext.deviceKey,\n            identityKey: this._signingContext.identityKey,\n            designation: AdmittedFeed.Designation.DATA,\n          },\n        }),\n      );\n    }\n\n    if (credentials.length > 0) {\n      try {\n        log('will notarize credentials for feed admission', { count: credentials.length });\n        // Never times out\n        await this.notarizationPlugin.notarize({ ctx: this._ctx, credentials, timeout: 0 });\n\n        log('credentials notarized');\n      } catch (err) {\n        log.error('error notarizing credentials for feed admission', err);\n        throw err;\n      }\n\n      // Set this after credentials are notarized so that on failure we will retry.\n      await this._metadataStore.setWritableFeedKeys(this.key, this.inner.controlFeedKey!, this.inner.dataFeedKey!);\n    }\n  }\n\n  private _onNewAutomergeRoot(rootUrl: string): void {\n    log('loading automerge root doc for space', { space: this.key, rootUrl });\n\n    let handle: DocHandle<DatabaseDirectory>;\n\n    // TODO(dmaretskyi): Make this single-threaded (but doc loading should still be parallel to not block epoch processing).\n    queueMicrotask(async () => {\n      try {\n        await warnAfterTimeout(5_000, 'Automerge root doc load timeout (DataSpace)', async () => {\n          handle = await cancelWithContext(\n            this._ctx,\n            this._echoHost.automergeRepo.find<DatabaseDirectory>(rootUrl as any, FIND_PARAMS),\n          );\n          await cancelWithContext(this._ctx, handle.whenReady());\n        });\n        if (this._ctx.disposed) {\n          return;\n        }\n\n        // Ensure only one root is processed at a time.\n        using _guard = await this._epochProcessingMutex.acquire();\n\n        // Attaching space keys to legacy documents.\n        const doc = handle.doc() ?? failedInvariant();\n        if (!doc.access?.spaceKey) {\n          handle.change((doc: any) => {\n            doc.access = { spaceKey: this.key.toHex() };\n          });\n        }\n\n        // TODO(dmaretskyi): Close roots.\n        // TODO(dmaretskyi): How do we handle changing to the next EPOCH?\n        const root = await this._echoHost.openSpaceRoot(this.id, handle.url);\n\n        // NOTE: Make sure this assignment happens synchronously together with the state change.\n        this._databaseRoot = root;\n        if (root.getVersion() !== SpaceDocVersion.CURRENT) {\n          this._state = SpaceState.SPACE_REQUIRES_MIGRATION;\n          this.stateUpdate.emit();\n        } else if (this._state !== SpaceState.SPACE_READY) {\n          await this._enterReadyState();\n        } else {\n          this.stateUpdate.emit();\n        }\n      } catch (err) {\n        if (err instanceof ContextDisposedError) {\n          return;\n        }\n        log.warn('error loading automerge root doc', { space: this.key, rootUrl, err });\n      }\n    });\n  }\n\n  // TODO(dmaretskyi): Use profile from signing context.\n  async updateOwnProfile(profile: ProfileDocument): Promise<void> {\n    const credential = await this._signingContext.credentialSigner.createCredential({\n      subject: this._signingContext.identityKey,\n      assertion: {\n        '@type': 'dxos.halo.credentials.MemberProfile',\n        profile,\n      },\n    });\n    await this.inner.controlPipeline.writer.write({ credential: { credential } });\n  }\n\n  async createEpoch(options?: CreateEpochOptions): Promise<CreateEpochResult | null> {\n    const ctx = this._ctx.derive();\n\n    // Preserving existing behavior.\n    if (!options?.migration) {\n      return null;\n    }\n\n    const { newRoot } = await runEpochMigration(ctx, {\n      echoHost: this._echoHost,\n      spaceId: this.id,\n      spaceKey: this.key,\n      migration: options.migration,\n      currentRoot: this._automergeSpaceState.rootUrl ?? null,\n      newAutomergeRoot: options.newAutomergeRoot,\n    });\n\n    const epoch: Epoch = {\n      previousId: this._automergeSpaceState.lastEpoch?.id,\n      number: (this._automergeSpaceState.lastEpoch?.subject.assertion.number ?? -1) + 1,\n      timeframe: this._automergeSpaceState.lastEpoch?.subject.assertion.timeframe ?? new Timeframe(),\n      automergeRoot: newRoot ?? this._automergeSpaceState.rootUrl,\n    };\n\n    const credential = (await this._signingContext.credentialSigner.createCredential({\n      subject: this.key,\n      assertion: {\n        '@type': 'dxos.halo.credentials.Epoch',\n        ...epoch,\n      },\n    })) as SpecificCredential<Epoch>;\n\n    const receipt = await this.inner.controlPipeline.writer.write({\n      credential: { credential },\n    });\n\n    const timeframe = new Timeframe([[receipt.feedKey, receipt.seq]]);\n    await this.inner.controlPipeline.state.waitUntilTimeframe(timeframe);\n    await this._echoHost.updateIndexes();\n\n    return { credential, timeframe };\n  }\n\n  @synchronized\n  async activate(): Promise<void> {\n    if (![SpaceState.SPACE_CLOSED, SpaceState.SPACE_INACTIVE].includes(this._state)) {\n      return;\n    }\n\n    await this._metadataStore.setSpaceState(this.key, SpaceState.SPACE_ACTIVE);\n    await this._open();\n    this.initializeDataPipelineAsync();\n  }\n\n  @synchronized\n  async deactivate(): Promise<void> {\n    if (this._state === SpaceState.SPACE_INACTIVE) {\n      return;\n    }\n    // Unregister from data service.\n    await this._metadataStore.setSpaceState(this.key, SpaceState.SPACE_INACTIVE);\n    if (this._state !== SpaceState.SPACE_CLOSED) {\n      await this._close();\n    }\n    this._state = SpaceState.SPACE_INACTIVE;\n    log('new state', { state: SpaceState[this._state] });\n    this.stateUpdate.emit();\n  }\n\n  getEdgeReplicationSetting() {\n    return this._metadataStore.getSpaceEdgeReplicationSetting(this.key);\n  }\n\n  private _onFeedAdded = async (feed: FeedWrapper<any>) => {\n    await this._edgeFeedReplicator!.addFeed(feed);\n  };\n}\n\ntype CreateEpochResult = {\n  credential: SpecificCredential<Epoch>;\n  timeframe: Timeframe;\n};\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { Event } from '@dxos/async';\nimport { Resource, type Context } from '@dxos/context';\nimport { type CredentialProcessor, type SpecificCredential, checkCredentialType } from '@dxos/credentials';\nimport { type Credential, type Epoch } from '@dxos/protocols/proto/dxos/halo/credentials';\n\nexport class AutomergeSpaceState extends Resource implements CredentialProcessor {\n  public rootUrl: string | undefined = undefined;\n  public lastEpoch: SpecificCredential<Epoch> | undefined = undefined;\n\n  public readonly onNewEpoch = new Event<SpecificCredential<Epoch>>();\n\n  private _isProcessingRootDocs = false;\n\n  constructor(private readonly _onNewRoot: (rootUrl: string) => void) {\n    super();\n  }\n\n  protected override async _open(ctx: Context): Promise<void> {}\n\n  protected override async _close(ctx: Context): Promise<void> {\n    this._isProcessingRootDocs = false;\n  }\n\n  async processCredential(credential: Credential): Promise<void> {\n    if (!checkCredentialType(credential, 'dxos.halo.credentials.Epoch')) {\n      return;\n    }\n\n    this.lastEpoch = credential;\n    if (credential.subject.assertion.automergeRoot) {\n      this.rootUrl = credential.subject.assertion.automergeRoot;\n\n      if (this._isProcessingRootDocs) {\n        this._onNewRoot(this.rootUrl);\n      }\n    }\n\n    this.onNewEpoch.emit(credential);\n  }\n\n  startProcessingRootDocs(): void {\n    if (this._isProcessingRootDocs) {\n      return;\n    }\n\n    if (this.rootUrl) {\n      this._onNewRoot(this.rootUrl);\n    }\n    this._isProcessingRootDocs = true;\n  }\n\n  async ensureEpochInitialized(): Promise<void> {\n    await this.onNewEpoch.waitForCondition(() => !!this.lastEpoch);\n  }\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport type { AutomergeUrl } from '@automerge/automerge-repo';\n\nimport { type Context } from '@dxos/context';\nimport { type EchoHost } from '@dxos/echo-pipeline';\nimport { invariant } from '@dxos/invariant';\nimport type { PublicKey, SpaceId } from '@dxos/keys';\nimport { CreateEpochRequest } from '@dxos/protocols/proto/dxos/client/services';\n\nexport type MigrationContext = {\n  echoHost: EchoHost;\n\n  spaceId: SpaceId;\n  /**\n   * @deprecated Remove.\n   */\n  spaceKey: PublicKey;\n  migration: CreateEpochRequest.Migration;\n  currentRoot: string | null;\n\n  /**\n   * For set automerge root migration type.\n   */\n  newAutomergeRoot?: string;\n};\n\nexport type MigrationResult = {\n  newRoot?: string;\n};\n\nconst LOAD_DOC_TIMEOUT = 10_000;\n\nexport const runEpochMigration = async (ctx: Context, context: MigrationContext): Promise<MigrationResult> => {\n  switch (context.migration) {\n    case CreateEpochRequest.Migration.INIT_AUTOMERGE: {\n      const document = context.echoHost.createDoc();\n      await context.echoHost.flush();\n      return { newRoot: document.url };\n    }\n    case CreateEpochRequest.Migration.PRUNE_AUTOMERGE_ROOT_HISTORY: {\n      if (!context.currentRoot) {\n        throw new Error('Space does not have an automerge root');\n      }\n      const rootHandle = await context.echoHost.loadDoc(ctx, context.currentRoot as AutomergeUrl, {\n        timeout: LOAD_DOC_TIMEOUT,\n      });\n\n      const newRoot = context.echoHost.createDoc(rootHandle.doc());\n      await context.echoHost.flush();\n      return { newRoot: newRoot.url };\n    }\n    case CreateEpochRequest.Migration.FRAGMENT_AUTOMERGE_ROOT: {\n      throw new Error('Migration not available');\n    }\n    case CreateEpochRequest.Migration.MIGRATE_REFERENCES_TO_DXN: {\n      throw new Error('Migration not available');\n    }\n    // TODO(dmaretskyi): This path doesn't seem to fit here. This is not a migration.\n    case CreateEpochRequest.Migration.REPLACE_AUTOMERGE_ROOT: {\n      invariant(context.newAutomergeRoot);\n\n      // Defensive programming - it should be the responsibility of the caller to flush the new root.\n      await context.echoHost.flush();\n      return {\n        newRoot: context.newAutomergeRoot,\n      };\n    }\n  }\n\n  return {};\n};\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { DeferredTask, Event, scheduleTask, sleep, TimeoutError, Trigger, scheduleMicroTask } from '@dxos/async';\nimport { type Context, rejectOnDispose, Resource } from '@dxos/context';\nimport { type CredentialProcessor, verifyCredential } from '@dxos/credentials';\nimport { type EdgeHttpClient } from '@dxos/edge-client';\nimport { type FeedWriter } from '@dxos/feed-store';\nimport { invariant } from '@dxos/invariant';\nimport { PublicKey } from '@dxos/keys';\nimport { type SpaceId } from '@dxos/keys';\nimport { logInfo, log } from '@dxos/log';\nimport { EdgeCallFailedError } from '@dxos/protocols';\nimport { schema } from '@dxos/protocols/proto';\nimport { type Runtime } from '@dxos/protocols/proto/dxos/config';\nimport { type Credential } from '@dxos/protocols/proto/dxos/halo/credentials';\nimport { type NotarizationService, type NotarizeRequest } from '@dxos/protocols/proto/dxos/mesh/teleport/notarization';\nimport { type ExtensionContext, RpcExtension } from '@dxos/teleport';\nimport { ComplexMap, ComplexSet, entry } from '@dxos/util';\n\nconst DEFAULT_RETRY_TIMEOUT = 1_000;\n\nconst DEFAULT_SUCCESS_DELAY = 1_000;\n\nconst DEFAULT_NOTARIZE_TIMEOUT = 10_000;\n\nconst DEFAULT_ACTIVE_EDGE_POLLING_INTERVAL = 3_000;\n\nconst MAX_EDGE_RETRIES = 2;\n\nconst WRITER_NOT_SET_ERROR_CODE = 'WRITER_NOT_SET';\n\nconst credentialCodec = schema.getCodecForType('dxos.halo.credentials.Credential');\n\nexport type NotarizationPluginParams = {\n  spaceId: SpaceId;\n  edgeClient?: EdgeHttpClient;\n  edgeFeatures?: Runtime.Client.EdgeFeatures;\n  activeEdgePollingInterval?: number;\n};\n\nexport type NotarizeParams = {\n  /**\n   * For cancellation.\n   */\n  ctx?: Context;\n\n  /**\n   * Credentials to notarize.\n   */\n  credentials: Credential[];\n\n  /**\n   * Timeout for the whole notarization process.\n   * Set to 0 to disable.\n   * @default {@link DEFAULT_NOTARIZE_TIMEOUT}\n   */\n  timeout?: number;\n\n  /**\n   * Retry timeout.\n   * @default {@link DEFAULT_RETRY_TIMEOUT}\n   */\n  retryTimeout?: number;\n\n  /**\n   * Minimum wait time after a peer confirms successful notarization before attempting with a new peer.\n   * This is to avoid spamming peers with notarization requests.\n   * @default {@link DEFAULT_SUCCESS_DELAY}\n   */\n  successDelay?: number;\n\n  /**\n   * A random amount of time before making or retrying an edge request to help prevent large bursts of requests.\n   */\n  edgeRetryJitter?: number;\n};\n\n/**\n * See NotarizationService proto.\n */\nexport class NotarizationPlugin extends Resource implements CredentialProcessor {\n  private readonly _extensionOpened = new Event();\n\n  private _writer: FeedWriter<Credential> | undefined;\n  private readonly _extensions = new Set<NotarizationTeleportExtension>();\n  private readonly _processedCredentials = new ComplexSet<PublicKey>(PublicKey.hash);\n  private readonly _processCredentialsTriggers = new ComplexMap<PublicKey, Trigger>(PublicKey.hash);\n\n  private _activeEdgePollingIntervalHandle: any | undefined = undefined;\n  private readonly _activeEdgePollingInterval: number;\n  private _activeEdgePollingEnabled = false;\n\n  @logInfo\n  private readonly _spaceId: SpaceId;\n\n  private readonly _edgeClient: EdgeHttpClient | undefined;\n\n  constructor(params: NotarizationPluginParams) {\n    super();\n    this._spaceId = params.spaceId;\n    this._activeEdgePollingInterval = params.activeEdgePollingInterval ?? DEFAULT_ACTIVE_EDGE_POLLING_INTERVAL;\n    if (params.edgeClient && params.edgeFeatures?.feedReplicator) {\n      this._edgeClient = params.edgeClient;\n    }\n  }\n\n  setActiveEdgePollingEnabled(enabled: boolean): void {\n    const client = this._edgeClient;\n    invariant(client);\n    this._activeEdgePollingEnabled = enabled;\n    if (this.isOpen) {\n      if (enabled && !this._activeEdgePollingIntervalHandle) {\n        this._startPeriodicEdgePolling(client);\n      } else if (!enabled && this._activeEdgePollingIntervalHandle) {\n        this._stopPeriodicEdgePolling();\n      }\n    }\n  }\n\n  get hasWriter() {\n    return !!this._writer;\n  }\n\n  protected override async _open(): Promise<void> {\n    if (this._edgeClient) {\n      if (this._activeEdgePollingEnabled) {\n        this._startPeriodicEdgePolling(this._edgeClient);\n      }\n      if (this._writer) {\n        this._notarizePendingEdgeCredentials(this._edgeClient, this._writer);\n      }\n    }\n  }\n\n  protected override async _close(): Promise<void> {\n    this._stopPeriodicEdgePolling();\n    await this._ctx.dispose();\n  }\n\n  /**\n   * Request credentials to be notarized.\n   */\n  async notarize({\n    ctx: opCtx,\n    credentials,\n    timeout = DEFAULT_NOTARIZE_TIMEOUT,\n    retryTimeout = DEFAULT_RETRY_TIMEOUT,\n    successDelay = DEFAULT_SUCCESS_DELAY,\n    edgeRetryJitter,\n  }: NotarizeParams): Promise<void> {\n    log('notarize', { credentials });\n    invariant(\n      credentials.every((credential) => credential.id),\n      'Credentials must have an id',\n    );\n\n    const errors = new Trigger();\n    const ctx = this._ctx.derive({\n      onError: (err) => {\n        log.warn('Notarization error', { err });\n        void ctx.dispose();\n        errors.throw(err);\n      },\n    });\n    opCtx?.onDispose(() => ctx.dispose());\n\n    if (timeout !== 0) {\n      this._scheduleTimeout(ctx, errors, timeout);\n    }\n\n    const allNotarized = Promise.all(credentials.map((credential) => this._waitUntilProcessed(credential.id!)));\n\n    this._tryNotarizeCredentialsWithPeers(ctx, credentials, { retryTimeout, successDelay });\n\n    if (this._edgeClient) {\n      this._tryNotarizeCredentialsWithEdge(ctx, this._edgeClient, credentials, {\n        retryTimeout,\n        successDelay,\n        jitter: edgeRetryJitter,\n      });\n    }\n\n    try {\n      await Promise.race([rejectOnDispose(ctx), allNotarized, errors.wait()]);\n      log('done');\n    } finally {\n      await ctx.dispose();\n    }\n  }\n\n  private _tryNotarizeCredentialsWithPeers(\n    ctx: Context,\n    credentials: Credential[],\n    { retryTimeout, successDelay }: NotarizationTimeouts,\n  ): void {\n    const peersTried = new Set<NotarizationTeleportExtension>();\n\n    // Repeatable task that tries to notarize credentials with one of the available peers.\n    const notarizeTask = new DeferredTask(ctx, async () => {\n      try {\n        if (this._extensions.size === 0) {\n          return; // No peers to try.\n        }\n\n        // Pick a peer that we haven't tried yet.\n        const peer = [...this._extensions].find((peer) => !peersTried.has(peer));\n        if (!peer) {\n          log.info('Exhausted all peers to notarize with', { retryIn: retryTimeout });\n          peersTried.clear();\n          scheduleTask(ctx, () => notarizeTask.schedule(), retryTimeout); // retry with all peers again\n          return;\n        }\n\n        peersTried.add(peer);\n        log('try notarizing', { peer: peer.localPeerId, credentialId: credentials.map((credential) => credential.id) });\n        await peer.rpc.NotarizationService.notarize({\n          credentials: credentials.filter((credential) => !this._processedCredentials.has(credential.id!)),\n        });\n        log('success');\n\n        await sleep(successDelay); // wait before trying with a new peer\n      } catch (err: any) {\n        if (!ctx.disposed && !err.message.includes(WRITER_NOT_SET_ERROR_CODE)) {\n          log.info('error notarizing (recoverable)', err);\n        }\n        notarizeTask.schedule(); // retry immediately with next peer\n      }\n    });\n\n    notarizeTask.schedule();\n    this._extensionOpened.on(ctx, () => notarizeTask.schedule());\n  }\n\n  private _tryNotarizeCredentialsWithEdge(\n    ctx: Context,\n    client: EdgeHttpClient,\n    credentials: Credential[],\n    timeouts: NotarizationTimeouts & { jitter?: number },\n  ): void {\n    const encodedCredentials = credentials.map((credential) => {\n      const binary = credentialCodec.encode(credential);\n      return Buffer.from(binary).toString('base64');\n    });\n    scheduleTask(ctx, async () => {\n      try {\n        await client.notarizeCredentials(\n          this._spaceId,\n          { credentials: encodedCredentials },\n          { retry: { count: MAX_EDGE_RETRIES, timeout: timeouts.retryTimeout, jitter: timeouts.jitter } },\n        );\n\n        log('edge notarization success');\n      } catch (error: any) {\n        handleEdgeError(error);\n      }\n    });\n  }\n\n  /**\n   * Called with credentials arriving from the control pipeline.\n   */\n  async processCredential(credential: Credential): Promise<void> {\n    if (!credential.id) {\n      return;\n    }\n    this._processCredentialsTriggers.get(credential.id)?.wake();\n    this._processedCredentials.add(credential.id);\n    this._processCredentialsTriggers.delete(credential.id);\n  }\n\n  setWriter(writer: FeedWriter<Credential>): void {\n    invariant(!this._writer, 'Writer already set.');\n    this._writer = writer;\n    if (this._edgeClient && this.isOpen) {\n      this._notarizePendingEdgeCredentials(this._edgeClient, writer);\n    }\n  }\n\n  private _startPeriodicEdgePolling(client: EdgeHttpClient): void {\n    this._activeEdgePollingIntervalHandle = setInterval(() => {\n      if (this._writer) {\n        this._notarizePendingEdgeCredentials(client, this._writer);\n      }\n    }, this._activeEdgePollingInterval);\n  }\n\n  private _stopPeriodicEdgePolling(): void {\n    if (this._activeEdgePollingIntervalHandle) {\n      clearInterval(this._activeEdgePollingIntervalHandle);\n      this._activeEdgePollingIntervalHandle = undefined;\n    }\n  }\n\n  /**\n   * The method is used only for adding agent feeds to spaces.\n   * When an agent is created we can admit them into all the existing spaces. In case the operation fails\n   * this method will fix it on the next space open.\n   * Given how rarely this happens there's no need to poll the endpoint.\n   */\n  private _notarizePendingEdgeCredentials(client: EdgeHttpClient, writer: FeedWriter<Credential>): void {\n    scheduleMicroTask(this._ctx, async () => {\n      try {\n        const response = await client.getCredentialsForNotarization(this._spaceId, {\n          retry: { count: MAX_EDGE_RETRIES },\n        });\n\n        const credentials = response.awaitingNotarization.credentials;\n        if (!credentials.length) {\n          log('edge did not return credentials for notarization');\n          return;\n        }\n\n        log('got edge credentials for notarization', { count: credentials.length });\n\n        const decodedCredentials = credentials.map((credential) => {\n          const binary = Buffer.from(credential, 'base64');\n          return credentialCodec.decode(binary);\n        });\n\n        await this._notarizeCredentials(writer, decodedCredentials);\n\n        log.info('notarized edge credentials', { count: decodedCredentials.length });\n      } catch (error: any) {\n        handleEdgeError(error);\n      }\n    });\n  }\n\n  private async _waitUntilProcessed(id: PublicKey): Promise<void> {\n    if (this._processedCredentials.has(id)) {\n      return;\n    }\n    await entry(this._processCredentialsTriggers, id).orInsert(new Trigger()).value.wait();\n  }\n\n  /**\n   * Requests from other peers to notarize credentials.\n   */\n  private async _onNotarize(request: NotarizeRequest): Promise<void> {\n    if (!this._writer) {\n      throw new Error(WRITER_NOT_SET_ERROR_CODE);\n    }\n    await this._notarizeCredentials(this._writer, request.credentials ?? []);\n  }\n\n  private async _notarizeCredentials(writer: FeedWriter<Credential>, credentials: Credential[]): Promise<void> {\n    for (const credential of credentials) {\n      invariant(credential.id, 'Credential must have an id');\n      if (this._processedCredentials.has(credential.id)) {\n        continue;\n      }\n      const verificationResult = await verifyCredential(credential);\n      if (verificationResult.kind === 'fail') {\n        throw new Error(`Credential verification failed: ${verificationResult.errors.join('\\n')}.`);\n      }\n      await writer.write(credential);\n    }\n  }\n\n  createExtension(): NotarizationTeleportExtension {\n    const extension = new NotarizationTeleportExtension({\n      onOpen: async () => {\n        log('extension opened', { peer: extension.localPeerId });\n        this._extensions.add(extension);\n        this._extensionOpened.emit();\n      },\n      onClose: async () => {\n        log('extension closed', { peer: extension.localPeerId });\n        this._extensions.delete(extension);\n      },\n      onNotarize: this._onNotarize.bind(this),\n    });\n    return extension;\n  }\n\n  private _scheduleTimeout(ctx: Context, errors: Trigger, timeout: number): void {\n    scheduleTask(\n      ctx,\n      () => {\n        log.warn('Notarization timeout', {\n          timeout,\n          peers: Array.from(this._extensions).map((extension) => extension.remotePeerId),\n        });\n        void ctx.dispose();\n        errors.throw(new TimeoutError(timeout, 'Notarization timed out'));\n      },\n      timeout,\n    );\n  }\n}\n\nconst handleEdgeError = (error: any) => {\n  if (!(error instanceof EdgeCallFailedError) || error.errorData) {\n    log.catch(error);\n  } else {\n    log.info('Edge notarization failure', { reason: error.reason });\n  }\n};\n\nexport type NotarizationTeleportExtensionParams = {\n  onOpen: () => Promise<void>;\n  onClose: () => Promise<void>;\n  onNotarize: (request: NotarizeRequest) => Promise<void>;\n};\n\nexport class NotarizationTeleportExtension extends RpcExtension<Services, Services> {\n  constructor(private readonly _params: NotarizationTeleportExtensionParams) {\n    super({\n      requested: {\n        NotarizationService: schema.getService('dxos.mesh.teleport.notarization.NotarizationService'),\n      },\n      exposed: {\n        NotarizationService: schema.getService('dxos.mesh.teleport.notarization.NotarizationService'),\n      },\n    });\n  }\n\n  protected async getHandlers(): Promise<Services> {\n    return {\n      NotarizationService: {\n        notarize: async (request) => {\n          await this._params.onNotarize(request);\n        },\n      },\n    };\n  }\n\n  override async onOpen(ctx: ExtensionContext): Promise<void> {\n    await super.onOpen(ctx);\n    await this._params.onOpen();\n  }\n\n  override async onClose(err?: Error | undefined): Promise<void> {\n    await this._params.onClose();\n    await super.onClose(err);\n  }\n}\n\ntype NotarizationTimeouts = {\n  retryTimeout: number;\n  successDelay: number;\n};\n\ntype Services = {\n  NotarizationService: NotarizationService;\n};\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { Event } from '@dxos/async';\nimport { AUTH_TIMEOUT, LOAD_CONTROL_FEEDS_TIMEOUT } from '@dxos/client-protocol';\nimport { type Context } from '@dxos/context';\nimport {\n  DeviceStateMachine,\n  type CredentialSigner,\n  createCredentialSignerWithKey,\n  createCredentialSignerWithChain,\n  ProfileStateMachine,\n} from '@dxos/credentials';\nimport { type Signer } from '@dxos/crypto';\nimport { type Space } from '@dxos/echo-pipeline';\nimport { type EdgeConnection } from '@dxos/edge-client';\nimport { writeMessages, type FeedWrapper } from '@dxos/feed-store';\nimport { invariant } from '@dxos/invariant';\nimport { type IdentityDid, PublicKey, type SpaceId } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { type Runtime } from '@dxos/protocols/proto/dxos/config';\nimport { type FeedMessage } from '@dxos/protocols/proto/dxos/echo/feed';\nimport {\n  AdmittedFeed,\n  type DeviceProfileDocument,\n  type ProfileDocument,\n  type Credential,\n} from '@dxos/protocols/proto/dxos/halo/credentials';\nimport { type DeviceAdmissionRequest } from '@dxos/protocols/proto/dxos/halo/invitations';\nimport { type Presence } from '@dxos/teleport-extension-gossip';\nimport { Timeframe } from '@dxos/timeframe';\nimport { trace } from '@dxos/tracing';\nimport { type ComplexMap, ComplexSet } from '@dxos/util';\n\nimport { TrustedKeySetAuthVerifier } from './authenticator';\nimport { DefaultSpaceStateMachine } from './default-space-state-machine';\nimport { EdgeFeedReplicator } from '../spaces';\n\nexport type IdentityParams = {\n  did: IdentityDid;\n  identityKey: PublicKey;\n  deviceKey: PublicKey;\n  signer: Signer;\n  space: Space;\n  presence?: Presence;\n\n  edgeConnection?: EdgeConnection;\n  edgeFeatures?: Runtime.Client.EdgeFeatures;\n};\n\n/**\n * Agent identity manager, which includes the agent's Halo space.\n */\n@trace.resource()\nexport class Identity {\n  public readonly space: Space;\n  private readonly _signer: Signer;\n  private readonly _presence?: Presence;\n  private readonly _deviceStateMachine: DeviceStateMachine;\n  private readonly _profileStateMachine: ProfileStateMachine;\n  private readonly _defaultSpaceStateMachine: DefaultSpaceStateMachine;\n  private readonly _edgeFeedReplicator?: EdgeFeedReplicator = undefined;\n\n  public readonly authVerifier: TrustedKeySetAuthVerifier;\n\n  public readonly did: IdentityDid;\n  public readonly identityKey: PublicKey;\n  public readonly deviceKey: PublicKey;\n\n  public readonly stateUpdate = new Event();\n\n  constructor(params: IdentityParams) {\n    this.space = params.space;\n    this._signer = params.signer;\n    this._presence = params.presence;\n\n    this.did = params.did;\n    this.identityKey = params.identityKey;\n    this.deviceKey = params.deviceKey;\n\n    log.trace('dxos.halo.device', { deviceKey: params.deviceKey });\n\n    this._deviceStateMachine = new DeviceStateMachine({\n      identityKey: this.identityKey,\n      deviceKey: this.deviceKey,\n      onUpdate: () => this.stateUpdate.emit(),\n    });\n    this._profileStateMachine = new ProfileStateMachine({\n      identityKey: this.identityKey,\n      onUpdate: () => this.stateUpdate.emit(),\n    });\n    this._defaultSpaceStateMachine = new DefaultSpaceStateMachine({\n      identityKey: this.identityKey,\n      onUpdate: () => this.stateUpdate.emit(),\n    });\n\n    this.authVerifier = new TrustedKeySetAuthVerifier({\n      trustedKeysProvider: () => new ComplexSet(PublicKey.hash, this.authorizedDeviceKeys.keys()),\n      update: this.stateUpdate,\n      authTimeout: AUTH_TIMEOUT,\n    });\n\n    if (params.edgeConnection && params.edgeFeatures?.feedReplicator) {\n      this._edgeFeedReplicator = new EdgeFeedReplicator({ messenger: params.edgeConnection, spaceId: this.space.id });\n    }\n  }\n\n  // TODO(burdon): Expose state object?\n  get authorizedDeviceKeys(): ComplexMap<PublicKey, DeviceProfileDocument> {\n    return this._deviceStateMachine.authorizedDeviceKeys;\n  }\n\n  get defaultSpaceId(): SpaceId | undefined {\n    return this._defaultSpaceStateMachine.spaceId;\n  }\n\n  @trace.span()\n  async open(ctx: Context): Promise<void> {\n    await this._presence?.open();\n    await this.space.spaceState.addCredentialProcessor(this._deviceStateMachine);\n    await this.space.spaceState.addCredentialProcessor(this._profileStateMachine);\n    await this.space.spaceState.addCredentialProcessor(this._defaultSpaceStateMachine);\n    if (this._edgeFeedReplicator) {\n      this.space.protocol.feedAdded.append(this._onFeedAdded);\n    }\n    await this.space.open(ctx);\n  }\n\n  public async joinNetwork(): Promise<void> {\n    await this.space.startProtocol();\n    await this._edgeFeedReplicator?.open();\n  }\n\n  @trace.span()\n  async close(ctx: Context): Promise<void> {\n    await this._presence?.close();\n    await this.authVerifier.close();\n    await this.space.spaceState.removeCredentialProcessor(this._defaultSpaceStateMachine);\n    await this.space.spaceState.removeCredentialProcessor(this._profileStateMachine);\n    await this.space.spaceState.removeCredentialProcessor(this._deviceStateMachine);\n\n    if (this._edgeFeedReplicator) {\n      this.space.protocol.feedAdded.remove(this._onFeedAdded);\n    }\n\n    await this._edgeFeedReplicator?.close();\n\n    await this.space.close();\n  }\n\n  async ready(): Promise<void> {\n    await this._deviceStateMachine.deviceChainReady.wait();\n\n    await this.controlPipeline.state.waitUntilReachedTargetTimeframe({ timeout: LOAD_CONTROL_FEEDS_TIMEOUT });\n  }\n\n  get profileDocument(): ProfileDocument | undefined {\n    return this._profileStateMachine.profile;\n  }\n\n  /**\n   * @test-only\n   */\n  get controlPipeline() {\n    return this.space.controlPipeline;\n  }\n\n  get haloSpaceId() {\n    return this.space.id;\n  }\n\n  get haloSpaceKey() {\n    return this.space.key;\n  }\n\n  get haloGenesisFeedKey() {\n    return this.space.genesisFeedKey;\n  }\n\n  get deviceCredentialChain() {\n    return this._deviceStateMachine.deviceCredentialChain;\n  }\n\n  get presence() {\n    return this._presence;\n  }\n\n  get signer() {\n    return this._signer;\n  }\n\n  /**\n   * Issues credentials as identity.\n   * Requires identity to be ready.\n   */\n  getIdentityCredentialSigner(): CredentialSigner {\n    invariant(this._deviceStateMachine.deviceCredentialChain, 'Device credential chain is not ready.');\n    return createCredentialSignerWithChain(\n      this._signer,\n      this._deviceStateMachine.deviceCredentialChain,\n      this.deviceKey,\n    );\n  }\n\n  /**\n   * Issues credentials as device.\n   */\n  getDeviceCredentialSigner(): CredentialSigner {\n    return createCredentialSignerWithKey(this._signer, this.deviceKey);\n  }\n\n  async updateDefaultSpace(spaceId: SpaceId): Promise<void> {\n    const credential = await this.getDeviceCredentialSigner().createCredential({\n      subject: this.identityKey,\n      assertion: { '@type': 'dxos.halo.credentials.DefaultSpace', spaceId },\n    });\n    const receipt = await this.controlPipeline.writer.write({ credential: { credential } });\n    await this.controlPipeline.state.waitUntilTimeframe(new Timeframe([[receipt.feedKey, receipt.seq]]));\n  }\n\n  async admitDevice({ deviceKey, controlFeedKey, dataFeedKey }: DeviceAdmissionRequest): Promise<Credential> {\n    log('Admitting device:', {\n      identityKey: this.identityKey,\n      hostDevice: this.deviceKey,\n      deviceKey,\n      controlFeedKey,\n      dataFeedKey,\n    });\n    const signer = this.getIdentityCredentialSigner();\n    const deviceCredential = await signer.createCredential({\n      subject: deviceKey,\n      assertion: {\n        '@type': 'dxos.halo.credentials.AuthorizedDevice',\n        identityKey: this.identityKey,\n        deviceKey,\n      },\n    });\n    await writeMessages(\n      this.controlPipeline.writer,\n      [\n        deviceCredential,\n        await signer.createCredential({\n          subject: controlFeedKey,\n          assertion: {\n            '@type': 'dxos.halo.credentials.AdmittedFeed',\n            spaceKey: this.haloSpaceKey,\n            deviceKey,\n            identityKey: this.identityKey,\n            designation: AdmittedFeed.Designation.CONTROL,\n          },\n        }),\n        await signer.createCredential({\n          subject: dataFeedKey,\n          assertion: {\n            '@type': 'dxos.halo.credentials.AdmittedFeed',\n            spaceKey: this.haloSpaceKey,\n            deviceKey,\n            identityKey: this.identityKey,\n            designation: AdmittedFeed.Designation.DATA,\n          },\n        }),\n      ].map((credential): FeedMessage.Payload => ({ credential: { credential } })),\n    );\n\n    return deviceCredential;\n  }\n\n  private _onFeedAdded = async (feed: FeedWrapper<any>) => {\n    await this._edgeFeedReplicator!.addFeed(feed);\n  };\n}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { type CredentialProcessor, getCredentialAssertion } from '@dxos/credentials';\nimport { SpaceId, type PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { type Credential } from '@dxos/protocols/proto/dxos/halo/credentials';\n\ntype DefaultSpaceStateMachineParams = {\n  identityKey: PublicKey;\n  onUpdate?: () => void;\n};\n\n/**\n * Processes device invitation credentials.\n */\nexport class DefaultSpaceStateMachine implements CredentialProcessor {\n  private _spaceId: SpaceId | undefined;\n\n  constructor(private readonly _params: DefaultSpaceStateMachineParams) {}\n\n  public get spaceId(): SpaceId | undefined {\n    return this._spaceId;\n  }\n\n  async processCredential(credential: Credential): Promise<void> {\n    const assertion = getCredentialAssertion(credential);\n    switch (assertion['@type']) {\n      case 'dxos.halo.credentials.DefaultSpace': {\n        if (!credential.subject.id.equals(this._params.identityKey)) {\n          log.warn('Invalid default space credential', { expectedIdentity: this._params.identityKey, credential });\n          return;\n        }\n        if (!SpaceId.isValid(assertion.spaceId)) {\n          log.warn('Invalid default space id', { id: assertion.spaceId });\n          return;\n        }\n        this._spaceId = assertion.spaceId;\n        break;\n      }\n    }\n  }\n}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { type Doc } from '@automerge/automerge';\nimport { interpretAsDocumentId, type AutomergeUrl, type DocHandle, type DocumentId } from '@automerge/automerge-repo';\n\nimport { Event, synchronized, trackLeaks } from '@dxos/async';\nimport { PropertiesType, TYPE_PROPERTIES } from '@dxos/client-protocol';\nimport { Context, LifecycleState, Resource, cancelWithContext } from '@dxos/context';\nimport {\n  createAdmissionCredentials,\n  getCredentialAssertion,\n  type CredentialSigner,\n  type DelegateInvitationCredential,\n  type MemberInfo,\n} from '@dxos/credentials';\nimport {\n  DatabaseRoot,\n  findInlineObjectOfType,\n  type EchoEdgeReplicator,\n  type EchoHost,\n  AuthStatus,\n  CredentialServerExtension,\n  type MeshEchoReplicator,\n  type MetadataStore,\n  type Space,\n  type SpaceManager,\n  type SpaceProtocol,\n  type SpaceProtocolSession,\n  FIND_PARAMS,\n} from '@dxos/echo-pipeline';\nimport {\n  SpaceDocVersion,\n  createIdFromSpaceKey,\n  encodeReference,\n  type ObjectStructure,\n  type DatabaseDirectory,\n} from '@dxos/echo-protocol';\nimport { ObjectId, getTypeReference } from '@dxos/echo-schema';\nimport type { EdgeConnection, EdgeHttpClient } from '@dxos/edge-client';\nimport { writeMessages, type FeedStore } from '@dxos/feed-store';\nimport { assertArgument, assertState, failedInvariant, invariant } from '@dxos/invariant';\nimport { type Keyring } from '@dxos/keyring';\nimport { PublicKey, type SpaceId } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { AlreadyJoinedError, trace as Trace } from '@dxos/protocols';\nimport { Invitation, SpaceState } from '@dxos/protocols/proto/dxos/client/services';\nimport { type Runtime } from '@dxos/protocols/proto/dxos/config';\nimport { type FeedMessage } from '@dxos/protocols/proto/dxos/echo/feed';\nimport { type SpaceMetadata, EdgeReplicationSetting } from '@dxos/protocols/proto/dxos/echo/metadata';\nimport { SpaceMember, type Credential, type ProfileDocument } from '@dxos/protocols/proto/dxos/halo/credentials';\nimport { type DelegateSpaceInvitation } from '@dxos/protocols/proto/dxos/halo/invitations';\nimport { type PeerState } from '@dxos/protocols/proto/dxos/mesh/presence';\nimport { type Teleport } from '@dxos/teleport';\nimport { Gossip, Presence } from '@dxos/teleport-extension-gossip';\nimport { type Timeframe } from '@dxos/timeframe';\nimport { trace } from '@dxos/tracing';\nimport { ComplexMap, setDeep, deferFunction, forEachAsync } from '@dxos/util';\n\nimport { DataSpace } from './data-space';\nimport { spaceGenesis } from './genesis';\nimport { createAuthProvider } from '../identity';\nimport { type InvitationsManager } from '../invitations';\n\nconst PRESENCE_ANNOUNCE_INTERVAL = 10_000;\nconst PRESENCE_OFFLINE_TIMEOUT = 20_000;\n\n// Space properties key for default metadata.\nconst DEFAULT_SPACE_KEY = '__DEFAULT__';\n\nexport interface SigningContext {\n  identityKey: PublicKey;\n  deviceKey: PublicKey;\n  credentialSigner: CredentialSigner; // TODO(burdon): Already has keyring.\n  recordCredential: (credential: Credential) => Promise<void>;\n  // TODO(dmaretskyi): Should be a getter.\n  getProfile: () => ProfileDocument | undefined;\n}\n\nexport type AcceptSpaceOptions = {\n  spaceKey: PublicKey;\n  genesisFeedKey: PublicKey;\n\n  /**\n   * Latest known timeframe for the control pipeline.\n   * We will try to catch up to this timeframe before starting the data pipeline.\n   */\n  controlTimeframe?: Timeframe;\n\n  /**\n   * Latest known timeframe for the data pipeline.\n   * We will try to catch up to this timeframe before initializing the database.\n   */\n  dataTimeframe?: Timeframe;\n};\n\nexport type AdmitMemberOptions = {\n  spaceKey: PublicKey;\n  identityKey: PublicKey;\n  role: SpaceMember.Role;\n  profile?: ProfileDocument;\n  delegationCredentialId?: PublicKey;\n};\n\nexport type DataSpaceManagerParams = {\n  spaceManager: SpaceManager;\n  metadataStore: MetadataStore;\n  keyring: Keyring;\n  signingContext: SigningContext;\n  feedStore: FeedStore<FeedMessage>;\n  echoHost: EchoHost;\n  invitationsManager: InvitationsManager;\n  edgeConnection?: EdgeConnection;\n  edgeHttpClient?: EdgeHttpClient;\n  meshReplicator?: MeshEchoReplicator;\n  echoEdgeReplicator?: EchoEdgeReplicator;\n  runtimeParams?: DataSpaceManagerRuntimeParams;\n  edgeFeatures?: Runtime.Client.EdgeFeatures;\n};\n\nexport type DataSpaceManagerRuntimeParams = {\n  spaceMemberPresenceAnnounceInterval?: number;\n  spaceMemberPresenceOfflineTimeout?: number;\n  activeEdgeNotarizationPollingInterval?: number;\n  disableP2pReplication?: boolean;\n};\n\nexport type CreateSpaceOptions = {\n  rootUrl?: AutomergeUrl;\n  documents?: Record<DocumentId, Uint8Array>;\n};\n\n@trackLeaks('open', 'close')\nexport class DataSpaceManager extends Resource {\n  public readonly updated = new Event();\n\n  private readonly _spaces = new ComplexMap<PublicKey, DataSpace>(PublicKey.hash);\n\n  private readonly _instanceId = PublicKey.random().toHex();\n\n  private readonly _spaceManager: SpaceManager;\n  private readonly _metadataStore: MetadataStore;\n  private readonly _keyring: Keyring;\n  private readonly _signingContext: SigningContext;\n  private readonly _feedStore: FeedStore<FeedMessage>;\n  private readonly _echoHost: EchoHost;\n  private readonly _invitationsManager: InvitationsManager;\n  private readonly _edgeConnection?: EdgeConnection = undefined;\n  private readonly _edgeHttpClient?: EdgeHttpClient = undefined;\n  private readonly _edgeFeatures?: Runtime.Client.EdgeFeatures = undefined;\n  private readonly _meshReplicator?: MeshEchoReplicator = undefined;\n  private readonly _echoEdgeReplicator?: EchoEdgeReplicator = undefined;\n  private readonly _runtimeParams?: DataSpaceManagerRuntimeParams = undefined;\n\n  constructor(params: DataSpaceManagerParams) {\n    super();\n\n    this._spaceManager = params.spaceManager;\n    this._metadataStore = params.metadataStore;\n    this._keyring = params.keyring;\n    this._signingContext = params.signingContext;\n    this._feedStore = params.feedStore;\n    this._echoHost = params.echoHost;\n    this._meshReplicator = params.meshReplicator;\n    this._invitationsManager = params.invitationsManager;\n    this._edgeConnection = params.edgeConnection;\n    this._edgeFeatures = params.edgeFeatures;\n    this._echoEdgeReplicator = params.echoEdgeReplicator;\n    this._edgeHttpClient = params.edgeHttpClient;\n    this._runtimeParams = params.runtimeParams;\n\n    trace.diagnostic({\n      id: 'spaces',\n      name: 'Spaces',\n      fetch: async () => {\n        return Promise.all(\n          Array.from(this._spaces.values()).map(async (space) => {\n            const rootUrl = space.automergeSpaceState.rootUrl;\n            const rootHandle = rootUrl\n              ? await this._echoHost.automergeRepo.find<Doc<DatabaseDirectory>>(rootUrl as AutomergeUrl, FIND_PARAMS)\n              : undefined;\n            await rootHandle?.whenReady();\n            const rootDoc = rootHandle?.doc();\n\n            const properties = rootDoc && findInlineObjectOfType(rootDoc, TYPE_PROPERTIES);\n\n            return {\n              key: space.key.toHex(),\n              state: SpaceState[space.state],\n              name: properties?.[1].data.name ?? null,\n              inlineObjects: rootDoc ? Object.keys(rootDoc.objects ?? {}).length : null,\n              linkedObjects: rootDoc ? Object.keys(rootDoc.links ?? {}).length : null,\n              credentials: space.inner.spaceState.credentials.length,\n              members: space.inner.spaceState.members.size,\n              rootUrl,\n            };\n          }),\n        );\n      },\n    });\n  }\n\n  // TODO(burdon): Remove.\n  get spaces() {\n    return this._spaces;\n  }\n\n  getSpaceById(spaceId: SpaceId): DataSpace | undefined {\n    return [...this._spaces.values()].find((space) => space.id === spaceId);\n  }\n\n  @synchronized\n  protected override async _open(): Promise<void> {\n    log('open');\n    log.trace('dxos.echo.data-space-manager.open', Trace.begin({ id: this._instanceId }));\n    log('metadata loaded', { spaces: this._metadataStore.spaces.length });\n\n    await forEachAsync(this._metadataStore.spaces, async (spaceMetadata) => {\n      try {\n        log('load space', { spaceMetadata });\n        await this._constructSpace(spaceMetadata);\n      } catch (err) {\n        log.error('Error loading space', { spaceMetadata, err });\n      }\n    });\n\n    this.updated.emit();\n\n    log.trace('dxos.echo.data-space-manager.open', Trace.end({ id: this._instanceId }));\n  }\n\n  @synchronized\n  protected override async _close(): Promise<void> {\n    log('close');\n    for (const space of this._spaces.values()) {\n      await space.close();\n    }\n    this._spaces.clear();\n  }\n\n  /**\n   * Creates a new space writing the genesis credentials to the control feed.\n   */\n  @synchronized\n  async createSpace(options: CreateSpaceOptions = {}): Promise<DataSpace> {\n    assertArgument(!!options.rootUrl === !!options.documents, 'root url must be required when providing documents');\n\n    assertState(this._lifecycleState === LifecycleState.OPEN, 'Not open.');\n    const spaceKey = await this._keyring.createKey();\n    const controlFeedKey = await this._keyring.createKey();\n    const dataFeedKey = await this._keyring.createKey();\n\n    const spaceId = await createIdFromSpaceKey(spaceKey);\n\n    const metadata: SpaceMetadata = {\n      key: spaceKey,\n      genesisFeedKey: controlFeedKey,\n      controlFeedKey,\n      dataFeedKey,\n      state: SpaceState.SPACE_ACTIVE,\n    };\n\n    log('creating space...', { spaceId, spaceKey });\n\n    // New document IDs for the space.\n    const documentIdMapping: Record<DocumentId, DocumentId> = {};\n    if (options.documents) {\n      invariant(\n        Object.keys(options.documents).every((documentId) => /^[a-zA-Z0-9]+$/.test(documentId)),\n        'Invalid document IDs',\n      );\n\n      await Promise.all(\n        Object.entries(options.documents).map(async ([documentId, data]) => {\n          log('creating document...', { documentId });\n          const newDoc = await this._echoHost.createDoc(data, { preserveHistory: true });\n          documentIdMapping[documentId as DocumentId] = newDoc.documentId;\n        }),\n      );\n    }\n\n    log('opening space...', { spaceKey });\n\n    let root: DatabaseRoot;\n    if (options.rootUrl) {\n      const newRootDocId = documentIdMapping[interpretAsDocumentId(options.rootUrl)] ?? failedInvariant();\n      const rootDocHandle = await this._echoHost.loadDoc<DatabaseDirectory>(Context.default(), newRootDocId);\n      DatabaseRoot.mapLinks(rootDocHandle, documentIdMapping);\n\n      root = await this._echoHost.openSpaceRoot(spaceId, `automerge:${newRootDocId}` as AutomergeUrl);\n    } else {\n      root = await this._echoHost.createSpaceRoot(spaceKey);\n    }\n\n    log('constructing space...', { spaceKey });\n\n    const space = await this._constructSpace(metadata);\n    await space.open();\n\n    log('adding space...', { spaceKey });\n\n    const credentials = await spaceGenesis(this._keyring, this._signingContext, space.inner, root.url);\n    await this._metadataStore.addSpace(metadata);\n\n    const memberCredential = credentials[1];\n    invariant(getCredentialAssertion(memberCredential)['@type'] === 'dxos.halo.credentials.SpaceMember');\n    await this._signingContext.recordCredential(memberCredential);\n\n    await space.initializeDataPipeline();\n\n    log('space ready.', { spaceId, spaceKey });\n\n    this.updated.emit();\n    return space;\n  }\n\n  async isDefaultSpace(space: DataSpace): Promise<boolean> {\n    if (!space.databaseRoot) {\n      return false;\n    }\n    switch (space.databaseRoot.getVersion()) {\n      case SpaceDocVersion.CURRENT: {\n        if (!space.databaseRoot.handle.isReady()) {\n          log.warn('waiting for space root to be ready', { spaceId: space.id });\n          await space.databaseRoot.handle.whenReady();\n        }\n        const [_, properties] = findInlineObjectOfType(space.databaseRoot.doc()!, TYPE_PROPERTIES) ?? [];\n        return properties?.data?.[DEFAULT_SPACE_KEY] === this._signingContext.identityKey.toHex();\n      }\n      case SpaceDocVersion.LEGACY: {\n        throw new Error('Legacy space version is not supported');\n      }\n\n      default:\n        log.warn('unknown space version', { version: space.databaseRoot.getVersion(), spaceId: space.id });\n        return false;\n    }\n  }\n\n  async createDefaultSpace(): Promise<DataSpace> {\n    const space = await this.createSpace();\n    const document = await this._getSpaceRootDocument(space);\n\n    // TODO(dmaretskyi): Better API for low-level data access.\n    const properties: ObjectStructure = {\n      system: {\n        type: encodeReference(getTypeReference(PropertiesType)!),\n      },\n      data: {\n        [DEFAULT_SPACE_KEY]: this._signingContext.identityKey.toHex(),\n      },\n      meta: {\n        keys: [],\n      },\n    };\n\n    const propertiesId = ObjectId.random();\n    document.change((doc: DatabaseDirectory) => {\n      setDeep(doc, ['objects', propertiesId], properties);\n    });\n\n    await this._echoHost.flush();\n    return space;\n  }\n\n  private async _getSpaceRootDocument(space: DataSpace): Promise<DocHandle<DatabaseDirectory>> {\n    const automergeIndex = space.automergeSpaceState.rootUrl;\n    invariant(automergeIndex);\n    const document = await this._echoHost.automergeRepo.find<DatabaseDirectory>(automergeIndex as any, FIND_PARAMS);\n    await document.whenReady();\n    return document;\n  }\n\n  // TODO(burdon): Rename join space.\n  @synchronized\n  async acceptSpace(opts: AcceptSpaceOptions): Promise<DataSpace> {\n    log('accept space', { opts });\n    invariant(this._lifecycleState === LifecycleState.OPEN, 'Not open.');\n    invariant(!this._spaces.has(opts.spaceKey), 'Space already exists.');\n\n    const metadata: SpaceMetadata = {\n      key: opts.spaceKey,\n      genesisFeedKey: opts.genesisFeedKey,\n      controlTimeframe: opts.controlTimeframe,\n      dataTimeframe: opts.dataTimeframe,\n    };\n\n    const space = await this._constructSpace(metadata);\n    await space.open();\n    await this._metadataStore.addSpace(metadata);\n    space.initializeDataPipelineAsync();\n\n    this.updated.emit();\n    return space;\n  }\n\n  async admitMember(options: AdmitMemberOptions): Promise<Credential> {\n    const space = this._spaceManager.spaces.get(options.spaceKey);\n    invariant(space);\n\n    if (space.spaceState.getMemberRole(options.identityKey) !== SpaceMember.Role.REMOVED) {\n      throw new AlreadyJoinedError();\n    }\n\n    // TODO(burdon): Check if already admitted.\n    const credentials: FeedMessage.Payload[] = await createAdmissionCredentials(\n      this._signingContext.credentialSigner,\n      options.identityKey,\n      space.key,\n      space.genesisFeedKey,\n      options.role,\n      space.spaceState.membershipChainHeads,\n      options.profile,\n      options.delegationCredentialId,\n    );\n\n    // TODO(dmaretskyi): Refactor.\n    invariant(credentials[0].credential);\n    const spaceMemberCredential = credentials[0].credential.credential;\n    invariant(getCredentialAssertion(spaceMemberCredential)['@type'] === 'dxos.halo.credentials.SpaceMember');\n    await writeMessages(space.controlPipeline.writer, credentials);\n\n    return spaceMemberCredential;\n  }\n\n  /**\n   * Wait until the space data pipeline is fully initialized.\n   * Used by invitation handler.\n   * TODO(dmaretskyi): Consider removing.\n   */\n  async waitUntilSpaceReady(spaceKey: PublicKey): Promise<void> {\n    await cancelWithContext(\n      this._ctx,\n      this.updated.waitForCondition(() => {\n        const space = this._spaces.get(spaceKey);\n        return !!space && space.state === SpaceState.SPACE_READY;\n      }),\n    );\n  }\n\n  public async requestSpaceAdmissionCredential(spaceKey: PublicKey): Promise<Credential> {\n    return this._spaceManager.requestSpaceAdmissionCredential({\n      spaceKey,\n      identityKey: this._signingContext.identityKey,\n      timeout: 15_000,\n      swarmIdentity: {\n        identityKey: this._signingContext.identityKey,\n        peerKey: this._signingContext.deviceKey,\n        credentialProvider: createAuthProvider(this._signingContext.credentialSigner),\n        credentialAuthenticator: async () => true,\n      },\n    });\n  }\n\n  async setSpaceEdgeReplicationSetting(spaceKey: PublicKey, setting: EdgeReplicationSetting): Promise<void> {\n    const space = this._spaces.get(spaceKey);\n    invariant(space, 'Space not found.');\n\n    await this._metadataStore.setSpaceEdgeReplicationSetting(spaceKey, setting);\n\n    if (space.isOpen) {\n      switch (setting) {\n        case EdgeReplicationSetting.DISABLED:\n          await this._echoEdgeReplicator?.disconnectFromSpace(space.id);\n          break;\n        case EdgeReplicationSetting.ENABLED:\n          await this._echoEdgeReplicator?.connectToSpace(space.id);\n          break;\n      }\n    }\n\n    space.stateUpdate.emit();\n  }\n\n  private async _constructSpace(metadata: SpaceMetadata): Promise<DataSpace> {\n    log('construct space', { metadata });\n    const gossip = new Gossip({\n      localPeerId: this._signingContext.deviceKey,\n    });\n    const presence = new Presence({\n      announceInterval: this._runtimeParams?.spaceMemberPresenceAnnounceInterval ?? PRESENCE_ANNOUNCE_INTERVAL,\n      offlineTimeout: this._runtimeParams?.spaceMemberPresenceOfflineTimeout ?? PRESENCE_OFFLINE_TIMEOUT,\n      identityKey: this._signingContext.identityKey,\n      gossip,\n    });\n\n    const controlFeed =\n      metadata.controlFeedKey && (await this._feedStore.openFeed(metadata.controlFeedKey, { writable: true }));\n    const dataFeed =\n      metadata.dataFeedKey &&\n      (await this._feedStore.openFeed(metadata.dataFeedKey, {\n        writable: true,\n        sparse: true,\n      }));\n\n    const space: Space = await this._spaceManager.constructSpace({\n      metadata,\n      swarmIdentity: {\n        identityKey: this._signingContext.identityKey,\n        peerKey: this._signingContext.deviceKey,\n        credentialProvider: createAuthProvider(this._signingContext.credentialSigner),\n        credentialAuthenticator: deferFunction(() => dataSpace.authVerifier.verifier),\n      },\n      onAuthorizedConnection: (session) =>\n        queueMicrotask(async () => {\n          try {\n            if (!session.isOpen) {\n              return;\n            }\n            session.addExtension('dxos.mesh.teleport.admission-discovery', new CredentialServerExtension(space));\n            session.addExtension(\n              'dxos.mesh.teleport.gossip',\n              gossip.createExtension({ remotePeerId: session.remotePeerId }),\n            );\n            session.addExtension('dxos.mesh.teleport.notarization', dataSpace.notarizationPlugin.createExtension());\n            await this._connectEchoMeshReplicator(space, session);\n          } catch (err: any) {\n            log.warn('error on authorized connection', { err });\n            await session.close(err);\n          }\n        }),\n      onAuthFailure: () => {\n        log.warn('auth failure');\n      },\n      onMemberRolesChanged: async (members: MemberInfo[]) => {\n        if (dataSpace?.state === SpaceState.SPACE_READY) {\n          this._handleMemberRoleChanges(presence, space.protocol, members);\n        }\n      },\n      memberKey: this._signingContext.identityKey,\n      onDelegatedInvitationStatusChange: (invitation, isActive) => {\n        return this._handleInvitationStatusChange(dataSpace, invitation, isActive);\n      },\n    });\n    controlFeed && (await space.setControlFeed(controlFeed));\n    dataFeed && (await space.setDataFeed(dataFeed));\n\n    const dataSpace = new DataSpace({\n      inner: space,\n      initialState: metadata.state === SpaceState.SPACE_INACTIVE ? SpaceState.SPACE_INACTIVE : SpaceState.SPACE_CLOSED,\n      metadataStore: this._metadataStore,\n      gossip,\n      presence,\n      keyring: this._keyring,\n      feedStore: this._feedStore,\n      echoHost: this._echoHost,\n      signingContext: this._signingContext,\n      callbacks: {\n        beforeReady: async () => {\n          log('before space ready', { space: space.key });\n        },\n        afterReady: async () => {\n          log('after space ready', { space: space.key, open: this._lifecycleState === LifecycleState.OPEN });\n          if (this._lifecycleState === LifecycleState.OPEN) {\n            await this._createDelegatedInvitations(dataSpace, [...space.spaceState.invitations.entries()]);\n            this._handleMemberRoleChanges(presence, space.protocol, [...space.spaceState.members.values()]);\n            this.updated.emit();\n          }\n        },\n        beforeClose: async () => {\n          log('before space close', { space: space.key });\n        },\n      },\n      cache: metadata.cache,\n      edgeConnection: this._edgeConnection,\n      edgeHttpClient: this._edgeHttpClient,\n      edgeFeatures: this._edgeFeatures,\n      activeEdgeNotarizationPollingInterval: this._runtimeParams?.activeEdgeNotarizationPollingInterval,\n    });\n    dataSpace.postOpen.append(async () => {\n      const setting = dataSpace.getEdgeReplicationSetting();\n      if (!setting || setting === EdgeReplicationSetting.ENABLED) {\n        await this._echoEdgeReplicator?.connectToSpace(dataSpace.id);\n      } else if (this._echoEdgeReplicator) {\n        log('not connecting EchoEdgeReplicator because of EdgeReplicationSetting', { spaceId: dataSpace.id });\n      }\n    });\n    dataSpace.preClose.append(async () => {\n      const setting = dataSpace.getEdgeReplicationSetting();\n      if (!setting || setting === EdgeReplicationSetting.ENABLED) {\n        await this._echoEdgeReplicator?.disconnectFromSpace(dataSpace.id);\n      }\n    });\n\n    presence.newPeer.on((peerState) => {\n      if (dataSpace.state === SpaceState.SPACE_READY) {\n        this._handleNewPeerConnected(space, peerState);\n      }\n    });\n\n    if (metadata.controlTimeframe) {\n      dataSpace.inner.controlPipeline.state.setTargetTimeframe(metadata.controlTimeframe);\n    }\n\n    this._spaces.set(metadata.key, dataSpace);\n    return dataSpace;\n  }\n\n  private async _connectEchoMeshReplicator(space: Space, session: Teleport): Promise<void> {\n    const replicator = this._meshReplicator;\n    if (!replicator) {\n      log.warn('p2p automerge replication disabled', { space: space.key });\n      return;\n    }\n    await replicator.authorizeDevice(space.key, session.remotePeerId);\n    // session ended during device authorization\n    if (session.isOpen) {\n      session.addExtension('dxos.mesh.teleport.automerge', replicator.createExtension());\n    }\n  }\n\n  private _handleMemberRoleChanges(presence: Presence, spaceProtocol: SpaceProtocol, memberInfo: MemberInfo[]): void {\n    let closedSessions = 0;\n    for (const member of memberInfo) {\n      if (member.key.equals(presence.getLocalState().identityKey)) {\n        continue;\n      }\n      const peers = presence.getPeersByIdentityKey(member.key);\n      const sessions = peers.map((p) => p.peerId && spaceProtocol.sessions.get(p.peerId));\n      const sessionsToClose = sessions.filter((s): s is SpaceProtocolSession => {\n        return (s && (member.role === SpaceMember.Role.REMOVED) !== (s.authStatus === AuthStatus.FAILURE)) ?? false;\n      });\n      sessionsToClose.forEach((session) => {\n        void session.close().catch(log.error);\n      });\n      closedSessions += sessionsToClose.length;\n    }\n    log('processed member role changes', {\n      roleChangeCount: memberInfo.length,\n      peersOnline: presence.getPeersOnline().length,\n      closedSessions,\n    });\n    // Handle the case when there was a removed peer online, we can now establish a connection with them\n    spaceProtocol.updateTopology();\n  }\n\n  private _handleNewPeerConnected(space: Space, peerState: PeerState): void {\n    const role = space.spaceState.getMemberRole(peerState.identityKey);\n    if (role === SpaceMember.Role.REMOVED) {\n      const session = peerState.peerId && space.protocol.sessions.get(peerState.peerId);\n      if (session != null) {\n        log('closing a session with a removed peer', { peerId: peerState.peerId });\n        void session.close().catch(log.error);\n      }\n    }\n  }\n\n  private async _handleInvitationStatusChange(\n    dataSpace: DataSpace | undefined,\n    delegatedInvitation: DelegateInvitationCredential,\n    isActive: boolean,\n  ): Promise<void> {\n    if (dataSpace?.state !== SpaceState.SPACE_READY) {\n      return;\n    }\n    if (isActive) {\n      await this._createDelegatedInvitations(dataSpace, [\n        [delegatedInvitation.credentialId, delegatedInvitation.invitation],\n      ]);\n    } else {\n      await this._invitationsManager.cancelInvitation(delegatedInvitation.invitation);\n    }\n  }\n\n  private async _createDelegatedInvitations(\n    space: DataSpace,\n    invitations: Array<[PublicKey, DelegateSpaceInvitation]>,\n  ): Promise<void> {\n    const tasks = invitations.map(([credentialId, invitation]) => {\n      return this._invitationsManager.createInvitation({\n        type: Invitation.Type.DELEGATED,\n        kind: Invitation.Kind.SPACE,\n        spaceKey: space.key,\n        authMethod: invitation.authMethod,\n        invitationId: invitation.invitationId,\n        swarmKey: invitation.swarmKey,\n        guestKeypair: invitation.guestKey ? { publicKey: invitation.guestKey } : undefined,\n        lifetime: invitation.expiresOn ? (invitation.expiresOn.getTime() - Date.now()) / 1000 : undefined,\n        multiUse: invitation.multiUse,\n        delegationCredentialId: credentialId,\n        persistent: false,\n      });\n    });\n    await Promise.all(tasks);\n  }\n}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { createCredential } from '@dxos/credentials';\nimport { failUndefined } from '@dxos/debug';\nimport { type Space } from '@dxos/echo-pipeline';\nimport { type Keyring } from '@dxos/keyring';\nimport { AdmittedFeed, SpaceMember } from '@dxos/protocols/proto/dxos/halo/credentials';\nimport { Timeframe } from '@dxos/timeframe';\n\nimport { type SigningContext } from './data-space-manager';\n\nexport const spaceGenesis = async (\n  keyring: Keyring,\n  signingContext: SigningContext,\n  space: Space,\n  automergeRoot?: string,\n) => {\n  // TODO(dmaretskyi): Find a way to reconcile with credential generator.\n  const credentials = [\n    await createCredential({\n      signer: keyring,\n      issuer: space.key,\n      subject: space.key,\n      assertion: {\n        '@type': 'dxos.halo.credentials.SpaceGenesis',\n        spaceKey: space.key,\n      },\n    }),\n\n    await createCredential({\n      signer: keyring,\n      issuer: space.key,\n      subject: signingContext.identityKey,\n      assertion: {\n        '@type': 'dxos.halo.credentials.SpaceMember',\n        spaceKey: space.key,\n        role: SpaceMember.Role.OWNER,\n        profile: signingContext.getProfile(),\n        genesisFeedKey: space.controlFeedKey ?? failUndefined(),\n      },\n    }),\n\n    await signingContext.credentialSigner.createCredential({\n      subject: space.controlFeedKey ?? failUndefined(),\n      assertion: {\n        '@type': 'dxos.halo.credentials.AdmittedFeed',\n        spaceKey: space.key,\n        identityKey: signingContext.identityKey,\n        deviceKey: signingContext.deviceKey,\n        designation: AdmittedFeed.Designation.CONTROL,\n      },\n    }),\n\n    await signingContext.credentialSigner.createCredential({\n      subject: space.dataFeedKey ?? failUndefined(),\n      assertion: {\n        '@type': 'dxos.halo.credentials.AdmittedFeed',\n        spaceKey: space.key,\n        identityKey: signingContext.identityKey,\n        deviceKey: signingContext.deviceKey,\n        designation: AdmittedFeed.Designation.DATA,\n      },\n    }),\n\n    await signingContext.credentialSigner.createCredential({\n      subject: space.key ?? failUndefined(),\n      assertion: {\n        '@type': 'dxos.halo.credentials.Epoch',\n        number: 0,\n        previousId: undefined,\n        timeframe: new Timeframe(),\n        snapshotCid: undefined,\n        automergeRoot,\n      },\n    }),\n  ];\n\n  for (const credential of credentials) {\n    await space.controlPipeline.writer.write({\n      credential: { credential },\n    });\n  }\n\n  return credentials;\n};\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport type { AutomergeUrl } from '@automerge/automerge-repo';\n\nimport { SubscriptionList, UpdateScheduler, scheduleTask } from '@dxos/async';\nimport { Stream } from '@dxos/codec-protobuf/stream';\nimport {\n  type CredentialProcessor,\n  createAdmissionCredentials,\n  createDidFromIdentityKey,\n  getCredentialAssertion,\n} from '@dxos/credentials';\nimport { raise } from '@dxos/debug';\nimport { type SpaceManager } from '@dxos/echo-pipeline';\nimport { writeMessages } from '@dxos/feed-store';\nimport { assertArgument, assertState, invariant } from '@dxos/invariant';\nimport { SpaceId } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport {\n  encodeError,\n  ApiError,\n  AuthorizationError,\n  IdentityNotInitializedError,\n  SpaceNotFoundError,\n} from '@dxos/protocols';\nimport {\n  SpaceMember,\n  SpaceState,\n  type CreateEpochRequest,\n  type PostMessageRequest,\n  type QueryCredentialsRequest,\n  type QuerySpacesResponse,\n  type Space,\n  type SpacesService,\n  type SubscribeMessagesRequest,\n  type UpdateSpaceRequest,\n  type WriteCredentialsRequest,\n  type UpdateMemberRoleRequest,\n  type AdmitContactRequest,\n  type ContactAdmission,\n  type JoinSpaceResponse,\n  type JoinBySpaceKeyRequest,\n  type CreateEpochResponse,\n  type ExportSpaceResponse,\n  type ExportSpaceRequest,\n  type ImportSpaceRequest,\n  type ImportSpaceResponse,\n} from '@dxos/protocols/proto/dxos/client/services';\nimport { type Credential } from '@dxos/protocols/proto/dxos/halo/credentials';\nimport { type GossipMessage } from '@dxos/protocols/proto/dxos/mesh/teleport/gossip';\nimport { trace } from '@dxos/tracing';\nimport { type Provider } from '@dxos/util';\n\nimport { type DataSpace } from './data-space';\nimport { type DataSpaceManager } from './data-space-manager';\nimport { type IdentityManager } from '../identity';\nimport { extractSpaceArchive, SpaceArchiveWriter } from '../space-export';\n\nexport class SpacesServiceImpl implements SpacesService {\n  constructor(\n    private readonly _identityManager: IdentityManager,\n    private readonly _spaceManager: SpaceManager,\n    private readonly _getDataSpaceManager: Provider<Promise<DataSpaceManager>>,\n  ) {}\n\n  async createSpace(): Promise<Space> {\n    this._requireIdentity();\n    const dataSpaceManager = await this._getDataSpaceManager();\n    const space = await dataSpaceManager.createSpace();\n    await this._updateMetrics();\n    return this._serializeSpace(space);\n  }\n\n  async updateSpace({ spaceKey, state, edgeReplication }: UpdateSpaceRequest): Promise<void> {\n    const dataSpaceManager = await this._getDataSpaceManager();\n    const space = dataSpaceManager.spaces.get(spaceKey) ?? raise(new SpaceNotFoundError(spaceKey));\n\n    if (state) {\n      switch (state) {\n        case SpaceState.SPACE_ACTIVE:\n          await space.activate();\n          break;\n\n        case SpaceState.SPACE_INACTIVE:\n          await space.deactivate();\n          break;\n        default:\n          throw new ApiError('Invalid space state');\n      }\n    }\n\n    if (edgeReplication !== undefined) {\n      await dataSpaceManager.setSpaceEdgeReplicationSetting(spaceKey, edgeReplication);\n    }\n  }\n\n  async updateMemberRole(request: UpdateMemberRoleRequest): Promise<void> {\n    const identity = this._requireIdentity();\n    const space = this._spaceManager.spaces.get(request.spaceKey);\n    if (space == null) {\n      throw new SpaceNotFoundError(request.spaceKey);\n    }\n    if (!space.spaceState.hasMembershipManagementPermission(identity.identityKey)) {\n      throw new AuthorizationError('No member management permission.', {\n        spaceKey: space.key,\n        role: space.spaceState.getMemberRole(identity.identityKey),\n      });\n    }\n    const credentials = await createAdmissionCredentials(\n      identity.getIdentityCredentialSigner(),\n      request.memberKey,\n      space.key,\n      space.genesisFeedKey,\n      request.newRole,\n      space.spaceState.membershipChainHeads,\n    );\n    invariant(credentials[0].credential);\n    const spaceMemberCredential = credentials[0].credential.credential;\n    invariant(getCredentialAssertion(spaceMemberCredential)['@type'] === 'dxos.halo.credentials.SpaceMember');\n    await writeMessages(space.controlPipeline.writer, credentials);\n  }\n\n  querySpaces(): Stream<QuerySpacesResponse> {\n    return new Stream<QuerySpacesResponse>(({ next, ctx }) => {\n      const scheduler = new UpdateScheduler(\n        ctx,\n        async () => {\n          const dataSpaceManager = await this._getDataSpaceManager();\n          const spaces = await Promise.all(\n            Array.from(dataSpaceManager.spaces.values()).map((space) => this._serializeSpace(space)),\n          );\n          log('update', () => ({ ids: spaces.map((space) => space.id) }));\n          await this._updateMetrics();\n          next({ spaces });\n        },\n        { maxFrequency: process.env.NODE_ENV === 'test' ? undefined : 2 },\n      );\n\n      scheduleTask(ctx, async () => {\n        const dataSpaceManager = await this._getDataSpaceManager();\n\n        const subscriptions = new SubscriptionList();\n        ctx.onDispose(() => subscriptions.clear());\n\n        // TODO(dmaretskyi): Create a pattern for subscribing to a set of objects.\n        const subscribeSpaces = () => {\n          subscriptions.clear();\n\n          for (const space of dataSpaceManager.spaces.values()) {\n            let lastState: SpaceState | undefined;\n            subscriptions.add(\n              space.stateUpdate.on(ctx, () => {\n                // Always send a separate update if the space state has changed.\n                if (space.state !== lastState) {\n                  scheduler.forceTrigger();\n                } else {\n                  scheduler.trigger();\n                }\n                lastState = space.state;\n              }),\n            );\n\n            subscriptions.add(space.presence.updated.on(ctx, () => scheduler.trigger()));\n            subscriptions.add(space.automergeSpaceState.onNewEpoch.on(ctx, () => scheduler.trigger()));\n\n            // Pipeline progress.\n            subscriptions.add(space.inner.controlPipeline.state.timeframeUpdate.on(ctx, () => scheduler.trigger()));\n          }\n        };\n\n        dataSpaceManager.updated.on(ctx, () => {\n          subscribeSpaces();\n          scheduler.trigger();\n        });\n        subscribeSpaces();\n\n        scheduler.trigger();\n      });\n\n      if (!this._identityManager.identity) {\n        next({ spaces: [] });\n      }\n    });\n  }\n\n  async postMessage({ spaceKey, channel, message }: PostMessageRequest): Promise<void> {\n    const dataSpaceManager = await this._getDataSpaceManager();\n    const space = dataSpaceManager.spaces.get(spaceKey) ?? raise(new SpaceNotFoundError(spaceKey));\n    await space.postMessage(getChannelId(channel), message);\n  }\n\n  subscribeMessages({ spaceKey, channel }: SubscribeMessagesRequest): Stream<GossipMessage> {\n    return new Stream<GossipMessage>(({ ctx, next }) => {\n      scheduleTask(ctx, async () => {\n        const dataSpaceManager = await this._getDataSpaceManager();\n        const space = dataSpaceManager.spaces.get(spaceKey) ?? raise(new SpaceNotFoundError(spaceKey));\n        const handle = space.listen(getChannelId(channel), (message) => {\n          next(message);\n        });\n        ctx.onDispose(() => handle.unsubscribe());\n      });\n    });\n  }\n\n  queryCredentials({ spaceKey, noTail }: QueryCredentialsRequest): Stream<Credential> {\n    return new Stream(({ ctx, next, close }) => {\n      const space = this._spaceManager.spaces.get(spaceKey) ?? raise(new SpaceNotFoundError(spaceKey));\n\n      const processor: CredentialProcessor = {\n        processCredential: async (credential) => {\n          next(credential);\n        },\n      };\n      ctx.onDispose(() => space.spaceState.removeCredentialProcessor(processor));\n      scheduleTask(ctx, async () => {\n        await space.spaceState.addCredentialProcessor(processor);\n        if (noTail) {\n          close();\n        }\n      });\n    });\n  }\n\n  async writeCredentials({ spaceKey, credentials }: WriteCredentialsRequest): Promise<void> {\n    const space = this._spaceManager.spaces.get(spaceKey) ?? raise(new SpaceNotFoundError(spaceKey));\n    for (const credential of credentials ?? []) {\n      if (credential.proof) {\n        await space.controlPipeline.writer.write({ credential: { credential } });\n      } else {\n        invariant(!credential.id, 'Id on unsigned credentials is not allowed');\n        invariant(this._identityManager.identity, 'Identity is not available');\n        const signer = this._identityManager.identity.getIdentityCredentialSigner();\n        invariant(credential.issuer.equals(signer.getIssuer()));\n        const signedCredential = await signer.createCredential({\n          subject: credential.subject.id,\n          assertion: credential.subject.assertion,\n        });\n        await space.controlPipeline.writer.write({ credential: { credential: signedCredential } });\n      }\n    }\n  }\n\n  async createEpoch({ spaceKey, migration, automergeRootUrl }: CreateEpochRequest): Promise<CreateEpochResponse> {\n    const dataSpaceManager = await this._getDataSpaceManager();\n    const space = dataSpaceManager.spaces.get(spaceKey) ?? raise(new SpaceNotFoundError(spaceKey));\n    const result = await space.createEpoch({ migration, newAutomergeRoot: automergeRootUrl });\n    return { epochCredential: result?.credential, controlTimeframe: result?.timeframe };\n  }\n\n  async admitContact(request: AdmitContactRequest): Promise<void> {\n    const dataSpaceManager = await this._getDataSpaceManager();\n    await dataSpaceManager.admitMember({\n      spaceKey: request.spaceKey,\n      identityKey: request.contact.identityKey,\n      role: request.role,\n    });\n  }\n\n  async joinBySpaceKey({ spaceKey }: JoinBySpaceKeyRequest): Promise<JoinSpaceResponse> {\n    const dataSpaceManager = await this._getDataSpaceManager();\n    const credential = await dataSpaceManager.requestSpaceAdmissionCredential(spaceKey);\n    return this._joinByAdmission({ credential });\n  }\n\n  async exportSpace(request: ExportSpaceRequest): Promise<ExportSpaceResponse> {\n    await using writer = await new SpaceArchiveWriter().open();\n    assertArgument(SpaceId.isValid(request.spaceId), 'Invalid space ID');\n\n    const dataSpaceManager = await this._getDataSpaceManager();\n    const space = dataSpaceManager.getSpaceById(request.spaceId) ?? raise(new Error('Space not found'));\n    await writer.begin({ spaceId: space.id });\n    const rootUrl = space.automergeSpaceState.lastEpoch?.subject.assertion.automergeRoot;\n    assertState(rootUrl, 'Space does not have a root URL');\n    await writer.setCurrentRootUrl(rootUrl);\n\n    for await (const [documentId, data] of space.getAllDocuments()) {\n      await writer.writeDocument(documentId, data);\n    }\n\n    const archive = await writer.finish();\n    return { archive };\n  }\n\n  async importSpace(request: ImportSpaceRequest): Promise<ImportSpaceResponse> {\n    const dataSpaceManager = await this._getDataSpaceManager();\n    const extracted = await extractSpaceArchive(request.archive);\n    invariant(extracted.metadata.echo?.currentRootUrl, 'Space archive does not contain a root URL');\n    const space = await dataSpaceManager.createSpace({\n      documents: extracted.documents,\n      rootUrl: extracted.metadata.echo?.currentRootUrl as AutomergeUrl,\n    });\n    await this._updateMetrics();\n    return { newSpaceId: space.id };\n  }\n\n  private async _joinByAdmission({ credential }: ContactAdmission): Promise<JoinSpaceResponse> {\n    const assertion = getCredentialAssertion(credential);\n    invariant(assertion['@type'] === 'dxos.halo.credentials.SpaceMember', 'Invalid credential');\n    const myIdentity = this._identityManager.identity;\n    invariant(myIdentity && credential.subject.id.equals(myIdentity.identityKey));\n\n    const dataSpaceManager = await this._getDataSpaceManager();\n    let dataSpace = dataSpaceManager.spaces.get(assertion.spaceKey);\n    if (!dataSpace) {\n      dataSpace = await dataSpaceManager.acceptSpace({\n        spaceKey: assertion.spaceKey,\n        genesisFeedKey: assertion.genesisFeedKey,\n      });\n      await myIdentity.controlPipeline.writer.write({ credential: { credential } });\n    }\n\n    return { space: await this._serializeSpace(dataSpace) };\n  }\n\n  private async _serializeSpace(space: DataSpace): Promise<Space> {\n    return {\n      id: space.id,\n      spaceKey: space.key,\n      state: space.state,\n      error: space.error ? encodeError(space.error) : undefined,\n      pipeline: {\n        currentEpoch: space.automergeSpaceState.lastEpoch,\n        appliedEpoch: space.automergeSpaceState.lastEpoch,\n\n        controlFeeds: space.inner.controlPipeline.state.feeds.map((feed) => feed.key),\n        currentControlTimeframe: space.inner.controlPipeline.state.timeframe,\n        targetControlTimeframe: space.inner.controlPipeline.state.targetTimeframe,\n        totalControlTimeframe: space.inner.controlPipeline.state.endTimeframe,\n\n        dataFeeds: undefined,\n        startDataTimeframe: undefined,\n        currentDataTimeframe: undefined,\n        targetDataTimeframe: undefined,\n        totalDataTimeframe: undefined,\n\n        spaceRootUrl: space.databaseRoot?.url,\n      },\n      members: await Promise.all(\n        Array.from(space.inner.spaceState.members.values()).map(async (member) => {\n          const peers = space.presence.getPeersOnline().filter(({ identityKey }) => identityKey.equals(member.key));\n          const isMe = this._identityManager.identity?.identityKey.equals(member.key);\n\n          if (isMe) {\n            peers.push(space.presence.getLocalState());\n          }\n\n          return {\n            identity: {\n              did: await createDidFromIdentityKey(member.key),\n              identityKey: member.key,\n              profile: member.profile ?? {},\n            },\n            role: member.role,\n            presence: peers.length > 0 ? SpaceMember.PresenceState.ONLINE : SpaceMember.PresenceState.OFFLINE,\n            peerStates: peers,\n          };\n        }),\n      ),\n      creator: space.inner.spaceState.creator?.key,\n      cache: space.cache,\n      metrics: space.metrics,\n      edgeReplication: space.getEdgeReplicationSetting(),\n    };\n  }\n\n  private _requireIdentity() {\n    if (!this._identityManager.identity) {\n      throw new IdentityNotInitializedError(\n        'This device has no HALO identity available. See https://docs.dxos.org/guide/platform/halo',\n      );\n    }\n    return this._identityManager.identity;\n  }\n\n  private async _updateMetrics(): Promise<void> {\n    const dataSpaceManager = await this._getDataSpaceManager();\n    const identity = this._identityManager.identity?.identityKey.truncate();\n    if (identity) {\n      trace.metrics.gauge('dxos.echo.space.count', dataSpaceManager.spaces.size, {\n        tags: { identity },\n      });\n    }\n  }\n}\n\n// Add `user-channel` prefix to the channel name, so that it doesn't collide with the internal channels.\nconst getChannelId = (channel: string): string => `user-channel/${channel}`;\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport type * as tar from '@obsidize/tar-browserify';\n\nimport { Resource, type Context } from '@dxos/context';\nimport { assertArgument, assertState } from '@dxos/invariant';\nimport type { IdentityDid, SpaceId } from '@dxos/keys';\nimport { SpaceArchiveFileStructure, SpaceArchiveVersion, type SpaceArchiveMetadata } from '@dxos/protocols';\nimport type { SpaceArchive } from '@dxos/protocols/proto/dxos/client/services';\n\nexport type SpaceArchiveBeginProps = {\n  spaceId?: SpaceId;\n\n  /**\n   * DID of the identity that exported the space.\n   */\n  exportedBy?: IdentityDid;\n};\n\nconst CURRENT_VERSION = SpaceArchiveVersion.V1;\n\nexport class SpaceArchiveWriter extends Resource {\n  private _tar?: typeof tar;\n  private _archive?: tar.Archive;\n\n  private _meta?: SpaceArchiveBeginProps = undefined;\n  private _currentRootUrl?: string = undefined;\n\n  protected override async _open(ctx: Context): Promise<void> {\n    this._tar = await import('@obsidize/tar-browserify');\n  }\n\n  protected override async _close(): Promise<void> {\n    return Promise.resolve();\n  }\n\n  async begin(meta: SpaceArchiveBeginProps): Promise<void> {\n    assertState(this._tar, 'Not open');\n    assertState(!this._meta, 'Already started');\n    this._meta = meta;\n    this._archive = new this._tar.Archive();\n  }\n\n  async setCurrentRootUrl(url: string): Promise<void> {\n    assertArgument(url.startsWith('automerge:'), 'Invalid root URL');\n    assertState(this._tar, 'Not open');\n    assertState(this._meta, 'Not started');\n    this._currentRootUrl = url;\n  }\n\n  async writeDocument(documentId: string, data: Uint8Array): Promise<void> {\n    assertArgument(!documentId.startsWith('automerge:'), 'Invalid document ID');\n    assertState(this._archive, 'Not open');\n    this._archive.addBinaryFile(`${SpaceArchiveFileStructure.documents}/${documentId}.bin`, data);\n  }\n\n  async finish(): Promise<SpaceArchive> {\n    assertState(this._archive, 'Not open');\n    assertState(this._meta, 'Not started');\n    assertState(this._currentRootUrl, 'No root URL set');\n\n    const metadata: SpaceArchiveMetadata = {\n      version: CURRENT_VERSION,\n      createdAt: Date.now(),\n      exportedBy: this._meta.exportedBy,\n      originalSpaceId: this._meta.spaceId,\n      echo: {\n        currentRootUrl: this._currentRootUrl,\n      },\n    };\n\n    this._archive.addTextFile(SpaceArchiveFileStructure.metadata, JSON.stringify(metadata));\n\n    const binary = this._archive.toUint8Array();\n\n    return {\n      filename: `${this._meta.spaceId}.tar`,\n      contents: binary,\n    };\n  }\n}\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport type { DocumentId } from '@automerge/automerge-repo';\n\nimport { assertArgument, failedInvariant, invariant } from '@dxos/invariant';\nimport { log } from '@dxos/log';\nimport { SpaceArchiveFileStructure, type SpaceArchiveMetadata } from '@dxos/protocols';\nimport type { SpaceArchive } from '@dxos/protocols/proto/dxos/client/services';\n\nexport type ExtractedSpaceArchive = {\n  metadata: SpaceArchiveMetadata;\n  documents: Record<DocumentId, Uint8Array>;\n};\n\nexport const extractSpaceArchive = async (archive: SpaceArchive): Promise<ExtractedSpaceArchive> => {\n  const { Archive } = await import('@obsidize/tar-browserify');\n  const { entries } = await Archive.extract(archive.contents);\n  const metadataEntry = entries.find((entry) => entry.fileName === SpaceArchiveFileStructure.metadata);\n  assertArgument(metadataEntry, 'Metadata entry not found');\n  const metadata = JSON.parse(metadataEntry.getContentAsText());\n  const documents: Record<DocumentId, Uint8Array> = {};\n  for (const entry of entries.filter((entry) => entry.fileName.startsWith(`${SpaceArchiveFileStructure.documents}/`))) {\n    const documentId = entry.fileName\n      .replace(`${SpaceArchiveFileStructure.documents}/`, '')\n      .replace(/\\.bin$/, '') as DocumentId;\n    invariant(!documentId.includes('/'));\n    documents[documentId] = entry.content ?? failedInvariant();\n  }\n\n  log.info('extracted space archive', { metadata, documents });\n  return { metadata, documents };\n};\n", "//\n// Copyright 2022 DXOS.org\n//\nimport platform from 'platform';\n\nimport { Event } from '@dxos/async';\nimport { Context } from '@dxos/context';\nimport { createCredentialSignerWithKey, createDidFromIdentityKey, CredentialGenerator } from '@dxos/credentials';\nimport { type MetadataStore, type SpaceManager, type SwarmIdentity } from '@dxos/echo-pipeline';\nimport { type EdgeConnection } from '@dxos/edge-client';\nimport { type FeedStore } from '@dxos/feed-store';\nimport { invariant } from '@dxos/invariant';\nimport { type Keyring } from '@dxos/keyring';\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { trace } from '@dxos/protocols';\nimport { Device, DeviceKind } from '@dxos/protocols/proto/dxos/client/services';\nimport { type Runtime } from '@dxos/protocols/proto/dxos/config';\nimport { type FeedMessage } from '@dxos/protocols/proto/dxos/echo/feed';\nimport { type IdentityRecord, type SpaceMetadata } from '@dxos/protocols/proto/dxos/echo/metadata';\nimport {\n  AdmittedFeed,\n  type DeviceProfileDocument,\n  DeviceType,\n  type ProfileDocument,\n  type Credential,\n} from '@dxos/protocols/proto/dxos/halo/credentials';\nimport { Gossip, Presence } from '@dxos/teleport-extension-gossip';\nimport { Timeframe } from '@dxos/timeframe';\nimport { trace as Trace } from '@dxos/tracing';\nimport { isNode, deferFunction } from '@dxos/util';\n\nimport { createAuthProvider } from './authenticator';\nimport { Identity } from './identity';\n\nconst DEVICE_PRESENCE_ANNOUNCE_INTERVAL = 10_000;\nconst DEVICE_PRESENCE_OFFLINE_TIMEOUT = 20_000;\n\ninterface ConstructSpaceParams {\n  spaceRecord: SpaceMetadata;\n  swarmIdentity: SwarmIdentity;\n  identityKey: PublicKey;\n  gossip: Gossip;\n}\n\nexport type JoinIdentityParams = {\n  identityKey: PublicKey;\n  deviceKey: PublicKey;\n  haloSpaceKey: PublicKey;\n  haloGenesisFeedKey: PublicKey;\n  controlFeedKey: PublicKey;\n  dataFeedKey: PublicKey;\n  authorizedDeviceCredential: Credential;\n\n  /**\n   * Latest known timeframe for the control pipeline.\n   * We will try to catch up to this timeframe before starting the data pipeline.\n   */\n  controlTimeframe?: Timeframe;\n  // Custom device profile, merged with defaults, to be applied once the identity is accepted.\n  deviceProfile?: DeviceProfileDocument;\n};\n\nexport type CreateIdentityOptions = {\n  profile?: ProfileDocument;\n  // device profile for device creating the identity.\n  deviceProfile?: DeviceProfileDocument;\n};\n\nexport type IdentityManagerParams = {\n  metadataStore: MetadataStore;\n  keyring: Keyring;\n  feedStore: FeedStore<FeedMessage>;\n  spaceManager: SpaceManager;\n  edgeConnection?: EdgeConnection;\n  edgeFeatures?: Runtime.Client.EdgeFeatures;\n  devicePresenceAnnounceInterval?: number;\n  devicePresenceOfflineTimeout?: number;\n};\n\n// TODO(dmaretskyi): Rename: represents the peer's state machine.\n@Trace.resource()\nexport class IdentityManager {\n  readonly stateUpdate = new Event();\n\n  private readonly _metadataStore: MetadataStore;\n  private readonly _keyring: Keyring;\n  private readonly _feedStore: FeedStore<FeedMessage>;\n  private readonly _spaceManager: SpaceManager;\n  private readonly _devicePresenceAnnounceInterval: number;\n  private readonly _devicePresenceOfflineTimeout: number;\n  private readonly _edgeConnection: EdgeConnection | undefined;\n  private readonly _edgeFeatures: Runtime.Client.EdgeFeatures | undefined;\n\n  private _identity?: Identity;\n\n  // TODO(dmaretskyi): Perhaps this should take/generate the peerKey outside of an initialized identity.\n  constructor(params: IdentityManagerParams) {\n    this._metadataStore = params.metadataStore;\n    this._keyring = params.keyring;\n    this._feedStore = params.feedStore;\n    this._spaceManager = params.spaceManager;\n    this._edgeConnection = params.edgeConnection;\n    this._edgeFeatures = params.edgeFeatures;\n    this._devicePresenceAnnounceInterval = params.devicePresenceAnnounceInterval ?? DEVICE_PRESENCE_ANNOUNCE_INTERVAL;\n    this._devicePresenceOfflineTimeout = params.devicePresenceOfflineTimeout ?? DEVICE_PRESENCE_OFFLINE_TIMEOUT;\n  }\n\n  get identity() {\n    return this._identity;\n  }\n\n  @Trace.span({ showInBrowserTimeline: true })\n  async open(ctx: Context): Promise<void> {\n    const traceId = PublicKey.random().toHex();\n    log.trace('dxos.halo.identity-manager.open', trace.begin({ id: traceId }));\n\n    const identityRecord = this._metadataStore.getIdentityRecord();\n    log('identity record', { identityRecord });\n    if (identityRecord) {\n      this._identity = await this._constructIdentity(identityRecord);\n      await this._identity.open(ctx);\n      await this._identity.ready();\n      log.trace('dxos.halo.identity', {\n        identityKey: identityRecord.identityKey,\n        displayName: this._identity.profileDocument?.displayName,\n      });\n\n      this.stateUpdate.emit();\n    }\n    log.trace('dxos.halo.identity-manager.open', trace.end({ id: traceId }));\n  }\n\n  async close(): Promise<void> {\n    await this._identity?.close(new Context());\n  }\n\n  async createIdentity({ profile, deviceProfile }: CreateIdentityOptions = {}): Promise<Identity> {\n    // TODO(nf): populate using context from ServiceContext?\n    invariant(!this._identity, 'Identity already exists.');\n    log('creating identity...');\n\n    const controlFeedKey = await this._keyring.createKey();\n    const identityRecord: IdentityRecord = {\n      identityKey: await this._keyring.createKey(),\n      deviceKey: await this._keyring.createKey(),\n      haloSpace: {\n        key: await this._keyring.createKey(),\n        genesisFeedKey: controlFeedKey,\n        controlFeedKey,\n        dataFeedKey: await this._keyring.createKey(),\n      },\n    };\n\n    const identity = await this._constructIdentity(identityRecord);\n    await identity.open(new Context());\n\n    {\n      const generator = new CredentialGenerator(this._keyring, identityRecord.identityKey, identityRecord.deviceKey);\n      invariant(identityRecord.haloSpace.genesisFeedKey, 'Genesis feed key is required.');\n      invariant(identityRecord.haloSpace.dataFeedKey, 'Data feed key is required.');\n      const credentials = [\n        // Space genesis.\n        ...(await generator.createSpaceGenesis(identityRecord.haloSpace.key, identityRecord.haloSpace.genesisFeedKey)),\n\n        // Feed admission.\n        await generator.createFeedAdmission(\n          identityRecord.haloSpace.key,\n          identityRecord.haloSpace.dataFeedKey,\n          AdmittedFeed.Designation.DATA,\n        ),\n      ];\n\n      if (profile) {\n        credentials.push(await generator.createProfileCredential(profile));\n      }\n\n      // Device authorization (writes device chain).\n      // NOTE: This credential is written last. This is a hack to make sure that display name is set before identity is \"ready\".\n      credentials.push(await generator.createDeviceAuthorization(identityRecord.deviceKey));\n\n      // Write device metadata to profile.\n      credentials.push(\n        await generator.createDeviceProfile({\n          ...this.createDefaultDeviceProfile(),\n          ...deviceProfile,\n        }),\n      );\n      for (const credential of credentials) {\n        await identity.controlPipeline.writer.write({\n          credential: { credential },\n        });\n      }\n    }\n\n    await this._metadataStore.setIdentityRecord(identityRecord);\n    this._identity = identity;\n    await this._identity.ready();\n    log.trace('dxos.halo.identity', {\n      identityKey: identityRecord.identityKey,\n      displayName: this._identity.profileDocument?.displayName,\n    });\n    this.stateUpdate.emit();\n\n    log('created identity', {\n      identityKey: identity.identityKey,\n      deviceKey: identity.deviceKey,\n      profile: identity.profileDocument,\n    });\n\n    return identity;\n  }\n\n  // TODO(nf): receive platform info rather than generating it here.\n  createDefaultDeviceProfile(): DeviceProfileDocument {\n    let type: DeviceType;\n    // TODO(nf): call Platform service instead?\n    if (isNode()) {\n      type = DeviceType.AGENT;\n    } else {\n      if (platform.name?.startsWith('iOS') || platform.name?.startsWith('Android')) {\n        type = DeviceType.MOBILE;\n      } else if ((globalThis as any).__args) {\n        type = DeviceType.NATIVE;\n      } else {\n        type = DeviceType.BROWSER;\n      }\n    }\n\n    return {\n      type,\n      platform: platform.name,\n      platformVersion: platform.version,\n      architecture: typeof platform.os?.architecture === 'number' ? String(platform.os.architecture) : undefined,\n      os: platform.os?.family,\n      osVersion: platform.os?.version,\n    };\n  }\n\n  /**\n   * Prepare an identity object as the first step of acceptIdentity flow.\n   */\n  async prepareIdentity(params: JoinIdentityParams) {\n    log('accepting identity', { params });\n    invariant(!this._identity, 'Identity already exists.');\n\n    const identityRecord: IdentityRecord = {\n      identityKey: params.identityKey,\n      deviceKey: params.deviceKey,\n      haloSpace: {\n        key: params.haloSpaceKey,\n        genesisFeedKey: params.haloGenesisFeedKey,\n        controlFeedKey: params.controlFeedKey,\n        dataFeedKey: params.dataFeedKey,\n        controlTimeframe: params.controlTimeframe,\n      },\n    };\n    const identity = await this._constructIdentity(identityRecord);\n    await identity.open(new Context());\n    return { identity, identityRecord };\n  }\n\n  /**\n   * Accept an existing identity. Expects its device key to be authorized (now or later).\n   */\n  public async acceptIdentity(\n    identity: Identity,\n    identityRecord: IdentityRecord,\n    profile?: DeviceProfileDocument,\n  ): Promise<void> {\n    this._identity = identity;\n\n    // Identity becomes ready after device chain is replicated. Wait for it before storing the record.\n    await this._identity.ready();\n    await this._metadataStore.setIdentityRecord(identityRecord);\n\n    log.trace('dxos.halo.identity', {\n      identityKey: this._identity!.identityKey,\n      displayName: this._identity.profileDocument?.displayName,\n    });\n\n    await this.updateDeviceProfile({\n      ...this.createDefaultDeviceProfile(),\n      ...profile,\n    });\n    this.stateUpdate.emit();\n\n    log('accepted identity', { identityKey: identity.identityKey, deviceKey: identity.deviceKey });\n  }\n\n  /**\n   * Update the profile document of an existing identity.\n   */\n  async updateProfile(profile: ProfileDocument): Promise<ProfileDocument> {\n    invariant(this._identity, 'Identity not initialized.');\n    // TODO(wittjosiah): Use CredentialGenerator.\n    const credential = await this._identity.getIdentityCredentialSigner().createCredential({\n      subject: this._identity.identityKey,\n      assertion: {\n        '@type': 'dxos.halo.credentials.IdentityProfile',\n        profile,\n      },\n    });\n\n    const receipt = await this._identity.controlPipeline.writer.write({ credential: { credential } });\n    await this._identity.controlPipeline.state.waitUntilTimeframe(new Timeframe([[receipt.feedKey, receipt.seq]]));\n    this.stateUpdate.emit();\n    return profile;\n  }\n\n  async updateDeviceProfile(profile: DeviceProfileDocument): Promise<Device> {\n    invariant(this._identity, 'Identity not initialized.');\n\n    // TODO(nf): CredentialGenerator doesn't work when not updating own device.\n    // const generator = new CredentialGenerator(this._keyring, this._identity.identityKey, this._identity.deviceKey);\n    // const credential = await generator.createDeviceProfile(profile);\n\n    const credential = await this._identity.getDeviceCredentialSigner().createCredential({\n      subject: this._identity.deviceKey,\n      assertion: {\n        '@type': 'dxos.halo.credentials.DeviceProfile',\n        profile,\n      },\n    });\n\n    const receipt = await this._identity.controlPipeline.writer.write({ credential: { credential } });\n    await this._identity.controlPipeline.state.waitUntilTimeframe(new Timeframe([[receipt.feedKey, receipt.seq]]));\n    this.stateUpdate.emit();\n    return {\n      deviceKey: this._identity.deviceKey,\n      kind: DeviceKind.CURRENT,\n      presence: Device.PresenceState.ONLINE,\n      profile,\n    };\n  }\n\n  private async _constructIdentity(identityRecord: IdentityRecord): Promise<Identity> {\n    invariant(!this._identity);\n    log('constructing identity', { identityRecord });\n\n    const gossip = new Gossip({\n      localPeerId: identityRecord.deviceKey,\n    });\n    const presence = new Presence({\n      announceInterval: this._devicePresenceAnnounceInterval,\n      offlineTimeout: this._devicePresenceOfflineTimeout,\n      identityKey: identityRecord.deviceKey,\n      gossip,\n    });\n\n    // Must be created before the space so the feeds are writable.\n    invariant(identityRecord.haloSpace.controlFeedKey);\n    const controlFeed = await this._feedStore.openFeed(identityRecord.haloSpace.controlFeedKey, {\n      writable: true,\n    });\n    invariant(identityRecord.haloSpace.dataFeedKey);\n    const dataFeed = await this._feedStore.openFeed(identityRecord.haloSpace.dataFeedKey, {\n      writable: true,\n      sparse: true,\n    });\n\n    const space = await this._constructSpace({\n      spaceRecord: identityRecord.haloSpace,\n      swarmIdentity: {\n        identityKey: identityRecord.identityKey,\n        peerKey: identityRecord.deviceKey,\n        credentialProvider: createAuthProvider(createCredentialSignerWithKey(this._keyring, identityRecord.deviceKey)),\n        credentialAuthenticator: deferFunction(() => identity.authVerifier.verifier),\n      },\n      gossip,\n      identityKey: identityRecord.identityKey,\n    });\n    await space.setControlFeed(controlFeed);\n    await space.setDataFeed(dataFeed);\n\n    const did = await createDidFromIdentityKey(identityRecord.identityKey);\n    const identity: Identity = new Identity({\n      space,\n      presence,\n      signer: this._keyring,\n      did,\n      identityKey: identityRecord.identityKey,\n      deviceKey: identityRecord.deviceKey,\n      edgeConnection: this._edgeConnection,\n      edgeFeatures: this._edgeFeatures,\n    });\n    log('done', { identityKey: identityRecord.identityKey });\n\n    // TODO(mykola): Set new timeframe on a write to a feed.\n    if (identityRecord.haloSpace.controlTimeframe) {\n      identity.controlPipeline.state.setTargetTimeframe(identityRecord.haloSpace.controlTimeframe);\n    }\n\n    identity.stateUpdate.on(() => this.stateUpdate.emit());\n    return identity;\n  }\n\n  private async _constructSpace({ spaceRecord, swarmIdentity, identityKey, gossip }: ConstructSpaceParams) {\n    return this._spaceManager.constructSpace({\n      metadata: {\n        key: spaceRecord.key,\n        genesisFeedKey: spaceRecord.genesisFeedKey,\n      },\n      swarmIdentity,\n      onAuthorizedConnection: (session) => {\n        session.addExtension(\n          'dxos.mesh.teleport.gossip',\n          gossip.createExtension({ remotePeerId: session.remotePeerId }),\n        );\n      },\n      onAuthFailure: () => {\n        log.warn('auth failure');\n      },\n      memberKey: identityKey,\n      onDelegatedInvitationStatusChange: async () => {}, // TODO: will be used for recovery keys\n      onMemberRolesChanged: async () => {}, // TODO: will be used for device revocation\n    });\n  }\n}\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { Trigger, sleep } from '@dxos/async';\nimport { Stream } from '@dxos/codec-protobuf/stream';\nimport { Resource } from '@dxos/context';\nimport { createCredential, signPresentation } from '@dxos/credentials';\nimport { invariant } from '@dxos/invariant';\nimport { type Keyring } from '@dxos/keyring';\nimport { log } from '@dxos/log';\nimport {\n  type CreateIdentityRequest,\n  type CreateRecoveryCredentialRequest,\n  type Identity as IdentityProto,\n  type IdentityService,\n  type QueryIdentityResponse,\n  type RecoverIdentityRequest,\n  type SignPresentationRequest,\n  SpaceState,\n} from '@dxos/protocols/proto/dxos/client/services';\nimport { type Presentation, type ProfileDocument } from '@dxos/protocols/proto/dxos/halo/credentials';\nimport { safeAwaitAll } from '@dxos/util';\n\nimport { type Identity } from './identity';\nimport { type CreateIdentityOptions, type IdentityManager } from './identity-manager';\nimport { type EdgeIdentityRecoveryManager } from './identity-recovery-manager';\nimport { type DataSpaceManager } from '../spaces';\n\nconst DEFAULT_SPACE_SEARCH_TIMEOUT = 10_000;\n\nexport class IdentityServiceImpl extends Resource implements IdentityService {\n  constructor(\n    private readonly _identityManager: IdentityManager,\n    private readonly _recoveryManager: EdgeIdentityRecoveryManager,\n    private readonly _keyring: Keyring,\n    private readonly _dataSpaceManagerProvider: () => DataSpaceManager,\n    private readonly _createIdentity: (params: CreateIdentityOptions) => Promise<Identity>,\n    private readonly _onProfileUpdate?: (profile: ProfileDocument | undefined) => Promise<void>,\n  ) {\n    super();\n  }\n\n  protected override async _open(): Promise<void> {\n    const identity = this._identityManager.identity;\n    if (identity && !identity.defaultSpaceId) {\n      await this._fixIdentityWithoutDefaultSpace(identity);\n    }\n  }\n\n  async createIdentity(request: CreateIdentityRequest): Promise<IdentityProto> {\n    await this._createIdentity({ profile: request.profile, deviceProfile: request.deviceProfile });\n    const dataSpaceManager = this._dataSpaceManagerProvider();\n    await this._createDefaultSpace(dataSpaceManager);\n    return this._getIdentity()!;\n  }\n\n  private async _createDefaultSpace(dataSpaceManager: DataSpaceManager): Promise<void> {\n    const space = await dataSpaceManager!.createDefaultSpace();\n    const identity = this._identityManager.identity;\n    invariant(identity);\n    await identity.updateDefaultSpace(space.id);\n  }\n\n  queryIdentity(): Stream<QueryIdentityResponse> {\n    return new Stream(({ next }) => {\n      const emitNext = () => next({ identity: this._getIdentity() });\n\n      emitNext();\n      return this._identityManager.stateUpdate.on(emitNext);\n    });\n  }\n\n  private _getIdentity(): IdentityProto | undefined {\n    if (!this._identityManager.identity) {\n      return undefined;\n    }\n\n    return {\n      did: this._identityManager.identity.did,\n      identityKey: this._identityManager.identity.identityKey,\n      spaceKey: this._identityManager.identity.space.key,\n      profile: this._identityManager.identity.profileDocument,\n    };\n  }\n\n  async updateProfile(profile: ProfileDocument): Promise<IdentityProto> {\n    invariant(this._identityManager.identity, 'Identity not initialized.');\n    await this._identityManager.updateProfile(profile);\n    await this._onProfileUpdate?.(this._identityManager.identity.profileDocument);\n    return this._getIdentity()!;\n  }\n\n  async createRecoveryCredential(request: CreateRecoveryCredentialRequest) {\n    return this._recoveryManager.createRecoveryCredential(request);\n  }\n\n  async requestRecoveryChallenge() {\n    return this._recoveryManager.requestRecoveryChallenge();\n  }\n\n  async recoverIdentity(request: RecoverIdentityRequest): Promise<IdentityProto> {\n    if (request.recoveryCode) {\n      await this._recoveryManager.recoverIdentity({ recoveryCode: request.recoveryCode });\n    } else if (request.external) {\n      await this._recoveryManager.recoverIdentityWithExternalSignature(request.external);\n    } else if (request.token) {\n      await this._recoveryManager.recoverIdentityWithToken({ token: request.token });\n    } else {\n      throw new Error('Invalid request.');\n    }\n\n    return this._getIdentity()!;\n  }\n\n  // TODO(burdon): Rename createPresentation?\n  async signPresentation({ presentation, nonce }: SignPresentationRequest): Promise<Presentation> {\n    invariant(this._identityManager.identity, 'Identity not initialized.');\n\n    return await signPresentation({\n      presentation,\n      signer: this._keyring,\n      signerKey: this._identityManager.identity.deviceKey,\n      chain: this._identityManager.identity.deviceCredentialChain,\n      nonce,\n    });\n  }\n\n  async createAuthCredential() {\n    const identity = this._identityManager.identity;\n\n    invariant(identity, 'Identity not initialized.');\n\n    return await createCredential({\n      assertion: { '@type': 'dxos.halo.credentials.Auth' },\n      issuer: identity.identityKey,\n      subject: identity.identityKey,\n      chain: identity.deviceCredentialChain,\n      signingKey: identity.deviceKey,\n      signer: this._keyring,\n    });\n  }\n\n  private async _fixIdentityWithoutDefaultSpace(identity: Identity): Promise<void> {\n    let recodedDefaultSpace = false;\n    let foundDefaultSpace = false;\n    const dataSpaceManager = this._dataSpaceManagerProvider();\n\n    const recordedDefaultSpaceTrigger = new Trigger();\n\n    const allProcessed = safeAwaitAll(\n      dataSpaceManager.spaces.values(),\n      async (space) => {\n        if (space.state === SpaceState.SPACE_CLOSED) {\n          await space.open();\n\n          // Wait until the space is either READY or REQUIRES_MIGRATION.\n          // NOTE: Space could potentially never initialize if the space data is corrupted.\n          const requiresMigration = space.stateUpdate.waitForCondition(\n            () => space.state === SpaceState.SPACE_REQUIRES_MIGRATION,\n          );\n          await Promise.race([space.initializeDataPipeline(), requiresMigration]);\n        }\n        if (await dataSpaceManager.isDefaultSpace(space)) {\n          if (foundDefaultSpace) {\n            log.warn('Multiple default spaces found. Using the first one.', { duplicate: space.id });\n            return;\n          }\n\n          foundDefaultSpace = true;\n          await identity.updateDefaultSpace(space.id);\n          recodedDefaultSpace = true;\n          recordedDefaultSpaceTrigger.wake();\n        }\n      },\n      (err) => {\n        log.catch(err);\n      },\n    );\n\n    // Wait for all spaces to be processed or until the default space is recorded.\n    // If the timeout is reached, create a new default space.\n    await Promise.race([allProcessed, recordedDefaultSpaceTrigger.wait(), sleep(DEFAULT_SPACE_SEARCH_TIMEOUT)]);\n\n    if (!recodedDefaultSpace) {\n      await this._createDefaultSpace(dataSpaceManager);\n    }\n  }\n}\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { getCredentialAssertion } from '@dxos/credentials';\nimport { invariant } from '@dxos/invariant';\nimport { type Keyring } from '@dxos/keyring';\nimport { type PublicKey } from '@dxos/keys';\nimport { AlreadyJoinedError, type ApiError } from '@dxos/protocols';\nimport { Invitation } from '@dxos/protocols/proto/dxos/client/services';\nimport type { DeviceProfileDocument } from '@dxos/protocols/proto/dxos/halo/credentials';\nimport {\n  type AdmissionRequest,\n  type AdmissionResponse,\n  type IntroductionRequest,\n} from '@dxos/protocols/proto/dxos/halo/invitations';\n\nimport { type InvitationProtocol } from './invitation-protocol';\nimport { type Identity, type JoinIdentityParams } from '../identity';\n\nexport class DeviceInvitationProtocol implements InvitationProtocol {\n  constructor(\n    private readonly _keyring: Keyring,\n    private readonly _getIdentity: () => Identity,\n    private readonly _acceptIdentity: (identity: JoinIdentityParams) => Promise<Identity>,\n  ) {}\n\n  toJSON(): object {\n    return {\n      kind: 'device',\n    };\n  }\n\n  checkCanInviteNewMembers(): ApiError | undefined {\n    return undefined;\n  }\n\n  getInvitationContext(): Partial<Invitation> & Pick<Invitation, 'kind'> {\n    return {\n      kind: Invitation.Kind.DEVICE,\n    };\n  }\n\n  async delegate(): Promise<PublicKey> {\n    throw new Error('delegation not supported');\n  }\n\n  async cancelDelegation(): Promise<void> {\n    throw new Error('delegation not supported');\n  }\n\n  async admit(_: Invitation, request: AdmissionRequest): Promise<AdmissionResponse> {\n    invariant(request.device);\n    const identity = this._getIdentity();\n    const credential = await identity.admitDevice(request.device);\n    invariant(getCredentialAssertion(credential)['@type'] === 'dxos.halo.credentials.AuthorizedDevice');\n\n    return {\n      device: {\n        identityKey: identity.identityKey,\n        haloSpaceKey: identity.haloSpaceKey,\n        genesisFeedKey: identity.haloGenesisFeedKey,\n        controlTimeframe: identity.controlPipeline.state.timeframe,\n        credential,\n      },\n    };\n  }\n\n  checkInvitation(invitation: Partial<Invitation>): AlreadyJoinedError | undefined {\n    try {\n      const identity = this._getIdentity();\n      if (identity) {\n        return new AlreadyJoinedError('Currently only one identity per client is supported.');\n      }\n    } catch {\n      // No identity.\n    }\n  }\n\n  createIntroduction(): IntroductionRequest {\n    return {};\n  }\n\n  async createAdmissionRequest(deviceProfile?: DeviceProfileDocument): Promise<AdmissionRequest> {\n    const deviceKey = await this._keyring.createKey();\n    const controlFeedKey = await this._keyring.createKey();\n    const dataFeedKey = await this._keyring.createKey();\n\n    return {\n      device: {\n        deviceKey,\n        controlFeedKey,\n        dataFeedKey,\n        profile: deviceProfile,\n      },\n    };\n  }\n\n  async accept(response: AdmissionResponse, request: AdmissionRequest): Promise<Partial<Invitation>> {\n    invariant(response.device);\n    const { identityKey, haloSpaceKey, genesisFeedKey, controlTimeframe } = response.device;\n\n    invariant(request.device);\n    const { deviceKey, controlFeedKey, dataFeedKey, profile } = request.device;\n\n    // TODO(wittjosiah): When multiple identities are supported, verify identity doesn't already exist before accepting.\n\n    await this._acceptIdentity({\n      identityKey,\n      deviceKey,\n      haloSpaceKey,\n      haloGenesisFeedKey: genesisFeedKey,\n      controlFeedKey,\n      dataFeedKey,\n      controlTimeframe,\n      deviceProfile: profile,\n      authorizedDeviceCredential: response.device.credential,\n    });\n\n    return { identityKey };\n  }\n}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { type PushStream, scheduleTask, TimeoutError, type Trigger } from '@dxos/async';\nimport { INVITATION_TIMEOUT, getExpirationTime } from '@dxos/client-protocol';\nimport { type Context, ContextDisposedError } from '@dxos/context';\nimport { createKeyPair, sign } from '@dxos/crypto';\nimport { type EdgeHttpClient } from '@dxos/edge-client';\nimport { invariant } from '@dxos/invariant';\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { createTeleportProtocolFactory, type SwarmNetworkManager, type SwarmConnection } from '@dxos/network-manager';\nimport { InvalidInvitationError, InvalidInvitationExtensionRoleError, trace } from '@dxos/protocols';\nimport { type AdmissionKeypair, Invitation } from '@dxos/protocols/proto/dxos/client/services';\nimport { type DeviceProfileDocument } from '@dxos/protocols/proto/dxos/halo/credentials';\nimport { AuthenticationResponse, type IntroductionResponse } from '@dxos/protocols/proto/dxos/halo/invitations';\nimport { InvitationOptions } from '@dxos/protocols/proto/dxos/halo/invitations';\nimport { type ExtensionContext, type TeleportExtension, type TeleportParams } from '@dxos/teleport';\nimport { trace as _trace } from '@dxos/tracing';\nimport { ComplexSet } from '@dxos/util';\n\nimport { type EdgeInvitationConfig, EdgeInvitationHandler } from './edge-invitation-handler';\nimport { InvitationGuestExtension } from './invitation-guest-extenstion';\nimport { InvitationHostExtension, isAuthenticationRequired, MAX_OTP_ATTEMPTS } from './invitation-host-extension';\nimport { type InvitationProtocol } from './invitation-protocol';\nimport { createGuardedInvitationState } from './invitation-state';\nimport { InvitationTopology } from './invitation-topology';\n\nconst metrics = _trace.metrics;\n\nconst MAX_DELEGATED_INVITATION_HOST_TRIES = 3;\n\nexport type InvitationConnectionParams = {\n  teleport: Partial<TeleportParams>;\n  edgeInvitations?: EdgeInvitationConfig;\n};\n\n/**\n * Generic handler for Halo and Space invitations.\n * Handles the life-cycle of invitations between peers.\n *\n * Host\n * - Creates an invitation containing a swarm topic (which can be shared via a URL, QR code, or direct message).\n * - Joins the swarm with the topic and waits for guest's introduction.\n * - Wait for guest to authenticate with challenge specified in the invitation.\n * - Waits for guest to present credentials (containing local device and feed keys).\n * - Writes credentials to control feed then exits or waits for more guests (multi use invitations).\n *\n * Guest\n * - Joins the swarm with the topic.\n * - Sends an introduction.\n * - Submits the challenge.\n * - If Space handler then creates a local cloned space (with genesis block).\n * - Sends admission credentials.\n *  ```\n *  [Guest]                                          [Host]\n *   |------------------------------------Introduce-->|\n *   |-------------------------------[Authenticate]-->|\n *   |----------------------------------------Admit-->|\n *  ```\n *\n *  TODO: consider refactoring using xstate making the logic separation more explicit:\n *  TODO: the flow logic should either be contained in invitations-handler or in extensions, not be split across\n *  TODO: potentially re-evaluate host-side API to allow multiple concurrent connection, so that mutex can be removed\n */\nexport class InvitationsHandler {\n  /**\n   * @internal\n   */\n  constructor(\n    private readonly _networkManager: SwarmNetworkManager,\n    private readonly _edgeClient?: EdgeHttpClient,\n    private readonly _connectionParams?: InvitationConnectionParams,\n  ) {}\n\n  handleInvitationFlow(\n    ctx: Context,\n    stream: PushStream<Invitation>,\n    protocol: InvitationProtocol,\n    invitation: Invitation,\n  ): void {\n    log.verbose('dxos.sdk.invitations-handler.handleInvitationFlow', {\n      state: invitation.state,\n      invitationId: invitation.invitationId,\n      kind: invitation.kind,\n      type: invitation.type,\n    });\n    metrics.increment('dxos.invitation.host');\n    const guardedState = createGuardedInvitationState(ctx, invitation, stream);\n    // Called for every connecting peer.\n    const createExtension = (): InvitationHostExtension => {\n      const extension = new InvitationHostExtension(guardedState.mutex, {\n        get activeInvitation() {\n          return ctx.disposed ? null : guardedState.current;\n        },\n\n        onStateUpdate: (newState: Invitation.State): Invitation => {\n          if (newState !== Invitation.State.ERROR && newState !== Invitation.State.TIMEOUT) {\n            guardedState.set(extension, newState);\n          }\n          return guardedState.current;\n        },\n\n        admit: async (admissionRequest) => {\n          try {\n            log.verbose('dxos.sdk.invitations-handler.host.admit', {\n              invitationId: invitation.invitationId,\n              ...protocol.toJSON(),\n            });\n            const deviceKey = admissionRequest.device?.deviceKey ?? admissionRequest.space?.deviceKey;\n            invariant(deviceKey);\n            const admissionResponse = await protocol.admit(invitation, admissionRequest, extension.guestProfile);\n\n            // Updating credentials complete.\n            extension.completedTrigger.wake(deviceKey);\n\n            return admissionResponse;\n          } catch (err: any) {\n            // TODO(burdon): Generic RPC callback to report error to client.\n            guardedState.error(extension, err);\n            throw err; // Propagate error to guest.\n          }\n        },\n\n        onOpen: (connectionCtx: Context, extensionsCtx: ExtensionContext) => {\n          let admitted = false;\n          connectionCtx.onDispose(() => {\n            if (!admitted) {\n              guardedState.set(extension, Invitation.State.CONNECTING);\n            }\n          });\n\n          scheduleTask(connectionCtx, async () => {\n            const traceId = PublicKey.random().toHex();\n            try {\n              log.trace('dxos.sdk.invitations-handler.host.onOpen', trace.begin({ id: traceId }));\n              log.verbose('connected', { ...protocol.toJSON() });\n              const deviceKey = await extension.completedTrigger.wait({ timeout: invitation.timeout });\n              log.verbose('admitted guest', { guest: deviceKey, ...protocol.toJSON() });\n              guardedState.set(extension, Invitation.State.SUCCESS);\n              metrics.increment('dxos.invitation.success');\n              log.trace('dxos.sdk.invitations-handler.host.onOpen', trace.end({ id: traceId }));\n              admitted = true;\n\n              if (!invitation.multiUse) {\n                await ctx.dispose();\n              }\n            } catch (err: any) {\n              const stateChanged = guardedState.set(extension, Invitation.State.CONNECTING);\n              if (err instanceof TimeoutError) {\n                if (stateChanged) {\n                  metrics.increment('dxos.invitation.timeout');\n                  log.verbose('timeout', { ...protocol.toJSON() });\n                }\n              } else {\n                if (stateChanged) {\n                  metrics.increment('dxos.invitation.failed');\n                  log.error('failed', err);\n                }\n              }\n              log.trace('dxos.sdk.invitations-handler.host.onOpen', trace.error({ id: traceId, error: err }));\n              // Close connection\n              extensionsCtx.close(err);\n            }\n          });\n        },\n        onError: (err) => {\n          const stateChanged = guardedState.set(extension, Invitation.State.CONNECTING);\n          if (err instanceof InvalidInvitationExtensionRoleError) {\n            log('invalid role', { ...err.context });\n            return;\n          }\n          if (err instanceof TimeoutError) {\n            if (stateChanged) {\n              metrics.increment('dxos.invitation.timeout');\n              log.verbose('timeout', { err });\n            }\n          } else {\n            if (stateChanged) {\n              metrics.increment('dxos.invitation.failed');\n              log.error('failed', err);\n            }\n          }\n        },\n      });\n\n      return extension;\n    };\n\n    const expiresOn = getExpirationTime(invitation);\n    if (expiresOn) {\n      if (expiresOn.getTime() < Date.now()) {\n        log.warn('invitation has already expired');\n        guardedState.set(null, Invitation.State.EXPIRED);\n        void ctx.dispose().catch((err) => log.catch(err));\n        return;\n      }\n      scheduleTask(\n        ctx,\n        async () => {\n          // ensure the swarm is closed before changing state and closing the stream.\n          await swarmConnection.close();\n          guardedState.set(null, Invitation.State.EXPIRED);\n          metrics.increment('dxos.invitation.expired');\n          await ctx.dispose();\n        },\n        expiresOn.getTime() - Date.now(),\n      );\n    }\n\n    let swarmConnection: SwarmConnection;\n    scheduleTask(ctx, async () => {\n      swarmConnection = await this._joinSwarm(ctx, invitation, InvitationOptions.Role.HOST, createExtension);\n      guardedState.set(null, Invitation.State.CONNECTING);\n    });\n  }\n\n  acceptInvitation(\n    ctx: Context,\n    stream: PushStream<Invitation>,\n    protocol: InvitationProtocol,\n    invitation: Invitation,\n    otpEnteredTrigger: Trigger<string>,\n    deviceProfile?: DeviceProfileDocument,\n  ): void {\n    log.verbose('dxos.sdk.invitations-handler.acceptInvitation', {\n      state: invitation.state,\n      invitationId: invitation.invitationId,\n      kind: invitation.kind,\n      type: invitation.type,\n    });\n    const { timeout = INVITATION_TIMEOUT } = invitation;\n\n    if (deviceProfile) {\n      invariant(invitation.kind === Invitation.Kind.DEVICE, 'deviceProfile provided for non-device invitation');\n    }\n\n    const triedPeersIds = new ComplexSet(PublicKey.hash);\n    const guardedState = createGuardedInvitationState(ctx, invitation, stream);\n\n    const shouldCancelInvitationFlow = (extension: InvitationGuestExtension) => {\n      const isLockedByAnotherConnection = guardedState.mutex.isLocked() && !extension.hasFlowLock();\n      log('should cancel invitation flow', {\n        isLockedByAnotherConnection,\n        invitationType: Invitation.Type.DELEGATED,\n        triedPeers: triedPeersIds.size,\n      });\n      if (isLockedByAnotherConnection) {\n        return false;\n      }\n      // for delegated invitations we might try with other hosts and will dispose either after\n      // a timeout or when the number of tries was exceeded\n      return invitation.type !== Invitation.Type.DELEGATED || triedPeersIds.size >= MAX_DELEGATED_INVITATION_HOST_TRIES;\n    };\n\n    let admitted = false;\n    const createExtension = (): InvitationGuestExtension => {\n      const extension = new InvitationGuestExtension(guardedState.mutex, {\n        onStateUpdate: (newState: Invitation.State) => {\n          guardedState.set(extension, newState);\n        },\n        onOpen: (connectionCtx: Context, extensionCtx: ExtensionContext) => {\n          triedPeersIds.add(extensionCtx.remotePeerId);\n\n          if (admitted) {\n            extensionCtx.close();\n            return;\n          }\n\n          connectionCtx.onDispose(async () => {\n            log.verbose('extension disposed', { admitted, currentState: guardedState.current.state });\n            if (!admitted) {\n              guardedState.error(extension, new ContextDisposedError());\n              if (shouldCancelInvitationFlow(extension)) {\n                await ctx.dispose();\n              }\n            }\n          });\n\n          scheduleTask(connectionCtx, async () => {\n            const traceId = PublicKey.random().toHex();\n            try {\n              log.trace('dxos.sdk.invitations-handler.guest.onOpen', trace.begin({ id: traceId }));\n\n              scheduleTask(\n                connectionCtx,\n                () => {\n                  guardedState.set(extension, Invitation.State.TIMEOUT);\n                  extensionCtx.close();\n                },\n                timeout,\n              );\n\n              log.verbose('dxos.sdk.invitations-handler.guest.connected', { ...protocol.toJSON() });\n              guardedState.set(extension, Invitation.State.CONNECTED);\n\n              // 1. Introduce guest to host.\n              log.verbose('dxos.sdk.invitations-handler.guest.introduce', {\n                invitationId: invitation.invitationId,\n                ...protocol.toJSON(),\n              });\n              const introductionResponse = await extension.rpc.InvitationHostService.introduce({\n                invitationId: invitation.invitationId,\n                ...protocol.createIntroduction(),\n              });\n              log.verbose('dxos.sdk.invitations-handler.guest.introduce-response', {\n                invitationId: invitation.invitationId,\n                ...protocol.toJSON(),\n                authMethod: introductionResponse.authMethod,\n              });\n              invitation.authMethod = introductionResponse.authMethod;\n\n              // 2. Get authentication code.\n              if (isAuthenticationRequired(invitation)) {\n                switch (invitation.authMethod) {\n                  case Invitation.AuthMethod.SHARED_SECRET:\n                    await this._handleGuestOtpAuth(\n                      extension,\n                      (state) => guardedState.set(extension, state),\n                      otpEnteredTrigger,\n                      { timeout },\n                    );\n                    break;\n                  case Invitation.AuthMethod.KNOWN_PUBLIC_KEY:\n                    await this._handleGuestKpkAuth(\n                      extension,\n                      (state) => guardedState.set(extension, state),\n                      invitation,\n                      introductionResponse,\n                    );\n                    break;\n                }\n              }\n\n              // 3. Send admission credentials to host (with local space keys).\n              log.verbose('dxos.sdk.invitations-handler.guest.request-admission', {\n                invitationId: invitation.invitationId,\n                ...protocol.toJSON(),\n              });\n              const admissionRequest = await protocol.createAdmissionRequest(deviceProfile);\n              const admissionResponse = await extension.rpc.InvitationHostService.admit(admissionRequest);\n\n              // Remote connection no longer needed.\n              admitted = true;\n\n              // 4. Record credential in our HALO.\n              const result = await protocol.accept(admissionResponse, admissionRequest);\n\n              // 5. Success.\n              log.verbose('dxos.sdk.invitations-handler.guest.admitted-by-host', {\n                invitationId: invitation.invitationId,\n                ...protocol.toJSON(),\n              });\n              guardedState.complete({\n                ...guardedState.current,\n                ...result,\n                state: Invitation.State.SUCCESS,\n              });\n              log.trace('dxos.sdk.invitations-handler.guest.onOpen', trace.end({ id: traceId }));\n            } catch (err: any) {\n              if (err instanceof TimeoutError) {\n                log.verbose('timeout', { ...protocol.toJSON() });\n                guardedState.set(extension, Invitation.State.TIMEOUT);\n              } else {\n                log.verbose('auth failed', err);\n                guardedState.error(extension, err);\n              }\n              extensionCtx.close(err);\n              log.trace('dxos.sdk.invitations-handler.guest.onOpen', trace.error({ id: traceId, error: err }));\n            }\n          });\n        },\n        onError: (err) => {\n          if (err instanceof InvalidInvitationExtensionRoleError) {\n            return;\n          }\n          if (err instanceof TimeoutError) {\n            log.verbose('timeout', { ...protocol.toJSON() });\n            guardedState.set(extension, Invitation.State.TIMEOUT);\n          } else {\n            log.verbose('auth failed', err);\n            guardedState.error(extension, err);\n          }\n        },\n      });\n\n      return extension;\n    };\n\n    const edgeInvitationHandler = new EdgeInvitationHandler(this._connectionParams?.edgeInvitations, this._edgeClient, {\n      onInvitationSuccess: async (admissionResponse, admissionRequest) => {\n        const result = await protocol.accept(admissionResponse, admissionRequest);\n        log.info('admitted by edge', { ...protocol.toJSON() });\n        guardedState.complete({ ...guardedState.current, ...result, state: Invitation.State.SUCCESS });\n      },\n    });\n    edgeInvitationHandler.handle(ctx, guardedState, protocol, deviceProfile);\n\n    scheduleTask(ctx, async () => {\n      const error = checkInvitation(protocol, invitation);\n      if (error) {\n        stream.error(error);\n        await ctx.dispose();\n      } else {\n        invariant(invitation.swarmKey);\n\n        const timeoutInactive = () => {\n          if (guardedState.mutex.isLocked()) {\n            scheduleTask(ctx, timeoutInactive, timeout);\n          } else {\n            guardedState.set(null, Invitation.State.TIMEOUT);\n          }\n        };\n\n        // Timeout if no connection is established.\n        scheduleTask(ctx, timeoutInactive, timeout);\n\n        await this._joinSwarm(ctx, invitation, InvitationOptions.Role.GUEST, createExtension);\n        guardedState.set(null, Invitation.State.CONNECTING);\n      }\n    });\n  }\n\n  private async _joinSwarm(\n    ctx: Context,\n    invitation: Invitation,\n    role: InvitationOptions.Role,\n    extensionFactory: () => TeleportExtension,\n  ): Promise<SwarmConnection> {\n    let label: string;\n    if (role === InvitationOptions.Role.GUEST) {\n      label = 'invitation guest';\n    } else if (invitation.kind === Invitation.Kind.DEVICE) {\n      label = 'invitation host for device';\n    } else {\n      label = `invitation host for space ${invitation.spaceKey?.truncate()}`;\n    }\n    const swarmConnection = await this._networkManager.joinSwarm({\n      topic: invitation.swarmKey,\n      protocolProvider: createTeleportProtocolFactory(async (teleport) => {\n        teleport.addExtension('dxos.halo.invitations', extensionFactory());\n      }, this._connectionParams?.teleport),\n      topology: new InvitationTopology(role),\n      label,\n    });\n    ctx.onDispose(() => swarmConnection.close());\n    return swarmConnection;\n  }\n\n  private async _handleGuestOtpAuth(\n    extension: InvitationGuestExtension,\n    setState: (newState: Invitation.State) => void,\n    authenticated: Trigger<string>,\n    options: { timeout: number },\n  ): Promise<void> {\n    for (let attempt = 1; attempt <= MAX_OTP_ATTEMPTS; attempt++) {\n      log('guest waiting for authentication code...');\n      setState(Invitation.State.READY_FOR_AUTHENTICATION);\n      const authCode = await authenticated.wait(options);\n\n      log('sending authentication request');\n      setState(Invitation.State.AUTHENTICATING);\n      const response = await extension.rpc.InvitationHostService.authenticate({ authCode });\n      if (response.status === undefined || response.status === AuthenticationResponse.Status.OK) {\n        break;\n      }\n\n      if (response.status === AuthenticationResponse.Status.INVALID_OTP) {\n        if (attempt === MAX_OTP_ATTEMPTS) {\n          throw new Error(`Maximum retry attempts: ${MAX_OTP_ATTEMPTS}`);\n        } else {\n          log('retrying invalid code', { attempt });\n          authenticated.reset();\n        }\n      }\n    }\n  }\n\n  private async _handleGuestKpkAuth(\n    extension: InvitationGuestExtension,\n    setState: (newState: Invitation.State) => void,\n    invitation: Invitation,\n    introductionResponse: IntroductionResponse,\n  ): Promise<void> {\n    if (invitation.guestKeypair?.privateKey == null) {\n      throw new Error('keypair missing in the invitation');\n    }\n    if (introductionResponse.challenge == null) {\n      throw new Error('challenge missing in the introduction');\n    }\n    log('sending authentication request');\n    const signature = sign(Buffer.from(introductionResponse.challenge), invitation.guestKeypair.privateKey);\n    const response = await extension.rpc.InvitationHostService.authenticate({\n      signedChallenge: signature,\n    });\n    if (response.status !== AuthenticationResponse.Status.OK) {\n      throw new Error(`Authentication failed with code: ${response.status}`);\n    }\n  }\n}\n\nconst checkInvitation = (protocol: InvitationProtocol, invitation: Partial<Invitation>) => {\n  const expiresOn = getExpirationTime(invitation);\n  if (expiresOn && expiresOn.getTime() < Date.now()) {\n    return new InvalidInvitationError('Invitation already expired.');\n  }\n  return protocol.checkInvitation(invitation);\n};\n\nexport const createAdmissionKeypair = (): AdmissionKeypair => {\n  const keypair = createKeyPair();\n  return { publicKey: PublicKey.from(keypair.publicKey), privateKey: keypair.secretKey };\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { type MutexGuard, scheduleMicroTask, scheduleTask } from '@dxos/async';\nimport { type Context } from '@dxos/context';\nimport { sign } from '@dxos/crypto';\nimport { type EdgeHttpClient } from '@dxos/edge-client';\nimport { invariant } from '@dxos/invariant';\nimport { SpaceId } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport {\n  EdgeAuthChallengeError,\n  EdgeCallFailedError,\n  type JoinSpaceRequest,\n  type JoinSpaceResponseBody,\n} from '@dxos/protocols';\nimport { schema } from '@dxos/protocols/proto';\nimport { Invitation } from '@dxos/protocols/proto/dxos/client/services';\nimport { type DeviceProfileDocument } from '@dxos/protocols/proto/dxos/halo/credentials';\nimport {\n  type AdmissionResponse,\n  type AdmissionRequest,\n  type SpaceAdmissionRequest,\n} from '@dxos/protocols/proto/dxos/halo/invitations';\n\nimport { type InvitationProtocol } from './invitation-protocol';\nimport { type FlowLockHolder, type GuardedInvitationState } from './invitation-state';\nimport { tryAcquireBeforeContextDisposed } from './utils';\n\nexport interface EdgeInvitationHandlerCallbacks {\n  onInvitationSuccess(response: AdmissionResponse, request: AdmissionRequest): Promise<void>;\n}\n\nexport const MAX_RETRIES_PER_INVITATION = 5;\nexport const DEFAULT_REQUEST_RETRY_INTERVAL_MS = 3000;\nexport const DEFAULT_REQUEST_RETRY_JITTER_MS = 500;\n\nexport type EdgeInvitationConfig = {\n  retryInterval?: number;\n  retryJitter?: number;\n};\n\nexport class EdgeInvitationHandler implements FlowLockHolder {\n  private _flowLock: MutexGuard | undefined;\n\n  private readonly _retryInterval: number;\n  private readonly _retryJitter: number;\n\n  constructor(\n    config: EdgeInvitationConfig | undefined,\n    private readonly _client: EdgeHttpClient | undefined,\n    private readonly _callbacks: EdgeInvitationHandlerCallbacks,\n  ) {\n    this._retryInterval = config?.retryInterval ?? DEFAULT_REQUEST_RETRY_INTERVAL_MS;\n    this._retryJitter = config?.retryJitter ?? DEFAULT_REQUEST_RETRY_JITTER_MS;\n  }\n\n  public handle(\n    ctx: Context,\n    guardedState: GuardedInvitationState,\n    protocol: InvitationProtocol,\n    deviceProfile?: DeviceProfileDocument,\n  ): void {\n    if (!this._client) {\n      log('edge disabled');\n      return;\n    }\n\n    const invitation = guardedState.current;\n    const spaceId = invitation.spaceId;\n    const canBeHandledByEdge =\n      invitation.authMethod !== Invitation.AuthMethod.SHARED_SECRET &&\n      invitation.type === Invitation.Type.DELEGATED &&\n      invitation.kind === Invitation.Kind.SPACE &&\n      spaceId != null &&\n      SpaceId.isValid(spaceId);\n\n    if (!canBeHandledByEdge) {\n      log('invitation could not be handled by edge', { invitation });\n      return;\n    }\n\n    ctx.onDispose(() => {\n      this._flowLock?.release();\n      this._flowLock = undefined;\n    });\n\n    let requestCount = 0;\n    const tryHandleInvitation = async () => {\n      requestCount++;\n      const admissionRequest = await protocol.createAdmissionRequest(deviceProfile);\n      if (admissionRequest.space) {\n        try {\n          await this._handleSpaceInvitationFlow(ctx, guardedState, admissionRequest.space, spaceId);\n        } catch (error) {\n          if (error instanceof EdgeCallFailedError) {\n            log.info('join space with edge unsuccessful', {\n              reason: error.message,\n              retryable: error.isRetryable,\n              after: error.retryAfterMs ?? this._calculateNextRetryMs(),\n            });\n            if (error.isRetryable && requestCount < MAX_RETRIES_PER_INVITATION) {\n              scheduleTask(ctx, tryHandleInvitation, error.retryAfterMs ?? this._calculateNextRetryMs());\n            }\n          } else if (requestCount < MAX_RETRIES_PER_INVITATION) {\n            log.info('failed to handle invitation with edge', { error });\n            scheduleTask(ctx, tryHandleInvitation, this._calculateNextRetryMs());\n          }\n        }\n      }\n    };\n    scheduleMicroTask(ctx, tryHandleInvitation);\n  }\n\n  private async _handleSpaceInvitationFlow(\n    ctx: Context,\n    guardedState: GuardedInvitationState,\n    admissionRequest: SpaceAdmissionRequest,\n    spaceId: SpaceId,\n  ): Promise<void> {\n    try {\n      log('edge invitation flow');\n      this._flowLock = await tryAcquireBeforeContextDisposed(ctx, guardedState.mutex);\n      log.verbose('edge invitation flow acquired the lock');\n\n      guardedState.set(this, Invitation.State.CONNECTING);\n\n      const response = await this._joinSpaceByInvitation(guardedState, spaceId, {\n        identityKey: admissionRequest.identityKey.toHex(),\n        invitationId: guardedState.current.invitationId,\n      });\n\n      const admissionResponse = await this._mapToAdmissionResponse(response);\n      await this._callbacks.onInvitationSuccess(admissionResponse, { space: admissionRequest });\n    } catch (error) {\n      guardedState.set(this, Invitation.State.ERROR);\n      throw error;\n    } finally {\n      this._flowLock?.release();\n      this._flowLock = undefined;\n    }\n  }\n\n  private async _mapToAdmissionResponse(edgeResponse: JoinSpaceResponseBody): Promise<AdmissionResponse> {\n    const credentialBytes = Buffer.from(edgeResponse.spaceMemberCredential, 'base64');\n    const codec = schema.getCodecForType('dxos.halo.credentials.Credential');\n    return {\n      space: {\n        credential: codec.decode(credentialBytes),\n      },\n    };\n  }\n\n  private async _joinSpaceByInvitation(\n    guardedState: GuardedInvitationState,\n    spaceId: SpaceId,\n    request: JoinSpaceRequest,\n  ): Promise<JoinSpaceResponseBody> {\n    invariant(this._client);\n    try {\n      return await this._client.joinSpaceByInvitation(spaceId, request);\n    } catch (error: any) {\n      if (error instanceof EdgeAuthChallengeError) {\n        const publicKey = guardedState.current.guestKeypair?.publicKey;\n        const privateKey = guardedState.current.guestKeypair?.privateKey;\n        if (!privateKey || !publicKey) {\n          throw error;\n        }\n        const signature = sign(Buffer.from(error.challenge, 'base64'), privateKey);\n        return this._client.joinSpaceByInvitation(spaceId, {\n          ...request,\n          signature: Buffer.from(signature).toString('base64'),\n        });\n      } else {\n        throw error;\n      }\n    }\n  }\n\n  public hasFlowLock(): boolean {\n    return this._flowLock != null;\n  }\n\n  private _calculateNextRetryMs(): number {\n    return this._retryInterval + Math.random() * this._retryJitter;\n  }\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { type Mutex, type MutexGuard } from '@dxos/async';\nimport { cancelWithContext, type Context, ContextDisposedError } from '@dxos/context';\nimport { Invitation } from '@dxos/protocols/proto/dxos/client/services';\n\nexport const stateToString = (state: Invitation.State): string => {\n  return Object.entries(Invitation.State).find(([key, val]) => val === state)?.[0] ?? 'unknown';\n};\n\nexport const computeExpirationTime = (invitation: Partial<Invitation>): Date | undefined => {\n  if (!invitation.lifetime) {\n    return;\n  }\n  return new Date((invitation.created?.getTime() ?? Date.now()) + invitation.lifetime * 1000);\n};\n\nexport const tryAcquireBeforeContextDisposed = async (ctx: Context, mutex: Mutex): Promise<MutexGuard> => {\n  let guard: MutexGuard | undefined;\n  return cancelWithContext(\n    ctx,\n    (async () => {\n      guard = await mutex.acquire();\n      if (ctx.disposed) {\n        guard.release();\n        guard = undefined;\n        throw new ContextDisposedError();\n      }\n      return guard;\n    })(),\n  );\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { type Mutex, type MutexGuard, Trigger } from '@dxos/async';\nimport { cancelWithContext, Context } from '@dxos/context';\nimport { invariant } from '@dxos/invariant';\nimport { log } from '@dxos/log';\nimport { InvalidInvitationExtensionRoleError } from '@dxos/protocols';\nimport { schema } from '@dxos/protocols/proto';\nimport { type Invitation } from '@dxos/protocols/proto/dxos/client/services';\nimport { type InvitationHostService, InvitationOptions } from '@dxos/protocols/proto/dxos/halo/invitations';\nimport { type ExtensionContext, RpcExtension } from '@dxos/teleport';\n\nimport { type FlowLockHolder } from './invitation-state';\nimport { tryAcquireBeforeContextDisposed } from './utils';\n\nconst OPTIONS_TIMEOUT = 10_000;\n\ntype InvitationGuestExtensionCallbacks = {\n  // Deliberately not async to not block the extensions opening.\n  onOpen: (ctx: Context, extensionCtx: ExtensionContext) => void;\n  onError: (error: Error) => void;\n\n  onStateUpdate: (newState: Invitation.State) => void;\n};\n\n/**\n * Guest's side for a connection to a concrete peer in p2p network during invitation.\n */\nexport class InvitationGuestExtension\n  extends RpcExtension<\n    { InvitationHostService: InvitationHostService },\n    { InvitationHostService: InvitationHostService }\n  >\n  implements FlowLockHolder\n{\n  private _ctx = new Context();\n  private _remoteOptions?: InvitationOptions;\n  private _remoteOptionsTrigger = new Trigger();\n  /**\n   * Held to allow only one invitation flow at a time to be active.\n   */\n  private _invitationFlowLock: MutexGuard | null = null;\n\n  constructor(\n    private readonly _invitationFlowMutex: Mutex,\n    private readonly _callbacks: InvitationGuestExtensionCallbacks,\n  ) {\n    super({\n      requested: {\n        InvitationHostService: schema.getService('dxos.halo.invitations.InvitationHostService'),\n      },\n      exposed: {\n        InvitationHostService: schema.getService('dxos.halo.invitations.InvitationHostService'),\n      },\n    });\n  }\n\n  public hasFlowLock(): boolean {\n    return this._invitationFlowLock != null;\n  }\n\n  protected override async getHandlers(): Promise<{ InvitationHostService: InvitationHostService }> {\n    return {\n      InvitationHostService: {\n        options: async (options) => {\n          invariant(!this._remoteOptions, 'Remote options already set.');\n          this._remoteOptions = options;\n          this._remoteOptionsTrigger.wake();\n        },\n        introduce: () => {\n          throw new Error('Method not allowed.');\n        },\n        authenticate: () => {\n          throw new Error('Method not allowed.');\n        },\n        admit: () => {\n          throw new Error('Method not allowed.');\n        },\n      },\n    };\n  }\n\n  override async onOpen(context: ExtensionContext): Promise<void> {\n    await super.onOpen(context);\n\n    try {\n      log.verbose('guest acquire lock');\n      this._invitationFlowLock = await tryAcquireBeforeContextDisposed(this._ctx, this._invitationFlowMutex);\n      log.verbose('guest lock acquired');\n      await cancelWithContext(\n        this._ctx,\n        this.rpc.InvitationHostService.options({ role: InvitationOptions.Role.GUEST }),\n      );\n      log.verbose('options sent');\n      await cancelWithContext(this._ctx, this._remoteOptionsTrigger.wait({ timeout: OPTIONS_TIMEOUT }));\n      log.verbose('options received');\n      if (this._remoteOptions?.role !== InvitationOptions.Role.HOST) {\n        throw new InvalidInvitationExtensionRoleError(undefined, {\n          expected: InvitationOptions.Role.HOST,\n          remoteOptions: this._remoteOptions,\n          remotePeerId: context.remotePeerId,\n        });\n      }\n\n      this._callbacks.onOpen(this._ctx, context);\n    } catch (err: any) {\n      if (this._invitationFlowLock != null) {\n        this._callbacks.onError(err);\n      }\n      if (!this._ctx.disposed) {\n        context.close(err);\n      }\n    }\n  }\n\n  override async onClose(): Promise<void> {\n    await this._destroy();\n  }\n\n  override async onAbort(): Promise<void> {\n    await this._destroy();\n  }\n\n  private async _destroy(): Promise<void> {\n    await this._ctx.dispose();\n    if (this._invitationFlowLock != null) {\n      this._invitationFlowLock.release();\n      this._invitationFlowLock = null;\n      log.verbose('invitation flow lock released');\n    }\n  }\n}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { type Mutex, type MutexGuard, Trigger, scheduleTask } from '@dxos/async';\nimport { cancelWithContext, Context } from '@dxos/context';\nimport { randomBytes, verify } from '@dxos/crypto';\nimport { invariant, InvariantViolation } from '@dxos/invariant';\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { InvalidInvitationExtensionRoleError, trace } from '@dxos/protocols';\nimport { schema } from '@dxos/protocols/proto';\nimport { Invitation } from '@dxos/protocols/proto/dxos/client/services';\nimport { type ProfileDocument } from '@dxos/protocols/proto/dxos/halo/credentials';\nimport {\n  type AdmissionRequest,\n  type AdmissionResponse,\n  AuthenticationResponse,\n  type InvitationHostService,\n  InvitationOptions,\n} from '@dxos/protocols/proto/dxos/halo/invitations';\nimport { type ExtensionContext, RpcExtension } from '@dxos/teleport';\n\nimport type { FlowLockHolder } from './invitation-state';\nimport { stateToString, tryAcquireBeforeContextDisposed } from './utils';\n\n/// Timeout for the options exchange.\nconst OPTIONS_TIMEOUT = 10_000;\n\nexport const MAX_OTP_ATTEMPTS = 3;\n\ntype InvitationHostExtensionCallbacks = {\n  activeInvitation: Invitation | null;\n\n  // Deliberately not async to not block the extensions opening.\n  onOpen: (ctx: Context, extensionCtx: ExtensionContext) => void;\n  onError: (error: Error) => void;\n\n  onStateUpdate: (newState: Invitation.State) => void;\n\n  admit: (request: AdmissionRequest) => Promise<AdmissionResponse>;\n};\n\n/**\n * Host's side for a connection to a concrete peer in p2p network during invitation.\n */\nexport class InvitationHostExtension\n  extends RpcExtension<\n    { InvitationHostService: InvitationHostService },\n    { InvitationHostService: InvitationHostService }\n  >\n  implements FlowLockHolder\n{\n  /**\n   * @internal\n   */\n  private _ctx = new Context();\n  private _remoteOptions?: InvitationOptions;\n  private _remoteOptionsTrigger = new Trigger();\n\n  private _challenge?: Buffer = undefined;\n\n  public guestProfile?: ProfileDocument = undefined;\n\n  public authenticationPassed = false;\n\n  /**\n   * Retry counter for SHARED_SECRET authentication method.\n   */\n  public authenticationRetry = 0;\n\n  /**\n   * Resolved when admission is completed.\n   */\n  public completedTrigger = new Trigger<PublicKey>();\n\n  /**\n   * Held to allow only one invitation flow at a time to be active.\n   */\n  private _invitationFlowLock: MutexGuard | null = null;\n\n  constructor(\n    private readonly _invitationFlowMutex: Mutex,\n    private readonly _callbacks: InvitationHostExtensionCallbacks,\n  ) {\n    super({\n      requested: {\n        InvitationHostService: schema.getService('dxos.halo.invitations.InvitationHostService'),\n      },\n      exposed: {\n        InvitationHostService: schema.getService('dxos.halo.invitations.InvitationHostService'),\n      },\n    });\n  }\n\n  public hasFlowLock(): boolean {\n    return this._invitationFlowLock != null;\n  }\n\n  protected override async getHandlers(): Promise<{ InvitationHostService: InvitationHostService }> {\n    return {\n      // TODO(dmaretskyi): For now this is just forwarding the data to callbacks since we don't have session-specific logic.\n      // Perhaps in the future we will have more complex logic here.\n      InvitationHostService: {\n        options: async (options) => {\n          invariant(!this._remoteOptions, 'Remote options already set.');\n          this._remoteOptions = options;\n          this._remoteOptionsTrigger.wake();\n        },\n\n        introduce: async (request) => {\n          const { profile, invitationId } = request;\n          const traceId = PublicKey.random().toHex();\n          log.trace('dxos.sdk.invitation-handler.host.introduce', trace.begin({ id: traceId }));\n\n          const invitation = this._requireActiveInvitation();\n          this._assertInvitationState(Invitation.State.CONNECTED);\n          if (invitationId !== invitation?.invitationId) {\n            log.warn('incorrect invitationId', { expected: invitation.invitationId, actual: invitationId });\n            this._callbacks.onError(new Error('Incorrect invitationId.'));\n            scheduleTask(this._ctx, () => this.close());\n            // TODO(dmaretskyi): Better error handling.\n            return {\n              authMethod: Invitation.AuthMethod.NONE,\n            };\n          }\n\n          log.verbose('guest introduced themselves', { guestProfile: profile });\n          this.guestProfile = profile;\n          this._callbacks.onStateUpdate(Invitation.State.READY_FOR_AUTHENTICATION);\n          this._challenge =\n            invitation.authMethod === Invitation.AuthMethod.KNOWN_PUBLIC_KEY ? randomBytes(32) : undefined;\n\n          log.trace('dxos.sdk.invitation-handler.host.introduce', trace.end({ id: traceId }));\n          return {\n            authMethod: invitation.authMethod,\n            challenge: this._challenge,\n          };\n        },\n\n        authenticate: async ({ authCode: code, signedChallenge }) => {\n          const traceId = PublicKey.random().toHex();\n          log.trace('dxos.sdk.invitation-handler.host.authenticate', trace.begin({ id: traceId }));\n\n          const invitation = this._requireActiveInvitation();\n          log.verbose('received authentication request', { authCode: code });\n          let status = AuthenticationResponse.Status.OK;\n\n          this._assertInvitationState([Invitation.State.AUTHENTICATING, Invitation.State.READY_FOR_AUTHENTICATION]);\n          this._callbacks.onStateUpdate(Invitation.State.AUTHENTICATING);\n\n          switch (invitation.authMethod) {\n            case Invitation.AuthMethod.NONE: {\n              log('authentication not required');\n              return { status: AuthenticationResponse.Status.OK };\n            }\n\n            case Invitation.AuthMethod.SHARED_SECRET: {\n              if (invitation.authCode) {\n                if (this.authenticationRetry++ > MAX_OTP_ATTEMPTS) {\n                  status = AuthenticationResponse.Status.INVALID_OPT_ATTEMPTS;\n                } else if (code !== invitation.authCode) {\n                  status = AuthenticationResponse.Status.INVALID_OTP;\n                } else {\n                  this.authenticationPassed = true;\n                }\n              }\n              break;\n            }\n\n            case Invitation.AuthMethod.KNOWN_PUBLIC_KEY: {\n              if (!invitation.guestKeypair) {\n                status = AuthenticationResponse.Status.INTERNAL_ERROR;\n                break;\n              }\n              const isSignatureValid =\n                this._challenge &&\n                verify(\n                  this._challenge,\n                  Buffer.from(signedChallenge ?? []),\n                  invitation.guestKeypair.publicKey.asBuffer(),\n                );\n              if (isSignatureValid) {\n                this.authenticationPassed = true;\n              } else {\n                status = AuthenticationResponse.Status.INVALID_SIGNATURE;\n              }\n              break;\n            }\n\n            default: {\n              log.error('invalid authentication method', { authMethod: invitation.authMethod });\n              status = AuthenticationResponse.Status.INTERNAL_ERROR;\n              break;\n            }\n          }\n\n          if (![AuthenticationResponse.Status.OK, AuthenticationResponse.Status.INVALID_OTP].includes(status)) {\n            this._callbacks.onError(new Error(`Authentication failed, with status=${status}`));\n            scheduleTask(this._ctx, () => this.close());\n            return { status };\n          }\n\n          log.trace('dxos.sdk.invitation-handler.host.authenticate', trace.end({ id: traceId, data: { status } }));\n          return { status };\n        },\n\n        admit: async (request) => {\n          const traceId = PublicKey.random().toHex();\n          log.trace('dxos.sdk.invitation-handler.host.admit', trace.begin({ id: traceId }));\n          const invitation = this._requireActiveInvitation();\n\n          try {\n            // Check authenticated.\n            if (isAuthenticationRequired(invitation)) {\n              this._assertInvitationState(Invitation.State.AUTHENTICATING);\n              if (!this.authenticationPassed) {\n                throw new Error('Not authenticated');\n              }\n            }\n\n            const response = await this._callbacks.admit(request);\n\n            log.trace('dxos.sdk.invitation-handler.host.admit', trace.end({ id: traceId }));\n            return response;\n          } catch (err: any) {\n            this._callbacks.onError(err);\n            throw err;\n          }\n        },\n      },\n    };\n  }\n\n  override async onOpen(context: ExtensionContext): Promise<void> {\n    await super.onOpen(context);\n\n    try {\n      log.verbose('host acquire lock');\n      this._invitationFlowLock = await tryAcquireBeforeContextDisposed(this._ctx, this._invitationFlowMutex);\n      log.verbose('host lock acquired');\n      this._callbacks.onStateUpdate(Invitation.State.CONNECTING);\n      await this.rpc.InvitationHostService.options({ role: InvitationOptions.Role.HOST });\n      log.verbose('options sent');\n      await cancelWithContext(this._ctx, this._remoteOptionsTrigger.wait({ timeout: OPTIONS_TIMEOUT }));\n      log.verbose('options received');\n      if (this._remoteOptions?.role !== InvitationOptions.Role.GUEST) {\n        throw new InvalidInvitationExtensionRoleError(undefined, {\n          expected: InvitationOptions.Role.GUEST,\n          remoteOptions: this._remoteOptions,\n          remotePeerId: context.remotePeerId,\n        });\n      }\n      this._callbacks.onStateUpdate(Invitation.State.CONNECTED);\n      this._callbacks.onOpen(this._ctx, context);\n    } catch (err: any) {\n      if (this._invitationFlowLock != null) {\n        this._callbacks.onError(err);\n      }\n      if (!this._ctx.disposed) {\n        context.close(err);\n      }\n    }\n  }\n\n  private _requireActiveInvitation(): Invitation {\n    const invitation = this._callbacks.activeInvitation;\n    if (invitation == null) {\n      scheduleTask(this._ctx, () => this.close());\n      throw new Error('Active invitation not found');\n    }\n    return invitation;\n  }\n\n  private _assertInvitationState(stateOrMany: Invitation.State | Invitation.State[]): void {\n    const invitation = this._requireActiveInvitation();\n    const validStates = Array.isArray(stateOrMany) ? stateOrMany : [stateOrMany];\n    if (!validStates.includes(invitation.state)) {\n      scheduleTask(this._ctx, () => this.close());\n      throw new InvariantViolation(\n        `Expected ${stateToString(invitation.state)} to be one of [${validStates.map(stateToString).join(', ')}]`,\n      );\n    }\n  }\n\n  override async onClose(): Promise<void> {\n    await this._destroy();\n  }\n\n  override async onAbort(): Promise<void> {\n    await this._destroy();\n  }\n\n  private async _destroy(): Promise<void> {\n    await this._ctx.dispose();\n    if (this._invitationFlowLock != null) {\n      this._invitationFlowLock?.release();\n      this._invitationFlowLock = null;\n      log.verbose('invitation flow lock released');\n    }\n  }\n}\n\nexport const isAuthenticationRequired = (invitation: Invitation) =>\n  invitation.authMethod !== Invitation.AuthMethod.NONE;\n", "/**\n * A utility object for serializing invitation state changes by multiple concurrent\n * invitation flow connections.\n */\n//\n// Copyright 2024 DXOS.org\n//\n\nimport { Mutex, type PushStream } from '@dxos/async';\nimport { type Context } from '@dxos/context';\nimport { log } from '@dxos/log';\nimport { Invitation } from '@dxos/protocols/proto/dxos/client/services';\n\nimport { stateToString } from './utils';\n\nexport interface FlowLockHolder {\n  hasFlowLock(): boolean;\n}\n\nexport interface GuardedInvitationState {\n  mutex: Mutex;\n  current: Invitation;\n\n  complete(newState: Partial<Invitation>): void;\n  set(lockHolder: FlowLockHolder | null, newState: Invitation.State): boolean;\n  error(lockHolder: FlowLockHolder | null, error: any): boolean;\n}\n\nexport const createGuardedInvitationState = (\n  ctx: Context,\n  invitation: Invitation,\n  stream: PushStream<Invitation>,\n): GuardedInvitationState => {\n  // the mutex guards invitation flow on host and guest side, making sure only one flow is currently active\n  // deadlocks seem very unlikely because hosts don't initiate multiple connections\n  // even if this somehow happens that there are 2 guests (A, B) and 2 hosts (1, 2) and:\n  //  A has lock for flow with 1, B has lock for flow with 2\n  //  1 has lock for flow with B, 2 has lock for flow with A\n  // there'll be a 10-second introduction timeout after which connection will be closed and deadlock broken\n  const mutex = new Mutex();\n  let lastActiveLockHolder: FlowLockHolder | null = null;\n  let currentInvitation = { ...invitation };\n  const isStateChangeAllowed = (lockHolder: FlowLockHolder | null) => {\n    if (ctx.disposed || (lockHolder !== null && mutex.isLocked() && !lockHolder.hasFlowLock())) {\n      return false;\n    }\n    // don't allow transitions from a terminal state unless a new extension acquired mutex\n    // handles a case when error occurs (e.g. connection is closed) after we completed the flow\n    // successfully or already reported another error\n    return lockHolder == null || lastActiveLockHolder !== lockHolder || isNonTerminalState(currentInvitation.state);\n  };\n  return {\n    mutex,\n    get current() {\n      return currentInvitation;\n    },\n    // disposing context prevents any further state updates\n    complete: (newState: Partial<Invitation>) => {\n      logStateUpdate(currentInvitation, undefined, invitation.state);\n      currentInvitation = { ...currentInvitation, ...newState };\n      stream.next(currentInvitation);\n      return ctx.dispose();\n    },\n    set: (lockHolder: FlowLockHolder | null, newState: Invitation.State): boolean => {\n      if (isStateChangeAllowed(lockHolder)) {\n        logStateUpdate(currentInvitation, lockHolder, newState);\n        currentInvitation = { ...currentInvitation, state: newState };\n        stream.next(currentInvitation);\n        lastActiveLockHolder = lockHolder;\n        return true;\n      }\n      return false;\n    },\n    error: (lockHolder: FlowLockHolder | null, error: any): boolean => {\n      if (isStateChangeAllowed(lockHolder)) {\n        logStateUpdate(currentInvitation, lockHolder, Invitation.State.ERROR, error);\n        currentInvitation = { ...currentInvitation, state: Invitation.State.ERROR };\n        stream.next(currentInvitation);\n        stream.error(error);\n        lastActiveLockHolder = lockHolder;\n        return true;\n      }\n      return false;\n    },\n  };\n};\n\nconst logStateUpdate = (invitation: Invitation, actor: any, newState: Invitation.State, error?: Error) => {\n  const logContext = {\n    invitationId: invitation.invitationId,\n    actor: actor?.constructor.name,\n    newState: stateToString(newState),\n    oldState: stateToString(invitation.state),\n    error: error?.message,\n    errorStack: error?.stack,\n  };\n  if (isNonTerminalState(newState)) {\n    log.verbose('dxos.sdk.invitations-handler.state.update', logContext);\n  } else {\n    log.info('dxos.sdk.invitations-handler.state.update', logContext);\n  }\n};\n\nconst isNonTerminalState = (currentState: Invitation.State): boolean => {\n  return ![\n    Invitation.State.SUCCESS,\n    Invitation.State.ERROR,\n    Invitation.State.CANCELLED,\n    Invitation.State.TIMEOUT,\n    Invitation.State.EXPIRED,\n  ].includes(currentState);\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { invariant } from '@dxos/invariant';\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport type { SwarmController, Topology } from '@dxos/network-manager';\nimport { InvitationOptions } from '@dxos/protocols/proto/dxos/halo/invitations';\nimport { ComplexSet } from '@dxos/util';\n\n/**\n * Hosts are listening on an invitation topic.\n * They initiate a connection with any new peer if they are not currently in the invitation flow\n * with another peer (connected.length > 0).\n * When the invitation flow ends guest leaves the swarm and topology is updated once again,\n * so we can connect to the next peer we haven't tried yet.\n * If the peer turns out to be a host or a malicious guest their ID is remembered so that we don't try\n * to establish a connection with them again.\n *\n * Guests don't initiate connections. They accept all connections because if we reject,\n * the host won't retry their offer.\n * Even if we started an invitation flow with one host we might want to try other hosts in case\n * the first one failed due to a network error, so multiple connections are accepted.\n */\nexport class InvitationTopology implements Topology {\n  private _controller?: SwarmController;\n\n  /**\n   * Peers we tried to establish a connection with.\n   * In invitation flow peers are assigned random ids when they join the swarm, so we'll retry\n   * a peer if they reload an invitation.\n   *\n   * Consider keeping a separate set for peers we know are hosts and have some retry timeout\n   * for guests we failed an invitation flow with (potentially due to a network error).\n   */\n  private _seenPeers = new ComplexSet<PublicKey>(PublicKey.hash);\n\n  constructor(private readonly _role: InvitationOptions.Role) {}\n\n  init(controller: SwarmController): void {\n    invariant(!this._controller, 'Already initialized.');\n    this._controller = controller;\n  }\n\n  update(): void {\n    invariant(this._controller, 'Not initialized.');\n    const { ownPeerId, candidates, connected, allPeers } = this._controller.getState();\n\n    // guests don't initiate connections\n    if (this._role === InvitationOptions.Role.GUEST) {\n      return;\n    }\n\n    // don't start a connection while we have an active invitation flow\n    if (connected.length > 0) {\n      // update seenPeers here as well in case another host initiated a connection with us\n      connected.forEach((c) => this._seenPeers.add(c));\n      return;\n    }\n\n    const firstUnknownPeer = candidates.find((peerId) => !this._seenPeers.has(peerId));\n    // cleanup\n    this._seenPeers = new ComplexSet<PublicKey>(\n      PublicKey.hash,\n      allPeers.filter((peerId) => this._seenPeers.has(peerId)),\n    );\n    if (firstUnknownPeer != null) {\n      log('invitation connect', { ownPeerId, remotePeerId: firstUnknownPeer });\n      this._controller.connect(firstUnknownPeer);\n      this._seenPeers.add(firstUnknownPeer);\n    }\n  }\n\n  async onOffer(peer: PublicKey): Promise<boolean> {\n    invariant(this._controller, 'Not initialized.');\n    return !this._seenPeers.has(peer);\n  }\n\n  async destroy(): Promise<void> {\n    this._seenPeers.clear();\n  }\n\n  toString(): string {\n    return `InvitationTopology(${this._role === InvitationOptions.Role.GUEST ? 'guest' : 'host'})`;\n  }\n}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { Stream } from '@dxos/codec-protobuf/stream';\nimport {\n  type AuthenticationRequest,\n  type AcceptInvitationRequest,\n  type Invitation,\n  type InvitationsService,\n  QueryInvitationsResponse,\n} from '@dxos/protocols/proto/dxos/client/services';\nimport { trace } from '@dxos/tracing';\n\nimport { type InvitationsManager } from './invitations-manager';\n\n/**\n * Adapts invitation service observable to client/service stream.\n */\nexport class InvitationsServiceImpl implements InvitationsService {\n  constructor(private readonly _invitationsManager: InvitationsManager) {}\n\n  // TODO(burdon): Guest/host label.\n  getLoggingContext() {\n    return {\n      // deviceKey: this._identityManager.identity?.deviceKey\n    };\n  }\n\n  createInvitation(options: Invitation): Stream<Invitation> {\n    return new Stream<Invitation>(({ next, close }) => {\n      void this._invitationsManager\n        .createInvitation(options)\n        .then((invitation) => {\n          trace.metrics.increment('dxos.invitation.created');\n          invitation.subscribe(next, close, close);\n        })\n        .catch(close);\n    });\n  }\n\n  acceptInvitation(request: AcceptInvitationRequest): Stream<Invitation> {\n    const invitation = this._invitationsManager.acceptInvitation(request);\n    return new Stream<Invitation>(({ next, close }) => {\n      invitation.subscribe(next, close, close);\n    });\n  }\n\n  async authenticate(request: AuthenticationRequest): Promise<void> {\n    return this._invitationsManager.authenticate(request);\n  }\n\n  async cancelInvitation(request: { invitationId: string }): Promise<void> {\n    return this._invitationsManager.cancelInvitation(request);\n  }\n\n  queryInvitations(): Stream<QueryInvitationsResponse> {\n    return new Stream<QueryInvitationsResponse>(({ next, ctx }) => {\n      // Push added invitations to the stream.\n      this._invitationsManager.invitationCreated.on(ctx, (invitation) => {\n        next({\n          action: QueryInvitationsResponse.Action.ADDED,\n          type: QueryInvitationsResponse.Type.CREATED,\n          invitations: [invitation],\n        });\n      });\n\n      this._invitationsManager.invitationAccepted.on(ctx, (invitation) => {\n        next({\n          action: QueryInvitationsResponse.Action.ADDED,\n          type: QueryInvitationsResponse.Type.ACCEPTED,\n          invitations: [invitation],\n        });\n      });\n\n      // Push removed invitations to the stream.\n      this._invitationsManager.removedCreated.on(ctx, (invitation) => {\n        next({\n          action: QueryInvitationsResponse.Action.REMOVED,\n          type: QueryInvitationsResponse.Type.CREATED,\n          invitations: [invitation],\n        });\n      });\n\n      this._invitationsManager.removedAccepted.on(ctx, (invitation) => {\n        next({\n          action: QueryInvitationsResponse.Action.REMOVED,\n          type: QueryInvitationsResponse.Type.ACCEPTED,\n          invitations: [invitation],\n        });\n      });\n\n      // used only for testing\n      this._invitationsManager.saved.on(ctx, (invitation) => {\n        next({\n          action: QueryInvitationsResponse.Action.SAVED,\n          type: QueryInvitationsResponse.Type.CREATED,\n          invitations: [invitation],\n        });\n      });\n\n      // Push existing invitations to the stream.\n      next({\n        action: QueryInvitationsResponse.Action.ADDED,\n        type: QueryInvitationsResponse.Type.CREATED,\n        invitations: this._invitationsManager.getCreatedInvitations(),\n        existing: true,\n      });\n\n      next({\n        action: QueryInvitationsResponse.Action.ADDED,\n        type: QueryInvitationsResponse.Type.ACCEPTED,\n        invitations: this._invitationsManager.getAcceptedInvitations(),\n        existing: true,\n      });\n\n      this._invitationsManager.onPersistentInvitationsLoaded(ctx, () => {\n        next({\n          action: QueryInvitationsResponse.Action.LOAD_COMPLETE,\n          type: QueryInvitationsResponse.Type.CREATED,\n          // TODO(nf): populate with invitations\n        });\n      });\n      // TODO(nf): expired invitations?\n    });\n  }\n}\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport {\n  createCancelDelegatedSpaceInvitationCredential,\n  createDelegatedSpaceInvitationCredential,\n  getCredentialAssertion,\n} from '@dxos/credentials';\nimport { writeMessages } from '@dxos/feed-store';\nimport { invariant } from '@dxos/invariant';\nimport { type Keyring } from '@dxos/keyring';\nimport { type PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport {\n  AlreadyJoinedError,\n  type ApiError,\n  AuthorizationError,\n  InvalidInvitationError,\n  SpaceNotFoundError,\n} from '@dxos/protocols';\nimport { Invitation } from '@dxos/protocols/proto/dxos/client/services';\nimport { SpaceMember, type ProfileDocument } from '@dxos/protocols/proto/dxos/halo/credentials';\nimport {\n  type AdmissionRequest,\n  type AdmissionResponse,\n  type IntroductionRequest,\n} from '@dxos/protocols/proto/dxos/halo/invitations';\n\nimport { type InvitationProtocol } from './invitation-protocol';\nimport { computeExpirationTime } from './utils';\nimport { type DataSpaceManager, type SigningContext } from '../spaces';\n\nexport class SpaceInvitationProtocol implements InvitationProtocol {\n  constructor(\n    private readonly _spaceManager: DataSpaceManager,\n    private readonly _signingContext: SigningContext,\n    private readonly _keyring: Keyring,\n    private readonly _spaceKey?: PublicKey,\n  ) {}\n\n  toJSON(): object {\n    return {\n      kind: 'space',\n      deviceKey: this._signingContext.deviceKey,\n      spaceKey: this._spaceKey,\n    };\n  }\n\n  checkCanInviteNewMembers(): ApiError | undefined {\n    if (this._spaceKey == null) {\n      return new InvalidInvitationError('No spaceKey was provided for a space invitation.');\n    }\n    const space = this._spaceManager.spaces.get(this._spaceKey);\n    if (space == null) {\n      return new SpaceNotFoundError(this._spaceKey);\n    }\n    if (!space?.inner.spaceState.hasMembershipManagementPermission(this._signingContext.identityKey)) {\n      return new AuthorizationError('No member management permission.');\n    }\n    return undefined;\n  }\n\n  getInvitationContext(): Partial<Invitation> & Pick<Invitation, 'kind'> {\n    invariant(this._spaceKey);\n    const space = this._spaceManager.spaces.get(this._spaceKey);\n    invariant(space);\n    return {\n      kind: Invitation.Kind.SPACE,\n      spaceKey: this._spaceKey,\n      spaceId: space.id,\n    };\n  }\n\n  async admit(\n    invitation: Invitation,\n    request: AdmissionRequest,\n    guestProfile?: ProfileDocument | undefined,\n  ): Promise<AdmissionResponse> {\n    invariant(this._spaceKey && request.space);\n    log('writing guest credentials', { host: this._signingContext.deviceKey, guest: request.space.deviceKey });\n\n    const spaceMemberCredential = await this._spaceManager.admitMember({\n      spaceKey: this._spaceKey,\n      identityKey: request.space.identityKey,\n      role: invitation.role ?? SpaceMember.Role.ADMIN,\n      profile: guestProfile,\n      delegationCredentialId: invitation.delegationCredentialId,\n    });\n\n    const space = this._spaceManager.spaces.get(this._spaceKey);\n    return {\n      space: {\n        credential: spaceMemberCredential,\n        controlTimeframe: space?.inner.controlPipeline.state.timeframe,\n      },\n    };\n  }\n\n  async delegate(invitation: Invitation): Promise<PublicKey> {\n    invariant(this._spaceKey);\n    const space = this._spaceManager.spaces.get(this._spaceKey);\n    invariant(space);\n    if (invitation.authMethod === Invitation.AuthMethod.KNOWN_PUBLIC_KEY) {\n      invariant(invitation.guestKeypair?.publicKey);\n    }\n\n    log('writing delegate space invitation', { host: this._signingContext.deviceKey, id: invitation.invitationId });\n    const credential = await createDelegatedSpaceInvitationCredential(\n      this._signingContext.credentialSigner,\n      space.key,\n      {\n        invitationId: invitation.invitationId,\n        authMethod: invitation.authMethod,\n        swarmKey: invitation.swarmKey,\n        role: invitation.role ?? SpaceMember.Role.ADMIN,\n        expiresOn: computeExpirationTime(invitation),\n        multiUse: invitation.multiUse ?? false,\n        guestKey:\n          invitation.authMethod === Invitation.AuthMethod.KNOWN_PUBLIC_KEY\n            ? invitation.guestKeypair!.publicKey\n            : undefined,\n      },\n    );\n\n    invariant(credential.credential);\n    await writeMessages(space.inner.controlPipeline.writer, [credential]);\n    return credential.credential.credential.id!;\n  }\n\n  async cancelDelegation(invitation: Invitation): Promise<void> {\n    invariant(this._spaceKey);\n    invariant(invitation.type === Invitation.Type.DELEGATED && invitation.delegationCredentialId);\n    const space = this._spaceManager.spaces.get(this._spaceKey);\n    invariant(space);\n\n    log('cancelling delegated space invitation', { host: this._signingContext.deviceKey, id: invitation.invitationId });\n    const credential = await createCancelDelegatedSpaceInvitationCredential(\n      this._signingContext.credentialSigner,\n      space.key,\n      invitation.delegationCredentialId,\n    );\n\n    invariant(credential.credential);\n    await writeMessages(space.inner.controlPipeline.writer, [credential]);\n  }\n\n  checkInvitation(invitation: Partial<Invitation>): InvalidInvitationError | AlreadyJoinedError | undefined {\n    if (invitation.spaceKey == null) {\n      return new InvalidInvitationError('No spaceKey was provided for a space invitation.');\n    }\n    if (this._spaceManager.spaces.has(invitation.spaceKey)) {\n      return new AlreadyJoinedError('Already joined space.');\n    }\n  }\n\n  createIntroduction(): IntroductionRequest {\n    return {\n      profile: this._signingContext.getProfile(),\n    };\n  }\n\n  async createAdmissionRequest(): Promise<AdmissionRequest> {\n    // Generate a pair of keys for our feeds.\n    const controlFeedKey = await this._keyring.createKey();\n    const dataFeedKey = await this._keyring.createKey();\n\n    return {\n      space: {\n        identityKey: this._signingContext.identityKey,\n        deviceKey: this._signingContext.deviceKey,\n        controlFeedKey,\n        dataFeedKey,\n      },\n    };\n  }\n\n  async accept(response: AdmissionResponse): Promise<Partial<Invitation>> {\n    invariant(response.space);\n    const { credential, controlTimeframe, dataTimeframe } = response.space;\n    const assertion = getCredentialAssertion(credential);\n    invariant(assertion['@type'] === 'dxos.halo.credentials.SpaceMember', 'Invalid credential');\n    invariant(credential.subject.id.equals(this._signingContext.identityKey));\n\n    if (this._spaceManager.spaces.has(assertion.spaceKey)) {\n      throw new AlreadyJoinedError('Already joined space.');\n    }\n\n    // Create local space.\n    await this._spaceManager.acceptSpace({\n      spaceKey: assertion.spaceKey,\n      genesisFeedKey: assertion.genesisFeedKey,\n      controlTimeframe,\n      dataTimeframe,\n    });\n\n    await this._signingContext.recordCredential(credential);\n\n    return { spaceKey: assertion.spaceKey };\n  }\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { Event, PushStream, TimeoutError, Trigger } from '@dxos/async';\nimport {\n  AuthenticatingInvitation,\n  AUTHENTICATION_CODE_LENGTH,\n  CancellableInvitation,\n  INVITATION_TIMEOUT,\n} from '@dxos/client-protocol';\nimport { Context } from '@dxos/context';\nimport { generatePasscode } from '@dxos/credentials';\nimport { hasInvitationExpired, type MetadataStore } from '@dxos/echo-pipeline';\nimport { invariant } from '@dxos/invariant';\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport {\n  type AcceptInvitationRequest,\n  type AuthenticationRequest,\n  Invitation,\n} from '@dxos/protocols/proto/dxos/client/services';\nimport { SpaceMember } from '@dxos/protocols/proto/dxos/halo/credentials';\n\nimport type { InvitationProtocol } from './invitation-protocol';\nimport { createAdmissionKeypair, type InvitationsHandler } from './invitations-handler';\n\n/**\n * Entry point for creating and accepting invitations, keeps track of existing invitation set and\n * emits events when the set changes.\n */\nexport class InvitationsManager {\n  private readonly _createInvitations = new Map<string, CancellableInvitation>();\n  private readonly _acceptInvitations = new Map<string, AuthenticatingInvitation>();\n\n  public readonly invitationCreated = new Event<Invitation>();\n  public readonly invitationAccepted = new Event<Invitation>();\n  public readonly removedCreated = new Event<Invitation>();\n  public readonly removedAccepted = new Event<Invitation>();\n  public readonly saved = new Event<Invitation>();\n\n  private readonly _persistentInvitationsLoadedEvent = new Event();\n  private _persistentInvitationsLoaded = false;\n\n  constructor(\n    private readonly _invitationsHandler: InvitationsHandler,\n    private readonly _getHandler: (invitation: Partial<Invitation> & Pick<Invitation, 'kind'>) => InvitationProtocol,\n    private readonly _metadataStore: MetadataStore,\n  ) {}\n\n  async createInvitation(options: Partial<Invitation> & Pick<Invitation, 'kind'>): Promise<CancellableInvitation> {\n    if (options.invitationId) {\n      const existingInvitation = this._createInvitations.get(options.invitationId);\n      if (existingInvitation) {\n        return existingInvitation;\n      }\n    }\n\n    const handler = this._getHandler(options);\n    const invitationError = handler.checkCanInviteNewMembers();\n    if (invitationError != null) {\n      throw invitationError;\n    }\n    const invitation = this._createInvitation(handler, options);\n\n    const { ctx, stream, observableInvitation } = this._createObservableInvitation(handler, invitation);\n\n    this._createInvitations.set(invitation.invitationId, observableInvitation);\n    this.invitationCreated.emit(invitation);\n    // onComplete is called on cancel, expiration, or redemption of a single-use invitation\n    this._onInvitationComplete(observableInvitation, async () => {\n      this._createInvitations.delete(observableInvitation.get().invitationId);\n      this.removedCreated.emit(observableInvitation.get());\n      if (observableInvitation.get().persistent) {\n        await this._safeDeleteInvitation(observableInvitation.get());\n      }\n    });\n\n    try {\n      await this._persistIfRequired(handler, stream, invitation);\n    } catch (err) {\n      log.catch(err);\n      await observableInvitation.cancel();\n      return observableInvitation;\n    }\n\n    this._invitationsHandler.handleInvitationFlow(ctx, stream, handler, observableInvitation.get());\n\n    return observableInvitation;\n  }\n\n  async loadPersistentInvitations(): Promise<{ invitations: Invitation[] }> {\n    if (this._persistentInvitationsLoaded) {\n      const invitations = this.getCreatedInvitations().filter((i) => i.persistent);\n      return { invitations };\n    }\n    try {\n      const persistentInvitations = this._metadataStore.getInvitations();\n      // get saved persistent invitations, filter and remove from storage those that have expired.\n      const freshInvitations = persistentInvitations.filter((invitation) => !hasInvitationExpired(invitation));\n\n      const loadTasks = freshInvitations.map((persistentInvitation) => {\n        invariant(!this._createInvitations.get(persistentInvitation.invitationId), 'invitation already exists');\n        return this.createInvitation({ ...persistentInvitation, persistent: false });\n      });\n      const cInvitations = await Promise.all(loadTasks);\n\n      return { invitations: cInvitations.map((invitation) => invitation.get()) };\n    } catch (err) {\n      log.catch(err);\n      return { invitations: [] };\n    } finally {\n      this._persistentInvitationsLoadedEvent.emit();\n      this._persistentInvitationsLoaded = true;\n    }\n  }\n\n  acceptInvitation(request: AcceptInvitationRequest): AuthenticatingInvitation {\n    const options = request.invitation;\n    const existingInvitation = this._acceptInvitations.get(options.invitationId);\n    if (existingInvitation) {\n      return existingInvitation;\n    }\n\n    const handler = this._getHandler(options);\n    const { ctx, invitation, stream, otpEnteredTrigger } = this._createObservableAcceptingInvitation(handler, options);\n    this._invitationsHandler.acceptInvitation(ctx, stream, handler, options, otpEnteredTrigger, request.deviceProfile);\n    this._acceptInvitations.set(invitation.get().invitationId, invitation);\n    this.invitationAccepted.emit(invitation.get());\n\n    this._onInvitationComplete(invitation, () => {\n      this._acceptInvitations.delete(invitation.get().invitationId);\n      this.removedAccepted.emit(invitation.get());\n    });\n\n    return invitation;\n  }\n\n  async authenticate({ invitationId, authCode }: AuthenticationRequest): Promise<void> {\n    log('authenticating...');\n    invariant(invitationId);\n    const observable = this._acceptInvitations.get(invitationId);\n    if (!observable) {\n      log.warn('invalid invitation', { invitationId });\n    } else {\n      await observable.authenticate(authCode);\n    }\n  }\n\n  async cancelInvitation({ invitationId }: { invitationId: string }): Promise<void> {\n    log('cancelInvitation...', { invitationId });\n    invariant(invitationId);\n    const created = this._createInvitations.get(invitationId);\n    if (created) {\n      // remove from storage before modifying in-memory state, higher chance of failing\n      if (created.get().persistent) {\n        await this._metadataStore.removeInvitation(invitationId);\n      }\n      if (created.get().type === Invitation.Type.DELEGATED) {\n        const handler = this._getHandler(created.get());\n        await handler.cancelDelegation(created.get());\n      }\n      await created.cancel();\n      this._createInvitations.delete(invitationId);\n      this.removedCreated.emit(created.get());\n      return;\n    }\n\n    const accepted = this._acceptInvitations.get(invitationId);\n    if (accepted) {\n      await accepted.cancel();\n      this._acceptInvitations.delete(invitationId);\n      this.removedAccepted.emit(accepted.get());\n    }\n  }\n\n  getCreatedInvitations(): Invitation[] {\n    return [...this._createInvitations.values()].map((i) => i.get());\n  }\n\n  getAcceptedInvitations(): Invitation[] {\n    return [...this._acceptInvitations.values()].map((i) => i.get());\n  }\n\n  onPersistentInvitationsLoaded(ctx: Context, callback: () => void): void {\n    if (this._persistentInvitationsLoaded) {\n      callback();\n    } else {\n      this._persistentInvitationsLoadedEvent.once(ctx, () => callback());\n    }\n  }\n\n  private _createInvitation(protocol: InvitationProtocol, _options?: Partial<Invitation>): Invitation {\n    const {\n      invitationId = PublicKey.random().toHex(),\n      type = Invitation.Type.INTERACTIVE,\n      authMethod = Invitation.AuthMethod.SHARED_SECRET,\n      state = Invitation.State.INIT,\n      timeout = INVITATION_TIMEOUT,\n      swarmKey = PublicKey.random(),\n      persistent = _options?.authMethod !== Invitation.AuthMethod.KNOWN_PUBLIC_KEY, // default no not storing keypairs\n      created = new Date(),\n      guestKeypair = undefined,\n      role = SpaceMember.Role.ADMIN,\n      lifetime = 86400 * 7, // 7 days,\n      multiUse = false,\n      ...options\n    } = _options ?? {};\n    const authCode =\n      options?.authCode ??\n      (authMethod === Invitation.AuthMethod.SHARED_SECRET ? generatePasscode(AUTHENTICATION_CODE_LENGTH) : undefined);\n\n    return {\n      invitationId,\n      type,\n      authMethod,\n      state,\n      swarmKey,\n      authCode,\n      timeout,\n      persistent: persistent && type !== Invitation.Type.DELEGATED, // delegated invitations are persisted in control feed\n      guestKeypair:\n        guestKeypair ?? (authMethod === Invitation.AuthMethod.KNOWN_PUBLIC_KEY ? createAdmissionKeypair() : undefined),\n      created,\n      lifetime,\n      role,\n      multiUse,\n      delegationCredentialId: options?.delegationCredentialId,\n      ...options,\n      ...protocol.getInvitationContext(),\n    } satisfies Invitation;\n  }\n\n  private _createObservableInvitation(\n    handler: InvitationProtocol,\n    invitation: Invitation,\n  ): { ctx: Context; stream: PushStream<Invitation>; observableInvitation: CancellableInvitation } {\n    const stream = new PushStream<Invitation>();\n    const ctx = new Context({\n      onError: (err) => {\n        stream.error(err);\n        void ctx.dispose();\n      },\n    });\n    ctx.onDispose(() => {\n      log('complete', { ...handler.toJSON() });\n      stream.complete();\n    });\n    const observableInvitation = new CancellableInvitation({\n      initialInvitation: invitation,\n      subscriber: stream.observable,\n      onCancel: async () => {\n        stream.next({ ...invitation, state: Invitation.State.CANCELLED });\n        await ctx.dispose();\n      },\n    });\n    return { ctx, stream, observableInvitation };\n  }\n\n  private _createObservableAcceptingInvitation(\n    handler: InvitationProtocol,\n    initialState: Invitation,\n  ): {\n    ctx: Context;\n    invitation: AuthenticatingInvitation;\n    stream: PushStream<Invitation>;\n    otpEnteredTrigger: Trigger<string>;\n  } {\n    const otpEnteredTrigger = new Trigger<string>();\n    const stream = new PushStream<Invitation>();\n    const ctx = new Context({\n      onError: (err) => {\n        if (err instanceof TimeoutError) {\n          log('timeout', { ...handler.toJSON() });\n          stream.next({ ...initialState, state: Invitation.State.TIMEOUT });\n        } else {\n          log.warn('auth failed', err);\n          stream.next({ ...initialState, state: Invitation.State.ERROR });\n        }\n        void ctx.dispose();\n      },\n    });\n    ctx.onDispose(() => {\n      log('complete', { ...handler.toJSON() });\n      stream.complete();\n    });\n    const invitation = new AuthenticatingInvitation({\n      initialInvitation: initialState,\n      subscriber: stream.observable,\n      onCancel: async () => {\n        stream.next({ ...initialState, state: Invitation.State.CANCELLED });\n        await ctx.dispose();\n      },\n      onAuthenticate: async (code: string) => {\n        // TODO(burdon): Reset creates a race condition? Event?\n        otpEnteredTrigger.wake(code);\n      },\n    });\n    return { ctx, invitation, stream, otpEnteredTrigger };\n  }\n\n  private async _persistIfRequired(\n    handler: InvitationProtocol,\n    changeStream: PushStream<Invitation>,\n    invitation: Invitation,\n  ): Promise<void> {\n    if (invitation.type === Invitation.Type.DELEGATED && invitation.delegationCredentialId == null) {\n      const delegationCredentialId = await handler.delegate(invitation);\n      changeStream.next({ ...invitation, delegationCredentialId });\n    } else if (invitation.persistent) {\n      await this._metadataStore.addInvitation(invitation);\n      this.saved.emit(invitation);\n    }\n  }\n\n  private async _safeDeleteInvitation(invitation: Invitation): Promise<void> {\n    try {\n      await this._metadataStore.removeInvitation(invitation.invitationId);\n    } catch (err) {\n      log.catch(err);\n    }\n  }\n\n  private _onInvitationComplete(invitation: CancellableInvitation, callback: () => void): void {\n    invitation.subscribe(\n      () => {},\n      () => {},\n      callback,\n    );\n  }\n}\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { type FileHandle } from 'node:fs/promises';\n\nimport { invariant } from '@dxos/invariant';\nimport { LockFile } from '@dxos/lock-file';\nimport { log, logInfo } from '@dxos/log';\n\nimport { type ResourceLock, type ResourceLockOptions } from './resource-lock';\n\n// TODO(mykola): Factor out.\nexport class Lock implements ResourceLock {\n  private readonly _lockPath: string;\n  private readonly _onAcquire: ResourceLockOptions['onAcquire'];\n  private readonly _onRelease: ResourceLockOptions['onRelease'];\n  private _fileHandle?: FileHandle;\n\n  constructor({ lockKey: lockPath, onAcquire, onRelease }: ResourceLockOptions) {\n    this._lockPath = lockPath;\n    this._onAcquire = onAcquire;\n    this._onRelease = onRelease;\n  }\n\n  @logInfo\n  get lockKey() {\n    return this._lockPath;\n  }\n\n  async acquire(): Promise<void> {\n    log('acquiring lock...');\n    this._fileHandle = await LockFile.acquire(this._lockPath);\n\n    await this._onAcquire?.();\n\n    log('acquired lock');\n  }\n\n  async release(): Promise<void> {\n    await this._onRelease?.();\n    invariant(this._fileHandle, 'Lock is not acquired');\n    await LockFile.release(this._fileHandle);\n  }\n}\n\nexport const isLocked = (lockPath: string) => LockFile.isLocked(lockPath);\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { type ClientServices } from '@dxos/client-protocol';\nimport { type Any, type ServiceHandler, Stream } from '@dxos/codec-protobuf';\nimport { raise } from '@dxos/debug';\nimport { parseMethodName, RpcPeer, type RpcPeerOptions, type ServiceBundle } from '@dxos/rpc';\nimport { MapCounter, trace } from '@dxos/tracing';\nimport { type MaybePromise } from '@dxos/util';\n\nimport { type ServiceRegistry } from './service-registry';\n\nexport type ClientRpcServerParams = {\n  serviceRegistry: ServiceRegistry<ClientServices>;\n  handleCall?: (\n    method: string,\n    params: Any,\n    handler: (method: string, params: Any) => MaybePromise<Any>,\n  ) => Promise<Any>;\n  handleStream?: (\n    method: string,\n    params: Any,\n    handler: (method: string, params: Any) => Stream<Any>,\n  ) => MaybePromise<Stream<Any>>;\n} & Omit<RpcPeerOptions, 'callHandler' | 'streamHandler'>;\n\n@trace.resource()\nexport class ClientRpcServer {\n  private readonly _serviceRegistry: ServiceRegistry<ClientServices>;\n  private readonly _rpcPeer: RpcPeer;\n  private readonly _handlerCache = new Map<string, ServiceHandler<any>>();\n  private readonly _handleCall: ClientRpcServerParams['handleCall'];\n  private readonly _handleStream: ClientRpcServerParams['handleStream'];\n\n  @trace.metricsCounter()\n  private readonly _callMetrics = new MapCounter();\n\n  @trace.info()\n  private get _services() {\n    return Object.keys(this._serviceRegistry.services);\n  }\n\n  constructor(params: ClientRpcServerParams) {\n    const { serviceRegistry, handleCall, handleStream, ...rpcOptions } = params;\n    this._handleCall = handleCall;\n    this._handleStream = handleStream;\n\n    this._serviceRegistry = serviceRegistry;\n    this._rpcPeer = new RpcPeer({\n      ...rpcOptions,\n      callHandler: (method, params) => {\n        const [serviceName, methodName] = parseMethodName(method);\n        const handler = (method: string, params: Any) => this._getServiceHandler(serviceName).call(method, params);\n\n        this._callMetrics.inc(`${serviceName}.${methodName} request`);\n\n        if (this._handleCall) {\n          return this._handleCall(methodName, params, handler);\n        } else {\n          return handler(methodName, params);\n        }\n      },\n      streamHandler: (method, params) => {\n        const [serviceName, methodName] = parseMethodName(method);\n        const handler = (method: string, params: Any) =>\n          this._getServiceHandler(serviceName).callStream(method, params);\n\n        this._callMetrics.inc(`${serviceName}.${methodName} request stream`);\n\n        if (this._handleStream) {\n          return Stream.map(Stream.unwrapPromise(this._handleStream(methodName, params, handler)), (data) => {\n            this._callMetrics.inc(`${serviceName}.${methodName} response stream`);\n            return data;\n          });\n        } else {\n          return handler(methodName, params);\n        }\n      },\n    });\n  }\n\n  async open(): Promise<void> {\n    await this._rpcPeer.open();\n  }\n\n  async close(): Promise<void> {\n    await this._rpcPeer.close();\n  }\n\n  private _getServiceHandler(serviceName: string) {\n    if (!this._handlerCache.has(serviceName)) {\n      const [key, descriptor] =\n        Object.entries(this._serviceRegistry.descriptors as ServiceBundle<Record<string, any>>).find(\n          ([key, descriptor]) => descriptor.name === serviceName,\n        ) ?? raise(new Error(`Service not available: ${serviceName}`));\n\n      const service = this._serviceRegistry.services[key as keyof ClientServices] as any;\n      if (!service) {\n        throw new Error(`Service not available: ${serviceName}`);\n      }\n\n      this._handlerCache.set(serviceName, descriptor.createServer(service));\n    }\n\n    return this._handlerCache.get(serviceName)!;\n  }\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { DeferredTask, Event, scheduleTask, synchronized } from '@dxos/async';\nimport { Resource } from '@dxos/context';\nimport { type EdgeHttpClient } from '@dxos/edge-client';\nimport { invariant } from '@dxos/invariant';\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { EdgeAgentStatus, EdgeCallFailedError } from '@dxos/protocols';\nimport { SpaceState } from '@dxos/protocols/proto/dxos/client/services';\nimport { type Runtime } from '@dxos/protocols/proto/dxos/config';\nimport { EdgeReplicationSetting } from '@dxos/protocols/proto/dxos/echo/metadata';\n\nimport { type Identity } from '../identity';\nimport { type DataSpaceManager } from '../spaces';\n\nconst AGENT_STATUS_QUERY_RETRY_INTERVAL = 5000;\nconst AGENT_STATUS_QUERY_RETRY_JITTER = 1000;\nconst AGENT_FEED_ADDED_CHECK_INTERVAL_MS = 3000;\n\nexport type EdgeAgentManagerConfig = {};\n\nexport class EdgeAgentManager extends Resource {\n  public agentStatusChanged = new Event<EdgeAgentStatus>();\n\n  private _agentDeviceKey: PublicKey | undefined;\n  private _agentStatus: EdgeAgentStatus | undefined;\n\n  private _lastKnownDeviceCount = 0;\n\n  private _fetchAgentStatusTask: DeferredTask | undefined;\n\n  constructor(\n    private readonly _edgeFeatures: Runtime.Client.EdgeFeatures | undefined,\n    private readonly _edgeHttpClient: EdgeHttpClient | undefined,\n    private readonly _dataSpaceManager: DataSpaceManager,\n    private readonly _identity: Identity,\n  ) {\n    super();\n  }\n\n  public get agentStatus(): EdgeAgentStatus | undefined {\n    return this._agentStatus;\n  }\n\n  public get agentExists() {\n    return this._agentStatus && this._agentStatus !== EdgeAgentStatus.NOT_FOUND;\n  }\n\n  @synchronized\n  public async createAgent(): Promise<void> {\n    invariant(this.isOpen);\n    invariant(this._edgeHttpClient);\n    invariant(this._edgeFeatures?.agents);\n\n    const response = await this._edgeHttpClient.createAgent({\n      identityKey: this._identity.identityKey.toHex(),\n      haloSpaceId: this._identity.haloSpaceId,\n      haloSpaceKey: this._identity.haloSpaceKey.toHex(),\n    });\n\n    const deviceKey = PublicKey.fromHex(response.deviceKey);\n\n    if (await this._identity.authorizedDeviceKeys.has(deviceKey)) {\n      log.info('agent was already added to HALO, ignoring response', { response });\n      this._updateStatus(EdgeAgentStatus.ACTIVE, deviceKey);\n      return;\n    }\n\n    await this._identity.admitDevice({\n      deviceKey,\n      controlFeedKey: PublicKey.fromHex(response.feedKey),\n      // TODO: agents don't have data feed, should be removed\n      dataFeedKey: PublicKey.random(),\n    });\n\n    log('agent created', response);\n\n    this._updateStatus(EdgeAgentStatus.ACTIVE, deviceKey);\n  }\n\n  protected override async _open(): Promise<void> {\n    const isEnabled = this._edgeHttpClient && this._edgeFeatures?.agents;\n\n    log('edge agent manager open', { isEnabled });\n\n    if (!isEnabled) {\n      return;\n    }\n\n    this._lastKnownDeviceCount = this._identity.authorizedDeviceKeys.size;\n    this._fetchAgentStatusTask = new DeferredTask(this._ctx, async () => {\n      await this._fetchAgentStatus();\n    });\n    this._fetchAgentStatusTask.schedule();\n\n    this._dataSpaceManager.updated.on(this._ctx, () => {\n      if (this._agentDeviceKey) {\n        this._ensureAgentIsInSpaces(this._agentDeviceKey);\n      }\n    });\n\n    this._identity.stateUpdate.on(this._ctx, () => {\n      const maybeAgentWasCreated = this._identity.authorizedDeviceKeys.size > this._lastKnownDeviceCount;\n      if (this.agentExists || !maybeAgentWasCreated) {\n        return;\n      }\n      this._lastKnownDeviceCount = this._identity.authorizedDeviceKeys.size;\n      this._fetchAgentStatusTask?.schedule();\n    });\n  }\n\n  protected override async _close(): Promise<void> {\n    this._fetchAgentStatusTask = undefined;\n    this._lastKnownDeviceCount = 0;\n  }\n\n  protected async _fetchAgentStatus(): Promise<void> {\n    invariant(this._edgeHttpClient);\n    try {\n      log('fetching agent status');\n      const { agent } = await this._edgeHttpClient.getAgentStatus({ ownerIdentityKey: this._identity.identityKey });\n      const wasAgentCreatedDuringQuery = this._agentStatus === EdgeAgentStatus.ACTIVE;\n      if (!wasAgentCreatedDuringQuery) {\n        const deviceKey = agent.deviceKey ? PublicKey.fromHex(agent.deviceKey) : undefined;\n        this._updateStatus(agent.status, deviceKey);\n      }\n    } catch (err) {\n      if (err instanceof EdgeCallFailedError) {\n        if (!err.isRetryable) {\n          log.warn('non retryable error on agent status fetch attempt', { err });\n          return;\n        }\n      }\n      const retryAfterMs = AGENT_STATUS_QUERY_RETRY_INTERVAL + Math.random() * AGENT_STATUS_QUERY_RETRY_JITTER;\n      log.info('agent status fetching failed', { err, retryAfterMs });\n      scheduleTask(this._ctx, () => this._fetchAgentStatusTask?.schedule(), retryAfterMs);\n    }\n  }\n\n  /**\n   * We don't want notarization plugin to always actively poll edge looking for credentials to notarize,\n   * because most of the time we'll be getting an empty response.\n   * Instead, we stay in active polling mode while there are spaces where we don't see our agent's feed.\n   */\n  protected _ensureAgentIsInSpaces(agentDeviceKey: PublicKey): void {\n    let activePollingEnabled = false;\n    for (const space of this._dataSpaceManager.spaces.values()) {\n      if (space.getEdgeReplicationSetting() === EdgeReplicationSetting.DISABLED) {\n        space.notarizationPlugin.setActiveEdgePollingEnabled(false);\n        continue;\n      }\n      if ([SpaceState.SPACE_INACTIVE, SpaceState.SPACE_CLOSED].includes(space.state)) {\n        space.notarizationPlugin.setActiveEdgePollingEnabled(false);\n        continue;\n      }\n      const agentFeedNeedsNotarization = ![...space.inner.spaceState.feeds.values()].some((feed) =>\n        feed.assertion.deviceKey.equals(agentDeviceKey),\n      );\n      space.notarizationPlugin.setActiveEdgePollingEnabled(agentFeedNeedsNotarization);\n      activePollingEnabled = activePollingEnabled || agentFeedNeedsNotarization;\n\n      log.info('set active edge polling', { enabled: agentFeedNeedsNotarization, spaceId: space.id });\n    }\n\n    if (activePollingEnabled) {\n      // Check again to see if active edge polling can be disabled (agent feed is notarized in all the spaces)\n      scheduleTask(this._ctx, () => this._ensureAgentIsInSpaces(agentDeviceKey), AGENT_FEED_ADDED_CHECK_INTERVAL_MS);\n    }\n  }\n\n  private _updateStatus(status: EdgeAgentStatus, deviceKey: PublicKey | undefined): void {\n    this._agentStatus = status;\n    this._agentDeviceKey = deviceKey;\n    this.agentStatusChanged.emit(status);\n    if (deviceKey) {\n      this._ensureAgentIsInSpaces(deviceKey);\n    }\n    log.info('agent status update', { status });\n  }\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { Stream } from '@dxos/codec-protobuf/stream';\nimport { type EdgeConnection } from '@dxos/edge-client';\nimport { EdgeAgentStatus } from '@dxos/protocols';\nimport {\n  QueryAgentStatusResponse,\n  EdgeStatus,\n  type QueryEdgeStatusResponse,\n  type EdgeAgentService,\n} from '@dxos/protocols/proto/dxos/client/services';\n\nimport { type EdgeAgentManager } from './edge-agent-manager';\n\n// TODO(wittjosiah): This service is not currently exposed on the client api, it must be called directly.\nexport class EdgeAgentServiceImpl implements EdgeAgentService {\n  constructor(\n    private readonly _agentManagerProvider: () => Promise<EdgeAgentManager>,\n    private readonly _edgeConnection?: EdgeConnection,\n  ) {}\n\n  // TODO(mykola): Reconcile with NetworkService.queryStatus.\n  queryEdgeStatus(): Stream<QueryEdgeStatusResponse> {\n    return new Stream(({ ctx, next }) => {\n      const update = () => {\n        next({ status: this._edgeConnection?.status ?? EdgeStatus.NOT_CONNECTED });\n      };\n\n      this._edgeConnection?.statusChanged.on(ctx, update);\n      update();\n    });\n  }\n\n  async createAgent(): Promise<void> {\n    return (await this._agentManagerProvider()).createAgent();\n  }\n\n  queryAgentStatus(): Stream<QueryAgentStatusResponse> {\n    return new Stream(({ ctx, next }) => {\n      next({ status: QueryAgentStatusResponse.AgentStatus.UNKNOWN });\n      void this._agentManagerProvider().then((agentManager) => {\n        next({ status: mapStatus(agentManager.agentStatus) });\n        agentManager.agentStatusChanged.on(ctx, (newStatus) => {\n          next({ status: mapStatus(newStatus) });\n        });\n      });\n    });\n  }\n}\n\nconst mapStatus = (agentStatus: EdgeAgentStatus | undefined): QueryAgentStatusResponse.AgentStatus => {\n  switch (agentStatus) {\n    case EdgeAgentStatus.ACTIVE:\n      return QueryAgentStatusResponse.AgentStatus.ACTIVE;\n    case EdgeAgentStatus.INACTIVE:\n      return QueryAgentStatusResponse.AgentStatus.INACTIVE;\n    case EdgeAgentStatus.NOT_FOUND:\n      return QueryAgentStatusResponse.AgentStatus.NOT_FOUND;\n    case undefined:\n      return QueryAgentStatusResponse.AgentStatus.UNKNOWN;\n  }\n};\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { Mutex, Trigger } from '@dxos/async';\nimport { Context, Resource } from '@dxos/context';\nimport { getCredentialAssertion, type CredentialProcessor } from '@dxos/credentials';\nimport { failUndefined, warnAfterTimeout } from '@dxos/debug';\nimport {\n  EchoEdgeReplicator,\n  EchoHost,\n  MeshEchoReplicator,\n  MetadataStore,\n  SpaceManager,\n  valueEncoding,\n} from '@dxos/echo-pipeline';\nimport { createChainEdgeIdentity, createEphemeralEdgeIdentity } from '@dxos/edge-client';\nimport type { EdgeHttpClient, EdgeConnection, EdgeIdentity } from '@dxos/edge-client';\nimport { FeedFactory, FeedStore } from '@dxos/feed-store';\nimport { invariant } from '@dxos/invariant';\nimport { Keyring } from '@dxos/keyring';\nimport { PublicKey } from '@dxos/keys';\nimport { type LevelDB } from '@dxos/kv-store';\nimport { log } from '@dxos/log';\nimport { type SignalManager } from '@dxos/messaging';\nimport { type SwarmNetworkManager } from '@dxos/network-manager';\nimport { InvalidStorageVersionError, STORAGE_VERSION, trace } from '@dxos/protocols';\nimport { Invitation } from '@dxos/protocols/proto/dxos/client/services';\nimport { type Runtime } from '@dxos/protocols/proto/dxos/config';\nimport type { FeedMessage } from '@dxos/protocols/proto/dxos/echo/feed';\nimport { type Credential, type ProfileDocument } from '@dxos/protocols/proto/dxos/halo/credentials';\nimport { type Storage } from '@dxos/random-access-storage';\nimport { BlobStore } from '@dxos/teleport-extension-object-sync';\nimport { trace as Trace } from '@dxos/tracing';\nimport { safeInstanceof } from '@dxos/util';\n\nimport { EdgeAgentManager } from '../agents';\nimport {\n  IdentityManager,\n  type CreateIdentityOptions,\n  type IdentityManagerParams,\n  type JoinIdentityParams,\n} from '../identity';\nimport { EdgeIdentityRecoveryManager } from '../identity/identity-recovery-manager';\nimport {\n  DeviceInvitationProtocol,\n  type InvitationConnectionParams,\n  InvitationsHandler,\n  InvitationsManager,\n  SpaceInvitationProtocol,\n  type InvitationProtocol,\n} from '../invitations';\nimport { DataSpaceManager, type DataSpaceManagerRuntimeParams, type SigningContext } from '../spaces';\n\nexport type ServiceContextRuntimeParams = Pick<\n  IdentityManagerParams,\n  'devicePresenceOfflineTimeout' | 'devicePresenceAnnounceInterval'\n> &\n  DataSpaceManagerRuntimeParams & {\n    invitationConnectionDefaultParams?: InvitationConnectionParams;\n    disableP2pReplication?: boolean;\n    enableVectorIndexing?: boolean;\n  };\n/**\n * Shared backend for all client services.\n */\n// TODO(burdon): Rename/break-up into smaller components. And/or make members private.\n// TODO(dmaretskyi): Gets duplicated in CJS build between normal and testing bundles.\n@safeInstanceof('dxos.client-services.ServiceContext')\n@Trace.resource()\nexport class ServiceContext extends Resource {\n  private readonly _edgeIdentityUpdateMutex = new Mutex();\n\n  public readonly initialized = new Trigger();\n  public readonly metadataStore: MetadataStore;\n  public readonly blobStore: BlobStore;\n  public readonly feedStore: FeedStore<FeedMessage>;\n  public readonly keyring: Keyring;\n  public readonly spaceManager: SpaceManager;\n  public readonly identityManager: IdentityManager;\n  public readonly recoveryManager: EdgeIdentityRecoveryManager;\n  public readonly invitations: InvitationsHandler;\n  public readonly invitationsManager: InvitationsManager;\n  public readonly echoHost: EchoHost;\n  private readonly _meshReplicator?: MeshEchoReplicator = undefined;\n  private readonly _echoEdgeReplicator?: EchoEdgeReplicator = undefined;\n\n  // Initialized after identity is initialized.\n  public dataSpaceManager?: DataSpaceManager;\n  public edgeAgentManager?: EdgeAgentManager;\n\n  private readonly _handlerFactories = new Map<\n    Invitation.Kind,\n    (invitation: Partial<Invitation>) => InvitationProtocol\n  >();\n\n  private _deviceSpaceSync?: CredentialProcessor;\n\n  private readonly _instanceId = PublicKey.random().toHex();\n\n  constructor(\n    public readonly storage: Storage,\n    public readonly level: LevelDB,\n    public readonly networkManager: SwarmNetworkManager,\n    public readonly signalManager: SignalManager,\n    private readonly _edgeConnection: EdgeConnection | undefined,\n    private readonly _edgeHttpClient: EdgeHttpClient | undefined,\n    public readonly _runtimeParams?: ServiceContextRuntimeParams,\n    private readonly _edgeFeatures?: Runtime.Client.EdgeFeatures,\n  ) {\n    super();\n\n    // TODO(burdon): Move strings to constants.\n    this.metadataStore = new MetadataStore(storage.createDirectory('metadata'));\n    this.blobStore = new BlobStore(storage.createDirectory('blobs'));\n\n    this.keyring = new Keyring(storage.createDirectory('keyring'));\n    this.feedStore = new FeedStore<FeedMessage>({\n      factory: new FeedFactory<FeedMessage>({\n        root: storage.createDirectory('feeds'),\n        signer: this.keyring,\n        hypercore: {\n          valueEncoding,\n          stats: true,\n        },\n      }),\n    });\n\n    this.spaceManager = new SpaceManager({\n      feedStore: this.feedStore,\n      networkManager: this.networkManager,\n      blobStore: this.blobStore,\n      metadataStore: this.metadataStore,\n      disableP2pReplication: this._runtimeParams?.disableP2pReplication,\n    });\n\n    this.identityManager = new IdentityManager({\n      metadataStore: this.metadataStore,\n      keyring: this.keyring,\n      feedStore: this.feedStore,\n      spaceManager: this.spaceManager,\n      devicePresenceOfflineTimeout: this._runtimeParams?.devicePresenceOfflineTimeout,\n      devicePresenceAnnounceInterval: this._runtimeParams?.devicePresenceAnnounceInterval,\n      edgeConnection: this._edgeConnection,\n      edgeFeatures: this._edgeFeatures,\n    });\n\n    this.recoveryManager = new EdgeIdentityRecoveryManager(\n      this.keyring,\n      this._edgeHttpClient,\n      () => this.identityManager.identity,\n      this._acceptIdentity.bind(this),\n    );\n\n    this.echoHost = new EchoHost({\n      kv: this.level,\n      peerIdProvider: () => this.identityManager.identity?.deviceKey?.toHex(),\n      getSpaceKeyByRootDocumentId: (documentId) => this.spaceManager.findSpaceByRootDocumentId(documentId)?.key,\n      indexing: {\n        vector: this._runtimeParams?.enableVectorIndexing,\n      },\n    });\n\n    this._meshReplicator = new MeshEchoReplicator();\n\n    this.invitations = new InvitationsHandler(\n      this.networkManager, //\n      this._edgeHttpClient,\n      _runtimeParams?.invitationConnectionDefaultParams,\n    );\n    this.invitationsManager = new InvitationsManager(\n      this.invitations,\n      (invitation) => this.getInvitationHandler(invitation),\n      this.metadataStore,\n    );\n\n    // TODO(burdon): _initialize called in multiple places.\n    // TODO(burdon): Call _initialize on success.\n    this._handlerFactories.set(\n      Invitation.Kind.DEVICE,\n      () =>\n        new DeviceInvitationProtocol(\n          this.keyring,\n          () => this.identityManager.identity ?? failUndefined(),\n          this._acceptIdentity.bind(this),\n        ),\n    );\n\n    if (!this._runtimeParams?.disableP2pReplication) {\n      this._meshReplicator = new MeshEchoReplicator();\n    }\n    if (this._edgeConnection && this._edgeFeatures?.echoReplicator) {\n      this._echoEdgeReplicator = new EchoEdgeReplicator({\n        edgeConnection: this._edgeConnection,\n      });\n    }\n  }\n\n  @Trace.span()\n  protected override async _open(ctx: Context): Promise<void> {\n    await this._checkStorageVersion();\n\n    log('opening...');\n    log.trace('dxos.sdk.service-context.open', trace.begin({ id: this._instanceId }));\n\n    await this.identityManager.open(ctx);\n\n    await this._setNetworkIdentity();\n\n    await this._edgeConnection?.open();\n    await this.signalManager.open();\n    await this.networkManager.open();\n\n    await this.echoHost.open(ctx);\n\n    if (this._meshReplicator) {\n      await this.echoHost.addReplicator(this._meshReplicator);\n    }\n    if (this._echoEdgeReplicator) {\n      await this.echoHost.addReplicator(this._echoEdgeReplicator);\n    }\n\n    await this.metadataStore.load();\n    await this.spaceManager.open();\n\n    if (this.identityManager.identity) {\n      await this.identityManager.identity.joinNetwork();\n      await this._initialize(ctx);\n    }\n\n    const loadedInvitations = await this.invitationsManager.loadPersistentInvitations();\n    log('loaded persistent invitations', { count: loadedInvitations.invitations?.length });\n\n    log.trace('dxos.sdk.service-context.open', trace.end({ id: this._instanceId }));\n    log('opened');\n  }\n\n  protected override async _close(ctx: Context): Promise<void> {\n    log('closing...');\n    if (this._deviceSpaceSync && this.identityManager.identity) {\n      await this.identityManager.identity.space.spaceState.removeCredentialProcessor(this._deviceSpaceSync);\n    }\n    await this.dataSpaceManager?.close();\n    await this.edgeAgentManager?.close();\n    await this.identityManager.close();\n    await this.spaceManager.close();\n    await this.feedStore.close();\n    await this.metadataStore.close();\n\n    await this.echoHost.close(ctx);\n    await this.networkManager.close();\n    await this.signalManager.close();\n    await this._edgeConnection?.close();\n\n    log('closed');\n  }\n\n  async createIdentity(params: CreateIdentityOptions = {}) {\n    const identity = await this.identityManager.createIdentity(params);\n    await this._setNetworkIdentity();\n    await identity.joinNetwork();\n    await this._initialize(new Context());\n    return identity;\n  }\n\n  getInvitationHandler(invitation: Partial<Invitation> & Pick<Invitation, 'kind'>): InvitationProtocol {\n    if (this.identityManager.identity == null && invitation.kind === Invitation.Kind.SPACE) {\n      throw new Error('Identity must be created before joining a space.');\n    }\n    const factory = this._handlerFactories.get(invitation.kind);\n    invariant(factory, `Unknown invitation kind: ${invitation.kind}`);\n    return factory(invitation);\n  }\n\n  async broadcastProfileUpdate(profile: ProfileDocument | undefined): Promise<void> {\n    if (!profile || !this.dataSpaceManager) {\n      return;\n    }\n\n    for (const space of this.dataSpaceManager.spaces.values()) {\n      await space.updateOwnProfile(profile);\n    }\n  }\n\n  private async _acceptIdentity(params: JoinIdentityParams) {\n    const { identity, identityRecord } = await this.identityManager.prepareIdentity(params);\n    await this._setNetworkIdentity({ deviceCredential: params.authorizedDeviceCredential! });\n    await identity.joinNetwork();\n    await this.identityManager.acceptIdentity(identity, identityRecord, params.deviceProfile);\n    await this._initialize(new Context());\n    return identity;\n  }\n\n  private async _checkStorageVersion(): Promise<void> {\n    await this.metadataStore.load();\n    if (this.metadataStore.version !== STORAGE_VERSION) {\n      throw new InvalidStorageVersionError(STORAGE_VERSION, this.metadataStore.version);\n      // TODO(mykola): Migrate storage to a new version if incompatibility is detected.\n    }\n  }\n\n  // Called when identity is created.\n  @Trace.span()\n  private async _initialize(ctx: Context): Promise<void> {\n    log('initializing spaces...');\n    const identity = this.identityManager.identity ?? failUndefined();\n    const signingContext: SigningContext = {\n      credentialSigner: identity.getIdentityCredentialSigner(),\n      identityKey: identity.identityKey,\n      deviceKey: identity.deviceKey,\n      getProfile: () => identity.profileDocument,\n      recordCredential: async (credential) => {\n        await identity.controlPipeline.writer.write({ credential: { credential } });\n      },\n    };\n\n    this.dataSpaceManager = new DataSpaceManager({\n      spaceManager: this.spaceManager,\n      metadataStore: this.metadataStore,\n      keyring: this.keyring,\n      signingContext,\n      feedStore: this.feedStore,\n      echoHost: this.echoHost,\n      invitationsManager: this.invitationsManager,\n      edgeConnection: this._edgeConnection,\n      edgeHttpClient: this._edgeHttpClient,\n      echoEdgeReplicator: this._echoEdgeReplicator,\n      meshReplicator: this._meshReplicator,\n      runtimeParams: this._runtimeParams as DataSpaceManagerRuntimeParams,\n      edgeFeatures: this._edgeFeatures,\n    });\n    await this.dataSpaceManager.open();\n\n    this.edgeAgentManager = new EdgeAgentManager(\n      this._edgeFeatures,\n      this._edgeHttpClient,\n      this.dataSpaceManager,\n      identity,\n    );\n    await this.edgeAgentManager.open();\n\n    this._handlerFactories.set(Invitation.Kind.SPACE, (invitation) => {\n      invariant(this.dataSpaceManager, 'dataSpaceManager not initialized yet');\n      return new SpaceInvitationProtocol(this.dataSpaceManager, signingContext, this.keyring, invitation.spaceKey);\n    });\n    this.initialized.wake();\n\n    this._deviceSpaceSync = {\n      processCredential: async (credential: Credential) => {\n        const assertion = getCredentialAssertion(credential);\n        if (assertion['@type'] !== 'dxos.halo.credentials.SpaceMember') {\n          return;\n        }\n        if (assertion.spaceKey.equals(identity.space.key)) {\n          // ignore halo space\n          return;\n        }\n        if (!this.dataSpaceManager) {\n          log('dataSpaceManager not initialized yet, ignoring space admission', { details: assertion });\n          return;\n        }\n        if (this.dataSpaceManager.spaces.has(assertion.spaceKey)) {\n          log('space already exists, ignoring space admission', { details: assertion });\n          return;\n        }\n\n        try {\n          log('accepting space recorded in halo', { details: assertion });\n          await this.dataSpaceManager.acceptSpace({\n            spaceKey: assertion.spaceKey,\n            genesisFeedKey: assertion.genesisFeedKey,\n          });\n        } catch (err) {\n          log.catch(err);\n        }\n      },\n    };\n\n    await identity.space.spaceState.addCredentialProcessor(this._deviceSpaceSync);\n  }\n\n  private async _setNetworkIdentity(params?: { deviceCredential: Credential }): Promise<void> {\n    using _ = await this._edgeIdentityUpdateMutex.acquire();\n\n    let edgeIdentity: EdgeIdentity;\n    const identity = this.identityManager.identity;\n    if (identity) {\n      log('setting identity on edge connection', {\n        identity: identity.identityKey.toHex(),\n        swarms: this.networkManager.topics,\n      });\n\n      if (params?.deviceCredential) {\n        edgeIdentity = await createChainEdgeIdentity(\n          identity.signer,\n          identity.identityKey,\n          identity.deviceKey,\n          params?.deviceCredential && { credential: params.deviceCredential },\n          [], // TODO(dmaretskyi): Service access credentials.\n        );\n      } else {\n        // TODO: throw here or from identity if device chain can't be loaded, to avoid indefinite hangup\n        await warnAfterTimeout(10_000, 'Waiting for identity to be ready for edge connection', async () => {\n          await identity.ready();\n        });\n\n        invariant(identity.deviceCredentialChain);\n\n        edgeIdentity = await createChainEdgeIdentity(\n          identity.signer,\n          identity.identityKey,\n          identity.deviceKey,\n          identity.deviceCredentialChain,\n          [], // TODO(dmaretskyi): Service access credentials.\n        );\n      }\n    } else {\n      edgeIdentity = await createEphemeralEdgeIdentity();\n    }\n\n    this._edgeConnection?.setIdentity(edgeIdentity);\n    this._edgeHttpClient?.setIdentity(edgeIdentity);\n    this.networkManager.setPeerInfo({\n      identityKey: edgeIdentity.identityKey,\n      peerKey: edgeIdentity.peerKey,\n    });\n  }\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { generateSeedPhrase, keyPairFromSeedPhrase } from '@dxos/credentials';\nimport { sign } from '@dxos/crypto';\nimport { type EdgeHttpClient } from '@dxos/edge-client';\nimport { invariant } from '@dxos/invariant';\nimport { type Keyring } from '@dxos/keyring';\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport {\n  EdgeAuthChallengeError,\n  type RecoverIdentityRequest as EdgeRecoverIdentityRequest,\n  type RecoverIdentityResponseBody,\n} from '@dxos/protocols';\nimport { schema } from '@dxos/protocols/proto';\nimport {\n  type CreateRecoveryCredentialRequest,\n  type RecoverIdentityRequest,\n} from '@dxos/protocols/proto/dxos/client/services';\nimport { Timeframe } from '@dxos/timeframe';\n\nimport { type Identity } from './identity';\nimport { type JoinIdentityParams } from './identity-manager';\n\nexport class EdgeIdentityRecoveryManager {\n  constructor(\n    private readonly _keyring: Keyring,\n    private readonly _edgeClient: EdgeHttpClient | undefined,\n    private readonly _identityProvider: () => Identity | undefined,\n    private readonly _acceptRecoveredIdentity: (params: JoinIdentityParams) => Promise<Identity>,\n  ) {}\n\n  public async createRecoveryCredential({\n    data,\n  }: CreateRecoveryCredentialRequest): Promise<{ recoveryCode: string | undefined }> {\n    const identity = this._identityProvider();\n    invariant(identity);\n\n    let recoveryKey: PublicKey;\n    let lookupKey: PublicKey;\n    let algorithm: string;\n    let recoveryCode: string | undefined;\n    if (data) {\n      recoveryKey = data.recoveryKey;\n      lookupKey = data.lookupKey;\n      algorithm = data.algorithm;\n    } else {\n      recoveryCode = generateSeedPhrase();\n      const keypair = keyPairFromSeedPhrase(recoveryCode);\n      recoveryKey = PublicKey.from(keypair.publicKey);\n      lookupKey = PublicKey.from(keypair.publicKey);\n      algorithm = 'ED25519';\n    }\n\n    const identityKey = identity.identityKey;\n    const credential = await identity.getIdentityCredentialSigner().createCredential({\n      subject: identityKey,\n      assertion: {\n        '@type': 'dxos.halo.credentials.IdentityRecovery',\n        recoveryKey,\n        identityKey,\n        algorithm,\n        lookupKey,\n      },\n    });\n\n    const receipt = await identity.controlPipeline.writer.write({ credential: { credential } });\n    await identity.controlPipeline.state.waitUntilTimeframe(new Timeframe([[receipt.feedKey, receipt.seq]]));\n\n    return { recoveryCode };\n  }\n\n  public async requestRecoveryChallenge() {\n    invariant(this._edgeClient, 'Not connected to EDGE.');\n\n    const deviceKey = await this._keyring.createKey();\n    const controlFeedKey = await this._keyring.createKey();\n    const request: EdgeRecoverIdentityRequest = {\n      deviceKey: deviceKey.toHex(),\n      controlFeedKey: controlFeedKey.toHex(),\n    };\n\n    try {\n      await this._edgeClient.recoverIdentity(request);\n      throw new Error('No challenge received.');\n    } catch (error: any) {\n      if (!(error instanceof EdgeAuthChallengeError)) {\n        throw error;\n      }\n      return {\n        deviceKey,\n        controlFeedKey,\n        challenge: error.challenge,\n      };\n    }\n  }\n\n  public async recoverIdentityWithExternalSignature({\n    lookupKey,\n    deviceKey,\n    controlFeedKey,\n    signature,\n    clientDataJson,\n    authenticatorData,\n  }: RecoverIdentityRequest.ExternalSignature): Promise<void> {\n    invariant(this._edgeClient, 'Not connected to EDGE.');\n\n    const request: EdgeRecoverIdentityRequest = {\n      lookupKey: lookupKey.toHex(),\n      deviceKey: deviceKey.toHex(),\n      controlFeedKey: controlFeedKey.toHex(),\n      signature:\n        clientDataJson && authenticatorData\n          ? {\n              signature: Buffer.from(signature).toString('base64'),\n              clientDataJson: Buffer.from(clientDataJson).toString('base64'),\n              authenticatorData: Buffer.from(authenticatorData).toString('base64'),\n            }\n          : Buffer.from(signature).toString('base64'),\n    };\n\n    const response = await this._edgeClient.recoverIdentity(request);\n\n    await this._acceptRecoveredIdentity({\n      authorizedDeviceCredential: decodeCredential(response.deviceAuthCredential),\n      haloGenesisFeedKey: PublicKey.fromHex(response.genesisFeedKey),\n      haloSpaceKey: PublicKey.fromHex(response.haloSpaceKey),\n      identityKey: PublicKey.fromHex(response.identityKey),\n      deviceKey,\n      controlFeedKey,\n      dataFeedKey: await this._keyring.createKey(),\n    });\n  }\n\n  /**\n   * Recovery identity using an opaque token sent to the user's email.\n   */\n  public async recoverIdentityWithToken({ token }: { token: string }): Promise<void> {\n    invariant(this._edgeClient, 'Not connected to EDGE.');\n\n    const deviceKey = await this._keyring.createKey();\n    const controlFeedKey = await this._keyring.createKey();\n    const request: EdgeRecoverIdentityRequest = {\n      deviceKey: deviceKey.toHex(),\n      controlFeedKey: controlFeedKey.toHex(),\n      token,\n    };\n\n    const response = await this._edgeClient.recoverIdentity(request);\n\n    await this._acceptRecoveredIdentity({\n      authorizedDeviceCredential: decodeCredential(response.deviceAuthCredential),\n      haloGenesisFeedKey: PublicKey.fromHex(response.genesisFeedKey),\n      haloSpaceKey: PublicKey.fromHex(response.haloSpaceKey),\n      identityKey: PublicKey.fromHex(response.identityKey),\n      deviceKey,\n      controlFeedKey,\n      dataFeedKey: await this._keyring.createKey(),\n    });\n  }\n\n  public async recoverIdentity({ recoveryCode }: { recoveryCode: string }): Promise<void> {\n    invariant(this._edgeClient, 'Not connected to EDGE.');\n\n    const recoveryKeypair = keyPairFromSeedPhrase(recoveryCode);\n    const recoveryKey = PublicKey.from(recoveryKeypair.publicKey);\n    const deviceKey = await this._keyring.createKey();\n    const controlFeedKey = await this._keyring.createKey();\n    const request: EdgeRecoverIdentityRequest = {\n      lookupKey: recoveryKey.toHex(),\n      deviceKey: deviceKey.toHex(),\n      controlFeedKey: controlFeedKey.toHex(),\n    };\n\n    let response: RecoverIdentityResponseBody;\n    try {\n      response = await this._edgeClient.recoverIdentity(request);\n    } catch (error: any) {\n      if (!(error instanceof EdgeAuthChallengeError)) {\n        throw error;\n      }\n      const signature = sign(Buffer.from(error.challenge, 'base64'), recoveryKeypair.secretKey);\n      response = await this._edgeClient.recoverIdentity({\n        ...request,\n        signature: Buffer.from(signature).toString('base64'),\n      });\n    }\n\n    log.info('recovering identity', response);\n\n    await this._acceptRecoveredIdentity({\n      authorizedDeviceCredential: decodeCredential(response.deviceAuthCredential),\n      haloGenesisFeedKey: PublicKey.fromHex(response.genesisFeedKey),\n      haloSpaceKey: PublicKey.fromHex(response.haloSpaceKey),\n      identityKey: PublicKey.fromHex(response.identityKey),\n      deviceKey,\n      controlFeedKey,\n      dataFeedKey: await this._keyring.createKey(),\n    });\n  }\n}\n\nconst decodeCredential = (credentialBase64: string) => {\n  const credentialBytes = Buffer.from(credentialBase64, 'base64');\n  const codec = schema.getCodecForType('dxos.halo.credentials.Credential');\n  return codec.decode(credentialBytes);\n};\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { type ServiceBundle } from '@dxos/rpc';\n\n/**\n * Registry of operational services.\n */\nexport class ServiceRegistry<Services> {\n  // prettier-ignore\n  constructor (\n    private readonly _serviceBundle: ServiceBundle<Services>,\n    private _handlers: Partial<Services> = {}\n  ) {}\n\n  get descriptors() {\n    return this._serviceBundle;\n  }\n\n  get services() {\n    return this._handlers;\n  }\n\n  setServices(services: Partial<Services>): void {\n    this._handlers = services;\n  }\n\n  addService(name: keyof Services, service: Services[keyof Services]): void {\n    this._handlers[name] = service;\n  }\n\n  removeService(name: keyof Services): void {\n    delete this._handlers[name];\n  }\n}\n", "//\n\n//\n// Copyright 2023 DXOS.org\n//\n\nimport { InvalidConfigError } from '@dxos/protocols';\nimport { Runtime } from '@dxos/protocols/proto/dxos/config';\nimport { createStorage, StorageType } from '@dxos/random-access-storage';\n\nimport StorageDriver = Runtime.Client.Storage.StorageDriver;\nimport { getRootPath } from './util';\n\n// TODO(burdon): Factor out.\nexport const createStorageObjects = (config: Runtime.Client.Storage) => {\n  const { persistent = false, keyStore, dataStore } = config ?? {};\n  if (persistent && dataStore === StorageDriver.RAM) {\n    throw new InvalidConfigError('RAM storage cannot be used in persistent mode.');\n  }\n  if (!persistent && dataStore !== undefined && dataStore !== StorageDriver.RAM) {\n    throw new InvalidConfigError('Cannot use a persistent storage in not persistent mode.');\n  }\n  if (persistent && keyStore === StorageDriver.RAM) {\n    throw new InvalidConfigError('RAM key storage cannot be used in persistent mode.');\n  }\n  if (!persistent && keyStore !== StorageDriver.RAM && keyStore !== undefined) {\n    throw new InvalidConfigError('Cannot use a persistent key storage in not persistent mode.');\n  }\n\n  return {\n    storage: createStorage({\n      type: persistent ? toStorageType(dataStore) : StorageType.RAM,\n      root: getRootPath(config),\n    }),\n  };\n};\n\nconst toStorageType = (type: StorageDriver | undefined): StorageType | undefined => {\n  switch (type) {\n    case undefined:\n      return undefined;\n    case StorageDriver.RAM:\n      return StorageType.RAM;\n    case StorageDriver.CHROME:\n      return StorageType.CHROME;\n    case StorageDriver.FIREFOX:\n      return StorageType.FIREFOX;\n    case StorageDriver.IDB:\n      return StorageType.IDB;\n    case StorageDriver.NODE:\n      return StorageType.NODE;\n    case StorageDriver.WEBFS:\n      return StorageType.WEBFS;\n    default:\n      throw new Error(`Invalid storage type: ${StorageDriver[type]}`);\n  }\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { DX_DATA } from '@dxos/client-protocol';\nimport { Runtime } from '@dxos/protocols/proto/dxos/config';\nimport { isNode } from '@dxos/util';\n\nexport const getRootPath = (config: Runtime.Client.Storage) => {\n  const { dataRoot = isNode() ? DX_DATA : 'dxos/storage' } = config ?? {};\n  return `${dataRoot}/`;\n};\n\nexport const isPersistent = (config: Runtime.Client.Storage) => {\n  const { persistent = false } = config ?? {};\n  return (\n    (config.dataStore !== undefined && config.dataStore !== Runtime.Client.Storage.StorageDriver.RAM) || persistent\n  );\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport path from 'node:path';\n\nimport { PublicKey } from '@dxos/keys';\nimport { createLevel as createKV } from '@dxos/kv-store';\nimport { type Runtime } from '@dxos/protocols/proto/dxos/config';\n\nimport { getRootPath, isPersistent } from './util';\n\nexport const createLevel = async (config: Runtime.Client.Storage) => {\n  const persistent = isPersistent(config);\n  const storagePath = persistent ? path.join(getRootPath(config), 'level') : `/tmp/dxos-${PublicKey.random().toHex()}`;\n  const level = createKV(storagePath);\n  // TODO(dmaretskyi): This function shouldn't call open - .\n  await level.open();\n  return level;\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { cbor } from '@automerge/automerge-repo';\n\nimport { invariant } from '@dxos/invariant';\nimport type { LevelDB } from '@dxos/kv-store';\nimport { log } from '@dxos/log';\nimport { ProfileArchiveEntryType, type ProfileArchive } from '@dxos/protocols';\nimport type { Storage } from '@dxos/random-access-storage';\nimport { arrayToBuffer } from '@dxos/util';\n\nexport const encodeProfileArchive = (profile: ProfileArchive): Uint8Array => cbor.encode(profile);\n\nexport const decodeProfileArchive = (data: Uint8Array): ProfileArchive => cbor.decode(data);\n\nexport const exportProfileData = async ({\n  storage,\n  level,\n}: {\n  storage: Storage;\n  level: LevelDB;\n}): Promise<ProfileArchive> => {\n  const archive: ProfileArchive = { storage: [], meta: { timestamp: new Date().toISOString() } };\n\n  {\n    const directory = await storage.createDirectory();\n    const files = await directory.list();\n\n    log.info('begin exporting files', { count: files.length });\n    for (const filename of files) {\n      const file = await directory.getOrCreateFile(filename);\n      const { size } = await file.stat();\n      const data = await file.read(0, size);\n      archive.storage.push({\n        type: ProfileArchiveEntryType.FILE,\n        key: filename,\n        value: data,\n      });\n    }\n    log.info('done exporting files', { count: files.length });\n  }\n\n  {\n    log.info('begin exporting kv pairs');\n    const iter = await level.iterator<Uint8Array, Uint8Array>({ keyEncoding: 'binary', valueEncoding: 'binary' });\n    let count = 0;\n    for await (const [key, value] of iter) {\n      archive.storage.push({\n        type: ProfileArchiveEntryType.KEY_VALUE,\n        key,\n        value,\n      });\n      count++;\n    }\n    log.info('done exporting kv pairs', { count });\n  }\n\n  return archive;\n};\n\nexport const importProfileData = async (\n  {\n    storage,\n    level,\n  }: {\n    storage: Storage;\n    level: LevelDB;\n  },\n  archive: ProfileArchive,\n): Promise<void> => {\n  let batch = level.batch();\n\n  let count = 0;\n  for (const entry of archive.storage) {\n    switch (entry.type) {\n      case ProfileArchiveEntryType.FILE: {\n        const directory = await storage.createDirectory();\n        invariant(typeof entry.key === 'string', 'Invalid key type');\n        const file = await directory.getOrCreateFile(entry.key);\n        invariant(entry.value instanceof Uint8Array, 'Invalid value type');\n        await file.write(0, arrayToBuffer(entry.value));\n        await file.close();\n        break;\n      }\n      case ProfileArchiveEntryType.KEY_VALUE: {\n        invariant(entry.key instanceof Uint8Array, 'Invalid key type');\n        invariant(entry.value instanceof Uint8Array, 'Invalid value type');\n        batch.put(entry.key, entry.value, { keyEncoding: 'binary', valueEncoding: 'binary' });\n        break;\n      }\n      default:\n        throw new Error(`Invalid entry type: ${entry.type}`);\n    }\n\n    if (++count % 1000 === 0) {\n      // Apparently indexedDB can't handle big batches.\n      await batch.write();\n      batch = level.batch();\n\n      log.info('importing', {\n        count,\n        total: archive.storage.length,\n        progress: `${((count / archive.storage.length) * 100).toFixed()}%`,\n      });\n    }\n  }\n\n  log.info('committing changes..');\n  await batch.write();\n};\n", "//\n// Copyright 2021 DXOS.org\n//\n\nimport { Event, synchronized } from '@dxos/async';\nimport { clientServiceBundle, type ClientServices } from '@dxos/client-protocol';\nimport { type Config } from '@dxos/config';\nimport { Context } from '@dxos/context';\nimport { EdgeClient, EdgeHttpClient, createStubEdgeIdentity, type EdgeConnection } from '@dxos/edge-client';\nimport { invariant } from '@dxos/invariant';\nimport { PublicKey } from '@dxos/keys';\nimport { type LevelDB } from '@dxos/kv-store';\nimport { log } from '@dxos/log';\nimport { EdgeSignalManager, WebsocketSignalManager, type SignalManager } from '@dxos/messaging';\nimport {\n  SwarmNetworkManager,\n  createIceProvider,\n  createRtcTransportFactory,\n  type TransportFactory,\n} from '@dxos/network-manager';\nimport { trace } from '@dxos/protocols';\nimport { SystemStatus } from '@dxos/protocols/proto/dxos/client/services';\nimport { type Storage } from '@dxos/random-access-storage';\nimport { TRACE_PROCESSOR, trace as Trace } from '@dxos/tracing';\nimport { WebsocketRpcClient } from '@dxos/websocket-rpc';\n\nimport { ServiceContext, type ServiceContextRuntimeParams } from './service-context';\nimport { ServiceRegistry } from './service-registry';\nimport { EdgeAgentServiceImpl } from '../agents';\nimport { DevicesServiceImpl } from '../devices';\nimport { DevtoolsHostEvents, DevtoolsServiceImpl } from '../devtools';\nimport {\n  createCollectDiagnosticsBroadcastHandler,\n  createDiagnostics,\n  type CollectDiagnosticsBroadcastHandler,\n} from '../diagnostics';\nimport { IdentityServiceImpl, type CreateIdentityOptions } from '../identity';\nimport { ContactsServiceImpl } from '../identity/contacts-service';\nimport { InvitationsServiceImpl } from '../invitations';\nimport { Lock, type ResourceLock } from '../locks';\nimport { LoggingServiceImpl } from '../logging';\nimport { NetworkServiceImpl } from '../network';\nimport { SpacesServiceImpl } from '../spaces';\nimport { createLevel, createStorageObjects } from '../storage';\nimport { SystemServiceImpl } from '../system';\n\nexport type ClientServicesHostParams = {\n  /**\n   * Can be omitted if `initialize` is later called.\n   */\n  config?: Config;\n  transportFactory?: TransportFactory;\n  signalManager?: SignalManager;\n  connectionLog?: boolean;\n  storage?: Storage;\n  level?: LevelDB;\n  lockKey?: string;\n  callbacks?: ClientServicesHostCallbacks;\n  runtimeParams?: ServiceContextRuntimeParams;\n};\n\nexport type ClientServicesHostCallbacks = {\n  onReset?: () => Promise<void>;\n};\n\nexport type InitializeOptions = {\n  config?: Config;\n  transportFactory?: TransportFactory;\n  signalManager?: SignalManager;\n  connectionLog?: boolean;\n};\n\n/**\n * Remote service implementation.\n */\n@Trace.resource()\nexport class ClientServicesHost {\n  private readonly _resourceLock?: ResourceLock;\n  private readonly _serviceRegistry: ServiceRegistry<ClientServices>;\n  private readonly _systemService: SystemServiceImpl;\n  private readonly _loggingService: LoggingServiceImpl;\n  private readonly _tracingService = TRACE_PROCESSOR.createTraceSender();\n\n  private _config?: Config;\n  private readonly _statusUpdate = new Event<void>();\n  private _signalManager?: SignalManager;\n  private _networkManager?: SwarmNetworkManager;\n  private _storage?: Storage;\n  private _level?: LevelDB;\n  private _callbacks?: ClientServicesHostCallbacks;\n  private _devtoolsProxy?: WebsocketRpcClient<{}, ClientServices>;\n  private _edgeConnection?: EdgeConnection = undefined;\n  private _edgeHttpClient?: EdgeHttpClient = undefined;\n\n  private _serviceContext!: ServiceContext;\n  private readonly _runtimeParams: ServiceContextRuntimeParams;\n  private diagnosticsBroadcastHandler: CollectDiagnosticsBroadcastHandler;\n\n  @Trace.info()\n  private _opening = false;\n\n  @Trace.info()\n  private _open = false;\n\n  @Trace.info()\n  private _resetting = false;\n\n  constructor({\n    config,\n    transportFactory,\n    signalManager,\n    storage,\n    level,\n    // TODO(wittjosiah): Turn this on by default.\n    lockKey,\n    callbacks,\n    runtimeParams,\n  }: ClientServicesHostParams = {}) {\n    this._storage = storage;\n    this._level = level;\n    this._callbacks = callbacks;\n    this._runtimeParams = runtimeParams ?? {};\n\n    if (this._runtimeParams.disableP2pReplication === undefined) {\n      this._runtimeParams.disableP2pReplication = config?.get('runtime.client.disableP2pReplication', false);\n    }\n\n    if (this._runtimeParams.enableVectorIndexing === undefined) {\n      this._runtimeParams.enableVectorIndexing = config?.get('runtime.client.enableVectorIndexing', false);\n    }\n\n    if (config) {\n      this.initialize({ config, transportFactory, signalManager });\n    }\n\n    if (lockKey) {\n      this._resourceLock = new Lock({\n        lockKey,\n        onAcquire: () => {\n          if (!this._opening) {\n            void this.open(new Context());\n          }\n        },\n        onRelease: () => this.close(),\n      });\n    }\n\n    // TODO(wittjosiah): If config is not defined here, system service will always have undefined config.\n    this._systemService = new SystemServiceImpl({\n      config: () => this._config,\n      statusUpdate: this._statusUpdate,\n      getCurrentStatus: () => (this.isOpen && !this._resetting ? SystemStatus.ACTIVE : SystemStatus.INACTIVE),\n      getDiagnostics: () => {\n        return createDiagnostics(this._serviceRegistry.services, this._serviceContext, this._config!);\n      },\n      onUpdateStatus: async (status: SystemStatus) => {\n        if (!this.isOpen && status === SystemStatus.ACTIVE) {\n          await this._resourceLock?.acquire();\n        } else if (this.isOpen && status === SystemStatus.INACTIVE) {\n          await this._resourceLock?.release();\n        }\n      },\n      onReset: async () => {\n        await this.reset();\n      },\n    });\n\n    this.diagnosticsBroadcastHandler = createCollectDiagnosticsBroadcastHandler(this._systemService);\n    this._loggingService = new LoggingServiceImpl();\n\n    this._serviceRegistry = new ServiceRegistry<ClientServices>(clientServiceBundle, {\n      SystemService: this._systemService,\n      TracingService: this._tracingService,\n    });\n  }\n\n  get isOpen() {\n    return this._open;\n  }\n\n  get config() {\n    return this._config;\n  }\n\n  get context() {\n    return this._serviceContext;\n  }\n\n  get serviceRegistry() {\n    return this._serviceRegistry;\n  }\n\n  get descriptors() {\n    return this._serviceRegistry.descriptors;\n  }\n\n  get services() {\n    return this._serviceRegistry.services;\n  }\n\n  /**\n   * Initialize the service host with the config.\n   * Config can also be provided in the constructor.\n   * Can only be called once.\n   */\n  initialize({ config, ...options }: InitializeOptions): void {\n    invariant(!this._open, 'service host is open');\n    log('initializing...');\n\n    if (config) {\n      invariant(!this._config, 'config already set');\n      this._config = config;\n      if (!this._storage) {\n        this._storage = createStorageObjects(config.get('runtime.client.storage', {})!).storage;\n      }\n    }\n\n    if (!options.signalManager) {\n      log.warn('running signaling without telemetry metadata.');\n    }\n\n    const edgeEndpoint = config?.get('runtime.services.edge.url');\n    if (edgeEndpoint) {\n      this._edgeConnection = new EdgeClient(createStubEdgeIdentity(), { socketEndpoint: edgeEndpoint });\n      this._edgeHttpClient = new EdgeHttpClient(edgeEndpoint);\n    }\n\n    const {\n      connectionLog = true,\n      transportFactory = createRtcTransportFactory(\n        { iceServers: this._config?.get('runtime.services.ice') },\n        this._config?.get('runtime.services.iceProviders') &&\n          createIceProvider(this._config!.get('runtime.services.iceProviders')!),\n      ),\n      signalManager = this._edgeConnection && this._config?.get('runtime.client.edgeFeatures')?.signaling\n        ? new EdgeSignalManager({ edgeConnection: this._edgeConnection })\n        : new WebsocketSignalManager(this._config?.get('runtime.services.signaling') ?? []),\n    } = options;\n    this._signalManager = signalManager;\n\n    invariant(!this._networkManager, 'network manager already set');\n    this._networkManager = new SwarmNetworkManager({\n      enableDevtoolsLogging: connectionLog,\n      transportFactory,\n      signalManager,\n      peerInfo: this._edgeConnection\n        ? {\n            identityKey: this._edgeConnection.identityKey,\n            peerKey: this._edgeConnection.peerKey,\n          }\n        : undefined,\n    });\n\n    log('initialized');\n  }\n\n  @synchronized\n  @Trace.span()\n  async open(ctx: Context): Promise<void> {\n    if (this._open) {\n      return;\n    }\n\n    const traceId = PublicKey.random().toHex();\n    log.trace('dxos.client-services.host.open', trace.begin({ id: traceId }));\n\n    invariant(this._config, 'config not set');\n    invariant(this._storage, 'storage not set');\n    invariant(this._signalManager, 'signal manager not set');\n    invariant(this._networkManager, 'network manager not set');\n\n    this._opening = true;\n    log('opening...', { lockKey: this._resourceLock?.lockKey });\n\n    await this._resourceLock?.acquire();\n\n    if (!this._level) {\n      this._level = await createLevel(this._config.get('runtime.client.storage', {})!);\n    }\n    await this._level.open();\n\n    await this._loggingService.open();\n\n    this._serviceContext = new ServiceContext(\n      this._storage,\n      this._level,\n      this._networkManager,\n      this._signalManager,\n      this._edgeConnection,\n      this._edgeHttpClient,\n      this._runtimeParams,\n      this._config.get('runtime.client.edgeFeatures'),\n    );\n\n    const dataSpaceManagerProvider = async () => {\n      await this._serviceContext.initialized.wait();\n      return this._serviceContext.dataSpaceManager!;\n    };\n\n    const agentManagerProvider = async () => {\n      await this._serviceContext.initialized.wait();\n      return this._serviceContext.edgeAgentManager!;\n    };\n\n    const identityService = new IdentityServiceImpl(\n      this._serviceContext.identityManager,\n      this._serviceContext.recoveryManager,\n      this._serviceContext.keyring,\n      () => this._serviceContext.dataSpaceManager!,\n      (params) => this._createIdentity(params),\n      (profile) => this._serviceContext.broadcastProfileUpdate(profile),\n    );\n\n    this._serviceRegistry.setServices({\n      SystemService: this._systemService,\n      IdentityService: identityService,\n      ContactsService: new ContactsServiceImpl(\n        this._serviceContext.identityManager,\n        this._serviceContext.spaceManager,\n        dataSpaceManagerProvider,\n      ),\n\n      InvitationsService: new InvitationsServiceImpl(this._serviceContext.invitationsManager),\n\n      DevicesService: new DevicesServiceImpl(this._serviceContext.identityManager, this._edgeConnection),\n\n      SpacesService: new SpacesServiceImpl(\n        this._serviceContext.identityManager,\n        this._serviceContext.spaceManager,\n        dataSpaceManagerProvider,\n      ),\n\n      DataService: this._serviceContext.echoHost.dataService,\n      QueryService: this._serviceContext.echoHost.queryService,\n\n      NetworkService: new NetworkServiceImpl(\n        this._serviceContext.networkManager,\n        this._serviceContext.signalManager,\n        this._edgeConnection,\n      ),\n\n      LoggingService: this._loggingService,\n      TracingService: this._tracingService,\n\n      // TODO(burdon): Move to new protobuf definitions.\n      DevtoolsHost: new DevtoolsServiceImpl({\n        events: new DevtoolsHostEvents(),\n        config: this._config,\n        context: this._serviceContext,\n      }),\n\n      EdgeAgentService: new EdgeAgentServiceImpl(agentManagerProvider, this._edgeConnection),\n    });\n\n    await this._serviceContext.open(ctx);\n    await identityService.open();\n\n    const devtoolsProxy = this._config?.get('runtime.client.devtoolsProxy');\n    if (devtoolsProxy) {\n      this._devtoolsProxy = new WebsocketRpcClient({\n        url: devtoolsProxy,\n        requested: {},\n        exposed: clientServiceBundle,\n        handlers: this.services as ClientServices,\n      });\n      void this._devtoolsProxy.open();\n    }\n    this.diagnosticsBroadcastHandler.start();\n\n    this._opening = false;\n    this._open = true;\n    this._statusUpdate.emit();\n    const deviceKey = this._serviceContext.identityManager.identity?.deviceKey;\n    log('opened', { deviceKey });\n    log.trace('dxos.client-services.host.open', trace.end({ id: traceId }));\n  }\n\n  @synchronized\n  @Trace.span()\n  async close(): Promise<void> {\n    if (!this._open) {\n      return;\n    }\n\n    const deviceKey = this._serviceContext.identityManager.identity?.deviceKey;\n    log('closing...', { deviceKey });\n    this.diagnosticsBroadcastHandler.stop();\n    await this._devtoolsProxy?.close();\n    this._serviceRegistry.setServices({ SystemService: this._systemService });\n    await this._loggingService.close();\n    await this._serviceContext.close();\n    await this._level?.close();\n    this._open = false;\n    this._statusUpdate.emit();\n    log('closed', { deviceKey });\n  }\n\n  async reset(): Promise<void> {\n    const traceId = PublicKey.random().toHex();\n    log.trace('dxos.sdk.client-services-host.reset', trace.begin({ id: traceId }));\n\n    log.info('resetting...');\n    // Emit this status update immediately so app returns to fallback.\n    // This state is never cleared because the app reloads.\n    this._resetting = true;\n    this._statusUpdate.emit();\n    await this._serviceContext?.close();\n    await this._storage!.reset();\n    log.info('reset');\n    log.trace('dxos.sdk.client-services-host.reset', trace.end({ id: traceId }));\n    await this._callbacks?.onReset?.();\n  }\n\n  private async _createIdentity(params: CreateIdentityOptions) {\n    const identity = await this._serviceContext.createIdentity(params);\n    await this._serviceContext.initialized.wait();\n    return identity;\n  }\n}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { SubscriptionList } from '@dxos/async';\nimport { Stream } from '@dxos/codec-protobuf/stream';\nimport { type EdgeConnection } from '@dxos/edge-client';\nimport { invariant } from '@dxos/invariant';\nimport {\n  Device,\n  DeviceKind,\n  EdgeStatus,\n  type DevicesService,\n  type QueryDevicesResponse,\n} from '@dxos/protocols/proto/dxos/client/services';\nimport { type DeviceProfileDocument } from '@dxos/protocols/proto/dxos/halo/credentials';\n\nimport { type IdentityManager } from '../identity';\n\nexport class DevicesServiceImpl implements DevicesService {\n  constructor(\n    private readonly _identityManager: IdentityManager,\n    private readonly _edgeConnection?: EdgeConnection,\n  ) {}\n\n  async updateDevice(profile: DeviceProfileDocument): Promise<Device> {\n    return this._identityManager.updateDeviceProfile(profile);\n  }\n\n  queryDevices(): Stream<QueryDevicesResponse> {\n    return new Stream(({ next }) => {\n      const update = () => {\n        const deviceKeys = this._identityManager.identity?.authorizedDeviceKeys;\n        if (!deviceKeys) {\n          next({ devices: [] });\n        } else {\n          invariant(this._identityManager.identity?.presence, 'presence not present');\n          const peers = this._identityManager.identity.presence.getPeersOnline();\n          next({\n            devices: Array.from(deviceKeys.entries()).map(([key, profile]) => {\n              const isMe = this._identityManager.identity?.deviceKey.equals(key);\n              let presence;\n              if (isMe) {\n                presence = Device.PresenceState.ONLINE;\n              } else if (profile.os?.toUpperCase() === 'EDGE') {\n                presence =\n                  this._edgeConnection?.status === EdgeStatus.CONNECTED\n                    ? Device.PresenceState.ONLINE\n                    : Device.PresenceState.OFFLINE;\n              } else {\n                presence = peers.some((peer) => peer.identityKey.equals(key))\n                  ? Device.PresenceState.ONLINE\n                  : Device.PresenceState.OFFLINE;\n              }\n\n              return {\n                deviceKey: key,\n                kind: this._identityManager.identity?.deviceKey.equals(key) ? DeviceKind.CURRENT : DeviceKind.TRUSTED,\n                profile,\n                presence,\n              };\n            }),\n          });\n        }\n      };\n\n      let identitySubscribed = false;\n      let presenceSubscribed = false;\n      const subscribeIdentity = () => {\n        if (!identitySubscribed) {\n          this._identityManager.identity?.stateUpdate.on(() => {\n            update();\n          });\n          identitySubscribed = true;\n        }\n      };\n\n      const subscribePresence = () => {\n        if (!presenceSubscribed) {\n          this._identityManager.identity?.presence?.updated.on(() => {\n            update();\n          });\n          presenceSubscribed = true;\n        }\n      };\n\n      const subscriptions = new SubscriptionList();\n\n      if (this._identityManager.identity) {\n        subscribeIdentity();\n        subscribePresence();\n      }\n\n      subscriptions.add(\n        this._identityManager.stateUpdate.on(() => {\n          update();\n\n          if (this._identityManager.identity) {\n            subscribeIdentity();\n            subscribePresence();\n          }\n        }),\n      );\n\n      update();\n\n      return () => subscriptions.clear();\n    });\n  }\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { scheduleTask, UpdateScheduler, SubscriptionList } from '@dxos/async';\nimport { Stream } from '@dxos/codec-protobuf/stream';\nimport { type MemberInfo } from '@dxos/credentials';\nimport { type SpaceManager } from '@dxos/echo-pipeline';\nimport { PublicKey } from '@dxos/keys';\nimport { type Contact, type ContactBook, type ContactsService } from '@dxos/protocols/proto/dxos/client/services';\nimport { ComplexMap, ComplexSet } from '@dxos/util';\n\nimport { type IdentityManager } from './identity-manager';\nimport { type DataSpaceManager } from '../spaces';\n\nexport class ContactsServiceImpl implements ContactsService {\n  constructor(\n    private readonly _identityManager: IdentityManager,\n    private readonly _spaceManager: SpaceManager,\n    private readonly _dataSpaceManagerProvider: () => Promise<DataSpaceManager>,\n  ) {}\n\n  async getContacts(): Promise<ContactBook> {\n    const identity = this._identityManager.identity;\n    if (identity == null) {\n      return { contacts: [] };\n    }\n    const contacts = [...this._spaceManager.spaces.values()]\n      .flatMap((s) => [...s.spaceState.members.values()].map((m) => [s.key, m]))\n      .reduce((acc, v) => {\n        const [spaceKey, memberInfo] = v as [PublicKey, MemberInfo];\n        if (memberInfo.key.equals(identity.identityKey)) {\n          return acc;\n        }\n        const existing = acc.get(memberInfo.key);\n        if (existing != null) {\n          existing.profile ??= memberInfo.profile;\n          existing.commonSpaces?.push(spaceKey);\n        } else {\n          acc.set(memberInfo.key, {\n            identityKey: memberInfo.key,\n            profile: memberInfo.profile,\n            commonSpaces: [spaceKey],\n          });\n        }\n        return acc;\n      }, new ComplexMap<PublicKey, Contact>(PublicKey.hash));\n    return {\n      contacts: [...contacts.values()],\n    };\n  }\n\n  queryContacts(): Stream<ContactBook> {\n    const subscribedSpaceKeySet = new ComplexSet(PublicKey.hash);\n    return new Stream<ContactBook>(({ next, ctx }) => {\n      const pushUpdateTask = new UpdateScheduler(\n        ctx,\n        async () => {\n          const contacts = await this.getContacts();\n          next(contacts);\n        },\n        { maxFrequency: 2 },\n      );\n      scheduleTask(ctx, async () => {\n        const subscriptions = new SubscriptionList();\n        ctx.onDispose(() => subscriptions.clear());\n        const subscribeToSpaceAndUpdate = () => {\n          const oldSetSize = subscribedSpaceKeySet.size;\n          for (const space of this._spaceManager.spaces.values()) {\n            if (!subscribedSpaceKeySet.has(space.key)) {\n              subscriptions.add(space.stateUpdate.on(ctx, () => pushUpdateTask.trigger()));\n              subscribedSpaceKeySet.add(space.key);\n            }\n          }\n          if (oldSetSize !== subscribedSpaceKeySet.size) {\n            pushUpdateTask.trigger();\n          }\n        };\n        const unsubscribe = (await this._dataSpaceManagerProvider()).updated.on(ctx, subscribeToSpaceAndUpdate);\n        ctx.onDispose(unsubscribe);\n        subscribeToSpaceAndUpdate();\n      });\n    });\n  }\n}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { Event } from '@dxos/async';\nimport { Stream } from '@dxos/codec-protobuf/stream';\nimport { PublicKey } from '@dxos/keys';\nimport {\n  type LogLevel,\n  type LogProcessor,\n  type LogEntry as NaturalLogEntry,\n  getContextFromEntry,\n  log,\n} from '@dxos/log';\nimport {\n  type LogEntry,\n  type LoggingService,\n  type Metrics,\n  QueryLogsRequest,\n  type ControlMetricsRequest,\n  type ControlMetricsResponse,\n  type QueryMetricsRequest,\n  type QueryMetricsResponse,\n} from '@dxos/protocols/proto/dxos/client/services';\nimport { getDebugName, jsonify, numericalValues, tracer } from '@dxos/util';\n\n/**\n * Logging service used to spy on logs of the host.\n */\nexport class LoggingServiceImpl implements LoggingService {\n  private readonly _logs = new Event<NaturalLogEntry>();\n  private readonly _started = Date.now();\n  private readonly _sessionId = PublicKey.random().toHex();\n\n  async open(): Promise<void> {\n    log.runtimeConfig.processors.push(this._logProcessor);\n  }\n\n  async close(): Promise<void> {\n    const index = log.runtimeConfig.processors.findIndex((processor) => processor === this._logProcessor);\n    log.runtimeConfig.processors.splice(index, 1);\n  }\n\n  async controlMetrics({ reset, record }: ControlMetricsRequest): Promise<ControlMetricsResponse> {\n    if (reset) {\n      tracer.clear();\n    }\n\n    if (record === true) {\n      tracer.start();\n    } else if (record === false) {\n      tracer.stop();\n    }\n\n    return { recording: tracer.recording };\n  }\n\n  /**\n   * @deprecated (Move to diagnostics).\n   */\n  queryMetrics({ interval = 5_000 }: QueryMetricsRequest): Stream<QueryMetricsResponse> {\n    // TODO(burdon): Map all traces; how to bind to reducer/metrics shape (e.g., numericalValues)?\n    const getNumericalValues = (key: string) => {\n      const events = tracer.get(key) ?? [];\n      return { key, stats: numericalValues(events, 'duration') };\n    };\n\n    return new Stream(({ next }) => {\n      const update = () => {\n        const metrics: Metrics = {\n          timestamp: new Date(),\n          values: [\n            getNumericalValues('dxos.echo.pipeline.control'),\n            getNumericalValues('dxos.echo.pipeline.data'),\n          ].filter(Boolean) as Metrics.KeyPair[],\n        };\n\n        next({\n          timestamp: new Date(),\n          metrics,\n        });\n      };\n\n      update();\n      const i = setInterval(update, Math.max(interval, 1_000));\n      return () => {\n        clearInterval(i);\n      };\n    });\n  }\n\n  queryLogs(request: QueryLogsRequest): Stream<LogEntry> {\n    return new Stream<LogEntry>(({ ctx, next }) => {\n      const handler = (entry: NaturalLogEntry) => {\n        // This call was caused by the logging service itself.\n        if (LOG_PROCESSING > 0) {\n          return;\n        }\n\n        // Prevent logging feedback loop from logging service.\n        if (\n          entry.meta?.F.includes('logging-service') ||\n          (entry.context &&\n            Object.values(entry.context).some((value) => typeof value === 'string' && value.includes('LoggingService')))\n        ) {\n          return;\n        }\n\n        if (!shouldLog(entry, request)) {\n          return;\n        }\n\n        const record: LogEntry = {\n          ...entry,\n          context: jsonify(getContextFromEntry(entry)),\n          timestamp: new Date(),\n          meta: {\n            // TODO(dmaretskyi): Fix proto.\n            file: entry.meta?.F ?? '',\n            line: entry.meta?.L ?? 0,\n            scope: {\n              hostSessionId: this._sessionId,\n              uptimeSeconds: (Date.now() - this._started) / 1000,\n              name: getDebugName(entry.meta?.S),\n            },\n          },\n        };\n\n        try {\n          LOG_PROCESSING++;\n          next(record);\n        } finally {\n          LOG_PROCESSING--;\n        }\n      };\n\n      this._logs.on(ctx, handler);\n    });\n  }\n\n  private _logProcessor: LogProcessor = (_config, entry) => {\n    this._logs.emit(entry);\n  };\n}\n\nconst matchFilter = (\n  filter: QueryLogsRequest.Filter,\n  level: LogLevel,\n  path: string,\n  options: QueryLogsRequest.MatchingOptions,\n) => {\n  switch (options) {\n    case QueryLogsRequest.MatchingOptions.INCLUSIVE:\n      return level >= filter.level && (!filter.pattern || path.includes(filter.pattern));\n    case QueryLogsRequest.MatchingOptions.EXPLICIT:\n      return level === filter.level && (!filter.pattern || path.includes(filter.pattern));\n  }\n};\n\n/**\n * Determines if the current line should be logged (called by the processor).\n */\nconst shouldLog = (entry: NaturalLogEntry, request: QueryLogsRequest): boolean => {\n  const options = request.options ?? QueryLogsRequest.MatchingOptions.INCLUSIVE;\n  if (request.filters === undefined) {\n    return options === QueryLogsRequest.MatchingOptions.INCLUSIVE;\n  } else {\n    return request.filters.some((filter) => matchFilter(filter, entry.level, entry.meta?.F ?? '', options));\n  }\n};\n\n/**\n * Counter that is used to track whether we are processing a log entry.\n */\nlet LOG_PROCESSING = 0;\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { Stream } from '@dxos/codec-protobuf/stream';\nimport { type EdgeConnection } from '@dxos/edge-client';\nimport { type SignalManager } from '@dxos/messaging';\nimport { type SwarmNetworkManager } from '@dxos/network-manager';\nimport {\n  type SubscribeSwarmStateRequest,\n  type NetworkService,\n  type NetworkStatus,\n  type UpdateConfigRequest,\n} from '@dxos/protocols/proto/dxos/client/services';\nimport { type Peer, type SwarmResponse } from '@dxos/protocols/proto/dxos/edge/messenger';\nimport {\n  type LeaveRequest,\n  type JoinRequest,\n  type Message,\n  type QueryRequest,\n} from '@dxos/protocols/proto/dxos/edge/signal';\n\nexport class NetworkServiceImpl implements NetworkService {\n  constructor(\n    private readonly networkManager: SwarmNetworkManager,\n    private readonly signalManager: SignalManager,\n    private readonly edgeConnection?: EdgeConnection,\n  ) {}\n\n  queryStatus(): Stream<NetworkStatus> {\n    return new Stream<NetworkStatus>(({ ctx, next }) => {\n      const update = () => {\n        next({\n          swarm: this.networkManager.connectionState,\n          connectionInfo: this.networkManager.connectionLog?.swarms,\n          signaling: this.signalManager.getStatus?.().map(({ host, state }) => ({ server: host, state })),\n        });\n      };\n\n      this.networkManager.connectionStateChanged.on(ctx, () => update());\n      this.signalManager.statusChanged?.on(ctx, () => update());\n      update();\n    });\n  }\n\n  async updateConfig(request: UpdateConfigRequest): Promise<void> {\n    await this.networkManager.setConnectionState(request.swarm);\n  }\n\n  async joinSwarm(request: JoinRequest): Promise<void> {\n    return this.signalManager.join(request);\n  }\n\n  async leaveSwarm(request: LeaveRequest): Promise<void> {\n    return this.signalManager.leave(request);\n  }\n\n  async querySwarm(request: QueryRequest): Promise<SwarmResponse> {\n    return this.signalManager.query(request);\n  }\n\n  subscribeSwarmState(request: SubscribeSwarmStateRequest): Stream<SwarmResponse> {\n    return new Stream<SwarmResponse>(({ ctx, next }) => {\n      this.signalManager.swarmState?.on(ctx, (state) => {\n        if (request.topic.equals(state.swarmKey)) {\n          next(state);\n        }\n      });\n    });\n  }\n\n  async sendMessage(message: Message): Promise<void> {\n    return this.signalManager.sendMessage(message);\n  }\n\n  subscribeMessages(peer: Peer): Stream<Message> {\n    return new Stream<Message>(({ ctx, next }) => {\n      this.signalManager.onMessage.on(ctx, (message) => {\n        if (message.recipient.peerKey === peer.peerKey) {\n          next(message);\n        }\n      });\n    });\n  }\n}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { type Event } from '@dxos/async';\nimport { Stream } from '@dxos/codec-protobuf/stream';\nimport { type Config } from '@dxos/config';\nimport {\n  GetDiagnosticsRequest,\n  type SystemService,\n  type SystemStatus,\n  type UpdateStatusRequest,\n  type QueryStatusRequest,\n  type QueryStatusResponse,\n  type Platform,\n} from '@dxos/protocols/proto/dxos/client/services';\nimport { jsonKeyReplacer, type MaybePromise } from '@dxos/util';\n\nimport { type Diagnostics } from '../diagnostics';\nimport { getPlatform } from '../services/platform';\n\nexport type SystemServiceOptions = {\n  config?: () => MaybePromise<Config | undefined>;\n  statusUpdate: Event<void>;\n  getCurrentStatus: () => SystemStatus;\n  getDiagnostics: () => Promise<Partial<Diagnostics['services']>>;\n  onUpdateStatus: (status: SystemStatus) => MaybePromise<void>;\n  onReset: () => MaybePromise<void>;\n};\n\nexport class SystemServiceImpl implements SystemService {\n  private readonly _config?: SystemServiceOptions['config'];\n  private readonly _statusUpdate: SystemServiceOptions['statusUpdate'];\n  private readonly _getCurrentStatus: SystemServiceOptions['getCurrentStatus'];\n  private readonly _onUpdateStatus: SystemServiceOptions['onUpdateStatus'];\n  private readonly _onReset: SystemServiceOptions['onReset'];\n  private readonly _getDiagnostics: SystemServiceOptions['getDiagnostics'];\n\n  constructor({\n    config,\n    statusUpdate,\n    getDiagnostics,\n    onUpdateStatus,\n    getCurrentStatus,\n    onReset,\n  }: SystemServiceOptions) {\n    this._config = config;\n    this._statusUpdate = statusUpdate;\n    this._getCurrentStatus = getCurrentStatus;\n    this._getDiagnostics = getDiagnostics;\n    this._onUpdateStatus = onUpdateStatus;\n    this._onReset = onReset;\n  }\n\n  async getConfig() {\n    return (await this._config?.())?.values ?? {};\n  }\n\n  /**\n   * NOTE: Since this is serialized as a JSON object, we allow the option to serialize keys.\n   */\n  async getDiagnostics({ keys }: GetDiagnosticsRequest = {}) {\n    const diagnostics = await this._getDiagnostics();\n    return {\n      timestamp: new Date(),\n      diagnostics: JSON.parse(\n        JSON.stringify(\n          diagnostics,\n          jsonKeyReplacer({\n            truncate: keys === GetDiagnosticsRequest.KEY_OPTION.TRUNCATE,\n            humanize: keys === GetDiagnosticsRequest.KEY_OPTION.HUMANIZE,\n          }),\n        ),\n      ),\n    };\n  }\n\n  async getPlatform(): Promise<Platform> {\n    return getPlatform();\n  }\n\n  async updateStatus({ status }: UpdateStatusRequest): Promise<void> {\n    await this._onUpdateStatus(status);\n  }\n\n  // TODO(burdon): Standardize interval option in stream request?\n  queryStatus({ interval = 3_000 }: QueryStatusRequest = {}): Stream<QueryStatusResponse> {\n    return new Stream(({ next }) => {\n      const update = () => {\n        next({ status: this._getCurrentStatus() });\n      };\n\n      update();\n      const unsubscribe = this._statusUpdate.on(() => update());\n      const i = setInterval(update, interval);\n      return () => {\n        clearInterval(i);\n        unsubscribe();\n      };\n    });\n  }\n\n  async reset(): Promise<void> {\n    await this._onReset();\n  }\n}\n"],
  "mappings": "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",
  "names": ["import_stream", "import_keys", "import_async", "import_services", "import_tracing", "import_util", "import_context", "import_credentials", "import_log", "import_invariant", "import_protocols", "import_client_protocol", "import_proto", "import_feed_store", "import_timeframe", "import_echo_pipeline", "import_echo_protocol", "import_debug", "import_teleport_extension_gossip", "import_invitations", "import_crypto", "import_teleport", "import_codec_protobuf", "import_metadata", "import_edge_client", "import_config", "import_automerge_repo", "import_network_manager", "subscribeToFeeds", "feedStore", "spaceManager", "feedKeys", "Stream", "next", "subscriptions", "SubscriptionList", "feedMap", "ComplexMap", "PublicKey", "hash", "update", "feeds", "filter", "feed", "length", "some", "feedKey", "equals", "key", "forEach", "has", "set", "on", "add", "off", "get", "owner", "findFeedOwner", "Array", "from", "values", "map", "properties", "bytes", "core", "byteLength", "downloaded", "bitfield", "data", "toBuffer", "Uint8Array", "feedOpened", "clear", "feedInfo", "spaces", "flatMap", "space", "spaceState", "find", "log", "truncate", "allSpaces", "size", "undefined", "identity", "assertion", "identityKey", "device", "deviceKey", "subscribeToFeedBlocks", "maxBlocks", "timeout", "setTimeout", "getFeed", "blocks", "iterator", "FeedIterator", "open", "block", "push", "slice", "close", "clearTimeout", "subscribeToNetworkStatus", "signalManager", "status", "getStatus", "servers", "err", "statusChanged", "subscribeToSignal", "ctx", "Context", "onMessage", "message", "author", "peerKey", "asUint8Array", "recipient", "payload", "receivedAt", "Date", "swarmEvent", "peerAvailable", "peer", "since", "peerLeft", "topic", "dispose", "subscribeToNetworkTopics", "networkManager", "topics", "labeledTopics", "label", "getSwarm", "toHex", "topicsUpdated", "subscribeToSwarmInfo", "info", "connectionLog", "swarms", "getNetworkPeers", "request", "Error", "getSwarmMap", "peers", "connections", "connection", "subscribeToSpaces", "context", "spaceKeys", "unsubscribe", "filteredSpaces", "spaceKey", "spaceMetadata", "metadataStore", "isOpen", "timeframe", "dataTimeframe", "genesisFeed", "genesisFeedKey", "controlFeed", "controlFeedKey", "dataFeed", "dataFeedKey", "initialized", "wait", "dataSpaceManager", "updated", "subscribeToKeyringKeys", "keyring", "keys", "list", "keysUpdate", "scheduleTask", "subscribeToMetadata", "metadata", "DevtoolsHostEvents", "ready", "AsyncEvent", "DevtoolsServiceImpl", "params", "events", "getConfig", "config", "JSON", "stringify", "getStorageInfo", "storageUsage", "storage", "getDiskInfo", "used", "navigatorInfo", "navigator", "estimate", "type", "originUsage", "usage", "usageQuota", "quota", "getBlobs", "blobs", "blobStore", "getSnapshots", "snapshots", "resetStorage", "enableDebugLogging", "disableDebugLogging", "subscribeToCredentialMessages", "subscribeToItems", "getSpaceSnapshot", "saveSpaceSnapshot", "clearSnapshots", "subscribeToSignalStatus", "DXOS_VERSION", "getPlatform", "process", "browser", "window", "userAgent", "Platform", "PLATFORM_TYPE", "BROWSER", "uptime", "Math", "floor", "now", "performance", "timeOrigin", "SHARED_WORKER", "platform", "version", "arch", "NODE", "runtime", "memory", "memoryUsage", "DEFAULT_TIMEOUT", "createDiagnostics", "clientServices", "serviceContext", "diagnostics", "created", "toISOString", "client", "STORAGE_VERSION", "trace", "TRACE_PROCESSOR", "getDiagnostics", "Promise", "all", "invariant", "LoggingService", "metrics", "getFirstStreamValue", "queryMetrics", "catch", "asyncTimeout", "getStorageDiagnostics", "identityManager", "did", "profile", "profileDocument", "devices", "DevicesService", "queryDevices", "getSpaceStats", "DevtoolsHost", "NetworkService", "queryStatus", "networkStatus", "stats", "epochs", "inner", "credentials", "credentialTypeFilter", "credential", "subject", "id", "members", "member", "role", "createDidFromIdentityKey", "displayName", "presence", "getPeersOnline", "SpaceMember", "PresenceState", "ONLINE", "OFFLINE", "pipeline", "currentEpoch", "automergeSpaceState", "lastEpoch", "appliedEpoch", "controlFeeds", "controlPipeline", "state", "currentControlTimeframe", "targetControlTimeframe", "targetTimeframe", "totalControlTimeframe", "endTimeframe", "startupTime", "getTime", "Map", "dir", "getDirectory", "filename", "idx", "indexOf", "entries", "sort", "a", "b", "file", "count", "createCollectDiagnosticsBroadcastSender", "broadcastDiagnosticsRequest", "createCollectDiagnosticsBroadcastHandler", "_", "start", "stop", "GET_DIAGNOSTICS_RPC_TIMEOUT", "DiagnosticsCollector", "broadcastSender", "collect", "findConfigs", "services", "findSystemServiceProvider", "options", "serviceDiagnostics", "SystemService", "humanize", "GetDiagnosticsRequest", "KEY_OPTION", "HUMANIZE", "TRUNCATE", "clientDiagnostics", "broadcast", "parse", "jsonKeyReplacer", "serviceProviders", "findResourcesByAnnotation", "ClientServicesProviderResource", "providerResource", "r", "instance", "deref", "configs", "ConfigResource", "isNonNullable", "Credential", "schema", "getCodecForType", "createAuthProvider", "signer", "nonce", "createCredential", "getIssuer", "encode", "TrustedKeySetAuthVerifier", "_params", "_ctx", "verifier", "auth", "decode", "result", "verifyCredential", "kind", "proof", "Buffer", "_isTrustedKey", "issuer", "trigger", "Trigger", "onDispose", "wake", "trusted", "trustedKeysProvider", "authTimeout", "deviceSet", "EdgeFeedReplicator", "Resource", "messenger", "spaceId", "_feeds", "_connectionCtx", "_connected", "_messenger", "_spaceId", "_open", "serviceId", "service", "rest", "split", "EdgeService", "FEED_REPLICATOR", "decodeCbor", "value", "source", "_onMessage", "onReconnected", "scheduleMicroTask", "_handleReconnect", "_resetConnection", "EdgeStatus", "CONNECTED", "_startReplication", "_close", "connectionCtx", "_createConnectionContext", "_replicateFeed", "_remoteLength", "addFeed", "connected", "hasConnectionCtx", "_getPushMutex", "defaultMap", "_pushMutex", "Mutex", "_sendMessage", "Event", "wrap", "_pushBlocksIfNeeded", "index", "payloadValue", "bufferToArray", "encodeCbor", "send", "buf", "create", "RouterMessageSchema", "warn", "fromHex", "_guard", "acquire", "logMeta", "localLength", "remoteLength", "range", "to", "_pushBlocks", "_integrateBlocks", "rangeFromTo", "valueEncoding", "nodes", "signature", "blockBuffer", "bufferizeBlock", "putBuffer", "onError", "EdgeIdentityChangedError", "EdgeConnectionClosedError", "raise", "arrayToBuffer", "node", "AutomergeSpaceState", "_onNewRoot", "rootUrl", "onNewEpoch", "_isProcessingRootDocs", "processCredential", "checkCredentialType", "automergeRoot", "emit", "startProcessingRootDocs", "ensureEpochInitialized", "waitForCondition", "LOAD_DOC_TIMEOUT", "runEpochMigration", "migration", "CreateEpochRequest", "Migration", "INIT_AUTOMERGE", "document", "echoHost", "createDoc", "flush", "newRoot", "url", "PRUNE_AUTOMERGE_ROOT_HISTORY", "currentRoot", "rootHandle", "loadDoc", "doc", "FRAGMENT_AUTOMERGE_ROOT", "MIGRATE_REFERENCES_TO_DXN", "REPLACE_AUTOMERGE_ROOT", "newAutomergeRoot", "DEFAULT_RETRY_TIMEOUT", "DEFAULT_SUCCESS_DELAY", "DEFAULT_NOTARIZE_TIMEOUT", "DEFAULT_ACTIVE_EDGE_POLLING_INTERVAL", "MAX_EDGE_RETRIES", "WRITER_NOT_SET_ERROR_CODE", "credentialCodec", "NotarizationPlugin", "_extensionOpened", "_extensions", "Set", "_processedCredentials", "ComplexSet", "_processCredentialsTriggers", "_activeEdgePollingIntervalHandle", "_activeEdgePollingEnabled", "_activeEdgePollingInterval", "activeEdgePollingInterval", "edgeClient", "edgeFeatures", "feedReplicator", "_edgeClient", "setActiveEdgePollingEnabled", "enabled", "_startPeriodicEdgePolling", "_stopPeriodicEdgePolling", "hasWriter", "_writer", "_notarizePendingEdgeCredentials", "notarize", "opCtx", "retryTimeout", "successDelay", "edgeRetryJitter", "every", "errors", "derive", "throw", "_scheduleTimeout", "allNotarized", "_waitUntilProcessed", "_tryNotarizeCredentialsWithPeers", "_tryNotarizeCredentialsWithEdge", "jitter", "race", "rejectOnDispose", "peersTried", "notarizeTask", "DeferredTask", "retryIn", "schedule", "localPeerId", "credentialId", "rpc", "NotarizationService", "sleep", "disposed", "includes", "timeouts", "encodedCredentials", "binary", "toString", "notarizeCredentials", "retry", "error", "handleEdgeError", "delete", "setWriter", "writer", "setInterval", "clearInterval", "response", "getCredentialsForNotarization", "awaitingNotarization", "decodedCredentials", "_notarizeCredentials", "entry", "orInsert", "_onNotarize", "verificationResult", "join", "write", "createExtension", "extension", "NotarizationTeleportExtension", "onOpen", "onClose", "onNotarize", "bind", "remotePeerId", "TimeoutError", "EdgeCallFailedError", "errorData", "reason", "RpcExtension", "requested", "getService", "exposed", "getHandlers", "DefaultSpaceStateMachine", "getCredentialAssertion", "expectedIdentity", "SpaceId", "isValid", "spaceGenesis", "signingContext", "Role", "OWNER", "getProfile", "failUndefined", "credentialSigner", "designation", "AdmittedFeed", "Designation", "CONTROL", "DATA", "number", "previousId", "Timeframe", "snapshotCid", "PRESENCE_ANNOUNCE_INTERVAL", "PRESENCE_OFFLINE_TIMEOUT", "DEFAULT_SPACE_KEY", "DataSpaceManager", "_spaces", "_instanceId", "random", "_edgeConnection", "_edgeHttpClient", "_edgeFeatures", "_meshReplicator", "_echoEdgeReplicator", "_runtimeParams", "_spaceManager", "_metadataStore", "_keyring", "_signingContext", "_feedStore", "_echoHost", "meshReplicator", "_invitationsManager", "invitationsManager", "edgeConnection", "echoEdgeReplicator", "edgeHttpClient", "runtimeParams", "diagnostic", "name", "fetch", "automergeRepo", "FIND_PARAMS", "whenReady", "rootDoc", "findInlineObjectOfType", "TYPE_PROPERTIES", "SpaceState", "inlineObjects", "Object", "objects", "linkedObjects", "links", "getSpaceById", "Trace", "begin", "forEachAsync", "_constructSpace", "end", "createSpace", "assertArgument", "documents", "assertState", "_lifecycleState", "LifecycleState", "OPEN", "createKey", "createIdFromSpaceKey", "SPACE_ACTIVE", "documentIdMapping", "documentId", "test", "newDoc", "preserveHistory", "root", "newRootDocId", "interpretAsDocumentId", "failedInvariant", "rootDocHandle", "default", "DatabaseRoot", "mapLinks", "openSpaceRoot", "createSpaceRoot", "addSpace", "memberCredential", "recordCredential", "initializeDataPipeline", "isDefaultSpace", "databaseRoot", "getVersion", "SpaceDocVersion", "CURRENT", "handle", "isReady", "LEGACY", "createDefaultSpace", "_getSpaceRootDocument", "system", "encodeReference", "getTypeReference", "PropertiesType", "meta", "propertiesId", "ObjectId", "change", "setDeep", "automergeIndex", "acceptSpace", "opts", "controlTimeframe", "initializeDataPipelineAsync", "admitMember", "getMemberRole", "REMOVED", "AlreadyJoinedError", "createAdmissionCredentials", "membershipChainHeads", "delegationCredentialId", "spaceMemberCredential", "writeMessages", "waitUntilSpaceReady", "cancelWithContext", "SPACE_READY", "requestSpaceAdmissionCredential", "swarmIdentity", "credentialProvider", "credentialAuthenticator", "setSpaceEdgeReplicationSetting", "setting", "EdgeReplicationSetting", "DISABLED", "disconnectFromSpace", "ENABLED", "connectToSpace", "stateUpdate", "gossip", "Gossip", "Presence", "announceInterval", "spaceMemberPresenceAnnounceInterval", "offlineTimeout", "spaceMemberPresenceOfflineTimeout", "openFeed", "writable", "sparse", "constructSpace", "deferFunction", "dataSpace", "authVerifier", "onAuthorizedConnection", "session", "queueMicrotask", "addExtension", "CredentialServerExtension", "notarizationPlugin", "_connectEchoMeshReplicator", "onAuthFailure", "onMemberRolesChanged", "_handleMemberRoleChanges", "protocol", "memberKey", "onDelegatedInvitationStatusChange", "invitation", "isActive", "_handleInvitationStatusChange", "setControlFeed", "setDataFeed", "DataSpace", "initialState", "SPACE_INACTIVE", "SPACE_CLOSED", "callbacks", "beforeReady", "afterReady", "_createDelegatedInvitations", "invitations", "beforeClose", "cache", "activeEdgeNotarizationPollingInterval", "postOpen", "append", "getEdgeReplicationSetting", "preClose", "newPeer", "peerState", "_handleNewPeerConnected", "setTargetTimeframe", "replicator", "authorizeDevice", "spaceProtocol", "memberInfo", "closedSessions", "getLocalState", "getPeersByIdentityKey", "sessions", "p", "peerId", "sessionsToClose", "s", "authStatus", "AuthStatus", "FAILURE", "roleChangeCount", "peersOnline", "updateTopology", "delegatedInvitation", "cancelInvitation", "tasks", "createInvitation", "Invitation", "Type", "DELEGATED", "Kind", "SPACE", "authMethod", "invitationId", "swarmKey", "guestKeypair", "guestKey", "publicKey", "lifetime", "expiresOn", "multiUse", "persistent", "CURRENT_VERSION", "SpaceArchiveVersion", "V1", "SpaceArchiveWriter", "_meta", "_currentRootUrl", "_tar", "resolve", "_archive", "Archive", "setCurrentRootUrl", "startsWith", "writeDocument", "addBinaryFile", "SpaceArchiveFileStructure", "finish", "createdAt", "exportedBy", "originalSpaceId", "echo", "currentRootUrl", "addTextFile", "toUint8Array", "contents", "extractSpaceArchive", "archive", "extract", "metadataEntry", "fileName", "getContentAsText", "replace", "content", "SpacesServiceImpl", "_identityManager", "_getDataSpaceManager", "_requireIdentity", "_updateMetrics", "_serializeSpace", "updateSpace", "edgeReplication", "SpaceNotFoundError", "activate", "deactivate", "ApiError", "updateMemberRole", "hasMembershipManagementPermission", "AuthorizationError", "getIdentityCredentialSigner", "newRole", "querySpaces", "scheduler", "UpdateScheduler", "ids", "maxFrequency", "env", "NODE_ENV", "subscribeSpaces", "lastState", "forceTrigger", "timeframeUpdate", "postMessage", "channel", "getChannelId", "subscribeMessages", "listen", "queryCredentials", "noTail", "processor", "removeCredentialProcessor", "addCredentialProcessor", "writeCredentials", "signedCredential", "createEpoch", "automergeRootUrl", "epochCredential", "admitContact", "contact", "joinBySpaceKey", "_joinByAdmission", "exportSpace", "getAllDocuments", "importSpace", "extracted", "newSpaceId", "myIdentity", "encodeError", "dataFeeds", "startDataTimeframe", "currentDataTimeframe", "targetDataTimeframe", "totalDataTimeframe", "spaceRootUrl", "isMe", "peerStates", "creator", "IdentityNotInitializedError", "gauge", "tags", "Identity", "_edgeFeedReplicator", "_onFeedAdded", "_signer", "_presence", "_deviceStateMachine", "DeviceStateMachine", "onUpdate", "_profileStateMachine", "ProfileStateMachine", "_defaultSpaceStateMachine", "authorizedDeviceKeys", "AUTH_TIMEOUT", "defaultSpaceId", "feedAdded", "joinNetwork", "startProtocol", "remove", "deviceChainReady", "waitUntilReachedTargetTimeframe", "LOAD_CONTROL_FEEDS_TIMEOUT", "haloSpaceId", "haloSpaceKey", "haloGenesisFeedKey", "deviceCredentialChain", "createCredentialSignerWithChain", "getDeviceCredentialSigner", "createCredentialSignerWithKey", "updateDefaultSpace", "receipt", "waitUntilTimeframe", "seq", "admitDevice", "hostDevice", "deviceCredential", "span", "resource", "DEVICE_PRESENCE_ANNOUNCE_INTERVAL", "DEVICE_PRESENCE_OFFLINE_TIMEOUT", "IdentityManager", "_devicePresenceAnnounceInterval", "devicePresenceAnnounceInterval", "_devicePresenceOfflineTimeout", "devicePresenceOfflineTimeout", "_identity", "traceId", "identityRecord", "getIdentityRecord", "_constructIdentity", "createIdentity", "deviceProfile", "haloSpace", "generator", "CredentialGenerator", "createSpaceGenesis", "createFeedAdmission", "createProfileCredential", "createDeviceAuthorization", "createDeviceProfile", "createDefaultDeviceProfile", "setIdentityRecord", "isNode", "DeviceType", "AGENT", "MOBILE", "globalThis", "__args", "NATIVE", "platformVersion", "architecture", "os", "String", "family", "osVersion", "prepareIdentity", "acceptIdentity", "updateDeviceProfile", "updateProfile", "DeviceKind", "Device", "spaceRecord", "showInBrowserTimeline", "DEFAULT_SPACE_SEARCH_TIMEOUT", "IdentityServiceImpl", "_recoveryManager", "_dataSpaceManagerProvider", "_createIdentity", "_onProfileUpdate", "_fixIdentityWithoutDefaultSpace", "_createDefaultSpace", "_getIdentity", "queryIdentity", "emitNext", "createRecoveryCredential", "requestRecoveryChallenge", "recoverIdentity", "recoveryCode", "external", "recoverIdentityWithExternalSignature", "token", "recoverIdentityWithToken", "signPresentation", "presentation", "signerKey", "chain", "createAuthCredential", "signingKey", "recodedDefaultSpace", "foundDefaultSpace", "recordedDefaultSpaceTrigger", "allProcessed", "safeAwaitAll", "requiresMigration", "SPACE_REQUIRES_MIGRATION", "duplicate", "_cache", "_onNewAutomergeRoot", "_epochProcessingMutex", "_state", "_databaseRoot", "CallbackCollection", "_inner", "_gossip", "_callbacks", "_notarizationPlugin", "_automergeSpaceState", "_automergeInfo", "SPACE_CONTROL_ONLY", "callSerial", "callback", "pipelineInitBegin", "CancelledError", "ContextDisposedError", "SPACE_ERROR", "SystemError", "SPACE_INITIALIZING", "_initializeAndReadControlPipeline", "save", "documentUrl", "getAllLinkedDocuments", "exportDoc", "_enterReadyState", "breakOnStall", "controlPipelineReady", "_createWritableFeeds", "createMappedFeedWriter", "setWritableFeedKeys", "warnAfterTimeout", "access", "updateOwnProfile", "epoch", "updateIndexes", "setSpaceState", "getSpaceEdgeReplicationSetting", "enum", "depth", "DeviceInvitationProtocol", "_acceptIdentity", "toJSON", "checkCanInviteNewMembers", "getInvitationContext", "DEVICE", "delegate", "cancelDelegation", "admit", "checkInvitation", "createIntroduction", "createAdmissionRequest", "accept", "authorizedDeviceCredential", "stateToString", "State", "val", "computeExpirationTime", "tryAcquireBeforeContextDisposed", "mutex", "guard", "release", "MAX_RETRIES_PER_INVITATION", "DEFAULT_REQUEST_RETRY_INTERVAL_MS", "DEFAULT_REQUEST_RETRY_JITTER_MS", "EdgeInvitationHandler", "_client", "_retryInterval", "retryInterval", "_retryJitter", "retryJitter", "guardedState", "current", "canBeHandledByEdge", "AuthMethod", "SHARED_SECRET", "_flowLock", "requestCount", "tryHandleInvitation", "admissionRequest", "_handleSpaceInvitationFlow", "retryable", "isRetryable", "after", "retryAfterMs", "_calculateNextRetryMs", "verbose", "CONNECTING", "_joinSpaceByInvitation", "admissionResponse", "_mapToAdmissionResponse", "onInvitationSuccess", "ERROR", "edgeResponse", "credentialBytes", "codec", "joinSpaceByInvitation", "EdgeAuthChallengeError", "privateKey", "sign", "challenge", "hasFlowLock", "OPTIONS_TIMEOUT", "InvitationGuestExtension", "_invitationFlowMutex", "InvitationHostService", "_remoteOptionsTrigger", "_invitationFlowLock", "_remoteOptions", "introduce", "authenticate", "InvitationOptions", "GUEST", "HOST", "InvalidInvitationExtensionRoleError", "expected", "remoteOptions", "_destroy", "onAbort", "MAX_OTP_ATTEMPTS", "InvitationHostExtension", "_challenge", "guestProfile", "authenticationPassed", "authenticationRetry", "completedTrigger", "_requireActiveInvitation", "_assertInvitationState", "actual", "NONE", "onStateUpdate", "READY_FOR_AUTHENTICATION", "KNOWN_PUBLIC_KEY", "randomBytes", "authCode", "code", "signedChallenge", "AuthenticationResponse", "Status", "OK", "AUTHENTICATING", "INVALID_OPT_ATTEMPTS", "INVALID_OTP", "INTERNAL_ERROR", "isSignatureValid", "verify", "asBuffer", "INVALID_SIGNATURE", "isAuthenticationRequired", "activeInvitation", "stateOrMany", "validStates", "isArray", "InvariantViolation", "createGuardedInvitationState", "stream", "lastActiveLockHolder", "currentInvitation", "isStateChangeAllowed", "lockHolder", "isLocked", "isNonTerminalState", "complete", "newState", "logStateUpdate", "actor", "logContext", "oldState", "errorStack", "stack", "currentState", "SUCCESS", "CANCELLED", "TIMEOUT", "EXPIRED", "InvitationTopology", "_role", "_seenPeers", "init", "controller", "_controller", "ownPeerId", "candidates", "allPeers", "getState", "c", "firstUnknownPeer", "connect", "onOffer", "destroy", "_trace", "MAX_DELEGATED_INVITATION_HOST_TRIES", "InvitationsHandler", "_networkManager", "_connectionParams", "handleInvitationFlow", "increment", "extensionsCtx", "admitted", "guest", "stateChanged", "getExpirationTime", "swarmConnection", "_joinSwarm", "acceptInvitation", "otpEnteredTrigger", "INVITATION_TIMEOUT", "triedPeersIds", "shouldCancelInvitationFlow", "isLockedByAnotherConnection", "invitationType", "triedPeers", "extensionCtx", "introductionResponse", "_handleGuestOtpAuth", "_handleGuestKpkAuth", "edgeInvitationHandler", "edgeInvitations", "timeoutInactive", "extensionFactory", "joinSwarm", "protocolProvider", "createTeleportProtocolFactory", "teleport", "topology", "setState", "authenticated", "attempt", "reset", "InvalidInvitationError", "createAdmissionKeypair", "keypair", "createKeyPair", "secretKey", "InvitationsServiceImpl", "getLoggingContext", "then", "subscribe", "queryInvitations", "invitationCreated", "action", "QueryInvitationsResponse", "Action", "ADDED", "CREATED", "invitationAccepted", "ACCEPTED", "removedCreated", "removedAccepted", "saved", "SAVED", "getCreatedInvitations", "existing", "getAcceptedInvitations", "onPersistentInvitationsLoaded", "LOAD_COMPLETE", "SpaceInvitationProtocol", "_spaceKey", "host", "ADMIN", "createDelegatedSpaceInvitationCredential", "createCancelDelegatedSpaceInvitationCredential", "InvitationsManager", "_invitationsHandler", "_getHandler", "_createInvitations", "_acceptInvitations", "_persistentInvitationsLoadedEvent", "_persistentInvitationsLoaded", "existingInvitation", "handler", "invitationError", "_createInvitation", "observableInvitation", "_createObservableInvitation", "_onInvitationComplete", "_safeDeleteInvitation", "_persistIfRequired", "cancel", "loadPersistentInvitations", "i", "persistentInvitations", "getInvitations", "freshInvitations", "hasInvitationExpired", "loadTasks", "persistentInvitation", "cInvitations", "_createObservableAcceptingInvitation", "observable", "removeInvitation", "accepted", "once", "_options", "INTERACTIVE", "INIT", "generatePasscode", "AUTHENTICATION_CODE_LENGTH", "PushStream", "CancellableInvitation", "initialInvitation", "subscriber", "onCancel", "AuthenticatingInvitation", "onAuthenticate", "changeStream", "addInvitation", "Lock", "lockKey", "lockPath", "onAcquire", "onRelease", "_lockPath", "_onAcquire", "_onRelease", "_fileHandle", "LockFile", "ClientRpcServer", "_handlerCache", "_callMetrics", "MapCounter", "serviceRegistry", "handleCall", "handleStream", "rpcOptions", "_handleCall", "_handleStream", "_serviceRegistry", "_rpcPeer", "RpcPeer", "callHandler", "method", "serviceName", "methodName", "parseMethodName", "_getServiceHandler", "call", "inc", "streamHandler", "callStream", "unwrapPromise", "_services", "descriptor", "descriptors", "createServer", "metricsCounter", "AGENT_STATUS_QUERY_RETRY_INTERVAL", "AGENT_STATUS_QUERY_RETRY_JITTER", "AGENT_FEED_ADDED_CHECK_INTERVAL_MS", "EdgeAgentManager", "_dataSpaceManager", "agentStatusChanged", "_lastKnownDeviceCount", "agentStatus", "_agentStatus", "agentExists", "EdgeAgentStatus", "NOT_FOUND", "createAgent", "agents", "_updateStatus", "ACTIVE", "isEnabled", "_fetchAgentStatusTask", "_fetchAgentStatus", "_agentDeviceKey", "_ensureAgentIsInSpaces", "maybeAgentWasCreated", "agent", "getAgentStatus", "ownerIdentityKey", "wasAgentCreatedDuringQuery", "agentDeviceKey", "activePollingEnabled", "agentFeedNeedsNotarization", "EdgeAgentServiceImpl", "_agentManagerProvider", "queryEdgeStatus", "NOT_CONNECTED", "queryAgentStatus", "QueryAgentStatusResponse", "AgentStatus", "UNKNOWN", "agentManager", "mapStatus", "newStatus", "INACTIVE", "EdgeIdentityRecoveryManager", "_identityProvider", "_acceptRecoveredIdentity", "recoveryKey", "lookupKey", "algorithm", "generateSeedPhrase", "keyPairFromSeedPhrase", "clientDataJson", "authenticatorData", "decodeCredential", "deviceAuthCredential", "recoveryKeypair", "credentialBase64", "ServiceContext", "level", "_edgeIdentityUpdateMutex", "_handlerFactories", "MetadataStore", "createDirectory", "BlobStore", "Keyring", "FeedStore", "factory", "FeedFactory", "hypercore", "SpaceManager", "disableP2pReplication", "recoveryManager", "EchoHost", "kv", "peerIdProvider", "getSpaceKeyByRootDocumentId", "findSpaceByRootDocumentId", "indexing", "vector", "enableVectorIndexing", "MeshEchoReplicator", "invitationConnectionDefaultParams", "getInvitationHandler", "echoReplicator", "EchoEdgeReplicator", "_checkStorageVersion", "_setNetworkIdentity", "addReplicator", "load", "_initialize", "loadedInvitations", "_deviceSpaceSync", "edgeAgentManager", "broadcastProfileUpdate", "InvalidStorageVersionError", "details", "edgeIdentity", "createChainEdgeIdentity", "createEphemeralEdgeIdentity", "setIdentity", "setPeerInfo", "ServiceRegistry", "_serviceBundle", "_handlers", "setServices", "addService", "removeService", "getRootPath", "dataRoot", "DX_DATA", "isPersistent", "dataStore", "Runtime", "Client", "Storage", "StorageDriver", "RAM", "createStorageObjects", "keyStore", "InvalidConfigError", "createStorage", "toStorageType", "StorageType", "CHROME", "FIREFOX", "IDB", "WEBFS", "createLevel", "storagePath", "path", "createKV", "encodeProfileArchive", "cbor", "decodeProfileArchive", "exportProfileData", "timestamp", "directory", "files", "getOrCreateFile", "stat", "read", "ProfileArchiveEntryType", "FILE", "iter", "keyEncoding", "KEY_VALUE", "importProfileData", "batch", "put", "total", "progress", "toFixed", "DevicesServiceImpl", "updateDevice", "deviceKeys", "toUpperCase", "TRUSTED", "identitySubscribed", "presenceSubscribed", "subscribeIdentity", "subscribePresence", "ContactsServiceImpl", "getContacts", "contacts", "m", "reduce", "acc", "v", "commonSpaces", "queryContacts", "subscribedSpaceKeySet", "pushUpdateTask", "subscribeToSpaceAndUpdate", "oldSetSize", "LoggingServiceImpl", "_logs", "_started", "_sessionId", "_logProcessor", "_config", "runtimeConfig", "processors", "findIndex", "splice", "controlMetrics", "record", "tracer", "recording", "interval", "getNumericalValues", "numericalValues", "Boolean", "max", "queryLogs", "LOG_PROCESSING", "F", "shouldLog", "jsonify", "getContextFromEntry", "line", "L", "scope", "hostSessionId", "uptimeSeconds", "getDebugName", "S", "matchFilter", "QueryLogsRequest", "MatchingOptions", "INCLUSIVE", "pattern", "EXPLICIT", "filters", "NetworkServiceImpl", "swarm", "connectionState", "connectionInfo", "signaling", "server", "connectionStateChanged", "updateConfig", "setConnectionState", "leaveSwarm", "leave", "querySwarm", "query", "subscribeSwarmState", "swarmState", "sendMessage", "SystemServiceImpl", "statusUpdate", "onUpdateStatus", "getCurrentStatus", "onReset", "_statusUpdate", "_getCurrentStatus", "_getDiagnostics", "_onUpdateStatus", "_onReset", "updateStatus", "ClientServicesHost", "transportFactory", "_tracingService", "createTraceSender", "_opening", "_resetting", "_storage", "_level", "initialize", "_resourceLock", "_systemService", "SystemStatus", "_serviceContext", "diagnosticsBroadcastHandler", "_loggingService", "clientServiceBundle", "TracingService", "edgeEndpoint", "EdgeClient", "createStubEdgeIdentity", "socketEndpoint", "EdgeHttpClient", "createRtcTransportFactory", "iceServers", "createIceProvider", "EdgeSignalManager", "WebsocketSignalManager", "_signalManager", "SwarmNetworkManager", "enableDevtoolsLogging", "peerInfo", "dataSpaceManagerProvider", "agentManagerProvider", "identityService", "IdentityService", "ContactsService", "InvitationsService", "SpacesService", "DataService", "dataService", "QueryService", "queryService", "EdgeAgentService", "devtoolsProxy", "_devtoolsProxy", "WebsocketRpcClient", "handlers"]
}
