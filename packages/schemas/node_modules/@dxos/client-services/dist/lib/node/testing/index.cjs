"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var testing_exports = {};
__export(testing_exports, {
  TestBuilder: () => TestBuilder,
  TestPeer: () => TestPeer,
  acceptInvitation: () => acceptInvitation,
  createIdentity: () => createIdentity,
  createInvitation: () => createInvitation,
  createMockCredential: () => createMockCredential,
  createPeers: () => createPeers,
  createServiceContext: () => createServiceContext,
  createServiceHost: () => createServiceHost,
  createSigningContext: () => createSigningContext,
  performInvitation: () => performInvitation,
  sanitizeInvitation: () => sanitizeInvitation
});
module.exports = __toCommonJS(testing_exports);
var import_chunk_LMGLGOUU = require("../chunk-LMGLGOUU.cjs");
var import_credentials = require("@dxos/credentials");
var import_keys = require("@dxos/keys");
var import_async = require("@dxos/async");
var import_client_protocol = require("@dxos/client-protocol");
var import_invariant = require("@dxos/invariant");
var import_services = require("@dxos/protocols/proto/dxos/client/services");
var import_context = require("@dxos/context");
var import_credentials2 = require("@dxos/credentials");
var import_debug = require("@dxos/debug");
var import_echo_pipeline = require("@dxos/echo-pipeline");
var import_feed_store = require("@dxos/feed-store");
var import_keyring = require("@dxos/keyring");
var import_testing = require("@dxos/kv-store/testing");
var import_messaging = require("@dxos/messaging");
var import_network_manager = require("@dxos/network-manager");
var import_services2 = require("@dxos/protocols/proto/dxos/client/services");
var import_random_access_storage = require("@dxos/random-access-storage");
var import_teleport_extension_object_sync = require("@dxos/teleport-extension-object-sync");
var createMockCredential = async ({ signer, issuer }) => (0, import_credentials.createCredential)({
  signer,
  issuer,
  subject: new import_keys.PublicKey(Buffer.from("test")),
  assertion: {
    "@type": "example.testing.rpc.MessageWithAny",
    payload: {
      "@type": "google.protobuf.Any",
      value: Buffer.from("test")
    }
  }
});
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/testing/invitation-utils.ts";
var sanitizeInvitation = (invitation) => {
  return import_client_protocol.InvitationEncoder.decode(import_client_protocol.InvitationEncoder.encode(invitation));
};
var performInvitation = ({ host, guest, options, hooks, guestDeviceProfile, codeInputDelay }) => {
  let guestError = false;
  let guestConnected = false;
  let wereConnected = false;
  const hostComplete = new import_async.Trigger();
  const guestComplete = new import_async.Trigger();
  const authCode = new import_async.Trigger();
  void createInvitation(host, options).then((hostObservable) => {
    hostObservable.subscribe(async (hostInvitation) => {
      switch (hostInvitation.state) {
        case import_services.Invitation.State.CONNECTING: {
          if (guestConnected) {
            if (wereConnected) {
              hostComplete.wake({
                invitation: hostInvitation
              });
            }
            break;
          }
          guestConnected = true;
          if (hooks?.host?.onConnecting?.(hostObservable)) {
            break;
          }
          const guestObservable = acceptInvitation(guest, hostInvitation, guestDeviceProfile);
          guestObservable.subscribe(async (guestInvitation) => {
            switch (guestInvitation.state) {
              case import_services.Invitation.State.CONNECTING: {
                if (hooks?.guest?.onConnecting?.(guestObservable)) {
                  break;
                }
                (0, import_invariant.invariant)(hostInvitation.swarmKey.equals(guestInvitation.swarmKey), void 0, {
                  F: __dxlog_file,
                  L: 95,
                  S: void 0,
                  A: [
                    "hostInvitation.swarmKey!.equals(guestInvitation.swarmKey!)",
                    ""
                  ]
                });
                break;
              }
              case import_services.Invitation.State.CONNECTED: {
                hooks?.guest?.onConnected?.(guestObservable);
                break;
              }
              case import_services.Invitation.State.READY_FOR_AUTHENTICATION: {
                if (hooks?.guest?.onReady?.(guestObservable)) {
                  break;
                }
                const code = await authCode.wait();
                if (codeInputDelay == null) {
                  await guestObservable.authenticate(code);
                } else {
                  setTimeout(async () => {
                    if (!guestError) {
                      await guestObservable.authenticate(code);
                    }
                  }, codeInputDelay);
                }
                break;
              }
              case import_services.Invitation.State.AUTHENTICATING: {
                hooks?.guest?.onAuthenticating?.(guestObservable);
                break;
              }
              case import_services.Invitation.State.SUCCESS: {
                if (hooks?.guest?.onSuccess?.(guestObservable)) {
                  break;
                }
                guestComplete.wake({
                  invitation: guestInvitation
                });
                break;
              }
              case import_services.Invitation.State.CANCELLED: {
                if (hooks?.guest?.onCancelled?.(guestObservable)) {
                  break;
                }
                guestComplete.wake({
                  invitation: guestInvitation
                });
                break;
              }
              case import_services.Invitation.State.TIMEOUT: {
                if (hooks?.guest?.onTimeout?.(guestObservable)) {
                  return;
                }
                guestComplete.wake({
                  invitation: guestInvitation
                });
              }
            }
          }, (error) => {
            guestError = true;
            if (hooks?.guest?.onError?.(guestObservable)) {
              return;
            }
            guestComplete.wake({
              error
            });
          });
          break;
        }
        case import_services.Invitation.State.CONNECTED: {
          wereConnected = true;
          hooks?.host?.onConnected?.(hostObservable);
          break;
        }
        case import_services.Invitation.State.READY_FOR_AUTHENTICATION: {
          if (hooks?.host?.onReady?.(hostObservable)) {
            break;
          }
          if (hostInvitation.authCode) {
            authCode.wake(hostInvitation.authCode);
          }
          break;
        }
        case import_services.Invitation.State.AUTHENTICATING: {
          hooks?.host?.onAuthenticating?.(hostObservable);
          break;
        }
        case import_services.Invitation.State.SUCCESS: {
          if (hooks?.host?.onSuccess?.(hostObservable)) {
            break;
          }
          hostComplete.wake({
            invitation: hostInvitation
          });
          break;
        }
        case import_services.Invitation.State.CANCELLED: {
          if (hooks?.host?.onCancelled?.(hostObservable)) {
            break;
          }
          hostComplete.wake({
            invitation: hostInvitation
          });
          break;
        }
        case import_services.Invitation.State.TIMEOUT: {
          if (hooks?.host?.onTimeout?.(hostObservable)) {
            break;
          }
          hostComplete.wake({
            invitation: hostInvitation
          });
          break;
        }
      }
    }, (error) => {
      if (hooks?.host?.onError?.(hostObservable)) {
        return;
      }
      hostComplete.wake({
        error
      });
    });
  });
  return [
    hostComplete.wait(),
    guestComplete.wait()
  ];
};
var createInvitation = async (host, options) => {
  options ??= {
    authMethod: import_services.Invitation.AuthMethod.NONE,
    ...options ?? {}
  };
  if (host instanceof import_chunk_LMGLGOUU.ServiceContext) {
    return host.invitationsManager.createInvitation({
      kind: import_services.Invitation.Kind.SPACE,
      ...options
    });
  }
  return host.share(options);
};
var acceptInvitation = (guest, invitation, guestDeviceProfile) => {
  invitation = sanitizeInvitation(invitation);
  if (guest instanceof import_chunk_LMGLGOUU.ServiceContext) {
    return guest.invitationsManager.acceptInvitation({
      invitation,
      deviceProfile: guestDeviceProfile
    });
  }
  return guest.join(invitation, guestDeviceProfile);
};
var __dxlog_file2 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/testing/test-builder.ts";
var createServiceHost = (config, signalManagerContext) => {
  return new import_chunk_LMGLGOUU.ClientServicesHost({
    config,
    signalManager: new import_messaging.MemorySignalManager(signalManagerContext),
    transportFactory: import_network_manager.MemoryTransportFactory
  });
};
var createServiceContext = async ({ signalManagerFactory = async () => {
  const signalContext = new import_messaging.MemorySignalManagerContext();
  return new import_messaging.MemorySignalManager(signalContext);
}, storage = (0, import_random_access_storage.createStorage)({
  type: import_random_access_storage.StorageType.RAM
}), runtimeParams } = {}) => {
  const signalManager = await signalManagerFactory();
  const networkManager = new import_network_manager.SwarmNetworkManager({
    signalManager,
    transportFactory: import_network_manager.MemoryTransportFactory
  });
  const level = (0, import_testing.createTestLevel)();
  await level.open();
  return new import_chunk_LMGLGOUU.ServiceContext(storage, level, networkManager, signalManager, void 0, void 0, {
    invitationConnectionDefaultParams: {
      teleport: {
        controlHeartbeatInterval: 200
      }
    },
    ...runtimeParams
  });
};
var createPeers = async (numPeers, signalManagerFactory) => {
  if (!signalManagerFactory) {
    const signalContext = new import_messaging.MemorySignalManagerContext();
    signalManagerFactory = async () => new import_messaging.MemorySignalManager(signalContext);
  }
  return await Promise.all(Array.from(Array(numPeers)).map(async () => {
    const peer = await createServiceContext({
      signalManagerFactory
    });
    await peer.open(new import_context.Context(void 0, {
      F: __dxlog_file2,
      L: 70
    }));
    return peer;
  }));
};
var createIdentity = async (peer) => {
  await peer.createIdentity();
  return peer;
};
var TestBuilder = class {
  constructor() {
    this.signalContext = new import_messaging.MemorySignalManagerContext();
    this._ctx = new import_context.Context(void 0, {
      F: __dxlog_file2,
      L: 83
    });
  }
  createPeer(peerOptions) {
    const peer = new TestPeer(this.signalContext, peerOptions);
    this._ctx.onDispose(async () => peer.destroy());
    return peer;
  }
  async destroy() {
    await this._ctx.dispose();
  }
};
var TestPeer = class {
  constructor(_signalContext, _opts = {
    dataStore: import_random_access_storage.StorageType.RAM
  }) {
    this._signalContext = _signalContext;
    this._opts = _opts;
    this._props = {};
  }
  get props() {
    return this._props;
  }
  get storage() {
    return this._props.storage ??= (0, import_random_access_storage.createStorage)({
      type: this._opts.dataStore
    });
  }
  get keyring() {
    return this._props.keyring ??= new import_keyring.Keyring(this.storage.createDirectory("keyring"));
  }
  get level() {
    return this._props.level ??= (0, import_testing.createTestLevel)();
  }
  get feedStore() {
    return this._props.feedStore ??= new import_feed_store.FeedStore({
      factory: new import_feed_store.FeedFactory({
        root: this.storage.createDirectory("feeds"),
        signer: this.keyring,
        hypercore: {
          valueEncoding: import_echo_pipeline.valueEncoding
        }
      })
    });
  }
  get metadataStore() {
    return this._props.metadataStore ??= new import_echo_pipeline.MetadataStore(this.storage.createDirectory("metadata"));
  }
  get blobStore() {
    return this._props.blobStore ??= new import_teleport_extension_object_sync.BlobStore(this.storage.createDirectory("blobs"));
  }
  get networkManager() {
    return this._props.networkManager ??= new import_network_manager.SwarmNetworkManager({
      signalManager: new import_messaging.MemorySignalManager(this._signalContext),
      transportFactory: import_network_manager.MemoryTransportFactory
    });
  }
  get spaceManager() {
    return this._props.spaceManager ??= new import_echo_pipeline.SpaceManager({
      feedStore: this.feedStore,
      networkManager: this.networkManager,
      metadataStore: this.metadataStore,
      blobStore: this.blobStore
    });
  }
  get identity() {
    return this._props.signingContext ?? (0, import_debug.failUndefined)();
  }
  get echoHost() {
    return this._props.echoHost ??= new import_echo_pipeline.EchoHost({
      kv: this.level
    });
  }
  get meshEchoReplicator() {
    return this._props.meshEchoReplicator ??= new import_echo_pipeline.MeshEchoReplicator();
  }
  get dataSpaceManager() {
    return this._props.dataSpaceManager ??= new import_chunk_LMGLGOUU.DataSpaceManager({
      spaceManager: this.spaceManager,
      metadataStore: this.metadataStore,
      keyring: this.keyring,
      signingContext: this.identity,
      feedStore: this.feedStore,
      echoHost: this.echoHost,
      invitationsManager: this.invitationsManager,
      edgeConnection: void 0,
      meshReplicator: this.meshEchoReplicator,
      echoEdgeReplicator: void 0,
      runtimeParams: this._opts.dataSpaceParams
    });
  }
  get invitationsManager() {
    return this._props.invitationsManager ??= new import_chunk_LMGLGOUU.InvitationsManager(new import_chunk_LMGLGOUU.InvitationsHandler(this.networkManager), (invitation) => {
      if (invitation.kind === import_services2.Invitation.Kind.SPACE) {
        return new import_chunk_LMGLGOUU.SpaceInvitationProtocol(this.dataSpaceManager, this.identity, this.keyring, invitation.spaceKey);
      } else {
        throw new Error("not implemented");
      }
    }, this.metadataStore);
  }
  async createIdentity() {
    this._props.signingContext ??= await createSigningContext(this.keyring);
    this.networkManager.setPeerInfo({
      identityKey: this._props.signingContext.identityKey.toHex(),
      peerKey: this._props.signingContext.deviceKey.toHex()
    });
  }
  async destroy() {
    await this.level.close();
    await this.storage.reset();
  }
};
var createSigningContext = async (keyring) => {
  const identityKey = await keyring.createKey();
  const deviceKey = await keyring.createKey();
  return {
    identityKey,
    deviceKey,
    credentialSigner: (0, import_credentials2.createCredentialSignerWithChain)(keyring, {
      credential: await new import_credentials2.CredentialGenerator(keyring, identityKey, deviceKey).createDeviceAuthorization(deviceKey)
    }, deviceKey),
    recordCredential: async () => {
    },
    getProfile: () => void 0
  };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  TestBuilder,
  TestPeer,
  acceptInvitation,
  createIdentity,
  createInvitation,
  createMockCredential,
  createPeers,
  createServiceContext,
  createServiceHost,
  createSigningContext,
  performInvitation,
  sanitizeInvitation
});
//# sourceMappingURL=index.cjs.map
