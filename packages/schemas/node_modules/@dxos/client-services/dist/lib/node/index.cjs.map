{
  "version": 3,
  "sources": ["../../../src/packlets/worker/worker-runtime.ts", "../../../src/packlets/worker/worker-session.ts"],
  "sourcesContent": ["//\n// Copyright 2022 DXOS.org\n//\n\nimport { Trigger } from '@dxos/async';\nimport { DEFAULT_WORKER_BROADCAST_CHANNEL } from '@dxos/client-protocol';\nimport { type Config } from '@dxos/config';\nimport { Context } from '@dxos/context';\nimport { invariant } from '@dxos/invariant';\nimport { log } from '@dxos/log';\nimport {\n  MemorySignalManager,\n  MemorySignalManagerContext,\n  WebsocketSignalManager,\n  setIdentityTags,\n} from '@dxos/messaging';\nimport { RtcTransportProxyFactory } from '@dxos/network-manager';\nimport { type RpcPort } from '@dxos/rpc';\nimport { type MaybePromise } from '@dxos/util';\n\nimport { WorkerSession } from './worker-session';\nimport { ClientServicesHost } from '../services';\n\n// NOTE: Keep as RpcPorts to avoid dependency on @dxos/rpc-tunnel so we don't depend on browser-specific apis.\nexport type CreateSessionParams = {\n  appPort: RpcPort;\n  systemPort: RpcPort;\n  shellPort?: RpcPort;\n};\n\nexport type WorkerRuntimeOptions = {\n  channel?: string;\n  configProvider: () => MaybePromise<Config>;\n  acquireLock: () => Promise<void>;\n  releaseLock: () => void;\n  onStop?: () => Promise<void>;\n};\n\n/**\n * Runtime for the shared worker.\n * Manages connections from proxies (in tabs).\n * Tabs make requests to the `ClientServicesHost`, and provide a WebRTC gateway.\n */\nexport class WorkerRuntime {\n  private readonly _configProvider: () => MaybePromise<Config>;\n  private readonly _acquireLock: () => Promise<void>;\n  private readonly _releaseLock: () => void;\n  private readonly _onStop?: () => Promise<void>;\n  private readonly _transportFactory = new RtcTransportProxyFactory();\n  private readonly _ready = new Trigger<Error | undefined>();\n  private readonly _sessions = new Set<WorkerSession>();\n  private readonly _clientServices!: ClientServicesHost;\n  private readonly _channel: string;\n  private _broadcastChannel?: BroadcastChannel;\n  private _sessionForNetworking?: WorkerSession; // TODO(burdon): Expose to client QueryStatusResponse.\n  private _config!: Config;\n  private _signalMetadataTags: any = { runtime: 'worker-runtime' };\n  private _signalTelemetryEnabled: boolean = false;\n\n  constructor({\n    channel = DEFAULT_WORKER_BROADCAST_CHANNEL,\n    configProvider,\n    acquireLock,\n    releaseLock,\n    onStop,\n  }: WorkerRuntimeOptions) {\n    this._configProvider = configProvider;\n    this._acquireLock = acquireLock;\n    this._releaseLock = releaseLock;\n    this._onStop = onStop;\n    this._channel = channel;\n    this._clientServices = new ClientServicesHost({\n      callbacks: {\n        onReset: async () => this.stop(),\n      },\n    });\n  }\n\n  get host() {\n    return this._clientServices;\n  }\n\n  async start(): Promise<void> {\n    log('starting...');\n    try {\n      this._broadcastChannel = new BroadcastChannel(this._channel);\n      this._broadcastChannel.postMessage({ action: 'stop' });\n      this._broadcastChannel.onmessage = async (event) => {\n        if (event.data?.action === 'stop') {\n          await this.stop();\n        }\n      };\n\n      await this._acquireLock();\n      this._config = await this._configProvider();\n      const signals = this._config.get('runtime.services.signaling');\n      this._clientServices.initialize({\n        config: this._config,\n        signalManager: this._config.get('runtime.client.edgeFeatures')?.signaling\n          ? undefined\n          : signals\n            ? new WebsocketSignalManager(signals, () => (this._signalTelemetryEnabled ? this._signalMetadataTags : {}))\n            : new MemorySignalManager(new MemorySignalManagerContext()), // TODO(dmaretskyi): Inject this context.\n        transportFactory: this._transportFactory,\n      });\n\n      await this._clientServices.open(new Context());\n      this._ready.wake(undefined);\n      log('started');\n      setIdentityTags({\n        identityService: this._clientServices.services.IdentityService!,\n        devicesService: this._clientServices.services.DevicesService!,\n        setTag: (k: string, v: string) => {\n          this._signalMetadataTags[k] = v;\n        },\n      });\n    } catch (err: any) {\n      this._ready.wake(err);\n      log.error('starting', err);\n    }\n  }\n\n  async stop(): Promise<void> {\n    // Release the lock to notify remote clients that the worker is terminating.\n    this._releaseLock();\n    this._broadcastChannel?.close();\n    this._broadcastChannel = undefined;\n    await this._clientServices.close();\n    await this._onStop?.();\n  }\n\n  /**\n   * Create a new session.\n   */\n  async createSession({ appPort, systemPort, shellPort }: CreateSessionParams): Promise<void> {\n    const session = new WorkerSession({\n      serviceHost: this._clientServices,\n      appPort,\n      systemPort,\n      shellPort,\n      readySignal: this._ready,\n    });\n\n    // When tab is closed or client is destroyed.\n    session.onClose.set(async () => {\n      this._sessions.delete(session);\n      if (this._sessions.size === 0) {\n        // Terminate the worker when all sessions are closed.\n        await this.stop();\n      } else {\n        this._reconnectWebrtc();\n      }\n    });\n\n    await session.open();\n    // A worker can only service one origin currently\n    invariant(\n      !this._signalMetadataTags.origin || this._signalMetadataTags.origin === session.origin,\n      `worker origin changed from ${this._signalMetadataTags.origin} to ${session.origin}?`,\n    );\n    if (session.observabilityGroup) {\n      this._signalMetadataTags.group = session.observabilityGroup;\n    }\n    this._signalTelemetryEnabled = session.signalTelemetryEnabled ?? false;\n    this._signalMetadataTags.origin = session.origin;\n    this._sessions.add(session);\n\n    this._reconnectWebrtc();\n  }\n\n  /**\n   * Selects one of the existing session for WebRTC networking.\n   */\n  private _reconnectWebrtc(): void {\n    log('reconnecting webrtc...');\n    // Check if current session is already closed.\n    if (this._sessionForNetworking) {\n      if (!this._sessions.has(this._sessionForNetworking)) {\n        this._sessionForNetworking = undefined;\n      }\n    }\n\n    // Select existing session.\n    if (!this._sessionForNetworking) {\n      const selected = Array.from(this._sessions).find((session) => session.bridgeService);\n      if (selected) {\n        this._sessionForNetworking = selected;\n        this._transportFactory.setBridgeService(selected.bridgeService);\n      } else {\n        this._transportFactory.setBridgeService(undefined);\n      }\n    }\n  }\n}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { asyncTimeout, Trigger } from '@dxos/async';\nimport {\n  iframeServiceBundle,\n  type IframeServiceBundle,\n  PROXY_CONNECTION_TIMEOUT,\n  workerServiceBundle,\n} from '@dxos/client-protocol';\nimport { invariant } from '@dxos/invariant';\nimport { log, logInfo } from '@dxos/log';\nimport { type BridgeService } from '@dxos/protocols/proto/dxos/mesh/bridge';\nimport { createProtoRpcPeer, type ProtoRpcPeer, type RpcPort } from '@dxos/rpc';\nimport { Callback, type MaybePromise } from '@dxos/util';\n\nimport { type ClientServicesHost, ClientRpcServer, type ClientRpcServerParams } from '../services';\n\nexport type WorkerSessionParams = {\n  serviceHost: ClientServicesHost;\n  systemPort: RpcPort;\n  appPort: RpcPort;\n  // TODO(wittjosiah): Remove shellPort.\n  shellPort?: RpcPort;\n  readySignal: Trigger<Error | undefined>;\n};\n\n/**\n * Represents a tab connection within the worker.\n */\nexport class WorkerSession {\n  private readonly _clientRpc: ClientRpcServer;\n  private readonly _shellClientRpc?: ClientRpcServer;\n  private readonly _iframeRpc: ProtoRpcPeer<IframeServiceBundle>;\n  private readonly _startTrigger = new Trigger();\n  private readonly _serviceHost: ClientServicesHost;\n\n  public readonly onClose = new Callback<() => Promise<void>>();\n\n  @logInfo\n  public origin?: string;\n\n  // TODO(nf): factor out?\n  public observabilityGroup?: string;\n  public signalTelemetryEnabled?: boolean;\n\n  @logInfo\n  public lockKey?: string;\n\n  public bridgeService?: BridgeService;\n\n  constructor({ serviceHost, systemPort, appPort, shellPort, readySignal }: WorkerSessionParams) {\n    invariant(serviceHost);\n    this._serviceHost = serviceHost;\n\n    const middleware: Pick<ClientRpcServerParams, 'handleCall' | 'handleStream'> = {\n      handleCall: async (method, params, handler) => {\n        const error = await readySignal.wait({ timeout: PROXY_CONNECTION_TIMEOUT });\n        if (error) {\n          throw error;\n        }\n\n        return handler(method, params);\n      },\n      handleStream: async (method, params, handler) => {\n        const error = await readySignal.wait({ timeout: PROXY_CONNECTION_TIMEOUT });\n        if (error) {\n          throw error;\n        }\n\n        return handler(method, params);\n      },\n    };\n\n    this._clientRpc = new ClientRpcServer({\n      serviceRegistry: this._serviceHost.serviceRegistry,\n      port: appPort,\n      ...middleware,\n    });\n\n    this._shellClientRpc = shellPort\n      ? new ClientRpcServer({\n          serviceRegistry: this._serviceHost.serviceRegistry,\n          port: shellPort,\n          ...middleware,\n        })\n      : undefined;\n\n    this._iframeRpc = createProtoRpcPeer({\n      requested: iframeServiceBundle,\n      exposed: workerServiceBundle,\n      handlers: {\n        WorkerService: {\n          start: async (request) => {\n            this.origin = request.origin;\n            this.lockKey = request.lockKey;\n            this.observabilityGroup = request.observabilityGroup;\n            this.signalTelemetryEnabled = request.signalTelemetryEnabled;\n            this._startTrigger.wake();\n          },\n\n          stop: async () => {\n            setTimeout(async () => {\n              try {\n                await this.close();\n              } catch (err: any) {\n                log.catch(err);\n              }\n            });\n          },\n        },\n      },\n      port: systemPort,\n      timeout: 1_000, // With low timeout heartbeat may fail if the tab's thread is saturated.\n    });\n\n    this.bridgeService = this._iframeRpc.rpc.BridgeService;\n  }\n\n  async open(): Promise<void> {\n    log.info('opening...');\n    await Promise.all([this._clientRpc.open(), this._iframeRpc.open(), this._maybeOpenShell()]);\n\n    // Wait until the worker's RPC service has started.\n    await this._startTrigger.wait({ timeout: PROXY_CONNECTION_TIMEOUT });\n\n    // TODO(burdon): Comment required.\n    if (this.lockKey) {\n      void this._afterLockReleases(this.lockKey, () => this.close());\n    }\n\n    log.info('opened');\n  }\n\n  async close(): Promise<void> {\n    log.info('closing...');\n    try {\n      await this.onClose.callIfSet();\n    } catch (err: any) {\n      log.catch(err);\n    }\n\n    await Promise.all([this._clientRpc.close(), this._iframeRpc.close()]);\n    log.info('closed');\n  }\n\n  private async _maybeOpenShell(): Promise<void> {\n    try {\n      this._shellClientRpc && (await asyncTimeout(this._shellClientRpc.open(), 1_000));\n    } catch {\n      log.info('No shell connected.');\n    }\n  }\n\n  private _afterLockReleases(lockKey: string, callback: () => MaybePromise<void>): Promise<void> {\n    return navigator.locks\n      .request(lockKey, () => {\n        // No-op.\n      })\n      .then(callback);\n  }\n}\n"],
  "mappings": "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",
  "names": ["import_async", "import_client_protocol", "import_invariant", "import_log", "WorkerSession", "serviceHost", "systemPort", "appPort", "shellPort", "readySignal", "_startTrigger", "Trigger", "onClose", "Callback", "invariant", "_serviceHost", "middleware", "handleCall", "method", "params", "handler", "error", "wait", "timeout", "PROXY_CONNECTION_TIMEOUT", "handleStream", "_clientRpc", "ClientRpcServer", "serviceRegistry", "port", "_shellClientRpc", "undefined", "_iframeRpc", "createProtoRpcPeer", "requested", "iframeServiceBundle", "exposed", "workerServiceBundle", "handlers", "WorkerService", "start", "request", "origin", "lockKey", "observabilityGroup", "signalTelemetryEnabled", "wake", "stop", "setTimeout", "close", "err", "log", "catch", "bridgeService", "rpc", "BridgeService", "open", "info", "Promise", "all", "_maybeOpenShell", "_afterLockReleases", "callIfSet", "asyncTimeout", "callback", "navigator", "locks", "then", "WorkerRuntime", "channel", "DEFAULT_WORKER_BROADCAST_CHANNEL", "configProvider", "acquireLock", "releaseLock", "onStop", "_transportFactory", "RtcTransportProxyFactory", "_ready", "_sessions", "Set", "_signalMetadataTags", "runtime", "_signalTelemetryEnabled", "_configProvider", "_acquireLock", "_releaseLock", "_onStop", "_channel", "_clientServices", "ClientServicesHost", "callbacks", "onReset", "host", "_broadcastChannel", "BroadcastChannel", "postMessage", "action", "onmessage", "event", "data", "_config", "signals", "get", "initialize", "config", "signalManager", "signaling", "WebsocketSignalManager", "MemorySignalManager", "MemorySignalManagerContext", "transportFactory", "Context", "setIdentityTags", "identityService", "services", "IdentityService", "devicesService", "DevicesService", "setTag", "k", "v", "createSession", "session", "set", "delete", "size", "_reconnectWebrtc", "group", "add", "_sessionForNetworking", "has", "selected", "Array", "from", "find", "setBridgeService"]
}
