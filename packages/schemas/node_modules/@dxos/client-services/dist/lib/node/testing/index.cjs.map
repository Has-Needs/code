{
  "version": 3,
  "sources": ["../../../../src/packlets/testing/credential-utils.ts", "../../../../src/packlets/testing/invitation-utils.ts", "../../../../src/packlets/testing/test-builder.ts"],
  "sourcesContent": ["//\n// Copyright 2023 DXOS.org\n//\n\nimport { createCredential } from '@dxos/credentials';\nimport { type Signer } from '@dxos/crypto';\nimport { PublicKey } from '@dxos/keys';\nimport { type Credential } from '@dxos/protocols/proto/dxos/halo/credentials';\n\nexport const createMockCredential = async ({\n  signer,\n  issuer,\n}: {\n  signer: Signer;\n  issuer: PublicKey;\n}): Promise<Credential> =>\n  createCredential({\n    signer,\n    issuer,\n    subject: new PublicKey(Buffer.from('test')),\n    assertion: {\n      '@type': 'example.testing.rpc.MessageWithAny',\n      payload: {\n        '@type': 'google.protobuf.Any',\n        value: Buffer.from('test'),\n      },\n    },\n  });\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { Trigger } from '@dxos/async';\nimport { InvitationEncoder, type AuthenticatingInvitation, type CancellableInvitation } from '@dxos/client-protocol';\nimport { invariant } from '@dxos/invariant';\nimport { Invitation } from '@dxos/protocols/proto/dxos/client/services';\nimport { type DeviceProfileDocument } from '@dxos/protocols/proto/dxos/halo/credentials';\n\nimport { ServiceContext } from '../services';\n\n/**\n * Strip secrets from invitation before giving it to the peer.\n */\nexport const sanitizeInvitation = (invitation: Invitation): Invitation => {\n  return InvitationEncoder.decode(InvitationEncoder.encode(invitation));\n};\n\nexport type InvitationHost = {\n  share(options?: Partial<Invitation>): CancellableInvitation;\n};\n\nexport type InvitationGuest = {\n  join(invitation: Invitation | string, deviceProfile?: DeviceProfileDocument): AuthenticatingInvitation;\n};\n\nexport type PerformInvitationCallbacks<T> = {\n  onConnecting?: (value: T) => boolean | void;\n  onConnected?: (value: T) => boolean | void;\n  onReady?: (value: T) => boolean | void;\n  onAuthenticating?: (value: T) => boolean | void;\n  onSuccess?: (value: T) => boolean | void;\n  onCancelled?: (value: T) => boolean | void;\n  onTimeout?: (value: T) => boolean | void;\n  onError?: (value: T) => boolean | void;\n};\n\nexport type PerformInvitationParams = {\n  host: ServiceContext | InvitationHost;\n  guest: ServiceContext | InvitationGuest;\n  options?: Partial<Invitation>;\n  hooks?: {\n    host?: PerformInvitationCallbacks<CancellableInvitation>;\n    guest?: PerformInvitationCallbacks<AuthenticatingInvitation>;\n  };\n  guestDeviceProfile?: DeviceProfileDocument;\n  codeInputDelay?: number;\n};\n\nexport type Result = { invitation?: Invitation; error?: Error };\n\n// TODO(burdon): Make async.\n// TODO(burdon): Rename startInvitation.\nexport const performInvitation = ({\n  host,\n  guest,\n  options,\n  hooks,\n  guestDeviceProfile,\n  codeInputDelay,\n}: PerformInvitationParams): [Promise<Result>, Promise<Result>] => {\n  let guestError = false;\n  let guestConnected = false;\n  let wereConnected = false;\n  const hostComplete = new Trigger<Result>();\n  const guestComplete = new Trigger<Result>();\n  const authCode = new Trigger<string>();\n\n  void createInvitation(host, options).then((hostObservable) => {\n    hostObservable.subscribe(\n      async (hostInvitation: Invitation) => {\n        switch (hostInvitation.state) {\n          case Invitation.State.CONNECTING: {\n            if (guestConnected) {\n              if (wereConnected) {\n                hostComplete.wake({ invitation: hostInvitation });\n              }\n              break;\n            }\n\n            guestConnected = true;\n            if (hooks?.host?.onConnecting?.(hostObservable)) {\n              break;\n            }\n\n            const guestObservable = acceptInvitation(guest, hostInvitation, guestDeviceProfile);\n            guestObservable.subscribe(\n              async (guestInvitation: Invitation) => {\n                switch (guestInvitation.state) {\n                  case Invitation.State.CONNECTING: {\n                    if (hooks?.guest?.onConnecting?.(guestObservable)) {\n                      break;\n                    }\n                    invariant(hostInvitation.swarmKey!.equals(guestInvitation.swarmKey!));\n                    break;\n                  }\n\n                  case Invitation.State.CONNECTED: {\n                    hooks?.guest?.onConnected?.(guestObservable);\n                    break;\n                  }\n\n                  case Invitation.State.READY_FOR_AUTHENTICATION: {\n                    if (hooks?.guest?.onReady?.(guestObservable)) {\n                      break;\n                    }\n                    const code = await authCode.wait();\n                    if (codeInputDelay == null) {\n                      await guestObservable.authenticate(code);\n                    } else {\n                      setTimeout(async () => {\n                        if (!guestError) {\n                          await guestObservable.authenticate(code);\n                        }\n                      }, codeInputDelay);\n                    }\n                    break;\n                  }\n\n                  case Invitation.State.AUTHENTICATING: {\n                    hooks?.guest?.onAuthenticating?.(guestObservable);\n                    break;\n                  }\n\n                  case Invitation.State.SUCCESS: {\n                    if (hooks?.guest?.onSuccess?.(guestObservable)) {\n                      break;\n                    }\n                    guestComplete.wake({ invitation: guestInvitation });\n                    break;\n                  }\n\n                  case Invitation.State.CANCELLED: {\n                    if (hooks?.guest?.onCancelled?.(guestObservable)) {\n                      break;\n                    }\n                    guestComplete.wake({ invitation: guestInvitation });\n                    break;\n                  }\n\n                  case Invitation.State.TIMEOUT: {\n                    if (hooks?.guest?.onTimeout?.(guestObservable)) {\n                      return;\n                    }\n                    guestComplete.wake({ invitation: guestInvitation });\n                  }\n                }\n              },\n              (error: Error) => {\n                guestError = true;\n                if (hooks?.guest?.onError?.(guestObservable)) {\n                  return;\n                }\n                guestComplete.wake({ error });\n              },\n            );\n            break;\n          }\n\n          case Invitation.State.CONNECTED: {\n            wereConnected = true;\n            hooks?.host?.onConnected?.(hostObservable);\n            break;\n          }\n\n          case Invitation.State.READY_FOR_AUTHENTICATION: {\n            if (hooks?.host?.onReady?.(hostObservable)) {\n              break;\n            }\n            if (hostInvitation.authCode) {\n              authCode.wake(hostInvitation.authCode);\n            }\n            break;\n          }\n\n          case Invitation.State.AUTHENTICATING: {\n            hooks?.host?.onAuthenticating?.(hostObservable);\n            break;\n          }\n\n          case Invitation.State.SUCCESS: {\n            if (hooks?.host?.onSuccess?.(hostObservable)) {\n              break;\n            }\n            hostComplete.wake({ invitation: hostInvitation });\n            break;\n          }\n\n          case Invitation.State.CANCELLED: {\n            if (hooks?.host?.onCancelled?.(hostObservable)) {\n              break;\n            }\n            hostComplete.wake({ invitation: hostInvitation });\n            break;\n          }\n\n          case Invitation.State.TIMEOUT: {\n            if (hooks?.host?.onTimeout?.(hostObservable)) {\n              break;\n            }\n            hostComplete.wake({ invitation: hostInvitation });\n            break;\n          }\n        }\n      },\n      (error: Error) => {\n        if (hooks?.host?.onError?.(hostObservable)) {\n          return;\n        }\n        hostComplete.wake({ error });\n      },\n    );\n  });\n\n  return [hostComplete.wait(), guestComplete.wait()];\n};\n\nexport const createInvitation = async (\n  host: ServiceContext | InvitationHost,\n  options?: Partial<Invitation>,\n): Promise<CancellableInvitation> => {\n  options ??= {\n    authMethod: Invitation.AuthMethod.NONE,\n    ...(options ?? {}),\n  };\n\n  if (host instanceof ServiceContext) {\n    return host.invitationsManager.createInvitation({\n      kind: Invitation.Kind.SPACE,\n      ...options,\n    });\n  }\n\n  return host.share(options);\n};\n\nexport const acceptInvitation = (\n  guest: ServiceContext | InvitationGuest,\n  invitation: Invitation,\n  guestDeviceProfile?: DeviceProfileDocument,\n): AuthenticatingInvitation => {\n  invitation = sanitizeInvitation(invitation);\n\n  if (guest instanceof ServiceContext) {\n    return guest.invitationsManager.acceptInvitation({\n      invitation,\n      deviceProfile: guestDeviceProfile,\n    });\n  }\n\n  return guest.join(invitation, guestDeviceProfile);\n};\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { type Config } from '@dxos/config';\nimport { Context } from '@dxos/context';\nimport { createCredentialSignerWithChain, CredentialGenerator } from '@dxos/credentials';\nimport { failUndefined } from '@dxos/debug';\nimport { EchoHost, MetadataStore, SpaceManager, valueEncoding, MeshEchoReplicator } from '@dxos/echo-pipeline';\nimport { FeedFactory, FeedStore } from '@dxos/feed-store';\nimport { Keyring } from '@dxos/keyring';\nimport { type LevelDB } from '@dxos/kv-store';\nimport { createTestLevel } from '@dxos/kv-store/testing';\nimport { MemorySignalManager, MemorySignalManagerContext, type SignalManager } from '@dxos/messaging';\nimport { MemoryTransportFactory, SwarmNetworkManager } from '@dxos/network-manager';\nimport { Invitation } from '@dxos/protocols/proto/dxos/client/services';\nimport { createStorage, StorageType, type Storage } from '@dxos/random-access-storage';\nimport { BlobStore } from '@dxos/teleport-extension-object-sync';\n\nimport { InvitationsHandler, InvitationsManager, SpaceInvitationProtocol } from '../invitations';\nimport { ClientServicesHost, ServiceContext, type ServiceContextRuntimeParams } from '../services';\nimport { DataSpaceManager, type DataSpaceManagerRuntimeParams, type SigningContext } from '../spaces';\n\n//\n// TODO(burdon): Replace with test builder.\n//\n\nexport const createServiceHost = (config: Config, signalManagerContext: MemorySignalManagerContext) => {\n  return new ClientServicesHost({\n    config,\n    signalManager: new MemorySignalManager(signalManagerContext),\n    transportFactory: MemoryTransportFactory,\n  });\n};\n\nexport const createServiceContext = async ({\n  signalManagerFactory = async () => {\n    const signalContext = new MemorySignalManagerContext();\n    return new MemorySignalManager(signalContext);\n  },\n  storage = createStorage({ type: StorageType.RAM }),\n  runtimeParams,\n}: {\n  signalManagerFactory?: () => Promise<SignalManager>;\n  storage?: Storage;\n  runtimeParams?: ServiceContextRuntimeParams;\n} = {}) => {\n  const signalManager = await signalManagerFactory();\n  const networkManager = new SwarmNetworkManager({\n    signalManager,\n    transportFactory: MemoryTransportFactory,\n  });\n  const level = createTestLevel();\n  await level.open();\n\n  return new ServiceContext(storage, level, networkManager, signalManager, undefined, undefined, {\n    invitationConnectionDefaultParams: { teleport: { controlHeartbeatInterval: 200 } },\n    ...runtimeParams,\n  });\n};\n\nexport const createPeers = async (numPeers: number, signalManagerFactory?: () => Promise<SignalManager>) => {\n  if (!signalManagerFactory) {\n    const signalContext = new MemorySignalManagerContext();\n    signalManagerFactory = async () => new MemorySignalManager(signalContext);\n  }\n  return await Promise.all(\n    Array.from(Array(numPeers)).map(async () => {\n      const peer = await createServiceContext({ signalManagerFactory });\n      await peer.open(new Context());\n      return peer;\n    }),\n  );\n};\n\nexport const createIdentity = async (peer: ServiceContext) => {\n  await peer.createIdentity();\n  return peer;\n};\n\nexport class TestBuilder {\n  public readonly signalContext = new MemorySignalManagerContext();\n  private readonly _ctx = new Context();\n\n  createPeer(peerOptions?: TestPeerOpts): TestPeer {\n    const peer = new TestPeer(this.signalContext, peerOptions);\n    this._ctx.onDispose(async () => peer.destroy());\n    return peer;\n  }\n\n  async destroy(): Promise<void> {\n    await this._ctx.dispose();\n  }\n}\n\nexport type TestPeerOpts = {\n  dataStore?: StorageType;\n  dataSpaceParams?: DataSpaceManagerRuntimeParams;\n};\n\nexport type TestPeerProps = {\n  storage?: Storage;\n  level?: LevelDB;\n  feedStore?: FeedStore<any>;\n  metadataStore?: MetadataStore;\n  keyring?: Keyring;\n  networkManager?: SwarmNetworkManager;\n  spaceManager?: SpaceManager;\n  dataSpaceManager?: DataSpaceManager;\n  signingContext?: SigningContext;\n  blobStore?: BlobStore;\n  echoHost?: EchoHost;\n  meshEchoReplicator?: MeshEchoReplicator;\n  invitationsManager?: InvitationsManager;\n};\n\nexport class TestPeer {\n  private _props: TestPeerProps = {};\n\n  constructor(\n    private readonly _signalContext: MemorySignalManagerContext,\n    private readonly _opts: TestPeerOpts = { dataStore: StorageType.RAM },\n  ) {}\n\n  get props() {\n    return this._props;\n  }\n\n  get storage() {\n    return (this._props.storage ??= createStorage({ type: this._opts.dataStore }));\n  }\n\n  get keyring() {\n    return (this._props.keyring ??= new Keyring(this.storage.createDirectory('keyring')));\n  }\n\n  get level() {\n    return (this._props.level ??= createTestLevel());\n  }\n\n  get feedStore() {\n    return (this._props.feedStore ??= new FeedStore({\n      factory: new FeedFactory({\n        root: this.storage.createDirectory('feeds'),\n        signer: this.keyring,\n        hypercore: {\n          valueEncoding,\n        },\n      }),\n    }));\n  }\n\n  get metadataStore() {\n    return (this._props.metadataStore ??= new MetadataStore(this.storage.createDirectory('metadata')));\n  }\n\n  get blobStore() {\n    return (this._props.blobStore ??= new BlobStore(this.storage.createDirectory('blobs')));\n  }\n\n  get networkManager() {\n    return (this._props.networkManager ??= new SwarmNetworkManager({\n      signalManager: new MemorySignalManager(this._signalContext),\n      transportFactory: MemoryTransportFactory,\n    }));\n  }\n\n  get spaceManager() {\n    return (this._props.spaceManager ??= new SpaceManager({\n      feedStore: this.feedStore,\n      networkManager: this.networkManager,\n      metadataStore: this.metadataStore,\n      blobStore: this.blobStore,\n    }));\n  }\n\n  get identity() {\n    return this._props.signingContext ?? failUndefined();\n  }\n\n  get echoHost() {\n    return (this._props.echoHost ??= new EchoHost({ kv: this.level }));\n  }\n\n  get meshEchoReplicator() {\n    return (this._props.meshEchoReplicator ??= new MeshEchoReplicator());\n  }\n\n  get dataSpaceManager(): DataSpaceManager {\n    return (this._props.dataSpaceManager ??= new DataSpaceManager({\n      spaceManager: this.spaceManager,\n      metadataStore: this.metadataStore,\n      keyring: this.keyring,\n      signingContext: this.identity,\n      feedStore: this.feedStore,\n      echoHost: this.echoHost,\n      invitationsManager: this.invitationsManager,\n      edgeConnection: undefined,\n      meshReplicator: this.meshEchoReplicator,\n      echoEdgeReplicator: undefined,\n      runtimeParams: this._opts.dataSpaceParams,\n    }));\n  }\n\n  get invitationsManager() {\n    return (this._props.invitationsManager ??= new InvitationsManager(\n      new InvitationsHandler(this.networkManager),\n      (invitation) => {\n        if (invitation.kind === Invitation.Kind.SPACE) {\n          return new SpaceInvitationProtocol(this.dataSpaceManager, this.identity!, this.keyring, invitation.spaceKey!);\n        } else {\n          throw new Error('not implemented');\n        }\n      },\n      this.metadataStore,\n    ));\n  }\n\n  async createIdentity(): Promise<void> {\n    this._props.signingContext ??= await createSigningContext(this.keyring);\n    this.networkManager.setPeerInfo({\n      identityKey: this._props.signingContext.identityKey.toHex(),\n      peerKey: this._props.signingContext.deviceKey.toHex(),\n    });\n  }\n\n  async destroy(): Promise<void> {\n    await this.level.close();\n    await this.storage.reset();\n  }\n}\n\nexport const createSigningContext = async (keyring: Keyring): Promise<SigningContext> => {\n  const identityKey = await keyring.createKey();\n  const deviceKey = await keyring.createKey();\n\n  return {\n    identityKey,\n    deviceKey,\n    credentialSigner: createCredentialSignerWithChain(\n      keyring,\n      {\n        credential: await new CredentialGenerator(keyring, identityKey, deviceKey).createDeviceAuthorization(deviceKey),\n      },\n      deviceKey,\n    ),\n    recordCredential: async () => {}, // No-op.\n    getProfile: () => undefined,\n  };\n};\n"],
  "mappings": "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",
  "names": ["import_credentials", "import_services", "createMockCredential", "signer", "issuer", "createCredential", "subject", "PublicKey", "Buffer", "from", "assertion", "payload", "value", "sanitizeInvitation", "invitation", "InvitationEncoder", "decode", "encode", "performInvitation", "host", "guest", "options", "hooks", "guestDeviceProfile", "codeInputDelay", "guestError", "guestConnected", "wereConnected", "hostComplete", "Trigger", "guestComplete", "authCode", "createInvitation", "then", "hostObservable", "subscribe", "hostInvitation", "state", "Invitation", "State", "CONNECTING", "wake", "onConnecting", "guestObservable", "acceptInvitation", "guestInvitation", "invariant", "swarmKey", "equals", "CONNECTED", "onConnected", "READY_FOR_AUTHENTICATION", "onReady", "code", "wait", "authenticate", "setTimeout", "AUTHENTICATING", "onAuthenticating", "SUCCESS", "onSuccess", "CANCELLED", "onCancelled", "TIMEOUT", "onTimeout", "error", "onError", "authMethod", "AuthMethod", "NONE", "ServiceContext", "invitationsManager", "kind", "Kind", "SPACE", "share", "deviceProfile", "join", "createServiceHost", "config", "signalManagerContext", "ClientServicesHost", "signalManager", "MemorySignalManager", "transportFactory", "MemoryTransportFactory", "createServiceContext", "signalManagerFactory", "signalContext", "MemorySignalManagerContext", "storage", "createStorage", "type", "StorageType", "RAM", "runtimeParams", "networkManager", "SwarmNetworkManager", "level", "createTestLevel", "open", "undefined", "invitationConnectionDefaultParams", "teleport", "controlHeartbeatInterval", "createPeers", "numPeers", "Promise", "all", "Array", "map", "peer", "Context", "createIdentity", "TestBuilder", "_ctx", "createPeer", "peerOptions", "TestPeer", "onDispose", "destroy", "dispose", "_signalContext", "_opts", "dataStore", "_props", "props", "keyring", "Keyring", "createDirectory", "feedStore", "FeedStore", "factory", "FeedFactory", "root", "hypercore", "valueEncoding", "metadataStore", "MetadataStore", "blobStore", "BlobStore", "spaceManager", "SpaceManager", "identity", "signingContext", "failUndefined", "echoHost", "EchoHost", "kv", "meshEchoReplicator", "MeshEchoReplicator", "dataSpaceManager", "DataSpaceManager", "edgeConnection", "meshReplicator", "echoEdgeReplicator", "dataSpaceParams", "InvitationsManager", "InvitationsHandler", "SpaceInvitationProtocol", "spaceKey", "Error", "createSigningContext", "setPeerInfo", "identityKey", "toHex", "peerKey", "deviceKey", "close", "reset", "createKey", "credentialSigner", "createCredentialSignerWithChain", "credential", "CredentialGenerator", "createDeviceAuthorization", "recordCredential", "getProfile"]
}
