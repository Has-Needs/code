"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var node_exports = {};
__export(node_exports, {
  OBJECT_CONVERSION_OPTIONS: () => OBJECT_CONVERSION_OPTIONS,
  ProtoCodec: () => ProtoCodec,
  Schema: () => Schema,
  Service: () => Service,
  ServiceDescriptor: () => ServiceDescriptor,
  ServiceHandler: () => ServiceHandler,
  Stream: () => import_chunk_IOJXLIVL.Stream,
  anySubstitutions: () => anySubstitutions,
  compressSchema: () => compressSchema,
  createMappingDescriptors: () => createMappingDescriptors,
  decodeProtobuf: () => decodeProtobuf,
  decompressSchema: () => decompressSchema,
  encodeProtobuf: () => encodeProtobuf,
  getFirstStreamValue: () => getFirstStreamValue,
  mapMessage: () => mapMessage,
  patchBufferCodec: () => patchBufferCodec,
  sanitize: () => sanitize,
  structSubstitutions: () => structSubstitutions,
  timestampSubstitutions: () => timestampSubstitutions
});
module.exports = __toCommonJS(node_exports);
var import_chunk_IOJXLIVL = require("./chunk-IOJXLIVL.cjs");
var import_util = require("@dxos/util");
var import_protobufjs = __toESM(require("protobufjs"));
var import_invariant = require("@dxos/invariant");
var protobuf = __toESM(require("protobufjs"));
var import_protobufjs2 = __toESM(require("protobufjs"));
var import_invariant2 = require("@dxos/invariant");
var import_protobufjs3 = __toESM(require("protobufjs"));
var import_lodash = __toESM(require("lodash.merge"));
var import_protobufjs4 = __toESM(require("protobufjs"));
var import_invariant3 = require("@dxos/invariant");
var import_util2 = require("@dxos/util");
var import_compress_json = require("compress-json");
var import_async = require("@dxos/async");
var patchBufferCodec = (codec) => ({
  encode: (x) => (0, import_util.arrayToBuffer)(codec.encode(x)),
  decode: codec.decode.bind(codec)
});
var Ref = Symbol("Ref");
var ref = (value) => ({
  [Ref]: true,
  value
});
var isRef = (value) => value[Ref] === true;
var codegen = (name, args, gen, ctx = {}) => {
  const newCtx = {
    ...ctx
  };
  let nextAnnon = 1;
  let buf = "";
  gen((parts, ...args2) => {
    const preprocessArg = (arg) => {
      if (isRef(arg)) {
        const name2 = `anon${nextAnnon++}`;
        newCtx[name2] = arg.value;
        return name2;
      } else {
        return arg;
      }
    };
    buf += parts.map((s, i) => s + (i < args2.length ? preprocessArg(args2[i]) : "")).join("") + "\n";
  });
  const code = `return function ${name}(${args.join(", ")}) {
${buf}
}`;
  return Function(...Object.keys(newCtx), code)(...Object.values(newCtx));
};
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/common/codec-protobuf/src/precompiled-mapping/create-message-mapper.ts";
var createMessageMapper = (type, substitutions) => createMessageMapperCached(type, substitutions, {}).map;
var createMessageMapperCached = (type, substitutions, cache) => {
  if (!cache[type.fullName]) {
    cache[type.fullName] = {};
    cache[type.fullName].map = codegen(`${type.name}$map`, [
      "obj",
      "extraArgs"
    ], (c) => {
      c`const res = {};`;
      for (const field of type.fieldsArray) {
        field.resolve();
        c`if(obj.${field.name} !== undefined && obj.${field.name} !== null) {`;
        {
          const genMapScalar = (value) => {
            const substitution = field.resolvedType && substitutions[field.resolvedType.fullName.slice(1)];
            if (substitution) {
              const context = {
                messageName: type.fullName.slice(1),
                fieldName: field.name
              };
              c`${ref(substitution)}(${value}, ${ref(context)}, ...extraArgs)`;
            } else if (field.resolvedType && field.resolvedType instanceof import_protobufjs.default.Type) {
              const mapper = createMessageMapperCached(field.resolvedType, substitutions, cache);
              c`${ref(mapper)}.map(${value}, extraArgs)`;
            } else {
              c`${value}`;
            }
          };
          if (field.repeated) {
            c`res.${field.name} = obj.${field.name}.map(item => `;
            genMapScalar("item");
            c`);`;
          } else if (field.map) {
            (0, import_invariant.invariant)(field instanceof import_protobufjs.default.MapField, void 0, {
              F: __dxlog_file,
              L: 52,
              S: void 0,
              A: [
                "field instanceof pb.MapField",
                ""
              ]
            });
            c`res.${field.name} = {};`;
            c`for(const key of Object.keys(obj.${field.name})) {`;
            {
              c`res.${field.name}[key] = `;
              genMapScalar(`obj.${field.name}[key]`);
              c`;`;
            }
            c`}`;
          } else {
            c`res.${field.name} = `;
            genMapScalar(`obj.${field.name}`);
            c`;`;
          }
        }
        c`}`;
        if (!field.getOption("proto3_optional") && !field.repeated && !field.map && !field.partOf) {
          c`else {`;
          {
            if (field.resolvedType instanceof import_protobufjs.default.Type) {
              const mapper = createMessageMapperCached(field.resolvedType, substitutions, cache);
              c`res.${field.name} = ${ref(mapper)}.map({}, extraArgs);`;
            } else if (field.resolvedType instanceof import_protobufjs.default.Enum) {
              `res.${field.name} = 0;`;
            } else {
              c`res.${field.name} = ${getDefaultValue(field.type)};`;
            }
          }
          c`}`;
        }
      }
      c`return res;`;
    });
  }
  return cache[type.fullName];
};
var getDefaultValue = (type) => {
  switch (type) {
    case "double":
    case "float":
    case "int32":
    case "sfixed32":
    case "uint32":
    case "sint32":
    case "fixed32":
      return "0";
    case "sint64":
    case "int64":
    case "uint64":
    case "fixed64":
    case "sfixed64":
      return '"0"';
    case "bool":
      return "false";
    case "string":
      return '""';
    case "bytes":
      return "new Uint8Array()";
    default:
      throw new Error(`Unknown type: ${type}`);
  }
};
var OBJECT_CONVERSION_OPTIONS = {
  // Represent long integers as strings.
  longs: String,
  // Will set empty repeated fields to [] instead of undefined.
  arrays: true
};
var JSON_CONVERSION_OPTIONS = {
  // TODO(dmaretskyi): Internal crash with the current version of protobufjs.
  // longs: String,
  enums: String,
  bytes: String,
  defaults: false,
  json: true
};
var ProtoCodec = class {
  constructor(_type, _mapping, _schema) {
    this._type = _type;
    this._mapping = _mapping;
    this._schema = _schema;
    this._encodeMapper = createMessageMapper(this._type, this._mapping.encode);
    this._decodeMapper = createMessageMapper(this._type, this._mapping.decode);
  }
  /**
  * Underlying protobuf.js type descriptor.
  */
  get protoType() {
    return this._type;
  }
  get substitutionMappings() {
    return this._mapping;
  }
  /**
  * Reference to the protobuf schema this codec was created from.
  */
  get schema() {
    return this._schema;
  }
  encode(value, options = {}) {
    const sub = this._encodeMapper(value, [
      this._schema,
      options
    ]);
    return this._type.encode(sub).finish();
  }
  decode(data, options = {}) {
    const obj = this._type.toObject(this._type.decode(data), OBJECT_CONVERSION_OPTIONS);
    return this._decodeMapper(obj, [
      this._schema,
      options
    ]);
  }
  encodeAsAny(value, options = {}) {
    return {
      "@type": "google.protobuf.Any",
      type_url: this._type.fullName.slice(1),
      value: this.encode(value, options)
    };
  }
  fromObject(obj) {
    return this._decodeMapper(this._type.fromObject(obj).toJSON(), [
      this._schema
    ]);
  }
  /**
  * Dynamically add new definitions to this codec. Mutates the underlying schema.
  */
  addJson(schema) {
    this._schema.addJson(schema);
  }
  encodeToJson(value, options = {}) {
    const sub = this._encodeMapper(value, [
      this._schema,
      options
    ]);
    return this._type.toObject(sub, JSON_CONVERSION_OPTIONS);
  }
  decodeFromJson(data, options = {}) {
    const obj = this._type.toObject(this._type.fromObject(data), OBJECT_CONVERSION_OPTIONS);
    return this._decodeMapper(obj, [
      this._schema,
      options
    ]);
  }
};
var encodeProtobuf = (root) => root.toJSON();
var decodeProtobuf = (struct) => protobuf.Root.fromJSON(struct);
var __dxlog_file2 = "/home/runner/work/dxos/dxos/packages/common/codec-protobuf/src/mapping.ts";
var createMappingDescriptors = (substitutions) => {
  const encode = {};
  const decode = {};
  for (const type of Object.keys(substitutions)) {
    encode[type] = substitutions[type].encode;
    decode[type] = substitutions[type].decode;
  }
  return {
    encode,
    decode
  };
};
var mapMessage = async (type, mapper, obj) => {
  const res = {};
  for (const field of type.fieldsArray) {
    if (!(field.name in obj)) {
      continue;
    }
    res[field.name] = await mapField(field, mapper, obj[field.name]);
  }
  return res;
};
var mapField = async (field, mapper, value) => {
  if (!field.required && (value === null || value === void 0)) {
    return value;
  } else if (field.repeated) {
    return await Promise.all(value.map((value2) => mapScalarField(field, mapper, value2)));
  } else if (field.map) {
    (0, import_invariant2.invariant)(field instanceof import_protobufjs2.default.MapField, void 0, {
      F: __dxlog_file2,
      L: 62,
      S: void 0,
      A: [
        "field instanceof protobufjs.MapField",
        ""
      ]
    });
    return await asyncObjectMap((value2) => mapScalarField(field, mapper, value2), value);
  } else {
    return mapScalarField(field, mapper, value);
  }
};
var mapScalarField = async (field, mapper, value) => {
  if (!field.resolved) {
    field.resolve();
  }
  const typeName = field.resolvedType?.fullName.slice(1);
  if (typeName) {
    return await mapper(value, typeName);
  }
  if (field.resolvedType && field.resolvedType instanceof import_protobufjs2.default.Type) {
    return await mapMessage(field.resolvedType, mapper, value);
  }
  return value;
};
var asyncObjectMap = async (map, record) => {
  const res = {};
  await Promise.all(Object.entries(record).map(async ([key, value]) => {
    res[key] = await map(value, key);
  }));
  return res;
};
var sanitize = (type, value, path, context) => {
  if (!value) {
    return;
  }
  for (const key of Object.keys(value)) {
    if (!type.fields[key]) {
      continue;
    }
    const field = type.fields[key];
    if (field.repeated) {
      continue;
    }
    field.resolve();
    if (!field.resolvedType) {
      continue;
    }
    if (field.resolvedType instanceof import_protobufjs3.default.Type) {
      sanitize(field.resolvedType, value[key], `${path}.${key}`, context);
    } else if (field.resolvedType instanceof import_protobufjs3.default.Enum) {
      value[key] = sanitizeEnum(field.resolvedType, value[key], `${path}.${key}`, context);
    }
  }
};
var sanitizeEnum = (type, value, path, context) => {
  if (type.valuesById[value]) {
    return value;
  }
  if (typeof value === "string") {
    const normalizedValue = value.toLowerCase();
    for (const [name, tag] of Object.entries(type.values)) {
      if (name.toLowerCase() === normalizedValue) {
        return tag;
      }
    }
  }
  context.errors.push(`Invalid enum value: value=${JSON.stringify(value)} enum=${type.fullName} path=${path}`);
  return value;
};
var __dxlog_file3 = "/home/runner/work/dxos/dxos/packages/common/codec-protobuf/src/service.ts";
var ServiceDescriptor = class {
  // prettier-ignore
  constructor(_service, _schema) {
    this._service = _service;
    this._schema = _schema;
  }
  get serviceProto() {
    return this._service;
  }
  get name() {
    return this._service.fullName.slice(1);
  }
  createClient(backend, encodingOptions) {
    return new Service(backend, this._service, this._schema, encodingOptions);
  }
  createServer(handlers, encodingOptions) {
    return new ServiceHandler(this._service, this._schema, handlers, encodingOptions);
  }
};
var Service = class {
  constructor(backend, service, schema, encodingOptions) {
    for (const method of service.methodsArray) {
      method.resolve();
      (0, import_invariant3.invariant)(method.resolvedRequestType, void 0, {
        F: __dxlog_file3,
        L: 59,
        S: this,
        A: [
          "method.resolvedRequestType",
          ""
        ]
      });
      (0, import_invariant3.invariant)(method.resolvedResponseType, void 0, {
        F: __dxlog_file3,
        L: 60,
        S: this,
        A: [
          "method.resolvedResponseType",
          ""
        ]
      });
      (0, import_invariant3.invariant)(!method.requestStream, "Streaming RPC requests are not supported.", {
        F: __dxlog_file3,
        L: 61,
        S: this,
        A: [
          "!method.requestStream",
          "'Streaming RPC requests are not supported.'"
        ]
      });
      const requestCodec = schema.tryGetCodecForType(method.resolvedRequestType.fullName);
      const responseCodec = schema.tryGetCodecForType(method.resolvedResponseType.fullName);
      const methodName = mapRpcMethodName(method.name);
      if (method.responseStream) {
        this[methodName] = (request, requestOptions) => {
          const encoded = requestCodec.encode(request, encodingOptions);
          const stream = backend.callStream(method.name, {
            value: encoded,
            type_url: method.resolvedRequestType.fullName
          }, requestOptions);
          return import_chunk_IOJXLIVL.Stream.map(stream, (data) => responseCodec.decode(data.value, encodingOptions));
        };
      } else {
        this[methodName] = async (request, requestOptions) => {
          const encoded = requestCodec.encode(request, encodingOptions);
          const response = await backend.call(method.name, {
            value: encoded,
            type_url: method.resolvedRequestType.fullName
          }, requestOptions);
          return responseCodec.decode(response.value, encodingOptions);
        };
      }
      Object.defineProperty(this[methodName], "name", {
        value: methodName
      });
    }
  }
};
var ServiceHandler = class {
  constructor(_serviceDefinition, _schema, _serviceProvider, _encodingOptions) {
    this._serviceDefinition = _serviceDefinition;
    this._schema = _schema;
    this._serviceProvider = _serviceProvider;
    this._encodingOptions = _encodingOptions;
  }
  /**
  * Request/response method call.
  */
  async call(methodName, request, options) {
    const { method, requestCodec, responseCodec } = this._getMethodInfo(methodName);
    (0, import_invariant3.invariant)(!method.requestStream, "Invalid RPC method call: request streaming mismatch.", {
      F: __dxlog_file3,
      L: 120,
      S: this,
      A: [
        "!method.requestStream",
        "'Invalid RPC method call: request streaming mismatch.'"
      ]
    });
    (0, import_invariant3.invariant)(!method.responseStream, `Invalid RPC method call: response streaming mismatch. ${methodName}`, {
      F: __dxlog_file3,
      L: 121,
      S: this,
      A: [
        "!method.responseStream",
        "`Invalid RPC method call: response streaming mismatch. ${methodName}`"
      ]
    });
    const mappedMethodName = mapRpcMethodName(methodName);
    const handler = await this._getHandler(mappedMethodName);
    const requestDecoded = requestCodec.decode(request.value, this._encodingOptions);
    const response = await handler(requestDecoded, options);
    const responseEncoded = responseCodec.encode(response, this._encodingOptions);
    return {
      value: responseEncoded,
      type_url: method.resolvedResponseType.fullName
    };
  }
  /**
  * Streaming method call.
  */
  callStream(methodName, request, options) {
    const { method, requestCodec, responseCodec } = this._getMethodInfo(methodName);
    (0, import_invariant3.invariant)(!method.requestStream, "Invalid RPC method call: request streaming mismatch.", {
      F: __dxlog_file3,
      L: 141,
      S: this,
      A: [
        "!method.requestStream",
        "'Invalid RPC method call: request streaming mismatch.'"
      ]
    });
    (0, import_invariant3.invariant)(method.responseStream, `Invalid RPC method call: response streaming mismatch., ${methodName}`, {
      F: __dxlog_file3,
      L: 142,
      S: this,
      A: [
        "method.responseStream",
        "`Invalid RPC method call: response streaming mismatch., ${methodName}`"
      ]
    });
    const mappedMethodName = mapRpcMethodName(methodName);
    const handlerPromise = this._getHandler(mappedMethodName);
    const requestDecoded = requestCodec.decode(request.value, this._encodingOptions);
    const responseStream = import_chunk_IOJXLIVL.Stream.unwrapPromise(handlerPromise.then((handler) => handler(requestDecoded, options)));
    return import_chunk_IOJXLIVL.Stream.map(responseStream, (data) => ({
      value: responseCodec.encode(data, this._encodingOptions),
      type_url: method.resolvedResponseType.fullName
    }));
  }
  async _getHandler(method) {
    const service = await (0, import_util2.getAsyncProviderValue)(this._serviceProvider);
    const handler = service[method];
    (0, import_invariant3.invariant)(handler, `Handler is missing: ${method}`, {
      F: __dxlog_file3,
      L: 163,
      S: this,
      A: [
        "handler",
        "`Handler is missing: ${method}`"
      ]
    });
    return handler.bind(service);
  }
  _getMethodInfo(methodName) {
    const method = this._serviceDefinition.methods[methodName];
    (0, import_invariant3.invariant)(!!method, `Method not found: ${methodName}`, {
      F: __dxlog_file3,
      L: 169,
      S: this,
      A: [
        "!!method",
        "`Method not found: ${methodName}`"
      ]
    });
    method.resolve();
    (0, import_invariant3.invariant)(method.resolvedRequestType, void 0, {
      F: __dxlog_file3,
      L: 172,
      S: this,
      A: [
        "method.resolvedRequestType",
        ""
      ]
    });
    (0, import_invariant3.invariant)(method.resolvedResponseType, void 0, {
      F: __dxlog_file3,
      L: 173,
      S: this,
      A: [
        "method.resolvedResponseType",
        ""
      ]
    });
    const requestCodec = this._schema.tryGetCodecForType(method.resolvedRequestType.fullName);
    const responseCodec = this._schema.tryGetCodecForType(method.resolvedResponseType.fullName);
    return {
      method,
      requestCodec,
      responseCodec
    };
  }
};
var mapRpcMethodName = (name) => name[0].toLocaleLowerCase() + name.substring(1);
var Schema = class _Schema {
  static fromJson(schema, substitutions = {}) {
    const root = import_protobufjs4.default.Root.fromJSON(schema);
    return new _Schema(root, substitutions);
  }
  // prettier-ignore
  constructor(_typesRoot, substitutions) {
    this._typesRoot = _typesRoot;
    this._codecCache = /* @__PURE__ */ new Map();
    this._mapping = createMappingDescriptors(substitutions);
  }
  getCodecForType(typeName) {
    if (typeof typeName !== "string") {
      throw new TypeError("Expected `typeName` argument to be a string");
    }
    let codec = this._codecCache.get(typeName);
    if (codec) {
      return codec;
    }
    if (codec === null) {
      throw new Error(`Type not found: "${typeName}"`);
    }
    const type = this._typesRoot.lookupType(typeName);
    codec = new ProtoCodec(type, this._mapping, this);
    this._codecCache.set(typeName, codec);
    return codec;
  }
  hasType(typeName) {
    if (typeName === "") {
      return false;
    }
    if (this._codecCache.has(typeName)) {
      return true;
    }
    try {
      this.tryGetCodecForType(typeName);
      return true;
    } catch {
      return false;
    }
  }
  tryGetCodecForType(typeName) {
    if (typeName === "") {
      throw new Error(`Type not found: "${typeName}"`);
    }
    if (typeof typeName !== "string") {
      throw new TypeError("Expected `typeName` argument to be a string");
    }
    let codec = this._codecCache.get(typeName);
    if (codec) {
      return codec;
    }
    if (codec === null) {
      throw new Error(`Type not found: "${typeName}"`);
    }
    const type = this._typesRoot.lookupType(typeName);
    codec = new ProtoCodec(type, this._mapping, this);
    this._codecCache.set(typeName, codec);
    return codec;
  }
  getService(name) {
    if (typeof name !== "string") {
      throw new TypeError("Expected `name` argument to be a string");
    }
    const service = this._typesRoot.lookupService(name);
    return new ServiceDescriptor(service, this);
  }
  /**
  * Dynamically add new definitions to this schema.
  */
  addJson(schema) {
    if (!schema.nested) {
      throw new Error("Invalid schema: missing nested object");
    }
    this._typesRoot = import_protobufjs4.default.Root.fromJSON((0, import_lodash.default)(this._typesRoot.toJSON(), schema));
  }
};
var encodeStructValue = (structValue, visitedObjects) => {
  const valueType = typeof structValue;
  switch (valueType) {
    case "undefined": {
      return {
        nullValue: 0
      };
    }
    case "number": {
      return {
        numberValue: structValue
      };
    }
    case "string": {
      return {
        stringValue: structValue
      };
    }
    case "boolean": {
      return {
        boolValue: structValue
      };
    }
    case "object": {
      if (structValue === null || visitedObjects.has(structValue)) {
        return {
          nullValue: 0
        };
      }
      try {
        if (Array.isArray(structValue)) {
          return {
            listValue: {
              values: structValue.map((value) => encodeStructValue(value, visitedObjects))
            }
          };
        }
        return {
          structValue: encodeStruct(structValue, visitedObjects)
        };
      } finally {
        visitedObjects.delete(structValue);
      }
    }
    default: {
      return {
        nullValue: 0
      };
    }
  }
};
var encodeStruct = (struct, visitedObjects = /* @__PURE__ */ new WeakSet()) => ({
  fields: Object.fromEntries(Object.entries(struct).map(([key, value]) => [
    key,
    encodeStructValue(value, visitedObjects)
  ]))
});
var decodeStructValue = (structValue) => {
  const [key, v] = Object.entries(structValue)[0];
  switch (key) {
    case "nullValue": {
      return null;
    }
    case "numberValue": {
      return v;
    }
    case "stringValue": {
      return v;
    }
    case "boolValue": {
      return v;
    }
    case "structValue": {
      return decodeStruct(v);
    }
    case "listValue": {
      return v.values.map(decodeStructValue);
    }
    default:
      throw new Error(`Unsupported type: ${key}`);
  }
};
var decodeStruct = (struct) => Object.fromEntries(Object.entries(struct.fields || {}).map(([key, value]) => [
  key,
  decodeStructValue(value)
]));
var structSubstitutions = {
  "google.protobuf.Struct": {
    encode: (value) => encodeStruct(value),
    decode: (value) => decodeStruct(value)
  }
};
var anySubstitutions = {
  "google.protobuf.Any": {
    encode: (value, context, schema, options) => {
      const field = schema.getCodecForType(context.messageName).protoType.fields[context.fieldName];
      if (options.preserveAny || field.getOption("preserve_any")) {
        if (value["@type"] && value["@type"] !== "google.protobuf.Any") {
          throw new Error("Can only encode google.protobuf.Any with @type set to google.protobuf.Any in preserveAny mode.");
        }
        return value;
      }
      if (typeof value["@type"] !== "string") {
        throw new Error("Cannot encode google.protobuf.Any without @type string field");
      }
      if (value["@type"] === "google.protobuf.Any") {
        return value;
      }
      if (value["@type"] === "google.protobuf.Struct") {
        const codec2 = schema.tryGetCodecForType(value["@type"]);
        return codec2.encodeAsAny(structSubstitutions["google.protobuf.Struct"].encode(value));
      }
      const codec = schema.tryGetCodecForType(value["@type"]);
      return codec.encodeAsAny(value);
    },
    decode: (value, context, schema, options) => {
      const field = schema.getCodecForType(context.messageName).protoType.fields[context.fieldName];
      if (options.preserveAny || field.getOption("preserve_any")) {
        return {
          "@type": "google.protobuf.Any",
          type_url: value.type_url ?? "",
          value: value.value ?? new Uint8Array()
        };
      }
      if (!schema.hasType(value.type_url)) {
        return {
          "@type": "google.protobuf.Any",
          ...value
        };
      }
      const codec = schema.tryGetCodecForType(value.type_url);
      let data = codec.decode(value.value);
      if (value.type_url === "google.protobuf.Struct") {
        data = structSubstitutions["google.protobuf.Struct"].decode(data);
      }
      return {
        ...data,
        "@type": value.type_url
      };
    }
  }
};
var timestampSubstitutions = {
  "google.protobuf.Timestamp": {
    encode: (value) => {
      const unixMilliseconds = value.getTime();
      return {
        seconds: Math.floor(unixMilliseconds / 1e3).toString(),
        nanos: unixMilliseconds % 1e3 * 1e6
      };
    },
    decode: (value) => new Date(parseInt(value.seconds ?? "0") * 1e3 + (value.nanos ?? 0) / 1e6)
  }
};
var compressSchema = (data) => (0, import_compress_json.compress)(data);
var decompressSchema = (data) => (0, import_compress_json.decompress)(data);
var getFirstStreamValue = async (stream, { timeout } = {}) => {
  try {
    const trigger = new import_async.Trigger();
    stream.subscribe((value) => trigger.wake(value));
    return await trigger.wait({
      timeout
    });
  } finally {
    await stream.close();
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  OBJECT_CONVERSION_OPTIONS,
  ProtoCodec,
  Schema,
  Service,
  ServiceDescriptor,
  ServiceHandler,
  Stream,
  anySubstitutions,
  compressSchema,
  createMappingDescriptors,
  decodeProtobuf,
  decompressSchema,
  encodeProtobuf,
  getFirstStreamValue,
  mapMessage,
  patchBufferCodec,
  sanitize,
  structSubstitutions,
  timestampSubstitutions
});
//# sourceMappingURL=index.cjs.map
