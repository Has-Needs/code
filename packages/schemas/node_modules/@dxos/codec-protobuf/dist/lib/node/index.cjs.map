{
  "version": 3,
  "sources": ["../../../src/buffer-patch.ts", "../../../src/precompiled-mapping/create-message-mapper.ts", "../../../src/precompiled-mapping/codegen.ts", "../../../src/codec.ts", "../../../src/encoding.ts", "../../../src/mapping.ts", "../../../src/sanitizer.ts", "../../../src/schema.ts", "../../../src/service.ts", "../../../src/substitutions/struct.ts", "../../../src/substitutions/any.ts", "../../../src/substitutions/timestamp.ts", "../../../src/compression.ts", "../../../src/util.ts"],
  "sourcesContent": ["//\n// Copyright 2021 DXOS.org\n//\n\nimport { arrayToBuffer } from '@dxos/util';\n\nimport type { Codec } from './codec';\n\n/**\n * Protobuf codec returns instances of Uint8Arrays, but some storages expect to receive Buffers.\n * This function patches the encode method to convert result into a Buffer.\n */\nexport const patchBufferCodec = (codec: Codec<any>) => ({\n  encode: (x: any) => arrayToBuffer(codec.encode(x)),\n  decode: codec.decode.bind(codec),\n});\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport pb from 'protobufjs';\n\nimport { invariant } from '@dxos/invariant';\n\nimport { codegen, ref } from './codegen';\nimport { type MapingDescriptors, type TypeMapperContext } from '../mapping';\n\nexport type Mapper = (obj: any, extraArgs: any[]) => any;\n\nexport const createMessageMapper = (type: pb.Type, substitutions: MapingDescriptors): Mapper =>\n  createMessageMapperCached(type, substitutions, {}).map;\n\nconst createMessageMapperCached = (\n  type: pb.Type,\n  substitutions: MapingDescriptors,\n  cache: Record<string, { map: Mapper }>,\n) => {\n  if (!cache[type.fullName]) {\n    // Indirection to allow for recursive message types.\n    cache[type.fullName] = {} as any;\n    cache[type.fullName].map = codegen(`${type.name}$map`, ['obj', 'extraArgs'], (c) => {\n      c`const res = {};`;\n      for (const field of type.fieldsArray) {\n        field.resolve();\n        c`if(obj.${field.name} !== undefined && obj.${field.name} !== null) {`;\n        {\n          const genMapScalar = (value: string) => {\n            const substitution = field.resolvedType && substitutions[field.resolvedType.fullName.slice(1)];\n            if (substitution) {\n              const context: TypeMapperContext = {\n                messageName: type.fullName.slice(1),\n                fieldName: field.name,\n              };\n              c`${ref(substitution)}(${value}, ${ref(context)}, ...extraArgs)`;\n            } else if (field.resolvedType && field.resolvedType instanceof pb.Type) {\n              const mapper = createMessageMapperCached(field.resolvedType, substitutions, cache);\n              c`${ref(mapper)}.map(${value}, extraArgs)`;\n            } else {\n              c`${value}`;\n            }\n          };\n\n          if (field.repeated) {\n            c`res.${field.name} = obj.${field.name}.map(item => `;\n            genMapScalar('item');\n            c`);`;\n          } else if (field.map) {\n            invariant(field instanceof pb.MapField);\n            c`res.${field.name} = {};`;\n            c`for(const key of Object.keys(obj.${field.name})) {`;\n            {\n              c`res.${field.name}[key] = `;\n              genMapScalar(`obj.${field.name}[key]`);\n              c`;`;\n            }\n            c`}`;\n          } else {\n            c`res.${field.name} = `;\n            genMapScalar(`obj.${field.name}`);\n            c`;`;\n          }\n        }\n        c`}`;\n        if (!field.getOption('proto3_optional') && !field.repeated && !field.map && !field.partOf) {\n          c`else {`;\n          {\n            if (field.resolvedType instanceof pb.Type) {\n              const mapper = createMessageMapperCached(field.resolvedType, substitutions, cache);\n              c`res.${field.name} = ${ref(mapper)}.map({}, extraArgs);`;\n            } else if (field.resolvedType instanceof pb.Enum) {\n              `res.${field.name} = 0;`;\n            } else {\n              c`res.${field.name} = ${getDefaultValue(field.type)};`;\n            }\n          }\n          c`}`;\n        }\n      }\n      c`return res;`;\n    });\n  }\n\n  return cache[type.fullName];\n};\n\nconst getDefaultValue = (type: string): string => {\n  switch (type) {\n    case 'double':\n    case 'float':\n    case 'int32':\n    case 'sfixed32':\n    case 'uint32':\n    case 'sint32':\n    case 'fixed32':\n      return '0';\n    case 'sint64':\n    case 'int64':\n    case 'uint64':\n    case 'fixed64':\n    case 'sfixed64':\n      return '\"0\"';\n    case 'bool':\n      return 'false';\n    case 'string':\n      return '\"\"';\n    case 'bytes':\n      return 'new Uint8Array()';\n    default:\n      throw new Error(`Unknown type: ${type}`);\n  }\n};\n", "//\n// Copyright 2022 DXOS.org\n//\n\nconst Ref = Symbol('Ref');\n\ninterface Ref {\n  [Ref]: true;\n  value: any;\n}\n\n/**\n * Pass a JS value by reference rather then parsing it as code.\n *\n * Usage example:\n *\n * ```typescript\n * const double = x => x * 2;;\n * codegen('add', ['a', 'b'], c => {\n *   c`const c = a + b;`;\n *   c`return ${ref(double)}(c)`;\n * });\n * ```\n *\n * would generate a function:\n *\n * ```typescript\n * const double = x => x * 2;;\n * function add(a, b) {\n *   const c = a + b;\n *   return double(c);\n * }\n * ```\n */\nexport const ref = (value: any): Ref => ({\n  [Ref]: true,\n  value,\n});\n\nconst isRef = (value: any): value is Ref => value[Ref] === true;\n\n/**\n * DSL for runtime code generation.\n *\n * Example:\n *\n * ```typescript\n * const multiplier = 5;\n * codegen('add', ['a', 'b'], c => {\n *   c`const c = a + b;`;\n *   c`return c * ${multiplier};`;\n * });\n * ```\n *\n * would generate a function:\n *\n * ```typescript\n * function add(a, b) {\n *   const c = a + b;\n *   return c * 5;\n * }\n * ```\n *\n * @param name Function name. Will appear in stack traces.\n * @param args Names of function arguments.\n * @param gen Closure that builds the function source.\n * @param ctx Optional record with context variables that will appear in function's scope.\n */\nexport const codegen = (\n  name: string,\n  args: string[],\n  gen: (c: (parts: TemplateStringsArray, ...args: any[]) => void) => void,\n  ctx: Record<string, any> = {},\n): ((...args: any[]) => any) => {\n  const newCtx = { ...ctx };\n  let nextAnnon = 1;\n\n  let buf = '';\n  gen((parts, ...args) => {\n    const preprocessArg = (arg: any) => {\n      if (isRef(arg)) {\n        const name = `anon${nextAnnon++}`;\n        newCtx[name] = arg.value;\n        return name;\n      } else {\n        return arg;\n      }\n    };\n    buf += parts.map((s, i) => s + (i < args.length ? preprocessArg(args[i]) : '')).join('') + '\\n';\n  });\n\n  const code = `return function ${name}(${args.join(', ')}) {\\n${buf}\\n}`;\n\n  // eslint-disable-next-line no-new-func\n  return Function(...Object.keys(newCtx), code)(...Object.values(newCtx));\n};\n", "//\n// Copyright 2020 DXOS.org\n//\n\nimport { type IConversionOptions } from 'protobufjs';\nimport type protobufjs from 'protobufjs';\n\nimport { type Any, type EncodingOptions, type WithTypeUrl } from './common';\nimport { type BidirectionalMapingDescriptors } from './mapping';\nimport { createMessageMapper, type Mapper } from './precompiled-mapping/create-message-mapper';\nimport type { Schema } from './schema';\n\nexport const OBJECT_CONVERSION_OPTIONS: IConversionOptions = {\n  // Represent long integers as strings.\n  longs: String,\n\n  // Will set empty repeated fields to [] instead of undefined.\n  arrays: true,\n};\n\nconst JSON_CONVERSION_OPTIONS: IConversionOptions = {\n  // TODO(dmaretskyi): Internal crash with the current version of protobufjs.\n  // longs: String,\n  enums: String,\n  bytes: String,\n  defaults: false,\n  json: true,\n};\n\n/**\n * Defines a generic encoder/decoder.\n */\nexport interface Codec<T> {\n  encode(obj: T, opts?: EncodingOptions): Uint8Array;\n  decode(buffer: Uint8Array, opts?: EncodingOptions): T;\n}\n\n/**\n * Protocol buffer codec.\n */\nexport class ProtoCodec<T = any> implements Codec<T> {\n  private readonly _encodeMapper: Mapper;\n  private readonly _decodeMapper: Mapper;\n\n  constructor(\n    private readonly _type: protobufjs.Type,\n    private readonly _mapping: BidirectionalMapingDescriptors,\n    private readonly _schema: Schema<any>,\n  ) {\n    this._encodeMapper = createMessageMapper(this._type, this._mapping.encode);\n    this._decodeMapper = createMessageMapper(this._type, this._mapping.decode);\n  }\n\n  /**\n   * Underlying protobuf.js type descriptor.\n   */\n  get protoType(): protobufjs.Type {\n    return this._type;\n  }\n\n  get substitutionMappings(): BidirectionalMapingDescriptors {\n    return this._mapping;\n  }\n\n  /**\n   * Reference to the protobuf schema this codec was created from.\n   */\n  get schema(): Schema<any> {\n    // TODO(burdon): Add to generic type.\n    return this._schema;\n  }\n\n  encode(value: T, options: EncodingOptions = {}): Uint8Array {\n    const sub = this._encodeMapper(value, [this._schema, options]);\n    return this._type.encode(sub).finish();\n  }\n\n  decode(data: Uint8Array, options: EncodingOptions = {}): T {\n    const obj = this._type.toObject(this._type.decode(data), OBJECT_CONVERSION_OPTIONS);\n    return this._decodeMapper(obj, [this._schema, options]);\n  }\n\n  encodeAsAny(value: T, options: EncodingOptions = {}): WithTypeUrl<Any> {\n    return {\n      '@type': 'google.protobuf.Any',\n      type_url: this._type.fullName.slice(1),\n      value: this.encode(value, options),\n    };\n  }\n\n  fromObject(obj: any): T {\n    return this._decodeMapper(this._type.fromObject(obj).toJSON(), [this._schema]);\n  }\n\n  /**\n   * Dynamically add new definitions to this codec. Mutates the underlying schema.\n   */\n  addJson(schema: any): void {\n    this._schema.addJson(schema);\n  }\n\n  encodeToJson(value: T, options: EncodingOptions = {}): any {\n    const sub = this._encodeMapper(value, [this._schema, options]);\n    return this._type.toObject(sub, JSON_CONVERSION_OPTIONS);\n  }\n\n  decodeFromJson(data: any, options: EncodingOptions = {}): T {\n    const obj = this._type.toObject(this._type.fromObject(data), OBJECT_CONVERSION_OPTIONS);\n    return this._decodeMapper(obj, [this._schema, options]);\n  }\n}\n", "//\n// Copyright 2021 DXOS.org\n//\n\nimport * as protobuf from 'protobufjs';\n\nimport { type Struct } from './substitutions';\n\nexport const encodeProtobuf = (root: protobuf.Root): Struct => root.toJSON();\n\nexport const decodeProtobuf = (struct: Struct): protobuf.Root => protobuf.Root.fromJSON(struct);\n", "//\n// Copyright 2020 DXOS.org\n//\n\nimport protobufjs from 'protobufjs';\n\nimport { invariant } from '@dxos/invariant';\n\nimport { type Substitutions } from './common';\n\nexport type TypeMapperContext = {\n  /**\n   * Message FQN.\n   */\n  messageName: string;\n\n  fieldName: string;\n};\n\nexport type TypeMapper = (value: any, context: TypeMapperContext, ...extraArgs: any) => any;\n\nexport type MapingDescriptors = Partial<Record<string, TypeMapper>>;\n\nexport interface BidirectionalMapingDescriptors {\n  encode: MapingDescriptors;\n  decode: MapingDescriptors;\n}\n\nexport const createMappingDescriptors = (substitutions: Substitutions): BidirectionalMapingDescriptors => {\n  const encode: MapingDescriptors = {};\n  const decode: MapingDescriptors = {};\n  for (const type of Object.keys(substitutions)) {\n    encode[type] = substitutions[type].encode;\n    decode[type] = substitutions[type].decode;\n  }\n  return {\n    encode,\n    decode,\n  };\n};\n\nexport type FieldMapper = (value: any, typeName: string) => Promise<any>;\n\nexport const mapMessage = async (type: protobufjs.Type, mapper: FieldMapper, obj: any) => {\n  const res: any = {};\n  for (const field of type.fieldsArray) {\n    if (!(field.name in obj)) {\n      continue;\n    }\n    res[field.name] = await mapField(field, mapper, obj[field.name]);\n  }\n\n  return res;\n};\n\nconst mapField = async (field: protobufjs.Field, mapper: FieldMapper, value: any) => {\n  if (!field.required && (value === null || value === undefined)) {\n    return value;\n  } else if (field.repeated) {\n    return await Promise.all(value.map((value: any) => mapScalarField(field, mapper, value)));\n  } else if (field.map) {\n    invariant(field instanceof protobufjs.MapField);\n    return await asyncObjectMap((value) => mapScalarField(field, mapper, value), value);\n  } else {\n    return mapScalarField(field, mapper, value);\n  }\n};\n\nconst mapScalarField = async (field: protobufjs.Field, mapper: FieldMapper, value: any) => {\n  if (!field.resolved) {\n    field.resolve();\n  }\n\n  const typeName = field.resolvedType?.fullName.slice(1); // Name of the protobuf message type if the field type is not primitive.\n  if (typeName) {\n    return await mapper(value, typeName);\n  }\n\n  if (field.resolvedType && field.resolvedType instanceof protobufjs.Type) {\n    return await mapMessage(field.resolvedType, mapper, value);\n  }\n\n  return value;\n};\n\nconst asyncObjectMap = async <K extends keyof any, T, U>(\n  map: (value: T, key: K) => Promise<U>,\n  record: Record<K, T>,\n): Promise<Record<K, U>> => {\n  const res: Record<K, U> = {} as any;\n\n  await Promise.all(\n    Object.entries(record).map(async ([key, value]) => {\n      res[key as keyof typeof res] = await map(value as T, key as K);\n    }),\n  );\n\n  return res;\n};\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport pb from 'protobufjs';\n\nexport interface SanitizeContext {\n  errors: string[];\n}\n\n/**\n * Sanitiaze all enum fields in object based on protobuf type.\n * @param type\n * @param value\n * @param path\n * @param context\n */\nexport const sanitize = (type: pb.Type, value: any, path: string, context: SanitizeContext) => {\n  if (!value) {\n    return;\n  }\n\n  for (const key of Object.keys(value)) {\n    if (!type.fields[key]) {\n      // Ignore unknown fields.\n      continue;\n    }\n\n    const field = type.fields[key];\n    if (field.repeated) {\n      continue; // TODO(dmaretskyi): Implement.\n    }\n\n    field.resolve();\n    if (!field.resolvedType) {\n      continue;\n    }\n    if (field.resolvedType instanceof pb.Type) {\n      sanitize(field.resolvedType, value[key], `${path}.${key}`, context);\n    } else if (field.resolvedType instanceof pb.Enum) {\n      value[key] = sanitizeEnum(field.resolvedType, value[key], `${path}.${key}`, context);\n    }\n  }\n};\n\nconst sanitizeEnum = (type: pb.Enum, value: any, path: string, context: SanitizeContext): any => {\n  if (type.valuesById[value]) {\n    return value;\n  }\n\n  if (typeof value === 'string') {\n    const normalizedValue = value.toLowerCase();\n    for (const [name, tag] of Object.entries(type.values)) {\n      if (name.toLowerCase() === normalizedValue) {\n        return tag;\n      }\n    }\n  }\n\n  context.errors.push(`Invalid enum value: value=${JSON.stringify(value)} enum=${type.fullName} path=${path}`);\n\n  return value;\n};\n", "//\n// Copyright 2021 DXOS.org\n//\n\nimport merge from 'lodash.merge';\nimport pb from 'protobufjs';\n\nimport { ProtoCodec } from './codec';\nimport { type Substitutions } from './common';\nimport { type BidirectionalMapingDescriptors, createMappingDescriptors } from './mapping';\nimport { ServiceDescriptor } from './service';\n\nexport class Schema<T, S extends {} = {}> {\n  static fromJson<T extends Record<string, any>, S extends Record<string, any> = {}>(\n    schema: any,\n    substitutions: Substitutions = {},\n  ): Schema<T, S> {\n    const root = pb.Root.fromJSON(schema);\n    return new Schema(root, substitutions);\n  }\n\n  private readonly _mapping: BidirectionalMapingDescriptors;\n\n  private readonly _codecCache = new Map<string, ProtoCodec>();\n\n  // prettier-ignore\n  constructor(\n    private _typesRoot: pb.Root,\n    substitutions: Substitutions,\n  ) {\n    this._mapping = createMappingDescriptors(substitutions);\n  }\n\n  getCodecForType<K extends keyof T & string>(typeName: K): ProtoCodec<T[K]> {\n    if (typeof typeName !== 'string') {\n      throw new TypeError('Expected `typeName` argument to be a string');\n    }\n\n    let codec = this._codecCache.get(typeName);\n    if (codec) {\n      return codec;\n    }\n\n    if (codec === null) {\n      throw new Error(`Type not found: \"${typeName}\"`);\n    }\n\n    const type = this._typesRoot.lookupType(typeName);\n    codec = new ProtoCodec(type, this._mapping, this);\n    this._codecCache.set(typeName, codec);\n    return codec;\n  }\n\n  hasType(typeName: string): boolean {\n    if (typeName === '') {\n      return false;\n    }\n\n    if (this._codecCache.has(typeName)) {\n      return true;\n    }\n\n    try {\n      this.tryGetCodecForType(typeName);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  tryGetCodecForType(typeName: string): ProtoCodec {\n    if (typeName === '') {\n      throw new Error(`Type not found: \"${typeName}\"`);\n    }\n\n    if (typeof typeName !== 'string') {\n      throw new TypeError('Expected `typeName` argument to be a string');\n    }\n\n    let codec = this._codecCache.get(typeName);\n    if (codec) {\n      return codec;\n    }\n\n    if (codec === null) {\n      throw new Error(`Type not found: \"${typeName}\"`);\n    }\n\n    const type = this._typesRoot.lookupType(typeName);\n    codec = new ProtoCodec(type, this._mapping, this);\n    this._codecCache.set(typeName, codec);\n    return codec;\n  }\n\n  getService<K extends keyof S & string>(name: K): ServiceDescriptor<S[K]> {\n    if (typeof name !== 'string') {\n      throw new TypeError('Expected `name` argument to be a string');\n    }\n\n    const service = this._typesRoot.lookupService(name);\n    return new ServiceDescriptor(service, this);\n  }\n\n  /**\n   * Dynamically add new definitions to this schema.\n   */\n  addJson(schema: any): void {\n    if (!schema.nested) {\n      throw new Error('Invalid schema: missing nested object');\n    }\n\n    this._typesRoot = pb.Root.fromJSON(merge(this._typesRoot.toJSON(), schema));\n  }\n}\n", "//\n// Copyright 2021 DXOS.org\n//\n\nimport type pb from 'protobufjs';\n\nimport { invariant } from '@dxos/invariant';\nimport { getAsyncProviderValue } from '@dxos/util';\n\nimport { type Any, type EncodingOptions } from './common';\nimport { type RequestOptions } from './request-options';\nimport type { Schema } from './schema';\nimport { Stream } from './stream';\n\n/**\n * Service endpoint.\n */\nexport interface ServiceBackend {\n  call(method: string, request: Any, requestOptions?: RequestOptions): Promise<Any>;\n  callStream(method: string, request: Any, requestOptions?: RequestOptions): Stream<Any>;\n}\n\nexport type ServiceProvider<Service> = Service | (() => Service) | (() => Promise<Service>);\n\n/**\n * Client/server service wrapper.\n */\nexport class ServiceDescriptor<S> {\n  // prettier-ignore\n  constructor(\n    private readonly _service: pb.Service,\n    private readonly _schema: Schema<any>,\n  ) {}\n\n  get serviceProto(): pb.Service {\n    return this._service;\n  }\n\n  get name(): string {\n    return this._service.fullName.slice(1);\n  }\n\n  createClient(backend: ServiceBackend, encodingOptions?: EncodingOptions): Service & S {\n    return new Service(backend, this._service, this._schema, encodingOptions) as Service & S;\n  }\n\n  createServer(handlers: ServiceProvider<S>, encodingOptions?: EncodingOptions): ServiceHandler<S> {\n    return new ServiceHandler(this._service, this._schema, handlers, encodingOptions);\n  }\n}\n\n/**\n * Represents service instance.\n */\nexport class Service {\n  constructor(backend: ServiceBackend, service: pb.Service, schema: Schema<any>, encodingOptions?: EncodingOptions) {\n    for (const method of service.methodsArray) {\n      method.resolve();\n      invariant(method.resolvedRequestType);\n      invariant(method.resolvedResponseType);\n      invariant(!method.requestStream, 'Streaming RPC requests are not supported.');\n\n      // TODO(dmaretskyi): What about primitive types.\n      const requestCodec = schema.tryGetCodecForType(method.resolvedRequestType.fullName);\n      const responseCodec = schema.tryGetCodecForType(method.resolvedResponseType.fullName);\n      const methodName = mapRpcMethodName(method.name);\n\n      if (method.responseStream) {\n        (this as any)[methodName] = (request: unknown, requestOptions?: RequestOptions) => {\n          const encoded = requestCodec.encode(request, encodingOptions);\n          const stream = backend.callStream(\n            method.name,\n            {\n              value: encoded,\n              type_url: method.resolvedRequestType!.fullName,\n            },\n            requestOptions,\n          );\n          return Stream.map(stream, (data) => responseCodec.decode(data.value!, encodingOptions));\n        };\n      } else {\n        (this as any)[methodName] = async (request: unknown, requestOptions?: RequestOptions) => {\n          const encoded = requestCodec.encode(request, encodingOptions);\n          const response = await backend.call(\n            method.name,\n            {\n              value: encoded,\n              type_url: method.resolvedRequestType!.fullName,\n            },\n            requestOptions,\n          );\n          return responseCodec.decode(response.value, encodingOptions);\n        };\n      }\n\n      // Set function name so that is properly named in stack traces.\n      Object.defineProperty((this as any)[methodName], 'name', {\n        value: methodName,\n      });\n    }\n  }\n}\n\n/**\n * Represents service endpoint implementation.\n */\nexport class ServiceHandler<S = {}> implements ServiceBackend {\n  constructor(\n    private readonly _serviceDefinition: pb.Service,\n    private readonly _schema: Schema<any>,\n    private readonly _serviceProvider: ServiceProvider<S>,\n    private readonly _encodingOptions?: EncodingOptions,\n  ) {}\n\n  /**\n   * Request/response method call.\n   */\n  async call(methodName: string, request: Any, options?: RequestOptions): Promise<Any> {\n    const { method, requestCodec, responseCodec } = this._getMethodInfo(methodName);\n    invariant(!method.requestStream, 'Invalid RPC method call: request streaming mismatch.');\n    invariant(!method.responseStream, `Invalid RPC method call: response streaming mismatch. ${methodName}`);\n\n    const mappedMethodName = mapRpcMethodName(methodName);\n\n    const handler = await this._getHandler(mappedMethodName);\n    const requestDecoded = requestCodec.decode(request.value!, this._encodingOptions);\n    const response = await handler(requestDecoded, options);\n    const responseEncoded = responseCodec.encode(response, this._encodingOptions);\n\n    return {\n      value: responseEncoded,\n      type_url: method.resolvedResponseType!.fullName,\n    };\n  }\n\n  /**\n   * Streaming method call.\n   */\n  callStream(methodName: string, request: Any, options?: RequestOptions): Stream<Any> {\n    const { method, requestCodec, responseCodec } = this._getMethodInfo(methodName);\n    invariant(!method.requestStream, 'Invalid RPC method call: request streaming mismatch.');\n    invariant(method.responseStream, `Invalid RPC method call: response streaming mismatch., ${methodName}`);\n\n    const mappedMethodName = mapRpcMethodName(methodName);\n    const handlerPromise = this._getHandler(mappedMethodName);\n\n    const requestDecoded = requestCodec.decode(request.value!, this._encodingOptions);\n    const responseStream = Stream.unwrapPromise(\n      handlerPromise.then((handler) => handler(requestDecoded, options) as Stream<unknown>),\n    );\n    return Stream.map(\n      responseStream,\n      (data): Any => ({\n        value: responseCodec.encode(data, this._encodingOptions),\n        type_url: method.resolvedResponseType!.fullName,\n      }),\n    );\n  }\n\n  private async _getHandler(method: string): Promise<(request: unknown, options?: RequestOptions) => unknown> {\n    const service: S = await getAsyncProviderValue(this._serviceProvider);\n    const handler = service[method as keyof S];\n    invariant(handler, `Handler is missing: ${method}`);\n    return (handler as any).bind(service);\n  }\n\n  private _getMethodInfo(methodName: string) {\n    const method = this._serviceDefinition.methods[methodName];\n    invariant(!!method, `Method not found: ${methodName}`);\n\n    method.resolve();\n    invariant(method.resolvedRequestType);\n    invariant(method.resolvedResponseType);\n\n    const requestCodec = this._schema.tryGetCodecForType(method.resolvedRequestType.fullName);\n    const responseCodec = this._schema.tryGetCodecForType(method.resolvedResponseType.fullName);\n\n    return { method, requestCodec, responseCodec };\n  }\n}\n\nconst mapRpcMethodName = (name: string) => name[0].toLocaleLowerCase() + name.substring(1);\n", "//\n// Copyright 2022 DXOS.org\n//\n\nexport type Struct = Record<string, any>;\n\nconst encodeStructValue = (structValue: any, visitedObjects: WeakSet<any>): any => {\n  const valueType = typeof structValue;\n  switch (valueType) {\n    case 'undefined': {\n      return { nullValue: 0 };\n    }\n    case 'number': {\n      return { numberValue: structValue };\n    }\n    case 'string': {\n      return { stringValue: structValue };\n    }\n    case 'boolean': {\n      return { boolValue: structValue };\n    }\n    case 'object': {\n      // null, Array, Object will have typeof 'object'\n      if (structValue === null || visitedObjects.has(structValue)) {\n        return { nullValue: 0 };\n      }\n\n      try {\n        if (Array.isArray(structValue)) {\n          return { listValue: { values: structValue.map((value) => encodeStructValue(value, visitedObjects)) } };\n        }\n        return { structValue: encodeStruct(structValue, visitedObjects) };\n      } finally {\n        visitedObjects.delete(structValue);\n      }\n    }\n    default: {\n      return { nullValue: 0 };\n    }\n  }\n};\n\nconst encodeStruct = (struct: Struct, visitedObjects = new WeakSet<any>()): any => ({\n  fields: Object.fromEntries(\n    Object.entries(struct).map(([key, value]) => [key, encodeStructValue(value, visitedObjects)]),\n  ),\n});\n\nconst decodeStructValue = (structValue: any): any => {\n  const [key, v]: [string, any] = Object.entries(structValue)[0];\n  switch (key) {\n    case 'nullValue': {\n      return null;\n    }\n    case 'numberValue': {\n      return v;\n    }\n    case 'stringValue': {\n      return v;\n    }\n    case 'boolValue': {\n      return v;\n    }\n    case 'structValue': {\n      return decodeStruct(v);\n    }\n    case 'listValue': {\n      return v.values.map(decodeStructValue);\n    }\n    default:\n      throw new Error(`Unsupported type: ${key}`);\n  }\n};\n\nconst decodeStruct = (struct: any): Struct =>\n  Object.fromEntries(Object.entries(struct.fields || {}).map(([key, value]) => [key, decodeStructValue(value)]));\n\nexport const structSubstitutions = {\n  'google.protobuf.Struct': {\n    encode: (value: Struct): any => encodeStruct(value),\n    decode: (value: any): Struct => decodeStruct(value),\n  },\n};\n", "//\n// Copyright 2021 DXOS.org\n//\n\nimport { structSubstitutions } from './struct';\nimport { type EncodingOptions, type WithTypeUrl } from '../common';\nimport { type TypeMapperContext } from '../mapping';\nimport type { Schema } from '../schema';\n\nexport const anySubstitutions = {\n  'google.protobuf.Any': {\n    encode: (\n      value: WithTypeUrl<{}>,\n      context: TypeMapperContext,\n      schema: Schema<any>,\n      options: EncodingOptions,\n    ): any => {\n      const field = schema.getCodecForType(context.messageName).protoType.fields[context.fieldName];\n      if (options.preserveAny || field.getOption('preserve_any')) {\n        if (value['@type'] && value['@type'] !== 'google.protobuf.Any') {\n          throw new Error(\n            'Can only encode google.protobuf.Any with @type set to google.protobuf.Any in preserveAny mode.',\n          );\n        }\n        return value;\n      }\n\n      if (typeof value['@type'] !== 'string') {\n        throw new Error('Cannot encode google.protobuf.Any without @type string field');\n      }\n\n      if (value['@type'] === 'google.protobuf.Any') {\n        return value as any;\n      }\n\n      if (value['@type'] === 'google.protobuf.Struct') {\n        const codec = schema.tryGetCodecForType(value['@type']);\n        return codec.encodeAsAny(structSubstitutions['google.protobuf.Struct'].encode(value));\n      }\n\n      const codec = schema.tryGetCodecForType(value['@type']);\n      return codec.encodeAsAny(value);\n    },\n\n    decode: (\n      value: any,\n      context: TypeMapperContext,\n      schema: Schema<any>,\n      options: EncodingOptions,\n    ): WithTypeUrl<any> => {\n      const field = schema.getCodecForType(context.messageName).protoType.fields[context.fieldName];\n      if (options.preserveAny || field.getOption('preserve_any')) {\n        return {\n          '@type': 'google.protobuf.Any',\n          type_url: value.type_url ?? '',\n          value: value.value ?? new Uint8Array(),\n        };\n      }\n\n      if (!schema.hasType(value.type_url)) {\n        return {\n          '@type': 'google.protobuf.Any',\n          ...value,\n        };\n      }\n      const codec = schema.tryGetCodecForType(value.type_url);\n      let data = codec.decode(value.value);\n\n      if (value.type_url === 'google.protobuf.Struct') {\n        data = structSubstitutions['google.protobuf.Struct'].decode(data);\n      }\n\n      return {\n        ...data,\n        '@type': value.type_url,\n      };\n    },\n  },\n};\n", "//\n// Copyright 2022 DXOS.org\n//\n\nexport const timestampSubstitutions = {\n  'google.protobuf.Timestamp': {\n    encode: (value: Date): any => {\n      const unixMilliseconds = value.getTime();\n      return {\n        seconds: Math.floor(unixMilliseconds / 1000).toString(),\n        nanos: (unixMilliseconds % 1000) * 1e6,\n      };\n    },\n\n    decode: (value: any): Date => new Date(parseInt(value.seconds ?? '0') * 1000 + (value.nanos ?? 0) / 1e6),\n  },\n};\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { compress, decompress } from 'compress-json';\n\nexport const compressSchema = (data: any): any => compress(data);\n\nexport const decompressSchema = (data: any): any => decompress(data);\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { Trigger } from '@dxos/async';\n\nimport { type Stream } from './stream';\n\nexport const getFirstStreamValue = async <T extends {}>(\n  stream: Stream<T>,\n  { timeout }: { timeout?: number } = {},\n): Promise<T> => {\n  try {\n    const trigger = new Trigger<T>();\n    stream.subscribe((value) => trigger.wake(value));\n    return await trigger.wait({ timeout });\n  } finally {\n    await stream.close();\n  }\n};\n"],
  "mappings": "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",
  "names": ["import_protobufjs", "import_invariant", "import_util", "patchBufferCodec", "codec", "encode", "x", "arrayToBuffer", "decode", "bind", "Ref", "Symbol", "ref", "value", "isRef", "codegen", "name", "args", "gen", "ctx", "newCtx", "nextAnnon", "buf", "parts", "preprocessArg", "arg", "map", "s", "i", "length", "join", "code", "Function", "Object", "keys", "values", "createMessageMapper", "type", "substitutions", "createMessageMapperCached", "cache", "fullName", "c", "field", "fieldsArray", "resolve", "genMapScalar", "substitution", "resolvedType", "slice", "context", "messageName", "fieldName", "pb", "Type", "mapper", "repeated", "invariant", "MapField", "getOption", "partOf", "Enum", "getDefaultValue", "Error", "OBJECT_CONVERSION_OPTIONS", "longs", "String", "arrays", "JSON_CONVERSION_OPTIONS", "enums", "bytes", "defaults", "json", "ProtoCodec", "_type", "_mapping", "_schema", "_encodeMapper", "_decodeMapper", "protoType", "substitutionMappings", "schema", "options", "sub", "finish", "data", "obj", "toObject", "encodeAsAny", "type_url", "fromObject", "toJSON", "addJson", "encodeToJson", "decodeFromJson", "encodeProtobuf", "root", "decodeProtobuf", "struct", "Root", "fromJSON", "createMappingDescriptors", "mapMessage", "res", "mapField", "required", "undefined", "Promise", "all", "mapScalarField", "protobufjs", "asyncObjectMap", "resolved", "typeName", "record", "entries", "key", "sanitize", "path", "fields", "sanitizeEnum", "valuesById", "normalizedValue", "toLowerCase", "tag", "errors", "push", "JSON", "stringify", "ServiceDescriptor", "_service", "serviceProto", "createClient", "backend", "encodingOptions", "Service", "createServer", "handlers", "ServiceHandler", "service", "method", "methodsArray", "resolvedRequestType", "resolvedResponseType", "requestStream", "requestCodec", "tryGetCodecForType", "responseCodec", "methodName", "mapRpcMethodName", "responseStream", "request", "requestOptions", "encoded", "stream", "callStream", "Stream", "response", "call", "defineProperty", "_serviceDefinition", "_serviceProvider", "_encodingOptions", "_getMethodInfo", "mappedMethodName", "handler", "_getHandler", "requestDecoded", "responseEncoded", "handlerPromise", "unwrapPromise", "then", "getAsyncProviderValue", "methods", "toLocaleLowerCase", "substring", "Schema", "fromJson", "_typesRoot", "_codecCache", "Map", "getCodecForType", "TypeError", "get", "lookupType", "set", "hasType", "has", "getService", "lookupService", "nested", "merge", "encodeStructValue", "structValue", "visitedObjects", "valueType", "nullValue", "numberValue", "stringValue", "boolValue", "Array", "isArray", "listValue", "encodeStruct", "delete", "WeakSet", "fromEntries", "decodeStructValue", "v", "decodeStruct", "structSubstitutions", "anySubstitutions", "preserveAny", "Uint8Array", "timestampSubstitutions", "unixMilliseconds", "getTime", "seconds", "Math", "floor", "toString", "nanos", "Date", "parseInt", "compressSchema", "compress", "decompressSchema", "decompress", "getFirstStreamValue", "timeout", "trigger", "Trigger", "subscribe", "wake", "wait", "close"]
}
