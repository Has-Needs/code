import { createRequire } from 'node:module';const require = createRequire(import.meta.url);
import {
  MemorySignalManager,
  MemorySignalManagerContext,
  Messenger
} from "../chunk-SO4RY3ON.mjs";

// packages/core/mesh/messaging/src/testing/test-peer.ts
import { Event } from "@dxos/async";
import { Resource } from "@dxos/context";
import { PeerSchema } from "@dxos/edge-client";
import { PublicKey as PublicKey2 } from "@dxos/keys";
import { log } from "@dxos/log";
import { buf } from "@dxos/protocols/buf";

// packages/core/mesh/messaging/src/testing/utils.ts
import { asyncTimeout } from "@dxos/async";
import { PublicKey } from "@dxos/keys";

// packages/core/mesh/messaging/src/testing/test-messages.ts
var PAYLOAD_1 = {
  "@type": "google.protobuf.Any",
  type_url: "dxos.Example1",
  value: Buffer.from("1")
};
var PAYLOAD_2 = {
  "@type": "google.protobuf.Any",
  type_url: "dxos.Example2",
  value: Buffer.from("2")
};
var PAYLOAD_3 = {
  "@type": "google.protobuf.Any",
  type_url: "dxos.Example3",
  value: Buffer.from("3")
};

// packages/core/mesh/messaging/src/testing/utils.ts
var expectPeerAvailable = (client, expectedTopic, peer) => asyncTimeout(client.swarmEvent.waitFor(({ peerAvailable, topic }) => !!peerAvailable && peer.peerKey === peerAvailable.peer.peerKey && expectedTopic.equals(topic)), 6e3);
var expectPeerLeft = (client, expectedTopic, peer) => asyncTimeout(client.swarmEvent.waitFor(({ peerLeft, topic }) => !!peerLeft && peer.peerKey === peerLeft.peer.peerKey && expectedTopic.equals(topic)), 6e3);
var expectReceivedMessage = (event, expectedMessage) => {
  return asyncTimeout(event.waitFor((msg) => msg.author.peerKey === expectedMessage.author.peerKey && msg.recipient.peerKey === expectedMessage.recipient.peerKey && PublicKey.from(msg.payload.value).equals(expectedMessage.payload.value)), 5e3);
};
var createMessage = (author, recipient, payload = PAYLOAD_1) => ({
  author,
  recipient,
  payload
});
var messageEqual = (msg1, msg2) => msg1.author.peerKey === msg2.author.peerKey && msg1.recipient.peerKey === msg2.recipient.peerKey && PublicKey.from(msg1.payload.value).equals(msg2.payload.value);

// packages/core/mesh/messaging/src/testing/test-peer.ts
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/core/mesh/messaging/src/testing/test-peer.ts";
var TestPeer = class extends Resource {
  constructor(testBuilder) {
    super(), this.testBuilder = testBuilder, this.peerId = PublicKey2.random(), this.defaultReceived = new Event();
  }
  get peerInfo() {
    return buf.create(PeerSchema, {
      peerKey: this.peerId.toHex(),
      identityKey: this.peerId.toHex()
    });
  }
  async waitTillReceive(message) {
    return expectReceivedMessage(this.defaultReceived, message);
  }
  async waitForPeerAvailable(topic, peer) {
    return expectPeerAvailable(this.signalManager, topic, peer);
  }
  async waitForPeerLeft(topic, peer) {
    return expectPeerLeft(this.signalManager, topic, peer);
  }
  async _open() {
    this.signalManager = await this.testBuilder.createSignalManager(this);
    this.messenger = new Messenger({
      signalManager: this.signalManager,
      retryDelay: 300
    });
    await this.signalManager.open();
    this.messenger.open();
    await this.messenger.listen({
      peer: this.peerInfo,
      onMessage: async (msg) => {
        this.defaultReceived.emit(msg);
      }
    }).catch((err) => log.catch(err, void 0, {
      F: __dxlog_file,
      L: 57,
      S: this,
      C: (f, a) => f(...a)
    }));
  }
  async _close() {
    await this.messenger.close();
    await this.signalManager.close();
  }
};

// packages/core/mesh/messaging/src/testing/test-builder.ts
var TestBuilder = class {
  constructor(options) {
    this.options = options;
    this._signalContext = new MemorySignalManagerContext();
    this._peers = [];
  }
  async createSignalManager(peer) {
    const signalManager = await this.options.signalManagerFactory?.(peer) ?? new MemorySignalManager(this._signalContext);
    if (this.options.messageDisruption) {
      const trueSend = signalManager.sendMessage.bind(signalManager);
      signalManager.sendMessage = async (message) => {
        for (const msg of this.options.messageDisruption(message)) {
          await trueSend(msg);
        }
      };
    }
    return signalManager;
  }
  async createPeer() {
    const peer = new TestPeer(this);
    await peer.open();
    this._peers.push(peer);
    return peer;
  }
  async createPeers(count) {
    return Promise.all(Array.from({
      length: count
    }, () => this.createPeer()));
  }
  async close() {
    await Promise.all(this._peers.map((peer) => peer.close()));
  }
};
export {
  PAYLOAD_1,
  PAYLOAD_2,
  PAYLOAD_3,
  TestBuilder,
  TestPeer,
  createMessage,
  expectPeerAvailable,
  expectPeerLeft,
  expectReceivedMessage,
  messageEqual
};
//# sourceMappingURL=index.mjs.map
