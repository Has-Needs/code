import "@dxos/node-std/globals";

// packages/core/mesh/messaging/src/messenger.ts
import { TimeoutError, scheduleExponentialBackoffTaskInterval, scheduleTask, scheduleTaskInterval } from "@dxos/async";
import { Context } from "@dxos/context";
import { invariant } from "@dxos/invariant";
import { PublicKey } from "@dxos/keys";
import { log } from "@dxos/log";
import { TimeoutError as ProtocolTimeoutError, trace as trace2 } from "@dxos/protocols";
import { schema } from "@dxos/protocols/proto";
import { ComplexMap, ComplexSet } from "@dxos/util";

// packages/core/mesh/messaging/src/messenger-monitor.ts
import { trace } from "@dxos/tracing";
var MessengerMonitor = class {
  recordMessageAckFailed() {
    trace.metrics.increment("dxos.mesh.signal.messenger.failed-ack", 1);
  }
  recordReliableMessage(params) {
    trace.metrics.increment("dxos.mesh.signal.messenger.reliable-send", 1, {
      tags: {
        success: params.sent,
        attempts: params.sendAttempts
      }
    });
  }
};

// packages/core/mesh/messaging/src/timeouts.ts
var MESSAGE_TIMEOUT = 1e4;

// packages/core/mesh/messaging/src/messenger.ts
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/core/mesh/messaging/src/messenger.ts";
var ReliablePayload = schema.getCodecForType("dxos.mesh.messaging.ReliablePayload");
var Acknowledgement = schema.getCodecForType("dxos.mesh.messaging.Acknowledgement");
var RECEIVED_MESSAGES_GC_INTERVAL = 12e4;
var Messenger = class {
  constructor({ signalManager, retryDelay = 1e3 }) {
    this._monitor = new MessengerMonitor();
    // { peerId, payloadType } => listeners set
    this._listeners = new ComplexMap(({ peerId, payloadType }) => peerId + payloadType);
    // peerId => listeners set
    this._defaultListeners = /* @__PURE__ */ new Map();
    this._onAckCallbacks = new ComplexMap(PublicKey.hash);
    this._receivedMessages = new ComplexSet(PublicKey.hash);
    /**
    * Keys scheduled to be cleared from _receivedMessages on the next iteration.
    */
    this._toClear = new ComplexSet(PublicKey.hash);
    this._closed = true;
    this._signalManager = signalManager;
    this._retryDelay = retryDelay;
    this.open();
  }
  open() {
    if (!this._closed) {
      return;
    }
    const traceId = PublicKey.random().toHex();
    log.trace("dxos.mesh.messenger.open", trace2.begin({
      id: traceId
    }), {
      F: __dxlog_file,
      L: 72,
      S: this,
      C: (f, a) => f(...a)
    });
    this._ctx = new Context({
      onError: (err) => log.catch(err, void 0, {
        F: __dxlog_file,
        L: 74,
        S: this,
        C: (f, a) => f(...a)
      })
    }, {
      F: __dxlog_file,
      L: 73
    });
    this._ctx.onDispose(this._signalManager.onMessage.on(async (message) => {
      log("received message", {
        from: message.author
      }, {
        F: __dxlog_file,
        L: 78,
        S: this,
        C: (f, a) => f(...a)
      });
      await this._handleMessage(message);
    }));
    scheduleTaskInterval(this._ctx, async () => {
      this._performGc();
    }, RECEIVED_MESSAGES_GC_INTERVAL);
    this._closed = false;
    log.trace("dxos.mesh.messenger.open", trace2.end({
      id: traceId
    }), {
      F: __dxlog_file,
      L: 93,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  async close() {
    if (this._closed) {
      return;
    }
    this._closed = true;
    await this._ctx.dispose();
  }
  async sendMessage({ author, recipient, payload }) {
    invariant(!this._closed, "Closed", {
      F: __dxlog_file,
      L: 105,
      S: this,
      A: [
        "!this._closed",
        "'Closed'"
      ]
    });
    const messageContext = this._ctx.derive();
    const reliablePayload = {
      messageId: PublicKey.random(),
      payload
    };
    invariant(!this._onAckCallbacks.has(reliablePayload.messageId), void 0, {
      F: __dxlog_file,
      L: 112,
      S: this,
      A: [
        "!this._onAckCallbacks.has(reliablePayload.messageId!)",
        ""
      ]
    });
    log("send message", {
      messageId: reliablePayload.messageId,
      author,
      recipient
    }, {
      F: __dxlog_file,
      L: 113,
      S: this,
      C: (f, a) => f(...a)
    });
    let messageReceived;
    let timeoutHit;
    let sendAttempts = 0;
    const promise = new Promise((resolve, reject) => {
      messageReceived = resolve;
      timeoutHit = reject;
    });
    scheduleExponentialBackoffTaskInterval(messageContext, async () => {
      log("retrying message", {
        messageId: reliablePayload.messageId
      }, {
        F: __dxlog_file,
        L: 128,
        S: this,
        C: (f, a) => f(...a)
      });
      sendAttempts++;
      await this._encodeAndSend({
        author,
        recipient,
        reliablePayload
      }).catch((err) => log("failed to send message", {
        err
      }, {
        F: __dxlog_file,
        L: 131,
        S: this,
        C: (f, a) => f(...a)
      }));
    }, this._retryDelay);
    scheduleTask(messageContext, () => {
      log("message not delivered", {
        messageId: reliablePayload.messageId
      }, {
        F: __dxlog_file,
        L: 140,
        S: this,
        C: (f, a) => f(...a)
      });
      this._onAckCallbacks.delete(reliablePayload.messageId);
      timeoutHit(new ProtocolTimeoutError("signaling message not delivered", new TimeoutError(MESSAGE_TIMEOUT, "Message not delivered")));
      void messageContext.dispose();
      this._monitor.recordReliableMessage({
        sendAttempts,
        sent: false
      });
    }, MESSAGE_TIMEOUT);
    this._onAckCallbacks.set(reliablePayload.messageId, () => {
      messageReceived();
      this._onAckCallbacks.delete(reliablePayload.messageId);
      void messageContext.dispose();
      this._monitor.recordReliableMessage({
        sendAttempts,
        sent: true
      });
    });
    await this._encodeAndSend({
      author,
      recipient,
      reliablePayload
    });
    return promise;
  }
  /**
  * Subscribes onMessage function to messages that contains payload with payloadType.
  * @param payloadType if not specified, onMessage will be subscribed to all types of messages.
  */
  async listen({ peer, payloadType, onMessage }) {
    invariant(!this._closed, "Closed", {
      F: __dxlog_file,
      L: 178,
      S: this,
      A: [
        "!this._closed",
        "'Closed'"
      ]
    });
    await this._signalManager.subscribeMessages(peer);
    let listeners;
    invariant(peer.peerKey, "Peer key is required", {
      F: __dxlog_file,
      L: 182,
      S: this,
      A: [
        "peer.peerKey",
        "'Peer key is required'"
      ]
    });
    if (!payloadType) {
      listeners = this._defaultListeners.get(peer.peerKey);
      if (!listeners) {
        listeners = /* @__PURE__ */ new Set();
        this._defaultListeners.set(peer.peerKey, listeners);
      }
    } else {
      listeners = this._listeners.get({
        peerId: peer.peerKey,
        payloadType
      });
      if (!listeners) {
        listeners = /* @__PURE__ */ new Set();
        this._listeners.set({
          peerId: peer.peerKey,
          payloadType
        }, listeners);
      }
    }
    listeners.add(onMessage);
    return {
      unsubscribe: async () => {
        listeners.delete(onMessage);
      }
    };
  }
  async _encodeAndSend({ author, recipient, reliablePayload }) {
    await this._signalManager.sendMessage({
      author,
      recipient,
      payload: {
        type_url: "dxos.mesh.messaging.ReliablePayload",
        value: ReliablePayload.encode(reliablePayload, {
          preserveAny: true
        })
      }
    });
  }
  async _handleMessage(message) {
    switch (message.payload.type_url) {
      case "dxos.mesh.messaging.ReliablePayload": {
        await this._handleReliablePayload(message);
        break;
      }
      case "dxos.mesh.messaging.Acknowledgement": {
        await this._handleAcknowledgement({
          payload: message.payload
        });
        break;
      }
    }
  }
  async _handleReliablePayload({ author, recipient, payload }) {
    invariant(payload.type_url === "dxos.mesh.messaging.ReliablePayload", void 0, {
      F: __dxlog_file,
      L: 240,
      S: this,
      A: [
        "payload.type_url === 'dxos.mesh.messaging.ReliablePayload'",
        ""
      ]
    });
    const reliablePayload = ReliablePayload.decode(payload.value, {
      preserveAny: true
    });
    log("handling message", {
      messageId: reliablePayload.messageId
    }, {
      F: __dxlog_file,
      L: 243,
      S: this,
      C: (f, a) => f(...a)
    });
    try {
      await this._sendAcknowledgement({
        author,
        recipient,
        messageId: reliablePayload.messageId
      });
    } catch (err) {
      this._monitor.recordMessageAckFailed();
      throw err;
    }
    if (this._receivedMessages.has(reliablePayload.messageId)) {
      return;
    }
    this._receivedMessages.add(reliablePayload.messageId);
    await this._callListeners({
      author,
      recipient,
      payload: reliablePayload.payload
    });
  }
  async _handleAcknowledgement({ payload }) {
    invariant(payload.type_url === "dxos.mesh.messaging.Acknowledgement", void 0, {
      F: __dxlog_file,
      L: 271,
      S: this,
      A: [
        "payload.type_url === 'dxos.mesh.messaging.Acknowledgement'",
        ""
      ]
    });
    this._onAckCallbacks.get(Acknowledgement.decode(payload.value).messageId)?.();
  }
  async _sendAcknowledgement({ author, recipient, messageId }) {
    log("sending ACK", {
      messageId,
      from: recipient,
      to: author
    }, {
      F: __dxlog_file,
      L: 284,
      S: this,
      C: (f, a) => f(...a)
    });
    await this._signalManager.sendMessage({
      author: recipient,
      recipient: author,
      payload: {
        type_url: "dxos.mesh.messaging.Acknowledgement",
        value: Acknowledgement.encode({
          messageId
        })
      }
    });
  }
  async _callListeners(message) {
    {
      invariant(message.recipient.peerKey, "Peer key is required", {
        F: __dxlog_file,
        L: 298,
        S: this,
        A: [
          "message.recipient.peerKey",
          "'Peer key is required'"
        ]
      });
      const defaultListenerMap = this._defaultListeners.get(message.recipient.peerKey);
      if (defaultListenerMap) {
        for (const listener of defaultListenerMap) {
          await listener(message);
        }
      }
    }
    {
      const listenerMap = this._listeners.get({
        peerId: message.recipient.peerKey,
        payloadType: message.payload.type_url
      });
      if (listenerMap) {
        for (const listener of listenerMap) {
          await listener(message);
        }
      }
    }
  }
  _performGc() {
    const start = performance.now();
    for (const key of this._toClear.keys()) {
      this._receivedMessages.delete(key);
    }
    this._toClear.clear();
    for (const key of this._receivedMessages.keys()) {
      this._toClear.add(key);
    }
    const elapsed = performance.now() - start;
    if (elapsed > 100) {
      log.warn("GC took too long", {
        elapsed
      }, {
        F: __dxlog_file,
        L: 333,
        S: this,
        C: (f, a) => f(...a)
      });
    }
  }
};

// packages/core/mesh/messaging/src/signal-client/signal-client.ts
import { DeferredTask, Event as Event2, Trigger as Trigger2, scheduleTask as scheduleTask2, scheduleTaskInterval as scheduleTaskInterval3, sleep } from "@dxos/async";
import { cancelWithContext as cancelWithContext2, Resource } from "@dxos/context";
import { invariant as invariant3 } from "@dxos/invariant";
import { PublicKey as PublicKey4 } from "@dxos/keys";
import { log as log4 } from "@dxos/log";
import { trace as trace6 } from "@dxos/protocols";
import { SignalState } from "@dxos/protocols/proto/dxos/mesh/signal";

// packages/core/mesh/messaging/src/signal-client/signal-client-monitor.ts
import { trace as trace3 } from "@dxos/tracing";
var SignalClientMonitor = class {
  constructor() {
    this._performance = {
      sentMessages: 0,
      receivedMessages: 0,
      reconnectCounter: 0,
      joinCounter: 0,
      leaveCounter: 0
    };
    /**
    * Timestamp of when the connection attempt was began.
    */
    this._connectionStarted = /* @__PURE__ */ new Date();
    /**
    * Timestamp of last state change.
    */
    this._lastStateChange = /* @__PURE__ */ new Date();
  }
  getRecordedTimestamps() {
    return {
      connectionStarted: this._connectionStarted,
      lastStateChange: this._lastStateChange
    };
  }
  recordStateChangeTime() {
    this._lastStateChange = /* @__PURE__ */ new Date();
  }
  recordConnectionStartTime() {
    this._connectionStarted = /* @__PURE__ */ new Date();
  }
  recordReconnect(params) {
    this._performance.reconnectCounter++;
    trace3.metrics.increment("dxos.mesh.signal.signal-client.reconnect", 1, {
      tags: {
        success: params.success
      }
    });
  }
  recordJoin() {
    this._performance.joinCounter++;
  }
  recordLeave() {
    this._performance.leaveCounter++;
  }
  recordMessageReceived(message) {
    this._performance.receivedMessages++;
    trace3.metrics.increment("dxos.mesh.signal.signal-client.received-total", 1, {
      tags: createIdentityTags(message)
    });
    trace3.metrics.distribution("dxos.mesh.signal.signal-client.bytes-in", getByteCount(message), {
      tags: createIdentityTags(message)
    });
  }
  async recordMessageSending(message, sendMessage) {
    this._performance.sentMessages++;
    const tags = createIdentityTags(message);
    let success = true;
    try {
      const reqStart = Date.now();
      await sendMessage();
      const reqDuration = Date.now() - reqStart;
      trace3.metrics.distribution("dxos.mesh.signal.signal-client.send-duration", reqDuration, {
        tags
      });
      trace3.metrics.distribution("dxos.mesh.signal.signal-client.bytes-out", getByteCount(message), {
        tags
      });
    } catch (err) {
      success = false;
    }
    trace3.metrics.increment("dxos.mesh.signal.signal-client.sent-total", 1, {
      tags: {
        ...tags,
        success
      }
    });
  }
  recordStreamCloseErrors(count) {
    trace3.metrics.increment("dxos.mesh.signal.signal-client.stream-close-errors", count);
  }
  recordReconciliation(params) {
    trace3.metrics.increment("dxos.mesh.signal.signal-client.reconciliation", 1, {
      tags: {
        success: params.success
      }
    });
  }
};
var getByteCount = (message) => {
  return message.author.peerKey.length + message.recipient.peerKey.length + message.payload.type_url.length + message.payload.value.length;
};
var createIdentityTags = (message) => {
  return {
    peer: message.author.peerKey
  };
};

// packages/core/mesh/messaging/src/signal-client/signal-local-state.ts
import { asyncTimeout, Event } from "@dxos/async";
import { cancelWithContext } from "@dxos/context";
import { PublicKey as PublicKey2 } from "@dxos/keys";
import { log as log2 } from "@dxos/log";
import { ComplexMap as ComplexMap2, ComplexSet as ComplexSet2, safeAwaitAll } from "@dxos/util";
var __dxlog_file2 = "/home/runner/work/dxos/dxos/packages/core/mesh/messaging/src/signal-client/signal-local-state.ts";
var SignalLocalState = class {
  constructor(_onMessage, _onSwarmEvent) {
    this._onMessage = _onMessage;
    this._onSwarmEvent = _onSwarmEvent;
    this._swarmStreams = new ComplexMap2(({ topic, peerId }) => topic.toHex() + peerId.toHex());
    this._joinedTopics = new ComplexSet2(({ topic, peerId }) => topic.toHex() + peerId.toHex());
    this._subscribedMessages = new ComplexSet2(({ peerId }) => peerId.toHex());
    this.messageStreams = new ComplexMap2((key) => key.toHex());
    this.reconciled = new Event();
  }
  async safeCloseStreams() {
    const streams = [
      ...this._swarmStreams.values()
    ].concat([
      ...this.messageStreams.values()
    ]);
    this._swarmStreams.clear();
    this.messageStreams.clear();
    const failureCount = (await safeAwaitAll(streams, (s) => s.close())).length;
    return {
      failureCount
    };
  }
  join({ topic, peerId }) {
    this._joinedTopics.add({
      topic,
      peerId
    });
  }
  leave({ topic, peerId }) {
    void this._swarmStreams.get({
      topic,
      peerId
    })?.close();
    this._swarmStreams.delete({
      topic,
      peerId
    });
    this._joinedTopics.delete({
      topic,
      peerId
    });
  }
  subscribeMessages(peerId) {
    this._subscribedMessages.add({
      peerId
    });
  }
  unsubscribeMessages(peerId) {
    log2("unsubscribing from messages", {
      peerId
    }, {
      F: __dxlog_file2,
      L: 79,
      S: this,
      C: (f, a) => f(...a)
    });
    this._subscribedMessages.delete({
      peerId
    });
    void this.messageStreams.get(peerId)?.close();
    this.messageStreams.delete(peerId);
  }
  async reconcile(ctx, client) {
    await this._reconcileSwarmSubscriptions(ctx, client);
    await this._reconcileMessageSubscriptions(ctx, client);
    this.reconciled.emit();
  }
  async _reconcileSwarmSubscriptions(ctx, client) {
    for (const { topic, peerId } of this._swarmStreams.keys()) {
      if (this._joinedTopics.has({
        topic,
        peerId
      })) {
        continue;
      }
      void this._swarmStreams.get({
        topic,
        peerId
      })?.close();
      this._swarmStreams.delete({
        topic,
        peerId
      });
    }
    for (const { topic, peerId } of this._joinedTopics.values()) {
      if (this._swarmStreams.has({
        topic,
        peerId
      })) {
        continue;
      }
      const swarmStream = await asyncTimeout(cancelWithContext(ctx, client.join({
        topic,
        peerId
      })), 5e3);
      swarmStream.subscribe(async (swarmEvent) => {
        if (this._joinedTopics.has({
          topic,
          peerId
        })) {
          log2("swarm event", {
            swarmEvent
          }, {
            F: __dxlog_file2,
            L: 115,
            S: this,
            C: (f, a) => f(...a)
          });
          const event = swarmEvent.peerAvailable ? {
            topic,
            peerAvailable: {
              ...swarmEvent.peerAvailable,
              peer: {
                peerKey: PublicKey2.from(swarmEvent.peerAvailable.peer).toHex()
              }
            }
          } : {
            topic,
            peerLeft: {
              ...swarmEvent.peerLeft,
              peer: {
                peerKey: PublicKey2.from(swarmEvent.peerLeft.peer).toHex()
              }
            }
          };
          await this._onSwarmEvent(event);
        }
      });
      this._swarmStreams.set({
        topic,
        peerId
      }, swarmStream);
    }
  }
  async _reconcileMessageSubscriptions(ctx, client) {
    for (const peerId of this.messageStreams.keys()) {
      if (this._subscribedMessages.has({
        peerId
      })) {
        continue;
      }
      void this.messageStreams.get(peerId)?.close();
      this.messageStreams.delete(peerId);
    }
    for (const { peerId } of this._subscribedMessages.values()) {
      if (this.messageStreams.has(peerId)) {
        continue;
      }
      const messageStream = await asyncTimeout(cancelWithContext(ctx, client.receiveMessages(peerId)), 5e3);
      messageStream.subscribe(async (signalMessage) => {
        if (this._subscribedMessages.has({
          peerId
        })) {
          const message = {
            author: {
              peerKey: PublicKey2.from(signalMessage.author).toHex()
            },
            recipient: {
              peerKey: PublicKey2.from(signalMessage.recipient).toHex()
            },
            payload: signalMessage.payload
          };
          await this._onMessage(message);
        }
      });
      this.messageStreams.set(peerId, messageStream);
    }
  }
};

// packages/core/mesh/messaging/src/signal-client/signal-rpc-client.ts
import WebSocket from "isomorphic-ws";
import { scheduleTaskInterval as scheduleTaskInterval2, TimeoutError as TimeoutError2, Trigger } from "@dxos/async";
import { Context as Context2 } from "@dxos/context";
import { invariant as invariant2 } from "@dxos/invariant";
import { PublicKey as PublicKey3 } from "@dxos/keys";
import { log as log3 } from "@dxos/log";
import { trace as trace5 } from "@dxos/protocols";
import { schema as schema2 } from "@dxos/protocols/proto";
import { createProtoRpcPeer } from "@dxos/rpc";

// packages/core/mesh/messaging/src/signal-client/signal-rpc-client-monitor.ts
import { trace as trace4 } from "@dxos/tracing";
var SignalRpcClientMonitor = class {
  recordClientCloseFailure(params) {
    trace4.metrics.increment("dxos.mesh.signal.signal-rpc-client.close-failure", 1, {
      tags: {
        reason: params.failureReason
      }
    });
  }
};

// packages/core/mesh/messaging/src/signal-client/signal-rpc-client.ts
var __dxlog_file3 = "/home/runner/work/dxos/dxos/packages/core/mesh/messaging/src/signal-client/signal-rpc-client.ts";
var SIGNAL_KEEPALIVE_INTERVAL = 1e4;
var SignalRPCClient = class {
  constructor({ url, callbacks = {} }) {
    this._connectTrigger = new Trigger();
    this._closed = false;
    this._closeComplete = new Trigger();
    this._monitor = new SignalRpcClientMonitor();
    const traceId = PublicKey3.random().toHex();
    log3.trace("dxos.mesh.signal-rpc-client.constructor", trace5.begin({
      id: traceId
    }), {
      F: __dxlog_file3,
      L: 66,
      S: this,
      C: (f, a) => f(...a)
    });
    this._url = url;
    this._callbacks = callbacks;
    this._socket = new WebSocket(this._url);
    this._rpc = createProtoRpcPeer({
      requested: {
        Signal: schema2.getService("dxos.mesh.signal.Signal")
      },
      noHandshake: true,
      port: {
        send: (msg) => {
          if (this._closed) {
            return;
          }
          try {
            this._socket.send(msg);
          } catch (err) {
            log3.warn("send error", err, {
              F: __dxlog_file3,
              L: 85,
              S: this,
              C: (f, a) => f(...a)
            });
          }
        },
        subscribe: (cb) => {
          this._socket.onmessage = async (msg) => {
            if (typeof Blob !== "undefined" && msg.data instanceof Blob) {
              cb(Buffer.from(await msg.data.arrayBuffer()));
            } else {
              cb(msg.data);
            }
          };
        }
      },
      encodingOptions: {
        preserveAny: true
      }
    });
    this._socket.onopen = async () => {
      try {
        await this._rpc.open();
        if (this._closed) {
          await this._safeCloseRpc();
          return;
        }
        log3(`RPC open ${this._url}`, void 0, {
          F: __dxlog_file3,
          L: 110,
          S: this,
          C: (f, a) => f(...a)
        });
        this._callbacks.onConnected?.();
        this._connectTrigger.wake();
        this._keepaliveCtx = new Context2(void 0, {
          F: __dxlog_file3,
          L: 113
        });
        scheduleTaskInterval2(this._keepaliveCtx, async () => {
          this._socket?.send("__ping__");
        }, SIGNAL_KEEPALIVE_INTERVAL);
      } catch (err) {
        this._callbacks.onError?.(err);
        this._socket.close();
        this._closed = true;
      }
    };
    this._socket.onclose = async () => {
      log3(`Disconnected ${this._url}`, void 0, {
        F: __dxlog_file3,
        L: 133,
        S: this,
        C: (f, a) => f(...a)
      });
      this._callbacks.onDisconnected?.();
      this._closeComplete.wake();
      await this.close();
    };
    this._socket.onerror = async (event) => {
      if (this._closed) {
        this._socket.close();
        return;
      }
      this._closed = true;
      this._callbacks.onError?.(event.error ?? new Error(event.message));
      await this._safeCloseRpc();
      log3.warn(`Socket ${event.type ?? "unknown"} error`, {
        message: event.message,
        url: this._url
      }, {
        F: __dxlog_file3,
        L: 149,
        S: this,
        C: (f, a) => f(...a)
      });
    };
    log3.trace("dxos.mesh.signal-rpc-client.constructor", trace5.end({
      id: traceId
    }), {
      F: __dxlog_file3,
      L: 152,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  async close() {
    if (this._closed) {
      return;
    }
    this._closed = true;
    await this._keepaliveCtx?.dispose();
    try {
      await this._safeCloseRpc();
      if (this._socket.readyState === WebSocket.OPEN || this._socket.readyState === WebSocket.CONNECTING) {
        this._socket.close();
      }
      await this._closeComplete.wait({
        timeout: 1e3
      });
    } catch (err) {
      const failureReason = err instanceof TimeoutError2 ? "timeout" : err?.constructor?.name ?? "unknown";
      this._monitor.recordClientCloseFailure({
        failureReason
      });
    }
  }
  async join({ topic, peerId }) {
    log3("join", {
      topic,
      peerId,
      metadata: this._callbacks?.getMetadata?.()
    }, {
      F: __dxlog_file3,
      L: 178,
      S: this,
      C: (f, a) => f(...a)
    });
    invariant2(!this._closed, "SignalRPCClient is closed", {
      F: __dxlog_file3,
      L: 179,
      S: this,
      A: [
        "!this._closed",
        "'SignalRPCClient is closed'"
      ]
    });
    await this._connectTrigger.wait();
    const swarmStream = this._rpc.rpc.Signal.join({
      swarm: topic.asUint8Array(),
      peer: peerId.asUint8Array(),
      metadata: this._callbacks?.getMetadata?.()
    });
    await swarmStream.waitUntilReady();
    return swarmStream;
  }
  async receiveMessages(peerId) {
    log3("receiveMessages", {
      peerId
    }, {
      F: __dxlog_file3,
      L: 191,
      S: this,
      C: (f, a) => f(...a)
    });
    invariant2(!this._closed, "SignalRPCClient is closed", {
      F: __dxlog_file3,
      L: 192,
      S: this,
      A: [
        "!this._closed",
        "'SignalRPCClient is closed'"
      ]
    });
    await this._connectTrigger.wait();
    const messageStream = this._rpc.rpc.Signal.receiveMessages({
      peer: peerId.asUint8Array()
    });
    await messageStream.waitUntilReady();
    return messageStream;
  }
  async sendMessage({ author, recipient, payload }) {
    log3("sendMessage", {
      author,
      recipient,
      payload,
      metadata: this._callbacks?.getMetadata?.()
    }, {
      F: __dxlog_file3,
      L: 210,
      S: this,
      C: (f, a) => f(...a)
    });
    invariant2(!this._closed, "SignalRPCClient is closed", {
      F: __dxlog_file3,
      L: 211,
      S: this,
      A: [
        "!this._closed",
        "'SignalRPCClient is closed'"
      ]
    });
    await this._connectTrigger.wait();
    await this._rpc.rpc.Signal.sendMessage({
      author: author.asUint8Array(),
      recipient: recipient.asUint8Array(),
      payload,
      metadata: this._callbacks?.getMetadata?.()
    });
  }
  async _safeCloseRpc() {
    try {
      this._connectTrigger.reset();
      await this._rpc.close();
    } catch (err) {
      log3.catch(err, void 0, {
        F: __dxlog_file3,
        L: 226,
        S: this,
        C: (f, a) => f(...a)
      });
    }
  }
};

// packages/core/mesh/messaging/src/signal-client/signal-client.ts
var __dxlog_file4 = "/home/runner/work/dxos/dxos/packages/core/mesh/messaging/src/signal-client/signal-client.ts";
var DEFAULT_RECONNECT_TIMEOUT = 100;
var MAX_RECONNECT_TIMEOUT = 5e3;
var ERROR_RECONCILE_DELAY = 1e3;
var RECONCILE_INTERVAL = 5e3;
var SignalClient = class extends Resource {
  /**
  * @param _host Signal server websocket URL.
  * @param onMessage called when a new message is received.
  * @param onSwarmEvent called when a new swarm event is received.
  * @param _getMetadata signal-message metadata provider, called for every message.
  */
  constructor(_host, _getMetadata) {
    super(), this._host = _host, this._getMetadata = _getMetadata, this._monitor = new SignalClientMonitor(), this._state = SignalState.CLOSED, this._lastReconciliationFailed = false, this._clientReady = new Trigger2(), this._reconnectAfter = DEFAULT_RECONNECT_TIMEOUT, this._instanceId = PublicKey4.random().toHex(), this.statusChanged = new Event2(), this.onMessage = new Event2(), this.swarmEvent = new Event2();
    if (!this._host.startsWith("wss://") && !this._host.startsWith("ws://")) {
      throw new Error(`Signal server requires a websocket URL. Provided: ${this._host}`);
    }
    this.localState = new SignalLocalState(async (message) => {
      this._monitor.recordMessageReceived(message);
      this.onMessage.emit(message);
    }, async (event) => this.swarmEvent.emit(event));
  }
  async _open() {
    log4.trace("dxos.mesh.signal-client.open", trace6.begin({
      id: this._instanceId
    }), {
      F: __dxlog_file4,
      L: 96,
      S: this,
      C: (f, a) => f(...a)
    });
    if ([
      SignalState.CONNECTED,
      SignalState.CONNECTING
    ].includes(this._state)) {
      return;
    }
    this._setState(SignalState.CONNECTING);
    this._reconcileTask = new DeferredTask(this._ctx, async () => {
      try {
        await cancelWithContext2(this._connectionCtx, this._clientReady.wait({
          timeout: 5e3
        }));
        invariant3(this._state === SignalState.CONNECTED, "Not connected to Signal Server", {
          F: __dxlog_file4,
          L: 106,
          S: this,
          A: [
            "this._state === SignalState.CONNECTED",
            "'Not connected to Signal Server'"
          ]
        });
        await this.localState.reconcile(this._connectionCtx, this._client);
        this._monitor.recordReconciliation({
          success: true
        });
        this._lastReconciliationFailed = false;
      } catch (err) {
        this._lastReconciliationFailed = true;
        this._monitor.recordReconciliation({
          success: false
        });
        throw err;
      }
    });
    scheduleTaskInterval3(this._ctx, async () => {
      if (this._state === SignalState.CONNECTED) {
        this._reconcileTask.schedule();
      }
    }, RECONCILE_INTERVAL);
    this._reconnectTask = new DeferredTask(this._ctx, async () => {
      try {
        await this._reconnect();
        this._monitor.recordReconnect({
          success: true
        });
      } catch (err) {
        this._monitor.recordReconnect({
          success: false
        });
        throw err;
      }
    });
    this._createClient();
    log4.trace("dxos.mesh.signal-client.open", trace6.end({
      id: this._instanceId
    }), {
      F: __dxlog_file4,
      L: 139,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  async _catch(err) {
    if (this._state === SignalState.CLOSED || this._ctx.disposed) {
      return;
    }
    if (this._state === SignalState.CONNECTED && !this._lastReconciliationFailed) {
      log4.warn("SignalClient error:", err, {
        F: __dxlog_file4,
        L: 148,
        S: this,
        C: (f, a) => f(...a)
      });
    }
    this._scheduleReconcileAfterError();
  }
  async _close() {
    log4("closing...", void 0, {
      F: __dxlog_file4,
      L: 154,
      S: this,
      C: (f, a) => f(...a)
    });
    if ([
      SignalState.CLOSED
    ].includes(this._state)) {
      return;
    }
    this._setState(SignalState.CLOSED);
    await this._safeResetClient();
    log4("closed", void 0, {
      F: __dxlog_file4,
      L: 162,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  getStatus() {
    return {
      host: this._host,
      state: this._state,
      error: this._lastError?.message,
      reconnectIn: this._reconnectAfter,
      ...this._monitor.getRecordedTimestamps()
    };
  }
  async join(args) {
    log4("joining", {
      topic: args.topic,
      peerId: args.peer.peerKey
    }, {
      F: __dxlog_file4,
      L: 176,
      S: this,
      C: (f, a) => f(...a)
    });
    this._monitor.recordJoin();
    this.localState.join({
      topic: args.topic,
      peerId: PublicKey4.from(args.peer.peerKey)
    });
    this._reconcileTask?.schedule();
  }
  async leave(args) {
    log4("leaving", {
      topic: args.topic,
      peerId: args.peer.peerKey
    }, {
      F: __dxlog_file4,
      L: 183,
      S: this,
      C: (f, a) => f(...a)
    });
    this._monitor.recordLeave();
    this.localState.leave({
      topic: args.topic,
      peerId: PublicKey4.from(args.peer.peerKey)
    });
  }
  async query(params) {
    throw new Error("Not implemented");
  }
  async sendMessage(msg) {
    return this._monitor.recordMessageSending(msg, async () => {
      await this._clientReady.wait();
      invariant3(this._state === SignalState.CONNECTED, "Not connected to Signal Server", {
        F: __dxlog_file4,
        L: 195,
        S: this,
        A: [
          "this._state === SignalState.CONNECTED",
          "'Not connected to Signal Server'"
        ]
      });
      invariant3(msg.author.peerKey, "Author key required", {
        F: __dxlog_file4,
        L: 196,
        S: this,
        A: [
          "msg.author.peerKey",
          "'Author key required'"
        ]
      });
      invariant3(msg.recipient.peerKey, "Recipient key required", {
        F: __dxlog_file4,
        L: 197,
        S: this,
        A: [
          "msg.recipient.peerKey",
          "'Recipient key required'"
        ]
      });
      await this._client.sendMessage({
        author: PublicKey4.from(msg.author.peerKey),
        recipient: PublicKey4.from(msg.recipient.peerKey),
        payload: msg.payload
      });
    });
  }
  async subscribeMessages(peer) {
    invariant3(peer.peerKey, "Peer key required", {
      F: __dxlog_file4,
      L: 207,
      S: this,
      A: [
        "peer.peerKey",
        "'Peer key required'"
      ]
    });
    log4("subscribing to messages", {
      peer
    }, {
      F: __dxlog_file4,
      L: 208,
      S: this,
      C: (f, a) => f(...a)
    });
    this.localState.subscribeMessages(PublicKey4.from(peer.peerKey));
    this._reconcileTask?.schedule();
  }
  async unsubscribeMessages(peer) {
    invariant3(peer.peerKey, "Peer key required", {
      F: __dxlog_file4,
      L: 214,
      S: this,
      A: [
        "peer.peerKey",
        "'Peer key required'"
      ]
    });
    log4("unsubscribing from messages", {
      peer
    }, {
      F: __dxlog_file4,
      L: 215,
      S: this,
      C: (f, a) => f(...a)
    });
    this.localState.unsubscribeMessages(PublicKey4.from(peer.peerKey));
  }
  _scheduleReconcileAfterError() {
    scheduleTask2(this._ctx, () => this._reconcileTask.schedule(), ERROR_RECONCILE_DELAY);
  }
  _createClient() {
    log4("creating client", {
      host: this._host,
      state: this._state
    }, {
      F: __dxlog_file4,
      L: 224,
      S: this,
      C: (f, a) => f(...a)
    });
    invariant3(!this._client, "Client already created", {
      F: __dxlog_file4,
      L: 225,
      S: this,
      A: [
        "!this._client",
        "'Client already created'"
      ]
    });
    this._monitor.recordConnectionStartTime();
    this._connectionCtx = this._ctx.derive();
    this._connectionCtx.onDispose(async () => {
      log4("connection context disposed", void 0, {
        F: __dxlog_file4,
        L: 232,
        S: this,
        C: (f, a) => f(...a)
      });
      const { failureCount } = await this.localState.safeCloseStreams();
      this._monitor.recordStreamCloseErrors(failureCount);
    });
    try {
      const client = new SignalRPCClient({
        url: this._host,
        callbacks: {
          onConnected: () => {
            if (client === this._client) {
              log4("socket connected", void 0, {
                F: __dxlog_file4,
                L: 243,
                S: this,
                C: (f, a) => f(...a)
              });
              this._onConnected();
            }
          },
          onDisconnected: () => {
            if (client !== this._client) {
              return;
            }
            log4("socket disconnected", {
              state: this._state
            }, {
              F: __dxlog_file4,
              L: 252,
              S: this,
              C: (f, a) => f(...a)
            });
            if (this._state === SignalState.ERROR) {
              this._setState(SignalState.DISCONNECTED);
            } else {
              this._onDisconnected();
            }
          },
          onError: (error) => {
            if (client === this._client) {
              log4("socket error", {
                error,
                state: this._state
              }, {
                F: __dxlog_file4,
                L: 264,
                S: this,
                C: (f, a) => f(...a)
              });
              this._onDisconnected({
                error
              });
            }
          },
          getMetadata: this._getMetadata
        }
      });
      this._client = client;
    } catch (error) {
      this._client = void 0;
      this._onDisconnected({
        error
      });
    }
  }
  async _reconnect() {
    log4(`reconnecting in ${this._reconnectAfter}ms`, {
      state: this._state
    }, {
      F: __dxlog_file4,
      L: 279,
      S: this,
      C: (f, a) => f(...a)
    });
    if (this._state === SignalState.RECONNECTING) {
      log4.info("Signal api already reconnecting.", void 0, {
        F: __dxlog_file4,
        L: 282,
        S: this,
        C: (f, a) => f(...a)
      });
      return;
    }
    if (this._state === SignalState.CLOSED) {
      return;
    }
    this._setState(SignalState.RECONNECTING);
    await this._safeResetClient();
    await cancelWithContext2(this._ctx, sleep(this._reconnectAfter));
    this._createClient();
  }
  _onConnected() {
    this._lastError = void 0;
    this._lastReconciliationFailed = false;
    this._reconnectAfter = DEFAULT_RECONNECT_TIMEOUT;
    this._setState(SignalState.CONNECTED);
    this._clientReady.wake();
    this._reconcileTask.schedule();
  }
  _onDisconnected(options) {
    this._updateReconnectTimeout();
    if (this._state === SignalState.CLOSED) {
      return;
    }
    if (options?.error) {
      this._lastError = options.error;
      this._setState(SignalState.ERROR);
    } else {
      this._setState(SignalState.DISCONNECTED);
    }
    this._reconnectTask.schedule();
  }
  _setState(newState) {
    this._state = newState;
    this._monitor.recordStateChangeTime();
    log4("signal state changed", {
      status: this.getStatus()
    }, {
      F: __dxlog_file4,
      L: 323,
      S: this,
      C: (f, a) => f(...a)
    });
    this.statusChanged.emit(this.getStatus());
  }
  _updateReconnectTimeout() {
    if (this._state !== SignalState.CONNECTED && this._state !== SignalState.CONNECTING) {
      this._reconnectAfter *= 2;
      this._reconnectAfter = Math.min(this._reconnectAfter, MAX_RECONNECT_TIMEOUT);
    }
  }
  async _safeResetClient() {
    await this._connectionCtx?.dispose();
    this._connectionCtx = void 0;
    this._clientReady.reset();
    await this._client?.close().catch(() => {
    });
    this._client = void 0;
  }
};

// packages/core/mesh/messaging/src/signal-methods.ts
var PeerInfoHash = ({ peerKey }) => peerKey;

// packages/core/mesh/messaging/src/signal-manager/memory-signal-manager.ts
import { Event as Event3, Trigger as Trigger3 } from "@dxos/async";
import { Context as Context3 } from "@dxos/context";
import { invariant as invariant4 } from "@dxos/invariant";
import { PublicKey as PublicKey5 } from "@dxos/keys";
import { log as log5 } from "@dxos/log";
import { schema as schema3 } from "@dxos/protocols/proto";
import { ComplexMap as ComplexMap3, ComplexSet as ComplexSet3 } from "@dxos/util";
var __dxlog_file5 = "/home/runner/work/dxos/dxos/packages/core/mesh/messaging/src/signal-manager/memory-signal-manager.ts";
var MemorySignalManagerContext = class {
  constructor() {
    // Swarm messages.
    this.swarmEvent = new Event3();
    // Mapping from topic to set of peers.
    this.swarms = new ComplexMap3(PublicKey5.hash);
    // Map of connections for each peer for signaling.
    this.connections = new ComplexMap3(PeerInfoHash);
  }
};
var MemorySignalManager = class {
  constructor(_context) {
    this._context = _context;
    this.statusChanged = new Event3();
    this.swarmEvent = new Event3();
    this.onMessage = new Event3();
    this._joinedSwarms = new ComplexSet3(({ topic, peer }) => topic.toHex() + peer.peerKey);
    this._freezeTrigger = new Trigger3().wake();
    this._ctx = new Context3(void 0, {
      F: __dxlog_file5,
      L: 53
    });
    this._ctx.onDispose(this._context.swarmEvent.on((data) => this.swarmEvent.emit(data)));
  }
  async open() {
    if (!this._ctx.disposed) {
      return;
    }
    this._ctx = new Context3(void 0, {
      F: __dxlog_file5,
      L: 62
    });
    this._ctx.onDispose(this._context.swarmEvent.on((data) => this.swarmEvent.emit(data)));
    await Promise.all([
      ...this._joinedSwarms.values()
    ].map((value) => this.join(value)));
  }
  async close() {
    if (this._ctx.disposed) {
      return;
    }
    const joinedSwarmsCopy = new ComplexSet3(({ topic, peer }) => topic.toHex() + peer.peerKey, [
      ...this._joinedSwarms.values()
    ]);
    await Promise.all([
      ...this._joinedSwarms.values()
    ].map((value) => this.leave(value)));
    this._joinedSwarms = joinedSwarmsCopy;
    await this._ctx.dispose();
  }
  getStatus() {
    return [];
  }
  async join({ topic, peer }) {
    invariant4(!this._ctx.disposed, "Closed", {
      F: __dxlog_file5,
      L: 91,
      S: this,
      A: [
        "!this._ctx.disposed",
        "'Closed'"
      ]
    });
    this._joinedSwarms.add({
      topic,
      peer
    });
    if (!this._context.swarms.has(topic)) {
      this._context.swarms.set(topic, new ComplexSet3(PeerInfoHash));
    }
    this._context.swarms.get(topic).add(peer);
    this._context.swarmEvent.emit({
      topic,
      peerAvailable: {
        peer,
        since: /* @__PURE__ */ new Date()
      }
    });
    for (const [topic2, peers] of this._context.swarms) {
      Array.from(peers).forEach((peer2) => {
        this.swarmEvent.emit({
          topic: topic2,
          peerAvailable: {
            peer: peer2,
            since: /* @__PURE__ */ new Date()
          }
        });
      });
    }
  }
  async leave({ topic, peer }) {
    invariant4(!this._ctx.disposed, "Closed", {
      F: __dxlog_file5,
      L: 123,
      S: this,
      A: [
        "!this._ctx.disposed",
        "'Closed'"
      ]
    });
    this._joinedSwarms.delete({
      topic,
      peer
    });
    if (!this._context.swarms.has(topic)) {
      this._context.swarms.set(topic, new ComplexSet3(PeerInfoHash));
    }
    this._context.swarms.get(topic).delete(peer);
    const swarmEvent = {
      topic,
      peerLeft: {
        peer
      }
    };
    this._context.swarmEvent.emit(swarmEvent);
  }
  async query(request) {
    throw new Error("Not implemented");
  }
  async sendMessage({ author, recipient, payload }) {
    log5("send message", {
      author,
      recipient,
      ...dec(payload)
    }, {
      F: __dxlog_file5,
      L: 156,
      S: this,
      C: (f, a) => f(...a)
    });
    invariant4(recipient, void 0, {
      F: __dxlog_file5,
      L: 158,
      S: this,
      A: [
        "recipient",
        ""
      ]
    });
    invariant4(!this._ctx.disposed, "Closed", {
      F: __dxlog_file5,
      L: 159,
      S: this,
      A: [
        "!this._ctx.disposed",
        "'Closed'"
      ]
    });
    await this._freezeTrigger.wait();
    const remote = this._context.connections.get(recipient);
    if (!remote) {
      log5.warn("recipient is not subscribed for messages", {
        author,
        recipient
      }, {
        F: __dxlog_file5,
        L: 165,
        S: this,
        C: (f, a) => f(...a)
      });
      return;
    }
    if (remote._ctx.disposed) {
      log5.warn("recipient is disposed", {
        author,
        recipient
      }, {
        F: __dxlog_file5,
        L: 170,
        S: this,
        C: (f, a) => f(...a)
      });
      return;
    }
    remote._freezeTrigger.wait().then(() => {
      if (remote._ctx.disposed) {
        log5.warn("recipient is disposed", {
          author,
          recipient
        }, {
          F: __dxlog_file5,
          L: 178,
          S: this,
          C: (f, a) => f(...a)
        });
        return;
      }
      log5("receive message", {
        author,
        recipient,
        ...dec(payload)
      }, {
        F: __dxlog_file5,
        L: 182,
        S: this,
        C: (f, a) => f(...a)
      });
      remote.onMessage.emit({
        author,
        recipient,
        payload
      });
    }).catch((err) => {
      log5.error("error while waiting for freeze", {
        err
      }, {
        F: __dxlog_file5,
        L: 187,
        S: this,
        C: (f, a) => f(...a)
      });
    });
  }
  async subscribeMessages(peerInfo) {
    log5("subscribing", {
      peerInfo
    }, {
      F: __dxlog_file5,
      L: 192,
      S: this,
      C: (f, a) => f(...a)
    });
    this._context.connections.set(peerInfo, this);
  }
  async unsubscribeMessages(peerInfo) {
    log5("unsubscribing", {
      peerInfo
    }, {
      F: __dxlog_file5,
      L: 197,
      S: this,
      C: (f, a) => f(...a)
    });
    this._context.connections.delete(peerInfo);
  }
  freeze() {
    this._freezeTrigger.reset();
  }
  unfreeze() {
    this._freezeTrigger.wake();
  }
};
var dec = (payload) => {
  if (!payload.type_url.endsWith("ReliablePayload")) {
    return {};
  }
  const relPayload = schema3.getCodecForType("dxos.mesh.messaging.ReliablePayload").decode(payload.value);
  if (typeof relPayload?.payload?.data === "object") {
    return {
      payload: Object.keys(relPayload?.payload?.data)[0],
      sessionId: relPayload?.payload?.sessionId
    };
  }
  return {};
};

// packages/core/mesh/messaging/src/signal-manager/websocket-signal-manager.ts
import { Event as Event4, sleep as sleep2, synchronized } from "@dxos/async";
import { LifecycleState, Resource as Resource2 } from "@dxos/context";
import { invariant as invariant5 } from "@dxos/invariant";
import { PublicKey as PublicKey6 } from "@dxos/keys";
import { log as log6 } from "@dxos/log";
import { RateLimitExceededError, TimeoutError as TimeoutError3, trace as trace8 } from "@dxos/protocols";
import { BitField, safeAwaitAll as safeAwaitAll2 } from "@dxos/util";

// packages/core/mesh/messaging/src/signal-manager/websocket-signal-manager-monitor.ts
import { trace as trace7 } from "@dxos/tracing";
var WebsocketSignalManagerMonitor = class {
  recordRateLimitExceeded() {
    trace7.metrics.increment("dxos.mesh.signal.signal-manager.rate-limit-hit", 1);
  }
  recordServerFailure(params) {
    trace7.metrics.increment("dxos.mesh.signal.signal-manager.server-failure", 1, {
      tags: {
        server: params.serverName,
        restarted: params.willRestart
      }
    });
  }
};

// packages/core/mesh/messaging/src/signal-manager/websocket-signal-manager.ts
function _ts_decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file6 = "/home/runner/work/dxos/dxos/packages/core/mesh/messaging/src/signal-manager/websocket-signal-manager.ts";
var MAX_SERVER_FAILURES = 5;
var WSS_SIGNAL_SERVER_REBOOT_DELAY = 3e3;
var WebsocketSignalManager = class extends Resource2 {
  constructor(_hosts, _getMetadata) {
    super(), this._hosts = _hosts, this._getMetadata = _getMetadata, this._servers = /* @__PURE__ */ new Map(), this._monitor = new WebsocketSignalManagerMonitor(), this.failureCount = /* @__PURE__ */ new Map(), this.statusChanged = new Event4(), this.swarmEvent = new Event4(), this.onMessage = new Event4(), this._instanceId = PublicKey6.random().toHex();
    log6("Created WebsocketSignalManager", {
      hosts: this._hosts
    }, {
      F: __dxlog_file6,
      L: 58,
      S: this,
      C: (f, a) => f(...a)
    });
    for (const host of this._hosts) {
      if (this._servers.has(host.server)) {
        continue;
      }
      const server = new SignalClient(host.server, this._getMetadata);
      server.swarmEvent.on((data) => this.swarmEvent.emit(data));
      server.onMessage.on((data) => this.onMessage.emit(data));
      server.statusChanged.on(() => this.statusChanged.emit(this.getStatus()));
      this._servers.set(host.server, server);
      this.failureCount.set(host.server, 0);
    }
    this._failedServersBitfield = BitField.zeros(this._hosts.length);
  }
  async _open() {
    log6("open signal manager", {
      hosts: this._hosts
    }, {
      F: __dxlog_file6,
      L: 78,
      S: this,
      C: (f, a) => f(...a)
    });
    log6.trace("dxos.mesh.websocket-signal-manager.open", trace8.begin({
      id: this._instanceId
    }), {
      F: __dxlog_file6,
      L: 79,
      S: this,
      C: (f, a) => f(...a)
    });
    await safeAwaitAll2(this._servers.values(), (server) => server.open());
    log6.trace("dxos.mesh.websocket-signal-manager.open", trace8.end({
      id: this._instanceId
    }), {
      F: __dxlog_file6,
      L: 83,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  async _close() {
    await safeAwaitAll2(this._servers.values(), (server) => server.close());
  }
  async restartServer(serverName) {
    log6("restarting server", {
      serverName
    }, {
      F: __dxlog_file6,
      L: 91,
      S: this,
      C: (f, a) => f(...a)
    });
    invariant5(this._lifecycleState === LifecycleState.OPEN, void 0, {
      F: __dxlog_file6,
      L: 92,
      S: this,
      A: [
        "this._lifecycleState === LifecycleState.OPEN",
        ""
      ]
    });
    const server = this._servers.get(serverName);
    invariant5(server, "server not found", {
      F: __dxlog_file6,
      L: 95,
      S: this,
      A: [
        "server",
        "'server not found'"
      ]
    });
    await server.close();
    await sleep2(WSS_SIGNAL_SERVER_REBOOT_DELAY);
    await server.open();
  }
  getStatus() {
    return Array.from(this._servers.values()).map((server) => server.getStatus());
  }
  async join({ topic, peer }) {
    log6("join", {
      topic,
      peer
    }, {
      F: __dxlog_file6,
      L: 108,
      S: this,
      C: (f, a) => f(...a)
    });
    invariant5(this._lifecycleState === LifecycleState.OPEN, void 0, {
      F: __dxlog_file6,
      L: 109,
      S: this,
      A: [
        "this._lifecycleState === LifecycleState.OPEN",
        ""
      ]
    });
    await this._forEachServer((server) => server.join({
      topic,
      peer
    }));
  }
  async leave({ topic, peer }) {
    log6("leaving", {
      topic,
      peer
    }, {
      F: __dxlog_file6,
      L: 115,
      S: this,
      C: (f, a) => f(...a)
    });
    invariant5(this._lifecycleState === LifecycleState.OPEN, void 0, {
      F: __dxlog_file6,
      L: 116,
      S: this,
      A: [
        "this._lifecycleState === LifecycleState.OPEN",
        ""
      ]
    });
    await this._forEachServer((server) => server.leave({
      topic,
      peer
    }));
  }
  async query({ topic }) {
    throw new Error("Not implemented");
  }
  async sendMessage({ author, recipient, payload }) {
    log6("signal", {
      recipient
    }, {
      F: __dxlog_file6,
      L: 125,
      S: this,
      C: (f, a) => f(...a)
    });
    invariant5(this._lifecycleState === LifecycleState.OPEN, void 0, {
      F: __dxlog_file6,
      L: 126,
      S: this,
      A: [
        "this._lifecycleState === LifecycleState.OPEN",
        ""
      ]
    });
    void this._forEachServer(async (server, serverName, index) => {
      void server.sendMessage({
        author,
        recipient,
        payload
      }).then(() => this._clearServerFailedFlag(serverName, index)).catch((err) => {
        if (err instanceof RateLimitExceededError) {
          log6.info("WSS rate limit exceeded", {
            err
          }, {
            F: __dxlog_file6,
            L: 134,
            S: this,
            C: (f, a) => f(...a)
          });
          this._monitor.recordRateLimitExceeded();
        } else if (err instanceof TimeoutError3 || err.constructor.name === "TimeoutError") {
          log6.info("WSS sendMessage timeout", {
            err
          }, {
            F: __dxlog_file6,
            L: 137,
            S: this,
            C: (f, a) => f(...a)
          });
          void this.checkServerFailure(serverName, index);
        } else {
          log6.warn(`error sending to ${serverName}`, {
            err
          }, {
            F: __dxlog_file6,
            L: 140,
            S: this,
            C: (f, a) => f(...a)
          });
          void this.checkServerFailure(serverName, index);
        }
      });
    });
  }
  async checkServerFailure(serverName, index) {
    const failureCount = this.failureCount.get(serverName) ?? 0;
    const isRestartRequired = failureCount > MAX_SERVER_FAILURES;
    this._monitor.recordServerFailure({
      serverName,
      willRestart: isRestartRequired
    });
    if (isRestartRequired) {
      if (!BitField.get(this._failedServersBitfield, index)) {
        log6.warn("too many failures for ws-server, restarting", {
          serverName,
          failureCount
        }, {
          F: __dxlog_file6,
          L: 154,
          S: this,
          C: (f, a) => f(...a)
        });
        BitField.set(this._failedServersBitfield, index, true);
      }
      await this.restartServer(serverName);
      this.failureCount.set(serverName, 0);
      return;
    }
    this.failureCount.set(serverName, (this.failureCount.get(serverName) ?? 0) + 1);
  }
  _clearServerFailedFlag(serverName, index) {
    if (BitField.get(this._failedServersBitfield, index)) {
      log6.info("server connection restored", {
        serverName
      }, {
        F: __dxlog_file6,
        L: 167,
        S: this,
        C: (f, a) => f(...a)
      });
      BitField.set(this._failedServersBitfield, index, false);
      this.failureCount.set(serverName, 0);
    }
  }
  async subscribeMessages(peer) {
    log6("subscribed for message stream", {
      peer
    }, {
      F: __dxlog_file6,
      L: 174,
      S: this,
      C: (f, a) => f(...a)
    });
    invariant5(this._lifecycleState === LifecycleState.OPEN, void 0, {
      F: __dxlog_file6,
      L: 175,
      S: this,
      A: [
        "this._lifecycleState === LifecycleState.OPEN",
        ""
      ]
    });
    await this._forEachServer(async (server) => server.subscribeMessages(peer));
  }
  async unsubscribeMessages(peer) {
    log6("subscribed for message stream", {
      peer
    }, {
      F: __dxlog_file6,
      L: 181,
      S: this,
      C: (f, a) => f(...a)
    });
    invariant5(this._lifecycleState === LifecycleState.OPEN, void 0, {
      F: __dxlog_file6,
      L: 182,
      S: this,
      A: [
        "this._lifecycleState === LifecycleState.OPEN",
        ""
      ]
    });
    await this._forEachServer(async (server) => server.unsubscribeMessages(peer));
  }
  async _forEachServer(fn) {
    return Promise.all(Array.from(this._servers.entries()).map(([serverName, server], idx) => fn(server, serverName, idx)));
  }
};
_ts_decorate([
  synchronized
], WebsocketSignalManager.prototype, "join", null);
_ts_decorate([
  synchronized
], WebsocketSignalManager.prototype, "leave", null);
_ts_decorate([
  synchronized
], WebsocketSignalManager.prototype, "checkServerFailure", null);

// packages/core/mesh/messaging/src/signal-manager/edge-signal-manager.ts
import { Event as Event5, scheduleMicroTask } from "@dxos/async";
import { cancelWithContext as cancelWithContext3, Resource as Resource3 } from "@dxos/context";
import { protocol } from "@dxos/edge-client";
import { invariant as invariant6 } from "@dxos/invariant";
import { PublicKey as PublicKey7 } from "@dxos/keys";
import { log as log7 } from "@dxos/log";
import { EdgeService } from "@dxos/protocols";
import { bufWkt } from "@dxos/protocols/buf";
import { SwarmRequestSchema, SwarmRequest_Action as SwarmRequestAction, SwarmResponseSchema } from "@dxos/protocols/buf/dxos/edge/messenger_pb";
import { ComplexMap as ComplexMap4, ComplexSet as ComplexSet4 } from "@dxos/util";
var __dxlog_file7 = "/home/runner/work/dxos/dxos/packages/core/mesh/messaging/src/signal-manager/edge-signal-manager.ts";
var EdgeSignalManager = class extends Resource3 {
  constructor({ edgeConnection }) {
    super();
    /**
    * @deprecated
    */
    this.swarmEvent = new Event5();
    this.swarmState = new Event5();
    this.onMessage = new Event5();
    /**
    * Swarm key -> { peer: <own state payload>, joinedPeers: <state of swarm> }.
    */
    // TODO(mykola): This class should not contain swarm state joinedPeers. Temporary before network-manager API changes to accept list of peers.
    this._swarmPeers = new ComplexMap4(PublicKey7.hash);
    this._edgeConnection = edgeConnection;
  }
  async _open() {
    this._ctx.onDispose(this._edgeConnection.onMessage((message) => this._onMessage(message)));
    this._ctx.onDispose(this._edgeConnection.onReconnected(() => {
      scheduleMicroTask(this._ctx, () => this._rejoinAllSwarms());
    }));
  }
  /**
  * Warning: PeerInfo is inferred from edgeConnection.
  */
  async join({ topic, peer }) {
    if (!this._matchSelfPeerInfo(peer)) {
      log7.warn("ignoring peer info on join request", {
        peer,
        expected: {
          peerKey: this._edgeConnection.peerKey,
          identityKey: this._edgeConnection.identityKey
        }
      }, {
        F: __dxlog_file7,
        L: 65,
        S: this,
        C: (f, a) => f(...a)
      });
      peer.identityKey = this._edgeConnection.identityKey;
      peer.peerKey = this._edgeConnection.peerKey;
    }
    this._swarmPeers.set(topic, {
      lastState: peer.state,
      joinedPeers: new ComplexSet4(PeerInfoHash)
    });
    await this._edgeConnection.send(protocol.createMessage(SwarmRequestSchema, {
      serviceId: EdgeService.SWARM,
      source: createMessageSource(topic, peer),
      payload: {
        action: SwarmRequestAction.JOIN,
        swarmKeys: [
          topic.toHex()
        ]
      }
    }));
  }
  async leave({ topic, peer }) {
    this._swarmPeers.delete(topic);
    await this._edgeConnection.send(protocol.createMessage(SwarmRequestSchema, {
      serviceId: EdgeService.SWARM,
      source: createMessageSource(topic, peer),
      payload: {
        action: SwarmRequestAction.LEAVE,
        swarmKeys: [
          topic.toHex()
        ]
      }
    }));
  }
  async query({ topic }) {
    const response = cancelWithContext3(this._ctx, this.swarmState.waitFor((state) => state.swarmKey === topic.toHex()));
    await this._edgeConnection.send(protocol.createMessage(SwarmRequestSchema, {
      serviceId: EdgeService.SWARM,
      source: createMessageSource(topic, {
        peerKey: this._edgeConnection.peerKey,
        identityKey: this._edgeConnection.identityKey
      }),
      payload: {
        action: SwarmRequestAction.INFO,
        swarmKeys: [
          topic.toHex()
        ]
      }
    }));
    return response;
  }
  async sendMessage(message) {
    if (!this._matchSelfPeerInfo(message.author)) {
      log7.warn("ignoring author on send request", {
        author: message.author,
        expected: {
          peerKey: this._edgeConnection.peerKey,
          identityKey: this._edgeConnection.identityKey
        }
      }, {
        F: __dxlog_file7,
        L: 121,
        S: this,
        C: (f, a) => f(...a)
      });
    }
    await this._edgeConnection.send(protocol.createMessage(bufWkt.AnySchema, {
      serviceId: EdgeService.SIGNAL,
      source: message.author,
      target: [
        message.recipient
      ],
      payload: {
        typeUrl: message.payload.type_url,
        value: message.payload.value
      }
    }));
  }
  async subscribeMessages(peerInfo) {
  }
  async unsubscribeMessages(peerInfo) {
  }
  _onMessage(message) {
    switch (message.serviceId) {
      case EdgeService.SWARM: {
        this._processSwarmResponse(message);
        break;
      }
      case EdgeService.SIGNAL: {
        this._processMessage(message);
      }
    }
  }
  _processSwarmResponse(message) {
    invariant6(protocol.getPayloadType(message) === SwarmResponseSchema.typeName, "Wrong payload type", {
      F: __dxlog_file7,
      L: 158,
      S: this,
      A: [
        "protocol.getPayloadType(message) === SwarmResponseSchema.typeName",
        "'Wrong payload type'"
      ]
    });
    const payload = protocol.getPayload(message, SwarmResponseSchema);
    this.swarmState.emit(payload);
    const topic = PublicKey7.from(payload.swarmKey);
    if (!this._swarmPeers.has(topic)) {
      return;
    }
    const { joinedPeers: oldPeers } = this._swarmPeers.get(topic);
    const timestamp = message.timestamp ? new Date(Date.parse(message.timestamp)) : /* @__PURE__ */ new Date();
    const newPeers = new ComplexSet4(PeerInfoHash, payload.peers);
    for (const peer of newPeers) {
      if (oldPeers.has(peer)) {
        continue;
      }
      this.swarmEvent.emit({
        topic,
        peerAvailable: {
          peer,
          since: timestamp
        }
      });
    }
    for (const peer of oldPeers) {
      if (newPeers.has(peer)) {
        continue;
      }
      this.swarmEvent.emit({
        topic,
        peerLeft: {
          peer
        }
      });
    }
    this._swarmPeers.get(topic).joinedPeers = newPeers;
  }
  _processMessage(message) {
    invariant6(protocol.getPayloadType(message) === bufWkt.AnySchema.typeName, "Wrong payload type", {
      F: __dxlog_file7,
      L: 196,
      S: this,
      A: [
        "protocol.getPayloadType(message) === bufWkt.AnySchema.typeName",
        "'Wrong payload type'"
      ]
    });
    const payload = protocol.getPayload(message, bufWkt.AnySchema);
    invariant6(message.source, "source is missing", {
      F: __dxlog_file7,
      L: 198,
      S: this,
      A: [
        "message.source",
        "'source is missing'"
      ]
    });
    invariant6(message.target, "target is missing", {
      F: __dxlog_file7,
      L: 199,
      S: this,
      A: [
        "message.target",
        "'target is missing'"
      ]
    });
    invariant6(message.target.length === 1, "target should have exactly one item", {
      F: __dxlog_file7,
      L: 200,
      S: this,
      A: [
        "message.target.length === 1",
        "'target should have exactly one item'"
      ]
    });
    this.onMessage.emit({
      author: message.source,
      recipient: message.target[0],
      payload: {
        type_url: payload.typeUrl,
        value: payload.value
      }
    });
  }
  _matchSelfPeerInfo(peer) {
    return peer && (peer.peerKey === this._edgeConnection.peerKey || peer.identityKey === this._edgeConnection.identityKey);
  }
  async _rejoinAllSwarms() {
    log7("rejoin swarms", {
      swarms: Array.from(this._swarmPeers.keys())
    }, {
      F: __dxlog_file7,
      L: 219,
      S: this,
      C: (f, a) => f(...a)
    });
    for (const [topic, { lastState }] of this._swarmPeers.entries()) {
      await this.join({
        topic,
        peer: {
          peerKey: this._edgeConnection.peerKey,
          identityKey: this._edgeConnection.identityKey,
          state: lastState
        }
      });
    }
  }
};
var createMessageSource = (topic, peerInfo) => {
  return {
    swarmKey: topic.toHex(),
    ...peerInfo
  };
};

// packages/core/mesh/messaging/src/signal-manager/utils.ts
import { invariant as invariant7 } from "@dxos/invariant";
import { log as log8 } from "@dxos/log";
import { DeviceKind } from "@dxos/protocols/proto/dxos/client/services";
var __dxlog_file8 = "/home/runner/work/dxos/dxos/packages/core/mesh/messaging/src/signal-manager/utils.ts";
var setIdentityTags = ({ identityService, devicesService, setTag }) => {
  identityService.queryIdentity().subscribe((idqr) => {
    if (!idqr?.identity?.identityKey) {
      log8("empty response from identity service", {
        idqr
      }, {
        F: __dxlog_file8,
        L: 21,
        S: void 0,
        C: (f, a) => f(...a)
      });
      return;
    }
    setTag("identityKey", idqr.identity.identityKey.truncate());
  });
  devicesService.queryDevices().subscribe((dqr) => {
    if (!dqr || !dqr.devices || dqr.devices.length === 0) {
      log8("empty response from device service", {
        device: dqr
      }, {
        F: __dxlog_file8,
        L: 30,
        S: void 0,
        C: (f, a) => f(...a)
      });
      return;
    }
    invariant7(dqr, "empty response from device service", {
      F: __dxlog_file8,
      L: 33,
      S: void 0,
      A: [
        "dqr",
        "'empty response from device service'"
      ]
    });
    const thisDevice = dqr.devices.find((device) => device.kind === DeviceKind.CURRENT);
    if (!thisDevice) {
      log8("no current device", {
        device: dqr
      }, {
        F: __dxlog_file8,
        L: 37,
        S: void 0,
        C: (f, a) => f(...a)
      });
      return;
    }
    setTag("deviceKey", thisDevice.deviceKey.truncate());
  });
};

export {
  Messenger,
  SignalClient,
  PeerInfoHash,
  MemorySignalManagerContext,
  MemorySignalManager,
  WebsocketSignalManager,
  EdgeSignalManager,
  setIdentityTags
};
//# sourceMappingURL=chunk-ISA3S2ZX.mjs.map
