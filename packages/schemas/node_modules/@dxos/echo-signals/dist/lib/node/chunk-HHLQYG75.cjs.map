{
  "version": 3,
  "sources": ["../../../src/runtime/index.ts"],
  "sourcesContent": ["//\n// Copyright 2023 DXOS.org\n//\n\nexport interface GenericSignal {\n  /**\n   * Simulate a read operation on the signal.\n   * Subscribes the current computation to the signal.\n   */\n  notifyRead(): void;\n\n  /**\n   * Simulate a write operation on the signal.\n   * Notifies all subscribed computations about the change.\n   */\n  notifyWrite(): void;\n}\n\nexport interface SignalRuntime {\n  /**\n   * @param debugInfo - Optional string name or owner object of the signal. Used for debugging purposes.\n   */\n  createSignal(debugInfo?: unknown): GenericSignal;\n\n  /**\n   * All writes inside the callback will be batched and notified when the callback is finished.\n   */\n  batch(cb: () => void): void;\n\n  /**\n   * @deprecated Temporary measure to prevent ECHO from subscribing to signals within its internals.\n   */\n  untracked<T>(cb: () => T): T;\n}\n\nexport const runtimeList: SignalRuntime[] = [];\n\n/**\n * Self check to ensure registration is done before the first usage.\n */\nlet runtimeUsed = false;\n\n/**\n * Registeres a signal runtime (e.g., Preact Signals or SolidJS).\n * ECHO will hook into the runtime so that ECHO objects generate signal-like notifications on changes.\n * Registration is done at the module level (e.g., in the main module of the runtime).\n * Multiple runtimes can be registered at once.\n */\nexport const registerSignalsRuntime = (runtime: SignalRuntime) => {\n  if (runtimeUsed) {\n    // TODO(dmaretskyi): This is always taken because echo schema stuff creates typed objects when echo-schema package is imported.\n    // log.warn(\n    //   'Signal runtime registration is done after the first usage of the runtime. This may cause issues with reactivity.',\n    // );\n  }\n\n  runtimeList.push(runtime);\n};\n\nclass CompositeSignal implements GenericSignal {\n  constructor(\n    private readonly _signals: GenericSignal[],\n\n    public readonly debugInfo: unknown = undefined,\n  ) {}\n\n  notifyRead(): void {\n    for (const signal of this._signals) {\n      signal.notifyRead();\n    }\n  }\n\n  notifyWrite(): void {\n    for (const signal of this._signals) {\n      signal.notifyWrite();\n    }\n  }\n\n  toString(): string {\n    return 'CompositeSignal';\n  }\n}\n\nclass CompositeRuntime implements SignalRuntime {\n  batch(cb: () => void): void {\n    runtimeUsed = true;\n\n    const callBatchRecursively = (index: number): void => {\n      if (index >= runtimeList.length) {\n        return cb();\n      } else {\n        return runtimeList[index].batch(() => callBatchRecursively(index + 1));\n      }\n    };\n\n    return callBatchRecursively(0);\n  }\n\n  createSignal(debugInfo?: unknown): GenericSignal {\n    runtimeUsed = true;\n\n    return new CompositeSignal(\n      runtimeList.map((runtime) => runtime.createSignal(debugInfo)),\n      debugInfo,\n    );\n  }\n\n  untracked<T>(cb: () => T): T {\n    runtimeUsed = true;\n\n    const callUntrackedRecursively = (index: number): T => {\n      if (index >= runtimeList.length) {\n        return cb();\n      } else {\n        return runtimeList[index].untracked(() => callUntrackedRecursively(index + 1));\n      }\n    };\n\n    return callUntrackedRecursively(0);\n  }\n}\n\n/**\n * Runtime that represents a composite of all mutliple runtimes.\n * Signal notification would be broadcast to all runtimes individually.\n * Batches are executed in each runtime.\n */\nexport const compositeRuntime: SignalRuntime = new CompositeRuntime();\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;AAmCO,IAAMA,cAA+B,CAAA;AAK5C,IAAIC,cAAc;AAQX,IAAMC,yBAAyB,CAACC,YAAAA;AACrC,MAAIF,aAAa;EAKjB;AAEAD,cAAYI,KAAKD,OAAAA;AACnB;AAEA,IAAME,kBAAN,MAAMA;EACJ,YACmBC,UAEDC,YAAqBC,QACrC;SAHiBF,WAAAA;SAEDC,YAAAA;EACf;EAEHE,aAAmB;AACjB,eAAWC,UAAU,KAAKJ,UAAU;AAClCI,aAAOD,WAAU;IACnB;EACF;EAEAE,cAAoB;AAClB,eAAWD,UAAU,KAAKJ,UAAU;AAClCI,aAAOC,YAAW;IACpB;EACF;EAEAC,WAAmB;AACjB,WAAO;EACT;AACF;AAEA,IAAMC,mBAAN,MAAMA;EACJC,MAAMC,IAAsB;AAC1Bd,kBAAc;AAEd,UAAMe,uBAAuB,CAACC,UAAAA;AAC5B,UAAIA,SAASjB,YAAYkB,QAAQ;AAC/B,eAAOH,GAAAA;MACT,OAAO;AACL,eAAOf,YAAYiB,KAAAA,EAAOH,MAAM,MAAME,qBAAqBC,QAAQ,CAAA,CAAA;MACrE;IACF;AAEA,WAAOD,qBAAqB,CAAA;EAC9B;EAEAG,aAAaZ,WAAoC;AAC/CN,kBAAc;AAEd,WAAO,IAAII,gBACTL,YAAYoB,IAAI,CAACjB,YAAYA,QAAQgB,aAAaZ,SAAAA,CAAAA,GAClDA,SAAAA;EAEJ;EAEAc,UAAaN,IAAgB;AAC3Bd,kBAAc;AAEd,UAAMqB,2BAA2B,CAACL,UAAAA;AAChC,UAAIA,SAASjB,YAAYkB,QAAQ;AAC/B,eAAOH,GAAAA;MACT,OAAO;AACL,eAAOf,YAAYiB,KAAAA,EAAOI,UAAU,MAAMC,yBAAyBL,QAAQ,CAAA,CAAA;MAC7E;IACF;AAEA,WAAOK,yBAAyB,CAAA;EAClC;AACF;AAOO,IAAMC,mBAAkC,IAAIV,iBAAAA;",
  "names": ["runtimeList", "runtimeUsed", "registerSignalsRuntime", "runtime", "push", "CompositeSignal", "_signals", "debugInfo", "undefined", "notifyRead", "signal", "notifyWrite", "toString", "CompositeRuntime", "batch", "cb", "callBatchRecursively", "index", "length", "createSignal", "map", "untracked", "callUntrackedRecursively", "compositeRuntime"]
}
