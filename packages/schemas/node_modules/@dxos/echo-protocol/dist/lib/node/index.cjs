"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var node_exports = {};
__export(node_exports, {
  DATA_NAMESPACE: () => DATA_NAMESPACE,
  DatabaseDirectory: () => DatabaseDirectory,
  ForeignKey: () => ForeignKey,
  ObjectStructure: () => ObjectStructure,
  PROPERTY_ID: () => PROPERTY_ID,
  QueryAST: () => ast_exports,
  REFERENCE_TYPE_TAG: () => REFERENCE_TYPE_TAG,
  Reference: () => Reference,
  SpaceDocVersion: () => SpaceDocVersion,
  createIdFromSpaceKey: () => createIdFromSpaceKey,
  decodeReference: () => decodeReference,
  encodeReference: () => encodeReference,
  isEncodedReference: () => isEncodedReference
});
module.exports = __toCommonJS(node_exports);
var import_invariant = require("@dxos/invariant");
var import_util = require("@dxos/util");
var import_keys = require("@dxos/keys");
var import_crypto = require("@dxos/crypto");
var import_keys2 = require("@dxos/keys");
var import_util2 = require("@dxos/util");
var import_effect = require("effect");
var import_effect2 = require("effect");
var import_keys3 = require("@dxos/keys");
var __defProp2 = Object.defineProperty;
var __export2 = (target, all) => {
  for (var name in all)
    __defProp2(target, name, { get: all[name], enumerable: true });
};
var Reference = class _Reference {
  static {
    this.TYPE_PROTOCOL = "protobuf";
  }
  static fromDXN(dxn) {
    switch (dxn.kind) {
      case import_keys.DXN.kind.TYPE:
        return new _Reference(dxn.parts[0], _Reference.TYPE_PROTOCOL, "dxos.org", dxn);
      case import_keys.DXN.kind.ECHO:
        if (dxn.parts[0] === import_keys.LOCAL_SPACE_TAG) {
          return new _Reference(dxn.parts[1], void 0, void 0, dxn);
        } else {
          return new _Reference(dxn.parts[1], void 0, dxn.parts[0], dxn);
        }
      default:
        return new _Reference(dxn.parts[0], void 0, dxn.parts[0], dxn);
    }
  }
  static fromValue(value) {
    return new _Reference(value.objectId, value.protocol, value.host);
  }
  /**
  * Reference an object in the local space.
  */
  static localObjectReference(objectId) {
    return new _Reference(objectId);
  }
  /**
  * @deprecated
  */
  // TODO(dmaretskyi): Remove.
  static fromLegacyTypename(type) {
    return new _Reference(type, _Reference.TYPE_PROTOCOL, "dxos.org");
  }
  /**
  * @deprecated
  */
  // TODO(dmaretskyi): Remove
  static fromObjectIdAndSpaceKey(objectId, spaceKey) {
    return new _Reference(objectId, void 0, spaceKey.toHex());
  }
  // prettier-ignore
  constructor(_objectId, _protocol, _host, _dxn) {
    this._objectId = _objectId;
    this._protocol = _protocol;
    this._host = _host;
    this._dxn = _dxn;
  }
  get dxn() {
    return this._dxn;
  }
  /**
  * @deprecated
  */
  // TODO(dmaretskyi): Remove.
  get objectId() {
    return this._objectId;
  }
  /**
  * @deprecated
  */
  // TODO(dmaretskyi): Remove.
  get protocol() {
    return this._protocol;
  }
  /**
  * @deprecated
  */
  // TODO(dmaretskyi): Remove.
  get host() {
    return this._host;
  }
  encode() {
    return {
      objectId: this.objectId,
      host: this.host,
      protocol: this.protocol
    };
  }
  // TODO(dmaretskyi): Remove in favor of `reference.dxn`.
  toDXN() {
    if (this._dxn) {
      return this._dxn;
    }
    if (this.protocol === _Reference.TYPE_PROTOCOL) {
      return new import_keys.DXN(import_keys.DXN.kind.TYPE, [
        this.objectId
      ]);
    } else {
      if (this.host) {
        return new import_keys.DXN(import_keys.DXN.kind.ECHO, [
          this.host,
          this.objectId
        ]);
      } else {
        return new import_keys.DXN(import_keys.DXN.kind.ECHO, [
          import_keys.LOCAL_SPACE_TAG,
          this.objectId
        ]);
      }
    }
  }
};
var REFERENCE_TYPE_TAG = "dxos.echo.model.document.Reference";
var encodeReference = (reference) => ({
  "/": reference.toDXN().toString()
});
var decodeReference = (value) => {
  if (typeof value !== "object" || value === null || typeof value["/"] !== "string") {
    throw new Error("Invalid reference");
  }
  const dxnString = value["/"];
  if (dxnString.length % 2 === 0 && dxnString.slice(0, dxnString.length / 2) === dxnString.slice(dxnString.length / 2) && dxnString.includes("dxn:echo")) {
    throw new Error("Automerge bug detected!");
  }
  return Reference.fromDXN(import_keys.DXN.parse(dxnString));
};
var isEncodedReference = (value) => typeof value === "object" && value !== null && Object.keys(value).length === 1 && typeof value["/"] === "string";
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/core/echo/echo-protocol/src/document-structure.ts";
var DatabaseDirectory = Object.freeze({
  /**
  * @returns Space key in hex of the space that owns the document. In hex format. Without 0x prefix.
  */
  getSpaceKey: (doc) => {
    const rawSpaceKey = doc.access?.spaceKey ?? doc.experimental_spaceKey;
    if (rawSpaceKey == null) {
      return null;
    }
    const rawKey = String(rawSpaceKey);
    (0, import_invariant.invariant)(!rawKey.startsWith("0x"), "Space key must not start with 0x", {
      F: __dxlog_file,
      L: 66,
      S: void 0,
      A: [
        "!rawKey.startsWith('0x')",
        "'Space key must not start with 0x'"
      ]
    });
    return rawKey;
  },
  getInlineObject: (doc, id) => {
    return doc.objects?.[id];
  },
  getLink: (doc, id) => {
    return doc.links?.[id]?.toString();
  },
  make: ({ spaceKey, objects, links }) => ({
    access: {
      spaceKey
    },
    objects: objects ?? {},
    links: links ?? {}
  })
});
var ObjectStructure = Object.freeze({
  /**
  * @throws On invalid object structure.
  */
  getTypeReference: (object) => {
    return object.system?.type;
  },
  /**
  * @throws On invalid object structure.
  */
  getEntityKind: (object) => {
    const kind = object.system?.kind ?? "object";
    (0, import_invariant.invariant)(kind === "object" || kind === "relation", "Invalid kind", {
      F: __dxlog_file,
      L: 124,
      S: void 0,
      A: [
        "kind === 'object' || kind === 'relation'",
        "'Invalid kind'"
      ]
    });
    return kind;
  },
  isDeleted: (object) => {
    return object.system?.deleted ?? false;
  },
  getRelationSource: (object) => {
    return object.system?.source;
  },
  getRelationTarget: (object) => {
    return object.system?.target;
  },
  /**
  * @returns All references in the data section of the object.
  */
  getAllOutgoingReferences: (object) => {
    const references = [];
    const visit2 = (path, value) => {
      if (isEncodedReference(value)) {
        references.push({
          path,
          reference: value
        });
      } else {
        (0, import_util.visitValues)(value, (value2, key) => visit2([
          ...path,
          String(key)
        ], value2));
      }
    };
    (0, import_util.visitValues)(object.data, (value, key) => visit2([
      String(key)
    ], value));
    return references;
  },
  makeObject: ({ type, data, keys }) => {
    return {
      system: {
        kind: "object",
        type: {
          "/": type
        }
      },
      meta: {
        keys: keys ?? []
      },
      data: data ?? {}
    };
  },
  makeRelation: ({ type, source, target, deleted, keys, data }) => {
    return {
      system: {
        kind: "relation",
        type: {
          "/": type
        },
        source,
        target,
        deleted: deleted ?? false
      },
      meta: {
        keys: keys ?? []
      },
      data: data ?? {}
    };
  }
});
var PROPERTY_ID = "id";
var DATA_NAMESPACE = "data";
var SpaceDocVersion = Object.freeze({
  /**
  * For the documents created before the versioning was introduced.
  */
  LEGACY: 0,
  /**
  * Current version.
  */
  CURRENT: 1
});
var SPACE_IDS_CACHE = new import_util2.ComplexMap(import_keys2.PublicKey.hash);
var createIdFromSpaceKey = async (spaceKey) => {
  const cachedValue = SPACE_IDS_CACHE.get(spaceKey);
  if (cachedValue !== void 0) {
    return cachedValue;
  }
  const digest = await import_crypto.subtleCrypto.digest("SHA-256", spaceKey.asUint8Array());
  const bytes = new Uint8Array(digest).slice(0, import_keys2.SpaceId.byteLength);
  const spaceId = import_keys2.SpaceId.encode(bytes);
  SPACE_IDS_CACHE.set(spaceKey, spaceId);
  return spaceId;
};
var ForeignKey_ = import_effect.Schema.Struct({
  /**
  * Name of the foreign database/system.
  * E.g., `github.com`.
  */
  source: import_effect.Schema.String,
  /**
  * Id within the foreign database.
  */
  // TODO(wittjosiah): This annotation is currently used to ensure id field shows up in forms.
  // TODO(dmaretskyi): `false` is not a valid value for the annotation.
  id: import_effect.Schema.String.annotations({
    [import_effect.SchemaAST.IdentifierAnnotationId]: false
  })
});
var ForeignKey = ForeignKey_;
var ast_exports = {};
__export2(ast_exports, {
  Filter: () => Filter,
  FilterAnd: () => FilterAnd,
  FilterCompare: () => FilterCompare,
  FilterIn: () => FilterIn,
  FilterNot: () => FilterNot,
  FilterObject: () => FilterObject,
  FilterOr: () => FilterOr,
  FilterRange: () => FilterRange,
  FilterTextSearch: () => FilterTextSearch,
  Query: () => Query,
  QueryFilterClause: () => QueryFilterClause,
  QueryIncomingReferencesClause: () => QueryIncomingReferencesClause,
  QueryOptions: () => QueryOptions,
  QueryOptionsClause: () => QueryOptionsClause,
  QueryReferenceTraversalClause: () => QueryReferenceTraversalClause,
  QueryRelationClause: () => QueryRelationClause,
  QueryRelationTraversalClause: () => QueryRelationTraversalClause,
  QuerySelectClause: () => QuerySelectClause,
  QuerySetDifferenceClause: () => QuerySetDifferenceClause,
  QueryUnionClause: () => QueryUnionClause,
  visit: () => visit
});
var TypenameSpecifier = import_effect2.Schema.Union(import_keys3.DXN.Schema, import_effect2.Schema.Null).annotations({
  description: "DXN or null. Null means any type will match"
});
var FilterObject_ = import_effect2.Schema.Struct({
  type: import_effect2.Schema.Literal("object"),
  typename: TypenameSpecifier,
  id: import_effect2.Schema.optional(import_effect2.Schema.Array(import_keys3.ObjectId)),
  /**
  * Filter by property.
  * Must not include object ID.
  */
  props: import_effect2.Schema.Record({
    key: import_effect2.Schema.String.annotations({
      description: "Property name"
    }),
    value: import_effect2.Schema.suspend(() => Filter)
  }),
  /**
  * Objects that have any of the given foreign keys.
  */
  foreignKeys: import_effect2.Schema.optional(import_effect2.Schema.Array(ForeignKey))
});
var FilterObject = FilterObject_;
var FilterCompare_ = import_effect2.Schema.Struct({
  type: import_effect2.Schema.Literal("compare"),
  operator: import_effect2.Schema.Literal("eq", "neq", "gt", "gte", "lt", "lte"),
  value: import_effect2.Schema.Unknown
});
var FilterCompare = FilterCompare_;
var FilterIn_ = import_effect2.Schema.Struct({
  type: import_effect2.Schema.Literal("in"),
  values: import_effect2.Schema.Array(import_effect2.Schema.Any)
});
var FilterIn = FilterIn_;
var FilterRange_ = import_effect2.Schema.Struct({
  type: import_effect2.Schema.Literal("range"),
  from: import_effect2.Schema.Any,
  to: import_effect2.Schema.Any
});
var FilterRange = FilterRange_;
var FilterTextSearch_ = import_effect2.Schema.Struct({
  type: import_effect2.Schema.Literal("text-search"),
  text: import_effect2.Schema.String,
  searchKind: import_effect2.Schema.optional(import_effect2.Schema.Literal("full-text", "vector"))
});
var FilterTextSearch = FilterTextSearch_;
var FilterNot_ = import_effect2.Schema.Struct({
  type: import_effect2.Schema.Literal("not"),
  filter: import_effect2.Schema.suspend(() => Filter)
});
var FilterNot = FilterNot_;
var FilterAnd_ = import_effect2.Schema.Struct({
  type: import_effect2.Schema.Literal("and"),
  filters: import_effect2.Schema.Array(import_effect2.Schema.suspend(() => Filter))
});
var FilterAnd = FilterAnd_;
var FilterOr_ = import_effect2.Schema.Struct({
  type: import_effect2.Schema.Literal("or"),
  filters: import_effect2.Schema.Array(import_effect2.Schema.suspend(() => Filter))
});
var FilterOr = FilterOr_;
var Filter = import_effect2.Schema.Union(FilterObject, FilterTextSearch, FilterCompare, FilterIn, FilterRange, FilterNot, FilterAnd, FilterOr);
var QuerySelectClause_ = import_effect2.Schema.Struct({
  type: import_effect2.Schema.Literal("select"),
  filter: import_effect2.Schema.suspend(() => Filter)
});
var QuerySelectClause = QuerySelectClause_;
var QueryFilterClause_ = import_effect2.Schema.Struct({
  type: import_effect2.Schema.Literal("filter"),
  selection: import_effect2.Schema.suspend(() => Query),
  filter: import_effect2.Schema.suspend(() => Filter)
});
var QueryFilterClause = QueryFilterClause_;
var QueryReferenceTraversalClause_ = import_effect2.Schema.Struct({
  type: import_effect2.Schema.Literal("reference-traversal"),
  anchor: import_effect2.Schema.suspend(() => Query),
  property: import_effect2.Schema.String
});
var QueryReferenceTraversalClause = QueryReferenceTraversalClause_;
var QueryIncomingReferencesClause_ = import_effect2.Schema.Struct({
  type: import_effect2.Schema.Literal("incoming-references"),
  anchor: import_effect2.Schema.suspend(() => Query),
  property: import_effect2.Schema.String,
  typename: TypenameSpecifier
});
var QueryIncomingReferencesClause = QueryIncomingReferencesClause_;
var QueryRelationClause_ = import_effect2.Schema.Struct({
  type: import_effect2.Schema.Literal("relation"),
  anchor: import_effect2.Schema.suspend(() => Query),
  /**
  * outgoing: anchor is the source of the relation.
  * incoming: anchor is the target of the relation.
  * both: anchor is either the source or target of the relation.
  */
  direction: import_effect2.Schema.Literal("outgoing", "incoming", "both"),
  filter: import_effect2.Schema.optional(import_effect2.Schema.suspend(() => Filter))
});
var QueryRelationClause = QueryRelationClause_;
var QueryRelationTraversalClause_ = import_effect2.Schema.Struct({
  type: import_effect2.Schema.Literal("relation-traversal"),
  anchor: import_effect2.Schema.suspend(() => Query),
  direction: import_effect2.Schema.Literal("source", "target", "both")
});
var QueryRelationTraversalClause = QueryRelationTraversalClause_;
var QueryUnionClause_ = import_effect2.Schema.Struct({
  type: import_effect2.Schema.Literal("union"),
  queries: import_effect2.Schema.Array(import_effect2.Schema.suspend(() => Query))
});
var QueryUnionClause = QueryUnionClause_;
var QuerySetDifferenceClause_ = import_effect2.Schema.Struct({
  type: import_effect2.Schema.Literal("set-difference"),
  source: import_effect2.Schema.suspend(() => Query),
  exclude: import_effect2.Schema.suspend(() => Query)
});
var QuerySetDifferenceClause = QuerySetDifferenceClause_;
var QueryOptionsClause_ = import_effect2.Schema.Struct({
  type: import_effect2.Schema.Literal("options"),
  query: import_effect2.Schema.suspend(() => Query),
  options: import_effect2.Schema.suspend(() => QueryOptions)
});
var QueryOptionsClause = QueryOptionsClause_;
var Query_ = import_effect2.Schema.Union(QuerySelectClause, QueryFilterClause, QueryReferenceTraversalClause, QueryIncomingReferencesClause, QueryRelationClause, QueryRelationTraversalClause, QueryUnionClause, QuerySetDifferenceClause, QueryOptionsClause);
var Query = Query_;
var QueryOptions = import_effect2.Schema.Struct({
  spaceIds: import_effect2.Schema.optional(import_effect2.Schema.Array(import_effect2.Schema.String)),
  deleted: import_effect2.Schema.optional(import_effect2.Schema.Literal("include", "exclude", "only"))
});
var visit = (query, visitor) => {
  switch (query.type) {
    case "filter":
      visit(query.selection, visitor);
      break;
    case "reference-traversal":
      visit(query.anchor, visitor);
      break;
    case "incoming-references":
      visit(query.anchor, visitor);
      break;
    case "relation":
      visit(query.anchor, visitor);
      break;
    case "options":
      visit(query.query, visitor);
      break;
    case "relation-traversal":
      visit(query.anchor, visitor);
      break;
    case "union":
      query.queries.forEach((q) => visit(q, visitor));
      break;
    case "set-difference":
      visit(query.source, visitor);
      visit(query.exclude, visitor);
      break;
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  DATA_NAMESPACE,
  DatabaseDirectory,
  ForeignKey,
  ObjectStructure,
  PROPERTY_ID,
  QueryAST,
  REFERENCE_TYPE_TAG,
  Reference,
  SpaceDocVersion,
  createIdFromSpaceKey,
  decodeReference,
  encodeReference,
  isEncodedReference
});
//# sourceMappingURL=index.cjs.map
