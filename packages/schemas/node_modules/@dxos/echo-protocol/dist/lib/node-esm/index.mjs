import { createRequire } from 'node:module';const require = createRequire(import.meta.url);
var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// packages/core/echo/echo-protocol/src/document-structure.ts
import { invariant } from "@dxos/invariant";
import { visitValues } from "@dxos/util";

// packages/core/echo/echo-protocol/src/reference.ts
import { DXN, LOCAL_SPACE_TAG } from "@dxos/keys";
var Reference = class _Reference {
  static {
    /**
    * Protocol references to runtime registered types.
    * @deprecated
    */
    this.TYPE_PROTOCOL = "protobuf";
  }
  static fromDXN(dxn) {
    switch (dxn.kind) {
      case DXN.kind.TYPE:
        return new _Reference(dxn.parts[0], _Reference.TYPE_PROTOCOL, "dxos.org", dxn);
      case DXN.kind.ECHO:
        if (dxn.parts[0] === LOCAL_SPACE_TAG) {
          return new _Reference(dxn.parts[1], void 0, void 0, dxn);
        } else {
          return new _Reference(dxn.parts[1], void 0, dxn.parts[0], dxn);
        }
      default:
        return new _Reference(dxn.parts[0], void 0, dxn.parts[0], dxn);
    }
  }
  static fromValue(value) {
    return new _Reference(value.objectId, value.protocol, value.host);
  }
  /**
  * Reference an object in the local space.
  */
  static localObjectReference(objectId) {
    return new _Reference(objectId);
  }
  /**
  * @deprecated
  */
  // TODO(dmaretskyi): Remove.
  static fromLegacyTypename(type) {
    return new _Reference(type, _Reference.TYPE_PROTOCOL, "dxos.org");
  }
  /**
  * @deprecated
  */
  // TODO(dmaretskyi): Remove
  static fromObjectIdAndSpaceKey(objectId, spaceKey) {
    return new _Reference(objectId, void 0, spaceKey.toHex());
  }
  // prettier-ignore
  constructor(_objectId, _protocol, _host, _dxn) {
    this._objectId = _objectId;
    this._protocol = _protocol;
    this._host = _host;
    this._dxn = _dxn;
  }
  get dxn() {
    return this._dxn;
  }
  /**
  * @deprecated
  */
  // TODO(dmaretskyi): Remove.
  get objectId() {
    return this._objectId;
  }
  /**
  * @deprecated
  */
  // TODO(dmaretskyi): Remove.
  get protocol() {
    return this._protocol;
  }
  /**
  * @deprecated
  */
  // TODO(dmaretskyi): Remove.
  get host() {
    return this._host;
  }
  encode() {
    return {
      objectId: this.objectId,
      host: this.host,
      protocol: this.protocol
    };
  }
  // TODO(dmaretskyi): Remove in favor of `reference.dxn`.
  toDXN() {
    if (this._dxn) {
      return this._dxn;
    }
    if (this.protocol === _Reference.TYPE_PROTOCOL) {
      return new DXN(DXN.kind.TYPE, [
        this.objectId
      ]);
    } else {
      if (this.host) {
        return new DXN(DXN.kind.ECHO, [
          this.host,
          this.objectId
        ]);
      } else {
        return new DXN(DXN.kind.ECHO, [
          LOCAL_SPACE_TAG,
          this.objectId
        ]);
      }
    }
  }
};
var REFERENCE_TYPE_TAG = "dxos.echo.model.document.Reference";
var encodeReference = (reference) => ({
  "/": reference.toDXN().toString()
});
var decodeReference = (value) => {
  if (typeof value !== "object" || value === null || typeof value["/"] !== "string") {
    throw new Error("Invalid reference");
  }
  const dxnString = value["/"];
  if (dxnString.length % 2 === 0 && dxnString.slice(0, dxnString.length / 2) === dxnString.slice(dxnString.length / 2) && dxnString.includes("dxn:echo")) {
    throw new Error("Automerge bug detected!");
  }
  return Reference.fromDXN(DXN.parse(dxnString));
};
var isEncodedReference = (value) => typeof value === "object" && value !== null && Object.keys(value).length === 1 && typeof value["/"] === "string";

// packages/core/echo/echo-protocol/src/document-structure.ts
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/core/echo/echo-protocol/src/document-structure.ts";
var DatabaseDirectory = Object.freeze({
  /**
  * @returns Space key in hex of the space that owns the document. In hex format. Without 0x prefix.
  */
  getSpaceKey: (doc) => {
    const rawSpaceKey = doc.access?.spaceKey ?? doc.experimental_spaceKey;
    if (rawSpaceKey == null) {
      return null;
    }
    const rawKey = String(rawSpaceKey);
    invariant(!rawKey.startsWith("0x"), "Space key must not start with 0x", {
      F: __dxlog_file,
      L: 66,
      S: void 0,
      A: [
        "!rawKey.startsWith('0x')",
        "'Space key must not start with 0x'"
      ]
    });
    return rawKey;
  },
  getInlineObject: (doc, id) => {
    return doc.objects?.[id];
  },
  getLink: (doc, id) => {
    return doc.links?.[id]?.toString();
  },
  make: ({ spaceKey, objects, links }) => ({
    access: {
      spaceKey
    },
    objects: objects ?? {},
    links: links ?? {}
  })
});
var ObjectStructure = Object.freeze({
  /**
  * @throws On invalid object structure.
  */
  getTypeReference: (object) => {
    return object.system?.type;
  },
  /**
  * @throws On invalid object structure.
  */
  getEntityKind: (object) => {
    const kind = object.system?.kind ?? "object";
    invariant(kind === "object" || kind === "relation", "Invalid kind", {
      F: __dxlog_file,
      L: 124,
      S: void 0,
      A: [
        "kind === 'object' || kind === 'relation'",
        "'Invalid kind'"
      ]
    });
    return kind;
  },
  isDeleted: (object) => {
    return object.system?.deleted ?? false;
  },
  getRelationSource: (object) => {
    return object.system?.source;
  },
  getRelationTarget: (object) => {
    return object.system?.target;
  },
  /**
  * @returns All references in the data section of the object.
  */
  getAllOutgoingReferences: (object) => {
    const references = [];
    const visit2 = (path, value) => {
      if (isEncodedReference(value)) {
        references.push({
          path,
          reference: value
        });
      } else {
        visitValues(value, (value2, key) => visit2([
          ...path,
          String(key)
        ], value2));
      }
    };
    visitValues(object.data, (value, key) => visit2([
      String(key)
    ], value));
    return references;
  },
  makeObject: ({ type, data, keys }) => {
    return {
      system: {
        kind: "object",
        type: {
          "/": type
        }
      },
      meta: {
        keys: keys ?? []
      },
      data: data ?? {}
    };
  },
  makeRelation: ({ type, source, target, deleted, keys, data }) => {
    return {
      system: {
        kind: "relation",
        type: {
          "/": type
        },
        source,
        target,
        deleted: deleted ?? false
      },
      meta: {
        keys: keys ?? []
      },
      data: data ?? {}
    };
  }
});
var PROPERTY_ID = "id";
var DATA_NAMESPACE = "data";

// packages/core/echo/echo-protocol/src/space-doc-version.ts
var SpaceDocVersion = Object.freeze({
  /**
  * For the documents created before the versioning was introduced.
  */
  LEGACY: 0,
  /**
  * Current version.
  */
  CURRENT: 1
});

// packages/core/echo/echo-protocol/src/space-id.ts
import { subtleCrypto } from "@dxos/crypto";
import { PublicKey, SpaceId } from "@dxos/keys";
import { ComplexMap } from "@dxos/util";
var SPACE_IDS_CACHE = new ComplexMap(PublicKey.hash);
var createIdFromSpaceKey = async (spaceKey) => {
  const cachedValue = SPACE_IDS_CACHE.get(spaceKey);
  if (cachedValue !== void 0) {
    return cachedValue;
  }
  const digest = await subtleCrypto.digest("SHA-256", spaceKey.asUint8Array());
  const bytes = new Uint8Array(digest).slice(0, SpaceId.byteLength);
  const spaceId = SpaceId.encode(bytes);
  SPACE_IDS_CACHE.set(spaceKey, spaceId);
  return spaceId;
};

// packages/core/echo/echo-protocol/src/foreign-key.ts
import { Schema, SchemaAST } from "effect";
var ForeignKey_ = Schema.Struct({
  /**
  * Name of the foreign database/system.
  * E.g., `github.com`.
  */
  source: Schema.String,
  /**
  * Id within the foreign database.
  */
  // TODO(wittjosiah): This annotation is currently used to ensure id field shows up in forms.
  // TODO(dmaretskyi): `false` is not a valid value for the annotation.
  id: Schema.String.annotations({
    [SchemaAST.IdentifierAnnotationId]: false
  })
});
var ForeignKey = ForeignKey_;

// packages/core/echo/echo-protocol/src/query/ast.ts
var ast_exports = {};
__export(ast_exports, {
  Filter: () => Filter,
  FilterAnd: () => FilterAnd,
  FilterCompare: () => FilterCompare,
  FilterIn: () => FilterIn,
  FilterNot: () => FilterNot,
  FilterObject: () => FilterObject,
  FilterOr: () => FilterOr,
  FilterRange: () => FilterRange,
  FilterTextSearch: () => FilterTextSearch,
  Query: () => Query,
  QueryFilterClause: () => QueryFilterClause,
  QueryIncomingReferencesClause: () => QueryIncomingReferencesClause,
  QueryOptions: () => QueryOptions,
  QueryOptionsClause: () => QueryOptionsClause,
  QueryReferenceTraversalClause: () => QueryReferenceTraversalClause,
  QueryRelationClause: () => QueryRelationClause,
  QueryRelationTraversalClause: () => QueryRelationTraversalClause,
  QuerySelectClause: () => QuerySelectClause,
  QuerySetDifferenceClause: () => QuerySetDifferenceClause,
  QueryUnionClause: () => QueryUnionClause,
  visit: () => visit
});
import { Schema as Schema2 } from "effect";
import { DXN as DXN2, ObjectId } from "@dxos/keys";
var TypenameSpecifier = Schema2.Union(DXN2.Schema, Schema2.Null).annotations({
  description: "DXN or null. Null means any type will match"
});
var FilterObject_ = Schema2.Struct({
  type: Schema2.Literal("object"),
  typename: TypenameSpecifier,
  id: Schema2.optional(Schema2.Array(ObjectId)),
  /**
  * Filter by property.
  * Must not include object ID.
  */
  props: Schema2.Record({
    key: Schema2.String.annotations({
      description: "Property name"
    }),
    value: Schema2.suspend(() => Filter)
  }),
  /**
  * Objects that have any of the given foreign keys.
  */
  foreignKeys: Schema2.optional(Schema2.Array(ForeignKey))
});
var FilterObject = FilterObject_;
var FilterCompare_ = Schema2.Struct({
  type: Schema2.Literal("compare"),
  operator: Schema2.Literal("eq", "neq", "gt", "gte", "lt", "lte"),
  value: Schema2.Unknown
});
var FilterCompare = FilterCompare_;
var FilterIn_ = Schema2.Struct({
  type: Schema2.Literal("in"),
  values: Schema2.Array(Schema2.Any)
});
var FilterIn = FilterIn_;
var FilterRange_ = Schema2.Struct({
  type: Schema2.Literal("range"),
  from: Schema2.Any,
  to: Schema2.Any
});
var FilterRange = FilterRange_;
var FilterTextSearch_ = Schema2.Struct({
  type: Schema2.Literal("text-search"),
  text: Schema2.String,
  searchKind: Schema2.optional(Schema2.Literal("full-text", "vector"))
});
var FilterTextSearch = FilterTextSearch_;
var FilterNot_ = Schema2.Struct({
  type: Schema2.Literal("not"),
  filter: Schema2.suspend(() => Filter)
});
var FilterNot = FilterNot_;
var FilterAnd_ = Schema2.Struct({
  type: Schema2.Literal("and"),
  filters: Schema2.Array(Schema2.suspend(() => Filter))
});
var FilterAnd = FilterAnd_;
var FilterOr_ = Schema2.Struct({
  type: Schema2.Literal("or"),
  filters: Schema2.Array(Schema2.suspend(() => Filter))
});
var FilterOr = FilterOr_;
var Filter = Schema2.Union(FilterObject, FilterTextSearch, FilterCompare, FilterIn, FilterRange, FilterNot, FilterAnd, FilterOr);
var QuerySelectClause_ = Schema2.Struct({
  type: Schema2.Literal("select"),
  filter: Schema2.suspend(() => Filter)
});
var QuerySelectClause = QuerySelectClause_;
var QueryFilterClause_ = Schema2.Struct({
  type: Schema2.Literal("filter"),
  selection: Schema2.suspend(() => Query),
  filter: Schema2.suspend(() => Filter)
});
var QueryFilterClause = QueryFilterClause_;
var QueryReferenceTraversalClause_ = Schema2.Struct({
  type: Schema2.Literal("reference-traversal"),
  anchor: Schema2.suspend(() => Query),
  property: Schema2.String
});
var QueryReferenceTraversalClause = QueryReferenceTraversalClause_;
var QueryIncomingReferencesClause_ = Schema2.Struct({
  type: Schema2.Literal("incoming-references"),
  anchor: Schema2.suspend(() => Query),
  property: Schema2.String,
  typename: TypenameSpecifier
});
var QueryIncomingReferencesClause = QueryIncomingReferencesClause_;
var QueryRelationClause_ = Schema2.Struct({
  type: Schema2.Literal("relation"),
  anchor: Schema2.suspend(() => Query),
  /**
  * outgoing: anchor is the source of the relation.
  * incoming: anchor is the target of the relation.
  * both: anchor is either the source or target of the relation.
  */
  direction: Schema2.Literal("outgoing", "incoming", "both"),
  filter: Schema2.optional(Schema2.suspend(() => Filter))
});
var QueryRelationClause = QueryRelationClause_;
var QueryRelationTraversalClause_ = Schema2.Struct({
  type: Schema2.Literal("relation-traversal"),
  anchor: Schema2.suspend(() => Query),
  direction: Schema2.Literal("source", "target", "both")
});
var QueryRelationTraversalClause = QueryRelationTraversalClause_;
var QueryUnionClause_ = Schema2.Struct({
  type: Schema2.Literal("union"),
  queries: Schema2.Array(Schema2.suspend(() => Query))
});
var QueryUnionClause = QueryUnionClause_;
var QuerySetDifferenceClause_ = Schema2.Struct({
  type: Schema2.Literal("set-difference"),
  source: Schema2.suspend(() => Query),
  exclude: Schema2.suspend(() => Query)
});
var QuerySetDifferenceClause = QuerySetDifferenceClause_;
var QueryOptionsClause_ = Schema2.Struct({
  type: Schema2.Literal("options"),
  query: Schema2.suspend(() => Query),
  options: Schema2.suspend(() => QueryOptions)
});
var QueryOptionsClause = QueryOptionsClause_;
var Query_ = Schema2.Union(QuerySelectClause, QueryFilterClause, QueryReferenceTraversalClause, QueryIncomingReferencesClause, QueryRelationClause, QueryRelationTraversalClause, QueryUnionClause, QuerySetDifferenceClause, QueryOptionsClause);
var Query = Query_;
var QueryOptions = Schema2.Struct({
  spaceIds: Schema2.optional(Schema2.Array(Schema2.String)),
  deleted: Schema2.optional(Schema2.Literal("include", "exclude", "only"))
});
var visit = (query, visitor) => {
  switch (query.type) {
    case "filter":
      visit(query.selection, visitor);
      break;
    case "reference-traversal":
      visit(query.anchor, visitor);
      break;
    case "incoming-references":
      visit(query.anchor, visitor);
      break;
    case "relation":
      visit(query.anchor, visitor);
      break;
    case "options":
      visit(query.query, visitor);
      break;
    case "relation-traversal":
      visit(query.anchor, visitor);
      break;
    case "union":
      query.queries.forEach((q) => visit(q, visitor));
      break;
    case "set-difference":
      visit(query.source, visitor);
      visit(query.exclude, visitor);
      break;
  }
};
export {
  DATA_NAMESPACE,
  DatabaseDirectory,
  ForeignKey,
  ObjectStructure,
  PROPERTY_ID,
  ast_exports as QueryAST,
  REFERENCE_TYPE_TAG,
  Reference,
  SpaceDocVersion,
  createIdFromSpaceKey,
  decodeReference,
  encodeReference,
  isEncodedReference
};
//# sourceMappingURL=index.mjs.map
