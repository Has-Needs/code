import { createRequire } from 'node:module';const require = createRequire(import.meta.url);

// packages/common/random-access-storage/src/common/abstract-storage.ts
import { join as join2 } from "node:path";
import { inspect } from "node:util";
import { inspectObject } from "@dxos/debug";
import { log as log2 } from "@dxos/log";

// packages/common/random-access-storage/src/common/utils.ts
import { join } from "node:path";
var stringDiff = (first, second) => first.split(second).join("");
var getFullPath = (root, path) => join(root, stringDiff(path, root));

// packages/common/random-access-storage/src/common/directory.ts
var Directory = class _Directory {
  constructor({ type, path, list, getOrCreateFile, remove, onFlush }) {
    this.type = type;
    this.path = path;
    this._list = list;
    this._getOrCreateFile = getOrCreateFile;
    this._remove = remove;
    this._onFlush = onFlush;
  }
  toString() {
    return `Directory(${JSON.stringify({
      type: this.type,
      path: this.path
    })})`;
  }
  /**
  * Create a new sub-directory.
  */
  createDirectory(path) {
    return new _Directory({
      type: this.type,
      path: getFullPath(this.path, path),
      list: this._list,
      getOrCreateFile: this._getOrCreateFile,
      remove: this._remove
    });
  }
  /**
  * Get all files in the current directory.
  */
  list() {
    return this._list(this.path);
  }
  /**
  * Get or create a new file.
  */
  getOrCreateFile(filename, opts) {
    return this._getOrCreateFile(this.path, filename, opts);
  }
  async flush() {
    await this._onFlush?.();
  }
  /**
  * Close and delete all files in the directory and all its sub-directories.
  */
  async delete() {
    await this._remove();
  }
};

// packages/common/random-access-storage/src/common/file.ts
import pify from "pify";
import { log } from "@dxos/log";
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/common/random-access-storage/src/common/file.ts";
var MAX_STORAGE_OPERATION_TIME = 50;
var pifyFields = (object, type, fields) => {
  for (const field of fields) {
    if (!object[field]) {
    } else {
      const fn = pify(object[field].bind(object));
      object[field] = async (...args) => {
        const before = performance.now();
        const res = await fn(...args);
        const elapsed = performance.now() - before;
        if (elapsed > MAX_STORAGE_OPERATION_TIME) {
          log("Slow storage operation", {
            type,
            operation: field,
            elapsed
          }, {
            F: __dxlog_file,
            L: 62,
            S: void 0,
            C: (f, a) => f(...a)
          });
        }
        return res;
      };
    }
  }
  return object;
};
var wrapFile = (native, type) => {
  const file = pifyFields(native, type, [
    "write",
    "read",
    "del",
    "stat",
    "close",
    "destroy",
    "truncate"
  ]);
  return Object.assign(file, {
    type,
    native
  });
};

// packages/common/random-access-storage/src/common/abstract-storage.ts
var __dxlog_file2 = "/home/runner/work/dxos/dxos/packages/common/random-access-storage/src/common/abstract-storage.ts";
var AbstractStorage = class {
  // TODO(burdon): Make required.
  constructor(path) {
    this.path = path;
    this._files = /* @__PURE__ */ new Map();
  }
  [inspect.custom]() {
    return inspectObject(this);
  }
  toJSON() {
    return {
      type: this.type,
      path: this.path
    };
  }
  get size() {
    return this._files.size;
  }
  // TODO(burdon): Make required.
  createDirectory(sub = "") {
    return new Directory({
      type: this.type,
      path: getFullPath(this.path, sub),
      list: this._list.bind(this),
      getOrCreateFile: (...args) => this.getOrCreateFile(...args),
      remove: () => this._remove(sub)
    });
  }
  /**
  * Delete all files.
  */
  async reset() {
    try {
      log2.info("Erasing all data...", void 0, {
        F: __dxlog_file2,
        L: 60,
        S: this,
        C: (f, a) => f(...a)
      });
      await this._closeFilesInPath("");
      await this._remove("");
      await this._destroy();
      log2("Erased...", void 0, {
        F: __dxlog_file2,
        L: 64,
        S: this,
        C: (f, a) => f(...a)
      });
    } catch (err) {
      log2.catch(err, void 0, {
        F: __dxlog_file2,
        L: 66,
        S: this,
        C: (f, a) => f(...a)
      });
    }
  }
  async _list(path) {
    return Array.from((await this._getFiles(path)).keys()).map((filename) => {
      let name = filename.replace(path, "");
      if (name.startsWith("/")) {
        name = name.substring(1);
      }
      return name;
    });
  }
  getOrCreateFile(path, filename, opts) {
    const fullPath = join2(path, filename);
    let native;
    let file = this._getFileIfExists(fullPath);
    if (file) {
      if (!file.closed) {
        return file;
      }
      native = this._openFile(file.native);
    }
    if (!native) {
      native = this._createFile(path, filename, opts);
    }
    file = wrapFile(native, this.type);
    this._files.set(fullPath, file);
    return file;
  }
  _destroy() {
    return void 0;
  }
  /**
  * Attempt to reopen file.
  */
  _openFile(file) {
    return void 0;
  }
  _getFileIfExists(filename) {
    if (this._files.has(filename)) {
      const file = this._files.get(filename);
      if (file && !file.destroyed) {
        return file;
      }
    }
  }
  async _getFiles(path) {
    const fullPath = getFullPath(this.path, path);
    return new Map([
      ...this._files.entries()
    ].filter(([path2, file]) => path2.includes(fullPath) && file.destroyed !== true));
  }
  async _closeFilesInPath(path) {
    await Promise.all(Array.from((await this._getFiles(path)).values()).map((file) => file.close().catch((err) => log2.catch(err, void 0, {
      F: __dxlog_file2,
      L: 134,
      S: this,
      C: (f, a) => f(...a)
    }))));
  }
  async close() {
    await this._closeFilesInPath("");
  }
  // TODO(burdon): Delete directory (not just listed files).
  async _remove(path) {
    await Promise.all(Array.from(await this._getFiles(path)).map(([path2, file]) => {
      return file.destroy().then(() => this._files.delete(path2)).catch((err) => log2.error(err.message, void 0, {
        F: __dxlog_file2,
        L: 149,
        S: this,
        C: (f, a) => f(...a)
      }));
    }));
  }
};

// packages/common/random-access-storage/src/common/memory-storage.ts
import ram from "random-access-memory";
import { arrayToBuffer } from "@dxos/util";

// packages/common/random-access-storage/src/common/storage.ts
var StorageType = /* @__PURE__ */ function(StorageType2) {
  StorageType2["RAM"] = "ram";
  StorageType2["IDB"] = "idb";
  StorageType2["CHROME"] = "chrome";
  StorageType2["FIREFOX"] = "firefox";
  StorageType2["NODE"] = "node";
  StorageType2["WEBFS"] = "webfs";
  return StorageType2;
}({});

// packages/common/random-access-storage/src/common/memory-storage.ts
var MemoryStorage = class extends AbstractStorage {
  constructor() {
    super(...arguments);
    this.type = StorageType.RAM;
  }
  _createFile(path, filename) {
    return this._patchFile(ram());
  }
  _openFile(file) {
    const newFile = file.clone();
    newFile.closed = false;
    return this._patchFile(newFile);
  }
  _patchFile(file) {
    const trueRead = file.read.bind(file);
    file.read = (offset, size, cb) => trueRead(offset, size, (err, data) => {
      if (err) {
        return cb(err);
      } else {
        return cb(err, arrayToBuffer(data));
      }
    });
    return file;
  }
  async getDiskInfo() {
    let used = 0;
    for (const file of this._files.values()) {
      const size = file.length;
      used += Number.isNaN(size) ? 0 : size;
    }
    return {
      used
    };
  }
};

// packages/common/random-access-storage/src/node/node-storage.ts
import del from "del";
import { existsSync } from "node:fs";
import { readdir, stat } from "node:fs/promises";
import { join as join3 } from "node:path";
import raf from "random-access-file";
var NodeStorage = class extends AbstractStorage {
  constructor() {
    super(...arguments);
    this.type = StorageType.NODE;
    this._initialized = false;
  }
  async _loadFiles(path) {
    if (!existsSync(path)) {
      return;
    }
    const dir = await readdir(path);
    for (const entry of dir) {
      const fullPath = join3(path, entry);
      if (this._files.has(fullPath)) {
        continue;
      }
      const entryInfo = await stat(fullPath);
      if (entryInfo.isDirectory()) {
        await this._loadFiles(fullPath);
      } else if (entryInfo.isFile()) {
        const file = this._createFile(path, entry);
        this._files.set(fullPath, wrapFile(file, this.type));
      }
    }
  }
  _createFile(path, filename, opts = {}) {
    const file = raf(filename, {
      directory: path,
      ...opts
    });
    file.write(0, Buffer.from(""));
    return file;
  }
  async _destroy() {
    await del(this.path, {
      force: true
    });
  }
  async _getFiles(path) {
    if (!this._initialized) {
      await this._loadFiles(this.path);
      this._initialized = true;
    }
    return super._getFiles(path);
  }
  async getDiskInfo() {
    let used = 0;
    const recurse = async (path) => {
      const pathStats = await stat(path);
      if (pathStats.isDirectory()) {
        const entries = await readdir(path);
        await Promise.all(entries.map((entry) => recurse(join3(path, entry))));
      } else {
        used += pathStats.size;
      }
    };
    await recurse(this.path);
    return {
      used
    };
  }
};

// packages/common/random-access-storage/src/node/storage.ts
var createStorage = ({ type, root = "/tmp/dxos/testing" } = {}) => {
  if (type === void 0) {
    return new NodeStorage(root);
  }
  switch (type) {
    case StorageType.RAM: {
      return new MemoryStorage(root);
    }
    case StorageType.NODE: {
      return new NodeStorage(root);
    }
    default: {
      throw new Error(`Invalid type: ${type}`);
    }
  }
};
export {
  AbstractStorage,
  Directory,
  MemoryStorage,
  StorageType,
  createStorage,
  getFullPath,
  stringDiff,
  wrapFile
};
//# sourceMappingURL=index.mjs.map
