{
  "version": 3,
  "sources": ["../../../src/common/abstract-storage.ts", "../../../src/common/utils.ts", "../../../src/common/directory.ts", "../../../src/common/file.ts", "../../../src/common/memory-storage.ts", "../../../src/common/storage.ts", "../../../src/node/node-storage.ts", "../../../src/node/storage.ts"],
  "sourcesContent": ["//\n// Copyright 2021 DXOS.org\n//\n\nimport { join } from 'node:path';\nimport { inspect } from 'node:util';\nimport type { RandomAccessStorage } from 'random-access-storage';\n\nimport { inspectObject } from '@dxos/debug';\nimport { log } from '@dxos/log';\n\nimport { Directory } from './directory';\nimport { type File, wrapFile } from './file';\nimport { type Storage, type StorageType } from './storage';\nimport { getFullPath } from './utils';\n\n/**\n * Base class for all storage implementations.\n * https://github.com/random-access-storage\n * https://github.com/random-access-storage/random-access-storage\n */\n// TODO(dmaretskyi): Remove this class.\nexport abstract class AbstractStorage implements Storage {\n  protected readonly _files = new Map<string, File>();\n\n  public abstract readonly type: StorageType;\n\n  // TODO(burdon): Make required.\n  constructor(public readonly path: string) {}\n\n  [inspect.custom](): string {\n    return inspectObject(this);\n  }\n\n  toJSON(): { type: StorageType; path: string } {\n    return { type: this.type, path: this.path };\n  }\n\n  public get size() {\n    return this._files.size;\n  }\n\n  // TODO(burdon): Make required.\n  public createDirectory(sub = ''): Directory {\n    // invariant(sub.length);\n    return new Directory({\n      type: this.type,\n      path: getFullPath(this.path, sub),\n      list: this._list.bind(this),\n      getOrCreateFile: (...args) => this.getOrCreateFile(...args),\n      remove: () => this._remove(sub),\n    });\n  }\n\n  /**\n   * Delete all files.\n   */\n  async reset(): Promise<void> {\n    try {\n      log.info('Erasing all data...');\n      await this._closeFilesInPath('');\n      await this._remove('');\n      await this._destroy();\n      log('Erased...');\n    } catch (err: any) {\n      log.catch(err);\n    }\n  }\n\n  protected async _list(path: string): Promise<string[]> {\n    // TODO(dmaretskyi): Fix me.\n    return Array.from((await this._getFiles(path)).keys()).map((filename) => {\n      let name = filename.replace(path, '');\n      if (name.startsWith('/')) {\n        name = name.substring(1);\n      }\n      return name;\n    });\n  }\n\n  protected getOrCreateFile(path: string, filename: string, opts?: any): File {\n    const fullPath = join(path, filename);\n\n    let native;\n    let file = this._getFileIfExists(fullPath);\n    if (file) {\n      if (!file.closed) {\n        return file;\n      }\n\n      native = this._openFile(file.native);\n    }\n\n    if (!native) {\n      native = this._createFile(path, filename, opts);\n    }\n\n    file = wrapFile(native, this.type);\n    this._files.set(fullPath, file);\n    return file;\n  }\n\n  protected _destroy(): Promise<void> | undefined {\n    return undefined;\n  }\n\n  /**\n   * Attempt to reopen file.\n   */\n  protected _openFile(file: RandomAccessStorage): RandomAccessStorage | undefined {\n    return undefined;\n  }\n\n  protected abstract _createFile(path: string, filename: string, opts?: any): RandomAccessStorage;\n\n  private _getFileIfExists(filename: string): File | undefined {\n    if (this._files.has(filename)) {\n      const file = this._files.get(filename);\n      if (file && !file.destroyed) {\n        return file;\n      }\n    }\n  }\n\n  protected async _getFiles(path: string): Promise<Map<string, File>> {\n    const fullPath = getFullPath(this.path, path);\n    return new Map(\n      [...this._files.entries()].filter(([path, file]) => path.includes(fullPath) && file.destroyed !== true),\n    );\n  }\n\n  protected async _closeFilesInPath(path: string): Promise<void> {\n    await Promise.all(\n      Array.from((await this._getFiles(path)).values()).map((file) => file.close().catch((err: any) => log.catch(err))),\n    );\n  }\n\n  async close(): Promise<void> {\n    await this._closeFilesInPath('');\n  }\n\n  // TODO(burdon): Delete directory (not just listed files).\n  protected async _remove(path: string): Promise<void> {\n    await Promise.all(\n      Array.from(await this._getFiles(path)).map(([path, file]) => {\n        return file\n          .destroy()\n          .then(() => this._files.delete(path))\n          .catch((err: any) => log.error(err.message));\n      }),\n    );\n  }\n}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { join } from 'node:path';\n\n// TODO(burdon): Document.\nexport const stringDiff = (first: string, second: string) => first.split(second).join('');\n\nexport const getFullPath = (root: string, path: string) => join(root, stringDiff(path, root));\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { type File } from './file';\nimport { type StorageType } from './storage';\nimport { getFullPath } from './utils';\n\nexport type DirectoryParams = {\n  type: StorageType;\n  path: string;\n  // TODO(burdon): Create interface for these methods (shared with AbstractStorage).\n  list: (path: string) => Promise<string[]>;\n  getOrCreateFile: (path: string, filename: string, opts?: any) => File;\n  remove: () => Promise<void>;\n  onFlush?: () => Promise<void>;\n};\n\n/**\n * Wraps a directory in the storage file system.\n */\nexport class Directory {\n  public readonly type: StorageType;\n  public readonly path: string;\n  // TODO(burdon): Create interface for these methods (shared with AbstractStorage).\n  private readonly _list: (path: string) => Promise<string[]>;\n  private readonly _getOrCreateFile: (path: string, filename: string, opts?: any) => File;\n  private readonly _remove: () => Promise<void>;\n  private readonly _onFlush?: () => Promise<void>;\n\n  constructor({ type, path, list, getOrCreateFile, remove, onFlush }: DirectoryParams) {\n    this.type = type;\n    this.path = path;\n    this._list = list;\n    this._getOrCreateFile = getOrCreateFile;\n    this._remove = remove;\n    this._onFlush = onFlush;\n  }\n\n  toString(): string {\n    return `Directory(${JSON.stringify({ type: this.type, path: this.path })})`;\n  }\n\n  /**\n   * Create a new sub-directory.\n   */\n  createDirectory(path: string): Directory {\n    return new Directory({\n      type: this.type,\n      path: getFullPath(this.path, path),\n      list: this._list,\n      getOrCreateFile: this._getOrCreateFile,\n      remove: this._remove,\n    });\n  }\n\n  /**\n   * Get all files in the current directory.\n   */\n  list(): Promise<string[]> {\n    return this._list(this.path);\n  }\n\n  /**\n   * Get or create a new file.\n   */\n  getOrCreateFile(filename: string, opts?: any): File {\n    return this._getOrCreateFile(this.path, filename, opts);\n  }\n\n  async flush(): Promise<void> {\n    await this._onFlush?.();\n  }\n\n  /**\n   * Close and delete all files in the directory and all its sub-directories.\n   */\n  async delete(): Promise<void> {\n    await this._remove();\n  }\n}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport pify from 'pify';\nimport type { FileStat, RandomAccessStorage, RandomAccessStorageProperties } from 'random-access-storage';\n\nimport { log } from '@dxos/log';\n\nimport { type StorageType } from './storage';\n\nconst MAX_STORAGE_OPERATION_TIME = 50;\n\n/**\n * Random access file wrapper.\n * https://github.com/random-access-storage/random-access-storage\n */\nexport interface File extends RandomAccessStorageProperties {\n  readonly destroyed: boolean;\n\n  // TODO(burdon): Can we remove these since they are not standard across implementations?\n  readonly directory: string;\n  readonly filename: string;\n\n  // Added by factory.\n  readonly type: StorageType;\n  readonly native: RandomAccessStorage;\n\n  write(offset: number, data: Buffer): Promise<void>;\n  read(offset: number, size: number): Promise<Buffer>;\n  del(offset: number, size: number): Promise<void>;\n  stat(): Promise<FileStat>;\n  close(): Promise<Error | void>;\n  destroy(): Promise<Error | void>;\n\n  /**\n   * Save changes to disk.\n   */\n  flush?(): Promise<void>;\n\n  // Not supported in node, memory.\n  truncate?(offset: number): Promise<void>;\n\n  // random-access-memory only.\n  clone?(): RandomAccessStorage;\n}\n\nconst pifyFields = (object: any, type: StorageType, fields: string[]) => {\n  for (const field of fields) {\n    if (!object[field]) {\n      // TODO(burdon): Suppress warning and throw error if used.\n      // console.warn(`Field not supported for type: ${JSON.stringify({ type, field })}`);\n    } else {\n      const fn = pify(object[field].bind(object));\n      object[field] = async (...args: any) => {\n        const before = performance.now();\n\n        const res = await fn(...args);\n\n        const elapsed = performance.now() - before;\n        if (elapsed > MAX_STORAGE_OPERATION_TIME) {\n          log('Slow storage operation', { type, operation: field, elapsed });\n        }\n\n        return res;\n      };\n    }\n  }\n\n  return object;\n};\n\n/**\n * Construct async File wrapper.\n * NOTE: This is safe since these are interface methods only (not used internally).\n */\nexport const wrapFile = (native: RandomAccessStorage, type: StorageType): File => {\n  const file = pifyFields(native, type, ['write', 'read', 'del', 'stat', 'close', 'destroy', 'truncate']);\n  return Object.assign(file, { type, native });\n};\n", "//\n// Copyright 2021 DXOS.org\n//\n\nimport ram from 'random-access-memory';\nimport { type Callback, type RandomAccessStorage } from 'random-access-storage';\n\nimport { arrayToBuffer } from '@dxos/util';\n\nimport { AbstractStorage } from './abstract-storage';\nimport { type DiskInfo, StorageType } from './storage';\n\n/**\n * Storage interface implementation for RAM.\n * https://github.com/random-access-storage/random-access-memory\n */\nexport class MemoryStorage extends AbstractStorage {\n  public override type: StorageType = StorageType.RAM;\n\n  protected override _createFile(path: string, filename: string): RandomAccessStorage {\n    return this._patchFile(ram());\n  }\n\n  protected override _openFile(file: RandomAccessStorage): RandomAccessStorage {\n    const newFile = file.clone!();\n    (newFile as any).closed = false;\n    return this._patchFile(newFile);\n  }\n\n  private _patchFile(file: RandomAccessStorage): RandomAccessStorage {\n    // Patch required to make consistent across platforms.\n    const trueRead = file.read.bind(file);\n\n    file.read = (offset: number, size: number, cb: Callback<Buffer>) =>\n      trueRead(offset, size, (err: Error | null, data?: Buffer) => {\n        if (err) {\n          return cb(err);\n        } else {\n          return cb(err, arrayToBuffer(data!));\n        }\n      });\n\n    return file;\n  }\n\n  async getDiskInfo(): Promise<DiskInfo> {\n    let used = 0;\n\n    for (const file of this._files.values()) {\n      const size = (file as any).length;\n      used += Number.isNaN(size) ? 0 : size;\n    }\n\n    return {\n      used,\n    };\n  }\n}\n", "//\n// Copyright 2021 DXOS.org\n//\n\nimport { type Directory } from './directory';\n\n// TODO(burdon): Reconcile with ConfigProto.\nexport enum StorageType {\n  RAM = 'ram',\n  IDB = 'idb',\n  /**\n   * @deprecated\n   */\n  CHROME = 'chrome',\n  /**\n   * @deprecated\n   */\n  FIREFOX = 'firefox',\n  NODE = 'node',\n  /**\n   * @deprecated\n   */\n  WEBFS = 'webfs',\n}\n\nexport type DiskInfo = {\n  /**\n   * Bytes.\n   */\n  used: number;\n};\n\nexport interface Storage {\n  readonly path: string;\n  readonly type: StorageType;\n  readonly size: number;\n\n  getDiskInfo?(): Promise<DiskInfo>;\n\n  // TODO(burdon): Make required.\n  createDirectory: (path?: string) => Directory;\n  reset: () => Promise<void>;\n  close: () => Promise<void>;\n}\n\nexport type StorageConstructor = (params?: { type?: StorageType; root?: string }) => Storage;\n", "//\n// Copyright 2021 DXOS.org\n//\n\nimport del from 'del';\nimport { existsSync } from 'node:fs';\nimport { readdir, stat } from 'node:fs/promises';\nimport { join } from 'node:path';\nimport raf from 'random-access-file';\nimport { type RandomAccessStorage } from 'random-access-storage';\n\nimport { AbstractStorage, type DiskInfo, type Storage, StorageType, wrapFile } from '../common';\n\n/**\n * Storage interface implementation for Node.\n */\nexport class NodeStorage extends AbstractStorage implements Storage {\n  public override type: StorageType = StorageType.NODE;\n  private _initialized = false;\n\n  private async _loadFiles(path: string): Promise<void> {\n    // TODO(mykola): Do not load all files at once. It is a quick fix.\n    if (!existsSync(path)) {\n      return;\n    }\n\n    // Preload all files in a directory.\n    const dir = await readdir(path);\n    for (const entry of dir) {\n      const fullPath = join(path, entry);\n      if (this._files.has(fullPath)) {\n        continue;\n      }\n      const entryInfo = await stat(fullPath);\n      if (entryInfo.isDirectory()) {\n        await this._loadFiles(fullPath);\n      } else if (entryInfo.isFile()) {\n        const file = this._createFile(path, entry);\n        this._files.set(fullPath, wrapFile(file, this.type));\n      }\n    }\n  }\n\n  protected override _createFile(path: string, filename: string, opts: any = {}): RandomAccessStorage {\n    const file = raf(filename, { directory: path, ...opts });\n\n    // Empty write to create file on a drive.\n    file.write(0, Buffer.from(''));\n\n    return file;\n  }\n\n  protected override async _destroy(): Promise<void> {\n    await del(this.path, { force: true });\n  }\n\n  protected override async _getFiles(path: string) {\n    if (!this._initialized) {\n      await this._loadFiles(this.path);\n      this._initialized = true;\n    }\n\n    return super._getFiles(path);\n  }\n\n  async getDiskInfo(): Promise<DiskInfo> {\n    let used = 0;\n\n    const recurse = async (path: string) => {\n      const pathStats = await stat(path);\n\n      if (pathStats.isDirectory()) {\n        const entries = await readdir(path);\n        await Promise.all(entries.map((entry) => recurse(join(path, entry))));\n      } else {\n        used += pathStats.size;\n      }\n    };\n\n    await recurse(this.path);\n\n    return {\n      used,\n    };\n  }\n}\n", "//\n// Copyright 2021 DXOS.org\n//\n\nimport { NodeStorage } from './node-storage';\nimport { MemoryStorage, type Storage, type StorageConstructor, StorageType } from '../common';\n\nexport const createStorage: StorageConstructor = ({ type, root = '/tmp/dxos/testing' } = {}): Storage => {\n  if (type === undefined) {\n    return new NodeStorage(root);\n  }\n\n  switch (type) {\n    case StorageType.RAM: {\n      return new MemoryStorage(root);\n    }\n\n    case StorageType.NODE: {\n      return new NodeStorage(root);\n    }\n\n    default: {\n      throw new Error(`Invalid type: ${type}`);\n    }\n  }\n};\n"],
  "mappings": "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",
  "names": ["join", "inspect", "inspectObject", "log", "join", "stringDiff", "first", "second", "split", "join", "getFullPath", "root", "path", "Directory", "type", "path", "list", "getOrCreateFile", "remove", "onFlush", "_list", "_getOrCreateFile", "_remove", "_onFlush", "toString", "JSON", "stringify", "createDirectory", "getFullPath", "filename", "opts", "flush", "delete", "pify", "log", "MAX_STORAGE_OPERATION_TIME", "pifyFields", "object", "type", "fields", "field", "fn", "bind", "args", "before", "performance", "now", "res", "elapsed", "operation", "wrapFile", "native", "file", "Object", "assign", "AbstractStorage", "path", "_files", "Map", "inspect", "custom", "inspectObject", "toJSON", "type", "size", "createDirectory", "sub", "Directory", "getFullPath", "list", "_list", "bind", "getOrCreateFile", "args", "remove", "_remove", "reset", "log", "info", "_closeFilesInPath", "_destroy", "err", "catch", "Array", "from", "_getFiles", "keys", "map", "filename", "name", "replace", "startsWith", "substring", "opts", "fullPath", "join", "native", "file", "_getFileIfExists", "closed", "_openFile", "_createFile", "wrapFile", "set", "undefined", "has", "get", "destroyed", "entries", "filter", "includes", "Promise", "all", "values", "close", "destroy", "then", "delete", "error", "message", "ram", "arrayToBuffer", "StorageType", "MemoryStorage", "AbstractStorage", "type", "StorageType", "RAM", "_createFile", "path", "filename", "_patchFile", "ram", "_openFile", "file", "newFile", "clone", "closed", "trueRead", "read", "bind", "offset", "size", "cb", "err", "data", "arrayToBuffer", "getDiskInfo", "used", "_files", "values", "length", "Number", "isNaN", "del", "existsSync", "readdir", "stat", "join", "raf", "NodeStorage", "AbstractStorage", "type", "StorageType", "NODE", "_initialized", "_loadFiles", "path", "existsSync", "dir", "readdir", "entry", "fullPath", "join", "_files", "has", "entryInfo", "stat", "isDirectory", "isFile", "file", "_createFile", "set", "wrapFile", "filename", "opts", "raf", "directory", "write", "Buffer", "from", "_destroy", "del", "force", "_getFiles", "getDiskInfo", "used", "recurse", "pathStats", "entries", "Promise", "all", "map", "size", "createStorage", "type", "root", "undefined", "NodeStorage", "StorageType", "RAM", "MemoryStorage", "NODE", "Error"]
}
