{
  "version": 3,
  "sources": ["../../../src/common/abstract-storage.ts", "../../../src/common/utils.ts", "../../../src/common/directory.ts", "../../../src/common/file.ts", "../../../src/common/memory-storage.ts", "../../../src/common/storage.ts", "../../../src/node/node-storage.ts", "../../../src/node/storage.ts"],
  "sourcesContent": ["//\n// Copyright 2021 DXOS.org\n//\n\nimport { join } from 'node:path';\nimport { inspect } from 'node:util';\nimport type { RandomAccessStorage } from 'random-access-storage';\n\nimport { inspectObject } from '@dxos/debug';\nimport { log } from '@dxos/log';\n\nimport { Directory } from './directory';\nimport { type File, wrapFile } from './file';\nimport { type Storage, type StorageType } from './storage';\nimport { getFullPath } from './utils';\n\n/**\n * Base class for all storage implementations.\n * https://github.com/random-access-storage\n * https://github.com/random-access-storage/random-access-storage\n */\n// TODO(dmaretskyi): Remove this class.\nexport abstract class AbstractStorage implements Storage {\n  protected readonly _files = new Map<string, File>();\n\n  public abstract readonly type: StorageType;\n\n  // TODO(burdon): Make required.\n  constructor(public readonly path: string) {}\n\n  [inspect.custom](): string {\n    return inspectObject(this);\n  }\n\n  toJSON(): { type: StorageType; path: string } {\n    return { type: this.type, path: this.path };\n  }\n\n  public get size() {\n    return this._files.size;\n  }\n\n  // TODO(burdon): Make required.\n  public createDirectory(sub = ''): Directory {\n    // invariant(sub.length);\n    return new Directory({\n      type: this.type,\n      path: getFullPath(this.path, sub),\n      list: this._list.bind(this),\n      getOrCreateFile: (...args) => this.getOrCreateFile(...args),\n      remove: () => this._remove(sub),\n    });\n  }\n\n  /**\n   * Delete all files.\n   */\n  async reset(): Promise<void> {\n    try {\n      log.info('Erasing all data...');\n      await this._closeFilesInPath('');\n      await this._remove('');\n      await this._destroy();\n      log('Erased...');\n    } catch (err: any) {\n      log.catch(err);\n    }\n  }\n\n  protected async _list(path: string): Promise<string[]> {\n    // TODO(dmaretskyi): Fix me.\n    return Array.from((await this._getFiles(path)).keys()).map((filename) => {\n      let name = filename.replace(path, '');\n      if (name.startsWith('/')) {\n        name = name.substring(1);\n      }\n      return name;\n    });\n  }\n\n  protected getOrCreateFile(path: string, filename: string, opts?: any): File {\n    const fullPath = join(path, filename);\n\n    let native;\n    let file = this._getFileIfExists(fullPath);\n    if (file) {\n      if (!file.closed) {\n        return file;\n      }\n\n      native = this._openFile(file.native);\n    }\n\n    if (!native) {\n      native = this._createFile(path, filename, opts);\n    }\n\n    file = wrapFile(native, this.type);\n    this._files.set(fullPath, file);\n    return file;\n  }\n\n  protected _destroy(): Promise<void> | undefined {\n    return undefined;\n  }\n\n  /**\n   * Attempt to reopen file.\n   */\n  protected _openFile(file: RandomAccessStorage): RandomAccessStorage | undefined {\n    return undefined;\n  }\n\n  protected abstract _createFile(path: string, filename: string, opts?: any): RandomAccessStorage;\n\n  private _getFileIfExists(filename: string): File | undefined {\n    if (this._files.has(filename)) {\n      const file = this._files.get(filename);\n      if (file && !file.destroyed) {\n        return file;\n      }\n    }\n  }\n\n  protected async _getFiles(path: string): Promise<Map<string, File>> {\n    const fullPath = getFullPath(this.path, path);\n    return new Map(\n      [...this._files.entries()].filter(([path, file]) => path.includes(fullPath) && file.destroyed !== true),\n    );\n  }\n\n  protected async _closeFilesInPath(path: string): Promise<void> {\n    await Promise.all(\n      Array.from((await this._getFiles(path)).values()).map((file) => file.close().catch((err: any) => log.catch(err))),\n    );\n  }\n\n  async close(): Promise<void> {\n    await this._closeFilesInPath('');\n  }\n\n  // TODO(burdon): Delete directory (not just listed files).\n  protected async _remove(path: string): Promise<void> {\n    await Promise.all(\n      Array.from(await this._getFiles(path)).map(([path, file]) => {\n        return file\n          .destroy()\n          .then(() => this._files.delete(path))\n          .catch((err: any) => log.error(err.message));\n      }),\n    );\n  }\n}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { join } from 'node:path';\n\n// TODO(burdon): Document.\nexport const stringDiff = (first: string, second: string) => first.split(second).join('');\n\nexport const getFullPath = (root: string, path: string) => join(root, stringDiff(path, root));\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { type File } from './file';\nimport { type StorageType } from './storage';\nimport { getFullPath } from './utils';\n\nexport type DirectoryParams = {\n  type: StorageType;\n  path: string;\n  // TODO(burdon): Create interface for these methods (shared with AbstractStorage).\n  list: (path: string) => Promise<string[]>;\n  getOrCreateFile: (path: string, filename: string, opts?: any) => File;\n  remove: () => Promise<void>;\n  onFlush?: () => Promise<void>;\n};\n\n/**\n * Wraps a directory in the storage file system.\n */\nexport class Directory {\n  public readonly type: StorageType;\n  public readonly path: string;\n  // TODO(burdon): Create interface for these methods (shared with AbstractStorage).\n  private readonly _list: (path: string) => Promise<string[]>;\n  private readonly _getOrCreateFile: (path: string, filename: string, opts?: any) => File;\n  private readonly _remove: () => Promise<void>;\n  private readonly _onFlush?: () => Promise<void>;\n\n  constructor({ type, path, list, getOrCreateFile, remove, onFlush }: DirectoryParams) {\n    this.type = type;\n    this.path = path;\n    this._list = list;\n    this._getOrCreateFile = getOrCreateFile;\n    this._remove = remove;\n    this._onFlush = onFlush;\n  }\n\n  toString(): string {\n    return `Directory(${JSON.stringify({ type: this.type, path: this.path })})`;\n  }\n\n  /**\n   * Create a new sub-directory.\n   */\n  createDirectory(path: string): Directory {\n    return new Directory({\n      type: this.type,\n      path: getFullPath(this.path, path),\n      list: this._list,\n      getOrCreateFile: this._getOrCreateFile,\n      remove: this._remove,\n    });\n  }\n\n  /**\n   * Get all files in the current directory.\n   */\n  list(): Promise<string[]> {\n    return this._list(this.path);\n  }\n\n  /**\n   * Get or create a new file.\n   */\n  getOrCreateFile(filename: string, opts?: any): File {\n    return this._getOrCreateFile(this.path, filename, opts);\n  }\n\n  async flush(): Promise<void> {\n    await this._onFlush?.();\n  }\n\n  /**\n   * Close and delete all files in the directory and all its sub-directories.\n   */\n  async delete(): Promise<void> {\n    await this._remove();\n  }\n}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport pify from 'pify';\nimport type { FileStat, RandomAccessStorage, RandomAccessStorageProperties } from 'random-access-storage';\n\nimport { log } from '@dxos/log';\n\nimport { type StorageType } from './storage';\n\nconst MAX_STORAGE_OPERATION_TIME = 50;\n\n/**\n * Random access file wrapper.\n * https://github.com/random-access-storage/random-access-storage\n */\nexport interface File extends RandomAccessStorageProperties {\n  readonly destroyed: boolean;\n\n  // TODO(burdon): Can we remove these since they are not standard across implementations?\n  readonly directory: string;\n  readonly filename: string;\n\n  // Added by factory.\n  readonly type: StorageType;\n  readonly native: RandomAccessStorage;\n\n  write(offset: number, data: Buffer): Promise<void>;\n  read(offset: number, size: number): Promise<Buffer>;\n  del(offset: number, size: number): Promise<void>;\n  stat(): Promise<FileStat>;\n  close(): Promise<Error | void>;\n  destroy(): Promise<Error | void>;\n\n  /**\n   * Save changes to disk.\n   */\n  flush?(): Promise<void>;\n\n  // Not supported in node, memory.\n  truncate?(offset: number): Promise<void>;\n\n  // random-access-memory only.\n  clone?(): RandomAccessStorage;\n}\n\nconst pifyFields = (object: any, type: StorageType, fields: string[]) => {\n  for (const field of fields) {\n    if (!object[field]) {\n      // TODO(burdon): Suppress warning and throw error if used.\n      // console.warn(`Field not supported for type: ${JSON.stringify({ type, field })}`);\n    } else {\n      const fn = pify(object[field].bind(object));\n      object[field] = async (...args: any) => {\n        const before = performance.now();\n\n        const res = await fn(...args);\n\n        const elapsed = performance.now() - before;\n        if (elapsed > MAX_STORAGE_OPERATION_TIME) {\n          log('Slow storage operation', { type, operation: field, elapsed });\n        }\n\n        return res;\n      };\n    }\n  }\n\n  return object;\n};\n\n/**\n * Construct async File wrapper.\n * NOTE: This is safe since these are interface methods only (not used internally).\n */\nexport const wrapFile = (native: RandomAccessStorage, type: StorageType): File => {\n  const file = pifyFields(native, type, ['write', 'read', 'del', 'stat', 'close', 'destroy', 'truncate']);\n  return Object.assign(file, { type, native });\n};\n", "//\n// Copyright 2021 DXOS.org\n//\n\nimport ram from 'random-access-memory';\nimport { type Callback, type RandomAccessStorage } from 'random-access-storage';\n\nimport { arrayToBuffer } from '@dxos/util';\n\nimport { AbstractStorage } from './abstract-storage';\nimport { type DiskInfo, StorageType } from './storage';\n\n/**\n * Storage interface implementation for RAM.\n * https://github.com/random-access-storage/random-access-memory\n */\nexport class MemoryStorage extends AbstractStorage {\n  public override type: StorageType = StorageType.RAM;\n\n  protected override _createFile(path: string, filename: string): RandomAccessStorage {\n    return this._patchFile(ram());\n  }\n\n  protected override _openFile(file: RandomAccessStorage): RandomAccessStorage {\n    const newFile = file.clone!();\n    (newFile as any).closed = false;\n    return this._patchFile(newFile);\n  }\n\n  private _patchFile(file: RandomAccessStorage): RandomAccessStorage {\n    // Patch required to make consistent across platforms.\n    const trueRead = file.read.bind(file);\n\n    file.read = (offset: number, size: number, cb: Callback<Buffer>) =>\n      trueRead(offset, size, (err: Error | null, data?: Buffer) => {\n        if (err) {\n          return cb(err);\n        } else {\n          return cb(err, arrayToBuffer(data!));\n        }\n      });\n\n    return file;\n  }\n\n  async getDiskInfo(): Promise<DiskInfo> {\n    let used = 0;\n\n    for (const file of this._files.values()) {\n      const size = (file as any).length;\n      used += Number.isNaN(size) ? 0 : size;\n    }\n\n    return {\n      used,\n    };\n  }\n}\n", "//\n// Copyright 2021 DXOS.org\n//\n\nimport { type Directory } from './directory';\n\n// TODO(burdon): Reconcile with ConfigProto.\nexport enum StorageType {\n  RAM = 'ram',\n  IDB = 'idb',\n  /**\n   * @deprecated\n   */\n  CHROME = 'chrome',\n  /**\n   * @deprecated\n   */\n  FIREFOX = 'firefox',\n  NODE = 'node',\n  /**\n   * @deprecated\n   */\n  WEBFS = 'webfs',\n}\n\nexport type DiskInfo = {\n  /**\n   * Bytes.\n   */\n  used: number;\n};\n\nexport interface Storage {\n  readonly path: string;\n  readonly type: StorageType;\n  readonly size: number;\n\n  getDiskInfo?(): Promise<DiskInfo>;\n\n  // TODO(burdon): Make required.\n  createDirectory: (path?: string) => Directory;\n  reset: () => Promise<void>;\n  close: () => Promise<void>;\n}\n\nexport type StorageConstructor = (params?: { type?: StorageType; root?: string }) => Storage;\n", "//\n// Copyright 2021 DXOS.org\n//\n\nimport del from 'del';\nimport { existsSync } from 'node:fs';\nimport { readdir, stat } from 'node:fs/promises';\nimport { join } from 'node:path';\nimport raf from 'random-access-file';\nimport { type RandomAccessStorage } from 'random-access-storage';\n\nimport { AbstractStorage, type DiskInfo, type Storage, StorageType, wrapFile } from '../common';\n\n/**\n * Storage interface implementation for Node.\n */\nexport class NodeStorage extends AbstractStorage implements Storage {\n  public override type: StorageType = StorageType.NODE;\n  private _initialized = false;\n\n  private async _loadFiles(path: string): Promise<void> {\n    // TODO(mykola): Do not load all files at once. It is a quick fix.\n    if (!existsSync(path)) {\n      return;\n    }\n\n    // Preload all files in a directory.\n    const dir = await readdir(path);\n    for (const entry of dir) {\n      const fullPath = join(path, entry);\n      if (this._files.has(fullPath)) {\n        continue;\n      }\n      const entryInfo = await stat(fullPath);\n      if (entryInfo.isDirectory()) {\n        await this._loadFiles(fullPath);\n      } else if (entryInfo.isFile()) {\n        const file = this._createFile(path, entry);\n        this._files.set(fullPath, wrapFile(file, this.type));\n      }\n    }\n  }\n\n  protected override _createFile(path: string, filename: string, opts: any = {}): RandomAccessStorage {\n    const file = raf(filename, { directory: path, ...opts });\n\n    // Empty write to create file on a drive.\n    file.write(0, Buffer.from(''));\n\n    return file;\n  }\n\n  protected override async _destroy(): Promise<void> {\n    await del(this.path, { force: true });\n  }\n\n  protected override async _getFiles(path: string) {\n    if (!this._initialized) {\n      await this._loadFiles(this.path);\n      this._initialized = true;\n    }\n\n    return super._getFiles(path);\n  }\n\n  async getDiskInfo(): Promise<DiskInfo> {\n    let used = 0;\n\n    const recurse = async (path: string) => {\n      const pathStats = await stat(path);\n\n      if (pathStats.isDirectory()) {\n        const entries = await readdir(path);\n        await Promise.all(entries.map((entry) => recurse(join(path, entry))));\n      } else {\n        used += pathStats.size;\n      }\n    };\n\n    await recurse(this.path);\n\n    return {\n      used,\n    };\n  }\n}\n", "//\n// Copyright 2021 DXOS.org\n//\n\nimport { NodeStorage } from './node-storage';\nimport { MemoryStorage, type Storage, type StorageConstructor, StorageType } from '../common';\n\nexport const createStorage: StorageConstructor = ({ type, root = '/tmp/dxos/testing' } = {}): Storage => {\n  if (type === undefined) {\n    return new NodeStorage(root);\n  }\n\n  switch (type) {\n    case StorageType.RAM: {\n      return new MemoryStorage(root);\n    }\n\n    case StorageType.NODE: {\n      return new NodeStorage(root);\n    }\n\n    default: {\n      throw new Error(`Invalid type: ${type}`);\n    }\n  }\n};\n"],
  "mappings": "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",
  "names": ["import_node_path", "import_log", "stringDiff", "first", "second", "split", "join", "getFullPath", "root", "path", "Directory", "type", "list", "getOrCreateFile", "remove", "onFlush", "_list", "_getOrCreateFile", "_remove", "_onFlush", "toString", "JSON", "stringify", "createDirectory", "filename", "opts", "flush", "delete", "MAX_STORAGE_OPERATION_TIME", "pifyFields", "object", "fields", "field", "fn", "pify", "bind", "args", "before", "performance", "now", "res", "elapsed", "log", "operation", "wrapFile", "native", "file", "Object", "assign", "AbstractStorage", "_files", "Map", "inspect", "custom", "inspectObject", "toJSON", "size", "sub", "reset", "info", "_closeFilesInPath", "_destroy", "err", "catch", "Array", "from", "_getFiles", "keys", "map", "name", "replace", "startsWith", "substring", "fullPath", "_getFileIfExists", "closed", "_openFile", "_createFile", "set", "undefined", "has", "get", "destroyed", "entries", "filter", "includes", "Promise", "all", "values", "close", "destroy", "then", "error", "message", "StorageType", "MemoryStorage", "RAM", "_patchFile", "ram", "newFile", "clone", "trueRead", "read", "offset", "cb", "data", "arrayToBuffer", "getDiskInfo", "used", "length", "Number", "isNaN", "NodeStorage", "NODE", "_initialized", "_loadFiles", "existsSync", "dir", "readdir", "entry", "entryInfo", "stat", "isDirectory", "isFile", "raf", "directory", "write", "Buffer", "del", "force", "recurse", "pathStats", "createStorage", "Error"]
}
