{
  "version": 3,
  "sources": ["../../../../../../node_modules/.pnpm/random-access-idb@1.2.2_patch_hash=mqfhtwnltd5kq5s4kb4gk7k2k4/node_modules/random-access-idb/lib/blocks.js", "../../../../../../node_modules/.pnpm/random-access-idb@1.2.2_patch_hash=mqfhtwnltd5kq5s4kb4gk7k2k4/node_modules/random-access-idb/index.js", "../../../src/common/abstract-storage.ts", "../../../src/common/utils.ts", "../../../src/common/directory.ts", "../../../src/common/file.ts", "../../../src/common/memory-storage.ts", "../../../src/common/storage.ts", "../../../src/browser/idb-storage.ts", "../../../src/browser/web-fs.ts", "../../../src/browser/storage.ts"],
  "sourcesContent": ["module.exports = function (size, start, end) {\n  var result = []\n  for (var n = Math.floor(start/size)*size; n < end; n += size) {\n    result.push({\n      block: Math.floor(n/size),\n      start: Math.max(n,start) % size,\n      end: Math.min(n+size,end) % size || size\n    })\n  }\n  return result\n}\n", "var RandomAccess = require('random-access-storage')\nvar inherits = require('inherits')\nvar nextTick = require('next-tick')\nvar once = require('once')\nvar blocks = require('./lib/blocks.js')\nvar bufferFrom = require('buffer-from')\nvar bufferAlloc = require('buffer-alloc')\n\nvar DELIM = '\\0'\nvar win = typeof window !== 'undefined' ? window\n  : (typeof self !== 'undefined' ? self : {})\n\nmodule.exports = function (dbname, xopts) {\n  if (!xopts) xopts = {}\n  var idb = xopts.idb || (typeof win !== 'undefined'\n    ? win.indexedDB || win.mozIndexedDB\n      || win.webkitIndexedDB || win.msIndexedDB\n    : null)\n  if (!idb) throw new Error('indexedDB not present and not given')\n  var db = null, dbqueue = []\n  if (typeof idb.open === 'function') {\n    var req = idb.open(dbname)\n    req.addEventListener('upgradeneeded', function () {\n      db = req.result\n      db.createObjectStore('data')\n    })\n    req.addEventListener('success', function () {\n      db = req.result\n      dbqueue.forEach(function (cb) { cb(db) })\n      dbqueue = null\n    })\n  } else {\n    db = idb\n  }\n  function getdb (cb) {\n    if (db) nextTick(function () { cb(db) })\n    else dbqueue.push(cb)\n  }\n  return {\n    create: function (name, opts) {\n      if (typeof name === 'object') {\n        opts = name\n        name = opts.name\n      }\n\n      if (!opts) opts = {}\n      opts.name = name\n\n      return new Store(Object.assign({ db: getdb }, xopts, opts))\n    },\n    getdb\n  }\n}\n\nfunction Store (opts) {\n  if (!(this instanceof Store)) return new Store(opts)\n  RandomAccess.call(this)\n  if (!opts) opts = {}\n  if (typeof opts === 'string') opts = { name: opts }\n  this.size = opts.size || 4096\n  this.name = opts.name\n  this.length = opts.length || 0\n  this._getdb = opts.db\n}\ninherits(Store, RandomAccess)\n\nStore.prototype._blocks = function (i, j) {\n  return blocks(this.size, i, j)\n}\n\nStore.prototype._read = function (req) {\n  var self = this\n  var buffers = []\n  self._store('readonly', function (err, store) {\n    if ((self.length || 0) < req.offset+req.size) {\n      return req.callback(new Error('Could not satisfy length'))\n    }\n    if (err) return req.callback(err)\n    var offsets = self._blocks(req.offset, req.offset+req.size)\n    var pending = offsets.length + 1\n    var firstBlock = offsets.length > 0 ? offsets[0].block : 0\n    var j = 0\n    for (var i = 0; i < offsets.length; i++) (function (o) {\n      var key = self.name + DELIM + o.block\n      backify(store.get(key), function (err, ev) {\n        if (err) return req.callback(err)\n        buffers[o.block-firstBlock] = ev.target.result\n          ? bufferFrom(ev.target.result.subarray(o.start,o.end))\n          : bufferAlloc(o.end-o.start)\n        if (--pending === 0) req.callback(null, Buffer.concat(buffers))\n      })\n    })(offsets[i])\n    if (--pending === 0) req.callback(null, Buffer.concat(buffers))\n  })\n}\n\nStore.prototype._write = function (req) {\n  var self = this\n  self._store('readwrite', function (err, store) {\n    if (err) return req.callback(err)\n    var offsets = self._blocks(req.offset, req.offset + req.data.length)\n    var pending = 1\n    var buffers = {}\n    for (var i = 0; i < offsets.length; i++) (function (o,i) {\n      if (o.end-o.start === self.size) return\n      pending++\n      var key = self.name + DELIM + o.block\n      backify(store.get(key), function (err, ev) {\n        if (err) return req.callback(err)\n        buffers[i] = bufferFrom(ev.target.result || bufferAlloc(self.size))\n        if (--pending === 0) write(store, offsets, buffers)\n      })\n    })(offsets[i],i)\n    if (--pending === 0) write(store, offsets, buffers)\n  })\n  function write (store, offsets, buffers) {\n    var block\n    for (var i = 0, j = 0; i < offsets.length; i++) {\n      var o = offsets[i]\n      var len = o.end - o.start\n      if (len === self.size) {\n        block = bufferFrom(req.data.slice(j, j+len))\n      } else {\n        block = buffers[i]\n        req.data.copy(block, o.start, j, j+len)\n      }\n      store.put(block,self.name + DELIM + o.block)\n      j += len\n    }\n    var length = Math.max(self.length || 0, req.offset + req.data.length)\n    store.put(length, self.name + DELIM + 'length')\n    store.transaction.addEventListener('complete', function () {\n      self.length = length\n      req.callback(null)\n    })\n    store.transaction.addEventListener('error', function (err) {\n      req.callback(err)\n    })\n  }\n}\n\nStore.prototype._store = function (mode, cb) {\n  cb = once(cb)\n  var self = this\n  self._getdb(function (db) {\n    var tx = db.transaction(['data'], mode)\n    var store = tx.objectStore('data')\n    tx.addEventListener('error', cb)\n    cb(null, store)\n  })\n}\n\nStore.prototype._open = function (req) {\n  var self = this\n  this._getdb(function(db) {\n    self._store('readonly', function (err, store) {\n      backify(store.get(self.name + DELIM + \"length\"), function(err, ev) {\n        self.length = ev.target.result || 0\n        req.callback(null)\n      })\n    })\n  })\n}\n\nStore.prototype._close = function (req) {\n  this._getdb(function (db) {\n    // db.close() // TODO: reopen gracefully. Close breaks with corestore, as innercorestore closes the db\n    req.callback()\n  })\n}\n\nStore.prototype._stat = function (req) {\n  var self = this\n  nextTick(function () {\n    req.callback(null, { size: self.length })\n  })\n}\n\nfunction backify (r, cb) {\n  r.addEventListener('success', function (ev) { cb(null, ev) })\n  r.addEventListener('error', cb)\n}\n", "//\n// Copyright 2021 DXOS.org\n//\n\nimport { join } from 'node:path';\nimport { inspect } from 'node:util';\nimport type { RandomAccessStorage } from 'random-access-storage';\n\nimport { inspectObject } from '@dxos/debug';\nimport { log } from '@dxos/log';\n\nimport { Directory } from './directory';\nimport { type File, wrapFile } from './file';\nimport { type Storage, type StorageType } from './storage';\nimport { getFullPath } from './utils';\n\n/**\n * Base class for all storage implementations.\n * https://github.com/random-access-storage\n * https://github.com/random-access-storage/random-access-storage\n */\n// TODO(dmaretskyi): Remove this class.\nexport abstract class AbstractStorage implements Storage {\n  protected readonly _files = new Map<string, File>();\n\n  public abstract readonly type: StorageType;\n\n  // TODO(burdon): Make required.\n  constructor(public readonly path: string) {}\n\n  [inspect.custom](): string {\n    return inspectObject(this);\n  }\n\n  toJSON(): { type: StorageType; path: string } {\n    return { type: this.type, path: this.path };\n  }\n\n  public get size() {\n    return this._files.size;\n  }\n\n  // TODO(burdon): Make required.\n  public createDirectory(sub = ''): Directory {\n    // invariant(sub.length);\n    return new Directory({\n      type: this.type,\n      path: getFullPath(this.path, sub),\n      list: this._list.bind(this),\n      getOrCreateFile: (...args) => this.getOrCreateFile(...args),\n      remove: () => this._remove(sub),\n    });\n  }\n\n  /**\n   * Delete all files.\n   */\n  async reset(): Promise<void> {\n    try {\n      log.info('Erasing all data...');\n      await this._closeFilesInPath('');\n      await this._remove('');\n      await this._destroy();\n      log('Erased...');\n    } catch (err: any) {\n      log.catch(err);\n    }\n  }\n\n  protected async _list(path: string): Promise<string[]> {\n    // TODO(dmaretskyi): Fix me.\n    return Array.from((await this._getFiles(path)).keys()).map((filename) => {\n      let name = filename.replace(path, '');\n      if (name.startsWith('/')) {\n        name = name.substring(1);\n      }\n      return name;\n    });\n  }\n\n  protected getOrCreateFile(path: string, filename: string, opts?: any): File {\n    const fullPath = join(path, filename);\n\n    let native;\n    let file = this._getFileIfExists(fullPath);\n    if (file) {\n      if (!file.closed) {\n        return file;\n      }\n\n      native = this._openFile(file.native);\n    }\n\n    if (!native) {\n      native = this._createFile(path, filename, opts);\n    }\n\n    file = wrapFile(native, this.type);\n    this._files.set(fullPath, file);\n    return file;\n  }\n\n  protected _destroy(): Promise<void> | undefined {\n    return undefined;\n  }\n\n  /**\n   * Attempt to reopen file.\n   */\n  protected _openFile(file: RandomAccessStorage): RandomAccessStorage | undefined {\n    return undefined;\n  }\n\n  protected abstract _createFile(path: string, filename: string, opts?: any): RandomAccessStorage;\n\n  private _getFileIfExists(filename: string): File | undefined {\n    if (this._files.has(filename)) {\n      const file = this._files.get(filename);\n      if (file && !file.destroyed) {\n        return file;\n      }\n    }\n  }\n\n  protected async _getFiles(path: string): Promise<Map<string, File>> {\n    const fullPath = getFullPath(this.path, path);\n    return new Map(\n      [...this._files.entries()].filter(([path, file]) => path.includes(fullPath) && file.destroyed !== true),\n    );\n  }\n\n  protected async _closeFilesInPath(path: string): Promise<void> {\n    await Promise.all(\n      Array.from((await this._getFiles(path)).values()).map((file) => file.close().catch((err: any) => log.catch(err))),\n    );\n  }\n\n  async close(): Promise<void> {\n    await this._closeFilesInPath('');\n  }\n\n  // TODO(burdon): Delete directory (not just listed files).\n  protected async _remove(path: string): Promise<void> {\n    await Promise.all(\n      Array.from(await this._getFiles(path)).map(([path, file]) => {\n        return file\n          .destroy()\n          .then(() => this._files.delete(path))\n          .catch((err: any) => log.error(err.message));\n      }),\n    );\n  }\n}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { join } from 'node:path';\n\n// TODO(burdon): Document.\nexport const stringDiff = (first: string, second: string) => first.split(second).join('');\n\nexport const getFullPath = (root: string, path: string) => join(root, stringDiff(path, root));\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { type File } from './file';\nimport { type StorageType } from './storage';\nimport { getFullPath } from './utils';\n\nexport type DirectoryParams = {\n  type: StorageType;\n  path: string;\n  // TODO(burdon): Create interface for these methods (shared with AbstractStorage).\n  list: (path: string) => Promise<string[]>;\n  getOrCreateFile: (path: string, filename: string, opts?: any) => File;\n  remove: () => Promise<void>;\n  onFlush?: () => Promise<void>;\n};\n\n/**\n * Wraps a directory in the storage file system.\n */\nexport class Directory {\n  public readonly type: StorageType;\n  public readonly path: string;\n  // TODO(burdon): Create interface for these methods (shared with AbstractStorage).\n  private readonly _list: (path: string) => Promise<string[]>;\n  private readonly _getOrCreateFile: (path: string, filename: string, opts?: any) => File;\n  private readonly _remove: () => Promise<void>;\n  private readonly _onFlush?: () => Promise<void>;\n\n  constructor({ type, path, list, getOrCreateFile, remove, onFlush }: DirectoryParams) {\n    this.type = type;\n    this.path = path;\n    this._list = list;\n    this._getOrCreateFile = getOrCreateFile;\n    this._remove = remove;\n    this._onFlush = onFlush;\n  }\n\n  toString(): string {\n    return `Directory(${JSON.stringify({ type: this.type, path: this.path })})`;\n  }\n\n  /**\n   * Create a new sub-directory.\n   */\n  createDirectory(path: string): Directory {\n    return new Directory({\n      type: this.type,\n      path: getFullPath(this.path, path),\n      list: this._list,\n      getOrCreateFile: this._getOrCreateFile,\n      remove: this._remove,\n    });\n  }\n\n  /**\n   * Get all files in the current directory.\n   */\n  list(): Promise<string[]> {\n    return this._list(this.path);\n  }\n\n  /**\n   * Get or create a new file.\n   */\n  getOrCreateFile(filename: string, opts?: any): File {\n    return this._getOrCreateFile(this.path, filename, opts);\n  }\n\n  async flush(): Promise<void> {\n    await this._onFlush?.();\n  }\n\n  /**\n   * Close and delete all files in the directory and all its sub-directories.\n   */\n  async delete(): Promise<void> {\n    await this._remove();\n  }\n}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport pify from 'pify';\nimport type { FileStat, RandomAccessStorage, RandomAccessStorageProperties } from 'random-access-storage';\n\nimport { log } from '@dxos/log';\n\nimport { type StorageType } from './storage';\n\nconst MAX_STORAGE_OPERATION_TIME = 50;\n\n/**\n * Random access file wrapper.\n * https://github.com/random-access-storage/random-access-storage\n */\nexport interface File extends RandomAccessStorageProperties {\n  readonly destroyed: boolean;\n\n  // TODO(burdon): Can we remove these since they are not standard across implementations?\n  readonly directory: string;\n  readonly filename: string;\n\n  // Added by factory.\n  readonly type: StorageType;\n  readonly native: RandomAccessStorage;\n\n  write(offset: number, data: Buffer): Promise<void>;\n  read(offset: number, size: number): Promise<Buffer>;\n  del(offset: number, size: number): Promise<void>;\n  stat(): Promise<FileStat>;\n  close(): Promise<Error | void>;\n  destroy(): Promise<Error | void>;\n\n  /**\n   * Save changes to disk.\n   */\n  flush?(): Promise<void>;\n\n  // Not supported in node, memory.\n  truncate?(offset: number): Promise<void>;\n\n  // random-access-memory only.\n  clone?(): RandomAccessStorage;\n}\n\nconst pifyFields = (object: any, type: StorageType, fields: string[]) => {\n  for (const field of fields) {\n    if (!object[field]) {\n      // TODO(burdon): Suppress warning and throw error if used.\n      // console.warn(`Field not supported for type: ${JSON.stringify({ type, field })}`);\n    } else {\n      const fn = pify(object[field].bind(object));\n      object[field] = async (...args: any) => {\n        const before = performance.now();\n\n        const res = await fn(...args);\n\n        const elapsed = performance.now() - before;\n        if (elapsed > MAX_STORAGE_OPERATION_TIME) {\n          log('Slow storage operation', { type, operation: field, elapsed });\n        }\n\n        return res;\n      };\n    }\n  }\n\n  return object;\n};\n\n/**\n * Construct async File wrapper.\n * NOTE: This is safe since these are interface methods only (not used internally).\n */\nexport const wrapFile = (native: RandomAccessStorage, type: StorageType): File => {\n  const file = pifyFields(native, type, ['write', 'read', 'del', 'stat', 'close', 'destroy', 'truncate']);\n  return Object.assign(file, { type, native });\n};\n", "//\n// Copyright 2021 DXOS.org\n//\n\nimport ram from 'random-access-memory';\nimport { type Callback, type RandomAccessStorage } from 'random-access-storage';\n\nimport { arrayToBuffer } from '@dxos/util';\n\nimport { AbstractStorage } from './abstract-storage';\nimport { type DiskInfo, StorageType } from './storage';\n\n/**\n * Storage interface implementation for RAM.\n * https://github.com/random-access-storage/random-access-memory\n */\nexport class MemoryStorage extends AbstractStorage {\n  public override type: StorageType = StorageType.RAM;\n\n  protected override _createFile(path: string, filename: string): RandomAccessStorage {\n    return this._patchFile(ram());\n  }\n\n  protected override _openFile(file: RandomAccessStorage): RandomAccessStorage {\n    const newFile = file.clone!();\n    (newFile as any).closed = false;\n    return this._patchFile(newFile);\n  }\n\n  private _patchFile(file: RandomAccessStorage): RandomAccessStorage {\n    // Patch required to make consistent across platforms.\n    const trueRead = file.read.bind(file);\n\n    file.read = (offset: number, size: number, cb: Callback<Buffer>) =>\n      trueRead(offset, size, (err: Error | null, data?: Buffer) => {\n        if (err) {\n          return cb(err);\n        } else {\n          return cb(err, arrayToBuffer(data!));\n        }\n      });\n\n    return file;\n  }\n\n  async getDiskInfo(): Promise<DiskInfo> {\n    let used = 0;\n\n    for (const file of this._files.values()) {\n      const size = (file as any).length;\n      used += Number.isNaN(size) ? 0 : size;\n    }\n\n    return {\n      used,\n    };\n  }\n}\n", "//\n// Copyright 2021 DXOS.org\n//\n\nimport { type Directory } from './directory';\n\n// TODO(burdon): Reconcile with ConfigProto.\nexport enum StorageType {\n  RAM = 'ram',\n  IDB = 'idb',\n  /**\n   * @deprecated\n   */\n  CHROME = 'chrome',\n  /**\n   * @deprecated\n   */\n  FIREFOX = 'firefox',\n  NODE = 'node',\n  /**\n   * @deprecated\n   */\n  WEBFS = 'webfs',\n}\n\nexport type DiskInfo = {\n  /**\n   * Bytes.\n   */\n  used: number;\n};\n\nexport interface Storage {\n  readonly path: string;\n  readonly type: StorageType;\n  readonly size: number;\n\n  getDiskInfo?(): Promise<DiskInfo>;\n\n  // TODO(burdon): Make required.\n  createDirectory: (path?: string) => Directory;\n  reset: () => Promise<void>;\n  close: () => Promise<void>;\n}\n\nexport type StorageConstructor = (params?: { type?: StorageType; root?: string }) => Storage;\n", "//\n// Copyright 2021 DXOS.org\n//\n\nimport idb from 'random-access-idb';\nimport { type RandomAccessStorage } from 'random-access-storage';\n\nimport { invariant } from '@dxos/invariant';\n\nimport { AbstractStorage, StorageType, getFullPath, wrapFile } from '../common';\n\nconst DELIM = '\\0';\n/**\n * Storage interface implementation for index DB.\n * https://github.com/random-access-storage/random-access-idb\n */\nexport class IDbStorage extends AbstractStorage {\n  public override type: StorageType = StorageType.IDB;\n  private _db!: Promise<IDBDatabase>;\n  private readonly _store = 'data';\n  private _initialized = false;\n  protected readonly _fileStorage: (filename: string, opts?: {}) => RandomAccessStorage;\n\n  constructor(path: string) {\n    super(path);\n    this._fileStorage = this._createFileStorage(path);\n  }\n\n  protected _createFileStorage(path: string): (filename: string, opts?: {}) => RandomAccessStorage {\n    // Note: We use patched version of random-access-idb here that exposes the getdb method.\n    const database = idb(path);\n    let res: (db: IDBDatabase) => void;\n    this._db = new Promise((resolve) => {\n      res = resolve;\n    });\n\n    database.getdb(res!);\n    return database.create;\n  }\n\n  override async close(): Promise<void> {\n    await this._closeFilesInPath('');\n    // TODO(dmaretskyi): Set a flag to make the current instance unusable.\n  }\n\n  override async reset(): Promise<void> {\n    // We don't delete the database, just erase the data.\n    // Deleting that database causes IDB errors which I have no idea how to fix.\n    await this._closeFilesInPath('');\n    await this._remove('');\n    // TODO(dmaretskyi): Set a flag to make the current instance unusable.\n  }\n\n  protected override async _destroy(): Promise<void> {\n    throw new Error('Unreachable');\n  }\n\n  protected override _createFile(path: string, filename: string): RandomAccessStorage {\n    const file = this._fileStorage(getFullPath(path, filename));\n    file.destroy = (cb: (err: Error | null) => void) => {\n      void this._db.then((db) => {\n        const lowerBound = getFullPath(path, filename);\n        const upperBound = `${lowerBound}\\uffff`;\n        const range = IDBKeyRange.bound(lowerBound, upperBound);\n\n        const transaction = db.transaction(this._store, 'readwrite');\n        const objectStore = transaction.objectStore(this._store);\n        objectStore.delete(range);\n        transaction.oncomplete = () => {\n          (file as any).destroyed = true;\n          (file as any).unlinked = true;\n          (file as any).closed = true;\n          cb(null);\n        };\n        transaction.onerror = () => cb(transaction.error);\n      });\n    };\n    (file as any).deletable = true;\n\n    return file;\n  }\n\n  async _loadFiles(path: string): Promise<void> {\n    const db = await this._db;\n    invariant(db, 'Database is not initialized.');\n    const lowerBound = path;\n    const upperBound = `${path}\\uffff`;\n    const range = IDBKeyRange.bound(lowerBound, upperBound);\n\n    const transaction = db.transaction(this._store);\n    const objectStore = transaction.objectStore(this._store);\n    const request = objectStore.openCursor(range);\n\n    return new Promise((resolve, reject) => {\n      transaction.onerror = () => {\n        reject(request.error);\n      };\n\n      request.onsuccess = (event) => {\n        const cursor = (event.target as IDBRequest).result as IDBCursorWithValue;\n        if (cursor) {\n          // NOTE: The key contains some metadata at the end added by random-access-idb, so we need to split it.\n          const filename = String(cursor.key).split(DELIM)[0];\n          if (filename && !this._files.has(getFullPath(this.path, filename))) {\n            const file = this._createFile(path, filename);\n            this._files.set(getFullPath(this.path, filename), wrapFile(file, this.type));\n          }\n          cursor.continue();\n        } else {\n          resolve();\n        }\n      };\n    });\n  }\n\n  protected override async _getFiles(path: string) {\n    if (!this._initialized) {\n      await this._loadFiles(this.path);\n      this._initialized = true;\n    }\n\n    return super._getFiles(path);\n  }\n}\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { EventEmitter } from 'node:events';\nimport { callbackify } from 'node:util';\nimport { type RandomAccessStorage } from 'random-access-storage';\n\nimport { synchronized } from '@dxos/async';\nimport { invariant } from '@dxos/invariant';\nimport { log } from '@dxos/log';\nimport { TimeSeriesCounter, trace } from '@dxos/tracing';\n\nimport { Directory, type DiskInfo, type File, type Storage, StorageType, getFullPath } from '../common';\n\n/**\n * Web file systems.\n */\nexport class WebFS implements Storage {\n  private readonly _files = new Map<string, WebFile>();\n\n  readonly type = StorageType.WEBFS;\n\n  protected _root?: FileSystemDirectoryHandle;\n\n  constructor(public readonly path: string) {}\n\n  public get size() {\n    return this._files.size;\n  }\n\n  private _getFiles(path: string): Map<string, WebFile> {\n    const fullName = this._getFullFilename(this.path, path);\n    return new Map(\n      [...this._files.entries()].filter(([path, file]) => {\n        return path.includes(fullName) && !file.destroyed;\n      }),\n    );\n  }\n\n  private async _list(path: string): Promise<string[]> {\n    const fullName = this._getFullFilename(path);\n\n    const root = await this._initialize();\n\n    // TODO(dmaretskyi): While we're storing all files in flat namespace we just iterate the root.\n    // console.log({ path, fullName })\n    // let dir: FileSystemDirectoryHandle;\n    // if (path === '') {\n    //   dir = root;\n    // } else {\n    //   dir = await root.getDirectoryHandle(fullName, { create: true });\n    // }\n    const entries: string[] = [];\n\n    for await (const entry of (root as any).keys()) {\n      // Filter out .crswap files.\n      // https://bugs.chromium.org/p/chromium/issues/detail?id=1228068\n      // https://github.com/logseq/logseq/issues/4466#:~:text=Jun%2015%2C%202023-,.,is%20used%20to%20edit%20files.\n      if (entry.startsWith(fullName + '_') && !entry.endsWith('.crswap')) {\n        entries.push(entry.slice(fullName.length + 1));\n      }\n    }\n    return entries;\n  }\n\n  @synchronized\n  private async _initialize(): Promise<FileSystemDirectoryHandle> {\n    if (this._root) {\n      return this._root;\n    }\n    this._root = await navigator.storage.getDirectory();\n    invariant(this._root, 'Root is undefined');\n    return this._root;\n  }\n\n  createDirectory(sub = ''): Directory {\n    return new Directory({\n      type: this.type,\n      path: getFullPath(this.path, sub),\n      list: (path) => this._list(path),\n      getOrCreateFile: (...args) => this.getOrCreateFile(...args),\n      remove: () => this._delete(sub),\n      onFlush: async () => {\n        await Promise.all(Array.from(this._getFiles(sub)).map(([_, file]) => file.flush()));\n      },\n    });\n  }\n\n  getOrCreateFile(path: string, filename: string, opts?: any): File {\n    const fullName = this._getFullFilename(path, filename);\n    const existingFile = this._files.get(fullName);\n    if (existingFile) {\n      return existingFile;\n    }\n    const file = this._createFile(fullName);\n    this._files.set(fullName, file);\n    return file;\n  }\n\n  private _createFile(fullName: string): WebFile {\n    return new WebFile({\n      fileName: fullName,\n      file: this._initialize().then((root) => root.getFileHandle(fullName, { create: true })),\n      destroy: async () => {\n        this._files.delete(fullName);\n        const root = await this._initialize();\n        return root.removeEntry(fullName);\n      },\n    });\n  }\n\n  private async _delete(path: string): Promise<void> {\n    await Promise.all(\n      Array.from(this._getFiles(path)).map(async ([path, file]) => {\n        await file.destroy().catch((err: any) => log.warn(err));\n        this._files.delete(path);\n      }),\n    );\n  }\n\n  async reset(): Promise<void> {\n    await this._initialize();\n    for await (const filename of await (this._root as any).keys()) {\n      await this._root!.removeEntry(filename, { recursive: true }).catch((err: any) =>\n        log.warn('failed to remove an entry', { filename, err }),\n      );\n      this._files.delete(filename);\n    }\n    this._root = undefined;\n  }\n\n  async close(): Promise<void> {\n    await Promise.all(\n      Array.from(this._files.values()).map((file) => {\n        return file.close().catch((e) => log.warn('failed to close a file', { file: file.fileName, e }));\n      }),\n    );\n  }\n\n  private _getFullFilename(path: string, filename?: string): string {\n    // Replace slashes with underscores. Because we can't have slashes in filenames in Browser File Handle API.\n    if (filename) {\n      return getFullPath(path, filename).replace(/\\//g, '_');\n    } else {\n      return path.replace(/\\//g, '_');\n    }\n  }\n\n  async getDiskInfo(): Promise<DiskInfo> {\n    let used = 0;\n\n    const recurse = async (handle: FileSystemDirectoryHandle) => {\n      const promises = [];\n\n      for await (const entry of (handle as any).values()) {\n        promises.push(\n          (async () => {\n            switch (entry.kind) {\n              case 'file':\n                used += await (entry as FileSystemFileHandle).getFile().then((f) => f.size);\n                break;\n              case 'directory':\n                await recurse(entry as FileSystemDirectoryHandle);\n                break;\n            }\n          })(),\n        );\n      }\n      await Promise.all(promises);\n    };\n\n    await recurse(this._root!);\n\n    return {\n      used,\n    };\n  }\n}\n\n// TODO(mykola): Remove EventEmitter.\n// @trace.resource()\nexport class WebFile extends EventEmitter implements File {\n  @trace.info()\n  readonly fileName: string;\n\n  private readonly _fileHandle: Promise<FileSystemFileHandle>;\n  private readonly _destroy: () => Promise<void>;\n\n  /**\n   * Current view of the file contents.\n   */\n  private _buffer: Uint8Array | null = null;\n\n  private _loadBufferPromise: Promise<void> | null = null;\n\n  private _flushScheduled = false;\n  private _flushPromise: Promise<void> = Promise.resolve();\n  /**\n   * Used to discard unnecessary scheduled flushes.\n   * If _flushNow() is called with a lower sequence number it should early exit.\n   */\n  private _flushSequence = 0;\n\n  //\n  // Metrics\n  //\n\n  @trace.metricsCounter()\n  private _flushes = new TimeSeriesCounter();\n\n  @trace.metricsCounter()\n  private _operations = new TimeSeriesCounter();\n\n  @trace.metricsCounter()\n  private _reads = new TimeSeriesCounter();\n\n  @trace.metricsCounter()\n  private _readBytes = new TimeSeriesCounter();\n\n  @trace.metricsCounter()\n  private _writes = new TimeSeriesCounter();\n\n  @trace.metricsCounter()\n  private _writeBytes = new TimeSeriesCounter();\n\n  @trace.info()\n  get _bufferSize() {\n    return this._buffer?.length;\n  }\n\n  constructor({\n    fileName,\n    file,\n    destroy,\n  }: {\n    file: Promise<FileSystemFileHandle>;\n    fileName: string;\n    destroy: () => Promise<void>;\n  }) {\n    super();\n    this.fileName = fileName;\n    this._fileHandle = file;\n    this._destroy = destroy;\n\n    void this._loadBufferGuarded();\n  }\n\n  type: StorageType = StorageType.WEBFS;\n\n  //\n  // random-access-storage library compatibility\n  //\n\n  // TODO(dmaretskyi): Are those all needed?\n  readonly opened: boolean = true;\n  readonly suspended: boolean = false;\n  readonly closed: boolean = false;\n  readonly unlinked: boolean = false;\n  readonly writing: boolean = false;\n  readonly readable: boolean = true;\n  readonly writable: boolean = true;\n  readonly deletable: boolean = true;\n  readonly truncatable: boolean = true;\n  readonly statable: boolean = true;\n\n  destroyed = false;\n  directory = '';\n  // TODO(dmaretskyi): is this used?\n  filename = '';\n  native: RandomAccessStorage = {\n    write: callbackify(this.write.bind(this)),\n    read: callbackify(this.read.bind(this)),\n    del: callbackify(this.del.bind(this)),\n    stat: callbackify(this.stat.bind(this)),\n    destroy: callbackify(this.destroy.bind(this)),\n    truncate: callbackify(this.truncate?.bind(this)),\n  } as any as RandomAccessStorage;\n\n  private async _loadBuffer(): Promise<void> {\n    const fileHandle = await this._fileHandle;\n    const file = await fileHandle.getFile();\n    this._buffer = new Uint8Array(await file.arrayBuffer());\n  }\n\n  private async _loadBufferGuarded(): Promise<void> {\n    await (this._loadBufferPromise ??= this._loadBuffer());\n  }\n\n  // Do not call directly, use _flushLater or _flushNow.\n  private async _flushCache(sequence: number): Promise<void> {\n    if (this.destroyed || sequence < this._flushSequence) {\n      return;\n    }\n    this._flushSequence = sequence + 1;\n\n    this._flushes.inc();\n\n    await this._loadBufferGuarded();\n    invariant(this._buffer);\n\n    const fileHandle = await this._fileHandle;\n    const writable = await fileHandle.createWritable({ keepExistingData: true });\n    await writable.write({ type: 'write', data: this._buffer, position: 0 });\n    await writable.close();\n  }\n\n  private _flushLater(): void {\n    if (this._flushScheduled) {\n      return;\n    }\n\n    const sequence = this._flushSequence;\n    setTimeout(async () => {\n      // Making sure only one flush can run at a time.\n      await this._flushPromise;\n      this._flushScheduled = false;\n      this._flushPromise = this._flushCache(sequence).catch((err) => log.warn(err));\n    });\n\n    this._flushScheduled = true;\n  }\n\n  private async _flushNow(): Promise<void> {\n    await this._flushPromise;\n    this._flushPromise = this._flushCache(this._flushSequence).catch((err) => log.warn(err));\n    await this._flushPromise;\n  }\n\n  async read(offset: number, size: number): Promise<Buffer> {\n    this.assertNotDestroyed('Read');\n\n    this._operations.inc();\n    this._reads.inc();\n    this._readBytes.inc(size);\n\n    if (!this._buffer) {\n      await this._loadBufferGuarded();\n      invariant(this._buffer);\n    }\n\n    if (offset + size > this._buffer.length) {\n      throw new Error('Read out of bounds');\n    }\n\n    // Copy data into a new buffer.\n    return Buffer.from(this._buffer.slice(offset, offset + size));\n  }\n\n  async write(offset: number, data: Buffer): Promise<void> {\n    this.assertNotDestroyed('Write');\n\n    this._operations.inc();\n    this._writes.inc();\n    this._writeBytes.inc(data.length);\n\n    if (!this._buffer) {\n      await this._loadBufferGuarded();\n      invariant(this._buffer);\n    }\n\n    if (offset + data.length <= this._buffer.length) {\n      this._buffer.set(data, offset);\n    } else {\n      // TODO(dmaretskyi): Optimize re-allocations.\n      const newCache = new Uint8Array(offset + data.length);\n      newCache.set(this._buffer);\n      newCache.set(data, offset);\n      this._buffer = newCache;\n    }\n\n    this._flushLater();\n  }\n\n  async del(offset: number, size: number): Promise<void> {\n    this.assertNotDestroyed('Del');\n\n    this._operations.inc();\n\n    if (offset < 0 || size <= 0) {\n      return;\n    }\n\n    if (!this._buffer) {\n      await this._loadBufferGuarded();\n      invariant(this._buffer);\n    }\n\n    let leftoverSize = 0;\n    if (offset + size < this._buffer.length) {\n      leftoverSize = this._buffer.length - (offset + size);\n      this._buffer.set(this._buffer.slice(offset + size, offset + size + leftoverSize), offset);\n    }\n\n    this._buffer = this._buffer.slice(0, offset + leftoverSize);\n\n    this._flushLater();\n  }\n\n  async stat(): Promise<{ size: number }> {\n    this.assertNotDestroyed('Truncate');\n\n    this._operations.inc();\n\n    // NOTE: This will load all data from the file just to get it's size. While this is a lot of overhead, this works ok for out use cases.\n    if (!this._buffer) {\n      await this._loadBufferGuarded();\n      invariant(this._buffer);\n    }\n\n    return {\n      size: this._buffer.length,\n    };\n  }\n\n  async truncate(offset: number): Promise<void> {\n    this.assertNotDestroyed('Truncate');\n\n    this._operations.inc();\n\n    if (!this._buffer) {\n      await this._loadBufferGuarded();\n      invariant(this._buffer);\n    }\n\n    this._buffer = this._buffer.slice(0, offset);\n\n    this._flushLater();\n  }\n\n  async flush(): Promise<void> {\n    this.assertNotDestroyed('Flush');\n\n    await this._flushNow();\n  }\n\n  /**\n   * It's best to avoid using this method as it doesn't really close a file.\n   * We could update the _opened flag and add a guard like for destroyed, but this would break\n   * the FileSystemFileHandle sharing required for browser tests to run, where writes are\n   * not immediately visible if using different file handles.\n   */\n  async close(): Promise<void> {\n    await this._flushNow();\n  }\n\n  @synchronized\n  async destroy(): Promise<void> {\n    if (!this.destroyed) {\n      // We need to flush the buffer before destroying a file so that the call to a storage API\n      // finds an entry for deletion\n      await this._flushNow();\n      this.destroyed = true;\n      return await this._destroy();\n    }\n  }\n\n  private assertNotDestroyed(operation: string): void {\n    if (this.destroyed) {\n      throw new Error(`${operation} on a destroyed or closed file`);\n    }\n  }\n}\n", "//\n// Copyright 2021 DXOS.org\n//\n\nimport { IDbStorage } from './idb-storage';\nimport { WebFS } from './web-fs';\nimport { MemoryStorage, StorageType, type Storage, type StorageConstructor } from '../common';\n\nexport const createStorage: StorageConstructor = ({ type, root = '' } = {}): Storage => {\n  if (type === undefined) {\n    return new IDbStorage(root);\n  }\n\n  switch (type) {\n    case StorageType.RAM: {\n      return new MemoryStorage(root);\n    }\n\n    case StorageType.IDB:\n    case StorageType.CHROME:\n    case StorageType.FIREFOX: {\n      return new IDbStorage(root);\n    }\n\n    case StorageType.WEBFS: {\n      return new WebFS(root);\n    }\n\n    default: {\n      throw new Error(`Invalid type: ${type}`);\n    }\n  }\n};\n"],
  "mappings": "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",
  "names": ["DELIM", "idb", "self", "err", "i", "join", "inspect", "inspectObject", "log", "join", "stringDiff", "first", "second", "split", "join", "getFullPath", "root", "path", "Directory", "type", "path", "list", "getOrCreateFile", "remove", "onFlush", "_list", "_getOrCreateFile", "_remove", "_onFlush", "toString", "JSON", "stringify", "createDirectory", "getFullPath", "filename", "opts", "flush", "delete", "pify", "log", "MAX_STORAGE_OPERATION_TIME", "pifyFields", "object", "type", "fields", "field", "fn", "bind", "args", "before", "performance", "now", "res", "elapsed", "operation", "wrapFile", "native", "file", "Object", "assign", "AbstractStorage", "path", "_files", "Map", "inspect", "custom", "inspectObject", "toJSON", "type", "size", "createDirectory", "sub", "Directory", "getFullPath", "list", "_list", "bind", "getOrCreateFile", "args", "remove", "_remove", "reset", "log", "info", "_closeFilesInPath", "_destroy", "err", "catch", "Array", "from", "_getFiles", "keys", "map", "filename", "name", "replace", "startsWith", "substring", "opts", "fullPath", "join", "native", "file", "_getFileIfExists", "closed", "_openFile", "_createFile", "wrapFile", "set", "undefined", "has", "get", "destroyed", "entries", "filter", "includes", "Promise", "all", "values", "close", "destroy", "then", "delete", "error", "message", "ram", "arrayToBuffer", "StorageType", "MemoryStorage", "AbstractStorage", "type", "StorageType", "RAM", "_createFile", "path", "filename", "_patchFile", "ram", "_openFile", "file", "newFile", "clone", "closed", "trueRead", "read", "bind", "offset", "size", "cb", "err", "data", "arrayToBuffer", "getDiskInfo", "used", "_files", "values", "length", "Number", "isNaN", "invariant", "DELIM", "IDbStorage", "AbstractStorage", "path", "type", "StorageType", "IDB", "_store", "_initialized", "_fileStorage", "_createFileStorage", "database", "idb", "res", "_db", "Promise", "resolve", "getdb", "create", "close", "_closeFilesInPath", "reset", "_remove", "_destroy", "Error", "_createFile", "filename", "file", "getFullPath", "destroy", "cb", "then", "db", "lowerBound", "upperBound", "range", "IDBKeyRange", "bound", "transaction", "objectStore", "delete", "oncomplete", "destroyed", "unlinked", "closed", "onerror", "error", "deletable", "_loadFiles", "invariant", "request", "openCursor", "reject", "onsuccess", "event", "cursor", "target", "result", "String", "key", "split", "_files", "has", "set", "wrapFile", "continue", "_getFiles", "EventEmitter", "callbackify", "synchronized", "invariant", "log", "TimeSeriesCounter", "trace", "WebFS", "path", "_files", "Map", "type", "StorageType", "WEBFS", "size", "_getFiles", "fullName", "_getFullFilename", "entries", "filter", "file", "includes", "destroyed", "_list", "root", "_initialize", "entry", "keys", "startsWith", "endsWith", "push", "slice", "length", "_root", "navigator", "storage", "getDirectory", "invariant", "createDirectory", "sub", "Directory", "getFullPath", "list", "getOrCreateFile", "args", "remove", "_delete", "onFlush", "Promise", "all", "Array", "from", "map", "_", "flush", "filename", "opts", "existingFile", "get", "_createFile", "set", "WebFile", "fileName", "then", "getFileHandle", "create", "destroy", "delete", "removeEntry", "catch", "err", "log", "warn", "reset", "recursive", "undefined", "close", "values", "e", "replace", "getDiskInfo", "used", "recurse", "handle", "promises", "kind", "getFile", "f", "EventEmitter", "_buffer", "_loadBufferPromise", "_flushScheduled", "_flushPromise", "resolve", "_flushSequence", "_flushes", "TimeSeriesCounter", "_operations", "_reads", "_readBytes", "_writes", "_writeBytes", "opened", "suspended", "closed", "unlinked", "writing", "readable", "writable", "deletable", "truncatable", "statable", "directory", "native", "write", "callbackify", "bind", "read", "del", "stat", "truncate", "_fileHandle", "_destroy", "_loadBufferGuarded", "_bufferSize", "_loadBuffer", "fileHandle", "Uint8Array", "arrayBuffer", "_flushCache", "sequence", "inc", "createWritable", "keepExistingData", "data", "position", "_flushLater", "setTimeout", "_flushNow", "offset", "assertNotDestroyed", "Error", "Buffer", "newCache", "leftoverSize", "operation", "info", "metricsCounter", "createStorage", "type", "root", "undefined", "IDbStorage", "StorageType", "RAM", "MemoryStorage", "IDB", "CHROME", "FIREFOX", "WEBFS", "WebFS", "Error"]
}
