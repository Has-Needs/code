import { createRequire } from 'node:module';const require = createRequire(import.meta.url);

// packages/core/mesh/rpc-tunnel/src/ports/iframe.ts
import { UAParser } from "ua-parser-js";
import { log } from "@dxos/log";
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/core/mesh/rpc-tunnel/src/ports/iframe.ts";
var browser;
var os;
if (typeof navigator !== "undefined") {
  const parser = new UAParser(navigator.userAgent);
  browser = parser.getBrowser().name;
  os = parser.getOS().name;
}
var sendToIFrame = (iframe, origin, message) => {
  if (!iframe.contentWindow) {
    log("IFrame content window missing", {
      origin
    }, {
      F: __dxlog_file,
      L: 24,
      S: void 0,
      C: (f, a) => f(...a)
    });
    return;
  }
  if (browser === "Chrome" && os === "iOS") {
    iframe.contentWindow.postMessage(message, origin);
  } else {
    iframe.contentWindow.postMessage(message, origin, [
      message.payload
    ]);
  }
};
var sendToParentWindow = (origin, message) => {
  if (browser === "Chrome" && os === "iOS") {
    window.parent.postMessage(message, origin);
  } else {
    window.parent.postMessage(message, origin, [
      message.payload
    ]);
  }
};
var createIFramePort = ({ channel, iframe, origin, onOrigin }) => {
  return {
    send: async (data) => {
      if (!origin) {
        log("no origin set", {
          channel
        }, {
          F: __dxlog_file,
          L: 62,
          S: void 0,
          C: (f, a) => f(...a)
        });
        return;
      }
      log("sending", {
        channel,
        data: data.length
      }, {
        F: __dxlog_file,
        L: 66,
        S: void 0,
        C: (f, a) => f(...a)
      });
      const payload = data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
      const message = {
        channel,
        payload
      };
      if (iframe) {
        sendToIFrame(iframe, origin, message);
      } else {
        sendToParentWindow(origin, message);
      }
    },
    subscribe: (callback) => {
      const handler = (event) => {
        if (!iframe && event.source !== window.parent) {
          return;
        } else if (iframe && event.source !== iframe.contentWindow) {
          return;
        }
        const isMessageData = event.data && typeof event.data === "object" && "channel" in event.data && "payload" in event.data;
        const message = isMessageData ? event.data : void 0;
        if (message?.channel !== channel) {
          return;
        }
        if (!origin) {
          origin = event.origin;
          onOrigin?.(origin);
        }
        log("received", message, {
          F: __dxlog_file,
          L: 98,
          S: void 0,
          C: (f, a) => f(...a)
        });
        callback(new Uint8Array(message.payload));
      };
      window.addEventListener("message", handler);
      return () => window.removeEventListener("message", handler);
    }
  };
};
var createIFrame = (source, id, { hidden = true, allow } = {}) => {
  const create = () => {
    const iframe = document.createElement("iframe");
    iframe.id = id;
    iframe.src = source;
    hidden && iframe.setAttribute("style", "display: none;");
    allow && iframe.setAttribute("allow", allow);
    document.body.appendChild(iframe);
    return iframe;
  };
  return document.getElementById(id) ?? create();
};

// packages/core/mesh/rpc-tunnel/src/ports/worker.ts
import { log as log2 } from "@dxos/log";
var __dxlog_file2 = "/home/runner/work/dxos/dxos/packages/core/mesh/rpc-tunnel/src/ports/worker.ts";
var createWorkerPort = ({ port, channel, subscribe }) => ({
  send: async (message) => {
    const payload = message.buffer.slice(message.byteOffset, message.byteOffset + message.byteLength);
    port.postMessage({
      channel,
      payload
    }, [
      payload
    ]);
  },
  subscribe: subscribe ?? ((callback) => {
    const handler = (event) => {
      const message = event.data;
      if (channel && message.channel !== channel) {
        return;
      }
      log2.debug("received", {
        message
      }, {
        F: __dxlog_file2,
        L: 46,
        S: void 0,
        C: (f, a) => f(...a)
      });
      callback(new Uint8Array(message.payload));
    };
    port.onmessage = handler;
    return () => {
      port.onmessage = null;
    };
  })
});

// packages/core/mesh/rpc-tunnel/src/port-muxer.ts
import { log as log3 } from "@dxos/log";
var __dxlog_file3 = "/home/runner/work/dxos/dxos/packages/core/mesh/rpc-tunnel/src/port-muxer.ts";
var PortMuxer = class {
  constructor(_messagePort) {
    this._messagePort = _messagePort;
    this._activeChannels = /* @__PURE__ */ new Map();
    this._rpcPorts = /* @__PURE__ */ new Map();
    if (this._messagePort) {
      this._messagePort.onmessage = (event) => this.onWorkerMessage(event);
    }
    if (typeof window !== "undefined") {
      window.addEventListener("message", (event) => this.onWindowMessage(event));
    }
  }
  createWorkerPort(options) {
    if (!this._messagePort) {
      throw new Error("Message port is required to create worker ports");
    }
    const port = createWorkerPort({
      ...options,
      port: this._messagePort,
      subscribe: (callback) => {
        this._activeChannels.set(options.channel, callback);
        return () => this._activeChannels.delete(options.channel);
      }
    });
    this._rpcPorts.set(options.channel, port);
    return port;
  }
  createIFramePort(options) {
    const port = createIFramePort(options);
    this._rpcPorts.set(options.channel, port);
    return port;
  }
  onWorkerMessage(event) {
    const message = event.data;
    log3.debug("Recieved message from worker port", {
      channel: message.channel,
      payload: message.payload
    }, {
      F: __dxlog_file3,
      L: 56,
      S: this,
      C: (f, a) => f(...a)
    });
    const callback = this._activeChannels.get(message.channel);
    callback?.(new Uint8Array(message.payload));
  }
  onWindowMessage(event) {
    const message = event.data;
    log3.debug("Recieved message from window", {
      channel: message.channel,
      payload: message.payload
    }, {
      F: __dxlog_file3,
      L: 67,
      S: this,
      C: (f, a) => f(...a)
    });
  }
};
export {
  PortMuxer,
  createIFrame,
  createIFramePort,
  createWorkerPort
};
//# sourceMappingURL=index.mjs.map
