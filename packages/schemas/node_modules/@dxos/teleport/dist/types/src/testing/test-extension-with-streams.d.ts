import { Trigger } from '@dxos/async';
import { type ExtensionContext, type TeleportExtension } from '../teleport';
interface TestExtensionWithStreamsCallbacks {
    onOpen?: () => Promise<void>;
    onClose?: () => Promise<void>;
    onAbort?: () => Promise<void>;
}
export declare class TestExtensionWithStreams implements TeleportExtension {
    readonly callbacks: TestExtensionWithStreamsCallbacks;
    readonly open: Trigger<void>;
    readonly closed: Trigger<void>;
    readonly aborted: Trigger<void>;
    private readonly _streams;
    extensionContext: ExtensionContext | undefined;
    private _rpc;
    constructor(callbacks?: TestExtensionWithStreamsCallbacks);
    get remotePeerId(): import("@dxos/keys").PublicKey | undefined;
    private _openStream;
    private _closeStream;
    onOpen(context: ExtensionContext): Promise<void>;
    onClose(err?: Error): Promise<void>;
    onAbort(err?: Error): Promise<void>;
    addNewStream(streamLoadInterval: number, streamLoadChunkSize: number, streamTag?: string): Promise<string>;
    closeStream(streamTag: string): Promise<TestStreamStats>;
    /**
     * Force-close the connection.
     */
    closeConnection(err?: Error): Promise<void>;
}
type Stats = {
    bytesSent: number;
    bytesReceived: number;
    sendErrors: number;
    receiveErrors: number;
    runningTime: number;
};
export type TestStreamStats = {
    streamTag: string;
    stats: {
        local: Stats;
        remote: Stats;
    };
};
export {};
//# sourceMappingURL=test-extension-with-streams.d.ts.map