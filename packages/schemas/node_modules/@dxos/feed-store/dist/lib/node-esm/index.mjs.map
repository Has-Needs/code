{
  "version": 3,
  "sources": ["../../../src/feed-iterator.ts", "../../../src/feed-queue.ts", "../../../src/feed-set-iterator.ts", "../../../src/feed-writer.ts"],
  "sourcesContent": ["//\n// Copyright 2020 DXOS.org\n//\n\nimport safeRace from 'race-as-promised';\n\nimport { Trigger } from '@dxos/async';\nimport { invariant } from '@dxos/invariant';\nimport { log } from '@dxos/log';\n\nimport { FeedQueue } from './feed-queue';\nimport { type FeedWrapper } from './feed-wrapper';\nimport { type FeedBlock } from './types';\n\n/**\n * Base class for an async iterable feed.\n */\nexport abstract class AbstractFeedIterator<T> implements AsyncIterable<FeedBlock<T>> {\n  private readonly _stopTrigger = new Trigger();\n\n  protected _open = false;\n  protected _running = false;\n\n  toJSON(): { open: boolean; running: boolean } {\n    return {\n      open: this.isOpen,\n      running: this.isRunning,\n    };\n  }\n\n  get isOpen() {\n    return this._open;\n  }\n\n  get isRunning() {\n    return this._running;\n  }\n\n  async open(): Promise<void> {\n    if (!this._open) {\n      log('opening...');\n      await this._onOpen();\n      this._open = true;\n\n      await this.start();\n      log('opened');\n    }\n  }\n\n  async close(): Promise<void> {\n    if (this._open) {\n      log('closing...');\n      await this.stop();\n\n      await this._onClose();\n      this._open = false;\n      log('closed');\n    }\n  }\n\n  async start(): Promise<void> {\n    invariant(this._open);\n    if (!this._running) {\n      this._running = true;\n    }\n  }\n\n  async stop(): Promise<void> {\n    invariant(this._open);\n    if (this._running) {\n      this._running = false;\n      this._stopTrigger.wake();\n    }\n  }\n\n  //\n  // AsyncIterable\n  //\n\n  [Symbol.asyncIterator]() {\n    return this._generator();\n  }\n\n  async *_generator() {\n    log('started');\n    while (this._running) {\n      // https://github.com/nodejs/node/issues/17469\n      const block = await safeRace([this._stopTrigger.wait(), this._nextBlock()]);\n\n      if (block === undefined) {\n        break;\n      }\n\n      yield block;\n    }\n\n    log('stopped');\n  }\n\n  abstract _onOpen(): Promise<void>;\n  abstract _onClose(): Promise<void>;\n  abstract _nextBlock(): Promise<FeedBlock<T> | undefined>;\n}\n\n/**\n * Iterator that reads blocks from a single feed.\n */\nexport class FeedIterator<T extends {}> extends AbstractFeedIterator<T> {\n  private readonly _queue: FeedQueue<T>;\n\n  constructor(private readonly _feed: FeedWrapper<T>) {\n    super();\n    this._queue = new FeedQueue<T>(this._feed);\n  }\n\n  override async _onOpen(): Promise<void> {\n    await this._queue.open();\n  }\n\n  override async _onClose(): Promise<void> {\n    await this._queue.close();\n  }\n\n  override async _nextBlock(): Promise<FeedBlock<T> | undefined> {\n    return this._queue.pop();\n  }\n}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { inspect } from 'node:util';\nimport { Writable } from 'streamx';\n\nimport { Event, latch, Trigger } from '@dxos/async';\nimport { inspectObject } from '@dxos/debug';\nimport type { ReadStreamOptions } from '@dxos/hypercore';\nimport { invariant } from '@dxos/invariant';\nimport { log } from '@dxos/log';\n\nimport { type FeedWrapper } from './feed-wrapper';\nimport { type FeedBlock } from './types';\n\nexport const defaultReadStreamOptions: ReadStreamOptions = {\n  live: true, // Keep reading until closed.\n  batch: 1024, // Read in batches.\n};\n\nexport type FeedQueueOptions = {};\n\n/**\n * Async queue using an AsyncIterator created from a hypercore.\n */\nexport class FeedQueue<T extends {}> {\n  public updated = new Event<FeedQueue<T>>();\n\n  private readonly _messageTrigger = new Trigger<FeedBlock<T>>({\n    autoReset: true,\n  });\n\n  private _feedConsumer?: Writable = undefined;\n  private _next?: () => void;\n  private _currentBlock?: FeedBlock<T> = undefined;\n  private _index = -1;\n\n  // prettier-ignore\n  constructor(\n    private readonly _feed: FeedWrapper<T>,\n    private readonly _options: FeedQueueOptions = {},\n  ) {}\n\n  [inspect.custom](): string {\n    return inspectObject(this);\n  }\n\n  toJSON() {\n    return {\n      feedKey: this._feed.key,\n      index: this.index,\n      length: this.length,\n      open: this.isOpen,\n    };\n  }\n\n  get feed() {\n    return this._feed;\n  }\n\n  get isOpen(): boolean {\n    return Boolean(this._feedConsumer);\n  }\n\n  get length(): number {\n    return this._feed.properties.length;\n  }\n\n  /**\n   * Index (seq) of the NEXT block to be read, or -1 if not open.\n   */\n  get index() {\n    return this._index;\n  }\n\n  /**\n   * Opens (or reopens) the queue.\n   * @param options.start Starting index. First mutation to be read would have `seq == options.start`.\n   */\n  async open(options: ReadStreamOptions = {}): Promise<void> {\n    if (this.isOpen) {\n      // TODO(burdon): Warn if re-opening (e.g., with different starting point).\n      return;\n    }\n\n    this._index = options.start ?? 0;\n    // if (this._index !== 0) {\n    //   console.warn('Start index not yet supported.');\n    // }\n\n    log('opening', { feedKey: this._feed.key });\n\n    // TODO(burdon): Open with starting range.\n    const opts = Object.assign({}, defaultReadStreamOptions, options);\n    const feedStream = this._feed.createReadableStream(opts);\n\n    this._feedConsumer = new Writable({\n      write: (data: any, next: () => void) => {\n        this._next = () => {\n          this._next = undefined;\n          this._currentBlock = undefined;\n          this._index++;\n          next();\n        };\n\n        this._currentBlock = {\n          feedKey: this._feed.key,\n          seq: this._index,\n          data,\n        };\n\n        this._messageTrigger.wake(this._currentBlock);\n        this.updated.emit(this);\n      },\n    });\n\n    const onClose = () => {\n      this.feed.core.off('close', onClose);\n      this._feedConsumer?.off('close', onClose);\n      this._feedConsumer?.off('error', onError);\n\n      this._destroyConsumer();\n    };\n\n    const onError = (err?: Error) => {\n      if (!err) {\n        return;\n      }\n\n      if (err.message === 'Writable stream closed prematurely' || err.message === 'Feed is closed') {\n        return;\n      }\n\n      log.catch(err, { feedKey: this._feed.key });\n    };\n\n    // Called if feed is closed externally.\n    this._feed.core.once('close', onClose);\n    this._feedConsumer.on('error', onError);\n\n    // Called when queue is closed. Throws exception if waiting for `pop`.\n    this._feedConsumer.once('close', onClose);\n\n    // Pipe readable stream into writable consumer.\n    feedStream.pipe(this._feedConsumer, (err) => {\n      if (err) {\n        onError(err);\n      }\n      this._destroyConsumer();\n    });\n\n    log('opened');\n  }\n\n  /**\n   * Closes the queue.\n   */\n  async close(): Promise<void> {\n    if (this.isOpen) {\n      invariant(this._feedConsumer);\n      invariant(!this._feed.properties.closed);\n\n      log('closing', { feedKey: this._feed.key });\n      const [closed, setClosed] = latch();\n      this._feedConsumer.once('close', setClosed);\n      this._feedConsumer.destroy();\n      this._next?.(); // Release any message currently in the queue (otherwise destroy will block).\n      await closed();\n      log('closed');\n    }\n  }\n\n  /**\n   * Get the block at the head of the queue without removing it.\n   */\n  peek(): FeedBlock<T> | undefined {\n    return this._currentBlock;\n  }\n\n  /**\n   * Pop block at the head of the queue.\n   */\n  async pop(): Promise<FeedBlock<T>> {\n    if (!this.isOpen) {\n      throw new Error(`Queue closed: ${this.feed.key.truncate()}`);\n    }\n\n    let block = this.peek();\n    if (!block) {\n      block = await this._messageTrigger.wait();\n    }\n\n    if (block) {\n      this._next?.();\n    }\n\n    return block;\n  }\n\n  private _destroyConsumer(): void {\n    if (this._feedConsumer) {\n      log('queue closed', { feedKey: this._feed.key });\n      this._feedConsumer = undefined;\n      this._next = undefined;\n      this._currentBlock = undefined;\n      this._index = -1;\n    }\n  }\n}\n", "//\n// Copyright 2020 DXOS.org\n//\n\nimport { inspect } from 'node:util';\n\nimport { Event, SubscriptionList, Trigger } from '@dxos/async';\nimport { inspectObject } from '@dxos/debug';\nimport { invariant } from '@dxos/invariant';\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { ComplexMap, isNonNullable } from '@dxos/util';\n\nimport { AbstractFeedIterator } from './feed-iterator';\nimport { FeedQueue } from './feed-queue';\nimport { type FeedWrapper } from './feed-wrapper';\nimport { type FeedBlock } from './types';\n\n/**\n * Select next block.\n */\nexport type FeedBlockSelector<T> = (blocks: FeedBlock<T>[]) => number | undefined;\n\nexport type FeedIndex = {\n  feedKey: PublicKey;\n  index: number;\n};\n\nexport type FeedSetIteratorOptions = {\n  // TODO(burdon): Should we remove this and assume the feeds are positioned before adding?\n  start?: FeedIndex[];\n  stallTimeout?: number;\n};\n\nexport const defaultFeedSetIteratorOptions = {\n  stallTimeout: 1000,\n};\n\n/**\n * Iterator that reads blocks from multiple feeds, ordering them based on a traversal callback.\n */\nexport class FeedSetIterator<T extends {}> extends AbstractFeedIterator<T> {\n  private readonly _feedQueues = new ComplexMap<PublicKey, FeedQueue<T>>(PublicKey.hash);\n\n  private readonly _trigger = new Trigger({ autoReset: true });\n  private readonly _subscriptions = new SubscriptionList();\n\n  public readonly stalled = new Event<FeedSetIterator<T>>();\n\n  constructor(\n    private readonly _selector: FeedBlockSelector<T>,\n    public readonly options: FeedSetIteratorOptions = defaultFeedSetIteratorOptions,\n  ) {\n    super();\n    invariant(_selector);\n    invariant(options);\n  }\n\n  [inspect.custom](): string {\n    return inspectObject(this);\n  }\n\n  override toJSON(): { open: boolean; running: boolean; indexes: FeedIndex[] } {\n    return {\n      open: this.isOpen,\n      running: this.isRunning,\n      indexes: this.indexes,\n    };\n  }\n\n  get size() {\n    return this._feedQueues.size;\n  }\n\n  get feeds(): FeedWrapper<T>[] {\n    return Array.from(this._feedQueues.values()).map((feedQueue) => feedQueue.feed);\n  }\n\n  get indexes(): FeedIndex[] {\n    return Array.from(this._feedQueues.values()).map((feedQueue) => ({\n      feedKey: feedQueue.feed.key,\n      index: feedQueue.index,\n    }));\n  }\n\n  reiterateBlock(block: FeedBlock<T>): void {\n    this._trigger.wake();\n  }\n\n  async addFeed(feed: FeedWrapper<T>): Promise<void> {\n    invariant(!this._feedQueues.has(feed.key), `Feed already added: ${feed.key}`);\n    invariant(feed.properties.opened);\n    log('feed added', { feedKey: feed.key });\n\n    // Create queue and listen for updates.\n    const queue = new FeedQueue<T>(feed);\n    this._feedQueues.set(feed.key, queue);\n    this._subscriptions.add(\n      queue.updated.on(() => {\n        this._trigger.wake();\n      }),\n    );\n\n    await queue.open({\n      start: this.options.start?.find((index) => index.feedKey.equals(feed.key))?.index,\n    });\n\n    // Wake when feed added or queue updated.\n    this._trigger.wake();\n  }\n\n  hasFeed(feedKey: PublicKey): boolean {\n    return this._feedQueues.has(feedKey);\n  }\n\n  override async _onOpen(): Promise<void> {\n    for (const queue of this._feedQueues.values()) {\n      await queue.open();\n    }\n  }\n\n  override async _onClose(): Promise<void> {\n    this._subscriptions.clear();\n    await Promise.all(Array.from(this._feedQueues.values()).map((queue) => queue.close()));\n\n    // Wake when feed added or queue updated.\n    this._trigger.wake();\n  }\n\n  /**\n   * Gets the next block from the selected queue.\n   */\n  override async _nextBlock(): Promise<FeedBlock<T> | undefined> {\n    let t: NodeJS.Timeout | undefined;\n\n    while (this._running) {\n      // Get blocks from the head of each queue.\n      const queues = Array.from(this._feedQueues.values());\n      const blocks = queues.map((queue) => queue.peek()).filter(isNonNullable);\n      if (blocks.length) {\n        // Get the selected block from candidates.\n        const idx = this._selector(blocks);\n        log('selected', { idx, blocks });\n        if (idx === undefined) {\n          // Timeout if all candidates are rejected.\n          if (t === undefined) {\n            t = setTimeout(() => {\n              this.stalled.emit(this);\n              this._trigger.wake();\n            }, this.options.stallTimeout);\n          }\n        } else {\n          if (t !== undefined) {\n            clearTimeout(t);\n            t = undefined;\n          }\n          if (idx >= blocks.length) {\n            throw new Error(`Index out of bounds: ${idx} of ${blocks.length}`);\n          }\n\n          // Pop from queue.\n          const queue = this._feedQueues.get(blocks[idx].feedKey)!;\n          log('popping', queue.toJSON());\n          try {\n            const message = await queue.pop();\n            invariant(message === blocks[idx]);\n            return message;\n          } catch (err) {\n            // TODO(burdon): Same queue closed twice.\n            log.warn('queue closed', { feedKey: queue.feed.key });\n            // console.log(Array.from(this._feedQueues.values()));\n          }\n        }\n      }\n\n      // Wait until feed added, new block, or closing.\n      await this._trigger.wait();\n    }\n  }\n}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { type PublicKey } from '@dxos/keys';\n\nexport type WriteReceipt = {\n  feedKey: PublicKey;\n  seq: number;\n};\n\nexport type WriteOptions = {\n  /**\n   * Called after the write is complete.\n   * Runs and completes before the mutation is read from the pipeline.\n   */\n  afterWrite?: (receipt: WriteReceipt) => Promise<void>;\n};\n\nexport interface FeedWriter<T extends {}> {\n  /**\n   * Write data to the feed.\n   * Awaits `afterWrite` before returning.\n   */\n  write(data: T, options?: WriteOptions): Promise<WriteReceipt>;\n}\n\nexport const createFeedWriter = <T extends {}>(cb: (data: T) => Promise<WriteReceipt>): FeedWriter<T> => ({\n  write: async (data: T) => {\n    return cb(data);\n  },\n});\n\nexport const writeMessages = async <T extends {}>(writer: FeedWriter<T>, messages: T[]): Promise<WriteReceipt[]> => {\n  const receipts: WriteReceipt[] = [];\n  // NOTE: Write messages sequentially.\n  for (const message of messages) {\n    receipts.push(await writer.write(message));\n  }\n  return receipts;\n};\n"],
  "mappings": "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",
  "names": ["safeRace", "Trigger", "invariant", "log", "inspect", "Writable", "Event", "latch", "Trigger", "inspectObject", "invariant", "log", "defaultReadStreamOptions", "live", "batch", "FeedQueue", "_feed", "_options", "updated", "_messageTrigger", "autoReset", "_feedConsumer", "undefined", "_currentBlock", "_index", "custom", "toJSON", "feedKey", "key", "index", "length", "open", "isOpen", "feed", "Boolean", "properties", "options", "start", "opts", "Object", "assign", "feedStream", "createReadableStream", "write", "data", "next", "_next", "seq", "wake", "emit", "onClose", "core", "off", "onError", "_destroyConsumer", "err", "message", "catch", "once", "on", "pipe", "close", "closed", "setClosed", "destroy", "peek", "pop", "Error", "truncate", "block", "wait", "AbstractFeedIterator", "_stopTrigger", "Trigger", "_open", "_running", "toJSON", "open", "isOpen", "running", "isRunning", "log", "_onOpen", "start", "close", "stop", "_onClose", "invariant", "wake", "Symbol", "asyncIterator", "_generator", "block", "safeRace", "wait", "_nextBlock", "undefined", "FeedIterator", "_feed", "_queue", "FeedQueue", "pop", "inspect", "Event", "SubscriptionList", "Trigger", "inspectObject", "invariant", "PublicKey", "log", "ComplexMap", "isNonNullable", "defaultFeedSetIteratorOptions", "stallTimeout", "FeedSetIterator", "AbstractFeedIterator", "_selector", "options", "_feedQueues", "ComplexMap", "PublicKey", "hash", "_trigger", "Trigger", "autoReset", "_subscriptions", "SubscriptionList", "stalled", "Event", "invariant", "inspect", "custom", "inspectObject", "toJSON", "open", "isOpen", "running", "isRunning", "indexes", "size", "feeds", "Array", "from", "values", "map", "feedQueue", "feed", "feedKey", "key", "index", "reiterateBlock", "block", "wake", "addFeed", "has", "properties", "opened", "log", "queue", "FeedQueue", "set", "add", "updated", "on", "start", "find", "equals", "hasFeed", "_onOpen", "_onClose", "clear", "Promise", "all", "close", "_nextBlock", "t", "_running", "queues", "blocks", "peek", "filter", "isNonNullable", "length", "idx", "undefined", "setTimeout", "emit", "clearTimeout", "Error", "get", "message", "pop", "err", "warn", "wait", "createFeedWriter", "cb", "write", "data", "writeMessages", "writer", "messages", "receipts", "message", "push"]
}
