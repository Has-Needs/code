{
  "version": 3,
  "sources": ["../../../src/feed-wrapper.ts", "../../../src/feed-factory.ts", "../../../src/feed-store.ts"],
  "sourcesContent": ["//\n// Copyright 2022 DXOS.org\n//\n\nimport type { Proof } from 'hypercore';\nimport { inspect } from 'node:util';\nimport { Readable, Transform } from 'streamx';\n\nimport { Trigger } from '@dxos/async';\nimport { inspectObject, StackTrace } from '@dxos/debug';\nimport type { Hypercore, HypercoreProperties, ReadStreamOptions } from '@dxos/hypercore';\nimport { invariant } from '@dxos/invariant';\nimport { type PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { type Directory } from '@dxos/random-access-storage';\nimport { arrayToBuffer, createBinder, rangeFromTo } from '@dxos/util';\n\nimport { type FeedWriter, type WriteReceipt } from './feed-writer';\n\n/**\n * Async feed wrapper.\n */\nexport class FeedWrapper<T extends {}> {\n  private readonly _pendingWrites = new Set<StackTrace>();\n  private readonly _binder = createBinder(this._hypercore);\n\n  // Pending while writes are happening. Resolves when there are no pending writes.\n  private readonly _writeLock = new Trigger();\n\n  private _closed = false;\n\n  constructor(\n    private _hypercore: Hypercore<T>,\n    private _key: PublicKey, // TODO(burdon): Required since currently patching the key inside factory.\n    private _storageDirectory: Directory,\n  ) {\n    invariant(this._hypercore);\n    invariant(this._key);\n    this._writeLock.wake();\n  }\n\n  [inspect.custom](): string {\n    return inspectObject(this);\n  }\n\n  toJSON(): { feedKey: PublicKey; length: number; opened: boolean; closed: boolean } {\n    return {\n      feedKey: this._key,\n      length: this.properties.length,\n      opened: this.properties.opened,\n      closed: this.properties.closed,\n    };\n  }\n\n  get key(): PublicKey {\n    return this._key;\n  }\n\n  get core(): Hypercore<T> {\n    return this._hypercore;\n  }\n\n  // TODO(burdon): Create proxy.\n  get properties(): HypercoreProperties {\n    return this._hypercore;\n  }\n\n  createReadableStream(opts?: ReadStreamOptions): Readable {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this;\n    const transform = new Transform({\n      transform(data: any, cb: (err?: Error | null, data?: any) => void) {\n        // Delay until write is complete.\n        void self._writeLock.wait().then(() => {\n          this.push(data);\n          cb();\n        });\n      },\n    });\n    const readStream =\n      opts?.batch !== undefined && opts?.batch > 1\n        ? new BatchedReadStream(this._hypercore, opts)\n        : this._hypercore.createReadStream(opts);\n\n    readStream.pipe(transform, (err: any) => {\n      // Ignore errors.\n      // We might get \"Writable stream closed prematurely\" error.\n      // Its okay since the pipeline is closed and does not expect more messages.\n    });\n\n    return transform;\n  }\n\n  createFeedWriter(): FeedWriter<T> {\n    return {\n      write: async (data: T, { afterWrite } = {}) => {\n        log('write', { feed: this._key, seq: this._hypercore.length });\n        invariant(!this._closed, 'Feed closed');\n        const stackTrace = new StackTrace();\n\n        try {\n          // Pending writes pause the read stream.\n          this._pendingWrites.add(stackTrace);\n          if (this._pendingWrites.size === 1) {\n            this._writeLock.reset();\n          }\n\n          const receipt = await this.appendWithReceipt(data);\n\n          // TODO(dmaretskyi): Removing this will make user-intiated writes faster but might result in a data-loss.\n          await this.flushToDisk();\n\n          await afterWrite?.(receipt);\n\n          return receipt;\n        } finally {\n          // Unblock the read stream after the write (and callback) is complete.\n          this._pendingWrites.delete(stackTrace);\n          if (this._pendingWrites.size === 0) {\n            this._writeLock.wake();\n          }\n        }\n      },\n    };\n  }\n\n  async appendWithReceipt(data: T): Promise<WriteReceipt> {\n    const seq = await this.append(data);\n    invariant(seq < this.length, 'Invalid seq after write');\n    log('write complete', { feed: this._key, seq });\n    const receipt: WriteReceipt = {\n      feedKey: this.key,\n      seq,\n    };\n    return receipt;\n  }\n\n  /**\n   * Flush pending changes to disk.\n   * Calling this is not required unless you want to explicitly wait for data to be written.\n   */\n  async flushToDisk(): Promise<void> {\n    await this._storageDirectory.flush();\n  }\n\n  get opened() {\n    return this._hypercore.opened;\n  }\n\n  get closed() {\n    return this._hypercore.closed;\n  }\n\n  get readable() {\n    return this._hypercore.readable;\n  }\n\n  get length() {\n    return this._hypercore.length;\n  }\n\n  get byteLength() {\n    return this._hypercore.byteLength;\n  }\n\n  on = this._binder.fn(this._hypercore.on);\n  off = this._binder.fn(this._hypercore.off);\n\n  open = this._binder.async(this._hypercore.open);\n  private _close = this._binder.async(this._hypercore.close);\n  close = async () => {\n    if (this._pendingWrites.size) {\n      log.warn('Closing feed with pending writes', {\n        feed: this._key,\n        count: this._pendingWrites.size,\n        pendingWrites: Array.from(this._pendingWrites.values()).map((stack) => stack.getStack()),\n      });\n    }\n    this._closed = true;\n    await this.flushToDisk();\n    await this._close();\n  };\n\n  has = this._binder.fn(this._hypercore.has) as (start: number, end?: number) => boolean;\n  get = this._binder.async(this._hypercore.get);\n  append = this._binder.async(this._hypercore.append);\n\n  /**\n   * Will not resolve if `end` parameter is not specified and the feed is not closed.\n   */\n  download = this._binder.fn(this._hypercore.download);\n  undownload = this._binder.fn(this._hypercore.undownload);\n  setDownloading = this._binder.fn(this._hypercore.setDownloading);\n  replicate: Hypercore<T>['replicate'] = this._binder.fn(this._hypercore.replicate);\n  clear = this._binder.async(this._hypercore.clear) as (start: number, end?: number) => Promise<void>;\n\n  proof = this._binder.async(this._hypercore.proof) as (index: number) => Promise<Proof>;\n  put = this._binder.async(this._hypercore.put) as (index: number, data: T, proof: Proof) => Promise<void>;\n  putBuffer = this._binder.async((this._hypercore as any)._putBuffer) as (\n    index: number,\n    data: Buffer,\n    proof: Proof,\n    from: null,\n  ) => Promise<void>;\n\n  /**\n   * Clear and check for integrity.\n   */\n  async safeClear(from: number, to: number): Promise<void> {\n    invariant(from >= 0 && from < to && to <= this.length, 'Invalid range');\n\n    const CHECK_MESSAGES = 20;\n    const checkBegin = to;\n    const checkEnd = Math.min(checkBegin + CHECK_MESSAGES, this.length);\n\n    const messagesBefore = await Promise.all(\n      rangeFromTo(checkBegin, checkEnd).map((idx) =>\n        this.get(idx, {\n          valueEncoding: { decode: (x: Uint8Array) => x },\n        }),\n      ),\n    );\n\n    await this.clear(from, to);\n\n    const messagesAfter = await Promise.all(\n      rangeFromTo(checkBegin, checkEnd).map((idx) =>\n        this.get(idx, {\n          valueEncoding: { decode: (x: Uint8Array) => x },\n        }),\n      ),\n    );\n\n    for (let i = 0; i < messagesBefore.length; i++) {\n      const before = arrayToBuffer(messagesBefore[i]);\n      const after = arrayToBuffer(messagesAfter[i]);\n      if (!before.equals(after)) {\n        throw new Error('Feed corruption on clear. There has likely been a data loss.');\n      }\n    }\n  }\n}\n\nclass BatchedReadStream extends Readable {\n  private readonly _feed: Hypercore<any>;\n  private readonly _batch: number;\n  private _cursor: number;\n  private _reading = false;\n\n  constructor(feed: Hypercore<any>, opts: ReadStreamOptions = {}) {\n    super({ objectMode: true });\n    invariant(opts.live === true, 'Only live mode supported');\n    invariant(opts.batch !== undefined && opts.batch > 1);\n    this._feed = feed;\n    this._batch = opts.batch;\n    this._cursor = opts.start ?? 0;\n  }\n\n  override _open(cb: (err: Error | null) => void): void {\n    this._feed.ready(cb);\n  }\n\n  override _read(cb: (err: Error | null) => void): void {\n    if (this._reading) {\n      return;\n    }\n\n    if (this._feed.bitfield!.total(this._cursor, this._cursor + this._batch) === this._batch) {\n      this._batchedRead(cb);\n    } else {\n      this._nonBatchedRead(cb);\n    }\n  }\n\n  private _nonBatchedRead(cb: (err: Error | null) => void): void {\n    this._feed.get(this._cursor, { wait: true }, (err, data) => {\n      if (err) {\n        cb(err);\n      } else {\n        this._cursor++;\n        this._reading = false;\n        this.push(data);\n        cb(null);\n      }\n    });\n  }\n\n  private _batchedRead(cb: (err: Error | null) => void): void {\n    this._feed.getBatch(this._cursor, this._cursor + this._batch, { wait: true }, (err, data) => {\n      if (err) {\n        cb(err);\n      } else {\n        this._cursor += data.length;\n        this._reading = false;\n        for (const item of data) {\n          this.push(item);\n        }\n        cb(null);\n      }\n    });\n  }\n}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport defaultsDeep from 'lodash.defaultsdeep';\n\nimport { type Signer, subtleCrypto } from '@dxos/crypto';\nimport { failUndefined } from '@dxos/debug';\nimport type { HypercoreOptions } from '@dxos/hypercore';\nimport { createCrypto, hypercore } from '@dxos/hypercore';\nimport { type PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { type Directory } from '@dxos/random-access-storage';\n\nimport { FeedWrapper } from './feed-wrapper';\n\nexport type FeedFactoryOptions = {\n  root: Directory;\n  signer?: Signer;\n  hypercore?: HypercoreOptions;\n};\n\nexport type FeedOptions = HypercoreOptions & {\n  writable?: boolean;\n  /**\n   * Optional hook called before data is written after being verified.\n   * Called for writes done by this peer as well as for data replicated from other peers.\n   * NOTE: The callback must be invoked to complete the write operation.\n   * @param peer Always null in hypercore@9.12.0.\n   */\n  onwrite?: (index: number, data: any, peer: null, cb: (err: Error | null) => void) => void;\n};\n\n/**\n * Hypercore factory.\n */\nexport class FeedFactory<T extends {}> {\n  private readonly _root: Directory;\n  private readonly _signer?: Signer;\n  private readonly _hypercoreOptions?: HypercoreOptions;\n\n  constructor({ root, signer, hypercore }: FeedFactoryOptions) {\n    log('FeedFactory', { options: hypercore });\n    this._root = root ?? failUndefined();\n    this._signer = signer;\n    this._hypercoreOptions = hypercore;\n  }\n\n  get storageRoot() {\n    return this._root;\n  }\n\n  async createFeed(publicKey: PublicKey, options?: FeedOptions): Promise<FeedWrapper<T>> {\n    if (options?.writable && !this._signer) {\n      throw new Error('Signer required to create writable feeds.');\n    }\n    if (options?.secretKey) {\n      log.warn('Secret key ignored due to signer.');\n    }\n\n    // Required due to hypercore's 32-byte key limit.\n    const key = await subtleCrypto.digest('SHA-256', Buffer.from(publicKey.toHex()));\n\n    const opts = defaultsDeep(\n      {\n        // sparse: false,\n        // stats: false,\n      },\n      this._hypercoreOptions,\n      {\n        secretKey: this._signer && options?.writable ? Buffer.from('secret') : undefined,\n        crypto: this._signer ? createCrypto(this._signer, publicKey) : undefined,\n        onwrite: options?.onwrite,\n        noiseKeyPair: {}, // We're not using noise.\n      },\n      options,\n    );\n\n    const storageDir = this._root.createDirectory(publicKey.toHex());\n    const makeStorage = (filename: string) => {\n      const { type, native } = storageDir.getOrCreateFile(filename);\n      log('created', {\n        path: `${type}:${this._root.path}/${publicKey.truncate()}/${filename}`,\n      });\n\n      return native;\n    };\n\n    const core = hypercore(makeStorage, Buffer.from(key), opts);\n    return new FeedWrapper(core, publicKey, storageDir);\n  }\n}\n", "//\n// Copyright 2019 DXOS.org\n//\n\nimport { Event, Mutex } from '@dxos/async';\nimport { failUndefined } from '@dxos/debug';\nimport { invariant } from '@dxos/invariant';\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { ComplexMap, defaultMap } from '@dxos/util';\n\nimport { type FeedFactory, type FeedOptions } from './feed-factory';\nimport { type FeedWrapper } from './feed-wrapper';\n\nexport interface FeedStoreOptions<T extends {}> {\n  factory: FeedFactory<T>;\n}\n\n/**\n * Persistent hypercore store.\n */\nexport class FeedStore<T extends {}> {\n  private readonly _feeds: ComplexMap<PublicKey, FeedWrapper<T>> = new ComplexMap(PublicKey.hash);\n  private readonly _mutexes = new ComplexMap<PublicKey, Mutex>(PublicKey.hash);\n  private readonly _factory: FeedFactory<T>;\n\n  private _closed = false;\n\n  readonly feedOpened = new Event<FeedWrapper<T>>();\n\n  constructor({ factory }: FeedStoreOptions<T>) {\n    this._factory = factory ?? failUndefined();\n  }\n\n  get size() {\n    return this._feeds.size;\n  }\n\n  get feeds() {\n    return Array.from(this._feeds.values());\n  }\n\n  /**\n   * Get the open feed if it exists.\n   */\n  getFeed(publicKey: PublicKey): FeedWrapper<T> | undefined {\n    return this._feeds.get(publicKey);\n  }\n\n  /**\n   * Gets or opens a feed.\n   * The feed is readonly unless a secret key is provided.\n   */\n  async openFeed(feedKey: PublicKey, { writable, sparse }: FeedOptions = {}): Promise<FeedWrapper<T>> {\n    log('opening feed', { feedKey });\n    invariant(feedKey);\n    invariant(!this._closed, 'Feed store is closed');\n\n    const mutex = defaultMap(this._mutexes, feedKey, () => new Mutex());\n\n    return mutex.executeSynchronized(async () => {\n      let feed = this.getFeed(feedKey);\n      if (feed) {\n        // TODO(burdon): Need to check that there's another instance being used (create test and break this).\n        // TODO(burdon): Remove from store if feed is closed externally? (remove wrapped open/close methods?)\n        if (writable && !feed.properties.writable) {\n          throw new Error(`Read-only feed is already open: ${feedKey.truncate()}`);\n        } else if ((sparse ?? false) !== feed.properties.sparse) {\n          throw new Error(\n            `Feed already open with different sparse setting: ${feedKey.truncate()} [${sparse} !== ${\n              feed.properties.sparse\n            }]`,\n          );\n        } else {\n          await feed.open();\n          return feed;\n        }\n      }\n\n      feed = await this._factory.createFeed(feedKey, { writable, sparse });\n      this._feeds.set(feed.key, feed);\n\n      await feed.open();\n      this.feedOpened.emit(feed);\n      log('opened', { feedKey });\n      return feed;\n    });\n  }\n\n  /**\n   * Close all feeds.\n   */\n  async close(): Promise<void> {\n    log('closing...');\n    this._closed = true;\n    await Promise.all(\n      Array.from(this._feeds.values()).map(async (feed) => {\n        await feed.close();\n        invariant(feed.closed);\n        // TODO(burdon): SpaceProxy still being initialized.\n        //  SpaceProxy.initialize => Database.createItem => ... => FeedWrapper.append\n        //  Uncaught Error: Closed [random-access-storage/index.js:181:38]\n        // await sleep(100);\n      }),\n    );\n\n    this._feeds.clear();\n    log('closed');\n  }\n}\n"],
  "mappings": "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",
  "names": ["import_debug", "import_log", "import_async", "import_invariant", "import_util", "FeedWrapper", "_hypercore", "_key", "_storageDirectory", "_pendingWrites", "Set", "_binder", "createBinder", "_writeLock", "Trigger", "_closed", "on", "fn", "off", "open", "async", "_close", "close", "size", "log", "warn", "feed", "count", "pendingWrites", "Array", "from", "values", "map", "stack", "getStack", "flushToDisk", "has", "get", "append", "download", "undownload", "setDownloading", "replicate", "clear", "proof", "put", "putBuffer", "_putBuffer", "invariant", "wake", "inspect", "custom", "inspectObject", "toJSON", "feedKey", "length", "properties", "opened", "closed", "key", "core", "createReadableStream", "opts", "self", "transform", "Transform", "data", "cb", "wait", "then", "push", "readStream", "batch", "undefined", "BatchedReadStream", "createReadStream", "pipe", "err", "createFeedWriter", "write", "afterWrite", "seq", "stackTrace", "StackTrace", "add", "reset", "receipt", "appendWithReceipt", "delete", "flush", "readable", "byteLength", "safeClear", "to", "CHECK_MESSAGES", "checkBegin", "checkEnd", "Math", "min", "messagesBefore", "Promise", "all", "rangeFromTo", "idx", "valueEncoding", "decode", "x", "messagesAfter", "i", "before", "arrayToBuffer", "after", "equals", "Error", "Readable", "objectMode", "_reading", "live", "_feed", "_batch", "_cursor", "start", "_open", "ready", "_read", "bitfield", "total", "_batchedRead", "_nonBatchedRead", "getBatch", "item", "FeedFactory", "root", "signer", "hypercore", "options", "_root", "failUndefined", "_signer", "_hypercoreOptions", "storageRoot", "createFeed", "publicKey", "writable", "secretKey", "subtleCrypto", "digest", "Buffer", "toHex", "defaultsDeep", "crypto", "createCrypto", "onwrite", "noiseKeyPair", "storageDir", "createDirectory", "makeStorage", "filename", "type", "native", "getOrCreateFile", "path", "truncate", "FeedStore", "factory", "_feeds", "ComplexMap", "PublicKey", "hash", "_mutexes", "feedOpened", "Event", "_factory", "feeds", "getFeed", "openFeed", "sparse", "mutex", "defaultMap", "Mutex", "executeSynchronized", "set", "emit"]
}
