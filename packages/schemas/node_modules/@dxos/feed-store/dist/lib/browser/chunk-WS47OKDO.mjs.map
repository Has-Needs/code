{
  "version": 3,
  "sources": ["../../../src/feed-wrapper.ts", "../../../src/feed-factory.ts", "../../../src/feed-store.ts"],
  "sourcesContent": ["//\n// Copyright 2022 DXOS.org\n//\n\nimport type { Proof } from 'hypercore';\nimport { inspect } from 'node:util';\nimport { Readable, Transform } from 'streamx';\n\nimport { Trigger } from '@dxos/async';\nimport { inspectObject, StackTrace } from '@dxos/debug';\nimport type { Hypercore, HypercoreProperties, ReadStreamOptions } from '@dxos/hypercore';\nimport { invariant } from '@dxos/invariant';\nimport { type PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { type Directory } from '@dxos/random-access-storage';\nimport { arrayToBuffer, createBinder, rangeFromTo } from '@dxos/util';\n\nimport { type FeedWriter, type WriteReceipt } from './feed-writer';\n\n/**\n * Async feed wrapper.\n */\nexport class FeedWrapper<T extends {}> {\n  private readonly _pendingWrites = new Set<StackTrace>();\n  private readonly _binder = createBinder(this._hypercore);\n\n  // Pending while writes are happening. Resolves when there are no pending writes.\n  private readonly _writeLock = new Trigger();\n\n  private _closed = false;\n\n  constructor(\n    private _hypercore: Hypercore<T>,\n    private _key: PublicKey, // TODO(burdon): Required since currently patching the key inside factory.\n    private _storageDirectory: Directory,\n  ) {\n    invariant(this._hypercore);\n    invariant(this._key);\n    this._writeLock.wake();\n  }\n\n  [inspect.custom](): string {\n    return inspectObject(this);\n  }\n\n  toJSON(): { feedKey: PublicKey; length: number; opened: boolean; closed: boolean } {\n    return {\n      feedKey: this._key,\n      length: this.properties.length,\n      opened: this.properties.opened,\n      closed: this.properties.closed,\n    };\n  }\n\n  get key(): PublicKey {\n    return this._key;\n  }\n\n  get core(): Hypercore<T> {\n    return this._hypercore;\n  }\n\n  // TODO(burdon): Create proxy.\n  get properties(): HypercoreProperties {\n    return this._hypercore;\n  }\n\n  createReadableStream(opts?: ReadStreamOptions): Readable {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this;\n    const transform = new Transform({\n      transform(data: any, cb: (err?: Error | null, data?: any) => void) {\n        // Delay until write is complete.\n        void self._writeLock.wait().then(() => {\n          this.push(data);\n          cb();\n        });\n      },\n    });\n    const readStream =\n      opts?.batch !== undefined && opts?.batch > 1\n        ? new BatchedReadStream(this._hypercore, opts)\n        : this._hypercore.createReadStream(opts);\n\n    readStream.pipe(transform, (err: any) => {\n      // Ignore errors.\n      // We might get \"Writable stream closed prematurely\" error.\n      // Its okay since the pipeline is closed and does not expect more messages.\n    });\n\n    return transform;\n  }\n\n  createFeedWriter(): FeedWriter<T> {\n    return {\n      write: async (data: T, { afterWrite } = {}) => {\n        log('write', { feed: this._key, seq: this._hypercore.length });\n        invariant(!this._closed, 'Feed closed');\n        const stackTrace = new StackTrace();\n\n        try {\n          // Pending writes pause the read stream.\n          this._pendingWrites.add(stackTrace);\n          if (this._pendingWrites.size === 1) {\n            this._writeLock.reset();\n          }\n\n          const receipt = await this.appendWithReceipt(data);\n\n          // TODO(dmaretskyi): Removing this will make user-intiated writes faster but might result in a data-loss.\n          await this.flushToDisk();\n\n          await afterWrite?.(receipt);\n\n          return receipt;\n        } finally {\n          // Unblock the read stream after the write (and callback) is complete.\n          this._pendingWrites.delete(stackTrace);\n          if (this._pendingWrites.size === 0) {\n            this._writeLock.wake();\n          }\n        }\n      },\n    };\n  }\n\n  async appendWithReceipt(data: T): Promise<WriteReceipt> {\n    const seq = await this.append(data);\n    invariant(seq < this.length, 'Invalid seq after write');\n    log('write complete', { feed: this._key, seq });\n    const receipt: WriteReceipt = {\n      feedKey: this.key,\n      seq,\n    };\n    return receipt;\n  }\n\n  /**\n   * Flush pending changes to disk.\n   * Calling this is not required unless you want to explicitly wait for data to be written.\n   */\n  async flushToDisk(): Promise<void> {\n    await this._storageDirectory.flush();\n  }\n\n  get opened() {\n    return this._hypercore.opened;\n  }\n\n  get closed() {\n    return this._hypercore.closed;\n  }\n\n  get readable() {\n    return this._hypercore.readable;\n  }\n\n  get length() {\n    return this._hypercore.length;\n  }\n\n  get byteLength() {\n    return this._hypercore.byteLength;\n  }\n\n  on = this._binder.fn(this._hypercore.on);\n  off = this._binder.fn(this._hypercore.off);\n\n  open = this._binder.async(this._hypercore.open);\n  private _close = this._binder.async(this._hypercore.close);\n  close = async () => {\n    if (this._pendingWrites.size) {\n      log.warn('Closing feed with pending writes', {\n        feed: this._key,\n        count: this._pendingWrites.size,\n        pendingWrites: Array.from(this._pendingWrites.values()).map((stack) => stack.getStack()),\n      });\n    }\n    this._closed = true;\n    await this.flushToDisk();\n    await this._close();\n  };\n\n  has = this._binder.fn(this._hypercore.has) as (start: number, end?: number) => boolean;\n  get = this._binder.async(this._hypercore.get);\n  append = this._binder.async(this._hypercore.append);\n\n  /**\n   * Will not resolve if `end` parameter is not specified and the feed is not closed.\n   */\n  download = this._binder.fn(this._hypercore.download);\n  undownload = this._binder.fn(this._hypercore.undownload);\n  setDownloading = this._binder.fn(this._hypercore.setDownloading);\n  replicate: Hypercore<T>['replicate'] = this._binder.fn(this._hypercore.replicate);\n  clear = this._binder.async(this._hypercore.clear) as (start: number, end?: number) => Promise<void>;\n\n  proof = this._binder.async(this._hypercore.proof) as (index: number) => Promise<Proof>;\n  put = this._binder.async(this._hypercore.put) as (index: number, data: T, proof: Proof) => Promise<void>;\n  putBuffer = this._binder.async((this._hypercore as any)._putBuffer) as (\n    index: number,\n    data: Buffer,\n    proof: Proof,\n    from: null,\n  ) => Promise<void>;\n\n  /**\n   * Clear and check for integrity.\n   */\n  async safeClear(from: number, to: number): Promise<void> {\n    invariant(from >= 0 && from < to && to <= this.length, 'Invalid range');\n\n    const CHECK_MESSAGES = 20;\n    const checkBegin = to;\n    const checkEnd = Math.min(checkBegin + CHECK_MESSAGES, this.length);\n\n    const messagesBefore = await Promise.all(\n      rangeFromTo(checkBegin, checkEnd).map((idx) =>\n        this.get(idx, {\n          valueEncoding: { decode: (x: Uint8Array) => x },\n        }),\n      ),\n    );\n\n    await this.clear(from, to);\n\n    const messagesAfter = await Promise.all(\n      rangeFromTo(checkBegin, checkEnd).map((idx) =>\n        this.get(idx, {\n          valueEncoding: { decode: (x: Uint8Array) => x },\n        }),\n      ),\n    );\n\n    for (let i = 0; i < messagesBefore.length; i++) {\n      const before = arrayToBuffer(messagesBefore[i]);\n      const after = arrayToBuffer(messagesAfter[i]);\n      if (!before.equals(after)) {\n        throw new Error('Feed corruption on clear. There has likely been a data loss.');\n      }\n    }\n  }\n}\n\nclass BatchedReadStream extends Readable {\n  private readonly _feed: Hypercore<any>;\n  private readonly _batch: number;\n  private _cursor: number;\n  private _reading = false;\n\n  constructor(feed: Hypercore<any>, opts: ReadStreamOptions = {}) {\n    super({ objectMode: true });\n    invariant(opts.live === true, 'Only live mode supported');\n    invariant(opts.batch !== undefined && opts.batch > 1);\n    this._feed = feed;\n    this._batch = opts.batch;\n    this._cursor = opts.start ?? 0;\n  }\n\n  override _open(cb: (err: Error | null) => void): void {\n    this._feed.ready(cb);\n  }\n\n  override _read(cb: (err: Error | null) => void): void {\n    if (this._reading) {\n      return;\n    }\n\n    if (this._feed.bitfield!.total(this._cursor, this._cursor + this._batch) === this._batch) {\n      this._batchedRead(cb);\n    } else {\n      this._nonBatchedRead(cb);\n    }\n  }\n\n  private _nonBatchedRead(cb: (err: Error | null) => void): void {\n    this._feed.get(this._cursor, { wait: true }, (err, data) => {\n      if (err) {\n        cb(err);\n      } else {\n        this._cursor++;\n        this._reading = false;\n        this.push(data);\n        cb(null);\n      }\n    });\n  }\n\n  private _batchedRead(cb: (err: Error | null) => void): void {\n    this._feed.getBatch(this._cursor, this._cursor + this._batch, { wait: true }, (err, data) => {\n      if (err) {\n        cb(err);\n      } else {\n        this._cursor += data.length;\n        this._reading = false;\n        for (const item of data) {\n          this.push(item);\n        }\n        cb(null);\n      }\n    });\n  }\n}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport defaultsDeep from 'lodash.defaultsdeep';\n\nimport { type Signer, subtleCrypto } from '@dxos/crypto';\nimport { failUndefined } from '@dxos/debug';\nimport type { HypercoreOptions } from '@dxos/hypercore';\nimport { createCrypto, hypercore } from '@dxos/hypercore';\nimport { type PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { type Directory } from '@dxos/random-access-storage';\n\nimport { FeedWrapper } from './feed-wrapper';\n\nexport type FeedFactoryOptions = {\n  root: Directory;\n  signer?: Signer;\n  hypercore?: HypercoreOptions;\n};\n\nexport type FeedOptions = HypercoreOptions & {\n  writable?: boolean;\n  /**\n   * Optional hook called before data is written after being verified.\n   * Called for writes done by this peer as well as for data replicated from other peers.\n   * NOTE: The callback must be invoked to complete the write operation.\n   * @param peer Always null in hypercore@9.12.0.\n   */\n  onwrite?: (index: number, data: any, peer: null, cb: (err: Error | null) => void) => void;\n};\n\n/**\n * Hypercore factory.\n */\nexport class FeedFactory<T extends {}> {\n  private readonly _root: Directory;\n  private readonly _signer?: Signer;\n  private readonly _hypercoreOptions?: HypercoreOptions;\n\n  constructor({ root, signer, hypercore }: FeedFactoryOptions) {\n    log('FeedFactory', { options: hypercore });\n    this._root = root ?? failUndefined();\n    this._signer = signer;\n    this._hypercoreOptions = hypercore;\n  }\n\n  get storageRoot() {\n    return this._root;\n  }\n\n  async createFeed(publicKey: PublicKey, options?: FeedOptions): Promise<FeedWrapper<T>> {\n    if (options?.writable && !this._signer) {\n      throw new Error('Signer required to create writable feeds.');\n    }\n    if (options?.secretKey) {\n      log.warn('Secret key ignored due to signer.');\n    }\n\n    // Required due to hypercore's 32-byte key limit.\n    const key = await subtleCrypto.digest('SHA-256', Buffer.from(publicKey.toHex()));\n\n    const opts = defaultsDeep(\n      {\n        // sparse: false,\n        // stats: false,\n      },\n      this._hypercoreOptions,\n      {\n        secretKey: this._signer && options?.writable ? Buffer.from('secret') : undefined,\n        crypto: this._signer ? createCrypto(this._signer, publicKey) : undefined,\n        onwrite: options?.onwrite,\n        noiseKeyPair: {}, // We're not using noise.\n      },\n      options,\n    );\n\n    const storageDir = this._root.createDirectory(publicKey.toHex());\n    const makeStorage = (filename: string) => {\n      const { type, native } = storageDir.getOrCreateFile(filename);\n      log('created', {\n        path: `${type}:${this._root.path}/${publicKey.truncate()}/${filename}`,\n      });\n\n      return native;\n    };\n\n    const core = hypercore(makeStorage, Buffer.from(key), opts);\n    return new FeedWrapper(core, publicKey, storageDir);\n  }\n}\n", "//\n// Copyright 2019 DXOS.org\n//\n\nimport { Event, Mutex } from '@dxos/async';\nimport { failUndefined } from '@dxos/debug';\nimport { invariant } from '@dxos/invariant';\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { ComplexMap, defaultMap } from '@dxos/util';\n\nimport { type FeedFactory, type FeedOptions } from './feed-factory';\nimport { type FeedWrapper } from './feed-wrapper';\n\nexport interface FeedStoreOptions<T extends {}> {\n  factory: FeedFactory<T>;\n}\n\n/**\n * Persistent hypercore store.\n */\nexport class FeedStore<T extends {}> {\n  private readonly _feeds: ComplexMap<PublicKey, FeedWrapper<T>> = new ComplexMap(PublicKey.hash);\n  private readonly _mutexes = new ComplexMap<PublicKey, Mutex>(PublicKey.hash);\n  private readonly _factory: FeedFactory<T>;\n\n  private _closed = false;\n\n  readonly feedOpened = new Event<FeedWrapper<T>>();\n\n  constructor({ factory }: FeedStoreOptions<T>) {\n    this._factory = factory ?? failUndefined();\n  }\n\n  get size() {\n    return this._feeds.size;\n  }\n\n  get feeds() {\n    return Array.from(this._feeds.values());\n  }\n\n  /**\n   * Get the open feed if it exists.\n   */\n  getFeed(publicKey: PublicKey): FeedWrapper<T> | undefined {\n    return this._feeds.get(publicKey);\n  }\n\n  /**\n   * Gets or opens a feed.\n   * The feed is readonly unless a secret key is provided.\n   */\n  async openFeed(feedKey: PublicKey, { writable, sparse }: FeedOptions = {}): Promise<FeedWrapper<T>> {\n    log('opening feed', { feedKey });\n    invariant(feedKey);\n    invariant(!this._closed, 'Feed store is closed');\n\n    const mutex = defaultMap(this._mutexes, feedKey, () => new Mutex());\n\n    return mutex.executeSynchronized(async () => {\n      let feed = this.getFeed(feedKey);\n      if (feed) {\n        // TODO(burdon): Need to check that there's another instance being used (create test and break this).\n        // TODO(burdon): Remove from store if feed is closed externally? (remove wrapped open/close methods?)\n        if (writable && !feed.properties.writable) {\n          throw new Error(`Read-only feed is already open: ${feedKey.truncate()}`);\n        } else if ((sparse ?? false) !== feed.properties.sparse) {\n          throw new Error(\n            `Feed already open with different sparse setting: ${feedKey.truncate()} [${sparse} !== ${\n              feed.properties.sparse\n            }]`,\n          );\n        } else {\n          await feed.open();\n          return feed;\n        }\n      }\n\n      feed = await this._factory.createFeed(feedKey, { writable, sparse });\n      this._feeds.set(feed.key, feed);\n\n      await feed.open();\n      this.feedOpened.emit(feed);\n      log('opened', { feedKey });\n      return feed;\n    });\n  }\n\n  /**\n   * Close all feeds.\n   */\n  async close(): Promise<void> {\n    log('closing...');\n    this._closed = true;\n    await Promise.all(\n      Array.from(this._feeds.values()).map(async (feed) => {\n        await feed.close();\n        invariant(feed.closed);\n        // TODO(burdon): SpaceProxy still being initialized.\n        //  SpaceProxy.initialize => Database.createItem => ... => FeedWrapper.append\n        //  Uncaught Error: Closed [random-access-storage/index.js:181:38]\n        // await sleep(100);\n      }),\n    );\n\n    this._feeds.clear();\n    log('closed');\n  }\n}\n"],
  "mappings": "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",
  "names": ["inspect", "Readable", "Transform", "Trigger", "inspectObject", "StackTrace", "invariant", "log", "arrayToBuffer", "createBinder", "rangeFromTo", "FeedWrapper", "_hypercore", "_key", "_storageDirectory", "_pendingWrites", "Set", "_binder", "_writeLock", "_closed", "on", "fn", "off", "open", "async", "_close", "close", "size", "warn", "feed", "count", "pendingWrites", "Array", "from", "values", "map", "stack", "getStack", "flushToDisk", "has", "get", "append", "download", "undownload", "setDownloading", "replicate", "clear", "proof", "put", "putBuffer", "_putBuffer", "wake", "custom", "toJSON", "feedKey", "length", "properties", "opened", "closed", "key", "core", "createReadableStream", "opts", "self", "transform", "data", "cb", "wait", "then", "push", "readStream", "batch", "undefined", "BatchedReadStream", "createReadStream", "pipe", "err", "createFeedWriter", "write", "afterWrite", "seq", "stackTrace", "add", "reset", "receipt", "appendWithReceipt", "delete", "flush", "readable", "byteLength", "safeClear", "to", "CHECK_MESSAGES", "checkBegin", "checkEnd", "Math", "min", "messagesBefore", "Promise", "all", "idx", "valueEncoding", "decode", "x", "messagesAfter", "i", "before", "after", "equals", "Error", "objectMode", "_reading", "live", "_feed", "_batch", "_cursor", "start", "_open", "ready", "_read", "bitfield", "total", "_batchedRead", "_nonBatchedRead", "getBatch", "item", "defaultsDeep", "subtleCrypto", "failUndefined", "createCrypto", "hypercore", "log", "FeedFactory", "root", "signer", "hypercore", "log", "options", "_root", "failUndefined", "_signer", "_hypercoreOptions", "storageRoot", "createFeed", "publicKey", "writable", "Error", "secretKey", "warn", "key", "subtleCrypto", "digest", "Buffer", "from", "toHex", "opts", "defaultsDeep", "undefined", "crypto", "createCrypto", "onwrite", "noiseKeyPair", "storageDir", "createDirectory", "makeStorage", "filename", "type", "native", "getOrCreateFile", "path", "truncate", "core", "FeedWrapper", "Event", "Mutex", "failUndefined", "invariant", "PublicKey", "log", "ComplexMap", "defaultMap", "FeedStore", "factory", "_feeds", "hash", "_mutexes", "_closed", "feedOpened", "_factory", "size", "feeds", "Array", "from", "values", "getFeed", "publicKey", "get", "openFeed", "feedKey", "writable", "sparse", "mutex", "executeSynchronized", "feed", "properties", "Error", "truncate", "open", "createFeed", "set", "key", "emit", "close", "Promise", "all", "map", "closed", "clear"]
}
