import type { Proof } from 'hypercore';
import { inspect } from 'node:util';
import { Readable } from 'streamx';
import type { Hypercore, HypercoreProperties, ReadStreamOptions } from '@dxos/hypercore';
import { type PublicKey } from '@dxos/keys';
import { type Directory } from '@dxos/random-access-storage';
import { type FeedWriter, type WriteReceipt } from './feed-writer';
/**
 * Async feed wrapper.
 */
export declare class FeedWrapper<T extends {}> {
    private _hypercore;
    private _key;
    private _storageDirectory;
    private readonly _pendingWrites;
    private readonly _binder;
    private readonly _writeLock;
    private _closed;
    constructor(_hypercore: Hypercore<T>, _key: PublicKey, // TODO(burdon): Required since currently patching the key inside factory.
    _storageDirectory: Directory);
    [inspect.custom](): string;
    toJSON(): {
        feedKey: PublicKey;
        length: number;
        opened: boolean;
        closed: boolean;
    };
    get key(): PublicKey;
    get core(): Hypercore<T>;
    get properties(): HypercoreProperties;
    createReadableStream(opts?: ReadStreamOptions): Readable;
    createFeedWriter(): FeedWriter<T>;
    appendWithReceipt(data: T): Promise<WriteReceipt>;
    /**
     * Flush pending changes to disk.
     * Calling this is not required unless you want to explicitly wait for data to be written.
     */
    flushToDisk(): Promise<void>;
    get opened(): boolean;
    get closed(): boolean;
    get readable(): boolean;
    get length(): number;
    get byteLength(): number;
    on: any;
    off: any;
    open: Function;
    private _close;
    close: () => Promise<void>;
    has: (start: number, end?: number) => boolean;
    get: Function;
    append: Function;
    /**
     * Will not resolve if `end` parameter is not specified and the feed is not closed.
     */
    download: any;
    undownload: any;
    setDownloading: any;
    replicate: Hypercore<T>['replicate'];
    clear: (start: number, end?: number) => Promise<void>;
    proof: (index: number) => Promise<Proof>;
    put: (index: number, data: T, proof: Proof) => Promise<void>;
    putBuffer: (index: number, data: Buffer, proof: Proof, from: null) => Promise<void>;
    /**
     * Clear and check for integrity.
     */
    safeClear(from: number, to: number): Promise<void>;
}
//# sourceMappingURL=feed-wrapper.d.ts.map