{
  "version": 3,
  "sources": ["../../../src/plugin/definitions.ts", "../../../src/config.ts"],
  "sourcesContent": ["//\n// Copyright 2022 DXOS.org\n//\n\nimport yaml from 'js-yaml';\nimport { execSync } from 'node:child_process';\nimport { readFileSync } from 'node:fs';\nimport { resolve } from 'node:path';\nimport pkgUp from 'pkg-up';\n\nimport { log } from '@dxos/log';\nimport { setDeep } from '@dxos/util';\n\nimport { type ConfigPluginOpts } from './types';\nimport { mapFromKeyValues } from '../config';\n\nconst CWD = process.cwd();\n\nexport const definitions = ({\n  configPath,\n  envPath,\n  devPath,\n  mode = process.env.NODE_ENV,\n  publicUrl = '',\n  env,\n}: ConfigPluginOpts) => {\n  const KEYS_TO_FILE = {\n    __CONFIG_DEFAULTS__: configPath?.length ? configPath : resolve(CWD, 'dx.yml'),\n    __CONFIG_ENVS__: envPath?.length ? envPath : resolve(CWD, 'dx-env.yml'),\n  } as { [key: string]: string };\n\n  if (mode !== 'production') {\n    KEYS_TO_FILE.__CONFIG_LOCAL__ = devPath ?? resolve(CWD, 'dx-local.yml');\n  }\n\n  return Object.entries(KEYS_TO_FILE).reduce(\n    (prev, [key, value]) => {\n      let content = {};\n\n      try {\n        content = yaml.load(readFileSync(value, 'utf-8')) as any;\n\n        // Map environment variables to config values.\n        if (key === '__CONFIG_ENVS__') {\n          content = mapFromKeyValues(content, process.env);\n        }\n\n        if (key === '__CONFIG_DEFAULTS__') {\n          // Load app environment variables into default config.\n          Object.entries(process.env).forEach(([key, value]) => {\n            if (key.startsWith('DX_') || env?.includes(key)) {\n              setDeep(content, ['runtime', 'app', 'env', key], value);\n            }\n          });\n\n          // Set build info automatically if available.\n          try {\n            const timestamp = new Date().toISOString();\n            const commitHash =\n              process.env.DX_COMMIT_HASH ??\n              execSync('git rev-parse --short HEAD', { encoding: 'utf-8' }).replace('\\n', '');\n            const packagePath = pkgUp.sync();\n            const packageJson = packagePath && JSON.parse(readFileSync(packagePath, 'utf-8'));\n            setDeep(content, ['runtime', 'app', 'build', 'timestamp'], timestamp);\n            setDeep(content, ['runtime', 'app', 'build', 'commitHash'], commitHash);\n            setDeep(content, ['runtime', 'app', 'build', 'version'], packageJson?.version);\n          } catch {}\n        }\n      } catch (err: any) {\n        if (err.message.includes('YAMLException')) {\n          log.error(`Failed to parse file ${value}:`, err);\n        } else {\n          log(`Failed to load file ${value}:`, err);\n        }\n\n        if (key === '__CONFIG_DEFAULTS__') {\n          // Default config is required.\n          throw new Error(`Failed to load default config file from ${value}`);\n        }\n      }\n\n      return {\n        ...prev,\n        [key]: content,\n      };\n    },\n    {\n      __DXOS_CONFIG__: { dynamic: mode === 'production', publicUrl },\n      __CONFIG_DEFAULTS__: {},\n      __CONFIG_ENVS__: {},\n      __CONFIG_LOCAL__: {},\n    },\n  );\n};\n", "//\n// Copyright 2021 DXOS.org\n//\n\nimport { boolean } from 'boolean';\nimport defaultsDeep from 'lodash.defaultsdeep';\nimport isMatch from 'lodash.ismatch';\n\nimport { InvalidConfigError } from '@dxos/protocols';\nimport { schema } from '@dxos/protocols/proto';\nimport { type Config as ConfigProto } from '@dxos/protocols/proto/dxos/config';\nimport { trace } from '@dxos/tracing';\nimport { getDeep, setDeep } from '@dxos/util';\n\nimport { type ConfigKey, type DeepIndex, type ParseKey } from './types';\n\ntype MappingSpec = Record<string, { path: string; type?: string }>;\nconst configRootType = schema.getCodecForType('dxos.config.Config');\n\n/**\n * Maps the given objects onto a flattened set of (key x values).\n *\n * Expects parsed yaml content of the form:\n *\n * ```\n * ENV_VAR:\n *   path: config.selector.path\n * ```\n *\n * @param {object} spec\n * @param {object} values\n * @return {object}\n */\nexport const mapFromKeyValues = (spec: MappingSpec, values: Record<string, any>) => {\n  const config = {};\n\n  for (const [key, { path, type }] of Object.entries(spec)) {\n    let value = values[key];\n\n    if (value !== undefined) {\n      if (type) {\n        switch (type) {\n          case 'boolean': {\n            value = boolean(value);\n            break;\n          }\n\n          case 'number': {\n            value = Number(value);\n            break;\n          }\n\n          case 'string': {\n            break;\n          }\n\n          case 'json': {\n            value = value ? JSON.parse(value) : null;\n            break;\n          }\n\n          default: {\n            throw new Error(`Invalid type: ${type}`);\n          }\n        }\n      }\n\n      setDeep(config, path.split('.'), value);\n    }\n  }\n\n  return config;\n};\n\n/**\n * Maps the given flattend set of (key x values) onto a JSON object.\n * @param {object} spec\n * @param {object} values\n */\nexport const mapToKeyValues = (spec: MappingSpec, values: any) => {\n  const config: Record<string, any> = {};\n\n  for (const [key, { path, type }] of Object.entries(spec)) {\n    const value = getDeep(values, path.split('.'));\n    if (value !== undefined) {\n      switch (type) {\n        case 'json':\n          config[key] = JSON.stringify(value);\n          break;\n        default:\n          config[key] = value;\n      }\n    }\n  }\n\n  return config;\n};\n\n/**\n * Validate config object.\n */\nexport const validateConfig = (config: ConfigProto): ConfigProto => {\n  if (!('version' in config)) {\n    throw new InvalidConfigError('Version not specified');\n  }\n\n  if (config?.version !== 1) {\n    throw new InvalidConfigError(`Invalid config version: ${config.version}`);\n  }\n\n  const error = configRootType.protoType.verify(config);\n  if (error) {\n    throw new InvalidConfigError(error);\n  }\n\n  return config;\n};\n\nexport const ConfigResource = Symbol.for('dxos.resource.Config');\n\n/**\n * Global configuration object.\n * NOTE: Config objects are immutable.\n */\n@trace.resource({ annotation: ConfigResource })\nexport class Config {\n  private readonly _config: any;\n\n  /**\n   * Creates an immutable instance.\n   * @constructor\n   */\n  constructor(config: ConfigProto = {}, ...objects: ConfigProto[]) {\n    this._config = validateConfig(defaultsDeep(config, ...objects, { version: 1 }));\n  }\n\n  /**\n   * Returns an immutable config JSON object.\n   */\n  get values(): ConfigProto {\n    return this._config;\n  }\n\n  /**\n   * Returns the given config property.\n   *\n   * @param key A key in the config object. Can be a nested property with keys separated by dots: 'services.signal.server'.\n   * @param defaultValue Default value to return if option is not present in the config.\n   * @returns The config value or undefined if the option is not present.\n   */\n  get<K extends ConfigKey>(\n    key: K,\n    defaultValue?: DeepIndex<ConfigProto, ParseKey<K>>,\n  ): DeepIndex<ConfigProto, ParseKey<K>> | undefined {\n    return getDeep(this._config, key.split('.')) ?? defaultValue;\n  }\n\n  /**\n   * Get unique key.\n   */\n  find<T = any>(path: string, test: object): T | undefined {\n    const values = getDeep(this._config, path.split('.'));\n    if (!Array.isArray(values)) {\n      return;\n    }\n\n    return values.find((value) => isMatch(value, test));\n  }\n\n  /**\n   * Returns the given config property or throw if it doesn't exist.\n   *\n   * @param key A key in the config object. Can be a nested property with keys separated by dots: 'services.signal.server'.\n   */\n  getOrThrow<K extends ConfigKey>(key: K): Exclude<DeepIndex<ConfigProto, ParseKey<K>>, undefined> {\n    const value: DeepIndex<ConfigProto, ParseKey<K>> | undefined = getDeep(this._config, key.split('.'));\n    if (!value) {\n      throw new Error(`Config option not present: ${key}`);\n    }\n    return value;\n  }\n}\n"],
  "mappings": "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",
  "names": ["import_lodash", "import_util", "configRootType", "schema", "getCodecForType", "mapFromKeyValues", "spec", "values", "config", "key", "path", "type", "Object", "entries", "value", "undefined", "boolean", "Number", "JSON", "parse", "Error", "setDeep", "split", "validateConfig", "InvalidConfigError", "version", "error", "protoType", "verify", "ConfigResource", "Symbol", "for", "Config", "objects", "_config", "defaultsDeep", "get", "defaultValue", "getDeep", "find", "test", "Array", "isArray", "isMatch", "getOrThrow", "resource", "annotation", "CWD", "process", "cwd", "definitions", "configPath", "envPath", "devPath", "mode", "env", "NODE_ENV", "publicUrl", "KEYS_TO_FILE", "__CONFIG_DEFAULTS__", "length", "resolve", "__CONFIG_ENVS__", "__CONFIG_LOCAL__", "reduce", "prev", "content", "yaml", "load", "readFileSync", "forEach", "startsWith", "includes", "timestamp", "Date", "toISOString", "commitHash", "DX_COMMIT_HASH", "execSync", "encoding", "replace", "packagePath", "pkgUp", "sync", "packageJson", "err", "message", "log", "__DXOS_CONFIG__", "dynamic"]
}
