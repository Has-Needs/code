{
  "version": 3,
  "sources": ["../../../src/plugin/definitions.ts", "../../../src/config.ts"],
  "sourcesContent": ["//\n// Copyright 2022 DXOS.org\n//\n\nimport yaml from 'js-yaml';\nimport { execSync } from 'node:child_process';\nimport { readFileSync } from 'node:fs';\nimport { resolve } from 'node:path';\nimport pkgUp from 'pkg-up';\n\nimport { log } from '@dxos/log';\nimport { setDeep } from '@dxos/util';\n\nimport { type ConfigPluginOpts } from './types';\nimport { mapFromKeyValues } from '../config';\n\nconst CWD = process.cwd();\n\nexport const definitions = ({\n  configPath,\n  envPath,\n  devPath,\n  mode = process.env.NODE_ENV,\n  publicUrl = '',\n  env,\n}: ConfigPluginOpts) => {\n  const KEYS_TO_FILE = {\n    __CONFIG_DEFAULTS__: configPath?.length ? configPath : resolve(CWD, 'dx.yml'),\n    __CONFIG_ENVS__: envPath?.length ? envPath : resolve(CWD, 'dx-env.yml'),\n  } as { [key: string]: string };\n\n  if (mode !== 'production') {\n    KEYS_TO_FILE.__CONFIG_LOCAL__ = devPath ?? resolve(CWD, 'dx-local.yml');\n  }\n\n  return Object.entries(KEYS_TO_FILE).reduce(\n    (prev, [key, value]) => {\n      let content = {};\n\n      try {\n        content = yaml.load(readFileSync(value, 'utf-8')) as any;\n\n        // Map environment variables to config values.\n        if (key === '__CONFIG_ENVS__') {\n          content = mapFromKeyValues(content, process.env);\n        }\n\n        if (key === '__CONFIG_DEFAULTS__') {\n          // Load app environment variables into default config.\n          Object.entries(process.env).forEach(([key, value]) => {\n            if (key.startsWith('DX_') || env?.includes(key)) {\n              setDeep(content, ['runtime', 'app', 'env', key], value);\n            }\n          });\n\n          // Set build info automatically if available.\n          try {\n            const timestamp = new Date().toISOString();\n            const commitHash =\n              process.env.DX_COMMIT_HASH ??\n              execSync('git rev-parse --short HEAD', { encoding: 'utf-8' }).replace('\\n', '');\n            const packagePath = pkgUp.sync();\n            const packageJson = packagePath && JSON.parse(readFileSync(packagePath, 'utf-8'));\n            setDeep(content, ['runtime', 'app', 'build', 'timestamp'], timestamp);\n            setDeep(content, ['runtime', 'app', 'build', 'commitHash'], commitHash);\n            setDeep(content, ['runtime', 'app', 'build', 'version'], packageJson?.version);\n          } catch {}\n        }\n      } catch (err: any) {\n        if (err.message.includes('YAMLException')) {\n          log.error(`Failed to parse file ${value}:`, err);\n        } else {\n          log(`Failed to load file ${value}:`, err);\n        }\n\n        if (key === '__CONFIG_DEFAULTS__') {\n          // Default config is required.\n          throw new Error(`Failed to load default config file from ${value}`);\n        }\n      }\n\n      return {\n        ...prev,\n        [key]: content,\n      };\n    },\n    {\n      __DXOS_CONFIG__: { dynamic: mode === 'production', publicUrl },\n      __CONFIG_DEFAULTS__: {},\n      __CONFIG_ENVS__: {},\n      __CONFIG_LOCAL__: {},\n    },\n  );\n};\n", "//\n// Copyright 2021 DXOS.org\n//\n\nimport { boolean } from 'boolean';\nimport defaultsDeep from 'lodash.defaultsdeep';\nimport isMatch from 'lodash.ismatch';\n\nimport { InvalidConfigError } from '@dxos/protocols';\nimport { schema } from '@dxos/protocols/proto';\nimport { type Config as ConfigProto } from '@dxos/protocols/proto/dxos/config';\nimport { trace } from '@dxos/tracing';\nimport { getDeep, setDeep } from '@dxos/util';\n\nimport { type ConfigKey, type DeepIndex, type ParseKey } from './types';\n\ntype MappingSpec = Record<string, { path: string; type?: string }>;\nconst configRootType = schema.getCodecForType('dxos.config.Config');\n\n/**\n * Maps the given objects onto a flattened set of (key x values).\n *\n * Expects parsed yaml content of the form:\n *\n * ```\n * ENV_VAR:\n *   path: config.selector.path\n * ```\n *\n * @param {object} spec\n * @param {object} values\n * @return {object}\n */\nexport const mapFromKeyValues = (spec: MappingSpec, values: Record<string, any>) => {\n  const config = {};\n\n  for (const [key, { path, type }] of Object.entries(spec)) {\n    let value = values[key];\n\n    if (value !== undefined) {\n      if (type) {\n        switch (type) {\n          case 'boolean': {\n            value = boolean(value);\n            break;\n          }\n\n          case 'number': {\n            value = Number(value);\n            break;\n          }\n\n          case 'string': {\n            break;\n          }\n\n          case 'json': {\n            value = value ? JSON.parse(value) : null;\n            break;\n          }\n\n          default: {\n            throw new Error(`Invalid type: ${type}`);\n          }\n        }\n      }\n\n      setDeep(config, path.split('.'), value);\n    }\n  }\n\n  return config;\n};\n\n/**\n * Maps the given flattend set of (key x values) onto a JSON object.\n * @param {object} spec\n * @param {object} values\n */\nexport const mapToKeyValues = (spec: MappingSpec, values: any) => {\n  const config: Record<string, any> = {};\n\n  for (const [key, { path, type }] of Object.entries(spec)) {\n    const value = getDeep(values, path.split('.'));\n    if (value !== undefined) {\n      switch (type) {\n        case 'json':\n          config[key] = JSON.stringify(value);\n          break;\n        default:\n          config[key] = value;\n      }\n    }\n  }\n\n  return config;\n};\n\n/**\n * Validate config object.\n */\nexport const validateConfig = (config: ConfigProto): ConfigProto => {\n  if (!('version' in config)) {\n    throw new InvalidConfigError('Version not specified');\n  }\n\n  if (config?.version !== 1) {\n    throw new InvalidConfigError(`Invalid config version: ${config.version}`);\n  }\n\n  const error = configRootType.protoType.verify(config);\n  if (error) {\n    throw new InvalidConfigError(error);\n  }\n\n  return config;\n};\n\nexport const ConfigResource = Symbol.for('dxos.resource.Config');\n\n/**\n * Global configuration object.\n * NOTE: Config objects are immutable.\n */\n@trace.resource({ annotation: ConfigResource })\nexport class Config {\n  private readonly _config: any;\n\n  /**\n   * Creates an immutable instance.\n   * @constructor\n   */\n  constructor(config: ConfigProto = {}, ...objects: ConfigProto[]) {\n    this._config = validateConfig(defaultsDeep(config, ...objects, { version: 1 }));\n  }\n\n  /**\n   * Returns an immutable config JSON object.\n   */\n  get values(): ConfigProto {\n    return this._config;\n  }\n\n  /**\n   * Returns the given config property.\n   *\n   * @param key A key in the config object. Can be a nested property with keys separated by dots: 'services.signal.server'.\n   * @param defaultValue Default value to return if option is not present in the config.\n   * @returns The config value or undefined if the option is not present.\n   */\n  get<K extends ConfigKey>(\n    key: K,\n    defaultValue?: DeepIndex<ConfigProto, ParseKey<K>>,\n  ): DeepIndex<ConfigProto, ParseKey<K>> | undefined {\n    return getDeep(this._config, key.split('.')) ?? defaultValue;\n  }\n\n  /**\n   * Get unique key.\n   */\n  find<T = any>(path: string, test: object): T | undefined {\n    const values = getDeep(this._config, path.split('.'));\n    if (!Array.isArray(values)) {\n      return;\n    }\n\n    return values.find((value) => isMatch(value, test));\n  }\n\n  /**\n   * Returns the given config property or throw if it doesn't exist.\n   *\n   * @param key A key in the config object. Can be a nested property with keys separated by dots: 'services.signal.server'.\n   */\n  getOrThrow<K extends ConfigKey>(key: K): Exclude<DeepIndex<ConfigProto, ParseKey<K>>, undefined> {\n    const value: DeepIndex<ConfigProto, ParseKey<K>> | undefined = getDeep(this._config, key.split('.'));\n    if (!value) {\n      throw new Error(`Config option not present: ${key}`);\n    }\n    return value;\n  }\n}\n"],
  "mappings": "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",
  "names": ["yaml", "execSync", "readFileSync", "resolve", "pkgUp", "log", "setDeep", "boolean", "defaultsDeep", "isMatch", "InvalidConfigError", "schema", "trace", "getDeep", "setDeep", "configRootType", "schema", "getCodecForType", "mapFromKeyValues", "spec", "values", "config", "key", "path", "type", "Object", "entries", "value", "undefined", "boolean", "Number", "JSON", "parse", "Error", "setDeep", "split", "validateConfig", "config", "InvalidConfigError", "version", "error", "configRootType", "protoType", "verify", "ConfigResource", "Symbol", "for", "Config", "objects", "_config", "defaultsDeep", "values", "get", "key", "defaultValue", "getDeep", "split", "find", "path", "test", "Array", "isArray", "value", "isMatch", "getOrThrow", "Error", "resource", "annotation", "CWD", "process", "cwd", "definitions", "configPath", "envPath", "devPath", "mode", "env", "NODE_ENV", "publicUrl", "KEYS_TO_FILE", "__CONFIG_DEFAULTS__", "length", "resolve", "__CONFIG_ENVS__", "__CONFIG_LOCAL__", "Object", "entries", "reduce", "prev", "key", "value", "content", "yaml", "load", "readFileSync", "mapFromKeyValues", "forEach", "startsWith", "includes", "setDeep", "timestamp", "Date", "toISOString", "commitHash", "DX_COMMIT_HASH", "execSync", "encoding", "replace", "packagePath", "pkgUp", "sync", "packageJson", "JSON", "parse", "version", "err", "message", "log", "error", "Error", "__DXOS_CONFIG__", "dynamic"]
}
