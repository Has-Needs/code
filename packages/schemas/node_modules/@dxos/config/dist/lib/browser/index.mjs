// packages/sdk/config/src/index.ts
import * as defs from "@dxos/protocols/proto/dxos/config";

// packages/sdk/config/src/config.ts
import { boolean } from "boolean";
import defaultsDeep from "lodash.defaultsdeep";
import isMatch from "lodash.ismatch";
import { InvalidConfigError } from "@dxos/protocols";
import { schema } from "@dxos/protocols/proto";
import { trace } from "@dxos/tracing";
import { getDeep, setDeep } from "@dxos/util";
function _ts_decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var configRootType = schema.getCodecForType("dxos.config.Config");
var mapFromKeyValues = (spec, values) => {
  const config = {};
  for (const [key, { path, type }] of Object.entries(spec)) {
    let value = values[key];
    if (value !== void 0) {
      if (type) {
        switch (type) {
          case "boolean": {
            value = boolean(value);
            break;
          }
          case "number": {
            value = Number(value);
            break;
          }
          case "string": {
            break;
          }
          case "json": {
            value = value ? JSON.parse(value) : null;
            break;
          }
          default: {
            throw new Error(`Invalid type: ${type}`);
          }
        }
      }
      setDeep(config, path.split("."), value);
    }
  }
  return config;
};
var mapToKeyValues = (spec, values) => {
  const config = {};
  for (const [key, { path, type }] of Object.entries(spec)) {
    const value = getDeep(values, path.split("."));
    if (value !== void 0) {
      switch (type) {
        case "json":
          config[key] = JSON.stringify(value);
          break;
        default:
          config[key] = value;
      }
    }
  }
  return config;
};
var validateConfig = (config) => {
  if (!("version" in config)) {
    throw new InvalidConfigError("Version not specified");
  }
  if (config?.version !== 1) {
    throw new InvalidConfigError(`Invalid config version: ${config.version}`);
  }
  const error = configRootType.protoType.verify(config);
  if (error) {
    throw new InvalidConfigError(error);
  }
  return config;
};
var ConfigResource = Symbol.for("dxos.resource.Config");
var Config = class {
  /**
  * Creates an immutable instance.
  * @constructor
  */
  constructor(config = {}, ...objects) {
    this._config = validateConfig(defaultsDeep(config, ...objects, {
      version: 1
    }));
  }
  /**
  * Returns an immutable config JSON object.
  */
  get values() {
    return this._config;
  }
  /**
  * Returns the given config property.
  *
  * @param key A key in the config object. Can be a nested property with keys separated by dots: 'services.signal.server'.
  * @param defaultValue Default value to return if option is not present in the config.
  * @returns The config value or undefined if the option is not present.
  */
  get(key, defaultValue) {
    return getDeep(this._config, key.split(".")) ?? defaultValue;
  }
  /**
  * Get unique key.
  */
  find(path, test) {
    const values = getDeep(this._config, path.split("."));
    if (!Array.isArray(values)) {
      return;
    }
    return values.find((value) => isMatch(value, test));
  }
  /**
  * Returns the given config property or throw if it doesn't exist.
  *
  * @param key A key in the config object. Can be a nested property with keys separated by dots: 'services.signal.server'.
  */
  getOrThrow(key) {
    const value = getDeep(this._config, key.split("."));
    if (!value) {
      throw new Error(`Config option not present: ${key}`);
    }
    return value;
  }
};
Config = _ts_decorate([
  trace.resource({
    annotation: ConfigResource
  })
], Config);

// packages/sdk/config/src/loaders/browser.js
import localforage from "localforage";
import { log } from "@dxos/log";
var CONFIG_ENDPOINT = "/.well-known/dx/config";
var Local = () => {
  return typeof __CONFIG_LOCAL__ !== "undefined" ? __CONFIG_LOCAL__ : {};
};
var Dynamics = async () => {
  const { publicUrl = "", dynamic } = __DXOS_CONFIG__;
  if (!dynamic) {
    log("dynamics disabled");
    return {};
  }
  log("fetching config...", { publicUrl });
  return await fetch(`${publicUrl}${CONFIG_ENDPOINT}`).then((res) => res.json()).catch((error) => {
    log.warn("Failed to fetch dynamic config.", error);
    return {};
  });
};
var Envs = () => {
  return typeof __CONFIG_ENVS__ !== "undefined" ? __CONFIG_ENVS__ : {};
};
var Defaults = () => {
  return typeof __CONFIG_DEFAULTS__ !== "undefined" ? __CONFIG_DEFAULTS__ : {};
};
var Storage = async () => {
  try {
    const config = await localforage.getItem("dxos.org/settings/config");
    if (config) {
      return config;
    }
  } catch (err) {
    log.warn("Failed to load config", { err });
  }
  return {};
};
var Remote = (target, authenticationToken) => {
  if (!target) {
    return {};
  }
  try {
    const url = new URL(target);
    const protocol = url.protocol.slice(0, -1);
    return {
      runtime: {
        client: {
          // TODO(burdon): Remove vault.html.
          remoteSource: url.origin + (protocol.startsWith("http") ? "/vault.html" : ""),
          remoteSourceAuthenticationToken: authenticationToken
        }
      }
    };
  } catch (err) {
    log.catch(err);
    return {};
  }
};

// packages/sdk/config/src/savers/browser.js
import localforage2 from "localforage";
import { log as log2 } from "@dxos/log";
var PERFORMING_CONFIG_SAVE = false;
var SaveConfig = async (config) => {
  if (PERFORMING_CONFIG_SAVE) {
    log2.warn("Already performing config save");
    return;
  }
  PERFORMING_CONFIG_SAVE = true;
  try {
    await localforage2.setItem("dxos.org/settings/config", config);
  } catch (err) {
    log2.warn("Failed to save config", { err });
    return {};
  } finally {
    PERFORMING_CONFIG_SAVE = false;
  }
};

// packages/sdk/config/src/types.ts
var FILE_DEFAULTS = "defaults.yml";
var FILE_ENVS = "envs-map.yml";
var FILE_DYNAMICS = "config.yml";
export {
  Config,
  ConfigResource,
  Defaults,
  Dynamics,
  Envs,
  FILE_DEFAULTS,
  FILE_DYNAMICS,
  FILE_ENVS,
  Local,
  Remote,
  SaveConfig,
  Storage,
  defs,
  mapFromKeyValues,
  mapToKeyValues,
  validateConfig
};
//# sourceMappingURL=index.mjs.map
