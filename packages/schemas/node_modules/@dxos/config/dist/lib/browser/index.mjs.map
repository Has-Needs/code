{
  "version": 3,
  "sources": ["../../../src/index.ts", "../../../src/config.ts", "../../../src/loaders/browser.js", "../../../src/savers/browser.js", "../../../src/types.ts"],
  "sourcesContent": ["//\n// Copyright 2021 DXOS.org\n//\n\n// TODO(burdon): Why is this exported? (Rename).\nexport * as defs from '@dxos/protocols/proto/dxos/config';\n\nexport { type Config as ConfigProto } from '@dxos/protocols/proto/dxos/config';\n\nexport * from './config';\nexport * from './loaders';\nexport * from './savers';\nexport * from './plugin';\nexport * from './types';\n", "//\n// Copyright 2021 DXOS.org\n//\n\nimport { boolean } from 'boolean';\nimport defaultsDeep from 'lodash.defaultsdeep';\nimport isMatch from 'lodash.ismatch';\n\nimport { InvalidConfigError } from '@dxos/protocols';\nimport { schema } from '@dxos/protocols/proto';\nimport { type Config as ConfigProto } from '@dxos/protocols/proto/dxos/config';\nimport { trace } from '@dxos/tracing';\nimport { getDeep, setDeep } from '@dxos/util';\n\nimport { type ConfigKey, type DeepIndex, type ParseKey } from './types';\n\ntype MappingSpec = Record<string, { path: string; type?: string }>;\nconst configRootType = schema.getCodecForType('dxos.config.Config');\n\n/**\n * Maps the given objects onto a flattened set of (key x values).\n *\n * Expects parsed yaml content of the form:\n *\n * ```\n * ENV_VAR:\n *   path: config.selector.path\n * ```\n *\n * @param {object} spec\n * @param {object} values\n * @return {object}\n */\nexport const mapFromKeyValues = (spec: MappingSpec, values: Record<string, any>) => {\n  const config = {};\n\n  for (const [key, { path, type }] of Object.entries(spec)) {\n    let value = values[key];\n\n    if (value !== undefined) {\n      if (type) {\n        switch (type) {\n          case 'boolean': {\n            value = boolean(value);\n            break;\n          }\n\n          case 'number': {\n            value = Number(value);\n            break;\n          }\n\n          case 'string': {\n            break;\n          }\n\n          case 'json': {\n            value = value ? JSON.parse(value) : null;\n            break;\n          }\n\n          default: {\n            throw new Error(`Invalid type: ${type}`);\n          }\n        }\n      }\n\n      setDeep(config, path.split('.'), value);\n    }\n  }\n\n  return config;\n};\n\n/**\n * Maps the given flattend set of (key x values) onto a JSON object.\n * @param {object} spec\n * @param {object} values\n */\nexport const mapToKeyValues = (spec: MappingSpec, values: any) => {\n  const config: Record<string, any> = {};\n\n  for (const [key, { path, type }] of Object.entries(spec)) {\n    const value = getDeep(values, path.split('.'));\n    if (value !== undefined) {\n      switch (type) {\n        case 'json':\n          config[key] = JSON.stringify(value);\n          break;\n        default:\n          config[key] = value;\n      }\n    }\n  }\n\n  return config;\n};\n\n/**\n * Validate config object.\n */\nexport const validateConfig = (config: ConfigProto): ConfigProto => {\n  if (!('version' in config)) {\n    throw new InvalidConfigError('Version not specified');\n  }\n\n  if (config?.version !== 1) {\n    throw new InvalidConfigError(`Invalid config version: ${config.version}`);\n  }\n\n  const error = configRootType.protoType.verify(config);\n  if (error) {\n    throw new InvalidConfigError(error);\n  }\n\n  return config;\n};\n\nexport const ConfigResource = Symbol.for('dxos.resource.Config');\n\n/**\n * Global configuration object.\n * NOTE: Config objects are immutable.\n */\n@trace.resource({ annotation: ConfigResource })\nexport class Config {\n  private readonly _config: any;\n\n  /**\n   * Creates an immutable instance.\n   * @constructor\n   */\n  constructor(config: ConfigProto = {}, ...objects: ConfigProto[]) {\n    this._config = validateConfig(defaultsDeep(config, ...objects, { version: 1 }));\n  }\n\n  /**\n   * Returns an immutable config JSON object.\n   */\n  get values(): ConfigProto {\n    return this._config;\n  }\n\n  /**\n   * Returns the given config property.\n   *\n   * @param key A key in the config object. Can be a nested property with keys separated by dots: 'services.signal.server'.\n   * @param defaultValue Default value to return if option is not present in the config.\n   * @returns The config value or undefined if the option is not present.\n   */\n  get<K extends ConfigKey>(\n    key: K,\n    defaultValue?: DeepIndex<ConfigProto, ParseKey<K>>,\n  ): DeepIndex<ConfigProto, ParseKey<K>> | undefined {\n    return getDeep(this._config, key.split('.')) ?? defaultValue;\n  }\n\n  /**\n   * Get unique key.\n   */\n  find<T = any>(path: string, test: object): T | undefined {\n    const values = getDeep(this._config, path.split('.'));\n    if (!Array.isArray(values)) {\n      return;\n    }\n\n    return values.find((value) => isMatch(value, test));\n  }\n\n  /**\n   * Returns the given config property or throw if it doesn't exist.\n   *\n   * @param key A key in the config object. Can be a nested property with keys separated by dots: 'services.signal.server'.\n   */\n  getOrThrow<K extends ConfigKey>(key: K): Exclude<DeepIndex<ConfigProto, ParseKey<K>>, undefined> {\n    const value: DeepIndex<ConfigProto, ParseKey<K>> | undefined = getDeep(this._config, key.split('.'));\n    if (!value) {\n      throw new Error(`Config option not present: ${key}`);\n    }\n    return value;\n  }\n}\n", "//\n// Copyright 2021 DXOS.org\n//\n\n/* THIS FILE WILL BE LOADED BY CONTEXT REPLACEMENT PLUGIN IN BROWSER ENVS. */\n\n/* global __DXOS_CONFIG__ __CONFIG_ENVS__ __CONFIG_DEFAULTS__ __CONFIG_LOCAL__ */\n\nimport localforage from 'localforage';\n\nimport { log } from '@dxos/log';\n\nconst CONFIG_ENDPOINT = '/.well-known/dx/config';\n\nexport const Local = () => {\n  return typeof __CONFIG_LOCAL__ !== 'undefined' ? __CONFIG_LOCAL__ : {};\n};\n\nexport const Dynamics = async () => {\n  const { publicUrl = '', dynamic } = __DXOS_CONFIG__;\n  if (!dynamic) {\n    log('dynamics disabled');\n    return {};\n  }\n\n  log('fetching config...', { publicUrl });\n  return await fetch(`${publicUrl}${CONFIG_ENDPOINT}`)\n    .then((res) => res.json())\n    .catch((error) => {\n      log.warn('Failed to fetch dynamic config.', error);\n      return {};\n    });\n};\n\nexport const Envs = () => {\n  return typeof __CONFIG_ENVS__ !== 'undefined' ? __CONFIG_ENVS__ : {};\n};\n\nexport const Defaults = () => {\n  return typeof __CONFIG_DEFAULTS__ !== 'undefined' ? __CONFIG_DEFAULTS__ : {};\n};\n\n/**\n * Settings config from browser storage.\n */\nexport const Storage = async () => {\n  try {\n    const config = await localforage.getItem('dxos.org/settings/config');\n    if (config) {\n      return config;\n    }\n  } catch (err) {\n    log.warn('Failed to load config', { err });\n  }\n  return {};\n};\n\nexport const Remote = (target, authenticationToken) => {\n  if (!target) {\n    return {};\n  }\n\n  try {\n    const url = new URL(target);\n    const protocol = url.protocol.slice(0, -1);\n\n    return {\n      runtime: {\n        client: {\n          // TODO(burdon): Remove vault.html.\n          remoteSource: url.origin + (protocol.startsWith('http') ? '/vault.html' : ''),\n          remoteSourceAuthenticationToken: authenticationToken,\n        },\n      },\n    };\n  } catch (err) {\n    log.catch(err);\n    return {};\n  }\n};\n", "//\n// Copyright 2021 DXOS.org\n//\n\n/* THIS FILE WILL BE LOADED BY CONTEXT REPLACEMENT PLUGIN IN BROWSER ENVS. */\n\nimport localforage from 'localforage';\n\nimport { log } from '@dxos/log';\n\nlet PERFORMING_CONFIG_SAVE = false;\n\nexport const SaveConfig = async (config) => {\n  if (PERFORMING_CONFIG_SAVE) {\n    log.warn('Already performing config save');\n    return;\n  }\n  PERFORMING_CONFIG_SAVE = true;\n\n  try {\n    await localforage.setItem('dxos.org/settings/config', config);\n  } catch (err) {\n    log.warn('Failed to save config', { err });\n    return {};\n  } finally {\n    PERFORMING_CONFIG_SAVE = false;\n  }\n};\n", "//\n// Copyright 2021 DXOS.org\n//\n\nimport { type Config as ConfigProto } from '@dxos/protocols/proto/dxos/config';\n\nexport const FILE_DEFAULTS = 'defaults.yml';\nexport const FILE_ENVS = 'envs-map.yml';\nexport const FILE_DYNAMICS = 'config.yml';\n\ntype DotPrefix<T extends string> = T extends '' ? '' : `.${T}`;\n\n/**\n * Returns all dot-separated nested keys for an object.\n *\n * Read more: https://stackoverflow.com/a/68404823.\n */\ntype DotNestedKeys<T> = (\n  T extends object\n    ? {\n        [K in Exclude<keyof T, symbol>]: `${K}${DotPrefix<DotNestedKeys<T[K]>>}`;\n      }[Exclude<keyof T, symbol>]\n    : ''\n) extends infer D\n  ? Extract<D, string>\n  : never;\n\n/**\n * Parse a dot separated nested key into an array of keys.\n *\n * Example: 'services.signal.server' -> ['services', 'signal', 'server'].\n */\nexport type ParseKey<K extends string> = K extends `${infer L}.${infer Rest}` ? [L, ...ParseKey<Rest>] : [K];\n\n/**\n * Array of types that can act as an object key.\n */\ntype Keys = (keyof any)[];\n\n/**\n * Retrieves a property type in a series of nested objects.\n *\n * Read more: https://stackoverflow.com/a/61648690.\n */\nexport type DeepIndex<T, KS extends Keys, Fail = undefined> = KS extends [infer F, ...infer R]\n  ? F extends keyof Exclude<T, undefined>\n    ? R extends Keys\n      ? DeepIndex<Exclude<T, undefined>[F], R, Fail>\n      : Fail\n    : Fail\n  : T;\n\n/**\n * Any nested dot separated key that can be in config.\n */\n// TODO(egorgripasov): Clean once old config deprecated.\nexport type ConfigKey = DotNestedKeys<ConfigProto>;\n"],
  "mappings": "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",
  "names": ["defs", "boolean", "defaultsDeep", "isMatch", "InvalidConfigError", "schema", "trace", "getDeep", "setDeep", "configRootType", "schema", "getCodecForType", "mapFromKeyValues", "spec", "values", "config", "key", "path", "type", "Object", "entries", "value", "undefined", "boolean", "Number", "JSON", "parse", "Error", "setDeep", "split", "mapToKeyValues", "getDeep", "stringify", "validateConfig", "InvalidConfigError", "version", "error", "protoType", "verify", "ConfigResource", "Symbol", "for", "Config", "objects", "_config", "defaultsDeep", "get", "defaultValue", "find", "test", "Array", "isArray", "isMatch", "getOrThrow", "resource", "annotation", "localforage", "log", "FILE_DEFAULTS", "FILE_ENVS", "FILE_DYNAMICS"]
}
