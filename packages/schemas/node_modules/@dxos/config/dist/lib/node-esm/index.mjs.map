{
  "version": 3,
  "sources": ["../../../src/index.ts", "../../../src/config.ts", "../../../src/loaders/index.ts", "../../../src/types.ts", "../../../src/savers/index.ts", "../../../src/plugin/definitions.ts"],
  "sourcesContent": ["//\n// Copyright 2021 DXOS.org\n//\n\n// TODO(burdon): Why is this exported? (Rename).\nexport * as defs from '@dxos/protocols/proto/dxos/config';\n\nexport { type Config as ConfigProto } from '@dxos/protocols/proto/dxos/config';\n\nexport * from './config';\nexport * from './loaders';\nexport * from './savers';\nexport * from './plugin';\nexport * from './types';\n", "//\n// Copyright 2021 DXOS.org\n//\n\nimport { boolean } from 'boolean';\nimport defaultsDeep from 'lodash.defaultsdeep';\nimport isMatch from 'lodash.ismatch';\n\nimport { InvalidConfigError } from '@dxos/protocols';\nimport { schema } from '@dxos/protocols/proto';\nimport { type Config as ConfigProto } from '@dxos/protocols/proto/dxos/config';\nimport { trace } from '@dxos/tracing';\nimport { getDeep, setDeep } from '@dxos/util';\n\nimport { type ConfigKey, type DeepIndex, type ParseKey } from './types';\n\ntype MappingSpec = Record<string, { path: string; type?: string }>;\nconst configRootType = schema.getCodecForType('dxos.config.Config');\n\n/**\n * Maps the given objects onto a flattened set of (key x values).\n *\n * Expects parsed yaml content of the form:\n *\n * ```\n * ENV_VAR:\n *   path: config.selector.path\n * ```\n *\n * @param {object} spec\n * @param {object} values\n * @return {object}\n */\nexport const mapFromKeyValues = (spec: MappingSpec, values: Record<string, any>) => {\n  const config = {};\n\n  for (const [key, { path, type }] of Object.entries(spec)) {\n    let value = values[key];\n\n    if (value !== undefined) {\n      if (type) {\n        switch (type) {\n          case 'boolean': {\n            value = boolean(value);\n            break;\n          }\n\n          case 'number': {\n            value = Number(value);\n            break;\n          }\n\n          case 'string': {\n            break;\n          }\n\n          case 'json': {\n            value = value ? JSON.parse(value) : null;\n            break;\n          }\n\n          default: {\n            throw new Error(`Invalid type: ${type}`);\n          }\n        }\n      }\n\n      setDeep(config, path.split('.'), value);\n    }\n  }\n\n  return config;\n};\n\n/**\n * Maps the given flattend set of (key x values) onto a JSON object.\n * @param {object} spec\n * @param {object} values\n */\nexport const mapToKeyValues = (spec: MappingSpec, values: any) => {\n  const config: Record<string, any> = {};\n\n  for (const [key, { path, type }] of Object.entries(spec)) {\n    const value = getDeep(values, path.split('.'));\n    if (value !== undefined) {\n      switch (type) {\n        case 'json':\n          config[key] = JSON.stringify(value);\n          break;\n        default:\n          config[key] = value;\n      }\n    }\n  }\n\n  return config;\n};\n\n/**\n * Validate config object.\n */\nexport const validateConfig = (config: ConfigProto): ConfigProto => {\n  if (!('version' in config)) {\n    throw new InvalidConfigError('Version not specified');\n  }\n\n  if (config?.version !== 1) {\n    throw new InvalidConfigError(`Invalid config version: ${config.version}`);\n  }\n\n  const error = configRootType.protoType.verify(config);\n  if (error) {\n    throw new InvalidConfigError(error);\n  }\n\n  return config;\n};\n\nexport const ConfigResource = Symbol.for('dxos.resource.Config');\n\n/**\n * Global configuration object.\n * NOTE: Config objects are immutable.\n */\n@trace.resource({ annotation: ConfigResource })\nexport class Config {\n  private readonly _config: any;\n\n  /**\n   * Creates an immutable instance.\n   * @constructor\n   */\n  constructor(config: ConfigProto = {}, ...objects: ConfigProto[]) {\n    this._config = validateConfig(defaultsDeep(config, ...objects, { version: 1 }));\n  }\n\n  /**\n   * Returns an immutable config JSON object.\n   */\n  get values(): ConfigProto {\n    return this._config;\n  }\n\n  /**\n   * Returns the given config property.\n   *\n   * @param key A key in the config object. Can be a nested property with keys separated by dots: 'services.signal.server'.\n   * @param defaultValue Default value to return if option is not present in the config.\n   * @returns The config value or undefined if the option is not present.\n   */\n  get<K extends ConfigKey>(\n    key: K,\n    defaultValue?: DeepIndex<ConfigProto, ParseKey<K>>,\n  ): DeepIndex<ConfigProto, ParseKey<K>> | undefined {\n    return getDeep(this._config, key.split('.')) ?? defaultValue;\n  }\n\n  /**\n   * Get unique key.\n   */\n  find<T = any>(path: string, test: object): T | undefined {\n    const values = getDeep(this._config, path.split('.'));\n    if (!Array.isArray(values)) {\n      return;\n    }\n\n    return values.find((value) => isMatch(value, test));\n  }\n\n  /**\n   * Returns the given config property or throw if it doesn't exist.\n   *\n   * @param key A key in the config object. Can be a nested property with keys separated by dots: 'services.signal.server'.\n   */\n  getOrThrow<K extends ConfigKey>(key: K): Exclude<DeepIndex<ConfigProto, ParseKey<K>>, undefined> {\n    const value: DeepIndex<ConfigProto, ParseKey<K>> | undefined = getDeep(this._config, key.split('.'));\n    if (!value) {\n      throw new Error(`Config option not present: ${key}`);\n    }\n    return value;\n  }\n}\n", "//\n// Copyright 2021 DXOS.org\n//\n\nimport yaml from 'js-yaml';\nimport fs from 'node:fs';\nimport path from 'node:path';\n\nimport { log } from '@dxos/log';\nimport { type Config as ConfigProto } from '@dxos/protocols/proto/dxos/config';\n\nimport { mapFromKeyValues } from '../config';\nimport { FILE_DEFAULTS, FILE_ENVS } from '../types';\n\n// TODO(burdon): Move code out of index file.\n\nconst DEFAULT_BASE_PATH = path.resolve(process.cwd(), 'config');\n\nconst maybeLoadFile = (file: string): any => {\n  try {\n    return yaml.load(fs.readFileSync(file, { encoding: 'utf8' }));\n  } catch (err: any) {\n    // Ignored.\n  }\n};\n\n//\n// NOTE: Export LocalStorage and Dynamics for typescript to typecheck browser code (see ConfigPlugin).\n//\n\n/**\n * Profile\n */\nexport const Profile = (profile = 'default') => {\n  const configFile = path.join(process.env.HOME ?? '~', `.config/dx/profile/${profile}.yml`);\n  return maybeLoadFile(configFile) as ConfigProto;\n};\n\n/**\n * Development config.\n */\n// TODO(burdon): Rename or reconcile with Profile above?\nexport const Local = (): Partial<ConfigProto> => ({});\n\n/**\n * Provided dynamically by server.\n */\nexport const Dynamics = (): Partial<ConfigProto> => ({});\n\n/**\n * ENV variable (key/value) map.\n */\nexport const Envs = (basePath = DEFAULT_BASE_PATH): Partial<ConfigProto> => {\n  const content = maybeLoadFile(path.resolve(basePath, FILE_ENVS));\n  return content ? mapFromKeyValues(content, process.env) : {};\n};\n\n/**\n * JSON config.\n */\nexport const Defaults = (basePath = DEFAULT_BASE_PATH): Partial<ConfigProto> =>\n  maybeLoadFile(path.resolve(basePath, FILE_DEFAULTS)) ?? {};\n\n/**\n * Load config from storage.\n */\nexport const Storage = async (): Promise<Partial<ConfigProto>> => ({});\n\nexport const Remote = (target: string | undefined, authenticationToken?: string): Partial<ConfigProto> => {\n  if (!target) {\n    return {};\n  }\n\n  try {\n    const url = new URL(target);\n    const protocol = url.protocol.slice(0, -1);\n    return {\n      runtime: {\n        client: {\n          // TODO(burdon): Remove vault.html.\n          remoteSource: url.origin + (protocol.startsWith('http') ? '/vault.html' : ''),\n          remoteSourceAuthenticationToken: authenticationToken,\n        },\n      },\n    };\n  } catch (err) {\n    log.catch(err);\n    return {};\n  }\n};\n", "//\n// Copyright 2021 DXOS.org\n//\n\nimport { type Config as ConfigProto } from '@dxos/protocols/proto/dxos/config';\n\nexport const FILE_DEFAULTS = 'defaults.yml';\nexport const FILE_ENVS = 'envs-map.yml';\nexport const FILE_DYNAMICS = 'config.yml';\n\ntype DotPrefix<T extends string> = T extends '' ? '' : `.${T}`;\n\n/**\n * Returns all dot-separated nested keys for an object.\n *\n * Read more: https://stackoverflow.com/a/68404823.\n */\ntype DotNestedKeys<T> = (\n  T extends object\n    ? {\n        [K in Exclude<keyof T, symbol>]: `${K}${DotPrefix<DotNestedKeys<T[K]>>}`;\n      }[Exclude<keyof T, symbol>]\n    : ''\n) extends infer D\n  ? Extract<D, string>\n  : never;\n\n/**\n * Parse a dot separated nested key into an array of keys.\n *\n * Example: 'services.signal.server' -> ['services', 'signal', 'server'].\n */\nexport type ParseKey<K extends string> = K extends `${infer L}.${infer Rest}` ? [L, ...ParseKey<Rest>] : [K];\n\n/**\n * Array of types that can act as an object key.\n */\ntype Keys = (keyof any)[];\n\n/**\n * Retrieves a property type in a series of nested objects.\n *\n * Read more: https://stackoverflow.com/a/61648690.\n */\nexport type DeepIndex<T, KS extends Keys, Fail = undefined> = KS extends [infer F, ...infer R]\n  ? F extends keyof Exclude<T, undefined>\n    ? R extends Keys\n      ? DeepIndex<Exclude<T, undefined>[F], R, Fail>\n      : Fail\n    : Fail\n  : T;\n\n/**\n * Any nested dot separated key that can be in config.\n */\n// TODO(egorgripasov): Clean once old config deprecated.\nexport type ConfigKey = DotNestedKeys<ConfigProto>;\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { type Config as ConfigProto } from '@dxos/protocols/proto/dxos/config';\n\nexport const SaveConfig = async (_: ConfigProto) => {};\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport yaml from 'js-yaml';\nimport { execSync } from 'node:child_process';\nimport { readFileSync } from 'node:fs';\nimport { resolve } from 'node:path';\nimport pkgUp from 'pkg-up';\n\nimport { log } from '@dxos/log';\nimport { setDeep } from '@dxos/util';\n\nimport { type ConfigPluginOpts } from './types';\nimport { mapFromKeyValues } from '../config';\n\nconst CWD = process.cwd();\n\nexport const definitions = ({\n  configPath,\n  envPath,\n  devPath,\n  mode = process.env.NODE_ENV,\n  publicUrl = '',\n  env,\n}: ConfigPluginOpts) => {\n  const KEYS_TO_FILE = {\n    __CONFIG_DEFAULTS__: configPath?.length ? configPath : resolve(CWD, 'dx.yml'),\n    __CONFIG_ENVS__: envPath?.length ? envPath : resolve(CWD, 'dx-env.yml'),\n  } as { [key: string]: string };\n\n  if (mode !== 'production') {\n    KEYS_TO_FILE.__CONFIG_LOCAL__ = devPath ?? resolve(CWD, 'dx-local.yml');\n  }\n\n  return Object.entries(KEYS_TO_FILE).reduce(\n    (prev, [key, value]) => {\n      let content = {};\n\n      try {\n        content = yaml.load(readFileSync(value, 'utf-8')) as any;\n\n        // Map environment variables to config values.\n        if (key === '__CONFIG_ENVS__') {\n          content = mapFromKeyValues(content, process.env);\n        }\n\n        if (key === '__CONFIG_DEFAULTS__') {\n          // Load app environment variables into default config.\n          Object.entries(process.env).forEach(([key, value]) => {\n            if (key.startsWith('DX_') || env?.includes(key)) {\n              setDeep(content, ['runtime', 'app', 'env', key], value);\n            }\n          });\n\n          // Set build info automatically if available.\n          try {\n            const timestamp = new Date().toISOString();\n            const commitHash =\n              process.env.DX_COMMIT_HASH ??\n              execSync('git rev-parse --short HEAD', { encoding: 'utf-8' }).replace('\\n', '');\n            const packagePath = pkgUp.sync();\n            const packageJson = packagePath && JSON.parse(readFileSync(packagePath, 'utf-8'));\n            setDeep(content, ['runtime', 'app', 'build', 'timestamp'], timestamp);\n            setDeep(content, ['runtime', 'app', 'build', 'commitHash'], commitHash);\n            setDeep(content, ['runtime', 'app', 'build', 'version'], packageJson?.version);\n          } catch {}\n        }\n      } catch (err: any) {\n        if (err.message.includes('YAMLException')) {\n          log.error(`Failed to parse file ${value}:`, err);\n        } else {\n          log(`Failed to load file ${value}:`, err);\n        }\n\n        if (key === '__CONFIG_DEFAULTS__') {\n          // Default config is required.\n          throw new Error(`Failed to load default config file from ${value}`);\n        }\n      }\n\n      return {\n        ...prev,\n        [key]: content,\n      };\n    },\n    {\n      __DXOS_CONFIG__: { dynamic: mode === 'production', publicUrl },\n      __CONFIG_DEFAULTS__: {},\n      __CONFIG_ENVS__: {},\n      __CONFIG_LOCAL__: {},\n    },\n  );\n};\n"],
  "mappings": ";;;AAKA,YAAYA,UAAU;;;ACDtB,SAASC,eAAe;AACxB,OAAOC,kBAAkB;AACzB,OAAOC,aAAa;AAEpB,SAASC,0BAA0B;AACnC,SAASC,cAAc;AAEvB,SAASC,aAAa;AACtB,SAASC,SAASC,eAAe;;;;;;;AAKjC,IAAMC,iBAAiBC,OAAOC,gBAAgB,oBAAA;AAgBvC,IAAMC,mBAAmB,CAACC,MAAmBC,WAAAA;AAClD,QAAMC,SAAS,CAAC;AAEhB,aAAW,CAACC,KAAK,EAAEC,MAAAA,OAAMC,KAAI,CAAE,KAAKC,OAAOC,QAAQP,IAAAA,GAAO;AACxD,QAAIQ,QAAQP,OAAOE,GAAAA;AAEnB,QAAIK,UAAUC,QAAW;AACvB,UAAIJ,MAAM;AACR,gBAAQA,MAAAA;UACN,KAAK,WAAW;AACdG,oBAAQE,QAAQF,KAAAA;AAChB;UACF;UAEA,KAAK,UAAU;AACbA,oBAAQG,OAAOH,KAAAA;AACf;UACF;UAEA,KAAK,UAAU;AACb;UACF;UAEA,KAAK,QAAQ;AACXA,oBAAQA,QAAQI,KAAKC,MAAML,KAAAA,IAAS;AACpC;UACF;UAEA,SAAS;AACP,kBAAM,IAAIM,MAAM,iBAAiBT,IAAAA,EAAM;UACzC;QACF;MACF;AAEAU,cAAQb,QAAQE,MAAKY,MAAM,GAAA,GAAMR,KAAAA;IACnC;EACF;AAEA,SAAON;AACT;AAOO,IAAMe,iBAAiB,CAACjB,MAAmBC,WAAAA;AAChD,QAAMC,SAA8B,CAAC;AAErC,aAAW,CAACC,KAAK,EAAEC,MAAAA,OAAMC,KAAI,CAAE,KAAKC,OAAOC,QAAQP,IAAAA,GAAO;AACxD,UAAMQ,QAAQU,QAAQjB,QAAQG,MAAKY,MAAM,GAAA,CAAA;AACzC,QAAIR,UAAUC,QAAW;AACvB,cAAQJ,MAAAA;QACN,KAAK;AACHH,iBAAOC,GAAAA,IAAOS,KAAKO,UAAUX,KAAAA;AAC7B;QACF;AACEN,iBAAOC,GAAAA,IAAOK;MAClB;IACF;EACF;AAEA,SAAON;AACT;AAKO,IAAMkB,iBAAiB,CAAClB,WAAAA;AAC7B,MAAI,EAAE,aAAaA,SAAS;AAC1B,UAAM,IAAImB,mBAAmB,uBAAA;EAC/B;AAEA,MAAInB,QAAQoB,YAAY,GAAG;AACzB,UAAM,IAAID,mBAAmB,2BAA2BnB,OAAOoB,OAAO,EAAE;EAC1E;AAEA,QAAMC,QAAQ3B,eAAe4B,UAAUC,OAAOvB,MAAAA;AAC9C,MAAIqB,OAAO;AACT,UAAM,IAAIF,mBAAmBE,KAAAA;EAC/B;AAEA,SAAOrB;AACT;AAEO,IAAMwB,iBAAiBC,OAAOC,IAAI,sBAAA;AAOlC,IAAMC,SAAN,MAAMA;;;;;EAOX,YAAY3B,SAAsB,CAAC,MAAM4B,SAAwB;AAC/D,SAAKC,UAAUX,eAAeY,aAAa9B,QAAAA,GAAW4B,SAAS;MAAER,SAAS;IAAE,CAAA,CAAA;EAC9E;;;;EAKA,IAAIrB,SAAsB;AACxB,WAAO,KAAK8B;EACd;;;;;;;;EASAE,IACE9B,KACA+B,cACiD;AACjD,WAAOhB,QAAQ,KAAKa,SAAS5B,IAAIa,MAAM,GAAA,CAAA,KAASkB;EAClD;;;;EAKAC,KAAc/B,OAAcgC,MAA6B;AACvD,UAAMnC,SAASiB,QAAQ,KAAKa,SAAS3B,MAAKY,MAAM,GAAA,CAAA;AAChD,QAAI,CAACqB,MAAMC,QAAQrC,MAAAA,GAAS;AAC1B;IACF;AAEA,WAAOA,OAAOkC,KAAK,CAAC3B,UAAU+B,QAAQ/B,OAAO4B,IAAAA,CAAAA;EAC/C;;;;;;EAOAI,WAAgCrC,KAAiE;AAC/F,UAAMK,QAAyDU,QAAQ,KAAKa,SAAS5B,IAAIa,MAAM,GAAA,CAAA;AAC/F,QAAI,CAACR,OAAO;AACV,YAAM,IAAIM,MAAM,8BAA8BX,GAAAA,EAAK;IACrD;AACA,WAAOK;EACT;AACF;;QAzDOiC,SAAAA;IAAWC,YAAYhB;;;;;ACxH9B,OAAOiB,UAAU;AACjB,OAAOC,QAAQ;AACf,OAAOC,UAAU;AAEjB,SAASC,WAAW;;;ACFb,IAAMC,gBAAgB;AACtB,IAAMC,YAAY;AAClB,IAAMC,gBAAgB;;;;ADQ7B,IAAMC,oBAAoBC,KAAKC,QAAQC,QAAQC,IAAG,GAAI,QAAA;AAEtD,IAAMC,gBAAgB,CAACC,SAAAA;AACrB,MAAI;AACF,WAAOC,KAAKC,KAAKC,GAAGC,aAAaJ,MAAM;MAAEK,UAAU;IAAO,CAAA,CAAA;EAC5D,SAASC,KAAU;EAEnB;AACF;AASO,IAAMC,UAAU,CAACC,UAAU,cAAS;AACzC,QAAMC,aAAad,KAAKe,KAAKb,QAAQc,IAAIC,QAAQ,KAAK,sBAAsBJ,OAAAA,MAAa;AACzF,SAAOT,cAAcU,UAAAA;AACvB;AAMO,IAAMI,QAAQ,OAA6B,CAAC;AAK5C,IAAMC,WAAW,OAA6B,CAAC;AAK/C,IAAMC,OAAO,CAACC,WAAWtB,sBAAiB;AAC/C,QAAMuB,UAAUlB,cAAcJ,KAAKC,QAAQoB,UAAUE,SAAAA,CAAAA;AACrD,SAAOD,UAAUE,iBAAiBF,SAASpB,QAAQc,GAAG,IAAI,CAAC;AAC7D;AAKO,IAAMS,WAAW,CAACJ,WAAWtB,sBAClCK,cAAcJ,KAAKC,QAAQoB,UAAUK,aAAAA,CAAAA,KAAmB,CAAC;AAKpD,IAAMC,UAAU,aAA4C,CAAC;AAE7D,IAAMC,SAAS,CAACC,QAA4BC,wBAAAA;AACjD,MAAI,CAACD,QAAQ;AACX,WAAO,CAAC;EACV;AAEA,MAAI;AACF,UAAME,MAAM,IAAIC,IAAIH,MAAAA;AACpB,UAAMI,WAAWF,IAAIE,SAASC,MAAM,GAAG,EAAC;AACxC,WAAO;MACLC,SAAS;QACPC,QAAQ;;UAENC,cAAcN,IAAIO,UAAUL,SAASM,WAAW,MAAA,IAAU,gBAAgB;UAC1EC,iCAAiCV;QACnC;MACF;IACF;EACF,SAASnB,KAAK;AACZ8B,QAAIC,MAAM/B,KAAAA,QAAAA;;;;;;AACV,WAAO,CAAC;EACV;AACF;;;AEnFO,IAAMgC,aAAa,OAAOC,MAAAA;AAAoB;;;ACFrD,OAAOC,WAAU;AACjB,SAASC,gBAAgB;AACzB,SAASC,oBAAoB;AAC7B,SAASC,eAAe;AACxB,OAAOC,WAAW;AAElB,SAASC,OAAAA,YAAW;AACpB,SAASC,WAAAA,gBAAe;;AAKxB,IAAMC,MAAMC,QAAQC,IAAG;AAEhB,IAAMC,cAAc,CAAC,EAC1BC,YACAC,SACAC,SACAC,OAAON,QAAQO,IAAIC,UACnBC,YAAY,IACZF,IAAG,MACc;AACjB,QAAMG,eAAe;IACnBC,qBAAqBR,YAAYS,SAAST,aAAaU,QAAQd,KAAK,QAAA;IACpEe,iBAAiBV,SAASQ,SAASR,UAAUS,QAAQd,KAAK,YAAA;EAC5D;AAEA,MAAIO,SAAS,cAAc;AACzBI,iBAAaK,mBAAmBV,WAAWQ,QAAQd,KAAK,cAAA;EAC1D;AAEA,SAAOiB,OAAOC,QAAQP,YAAAA,EAAcQ,OAClC,CAACC,MAAM,CAACC,KAAKC,KAAAA,MAAM;AACjB,QAAIC,UAAU,CAAC;AAEf,QAAI;AACFA,gBAAUC,MAAKC,KAAKC,aAAaJ,OAAO,OAAA,CAAA;AAGxC,UAAID,QAAQ,mBAAmB;AAC7BE,kBAAUI,iBAAiBJ,SAAStB,QAAQO,GAAG;MACjD;AAEA,UAAIa,QAAQ,uBAAuB;AAEjCJ,eAAOC,QAAQjB,QAAQO,GAAG,EAAEoB,QAAQ,CAAC,CAACP,MAAKC,MAAAA,MAAM;AAC/C,cAAID,KAAIQ,WAAW,KAAA,KAAUrB,KAAKsB,SAAST,IAAAA,GAAM;AAC/CU,YAAAA,SAAQR,SAAS;cAAC;cAAW;cAAO;cAAOF;eAAMC,MAAAA;UACnD;QACF,CAAA;AAGA,YAAI;AACF,gBAAMU,aAAY,oBAAIC,KAAAA,GAAOC,YAAW;AACxC,gBAAMC,aACJlC,QAAQO,IAAI4B,kBACZC,SAAS,8BAA8B;YAAEC,UAAU;UAAQ,CAAA,EAAGC,QAAQ,MAAM,EAAA;AAC9E,gBAAMC,cAAcC,MAAMC,KAAI;AAC9B,gBAAMC,cAAcH,eAAeI,KAAKC,MAAMnB,aAAac,aAAa,OAAA,CAAA;AACxET,UAAAA,SAAQR,SAAS;YAAC;YAAW;YAAO;YAAS;aAAcS,SAAAA;AAC3DD,UAAAA,SAAQR,SAAS;YAAC;YAAW;YAAO;YAAS;aAAeY,UAAAA;AAC5DJ,UAAAA,SAAQR,SAAS;YAAC;YAAW;YAAO;YAAS;aAAYoB,aAAaG,OAAAA;QACxE,QAAQ;QAAC;MACX;IACF,SAASC,KAAU;AACjB,UAAIA,IAAIC,QAAQlB,SAAS,eAAA,GAAkB;AACzCmB,QAAAA,KAAIC,MAAM,wBAAwB5B,KAAAA,KAAUyB,KAAAA;;;;;;MAC9C,OAAO;AACLE,QAAAA,KAAI,uBAAuB3B,KAAAA,KAAUyB,KAAAA;;;;;;MACvC;AAEA,UAAI1B,QAAQ,uBAAuB;AAEjC,cAAM,IAAI8B,MAAM,2CAA2C7B,KAAAA,EAAO;MACpE;IACF;AAEA,WAAO;MACL,GAAGF;MACH,CAACC,GAAAA,GAAME;IACT;EACF,GACA;IACE6B,iBAAiB;MAAEC,SAAS9C,SAAS;MAAcG;IAAU;IAC7DE,qBAAqB,CAAC;IACtBG,iBAAiB,CAAC;IAClBC,kBAAkB,CAAC;EACrB,CAAA;AAEJ;",
  "names": ["defs", "boolean", "defaultsDeep", "isMatch", "InvalidConfigError", "schema", "trace", "getDeep", "setDeep", "configRootType", "schema", "getCodecForType", "mapFromKeyValues", "spec", "values", "config", "key", "path", "type", "Object", "entries", "value", "undefined", "boolean", "Number", "JSON", "parse", "Error", "setDeep", "split", "mapToKeyValues", "getDeep", "stringify", "validateConfig", "InvalidConfigError", "version", "error", "protoType", "verify", "ConfigResource", "Symbol", "for", "Config", "objects", "_config", "defaultsDeep", "get", "defaultValue", "find", "test", "Array", "isArray", "isMatch", "getOrThrow", "resource", "annotation", "yaml", "fs", "path", "log", "FILE_DEFAULTS", "FILE_ENVS", "FILE_DYNAMICS", "DEFAULT_BASE_PATH", "path", "resolve", "process", "cwd", "maybeLoadFile", "file", "yaml", "load", "fs", "readFileSync", "encoding", "err", "Profile", "profile", "configFile", "join", "env", "HOME", "Local", "Dynamics", "Envs", "basePath", "content", "FILE_ENVS", "mapFromKeyValues", "Defaults", "FILE_DEFAULTS", "Storage", "Remote", "target", "authenticationToken", "url", "URL", "protocol", "slice", "runtime", "client", "remoteSource", "origin", "startsWith", "remoteSourceAuthenticationToken", "log", "catch", "SaveConfig", "_", "yaml", "execSync", "readFileSync", "resolve", "pkgUp", "log", "setDeep", "CWD", "process", "cwd", "definitions", "configPath", "envPath", "devPath", "mode", "env", "NODE_ENV", "publicUrl", "KEYS_TO_FILE", "__CONFIG_DEFAULTS__", "length", "resolve", "__CONFIG_ENVS__", "__CONFIG_LOCAL__", "Object", "entries", "reduce", "prev", "key", "value", "content", "yaml", "load", "readFileSync", "mapFromKeyValues", "forEach", "startsWith", "includes", "setDeep", "timestamp", "Date", "toISOString", "commitHash", "DX_COMMIT_HASH", "execSync", "encoding", "replace", "packagePath", "pkgUp", "sync", "packageJson", "JSON", "parse", "version", "err", "message", "log", "error", "Error", "__DXOS_CONFIG__", "dynamic"]
}
