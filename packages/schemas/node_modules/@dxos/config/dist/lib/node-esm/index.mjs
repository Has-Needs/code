import { createRequire } from 'node:module';const require = createRequire(import.meta.url);

// packages/sdk/config/src/index.ts
import * as defs from "@dxos/protocols/proto/dxos/config";

// packages/sdk/config/src/config.ts
import { boolean } from "boolean";
import defaultsDeep from "lodash.defaultsdeep";
import isMatch from "lodash.ismatch";
import { InvalidConfigError } from "@dxos/protocols";
import { schema } from "@dxos/protocols/proto";
import { trace } from "@dxos/tracing";
import { getDeep, setDeep } from "@dxos/util";
function _ts_decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var configRootType = schema.getCodecForType("dxos.config.Config");
var mapFromKeyValues = (spec, values) => {
  const config = {};
  for (const [key, { path: path2, type }] of Object.entries(spec)) {
    let value = values[key];
    if (value !== void 0) {
      if (type) {
        switch (type) {
          case "boolean": {
            value = boolean(value);
            break;
          }
          case "number": {
            value = Number(value);
            break;
          }
          case "string": {
            break;
          }
          case "json": {
            value = value ? JSON.parse(value) : null;
            break;
          }
          default: {
            throw new Error(`Invalid type: ${type}`);
          }
        }
      }
      setDeep(config, path2.split("."), value);
    }
  }
  return config;
};
var mapToKeyValues = (spec, values) => {
  const config = {};
  for (const [key, { path: path2, type }] of Object.entries(spec)) {
    const value = getDeep(values, path2.split("."));
    if (value !== void 0) {
      switch (type) {
        case "json":
          config[key] = JSON.stringify(value);
          break;
        default:
          config[key] = value;
      }
    }
  }
  return config;
};
var validateConfig = (config) => {
  if (!("version" in config)) {
    throw new InvalidConfigError("Version not specified");
  }
  if (config?.version !== 1) {
    throw new InvalidConfigError(`Invalid config version: ${config.version}`);
  }
  const error = configRootType.protoType.verify(config);
  if (error) {
    throw new InvalidConfigError(error);
  }
  return config;
};
var ConfigResource = Symbol.for("dxos.resource.Config");
var Config = class {
  /**
  * Creates an immutable instance.
  * @constructor
  */
  constructor(config = {}, ...objects) {
    this._config = validateConfig(defaultsDeep(config, ...objects, {
      version: 1
    }));
  }
  /**
  * Returns an immutable config JSON object.
  */
  get values() {
    return this._config;
  }
  /**
  * Returns the given config property.
  *
  * @param key A key in the config object. Can be a nested property with keys separated by dots: 'services.signal.server'.
  * @param defaultValue Default value to return if option is not present in the config.
  * @returns The config value or undefined if the option is not present.
  */
  get(key, defaultValue) {
    return getDeep(this._config, key.split(".")) ?? defaultValue;
  }
  /**
  * Get unique key.
  */
  find(path2, test) {
    const values = getDeep(this._config, path2.split("."));
    if (!Array.isArray(values)) {
      return;
    }
    return values.find((value) => isMatch(value, test));
  }
  /**
  * Returns the given config property or throw if it doesn't exist.
  *
  * @param key A key in the config object. Can be a nested property with keys separated by dots: 'services.signal.server'.
  */
  getOrThrow(key) {
    const value = getDeep(this._config, key.split("."));
    if (!value) {
      throw new Error(`Config option not present: ${key}`);
    }
    return value;
  }
};
Config = _ts_decorate([
  trace.resource({
    annotation: ConfigResource
  })
], Config);

// packages/sdk/config/src/loaders/index.ts
import yaml from "js-yaml";
import fs from "node:fs";
import path from "node:path";
import { log } from "@dxos/log";

// packages/sdk/config/src/types.ts
var FILE_DEFAULTS = "defaults.yml";
var FILE_ENVS = "envs-map.yml";
var FILE_DYNAMICS = "config.yml";

// packages/sdk/config/src/loaders/index.ts
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/sdk/config/src/loaders/index.ts";
var DEFAULT_BASE_PATH = path.resolve(process.cwd(), "config");
var maybeLoadFile = (file) => {
  try {
    return yaml.load(fs.readFileSync(file, {
      encoding: "utf8"
    }));
  } catch (err) {
  }
};
var Profile = (profile = "default") => {
  const configFile = path.join(process.env.HOME ?? "~", `.config/dx/profile/${profile}.yml`);
  return maybeLoadFile(configFile);
};
var Local = () => ({});
var Dynamics = () => ({});
var Envs = (basePath = DEFAULT_BASE_PATH) => {
  const content = maybeLoadFile(path.resolve(basePath, FILE_ENVS));
  return content ? mapFromKeyValues(content, process.env) : {};
};
var Defaults = (basePath = DEFAULT_BASE_PATH) => maybeLoadFile(path.resolve(basePath, FILE_DEFAULTS)) ?? {};
var Storage = async () => ({});
var Remote = (target, authenticationToken) => {
  if (!target) {
    return {};
  }
  try {
    const url = new URL(target);
    const protocol = url.protocol.slice(0, -1);
    return {
      runtime: {
        client: {
          // TODO(burdon): Remove vault.html.
          remoteSource: url.origin + (protocol.startsWith("http") ? "/vault.html" : ""),
          remoteSourceAuthenticationToken: authenticationToken
        }
      }
    };
  } catch (err) {
    log.catch(err, void 0, {
      F: __dxlog_file,
      L: 87,
      S: void 0,
      C: (f, a) => f(...a)
    });
    return {};
  }
};

// packages/sdk/config/src/savers/index.ts
var SaveConfig = async (_) => {
};

// packages/sdk/config/src/plugin/definitions.ts
import yaml2 from "js-yaml";
import { execSync } from "node:child_process";
import { readFileSync } from "node:fs";
import { resolve } from "node:path";
import pkgUp from "pkg-up";
import { log as log2 } from "@dxos/log";
import { setDeep as setDeep2 } from "@dxos/util";
var __dxlog_file2 = "/home/runner/work/dxos/dxos/packages/sdk/config/src/plugin/definitions.ts";
var CWD = process.cwd();
var definitions = ({ configPath, envPath, devPath, mode = process.env.NODE_ENV, publicUrl = "", env }) => {
  const KEYS_TO_FILE = {
    __CONFIG_DEFAULTS__: configPath?.length ? configPath : resolve(CWD, "dx.yml"),
    __CONFIG_ENVS__: envPath?.length ? envPath : resolve(CWD, "dx-env.yml")
  };
  if (mode !== "production") {
    KEYS_TO_FILE.__CONFIG_LOCAL__ = devPath ?? resolve(CWD, "dx-local.yml");
  }
  return Object.entries(KEYS_TO_FILE).reduce((prev, [key, value]) => {
    let content = {};
    try {
      content = yaml2.load(readFileSync(value, "utf-8"));
      if (key === "__CONFIG_ENVS__") {
        content = mapFromKeyValues(content, process.env);
      }
      if (key === "__CONFIG_DEFAULTS__") {
        Object.entries(process.env).forEach(([key2, value2]) => {
          if (key2.startsWith("DX_") || env?.includes(key2)) {
            setDeep2(content, [
              "runtime",
              "app",
              "env",
              key2
            ], value2);
          }
        });
        try {
          const timestamp = (/* @__PURE__ */ new Date()).toISOString();
          const commitHash = process.env.DX_COMMIT_HASH ?? execSync("git rev-parse --short HEAD", {
            encoding: "utf-8"
          }).replace("\n", "");
          const packagePath = pkgUp.sync();
          const packageJson = packagePath && JSON.parse(readFileSync(packagePath, "utf-8"));
          setDeep2(content, [
            "runtime",
            "app",
            "build",
            "timestamp"
          ], timestamp);
          setDeep2(content, [
            "runtime",
            "app",
            "build",
            "commitHash"
          ], commitHash);
          setDeep2(content, [
            "runtime",
            "app",
            "build",
            "version"
          ], packageJson?.version);
        } catch {
        }
      }
    } catch (err) {
      if (err.message.includes("YAMLException")) {
        log2.error(`Failed to parse file ${value}:`, err, {
          F: __dxlog_file2,
          L: 71,
          S: void 0,
          C: (f, a) => f(...a)
        });
      } else {
        log2(`Failed to load file ${value}:`, err, {
          F: __dxlog_file2,
          L: 73,
          S: void 0,
          C: (f, a) => f(...a)
        });
      }
      if (key === "__CONFIG_DEFAULTS__") {
        throw new Error(`Failed to load default config file from ${value}`);
      }
    }
    return {
      ...prev,
      [key]: content
    };
  }, {
    __DXOS_CONFIG__: {
      dynamic: mode === "production",
      publicUrl
    },
    __CONFIG_DEFAULTS__: {},
    __CONFIG_ENVS__: {},
    __CONFIG_LOCAL__: {}
  });
};
export {
  Config,
  ConfigResource,
  Defaults,
  Dynamics,
  Envs,
  FILE_DEFAULTS,
  FILE_DYNAMICS,
  FILE_ENVS,
  Local,
  Profile,
  Remote,
  SaveConfig,
  Storage,
  definitions,
  defs,
  mapFromKeyValues,
  mapToKeyValues,
  validateConfig
};
//# sourceMappingURL=index.mjs.map
