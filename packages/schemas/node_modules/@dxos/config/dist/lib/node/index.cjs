"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var node_exports = {};
__export(node_exports, {
  Config: () => Config,
  ConfigResource: () => ConfigResource,
  Defaults: () => Defaults,
  Dynamics: () => Dynamics,
  Envs: () => Envs,
  FILE_DEFAULTS: () => FILE_DEFAULTS,
  FILE_DYNAMICS: () => FILE_DYNAMICS,
  FILE_ENVS: () => FILE_ENVS,
  Local: () => Local,
  Profile: () => Profile,
  Remote: () => Remote,
  SaveConfig: () => SaveConfig,
  Storage: () => Storage,
  definitions: () => definitions,
  defs: () => defs,
  mapFromKeyValues: () => mapFromKeyValues,
  mapToKeyValues: () => mapToKeyValues,
  validateConfig: () => validateConfig
});
module.exports = __toCommonJS(node_exports);
var defs = __toESM(require("@dxos/protocols/proto/dxos/config"));
var import_boolean = require("boolean");
var import_lodash = __toESM(require("lodash.defaultsdeep"));
var import_lodash2 = __toESM(require("lodash.ismatch"));
var import_protocols = require("@dxos/protocols");
var import_proto = require("@dxos/protocols/proto");
var import_tracing = require("@dxos/tracing");
var import_util = require("@dxos/util");
var import_js_yaml = __toESM(require("js-yaml"));
var import_node_fs = __toESM(require("node:fs"));
var import_node_path = __toESM(require("node:path"));
var import_log = require("@dxos/log");
var import_js_yaml2 = __toESM(require("js-yaml"));
var import_node_child_process = require("node:child_process");
var import_node_fs2 = require("node:fs");
var import_node_path2 = require("node:path");
var import_pkg_up = __toESM(require("pkg-up"));
var import_log2 = require("@dxos/log");
var import_util2 = require("@dxos/util");
function _ts_decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var configRootType = import_proto.schema.getCodecForType("dxos.config.Config");
var mapFromKeyValues = (spec, values) => {
  const config = {};
  for (const [key, { path: path2, type }] of Object.entries(spec)) {
    let value = values[key];
    if (value !== void 0) {
      if (type) {
        switch (type) {
          case "boolean": {
            value = (0, import_boolean.boolean)(value);
            break;
          }
          case "number": {
            value = Number(value);
            break;
          }
          case "string": {
            break;
          }
          case "json": {
            value = value ? JSON.parse(value) : null;
            break;
          }
          default: {
            throw new Error(`Invalid type: ${type}`);
          }
        }
      }
      (0, import_util.setDeep)(config, path2.split("."), value);
    }
  }
  return config;
};
var mapToKeyValues = (spec, values) => {
  const config = {};
  for (const [key, { path: path2, type }] of Object.entries(spec)) {
    const value = (0, import_util.getDeep)(values, path2.split("."));
    if (value !== void 0) {
      switch (type) {
        case "json":
          config[key] = JSON.stringify(value);
          break;
        default:
          config[key] = value;
      }
    }
  }
  return config;
};
var validateConfig = (config) => {
  if (!("version" in config)) {
    throw new import_protocols.InvalidConfigError("Version not specified");
  }
  if (config?.version !== 1) {
    throw new import_protocols.InvalidConfigError(`Invalid config version: ${config.version}`);
  }
  const error = configRootType.protoType.verify(config);
  if (error) {
    throw new import_protocols.InvalidConfigError(error);
  }
  return config;
};
var ConfigResource = Symbol.for("dxos.resource.Config");
var Config = class {
  /**
  * Creates an immutable instance.
  * @constructor
  */
  constructor(config = {}, ...objects) {
    this._config = validateConfig((0, import_lodash.default)(config, ...objects, {
      version: 1
    }));
  }
  /**
  * Returns an immutable config JSON object.
  */
  get values() {
    return this._config;
  }
  /**
  * Returns the given config property.
  *
  * @param key A key in the config object. Can be a nested property with keys separated by dots: 'services.signal.server'.
  * @param defaultValue Default value to return if option is not present in the config.
  * @returns The config value or undefined if the option is not present.
  */
  get(key, defaultValue) {
    return (0, import_util.getDeep)(this._config, key.split(".")) ?? defaultValue;
  }
  /**
  * Get unique key.
  */
  find(path2, test) {
    const values = (0, import_util.getDeep)(this._config, path2.split("."));
    if (!Array.isArray(values)) {
      return;
    }
    return values.find((value) => (0, import_lodash2.default)(value, test));
  }
  /**
  * Returns the given config property or throw if it doesn't exist.
  *
  * @param key A key in the config object. Can be a nested property with keys separated by dots: 'services.signal.server'.
  */
  getOrThrow(key) {
    const value = (0, import_util.getDeep)(this._config, key.split("."));
    if (!value) {
      throw new Error(`Config option not present: ${key}`);
    }
    return value;
  }
};
Config = _ts_decorate([
  import_tracing.trace.resource({
    annotation: ConfigResource
  })
], Config);
var FILE_DEFAULTS = "defaults.yml";
var FILE_ENVS = "envs-map.yml";
var FILE_DYNAMICS = "config.yml";
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/sdk/config/src/loaders/index.ts";
var DEFAULT_BASE_PATH = import_node_path.default.resolve(process.cwd(), "config");
var maybeLoadFile = (file) => {
  try {
    return import_js_yaml.default.load(import_node_fs.default.readFileSync(file, {
      encoding: "utf8"
    }));
  } catch (err) {
  }
};
var Profile = (profile = "default") => {
  const configFile = import_node_path.default.join(process.env.HOME ?? "~", `.config/dx/profile/${profile}.yml`);
  return maybeLoadFile(configFile);
};
var Local = () => ({});
var Dynamics = () => ({});
var Envs = (basePath = DEFAULT_BASE_PATH) => {
  const content = maybeLoadFile(import_node_path.default.resolve(basePath, FILE_ENVS));
  return content ? mapFromKeyValues(content, process.env) : {};
};
var Defaults = (basePath = DEFAULT_BASE_PATH) => maybeLoadFile(import_node_path.default.resolve(basePath, FILE_DEFAULTS)) ?? {};
var Storage = async () => ({});
var Remote = (target, authenticationToken) => {
  if (!target) {
    return {};
  }
  try {
    const url = new URL(target);
    const protocol = url.protocol.slice(0, -1);
    return {
      runtime: {
        client: {
          // TODO(burdon): Remove vault.html.
          remoteSource: url.origin + (protocol.startsWith("http") ? "/vault.html" : ""),
          remoteSourceAuthenticationToken: authenticationToken
        }
      }
    };
  } catch (err) {
    import_log.log.catch(err, void 0, {
      F: __dxlog_file,
      L: 87,
      S: void 0,
      C: (f, a) => f(...a)
    });
    return {};
  }
};
var SaveConfig = async (_) => {
};
var __dxlog_file2 = "/home/runner/work/dxos/dxos/packages/sdk/config/src/plugin/definitions.ts";
var CWD = process.cwd();
var definitions = ({ configPath, envPath, devPath, mode = process.env.NODE_ENV, publicUrl = "", env }) => {
  const KEYS_TO_FILE = {
    __CONFIG_DEFAULTS__: configPath?.length ? configPath : (0, import_node_path2.resolve)(CWD, "dx.yml"),
    __CONFIG_ENVS__: envPath?.length ? envPath : (0, import_node_path2.resolve)(CWD, "dx-env.yml")
  };
  if (mode !== "production") {
    KEYS_TO_FILE.__CONFIG_LOCAL__ = devPath ?? (0, import_node_path2.resolve)(CWD, "dx-local.yml");
  }
  return Object.entries(KEYS_TO_FILE).reduce((prev, [key, value]) => {
    let content = {};
    try {
      content = import_js_yaml2.default.load((0, import_node_fs2.readFileSync)(value, "utf-8"));
      if (key === "__CONFIG_ENVS__") {
        content = mapFromKeyValues(content, process.env);
      }
      if (key === "__CONFIG_DEFAULTS__") {
        Object.entries(process.env).forEach(([key2, value2]) => {
          if (key2.startsWith("DX_") || env?.includes(key2)) {
            (0, import_util2.setDeep)(content, [
              "runtime",
              "app",
              "env",
              key2
            ], value2);
          }
        });
        try {
          const timestamp = (/* @__PURE__ */ new Date()).toISOString();
          const commitHash = process.env.DX_COMMIT_HASH ?? (0, import_node_child_process.execSync)("git rev-parse --short HEAD", {
            encoding: "utf-8"
          }).replace("\n", "");
          const packagePath = import_pkg_up.default.sync();
          const packageJson = packagePath && JSON.parse((0, import_node_fs2.readFileSync)(packagePath, "utf-8"));
          (0, import_util2.setDeep)(content, [
            "runtime",
            "app",
            "build",
            "timestamp"
          ], timestamp);
          (0, import_util2.setDeep)(content, [
            "runtime",
            "app",
            "build",
            "commitHash"
          ], commitHash);
          (0, import_util2.setDeep)(content, [
            "runtime",
            "app",
            "build",
            "version"
          ], packageJson?.version);
        } catch {
        }
      }
    } catch (err) {
      if (err.message.includes("YAMLException")) {
        import_log2.log.error(`Failed to parse file ${value}:`, err, {
          F: __dxlog_file2,
          L: 71,
          S: void 0,
          C: (f, a) => f(...a)
        });
      } else {
        (0, import_log2.log)(`Failed to load file ${value}:`, err, {
          F: __dxlog_file2,
          L: 73,
          S: void 0,
          C: (f, a) => f(...a)
        });
      }
      if (key === "__CONFIG_DEFAULTS__") {
        throw new Error(`Failed to load default config file from ${value}`);
      }
    }
    return {
      ...prev,
      [key]: content
    };
  }, {
    __DXOS_CONFIG__: {
      dynamic: mode === "production",
      publicUrl
    },
    __CONFIG_DEFAULTS__: {},
    __CONFIG_ENVS__: {},
    __CONFIG_LOCAL__: {}
  });
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Config,
  ConfigResource,
  Defaults,
  Dynamics,
  Envs,
  FILE_DEFAULTS,
  FILE_DYNAMICS,
  FILE_ENVS,
  Local,
  Profile,
  Remote,
  SaveConfig,
  Storage,
  definitions,
  defs,
  mapFromKeyValues,
  mapToKeyValues,
  validateConfig
});
//# sourceMappingURL=index.cjs.map
