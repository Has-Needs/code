import { type Config as ConfigProto } from '@dxos/protocols/proto/dxos/config';
import { type ConfigKey, type DeepIndex, type ParseKey } from './types';
type MappingSpec = Record<string, {
    path: string;
    type?: string;
}>;
/**
 * Maps the given objects onto a flattened set of (key x values).
 *
 * Expects parsed yaml content of the form:
 *
 * ```
 * ENV_VAR:
 *   path: config.selector.path
 * ```
 *
 * @param {object} spec
 * @param {object} values
 * @return {object}
 */
export declare const mapFromKeyValues: (spec: MappingSpec, values: Record<string, any>) => {};
/**
 * Maps the given flattend set of (key x values) onto a JSON object.
 * @param {object} spec
 * @param {object} values
 */
export declare const mapToKeyValues: (spec: MappingSpec, values: any) => Record<string, any>;
/**
 * Validate config object.
 */
export declare const validateConfig: (config: ConfigProto) => ConfigProto;
export declare const ConfigResource: unique symbol;
/**
 * Global configuration object.
 * NOTE: Config objects are immutable.
 */
export declare class Config {
    private readonly _config;
    /**
     * Creates an immutable instance.
     * @constructor
     */
    constructor(config?: ConfigProto, ...objects: ConfigProto[]);
    /**
     * Returns an immutable config JSON object.
     */
    get values(): ConfigProto;
    /**
     * Returns the given config property.
     *
     * @param key A key in the config object. Can be a nested property with keys separated by dots: 'services.signal.server'.
     * @param defaultValue Default value to return if option is not present in the config.
     * @returns The config value or undefined if the option is not present.
     */
    get<K extends ConfigKey>(key: K, defaultValue?: DeepIndex<ConfigProto, ParseKey<K>>): DeepIndex<ConfigProto, ParseKey<K>> | undefined;
    /**
     * Get unique key.
     */
    find<T = any>(path: string, test: object): T | undefined;
    /**
     * Returns the given config property or throw if it doesn't exist.
     *
     * @param key A key in the config object. Can be a nested property with keys separated by dots: 'services.signal.server'.
     */
    getOrThrow<K extends ConfigKey>(key: K): Exclude<DeepIndex<ConfigProto, ParseKey<K>>, undefined>;
}
export {};
//# sourceMappingURL=config.d.ts.map