import {
  Filter,
  SpaceState,
  getMeta
} from "./chunk-NHOVA3RZ.mjs";

// packages/sdk/client/src/devtools/index.ts
import { KeyType } from "@dxos/protocols/proto/dxos/halo/keys";

// packages/sdk/client/src/devtools/devtools.ts
import { next as am } from "@automerge/automerge";
import { cbor } from "@automerge/automerge-repo";
import { exposeModule, importModule } from "@dxos/debug";
import { PublicKey } from "@dxos/keys";
import { log } from "@dxos/log";
import { createBundledRpcServer } from "@dxos/rpc";
import { TRACE_PROCESSOR } from "@dxos/tracing";
import { joinTables } from "@dxos/util";
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/sdk/client/src/devtools/devtools.ts";
exposeModule("@automerge/automerge", am);
var mountDevtoolsHooks = ({ client, host }) => {
  let server;
  let diagnostics = [];
  const hook = {
    // To debug client from console using 'window.__DXOS__.client'.
    client,
    host,
    tracing: TRACE_PROCESSOR,
    openClientRpcServer: async () => {
      if (!client) {
        log.error("Client not available", void 0, {
          F: __dxlog_file,
          L: 87,
          S: void 0,
          C: (f, a) => f(...a)
        });
        return false;
      }
      if (server) {
        log("Closing existing client RPC server.", void 0, {
          F: __dxlog_file,
          L: 92,
          S: void 0,
          C: (f, a) => f(...a)
        });
        await server.close();
      }
      log("Opening devtools client RPC server...", void 0, {
        F: __dxlog_file,
        L: 96,
        S: void 0,
        C: (f, a) => f(...a)
      });
      server = createBundledRpcServer({
        services: client.services.descriptors,
        handlers: client.services.services,
        port
      });
      await server.open().catch((err) => {
        log.error(`Failed to open RPC server: ${err}`, void 0, {
          F: __dxlog_file,
          L: 104,
          S: void 0,
          C: (f, a) => f(...a)
        });
        return false;
      });
      log("Opened devtools client RPC server.", void 0, {
        F: __dxlog_file,
        L: 108,
        S: void 0,
        C: (f, a) => f(...a)
      });
      return true;
    },
    reset,
    importModule,
    listDiagnostics: async () => {
      diagnostics = await TRACE_PROCESSOR.diagnosticsChannel.discover();
      console.table(diagnostics.map((diagnostic) => ({
        ...diagnostic,
        get fetch() {
          queueMicrotask(async () => {
            const { data, error } = await TRACE_PROCESSOR.diagnosticsChannel.fetch(diagnostic);
            if (error) {
              log.error(`Error fetching diagnostic ${diagnostic.id}: ${error}`, void 0, {
                F: __dxlog_file,
                L: 127,
                S: this,
                C: (f, a) => f(...a)
              });
              return;
            }
            console.table(data);
          });
          return void 0;
        }
      })));
    },
    // TODO(dmaretskyi): Joins across multiple diagnostics.
    fetchDiagnostics: async (id, instanceTag) => {
      const { data, error } = await TRACE_PROCESSOR.diagnosticsChannel.fetch({
        id,
        instanceTag
      });
      if (error) {
        log.error(`Error fetching diagnostic ${id}: ${error}`, void 0, {
          F: __dxlog_file,
          L: 144,
          S: void 0,
          C: (f, a) => f(...a)
        });
        return;
      }
      return data;
    },
    joinTables,
    // Globals.
    Filter,
    getMeta
  };
  if (client) {
    hook.spaces = createAccessor({
      getAll: () => client.spaces.get(),
      getByKey: (key) => client.spaces.get().find((space) => space.key.equals(key)),
      getSearchMap: () => new Map(client.spaces.get().flatMap((space) => [
        [
          space.id,
          space
        ],
        ...space.state.get() === SpaceState.SPACE_READY ? [
          [
            space.properties.name,
            space
          ]
        ] : [],
        [
          space.key.toHex(),
          space
        ]
      ]))
    });
    hook.halo = client.halo;
    hook.openDevtoolsApp = async () => {
      const vault = client.config?.values.runtime?.client?.remoteSource ?? "https://halo.dxos.org";
      let hasLocalDevtools = false;
      try {
        await fetch("http://localhost:5174/");
        hasLocalDevtools = true;
      } catch {
      }
      const isDev = window.location.href.includes(".dev.") || window.location.href.includes("localhost");
      const devtoolsApp = hasLocalDevtools ? "http://localhost:5174/" : `https://devtools${isDev ? ".dev." : "."}dxos.org/`;
      const devtoolsUrl = `${devtoolsApp}?target=${vault}`;
      window.open(devtoolsUrl, "_blank");
    };
    hook.downloadDiagnostics = async () => {
      const diagnostics2 = JSON.stringify(await client.diagnostics(), null, 4);
      downloadFile(diagnostics2, "application/json", `diagnostics-${window.location.hostname}-${(/* @__PURE__ */ new Date()).toISOString()}.json`);
    };
    hook.exportProfile = async () => {
      const { createLevel, createStorageObjects, exportProfileData } = await import("@dxos/client-services");
      const storageConfig = client.config.get("runtime.client.storage", {});
      const { storage } = createStorageObjects(storageConfig);
      const level = await createLevel(storageConfig);
      log.info("begin profile export", {
        storageConfig
      }, {
        F: __dxlog_file,
        L: 210,
        S: void 0,
        C: (f, a) => f(...a)
      });
      const archive = await exportProfileData({
        storage,
        level
      });
      log.info("done profile export", {
        storageEntries: archive.storage.length
      }, {
        F: __dxlog_file,
        L: 213,
        S: void 0,
        C: (f, a) => f(...a)
      });
      downloadFile(cbor.encode(archive), "application/octet-stream", "profile.dxprofile");
    };
    hook.importProfile = async () => {
      log.warn("Make sure to clear your data before importing a profile (Site Settings -> Clear data)", void 0, {
        F: __dxlog_file,
        L: 219,
        S: void 0,
        C: (f, a) => f(...a)
      });
      const data = await uploadFile();
      const { createLevel, createStorageObjects, decodeProfileArchive, importProfileData } = await import("@dxos/client-services");
      const storageConfig = client.config.get("runtime.client.storage", {});
      await client.destroy().catch(() => {
      });
      const { storage } = createStorageObjects(storageConfig);
      const level = await createLevel(storageConfig);
      const archive = decodeProfileArchive(data);
      log.info("begin profile import", {
        storageConfig,
        storageEntries: archive.storage.length
      }, {
        F: __dxlog_file,
        L: 236,
        S: void 0,
        C: (f, a) => f(...a)
      });
      await importProfileData({
        storage,
        level
      }, archive);
      log.info("done profile import", void 0, {
        F: __dxlog_file,
        L: 240,
        S: void 0,
        C: (f, a) => f(...a)
      });
      window.location.reload();
    };
  }
  if (host) {
    hook.spaces = createAccessor({
      getAll: () => Array.from(host.context.dataSpaceManager?.spaces.values() ?? []),
      getByKey: (key) => host.context.dataSpaceManager?.spaces.get(key),
      getSearchMap: () => new Map(Array.from(host.context.dataSpaceManager?.spaces.values() ?? []).flatMap((space) => [
        [
          space.key.toHex(),
          space
        ]
      ]))
    });
    hook.feeds = createAccessor({
      getAll: () => Array.from(host.context.feedStore?.feeds.values() ?? []),
      getByKey: (key) => host.context.feedStore?.feeds.find((feed) => feed.key.equals(key)),
      getSearchMap: () => new Map(Array.from(host.context.feedStore?.feeds.values() ?? []).flatMap((feed) => [
        [
          feed.key.toHex(),
          feed
        ]
      ]))
    });
  }
  globalThis.__DXOS__ = hook;
  let warningShown = false;
  Object.defineProperty(globalThis, "dxos", {
    get: () => {
      if (!warningShown) {
        warningShown = true;
        log.warn("globalThis.dxos is an undocumented API and may changed or removed entirely without notice.", void 0, {
          F: __dxlog_file,
          L: 272,
          S: void 0,
          C: (f, a) => f(...a)
        });
      }
      return hook;
    },
    configurable: true
  });
};
var unmountDevtoolsHooks = () => {
  delete globalThis.__DXOS__;
  delete globalThis.dxos;
};
var createAccessor = ({ getByKey, getSearchMap, getAll }) => (keyOrSearch) => {
  if (typeof keyOrSearch === "undefined") {
    return getAll?.() ?? [];
  }
  if (keyOrSearch instanceof PublicKey) {
    return getByKey?.(keyOrSearch);
  }
  const searchSpace = getSearchMap?.() ?? /* @__PURE__ */ new Map();
  if (searchSpace.has(keyOrSearch)) {
    return searchSpace.get(keyOrSearch);
  }
  for (const [key, value] of searchSpace.entries()) {
    if (key.startsWith(keyOrSearch)) {
      return value;
    }
  }
  for (const [key, value] of searchSpace.entries()) {
    if (key.includes(keyOrSearch)) {
      return value;
    }
  }
  return void 0;
};
var port = {
  send: async (message) => window.postMessage({
    data: Array.from(message),
    source: "dxos-client"
  }, "*"),
  subscribe: (callback) => {
    const handler = (event) => {
      if (event.source !== window) {
        return;
      }
      const message = event.data;
      if (typeof message !== "object" || message === null || message.source !== "content-script") {
        return;
      }
      callback(new Uint8Array(message.data));
    };
    window.addEventListener("message", handler);
    return () => window.removeEventListener("message", handler);
  }
};
var reset = async () => {
  log.info(`Deleting all data from ${typeof window.localStorage !== "undefined" ? window.location?.origin : ""}`, void 0, {
    F: __dxlog_file,
    L: 355,
    S: void 0,
    C: (f, a) => f(...a)
  });
  if (typeof localStorage !== "undefined") {
    localStorage.clear();
    log.info("Cleared local storage", void 0, {
      F: __dxlog_file,
      L: 359,
      S: void 0,
      C: (f, a) => f(...a)
    });
  }
  if (typeof navigator !== "undefined" && typeof navigator.storage !== "undefined" && typeof navigator.storage.getDirectory === "function") {
    const root = await navigator.storage.getDirectory();
    for await (const entry of root.keys()) {
      try {
        await root.removeEntry(entry, {
          recursive: true
        });
      } catch (err) {
        log.error(`Failed to delete ${entry}: ${err}`, void 0, {
          F: __dxlog_file,
          L: 372,
          S: void 0,
          C: (f, a) => f(...a)
        });
      }
    }
    log.info("Cleared OPFS", void 0, {
      F: __dxlog_file,
      L: 375,
      S: void 0,
      C: (f, a) => f(...a)
    });
    if (typeof location !== "undefined" && typeof location.reload === "function") {
      location.reload();
    } else if (typeof close === "function") {
      close();
    }
  }
};
var downloadFile = (data, contentType, filename) => {
  const url = URL.createObjectURL(new Blob([
    data
  ], {
    type: contentType
  }));
  const element = document.createElement("a");
  element.setAttribute("href", url);
  element.setAttribute("download", filename);
  element.setAttribute("target", "download");
  element.click();
};
var uploadFile = () => {
  return new Promise((resolve, reject) => {
    const dropArea = document.createElement("div");
    dropArea.style.width = "100%";
    dropArea.style.height = "100%";
    dropArea.style.backgroundColor = "rgba(0, 0, 0, 0.5)";
    dropArea.style.display = "flex";
    dropArea.style.justifyContent = "center";
    dropArea.style.alignItems = "center";
    dropArea.style.position = "fixed";
    const text = document.createElement("p");
    text.textContent = "Drop file here";
    text.style.color = "white";
    text.style.fontSize = "24px";
    dropArea.appendChild(text);
    document.body.appendChild(dropArea);
    const handleDrop = (event) => {
      event.preventDefault();
      const file = event.dataTransfer?.files?.[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = () => {
          const arrayBuffer = reader.result;
          const uint8Array = new Uint8Array(arrayBuffer);
          resolve(uint8Array);
        };
        reader.onerror = () => {
          reject(new Error("Failed to read file"));
        };
        reader.readAsArrayBuffer(file);
      }
      dropArea.remove();
    };
    const handleDragOver = (event) => {
      event.preventDefault();
    };
    const handleDragLeave = () => {
      dropArea.style.backgroundColor = "rgba(0, 0, 0, 0.5)";
    };
    const handleDragEnter = () => {
      dropArea.style.backgroundColor = "rgba(0, 0, 0, 0.8)";
    };
    dropArea.addEventListener("drop", handleDrop);
    dropArea.addEventListener("dragover", handleDragOver);
    dropArea.addEventListener("dragleave", handleDragLeave);
    dropArea.addEventListener("dragenter", handleDragEnter);
  });
};

export {
  mountDevtoolsHooks,
  unmountDevtoolsHooks,
  KeyType
};
//# sourceMappingURL=chunk-3RZQ4PHS.mjs.map
