{
  "version": 3,
  "sources": ["../../../src/services/agent.ts", "../../../src/services/client-services-factory.tsx", "../../../src/services/local-client-services.ts", "../../../src/services/socket.ts", "../../../src/services/worker-client-services.ts", "../../../src/services/service-proxy.ts", "../../../src/services/shared-worker-connection.ts", "../../../src/services/iframe-manager.ts", "../../../src/services/shell.ts", "../../../src/services/shell-manager.ts", "../../../src/services/agent-hosting-provider.ts", "../../../src/services/fake-agent-hosting-provider.ts"],
  "sourcesContent": ["//\n// Copyright 2023 DXOS.org\n//\n\nimport { Event } from '@dxos/async';\nimport {\n  DX_RUNTIME,\n  ENV_DX_PROFILE,\n  ENV_DX_PROFILE_DEFAULT,\n  type ClientServices,\n  type ClientServicesProvider,\n  clientServiceBundle,\n  getProfilePath,\n} from '@dxos/client-protocol';\nimport { ClientServicesProviderResource } from '@dxos/client-protocol';\nimport { log } from '@dxos/log';\nimport { type ServiceBundle } from '@dxos/rpc';\nimport { trace } from '@dxos/tracing';\nimport type { WebsocketRpcClient } from '@dxos/websocket-rpc';\n\nexport const getUnixSocket = (profile: string, protocol = 'unix') =>\n  `${protocol}://` + getProfilePath(DX_RUNTIME, profile, 'agent.sock');\n\nexport type FromAgentOptions = {\n  profile?: string;\n};\n\n/**\n * Connects to locally running CLI daemon.\n */\nexport const fromAgent = ({\n  profile = process.env[ENV_DX_PROFILE] ?? ENV_DX_PROFILE_DEFAULT,\n}: FromAgentOptions = {}): ClientServicesProvider => {\n  return new AgentClientServiceProvider(profile);\n};\n\n@trace.resource({ annotation: ClientServicesProviderResource })\nexport class AgentClientServiceProvider implements ClientServicesProvider {\n  // TODO(wittjosiah): Fire an event if the socket disconnects.\n  readonly closed = new Event<Error | undefined>();\n  private _client?: WebsocketRpcClient<ClientServices, {}>;\n\n  constructor(private readonly _profile: string) {}\n\n  get descriptors(): ServiceBundle<ClientServices> {\n    return clientServiceBundle;\n  }\n\n  get services(): Partial<ClientServices> {\n    return this._client!.rpc;\n  }\n\n  async open(): Promise<void> {\n    const { WebsocketRpcClient } = await import('@dxos/websocket-rpc');\n    this._client = new WebsocketRpcClient({\n      url: getUnixSocket(this._profile, 'ws+unix'),\n      requested: clientServiceBundle,\n      exposed: {},\n      handlers: {},\n    });\n\n    this._client.error.on((error) => {\n      this.closed.emit(error);\n    });\n    await this._client.open();\n  }\n\n  async close(): Promise<void> {\n    try {\n      await this._client?.close();\n    } catch (err) {\n      log.warn('Failed to close', err);\n    }\n  }\n}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { UAParser } from 'ua-parser-js';\n\nimport { type ClientServicesProvider } from '@dxos/client-protocol';\nimport { type Config } from '@dxos/config';\n\nimport { fromHost } from './local-client-services';\nimport { fromSocket } from './socket';\nimport { type WorkerClientServicesParams, fromWorker } from './worker-client-services';\n\n/**\n * Create services from config.\n * @param config\n * @param createWorker\n * @param observabilityGroup - Optional observability group that will be sent with Signaling metadata.\n * @param signalTelemetryEnabled - Optional flag to enable telemetry metadata sent with Signaling requests.\n */\nexport const createClientServices = (\n  config: Config,\n  createWorker?: WorkerClientServicesParams['createWorker'],\n  observabilityGroup?: string,\n  signalTelemetryEnabled?: boolean,\n): Promise<ClientServicesProvider> => {\n  const remote = config.values.runtime?.client?.remoteSource;\n  if (remote) {\n    const url = new URL(remote);\n    const protocol = url.protocol.slice(0, -1);\n    switch (protocol) {\n      case 'ws':\n      case 'wss': {\n        return fromSocket(remote, config.values.runtime?.client?.remoteSourceAuthenticationToken);\n      }\n\n      case 'http':\n      case 'https': {\n        throw new Error('IFrame services deprecated.');\n      }\n    }\n  }\n\n  let useWorker = false;\n  if (typeof navigator !== 'undefined' && navigator.userAgent) {\n    const parser = new UAParser(navigator.userAgent);\n\n    // TODO(wittjosiah): Ideally this should not need to do any user agent parsing.\n    //  However, while SharedWorker is supported by iOS, it is not fully working and there's no way to inspect it.\n    useWorker = typeof SharedWorker !== 'undefined' && parser.getOS().name !== 'iOS';\n  }\n\n  return createWorker && useWorker\n    ? fromWorker(config, { createWorker, observabilityGroup, signalTelemetryEnabled })\n    : fromHost(config, {}, observabilityGroup, signalTelemetryEnabled);\n};\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { Event, synchronized } from '@dxos/async';\nimport {\n  type ClientServices,\n  type ClientServicesProvider,\n  clientServiceBundle,\n  ClientServicesProviderResource,\n} from '@dxos/client-protocol';\nimport { type ClientServicesHost, type ClientServicesHostParams } from '@dxos/client-services';\nimport { Config } from '@dxos/config';\nimport { Context } from '@dxos/context';\nimport { log } from '@dxos/log';\nimport { type SignalManager } from '@dxos/messaging';\nimport { createIceProvider, type SwarmNetworkManagerOptions, type TransportFactory } from '@dxos/network-manager';\nimport { type ServiceBundle } from '@dxos/rpc';\nimport { trace } from '@dxos/tracing';\n\n/**\n * Creates stand-alone services without rpc.\n */\n// TODO(burdon): Rename createLocalServices?\nexport const fromHost = async (\n  config = new Config(),\n  params?: ClientServicesHostParams,\n  observabilityGroup?: string,\n  signalTelemetryEnabled?: boolean,\n): Promise<ClientServicesProvider> => {\n  const networking = await setupNetworking(config, {}, () =>\n    signalTelemetryEnabled\n      ? {\n          ...services.signalMetadataTags,\n          ...(observabilityGroup ? { group: observabilityGroup } : {}),\n        }\n      : {},\n  );\n\n  const services = new LocalClientServices({ config, ...networking, ...params });\n  return services;\n};\n\n/**\n * Creates signal manager and transport factory based on config.\n * These are used to create a WebRTC network manager connected to the specified signal server.\n */\nconst setupNetworking = async (\n  config: Config,\n  options: Partial<SwarmNetworkManagerOptions> = {},\n  signalMetadata?: () => void,\n): Promise<{\n  signalManager?: SignalManager;\n  transportFactory: TransportFactory;\n}> => {\n  const { MemorySignalManager, MemorySignalManagerContext, WebsocketSignalManager } = await import('@dxos/messaging');\n  const { createRtcTransportFactory, MemoryTransportFactory } = await import('@dxos/network-manager');\n\n  const signals = config.get('runtime.services.signaling');\n  const edgeFeatures = config.get('runtime.client.edgeFeatures');\n  if (signals || edgeFeatures?.signaling) {\n    const {\n      signalManager = edgeFeatures?.signaling || !signals\n        ? undefined // EdgeSignalManager needs EdgeConnection and will be created in service-host\n        : new WebsocketSignalManager(signals, signalMetadata),\n      transportFactory = createRtcTransportFactory(\n        { iceServers: config.get('runtime.services.ice') },\n        config.get('runtime.services.iceProviders') && createIceProvider(config.get('runtime.services.iceProviders')!),\n      ),\n    } = options;\n\n    return {\n      signalManager,\n      transportFactory,\n    };\n  }\n\n  // TODO(burdon): Should not provide a memory signal manager since no shared context.\n  //  Use TestClientBuilder for shared memory tests.\n  log('P2P network is not configured.');\n  const signalManager = new MemorySignalManager(new MemorySignalManagerContext());\n  const transportFactory = MemoryTransportFactory;\n  return {\n    signalManager,\n    transportFactory,\n  };\n};\n\n/**\n * Starts a local instance of the service host.\n */\n@trace.resource({ annotation: ClientServicesProviderResource })\nexport class LocalClientServices implements ClientServicesProvider {\n  readonly closed = new Event<Error | undefined>();\n  private readonly _ctx = new Context();\n  private readonly _params: ClientServicesHostParams;\n  private _host?: ClientServicesHost;\n  signalMetadataTags: any = {\n    runtime: 'local-client-services',\n  };\n\n  @trace.info()\n  private _isOpen = false;\n\n  constructor(params: ClientServicesHostParams) {\n    this._params = params;\n    // TODO(nf): extract\n    if (typeof window === 'undefined' || typeof window.location === 'undefined') {\n      // TODO(nf): collect ClientServices metadata as param?\n      this.signalMetadataTags.origin = 'undefined';\n    } else {\n      // SocketSupply native app\n      if ((globalThis as any).__args) {\n        this.signalMetadataTags.runtime = 'native';\n        this.signalMetadataTags.origin = window.location.origin;\n        // TODO(nf): access socket app metadata?\n      } else {\n        this.signalMetadataTags.origin = window.location.origin;\n      }\n    }\n  }\n\n  get descriptors(): ServiceBundle<ClientServices> {\n    return clientServiceBundle;\n  }\n\n  get services(): Partial<ClientServices> {\n    return this._host?.services ?? {};\n  }\n\n  get host(): ClientServicesHost | undefined {\n    return this._host;\n  }\n\n  @synchronized\n  async open(): Promise<void> {\n    if (this._isOpen) {\n      return;\n    }\n\n    const { ClientServicesHost } = await import('@dxos/client-services');\n    const { setIdentityTags } = await import('@dxos/messaging');\n\n    this._host = new ClientServicesHost({\n      ...this._params,\n      callbacks: {\n        ...this._params.callbacks,\n        onReset: async () => {\n          this.closed.emit(undefined);\n          await this._params.callbacks?.onReset?.();\n        },\n      },\n    });\n    await this._host.open(this._ctx);\n    this._isOpen = true;\n    setIdentityTags({\n      identityService: this._host.services.IdentityService!,\n      devicesService: this._host.services.DevicesService!,\n      setTag: (k: string, v: string) => {\n        this.signalMetadataTags[k] = v;\n      },\n    });\n  }\n\n  @synchronized\n  async close(): Promise<void> {\n    if (!this._isOpen) {\n      return;\n    }\n\n    await this._host?.close();\n    this._isOpen = false;\n  }\n}\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { Event } from '@dxos/async';\nimport { type ClientServices, type ClientServicesProvider, clientServiceBundle } from '@dxos/client-protocol';\nimport { log } from '@dxos/log';\nimport { ApiError } from '@dxos/protocols';\nimport type { WebsocketRpcClient } from '@dxos/websocket-rpc';\n\n/**\n * Access to remote client via a socket.\n */\nexport const fromSocket = async (url: string, authenticationToken?: string): Promise<ClientServicesProvider> => {\n  const closed = new Event<Error | undefined>();\n  let dxRpcClient!: WebsocketRpcClient<ClientServices, {}>;\n\n  return {\n    get closed() {\n      return closed;\n    },\n\n    get descriptors() {\n      return clientServiceBundle;\n    },\n\n    get services() {\n      return dxRpcClient.rpc;\n    },\n\n    open: async () => {\n      const { WebsocketRpcClient } = await import('@dxos/websocket-rpc');\n      dxRpcClient = new WebsocketRpcClient({\n        url,\n        authenticationToken,\n        requested: clientServiceBundle,\n        exposed: {},\n        handlers: {},\n      });\n\n      dxRpcClient.error.on(async (error) => {\n        log.warn('websocket rpc client error', { error });\n        // Browsers do not include the error message in the event object, so we cannot discern 401 errors from other errors.\n        if (error.message.includes('401')) {\n          log.warn('websocket authentication failed');\n        }\n        closed.emit(new ApiError('websocket error'));\n      });\n      await dxRpcClient.open();\n    },\n\n    close: async () => {\n      await dxRpcClient.close();\n    },\n  };\n};\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { Event, Trigger, synchronized } from '@dxos/async';\nimport { type ClientServices, type ClientServicesProvider, clientServiceBundle } from '@dxos/client-protocol';\nimport type { Stream } from '@dxos/codec-protobuf/stream';\nimport { Config } from '@dxos/config';\nimport type { PublicKey } from '@dxos/keys';\nimport { type LogFilter, parseFilter, log, type CallMetadata } from '@dxos/log';\nimport { type LogEntry, LogLevel } from '@dxos/protocols/proto/dxos/client/services';\nimport { type ServiceBundle } from '@dxos/rpc';\nimport { createWorkerPort } from '@dxos/rpc-tunnel';\nimport { trace } from '@dxos/tracing';\n\nimport { ClientServicesProxy } from './service-proxy';\nimport { SharedWorkerConnection } from './shared-worker-connection';\nimport { RPC_TIMEOUT } from '../common';\nimport { LOCK_KEY } from '../lock-key';\n\n/**\n * Creates services provider connected via worker.\n */\nexport const fromWorker = async (config: Config = new Config(), options: Omit<WorkerClientServicesParams, 'config'>) =>\n  new WorkerClientServices({ config, ...options });\n\nexport type WorkerClientServicesParams = {\n  config: Config;\n  createWorker: () => SharedWorker;\n  logFilter?: string;\n  observabilityGroup?: string;\n  signalTelemetryEnabled?: boolean;\n};\n\n/**\n * Proxy to host client service in worker.\n */\n@trace.resource()\nexport class WorkerClientServices implements ClientServicesProvider {\n  readonly closed = new Event<Error | undefined>();\n  readonly joinedSpace = new Event<PublicKey>();\n\n  @trace.info()\n  private _isOpen = false;\n\n  private readonly _config: Config;\n  private readonly _createWorker: () => SharedWorker;\n  private readonly _logFilter: LogFilter[];\n\n  private _runtime!: SharedWorkerConnection;\n  private _services!: ClientServicesProxy;\n  private _loggingStream?: Stream<LogEntry>;\n  private readonly _observabilityGroup?: string;\n  private readonly _signalTelemetryEnabled: boolean;\n\n  constructor({\n    config,\n    createWorker,\n    logFilter = 'error,warn',\n    observabilityGroup,\n    signalTelemetryEnabled,\n  }: WorkerClientServicesParams) {\n    this._config = config;\n    this._createWorker = createWorker;\n    this._logFilter = parseFilter(logFilter);\n    this._observabilityGroup = observabilityGroup;\n    this._signalTelemetryEnabled = signalTelemetryEnabled ?? false;\n  }\n\n  get descriptors(): ServiceBundle<ClientServices> {\n    return clientServiceBundle;\n  }\n\n  get services(): Partial<ClientServices> {\n    return this._services.services;\n  }\n\n  get runtime(): SharedWorkerConnection {\n    return this._runtime;\n  }\n\n  @synchronized\n  async open(): Promise<void> {\n    if (this._isOpen) {\n      return;\n    }\n\n    log('opening...');\n    const ports = new Trigger<{ systemPort: MessagePort; appPort: MessagePort }>();\n    const worker = this._createWorker();\n    worker.port.postMessage({ dxlog: localStorage.getItem('dxlog') });\n    worker.port.onmessage = (event) => {\n      const { command, payload } = event.data;\n      if (command === 'init') {\n        ports.wake(payload);\n      }\n    };\n    const { systemPort, appPort } = await ports.wait();\n\n    this._runtime = new SharedWorkerConnection({\n      config: this._config,\n      systemPort: createWorkerPort({ port: systemPort }),\n    });\n    await this._runtime.open({\n      origin: location.origin,\n      observabilityGroup: this._observabilityGroup,\n      signalTelemetryEnabled: this._signalTelemetryEnabled,\n    });\n\n    this._services = new ClientServicesProxy(createWorkerPort({ port: appPort }));\n    await this._services.open();\n    void navigator.locks.request(LOCK_KEY, () => {\n      log('terminated');\n      if (this._isOpen) {\n        this.closed.emit(new Error('Shared worker terminated.'));\n      }\n    });\n\n    this._loggingStream = this._services.services.LoggingService.queryLogs(\n      {\n        filters: this._logFilter,\n      },\n      { timeout: RPC_TIMEOUT },\n    );\n    this._loggingStream.subscribe((entry) => {\n      switch (entry.level) {\n        case LogLevel.DEBUG:\n          log.debug(entry.message, entry.context, mapLogMeta(entry.meta));\n          break;\n        case LogLevel.VERBOSE:\n          log.verbose(entry.message, entry.context, mapLogMeta(entry.meta));\n          break;\n        case LogLevel.INFO:\n          log.info(entry.message, entry.context, mapLogMeta(entry.meta));\n          break;\n        case LogLevel.WARN:\n          log.warn(entry.message, entry.context, mapLogMeta(entry.meta));\n          break;\n        case LogLevel.ERROR:\n          log.error(entry.message, entry.context, mapLogMeta(entry.meta));\n          break;\n      }\n    });\n\n    log('opened');\n    this._isOpen = true;\n  }\n\n  @synchronized\n  async close(): Promise<void> {\n    if (!this._isOpen) {\n      return;\n    }\n\n    log('closing...');\n    await this._loggingStream?.close();\n    await this._runtime.close();\n    await this._services.close();\n\n    log('closed');\n    this._isOpen = false;\n  }\n}\n\nconst mapLogMeta = (meta: LogEntry.Meta | undefined): CallMetadata | undefined => {\n  return (\n    meta && {\n      F: meta.file,\n      L: meta.line,\n      S: {\n        ...meta.scope,\n        remoteSessionId: meta.scope?.hostSessionId,\n        hostSessionId: undefined,\n      },\n    }\n  );\n};\n", "//\n// Copyright 2021 DXOS.org\n//\n\nimport { asyncTimeout, Event } from '@dxos/async';\nimport {\n  clientServiceBundle,\n  ClientServicesProviderResource,\n  type ClientServices,\n  type ClientServicesProvider,\n} from '@dxos/client-protocol';\nimport { invariant } from '@dxos/invariant';\nimport { RemoteServiceConnectionTimeout } from '@dxos/protocols';\nimport { createProtoRpcPeer, type ProtoRpcPeer, type RpcPort } from '@dxos/rpc';\nimport { trace } from '@dxos/tracing';\n\n/**\n * Implements services that are not local to the app.\n * For example, the services can be located in Wallet Extension.\n */\n@trace.resource({ annotation: ClientServicesProviderResource })\nexport class ClientServicesProxy implements ClientServicesProvider {\n  readonly closed = new Event<Error | undefined>();\n  private _proxy?: ProtoRpcPeer<ClientServices>;\n\n  constructor(\n    private readonly _port: RpcPort,\n    // NOTE: With lower timeout the shared worker does not have enough time to start.\n    // TODO(dmaretskyi): Find better ways to detected when the worker has finished loading. It might take a while on slow connections.\n    private readonly _timeout = 30_000,\n  ) {}\n\n  get proxy() {\n    invariant(this._proxy, 'Client services not open');\n    return this._proxy;\n  }\n\n  get descriptors() {\n    return clientServiceBundle;\n  }\n\n  get services() {\n    invariant(this._proxy, 'Client services not open');\n    return this._proxy.rpc;\n  }\n\n  async open(): Promise<void> {\n    if (this._proxy) {\n      return;\n    }\n\n    this._proxy = createProtoRpcPeer({\n      requested: clientServiceBundle,\n      exposed: {},\n      handlers: {},\n      port: this._port,\n      // TODO(wittjosiah): Specifying breaks the reset flows in Composer.\n      // timeout: this._timeout,\n    });\n\n    await asyncTimeout(\n      this._proxy.open(),\n      this._timeout,\n      new RemoteServiceConnectionTimeout('Failed to establish dxrpc connection', { timeout: this._timeout }),\n    );\n  }\n\n  async close(): Promise<void> {\n    if (!this._proxy) {\n      return;\n    }\n\n    await this._proxy.close();\n    this._proxy = undefined;\n  }\n}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { Trigger } from '@dxos/async';\nimport { iframeServiceBundle, workerServiceBundle, type WorkerServiceBundle } from '@dxos/client-protocol';\nimport { type Config } from '@dxos/config';\nimport { log } from '@dxos/log';\nimport { createIceProvider } from '@dxos/network-manager';\nimport { RemoteServiceConnectionError } from '@dxos/protocols';\nimport { type BridgeService } from '@dxos/protocols/proto/dxos/mesh/bridge';\nimport { createProtoRpcPeer, type ProtoRpcPeer, type RpcPort } from '@dxos/rpc';\nimport { getAsyncProviderValue, type MaybePromise, type Provider } from '@dxos/util';\n\n// NOTE: Keep as RpcPorts to avoid dependency on @dxos/rpc-tunnel so we don't depend on browser-specific apis.\nexport type SharedWorkerConnectionOptions = {\n  config: Config | Provider<MaybePromise<Config>>;\n  systemPort: RpcPort;\n  /**\n   * @deprecated Only used with iframes.\n   */\n  shellPort?: RpcPort;\n};\n\n/**\n * Manages the client connection to the shared worker.\n */\nexport class SharedWorkerConnection {\n  private readonly _id = String(Math.floor(Math.random() * 1000000));\n  private readonly _configProvider: SharedWorkerConnectionOptions['config'];\n  private readonly _systemPort: RpcPort;\n  private _release = new Trigger();\n  private _config!: Config;\n  private _transportService!: BridgeService;\n  private _systemRpc!: ProtoRpcPeer<WorkerServiceBundle>;\n\n  constructor({ config, systemPort }: SharedWorkerConnectionOptions) {\n    this._configProvider = config;\n    this._systemPort = systemPort;\n  }\n\n  async open(params: { origin: string; observabilityGroup?: string; signalTelemetryEnabled?: boolean }): Promise<void> {\n    const { RtcTransportService } = await import('@dxos/network-manager');\n\n    this._config = await getAsyncProviderValue(this._configProvider);\n\n    this._transportService = new RtcTransportService(\n      { iceServers: [...(this._config.get('runtime.services.ice') ?? [])] },\n      this._config.get('runtime.services.iceProviders') &&\n        createIceProvider(this._config.get('runtime.services.iceProviders')!),\n    );\n\n    this._systemRpc = createProtoRpcPeer({\n      requested: workerServiceBundle,\n      exposed: iframeServiceBundle,\n      handlers: {\n        BridgeService: this._transportService,\n      },\n      port: this._systemPort,\n      // TODO(wittjosiah): Make longer and factor out to constant.\n      // TODO(wittjosiah): If this is too long then it breaks the reset flows in Composer.\n      timeout: 200,\n    });\n\n    let lockKey: string | undefined;\n    if (typeof navigator !== 'undefined') {\n      lockKey = this._lockKey(params.origin);\n      this._release = new Trigger();\n      const ready = new Trigger();\n      void navigator.locks.request(lockKey, async () => {\n        ready.wake();\n        await this._release.wait();\n      });\n      await ready.wait();\n    }\n\n    try {\n      await this._systemRpc.open();\n      await this._systemRpc.rpc.WorkerService.start({ lockKey, ...params });\n    } catch (err) {\n      log.catch(err);\n      throw new RemoteServiceConnectionError('Failed to connect to worker');\n    }\n  }\n\n  async close(): Promise<void> {\n    this._release.wake();\n    try {\n      await this._systemRpc.rpc.WorkerService.stop();\n    } catch {\n      // If this fails, the worker is probably already gone.\n    }\n    await this._systemRpc.close();\n  }\n\n  private _lockKey(origin: string): string {\n    return `${origin}-${this._id}`;\n  }\n}\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { PublicKey } from '@dxos/keys';\nimport { createIFrame } from '@dxos/rpc-tunnel';\nimport { type MaybePromise } from '@dxos/util';\n\nexport class IFrameManager {\n  private _iframe?: HTMLIFrameElement;\n  private readonly _source: URL;\n  private readonly _onOpen?: () => MaybePromise<void>;\n  private readonly _onMessage?: (event: MessageEvent) => MaybePromise<void>;\n\n  constructor({\n    source,\n    onOpen,\n    onMessage,\n  }: {\n    source: URL;\n    onOpen?: () => MaybePromise<void>;\n    onMessage?: (event: MessageEvent) => MaybePromise<void>;\n  }) {\n    this._source = source;\n    this._onOpen = onOpen;\n    this._onMessage = onMessage;\n    this._messageHandler = this._messageHandler.bind(this);\n  }\n\n  get source() {\n    return this._source;\n  }\n\n  get iframe() {\n    return this._iframe;\n  }\n\n  async open(): Promise<void> {\n    if (this._iframe) {\n      return;\n    }\n\n    window.addEventListener('message', this._messageHandler);\n    const iframeId = `__DXOS_CLIENT_${PublicKey.random().toHex()}__`;\n    this._iframe = createIFrame(this._source.toString(), iframeId, { allow: 'clipboard-read; clipboard-write' });\n\n    await this._onOpen?.();\n  }\n\n  async close(): Promise<void> {\n    window.removeEventListener('message', this._messageHandler);\n    this._iframe?.remove();\n    this._iframe = undefined;\n  }\n\n  private async _messageHandler(event: MessageEvent): Promise<void> {\n    void this._onMessage?.(event);\n  }\n}\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport type { MulticastObservable } from '@dxos/async';\nimport { type PublicKey } from '@dxos/keys';\nimport { type LayoutRequest, ShellDisplay, ShellLayout } from '@dxos/protocols/proto/dxos/iframe';\nimport { ComplexSet } from '@dxos/util';\n\nimport type { ShellManager } from './shell-manager';\nimport type { Space, SpaceMember } from '../echo';\nimport type { Device, Identity } from '../halo';\n\ntype ShellResult = {\n  cancelled: boolean;\n  error?: Error;\n};\n\ntype InitializeIdentityResult = ShellResult & {\n  identity?: Identity;\n};\n\ntype ShareIdentityResult = ShellResult & {\n  device?: Device;\n};\n\ntype ShareSpaceResult = ShellResult & {\n  members?: SpaceMember[];\n};\n\ntype JoinSpaceResult = ShellResult & {\n  space?: Space;\n  target?: string;\n};\n\ntype ShellParams = {\n  shellManager: ShellManager;\n  identity: MulticastObservable<Identity | null>;\n  devices: MulticastObservable<Device[]>;\n  spaces: MulticastObservable<Space[]>;\n};\n\n/**\n * Interface for controlling the shell.\n */\nexport class Shell {\n  private readonly _shellManager: ShellManager;\n  private readonly _identity: MulticastObservable<Identity | null>;\n  private readonly _devices: MulticastObservable<Device[]>;\n  private readonly _spaces: MulticastObservable<Space[]>;\n\n  constructor({ shellManager, identity, devices, spaces }: ShellParams) {\n    this._shellManager = shellManager;\n    this._identity = identity;\n    this._devices = devices;\n    this._spaces = spaces;\n  }\n\n  async setInvitationUrl(request: {\n    invitationUrl: string;\n    deviceInvitationParam: string;\n    spaceInvitationParam: string;\n  }): Promise<void> {\n    await this._shellManager.setInvitationUrl(request);\n  }\n\n  /**\n   * Open the shell with the given layout.\n   */\n  async open(layout: ShellLayout = ShellLayout.IDENTITY, options: Omit<LayoutRequest, 'layout'> = {}): Promise<void> {\n    await this._shellManager.setLayout({ layout, ...options });\n  }\n\n  get display() {\n    return this._shellManager.display;\n  }\n\n  /**\n   * Listen for changes to the shell display.\n   */\n  onDisplayChange(cb: (display: ShellDisplay) => void) {\n    return this._shellManager.contextUpdate.on((data) => {\n      if ('display' in data) {\n        cb(data.display!);\n      }\n    });\n  }\n\n  /**\n   * Listen for reset event.\n   */\n  onReset(cb: (target?: string) => void) {\n    return this._shellManager.contextUpdate.on((data) => {\n      if ('reset' in data && data.reset) {\n        cb(data.target);\n      }\n    });\n  }\n\n  /**\n   * Create a new identity.\n   * Opens the shell and starts the identity creation flow.\n   *\n   * @returns Shell result with the new identity.\n   */\n  async createIdentity(): Promise<InitializeIdentityResult> {\n    await this._shellManager.setLayout({ layout: ShellLayout.INITIALIZE_IDENTITY });\n    return new Promise((resolve) => {\n      this._shellManager.contextUpdate.on((context) => {\n        if (context.display === ShellDisplay.NONE) {\n          resolve({ cancelled: true });\n        }\n      });\n\n      this._identity.subscribe((identity) => {\n        if (identity) {\n          resolve({ identity, cancelled: false });\n        }\n      });\n    });\n  }\n\n  /**\n   * Join an existing identity.\n   * Opens the shell and starts the device invitation flow based on the given options.\n   *\n   * @param options.invitationCode If provided, join an existing identity via device invitation.\n   *\n   * @returns Shell result with the new identity.\n   */\n  async joinIdentity({ invitationCode }: { invitationCode?: string } = {}): Promise<InitializeIdentityResult> {\n    await this._shellManager.setLayout({ layout: ShellLayout.INITIALIZE_IDENTITY_FROM_INVITATION, invitationCode });\n    return new Promise((resolve) => {\n      this._shellManager.contextUpdate.on((context) => {\n        if (context.display === ShellDisplay.NONE) {\n          resolve({ cancelled: true });\n        }\n      });\n\n      this._identity.subscribe((identity) => {\n        if (identity) {\n          resolve({ identity, cancelled: false });\n        }\n      });\n    });\n  }\n\n  /**\n   * Invite a new device to join the current identity.\n   * Opens the shell and presents a device invitation.\n   *\n   * @returns Shell result with the new device.\n   */\n  async shareIdentity(): Promise<ShareIdentityResult> {\n    if (!this._identity.get()) {\n      return { error: new Error('Identity does not exist'), cancelled: false };\n    }\n\n    const initialDevices = new ComplexSet<PublicKey>(\n      (key) => key.toHex(),\n      this._devices.get().map((device) => device.deviceKey),\n    );\n    await this._shellManager.setLayout({ layout: ShellLayout.SHARE_IDENTITY });\n    return new Promise((resolve) => {\n      this._shellManager.contextUpdate.on((context) => {\n        if (context.display === ShellDisplay.NONE) {\n          const device = this._devices.get().find((device) => !initialDevices.has(device.deviceKey));\n          resolve({ device, cancelled: !device });\n        }\n      });\n    });\n  }\n\n  /**\n   * Initialize a new device with an existing identity using a recovery code.\n   *\n   * @returns Shell result with the identity.\n   */\n  async recoverIdentity(): Promise<InitializeIdentityResult> {\n    await this._shellManager.setLayout({ layout: ShellLayout.INITIALIZE_IDENTITY_FROM_RECOVERY });\n    return new Promise((resolve) => {\n      this._shellManager.contextUpdate.on((context) => {\n        if (context.display === ShellDisplay.NONE) {\n          resolve({ cancelled: true });\n        }\n      });\n\n      this._identity.subscribe((identity) => {\n        if (identity) {\n          resolve({ identity, cancelled: false });\n        }\n      });\n    });\n  }\n\n  /**\n   * Invite new members to join the current space.\n   * Opens the shell to the specified space, showing current members and allowing new members to be invited.\n   *\n   * @param options.spaceKey The space to share. (Deprecated, use spaceId instead.)\n   * @param options.spaceId The space to share.\n   * @param options.target The target location to share with new members.\n   *\n   * @returns Shell result with any new members that join while the shell is open.\n   */\n  async shareSpace({\n    spaceKey,\n    spaceId,\n    target,\n  }: {\n    spaceKey?: PublicKey;\n    spaceId?: string;\n    target?: string;\n  }): Promise<ShareSpaceResult> {\n    if (!this._identity.get()) {\n      return { error: new Error('Identity does not exist'), cancelled: false };\n    }\n\n    const space = this._spaces.get().find((space) => spaceKey?.equals(space.key) || space.id === spaceId);\n    if (!space) {\n      return { error: new Error('Space does not exist'), cancelled: false };\n    }\n\n    const initialMembers = new ComplexSet<PublicKey>(\n      (key) => key.toHex(),\n      space.members.get().map((member) => member.identity.identityKey),\n    );\n    await this._shellManager.setLayout({ layout: ShellLayout.SPACE, spaceKey, spaceId, target });\n    return new Promise((resolve) => {\n      this._shellManager.contextUpdate.on((context) => {\n        if (context.display === ShellDisplay.NONE) {\n          const members = space.members.get().filter((member) => !initialMembers.has(member.identity.identityKey));\n          resolve({ members, cancelled: members.length === 0 });\n        }\n      });\n    });\n  }\n\n  /**\n   * Join an existing space.\n   * Opens the shell and starts the space join flow based on the given options.\n   *\n   * @param options.invitationCode If provided, redeem the invitation code to join the space.\n   *\n   * @returns The joined space.\n   * @throws {Error} If no identity exists.\n   */\n  async joinSpace({ invitationCode }: { invitationCode?: string } = {}): Promise<JoinSpaceResult> {\n    if (!this._identity.get()) {\n      return { error: new Error('Identity does not exist'), cancelled: false };\n    }\n\n    await this._shellManager.setLayout({ layout: ShellLayout.JOIN_SPACE, invitationCode });\n    return new Promise((resolve) => {\n      this._shellManager.contextUpdate.on((context) => {\n        const space = context.spaceKey && this._spaces.get().find((space) => context.spaceKey?.equals(space.key));\n        if (space) {\n          resolve({ space, target: context.target, cancelled: false });\n        }\n\n        if (context.display === ShellDisplay.NONE) {\n          resolve({ cancelled: true });\n        }\n      });\n    });\n  }\n}\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { Event } from '@dxos/async';\nimport {\n  DEFAULT_SHELL_CHANNEL,\n  type ShellServiceBundle,\n  appServiceBundle,\n  shellServiceBundle,\n} from '@dxos/client-protocol';\nimport { invariant } from '@dxos/invariant';\nimport { log } from '@dxos/log';\nimport {\n  type AppContextRequest,\n  type LayoutRequest,\n  ShellDisplay,\n  type InvitationUrlRequest,\n} from '@dxos/protocols/proto/dxos/iframe';\nimport { createProtoRpcPeer, type ProtoRpcPeer } from '@dxos/rpc';\nimport { createIFramePort } from '@dxos/rpc-tunnel';\n\nimport { type IFrameManager } from './iframe-manager';\nimport { RPC_TIMEOUT } from '../common';\n\nconst shellStyles = Object.entries({\n  display: 'none',\n  position: 'fixed',\n  top: 0,\n  left: 0,\n  width: '100vw',\n  height: '100vh',\n  border: 0,\n  'z-index': 60,\n}).reduce((acc, [key, value]) => `${acc}${key}: ${value};`, '');\n\n/**\n * Provide access to the shell via RPC connection.\n */\nexport class ShellManager {\n  readonly contextUpdate = new Event<AppContextRequest>();\n\n  private _shellRpc?: ProtoRpcPeer<ShellServiceBundle>;\n  private _display = ShellDisplay.NONE;\n\n  // prettier-ignore\n  constructor(\n    private readonly _iframeManager: IFrameManager,\n    private readonly _channel = DEFAULT_SHELL_CHANNEL,\n  ) {}\n\n  get display() {\n    return this._display;\n  }\n\n  async setLayout(request: LayoutRequest): Promise<void> {\n    invariant(this._shellRpc, 'ShellManager not open');\n    log('set layout', request);\n    this._display = ShellDisplay.FULLSCREEN;\n    this.contextUpdate.emit({ display: this._display });\n    await this._shellRpc.rpc.ShellService.setLayout(request, { timeout: RPC_TIMEOUT });\n    // Focus the first focusable element when the iframe has something to display so that keybindings global to the iframe (e.g. Escape) work as expected.\n    (\n      this._iframeManager.iframe?.contentDocument?.querySelector(\n        'a[href], button:not([disabled]), input:not([disabled]), textarea:not([disabled]), select:not([disabled]), [tabindex]:not([tabindex=\"-1\"])',\n      ) as HTMLElement | null | undefined\n    )?.focus();\n  }\n\n  async setInvitationUrl(request: InvitationUrlRequest): Promise<void> {\n    log('set invitation url', request);\n    await this._shellRpc?.rpc.ShellService.setInvitationUrl(request, { timeout: RPC_TIMEOUT });\n  }\n\n  async open(): Promise<void> {\n    if (this._shellRpc) {\n      return;\n    }\n\n    await this._iframeManager.open();\n\n    const iframe = this._iframeManager.iframe;\n    iframe!.setAttribute('style', shellStyles);\n    iframe!.setAttribute('name', 'dxos-shell');\n    iframe!.setAttribute('data-testid', 'dxos-shell');\n    this.contextUpdate.on(({ display }) => {\n      iframe!.style.display = display === ShellDisplay.NONE ? 'none' : '';\n      if (display === ShellDisplay.NONE) {\n        iframe!.blur();\n      }\n    });\n\n    // TODO(wittjosiah): Remove. Workaround for socket runtime bug.\n    //   https://github.com/socketsupply/socket/issues/893\n    const origin =\n      this._iframeManager.source.origin === 'null'\n        ? this._iframeManager.source.toString().split('/').slice(0, 3).join('/')\n        : this._iframeManager.source.origin;\n\n    const port = createIFramePort({\n      origin,\n      channel: this._channel,\n      iframe: this._iframeManager.iframe,\n    });\n\n    this._shellRpc = createProtoRpcPeer({\n      requested: shellServiceBundle,\n      exposed: appServiceBundle,\n      handlers: {\n        AppService: {\n          setContext: async (request) => {\n            log('set context', request);\n            if (request.display) {\n              this._display = request.display;\n            }\n            this.contextUpdate.emit(request);\n          },\n        },\n      },\n      port,\n    });\n\n    await this._shellRpc.open();\n  }\n\n  async close(): Promise<void> {\n    if (!this._shellRpc) {\n      return;\n    }\n\n    await this._shellRpc?.close();\n    this._shellRpc = undefined;\n  }\n}\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { jwtDecode } from 'jwt-decode';\n\nimport { synchronized } from '@dxos/async';\nimport { type Halo } from '@dxos/client-protocol';\nimport { type Config } from '@dxos/config';\nimport { invariant } from '@dxos/invariant';\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { schema } from '@dxos/protocols/proto';\nimport { type Credential } from '@dxos/protocols/proto/dxos/halo/credentials';\nimport { type AgentManager, InitAuthSequenceResponse } from '@dxos/protocols/proto/dxos/service/agentmanager';\nimport { type WebsocketRpcClient } from '@dxos/websocket-rpc';\n\nexport type AgentHostingProvider = {\n  name: string;\n  baseUrl: string;\n  username: string;\n  password?: string;\n};\n\n/**\n * Cannot communicate with, or decode response from hosting provider.\n */\nexport class ProviderApiError extends Error {}\n\n// TODO: Load from config or dynamically discover\nconst defaultConfig: AgentHostingProvider = {\n  name: 'default',\n  baseUrl: 'http://localhost:8082/v1alpha1/',\n  username: 'dxos',\n};\n\nexport interface AgentHostingProviderClient {\n  /**\n   * Initialize the client, potentially using the authToken to check authorization.\n   */\n\n  // TODO: will need to be async?\n  init(authToken?: any): boolean;\n  createAgent(invitationCode: string, identityKey: string): Promise<string>;\n  getAgent(agentID: string): Promise<string | null>;\n  destroyAgent(agentID: string): Promise<boolean>;\n}\n\n// Interface to REST API to manage agent deployments\n// TODO(nf): for now API just simply returns created k8s CRD objects, define backend-agnostic API\nconst COMPOSER_BETA_COOKIE_NAME = 'COMPOSER-BETA';\nconst HUB_SERVICE_ACCESS_CAPABILITY = 'agent:beta';\nconst HUB_SERVICE_ACCESS_MAGIC = 'HubServiceAccessCredential';\n\nexport type ComposerBetaJwt = {\n  access_token: string;\n  auth_app?: number;\n  auth_agent?: number;\n};\n\nexport class AgentManagerClient implements AgentHostingProviderClient {\n  private readonly _config: AgentHostingProvider;\n  private readonly DXRPC_PATH = 'dxrpc';\n  private readonly _wsDxrpcUrl: string;\n  private _rpc: WebsocketRpcClient<{ AgentManager: AgentManager }, {}> | undefined;\n  private _rpcState: 'connected' | 'disconnected' = 'disconnected';\n  private _authToken: string | null = null;\n\n  // TODO(nf): just accept Client instead?\n  constructor(\n    private readonly _clientConfig: Config,\n    private readonly _halo: Halo,\n  ) {\n    const runtimeAgentHostingConfig = this._clientConfig.get('runtime.services.agentHosting');\n    invariant(runtimeAgentHostingConfig, 'agentHosting config not found');\n    invariant(runtimeAgentHostingConfig.server, 'agentHosting server not found');\n    this._config = {\n      ...defaultConfig,\n      baseUrl: runtimeAgentHostingConfig.server,\n      password: this._clientConfig.get('runtime.app.env.DX_AGENTHOSTING_PASSWORD'),\n    };\n\n    // Ensure trailing slash to ensure proper path joining with URL() constructor.\n    if (!this._config.baseUrl.endsWith('/')) {\n      this._config.baseUrl += '/';\n    }\n    this._wsDxrpcUrl = new URL(this.DXRPC_PATH, this._config.baseUrl.replace('http', 'ws')).href;\n  }\n\n  init(authToken?: any): boolean {\n    if (!this._checkAuthorization(authToken)) {\n      return false;\n    }\n\n    // TODO: AgentHostingContext is currently called 4 times on startup.\n    // when this is reduced to one, preemptively open the Websocket connection to decrease the latency of the first RPC call.\n    // void this._openRpc();\n    return true;\n  }\n\n  /**\n   * Check auth token/credential from CF worker whether identity is allowed to create agent.\n   *\n   * Note: This will prevent the client from making unnecessary requests to the AgentHostingProvider API.\n   * The AgentHostingProvider will also validate the auth token/credential on its own.\n   */\n\n  _checkAuthorization(authToken?: any): boolean {\n    const validCookie = this._checkAuthCookie(authToken);\n    if (validCookie) {\n      log('beta JWT found');\n      return true;\n    }\n\n    const credential = this._getAuthorizationCredential();\n    if (credential) {\n      log('beta credential found', { credential });\n      return true;\n    }\n\n    log('neither JWT nor beta credential found');\n    return false;\n  }\n\n  _checkAuthCookie(authToken: any): boolean {\n    const cookies = Object.fromEntries(\n      document.cookie.split('; ').map((v) => v.split(/=(.*)/s).map(decodeURIComponent)),\n    );\n\n    if (cookies[COMPOSER_BETA_COOKIE_NAME] == null) {\n      return false;\n    }\n\n    const composerBetaJwt = this._decodeComposerBetaJwt();\n\n    // The AgentManager server will verify the JWT. This check is just to prevent unnecessary requests.\n    if (composerBetaJwt && composerBetaJwt.auth_agent) {\n      return true;\n    }\n    return false;\n  }\n\n  // TODO(nf): use asymmetric key to verify token?\n  _decodeComposerBetaJwt(): ComposerBetaJwt {\n    const decoded: ComposerBetaJwt = jwtDecode(this._getComposerBetaCookie());\n    return decoded;\n  }\n\n  _getComposerBetaCookie() {\n    const cookies = Object.fromEntries(\n      document.cookie.split('; ').map((v) => v.split(/=(.*)/s).map(decodeURIComponent)),\n    );\n\n    if (cookies[COMPOSER_BETA_COOKIE_NAME] == null) {\n      return null;\n    }\n    return cookies[COMPOSER_BETA_COOKIE_NAME];\n  }\n\n  _getAuthorizationCredential() {\n    // TODO: ensure we use the newest credential?\n    return this._halo\n      .queryCredentials()\n      .toSorted((a, b) => b.issuanceDate.getTime() - a.issuanceDate.getTime())\n      .find(matchServiceCredential([HUB_SERVICE_ACCESS_CAPABILITY]));\n  }\n\n  public requestInitWithCredentials(req: RequestInit): RequestInit {\n    return {\n      ...req,\n      headers: {\n        ...req.headers,\n        Authorization: 'Basic ' + Buffer.from(`${this._config.username}:${this._config.password}`).toString('base64'),\n      },\n    };\n  }\n\n  public requestInitWithAuthToken(req: RequestInit): RequestInit {\n    return {\n      ...req,\n      headers: {\n        ...req.headers,\n        Authorization: 'Bearer ' + this._authToken,\n      },\n    };\n  }\n\n  @synchronized\n  async _ensureAuthenticated(): Promise<void> {\n    if (this._validAuthToken()) {\n      return;\n    }\n    const { deviceKey } = this._halo.device!;\n\n    invariant(deviceKey, 'deviceKey not found');\n    const authDeviceCreds = await this._queryCredentials('dxos.halo.credentials.AuthorizedDevice', (cred) =>\n      PublicKey.equals(cred.subject.id, deviceKey),\n    );\n\n    invariant(authDeviceCreds.length === 1, 'Improper number of authorized devices');\n\n    const agentBetaCredential = this._getAuthorizationCredential();\n    await this._agentManagerAuth(authDeviceCreds[0], agentBetaCredential);\n  }\n\n  async _openRpc(): Promise<void> {\n    if (this._rpcState === 'connected') {\n      return;\n    }\n    const { WebsocketRpcClient } = await import('@dxos/websocket-rpc');\n    this._rpc = new WebsocketRpcClient({\n      url: this._wsDxrpcUrl,\n      requested: { AgentManager: schema.getService('dxos.service.agentmanager.AgentManager') },\n      noHandshake: true,\n    });\n\n    this._rpc.connected.on(() => {\n      this._rpcState = 'connected';\n    });\n\n    this._rpc.disconnected.on(() => {\n      this._rpcState = 'disconnected';\n    });\n\n    this._rpc.error.on((err) => {\n      log.info('rpc error', { err });\n      this._rpcState = 'disconnected';\n    });\n    try {\n      await this._rpc.open();\n    } catch (err) {\n      log.warn('failed to open rpc', { err });\n      throw new Error('Failed to open rpc');\n    }\n  }\n\n  // Authenticate to the agentmanager service using dxrpc and obtain a JWT token for subsequent HTTP requests.\n  async _agentManagerAuth(authDeviceCreds: Credential, agentAuthzCredential?: Credential): Promise<void> {\n    await this._openRpc();\n    invariant(this._rpc, 'RPC not initialized');\n    const { result, nonce, agentmanagerKey, initAuthResponseReason } =\n      await this._rpc.rpc.AgentManager.initAuthSequence({\n        authToken: agentAuthzCredential ? HUB_SERVICE_ACCESS_MAGIC : this._getComposerBetaCookie(),\n      });\n\n    if (result !== InitAuthSequenceResponse.InitAuthSequenceResult.SUCCESS || !nonce || !agentmanagerKey) {\n      log('auth init failed', { result, nonce, agentmanagerKey, initAuthResponseReason });\n      throw new Error('Failed to initialize auth sequence');\n    }\n    const agentmanagerAccessCreds = await this._queryCredentials('dxos.halo.credentials.ServiceAccess', (cred) =>\n      PublicKey.equals(cred.issuer, agentmanagerKey),\n    );\n    if (!agentmanagerAccessCreds.length) {\n      log.info('no access credentials - requesting...');\n    } else {\n      log.info('access credentials found - requesting session token..');\n    }\n\n    const credsToPresent = [authDeviceCreds.id, agentmanagerAccessCreds[0]?.id, agentAuthzCredential?.id].filter(\n      Boolean,\n    );\n    const presentation = await this._halo.presentCredentials({\n      ids: credsToPresent as PublicKey[],\n      nonce,\n    });\n\n    const { token, credential } = await this._rpc.rpc.AgentManager.authenticate({ presentation });\n    if (token) {\n      this._authToken = token;\n      if (!this._validAuthToken()) {\n        log('received invalid authToken', { token });\n        throw new ProviderApiError('Received invalid authToken');\n      }\n    } else {\n      invariant(credential, 'No credential or token received');\n      log('received credential, writing to HALO', { credential });\n      await this._halo.writeCredentials([credential]);\n      // re-do authentication now that we have a agentmanager serviceAccess credential.\n      await this._agentManagerAuth(authDeviceCreds, agentAuthzCredential);\n    }\n  }\n\n  _validAuthToken() {\n    if (!this._authToken) {\n      return null;\n    }\n    const decoded = jwtDecode(this._authToken);\n    if (!decoded.exp) {\n      log.warn('authToken missing expiry', { decoded });\n      return null;\n    }\n    if (decoded.exp * 1000 < Date.now()) {\n      log('authToken expired', { decoded });\n      return null;\n    }\n    return decoded;\n  }\n\n  public async _queryCredentials(type?: string, predicate?: (value: Credential) => boolean): Promise<Credential[]> {\n    // assumes all credentials are already loaded. should client.spaces.waitUntilReady()?\n    const haloCredentials = this._halo.credentials.get();\n\n    return haloCredentials.filter((cred) => {\n      if (type && cred.subject.assertion['@type'] !== type) {\n        return false;\n      }\n      if (predicate && !predicate(cred)) {\n        return false;\n      }\n      return true;\n    });\n  }\n\n  public async createAgent(invitationCode: string, identityKey: string) {\n    await this._ensureAuthenticated();\n    const res = await fetch(\n      new URL('agent', this._config.baseUrl),\n      this.requestInitWithAuthToken({\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          invitation: invitationCode,\n          identityKey,\n        }),\n      }),\n    );\n\n    try {\n      const agent = await res.json();\n      return agent.metadata.uid;\n    } catch (err) {\n      if (err instanceof TypeError) {\n        log.warn('failed to parse response from agent create', { res });\n        throw new ProviderApiError('failed to parse response from hosting provider');\n      }\n      log.warn('bad response from agent create', { res });\n      throw new ProviderApiError('bad response from hosting provider');\n    }\n  }\n\n  public async getAgent(agentID: string) {\n    await this._ensureAuthenticated();\n    const res = await fetch(\n      new URL('agent/' + agentID, this._config.baseUrl),\n      this.requestInitWithAuthToken({\n        method: 'GET',\n      }),\n    );\n    // TODO(nf): is Sentry logging this and causing the log message?\n    switch (res.status) {\n      // TODO(nf): other status codes?\n      case 200:\n        break;\n      case 404:\n        return null;\n      case 401:\n        throw new ProviderApiError('unauthorized');\n      case 403:\n        throw new ProviderApiError('forbidden');\n      case 500:\n        log.warn('request to agent get failed', { res });\n        throw new ProviderApiError('internal server error from hosting provider');\n      default:\n        log.warn('request to agent get failed', { res });\n        throw new ProviderApiError('unknown API error');\n    }\n\n    log.info('getAgent', { res });\n\n    try {\n      const agent = await res.json();\n      return agent.metadata.uid;\n    } catch (err) {\n      if (err instanceof TypeError) {\n        log.warn('failed to parse response from agent get', { err });\n        throw new ProviderApiError('failed to parse response from hosting provider');\n      }\n      log.warn('bad response from agent get', { res });\n      throw new ProviderApiError('bad response from hosting provider');\n    }\n  }\n\n  public async destroyAgent(agentID: string): Promise<boolean> {\n    await this._ensureAuthenticated();\n    const res = await fetch(\n      new URL('agent/' + agentID, this._config.baseUrl),\n      this.requestInitWithAuthToken({\n        method: 'DELETE',\n      }),\n    );\n\n    switch (res.status) {\n      // TODO(nf): other status codes?\n      case 204:\n        return true;\n      case 404:\n        log.warn('requested destroy on non-existent agent');\n        return false;\n      case 403:\n        throw new ProviderApiError('forbidden');\n      case 500:\n        log.warn('request to agent destroy failed', { res });\n        throw new ProviderApiError('internal server error from hosting provider');\n      default:\n        log.warn('request to agent destroy failed', { res });\n        throw new ProviderApiError('unknown API error');\n    }\n  }\n}\n\n// TODO: match serverName and serverKey\n\nexport const matchServiceCredential =\n  (capabilities: string[] = []) =>\n  (credential: Credential) => {\n    if (credential.subject.assertion['@type'] !== 'dxos.halo.credentials.ServiceAccess') {\n      return false;\n    }\n\n    const { capabilities: credentialCapabilities } = credential.subject.assertion;\n    return capabilities.every((capability) => credentialCapabilities.includes(capability));\n  };\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { sleep } from '@dxos/async';\n\nimport { type AgentHostingProviderClient } from './agent-hosting-provider';\n\nexport class FakeAgentHostingProvider implements AgentHostingProviderClient {\n  private _agents: Map<string, string> = new Map();\n  constructor(private _throw: boolean = false) {}\n\n  public async createAgent(invitationCode: string, identityKey: string): Promise<string> {\n    await sleep(3e3);\n    const agentID = crypto.randomUUID();\n    this._agents.set(identityKey, agentID);\n    return agentID;\n  }\n\n  public async getAgent(agentID: string): Promise<string | null> {\n    await sleep(3e3);\n    return this._agents.get(agentID) ?? null;\n  }\n\n  public async destroyAgent(agentID: string): Promise<boolean> {\n    await sleep(3e3);\n    return this._agents.delete(agentID);\n  }\n\n  public init(authToken: any): boolean {\n    return true;\n  }\n}\n"],
  "mappings": "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",
  "names": ["Event", "DX_RUNTIME", "ENV_DX_PROFILE", "ENV_DX_PROFILE_DEFAULT", "clientServiceBundle", "getProfilePath", "ClientServicesProviderResource", "log", "trace", "getUnixSocket", "profile", "protocol", "fromAgent", "process", "env", "AgentClientServiceProvider", "_profile", "closed", "descriptors", "services", "_client", "rpc", "open", "WebsocketRpcClient", "url", "requested", "exposed", "handlers", "error", "on", "emit", "close", "err", "warn", "resource", "annotation", "UAParser", "Event", "synchronized", "clientServiceBundle", "ClientServicesProviderResource", "Config", "Context", "log", "createIceProvider", "trace", "fromHost", "config", "params", "observabilityGroup", "signalTelemetryEnabled", "networking", "setupNetworking", "services", "signalMetadataTags", "group", "LocalClientServices", "options", "signalMetadata", "MemorySignalManager", "MemorySignalManagerContext", "WebsocketSignalManager", "createRtcTransportFactory", "MemoryTransportFactory", "signals", "get", "edgeFeatures", "signaling", "signalManager", "undefined", "transportFactory", "iceServers", "closed", "_ctx", "runtime", "_isOpen", "_params", "window", "location", "origin", "globalThis", "__args", "descriptors", "_host", "host", "open", "ClientServicesHost", "setIdentityTags", "callbacks", "onReset", "emit", "identityService", "IdentityService", "devicesService", "DevicesService", "setTag", "k", "v", "close", "info", "resource", "annotation", "Event", "clientServiceBundle", "log", "ApiError", "fromSocket", "url", "authenticationToken", "closed", "dxRpcClient", "descriptors", "services", "rpc", "open", "WebsocketRpcClient", "requested", "exposed", "handlers", "error", "on", "warn", "message", "includes", "emit", "close", "Event", "Trigger", "synchronized", "clientServiceBundle", "Config", "parseFilter", "log", "LogLevel", "createWorkerPort", "trace", "asyncTimeout", "Event", "clientServiceBundle", "ClientServicesProviderResource", "invariant", "RemoteServiceConnectionTimeout", "createProtoRpcPeer", "trace", "ClientServicesProxy", "_port", "_timeout", "closed", "proxy", "_proxy", "descriptors", "services", "rpc", "open", "requested", "exposed", "handlers", "port", "timeout", "close", "undefined", "resource", "annotation", "Trigger", "iframeServiceBundle", "workerServiceBundle", "log", "createIceProvider", "RemoteServiceConnectionError", "createProtoRpcPeer", "getAsyncProviderValue", "SharedWorkerConnection", "config", "systemPort", "_id", "String", "Math", "floor", "random", "_release", "_configProvider", "_systemPort", "open", "params", "RtcTransportService", "_config", "_transportService", "iceServers", "get", "_systemRpc", "requested", "exposed", "handlers", "BridgeService", "port", "timeout", "lockKey", "navigator", "_lockKey", "origin", "ready", "locks", "request", "wake", "wait", "rpc", "WorkerService", "start", "err", "catch", "close", "stop", "fromWorker", "config", "Config", "options", "WorkerClientServices", "createWorker", "logFilter", "observabilityGroup", "signalTelemetryEnabled", "closed", "Event", "joinedSpace", "_isOpen", "_config", "_createWorker", "_logFilter", "parseFilter", "_observabilityGroup", "_signalTelemetryEnabled", "descriptors", "clientServiceBundle", "services", "_services", "runtime", "_runtime", "open", "log", "ports", "Trigger", "worker", "port", "postMessage", "dxlog", "localStorage", "getItem", "onmessage", "event", "command", "payload", "data", "wake", "systemPort", "appPort", "wait", "SharedWorkerConnection", "createWorkerPort", "origin", "location", "ClientServicesProxy", "navigator", "locks", "request", "LOCK_KEY", "emit", "Error", "_loggingStream", "LoggingService", "queryLogs", "filters", "timeout", "RPC_TIMEOUT", "subscribe", "entry", "level", "LogLevel", "DEBUG", "debug", "message", "context", "mapLogMeta", "meta", "VERBOSE", "verbose", "INFO", "info", "WARN", "warn", "ERROR", "error", "close", "resource", "F", "file", "L", "line", "S", "scope", "remoteSessionId", "hostSessionId", "undefined", "createClientServices", "config", "createWorker", "observabilityGroup", "signalTelemetryEnabled", "remote", "values", "runtime", "client", "remoteSource", "url", "URL", "protocol", "slice", "fromSocket", "remoteSourceAuthenticationToken", "Error", "useWorker", "navigator", "userAgent", "parser", "UAParser", "SharedWorker", "getOS", "name", "fromWorker", "fromHost", "PublicKey", "createIFrame", "IFrameManager", "source", "onOpen", "onMessage", "_source", "_onOpen", "_onMessage", "_messageHandler", "bind", "iframe", "_iframe", "open", "window", "addEventListener", "iframeId", "PublicKey", "random", "toHex", "createIFrame", "toString", "allow", "close", "removeEventListener", "remove", "undefined", "event", "ShellDisplay", "ShellLayout", "ComplexSet", "Shell", "shellManager", "identity", "devices", "spaces", "_shellManager", "_identity", "_devices", "_spaces", "setInvitationUrl", "request", "open", "layout", "ShellLayout", "IDENTITY", "options", "setLayout", "display", "onDisplayChange", "cb", "contextUpdate", "on", "data", "onReset", "reset", "target", "createIdentity", "INITIALIZE_IDENTITY", "Promise", "resolve", "context", "ShellDisplay", "NONE", "cancelled", "subscribe", "joinIdentity", "invitationCode", "INITIALIZE_IDENTITY_FROM_INVITATION", "shareIdentity", "get", "error", "Error", "initialDevices", "ComplexSet", "key", "toHex", "map", "device", "deviceKey", "SHARE_IDENTITY", "find", "has", "recoverIdentity", "INITIALIZE_IDENTITY_FROM_RECOVERY", "shareSpace", "spaceKey", "spaceId", "space", "equals", "id", "initialMembers", "members", "member", "identityKey", "SPACE", "filter", "length", "joinSpace", "JOIN_SPACE", "Event", "DEFAULT_SHELL_CHANNEL", "appServiceBundle", "shellServiceBundle", "invariant", "log", "ShellDisplay", "createProtoRpcPeer", "createIFramePort", "shellStyles", "Object", "entries", "display", "position", "top", "left", "width", "height", "border", "reduce", "acc", "key", "value", "ShellManager", "_iframeManager", "_channel", "DEFAULT_SHELL_CHANNEL", "contextUpdate", "Event", "_display", "ShellDisplay", "NONE", "setLayout", "request", "invariant", "_shellRpc", "log", "FULLSCREEN", "emit", "rpc", "ShellService", "timeout", "RPC_TIMEOUT", "iframe", "contentDocument", "querySelector", "focus", "setInvitationUrl", "open", "setAttribute", "on", "style", "blur", "origin", "source", "toString", "split", "slice", "join", "port", "createIFramePort", "channel", "createProtoRpcPeer", "requested", "shellServiceBundle", "exposed", "appServiceBundle", "handlers", "AppService", "setContext", "close", "undefined", "jwtDecode", "synchronized", "invariant", "PublicKey", "log", "schema", "InitAuthSequenceResponse", "ProviderApiError", "Error", "defaultConfig", "name", "baseUrl", "username", "COMPOSER_BETA_COOKIE_NAME", "HUB_SERVICE_ACCESS_CAPABILITY", "HUB_SERVICE_ACCESS_MAGIC", "AgentManagerClient", "_clientConfig", "_halo", "DXRPC_PATH", "_rpcState", "_authToken", "runtimeAgentHostingConfig", "get", "server", "_config", "password", "endsWith", "_wsDxrpcUrl", "URL", "replace", "href", "init", "authToken", "_checkAuthorization", "validCookie", "_checkAuthCookie", "credential", "_getAuthorizationCredential", "cookies", "Object", "fromEntries", "document", "cookie", "split", "map", "v", "decodeURIComponent", "composerBetaJwt", "_decodeComposerBetaJwt", "auth_agent", "decoded", "_getComposerBetaCookie", "queryCredentials", "toSorted", "a", "b", "issuanceDate", "getTime", "find", "matchServiceCredential", "requestInitWithCredentials", "req", "headers", "Authorization", "Buffer", "from", "toString", "requestInitWithAuthToken", "_ensureAuthenticated", "_validAuthToken", "deviceKey", "device", "authDeviceCreds", "_queryCredentials", "cred", "equals", "subject", "id", "length", "agentBetaCredential", "_agentManagerAuth", "_openRpc", "WebsocketRpcClient", "_rpc", "url", "requested", "AgentManager", "getService", "noHandshake", "connected", "on", "disconnected", "error", "err", "info", "open", "warn", "agentAuthzCredential", "result", "nonce", "agentmanagerKey", "initAuthResponseReason", "rpc", "initAuthSequence", "InitAuthSequenceResult", "SUCCESS", "agentmanagerAccessCreds", "issuer", "credsToPresent", "filter", "Boolean", "presentation", "presentCredentials", "ids", "token", "authenticate", "writeCredentials", "exp", "Date", "now", "type", "predicate", "haloCredentials", "credentials", "assertion", "createAgent", "invitationCode", "identityKey", "res", "fetch", "method", "body", "JSON", "stringify", "invitation", "agent", "json", "metadata", "uid", "TypeError", "getAgent", "agentID", "status", "destroyAgent", "capabilities", "credentialCapabilities", "every", "capability", "includes", "sleep", "FakeAgentHostingProvider", "_throw", "_agents", "Map", "createAgent", "invitationCode", "identityKey", "sleep", "agentID", "crypto", "randomUUID", "set", "getAgent", "get", "destroyAgent", "delete", "init", "authToken"]
}
