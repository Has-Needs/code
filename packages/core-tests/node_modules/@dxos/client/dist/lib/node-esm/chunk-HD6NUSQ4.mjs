import { createRequire } from 'node:module';const require = createRequire(import.meta.url);
import {
  SpaceProxy
} from "./chunk-YSDZCRRN.mjs";

// packages/sdk/client/src/echo/index.ts
import { SpaceId } from "@dxos/keys";
import { compareForeignKeys, createQueueDXN, getMeta, getSchema, getType, getTypename, Expando, Ref, RefArray } from "@dxos/echo-schema";
import { live, isLiveObject as isLiveObject2, makeRef, refFromDXN } from "@dxos/live-object";
import { DocAccessor, Query, Filter as Filter2, ObjectVersion, Queue, ResultFormat, createDocAccessor, createObject, createSubscription, defineObjectMigration, fromCursor, isEchoObject, getObjectCore, getRangeFromCursor, getSource, getTarget, getTextInRange, getVersion, loadObjectReferences, toCursor, toCursorRange, updateText, isRelation } from "@dxos/echo-db";
import { decodeReference } from "@dxos/echo-protocol";
import { IndexKind } from "@dxos/protocols/proto/dxos/echo/indexing";
import { QueryOptions } from "@dxos/protocols/proto/dxos/echo/filter";
import { SpaceMember, SpaceState } from "@dxos/protocols/proto/dxos/client/services";
import { SpaceMember as SpaceMember2 } from "@dxos/protocols/proto/dxos/halo/credentials";
import { TextKind } from "@dxos/protocols/proto/dxos/echo/model/text";

// packages/sdk/client/src/echo/util.ts
import { Schema } from "effect";
import { Obj } from "@dxos/echo";
import { getDatabaseFromObject } from "@dxos/echo-db";
import { invariant } from "@dxos/invariant";
import { isLiveObject } from "@dxos/live-object";
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/sdk/client/src/echo/util.ts";
var SPACE_ID_LENGTH = 33;
var OBJECT_ID_LENGTH = 26;
var FQ_ID_LENGTH = SPACE_ID_LENGTH + OBJECT_ID_LENGTH + 1;
var isSpace = (object) => object instanceof SpaceProxy;
var SpaceSchema = Schema.Any.pipe(Schema.filter((x) => isSpace(x)), Schema.annotations({
  title: "Space"
}));
var ReactiveObjectSchema = Schema.Any.pipe(Schema.filter((x) => isLiveObject(x)), Schema.annotations({
  title: "Live"
}));
var EchoObjectSchema = Schema.Any.pipe(Schema.filter((x) => Obj.isObject(x)), Schema.annotations({
  title: "EchoObject"
}));
var getSpace = (object) => {
  if (!object) {
    return void 0;
  }
  const db = getDatabaseFromObject(object);
  const id = db?.spaceId;
  if (id) {
    const owner = db.graph._getOwningObject(id);
    if (owner instanceof SpaceProxy) {
      return owner;
    }
  }
  return void 0;
};
var fullyQualifiedId = (object) => {
  const space = getSpace(object);
  return space ? `${space.id}:${object.id}` : object.id;
};
var parseFullyQualifiedId = (id) => {
  const [spaceId, objectId] = id.split(":");
  invariant(objectId, "invalid id", {
    F: __dxlog_file,
    L: 69,
    S: void 0,
    A: [
      "objectId",
      "'invalid id'"
    ]
  });
  return [
    spaceId,
    objectId
  ];
};
var parseId = (id) => {
  if (!id) {
    return {};
  } else if (id.length === SPACE_ID_LENGTH) {
    return {
      spaceId: id
    };
  } else if (id.length === OBJECT_ID_LENGTH) {
    return {
      objectId: id
    };
  } else if (id.length === FQ_ID_LENGTH && id.indexOf(":") === SPACE_ID_LENGTH) {
    const [spaceId, objectId] = id.split(":");
    return {
      spaceId,
      objectId
    };
  } else {
    return {};
  }
};
var createEmptyEdgeSyncState = () => ({
  missingOnLocal: 0,
  missingOnRemote: 0,
  localDocumentCount: 0,
  remoteDocumentCount: 0,
  differentDocuments: 0
});
var getSyncSummary = (syncMap) => {
  return Object.entries(syncMap).reduce((summary, [_spaceId, peerState]) => {
    summary.missingOnLocal += peerState.missingOnLocal;
    summary.missingOnRemote += peerState.missingOnRemote;
    summary.localDocumentCount += peerState.localDocumentCount;
    summary.remoteDocumentCount += peerState.remoteDocumentCount;
    summary.differentDocuments += peerState.differentDocuments;
    return summary;
  }, createEmptyEdgeSyncState());
};

// packages/sdk/client/src/echo/import.ts
import { TYPE_PROPERTIES } from "@dxos/client-protocol";
import { decodeReferenceJSON, Filter, Serializer } from "@dxos/echo-db";
var importSpace = async (database, data) => {
  const { objects: [properties] } = await database.query(Filter.typename(TYPE_PROPERTIES)).run();
  await new Serializer().import(database, data, {
    onObject: async (object) => {
      const { "@type": typeEncoded, ...data2 } = object;
      const type = decodeReferenceJSON(typeEncoded);
      if (properties && type?.objectId === TYPE_PROPERTIES) {
        Object.entries(data2).forEach(([name, value]) => {
          if (!name.startsWith("@")) {
            properties[name] = value;
          }
        });
        return false;
      }
      return true;
    }
  });
};

export {
  SPACE_ID_LENGTH,
  OBJECT_ID_LENGTH,
  FQ_ID_LENGTH,
  isSpace,
  SpaceSchema,
  ReactiveObjectSchema,
  EchoObjectSchema,
  getSpace,
  fullyQualifiedId,
  parseFullyQualifiedId,
  parseId,
  createEmptyEdgeSyncState,
  getSyncSummary,
  importSpace,
  SpaceId,
  compareForeignKeys,
  createQueueDXN,
  getMeta,
  getSchema,
  getType,
  getTypename,
  Expando,
  Ref,
  RefArray,
  live,
  isLiveObject2 as isLiveObject,
  makeRef,
  refFromDXN,
  DocAccessor,
  Query,
  Filter2 as Filter,
  ObjectVersion,
  Queue,
  ResultFormat,
  createDocAccessor,
  createObject,
  createSubscription,
  defineObjectMigration,
  fromCursor,
  isEchoObject,
  getObjectCore,
  getRangeFromCursor,
  getSource,
  getTarget,
  getTextInRange,
  getVersion,
  loadObjectReferences,
  toCursor,
  toCursorRange,
  updateText,
  isRelation,
  decodeReference,
  IndexKind,
  QueryOptions,
  SpaceMember,
  SpaceState,
  SpaceMember2,
  TextKind
};
//# sourceMappingURL=chunk-HD6NUSQ4.mjs.map
