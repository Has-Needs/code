import { createRequire } from 'node:module';const require = createRequire(import.meta.url);
import {
  InvitationsProxy
} from "./chunk-RT5VBVJV.mjs";
import {
  RPC_TIMEOUT
} from "./chunk-YV6DEKSE.mjs";

// packages/sdk/client/src/halo/halo-proxy.ts
import { inspect } from "node:util";
import { asyncTimeout, Event, MulticastObservable, Trigger, SubscriptionList } from "@dxos/async";
import { AUTH_TIMEOUT } from "@dxos/client-protocol";
import { inspectObject } from "@dxos/debug";
import { invariant } from "@dxos/invariant";
import { PublicKey } from "@dxos/keys";
import { log } from "@dxos/log";
import { ApiError, trace as Trace } from "@dxos/protocols";
import { DeviceKind, Invitation } from "@dxos/protocols/proto/dxos/client/services";
import { trace } from "@dxos/tracing";
function _ts_decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/sdk/client/src/halo/halo-proxy.ts";
var HaloProxy = class {
  constructor(_serviceProvider, _traceParent) {
    this._serviceProvider = _serviceProvider;
    this._traceParent = _traceParent;
    this._instanceId = PublicKey.random().toHex();
    this._subscriptions = new SubscriptionList();
    this._identityChanged = new Event();
    this._devicesChanged = new Event();
    this._contactsChanged = new Event();
    this._credentialsChanged = new Event();
    this._identity = MulticastObservable.from(this._identityChanged, null);
    this._devices = MulticastObservable.from(this._devicesChanged, []);
    this._contacts = MulticastObservable.from(this._contactsChanged, []);
    this._credentials = MulticastObservable.from(this._credentialsChanged, []);
  }
  [inspect.custom]() {
    return inspectObject(this);
  }
  toJSON() {
    return {
      identityKey: this._identity.get()?.identityKey.truncate(),
      deviceKey: this.device?.deviceKey.truncate()
    };
  }
  /**
  * User identity info.
  */
  get identity() {
    return this._identity;
  }
  get devices() {
    return this._devices;
  }
  get device() {
    return this._devices.get().find((device) => device.kind === DeviceKind.CURRENT);
  }
  get contacts() {
    return this._contacts;
  }
  get credentials() {
    return this._credentials;
  }
  get invitations() {
    invariant(this._invitationProxy, "HaloProxy not opened", {
      F: __dxlog_file,
      L: 95,
      S: this,
      A: [
        "this._invitationProxy",
        "'HaloProxy not opened'"
      ]
    });
    return this._invitationProxy.created;
  }
  // TODO(burdon): Standardize isOpen, etc.
  get opened() {
    return this._invitationProxy !== void 0;
  }
  /**
  * Allocate resources and set-up internal subscriptions.
  *
  * @internal
  */
  async _open() {
    log.trace("dxos.sdk.halo-proxy.open", Trace.begin({
      id: this._instanceId,
      parentId: this._traceParent
    }), {
      F: __dxlog_file,
      L: 111,
      S: this,
      C: (f, a) => f(...a)
    });
    const gotIdentity = this._identityChanged.waitForCount(1);
    invariant(this._serviceProvider.services.InvitationsService, "InvitationsService not available", {
      F: __dxlog_file,
      L: 115,
      S: this,
      A: [
        "this._serviceProvider.services.InvitationsService",
        "'InvitationsService not available'"
      ]
    });
    this._invitationProxy = new InvitationsProxy(this._serviceProvider.services.InvitationsService, this._serviceProvider.services.IdentityService, () => ({
      kind: Invitation.Kind.DEVICE
    }));
    await this._invitationProxy.open();
    this._identityChanged.on((identity) => {
      if (identity && !this._haloCredentialStream) {
        invariant(this._serviceProvider.services.SpacesService, "SpacesService not available", {
          F: __dxlog_file,
          L: 127,
          S: this,
          A: [
            "this._serviceProvider.services.SpacesService",
            "'SpacesService not available'"
          ]
        });
        this._haloCredentialStream = this._serviceProvider.services.SpacesService.queryCredentials({
          spaceKey: identity.spaceKey
        }, {
          timeout: RPC_TIMEOUT
        });
        this._haloCredentialStream.subscribe((data) => {
          this._credentialsChanged.emit([
            ...this._credentials.get(),
            data
          ]);
        });
        this._subscriptions.add(() => this._haloCredentialStream?.close());
      }
    });
    invariant(this._serviceProvider.services.IdentityService, "IdentityService not available", {
      F: __dxlog_file,
      L: 141,
      S: this,
      A: [
        "this._serviceProvider.services.IdentityService",
        "'IdentityService not available'"
      ]
    });
    const identityStream = this._serviceProvider.services.IdentityService.queryIdentity(void 0, {
      timeout: RPC_TIMEOUT
    });
    identityStream.subscribe((data) => {
      data.identity && log.trace("dxos.halo.identity", {
        identityKey: data.identity.identityKey,
        displayName: data.identity.profile?.displayName
      }, {
        F: __dxlog_file,
        L: 148,
        S: this,
        C: (f, a) => f(...a)
      });
      this._identityChanged.emit(data.identity ?? null);
    });
    this._subscriptions.add(() => identityStream.close());
    const contactsStream = this._serviceProvider.services.ContactsService.queryContacts(void 0, {
      timeout: RPC_TIMEOUT
    });
    contactsStream.subscribe((data) => {
      this._contactsChanged.emit(data.contacts ?? []);
    });
    this._subscriptions.add(() => contactsStream.close());
    invariant(this._serviceProvider.services.DevicesService, "DevicesService not available", {
      F: __dxlog_file,
      L: 164,
      S: this,
      A: [
        "this._serviceProvider.services.DevicesService",
        "'DevicesService not available'"
      ]
    });
    const devicesStream = this._serviceProvider.services.DevicesService.queryDevices(void 0, {
      timeout: RPC_TIMEOUT
    });
    devicesStream.subscribe((data) => {
      if (data.devices) {
        this._devicesChanged.emit(data.devices);
        const current = data.devices.find((device) => device.kind === DeviceKind.CURRENT);
        log.trace("dxos.halo.device", {
          deviceKey: current?.deviceKey,
          profile: current?.profile
        }, {
          F: __dxlog_file,
          L: 172,
          S: this,
          C: (f, a) => f(...a)
        });
      }
    });
    this._subscriptions.add(() => devicesStream.close());
    log.trace("dxos.sdk.halo-proxy.open", Trace.end({
      id: this._instanceId
    }), {
      F: __dxlog_file,
      L: 180,
      S: this,
      C: (f, a) => f(...a)
    });
    await Promise.all([
      gotIdentity
    ]);
  }
  /**
  * Destroy the instance and clean-up subscriptions.
  *
  * @internal
  */
  async _close() {
    await this._invitationProxy?.close();
    this._invitationProxy = void 0;
    this._subscriptions.clear();
    this._identityChanged.emit(null);
    this._devicesChanged.emit([]);
    this._contactsChanged.emit([]);
  }
  /**
  * @internal
  */
  // TODO(wittjosiah): Should `Observable` class support this?
  _waitForIdentity() {
    return this._identityChanged.waitForCondition(() => !!this._identity.get());
  }
  /**
  * Create Identity.
  * Then initializes profile with given display name.
  * @param profile - optional display name
  * @param deviceProfile - optional device profile that will be merged with defaults
  */
  async createIdentity(profile = {}, deviceProfile) {
    invariant(this._serviceProvider.services.IdentityService, "IdentityService not available", {
      F: __dxlog_file,
      L: 213,
      S: this,
      A: [
        "this._serviceProvider.services.IdentityService",
        "'IdentityService not available'"
      ]
    });
    invariant(!this.identity.get(), "Identity already exists", {
      F: __dxlog_file,
      L: 214,
      S: this,
      A: [
        "!this.identity.get()",
        "'Identity already exists'"
      ]
    });
    const deviceProfileWithDefaults = {
      ...deviceProfile,
      ...deviceProfile?.label ? {
        label: deviceProfile.label
      } : {
        label: "initial identity device"
      }
    };
    const identity = await this._serviceProvider.services.IdentityService.createIdentity({
      profile,
      deviceProfile: deviceProfileWithDefaults
    }, {
      timeout: RPC_TIMEOUT
    });
    this._identityChanged.emit(identity);
    return identity;
  }
  async recoverIdentity(args) {
    invariant(this._serviceProvider.services.IdentityService, "IdentityService not available", {
      F: __dxlog_file,
      L: 231,
      S: this,
      A: [
        "this._serviceProvider.services.IdentityService",
        "'IdentityService not available'"
      ]
    });
    const identity = await this._serviceProvider.services.IdentityService.recoverIdentity(args, {
      timeout: RPC_TIMEOUT
    });
    this._identityChanged.emit(identity);
    return identity;
  }
  async updateProfile(profile) {
    invariant(this._serviceProvider.services.IdentityService, "IdentityService not available", {
      F: __dxlog_file,
      L: 240,
      S: this,
      A: [
        "this._serviceProvider.services.IdentityService",
        "'IdentityService not available'"
      ]
    });
    const identity = await this._serviceProvider.services.IdentityService.updateProfile(profile, {
      timeout: RPC_TIMEOUT
    });
    this._identityChanged.emit(identity);
    return identity;
  }
  /**
  * Get Halo credentials for the current user.
  * Note: Will return an empty result if called before all credentials have been loaded.
  */
  queryCredentials({ ids, type } = {}) {
    return this._credentials.get().filter((credential) => {
      if (ids && !ids.some((id) => id.equals(credential.id))) {
        return false;
      }
      if (type && credential.subject.assertion["@type"] !== type) {
        return false;
      }
      return true;
    });
  }
  /**
  * Initiates device invitation.
  */
  share(options) {
    if (!this.opened) {
      throw new ApiError("Client not open.");
    }
    log("create invitation", {
      options
    }, {
      F: __dxlog_file,
      L: 272,
      S: this,
      C: (f, a) => f(...a)
    });
    const invitation = this._invitationProxy.share(options);
    return invitation;
  }
  /**
  * Initiates accepting invitation.
  * @param invitation
  * @param deviceProfile - optional device profile that will be merged with defaults
  */
  join(invitation, deviceProfile) {
    if (!this.opened) {
      throw new ApiError("Client not open.");
    }
    const deviceProfileWithDefaults = {
      ...deviceProfile,
      ...deviceProfile?.label ? {
        label: deviceProfile.label
      } : {
        label: "additional device"
      }
    };
    return this._invitationProxy.join(invitation, deviceProfileWithDefaults);
  }
  /**
  * Write credentials to halo profile.
  */
  async writeCredentials(credentials) {
    const identity = this._identity.get();
    if (!identity) {
      throw new ApiError("Identity is not available.");
    }
    if (!this._serviceProvider.services.SpacesService) {
      throw new ApiError("SpacesService is not available.");
    }
    return this._serviceProvider.services.SpacesService.writeCredentials({
      spaceKey: identity.spaceKey,
      credentials
    }, {
      timeout: RPC_TIMEOUT
    });
  }
  /**
  * Present Credentials.
  */
  // TODO(burdon): Rename createPresentation?
  async presentCredentials({ ids, nonce }) {
    if (!this._serviceProvider.services.IdentityService) {
      throw new ApiError("IdentityService is not available.");
    }
    const trigger = new Trigger();
    this._credentials.subscribe((credentials2) => {
      const credentialsToPresent = credentials2.filter((credential) => ids.some((id) => id.equals(credential.id)));
      if (credentialsToPresent.length === ids.length) {
        trigger.wake(credentialsToPresent);
      }
    });
    const credentials = await asyncTimeout(trigger.wait(), AUTH_TIMEOUT, new ApiError("Timeout while waiting for credentials."));
    return this._serviceProvider.services.IdentityService.signPresentation({
      presentation: {
        credentials
      },
      nonce
    }, {
      timeout: RPC_TIMEOUT
    });
  }
};
_ts_decorate([
  trace.info({
    depth: null
  })
], HaloProxy.prototype, "toJSON", null);
_ts_decorate([
  trace.info()
], HaloProxy.prototype, "opened", null);
HaloProxy = _ts_decorate([
  trace.resource()
], HaloProxy);
export {
  HaloProxy
};
//# sourceMappingURL=halo-proxy-WKTHF4OP.mjs.map
