{
  "version": 3,
  "sources": ["../../../src/echo/space-proxy.ts"],
  "sourcesContent": ["//\n// Copyright 2021 DXOS.org\n//\n\nimport isEqualWith from 'lodash.isequalwith';\n\nimport { Event, MulticastObservable, scheduleMicroTask, synchronized, Trigger } from '@dxos/async';\nimport { PropertiesType, type ClientServicesProvider, type Space, type SpaceInternal } from '@dxos/client-protocol';\nimport { Stream } from '@dxos/codec-protobuf/stream';\nimport { cancelWithContext, Context } from '@dxos/context';\nimport { checkCredentialType, type SpecificCredential } from '@dxos/credentials';\nimport {\n  inspectCustom,\n  loadashEqualityFn,\n  todo,\n  warnAfterTimeout,\n  type CustomInspectable,\n  type CustomInspectFunction,\n} from '@dxos/debug';\nimport {\n  Filter,\n  type QueueFactory,\n  type AnyLiveObject,\n  type CoreDatabase,\n  type EchoClient,\n  type EchoDatabase,\n  type EchoDatabaseImpl,\n} from '@dxos/echo-db';\nimport { invariant } from '@dxos/invariant';\nimport { type PublicKey, type SpaceId } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { decodeError } from '@dxos/protocols';\nimport {\n  CreateEpochRequest,\n  Invitation,\n  SpaceState,\n  type Contact,\n  type SpaceArchive,\n  type Space as SpaceData,\n  type SpaceMember,\n  type UpdateMemberRoleRequest,\n} from '@dxos/protocols/proto/dxos/client/services';\nimport { QueryOptions } from '@dxos/protocols/proto/dxos/echo/filter';\nimport { type EdgeReplicationSetting } from '@dxos/protocols/proto/dxos/echo/metadata';\nimport { type SpaceSnapshot } from '@dxos/protocols/proto/dxos/echo/snapshot';\nimport {\n  SpaceMember as HaloSpaceMember,\n  type Credential,\n  type Epoch,\n} from '@dxos/protocols/proto/dxos/halo/credentials';\nimport { type GossipMessage } from '@dxos/protocols/proto/dxos/mesh/teleport/gossip';\nimport { Timeframe } from '@dxos/timeframe';\nimport { trace } from '@dxos/tracing';\n\nimport { RPC_TIMEOUT } from '../common';\nimport { InvitationsProxy } from '../invitations';\n\nconst EPOCH_CREATION_TIMEOUT = 60_000;\n\n// TODO(burdon): This should not be used as part of the API (don't export).\n@trace.resource()\nexport class SpaceProxy implements Space, CustomInspectable {\n  private _ctx = new Context();\n\n  /**\n   * Sent whenever any space data changes.\n   */\n  private readonly _anySpaceUpdate = new Event<SpaceData>();\n\n  /**\n   * @internal\n   * To update the space query when a space changes.\n   */\n  // TODO(dmaretskyi): Make private.\n  public readonly _stateUpdate = new Event<SpaceState>();\n\n  private readonly _pipelineUpdate = new Event<SpaceData.PipelineState>();\n\n  // TODO(dmaretskyi): Reconcile initialization states.\n\n  /**\n   * @internal\n   * To unlock internal operations that should happen after the database is initialized but before initialize() completes.\n   */\n  public readonly _databaseInitialized = new Trigger();\n\n  /**\n   * @internal\n   * Space proxy is fully initialized, database open, state is READY.\n   */\n  public readonly _initializationComplete = new Trigger();\n\n  @trace.info()\n  private _initializing = false;\n\n  /**\n   * @internal\n   */\n  @trace.info()\n  _initialized = false;\n\n  private readonly _db!: EchoDatabaseImpl;\n  private readonly _internal!: SpaceInternal;\n  private readonly _invitationsProxy: InvitationsProxy;\n\n  private readonly _state = MulticastObservable.from(this._stateUpdate, SpaceState.SPACE_CLOSED);\n  private readonly _pipeline = MulticastObservable.from(this._pipelineUpdate, {});\n  private readonly _membersUpdate = new Event<SpaceMember[]>();\n  private readonly _members = MulticastObservable.from(this._membersUpdate, []);\n\n  private readonly _queues!: QueueFactory;\n\n  private _databaseOpen = false;\n  private _error: Error | undefined = undefined;\n  private _properties?: AnyLiveObject<any> = undefined;\n\n  constructor(\n    private _clientServices: ClientServicesProvider,\n    private _data: SpaceData,\n    echoClient: EchoClient,\n  ) {\n    log('construct', { key: _data.spaceKey, state: SpaceState[_data.state] });\n    invariant(this._clientServices.services.InvitationsService, 'InvitationsService not available');\n    this._invitationsProxy = new InvitationsProxy(\n      this._clientServices.services.InvitationsService,\n      this._clientServices.services.IdentityService,\n      () => ({\n        kind: Invitation.Kind.SPACE,\n        spaceKey: this.key,\n      }),\n    );\n\n    this._db = echoClient.constructDatabase({ spaceId: this.id, spaceKey: this.key, owningObject: this });\n    this._queues = echoClient.constructQueueFactory(this.id);\n\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this;\n    this._internal = {\n      get data() {\n        return self._data;\n      },\n      createEpoch: this._createEpoch.bind(this),\n      getCredentials: this._getCredentials.bind(this),\n      getEpochs: this._getEpochs.bind(this),\n      removeMember: this._removeMember.bind(this),\n      migrate: this._migrate.bind(this),\n      setEdgeReplicationPreference: this._setEdgeReplicationPreference.bind(this),\n      export: this._export.bind(this),\n    };\n\n    this._error = this._data.error ? decodeError(this._data.error) : undefined;\n\n    // Update observables.\n    this._stateUpdate.emit(this._currentState);\n    this._pipelineUpdate.emit(_data.pipeline ?? {});\n    this._membersUpdate.emit(_data.members ?? []);\n  }\n\n  toJSON() {\n    return {\n      id: this.id,\n      db: this._db.toJSON(),\n      state: SpaceState[this.state.get()],\n    };\n  }\n\n  get id(): SpaceId {\n    return this._data.id as SpaceId;\n  }\n\n  @trace.info()\n  get key() {\n    return this._data.spaceKey;\n  }\n\n  get db(): EchoDatabase {\n    return this._db;\n  }\n\n  get queues(): QueueFactory {\n    return this._queues;\n  }\n\n  /**\n   * @deprecated\n   */\n  get crud(): CoreDatabase {\n    return this._db.coreDatabase;\n  }\n\n  @trace.info()\n  get isOpen() {\n    return this._data.state === SpaceState.SPACE_READY && this._initialized;\n  }\n\n  @trace.info({ depth: 2 })\n  get properties(): AnyLiveObject<any> {\n    this._throwIfNotInitialized();\n    invariant(this._properties, 'Properties not available');\n    return this._properties;\n  }\n\n  get state() {\n    return this._state;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  get pipeline() {\n    return this._pipeline;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  get invitations() {\n    return this._invitationsProxy.created;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  get members() {\n    return this._members;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  // TODO(burdon): Remove?\n  get internal(): SpaceInternal {\n    return this._internal;\n  }\n\n  get error(): Error | undefined {\n    return this._error;\n  }\n\n  get [Symbol.toStringTag](): string {\n    return 'SpaceProxy';\n  }\n\n  [inspectCustom]: CustomInspectFunction = (depth, options, inspect) => {\n    return `${options.stylize(this[Symbol.toStringTag], 'special')} ${inspect({\n      id: this.id,\n      state: SpaceState[this.state.get()],\n    })}`;\n  };\n\n  /**\n   * Current state of the space.\n   * The database is ready to be used in `SpaceState.SPACE_READY` state.\n   * Presence is available in `SpaceState.SPACE_CONTROL_ONLY` state.\n   */\n  @trace.info({ enum: SpaceState })\n  private get _currentState(): SpaceState {\n    if (this._data.state === SpaceState.SPACE_READY && !this._initialized) {\n      return SpaceState.SPACE_INITIALIZING;\n    } else {\n      return this._data.state;\n    }\n  }\n\n  /**\n   * Called by EchoProxy to update this space instance.\n   * Called once on initial creation.\n   * @internal Package-private.\n   */\n  @synchronized\n  async _processSpaceUpdate(space: SpaceData): Promise<void> {\n    const emitEvent = shouldUpdate(this._data, space);\n    const emitPipelineEvent = shouldPipelineUpdate(this._data, space);\n    const emitMembersEvent = shouldMembersUpdate(this._data.members, space.members);\n    const isFirstTimeInitializing =\n      space.state === SpaceState.SPACE_READY && !(this._initialized || this._initializing);\n    const isReopening =\n      this._data.state !== SpaceState.SPACE_READY && space.state === SpaceState.SPACE_READY && !this._databaseOpen;\n    const shouldReset = this._databaseOpen && space.state === SpaceState.SPACE_REQUIRES_MIGRATION;\n\n    log('update', {\n      key: space.spaceKey,\n      prevState: SpaceState[this._data.state],\n      state: SpaceState[space.state],\n      emitEvent,\n      emitPipelineEvent,\n      emitMembersEvent,\n      isFirstTimeInitializing,\n      isReopening,\n    });\n\n    this._data = space;\n\n    if (isFirstTimeInitializing) {\n      await this._initialize();\n    } else if (isReopening) {\n      await this._initializeDb();\n    } else if (shouldReset) {\n      await this._reset();\n    }\n\n    if (space.error) {\n      this._error = decodeError(space.error);\n    }\n\n    if (this._initialized) {\n      // Transition onto new automerge root.\n      const automergeRoot = space.pipeline?.spaceRootUrl;\n      if (automergeRoot) {\n        log('set space root', { spaceKey: this.key, automergeRoot });\n        // NOOP if the root is the same.\n        await this._db.setSpaceRoot(automergeRoot);\n      }\n    }\n\n    this._anySpaceUpdate.emit(space);\n    if (emitEvent) {\n      this._stateUpdate.emit(this._currentState);\n    }\n    if (emitPipelineEvent) {\n      this._pipelineUpdate.emit(space.pipeline ?? {});\n    }\n    if (emitMembersEvent) {\n      this._membersUpdate.emit(space.members!);\n    }\n  }\n\n  private async _initialize(): Promise<void> {\n    if (this._initializing || this._initialized) {\n      return;\n    }\n\n    log('initializing...', { space: this.key });\n    this._initializing = true;\n    await this._invitationsProxy.open();\n    await this._initializeDb();\n\n    this._initialized = true;\n    this._initializing = false;\n    this._initializationComplete.wake();\n    this._stateUpdate.emit(this._currentState);\n    this._data.members && this._membersUpdate.emit(this._data.members);\n    log('initialized', { space: this.key });\n  }\n\n  @trace.span({ showInBrowserTimeline: true })\n  private async _initializeDb(): Promise<void> {\n    this._databaseOpen = true;\n\n    {\n      const automergeRoot = this._data.pipeline?.spaceRootUrl;\n      if (automergeRoot !== undefined) {\n        await this._db.setSpaceRoot(automergeRoot);\n      } else {\n        log.warn('no automerge root found for space', { spaceId: this.id });\n      }\n      await this._db.open();\n    }\n\n    log('ready');\n\n    this._databaseInitialized.wake();\n\n    const propertiesAvailable = new Trigger();\n    // Set properties document when it's available.\n    // NOTE: Emits state update event when properties are first available.\n    //   This is needed to ensure reactivity for newly created spaces.\n    // TODO(wittjosiah): Transfer subscriptions from cached properties to the new properties object.\n    {\n      const unsubscribe = this._db\n        .query(Filter.type(PropertiesType), { dataLocation: QueryOptions.DataLocation.LOCAL })\n        .subscribe(\n          (query) => {\n            if (query.objects.length === 1) {\n              this._properties = query.objects[0];\n              propertiesAvailable.wake();\n              this._stateUpdate.emit(this._currentState);\n              scheduleMicroTask(this._ctx, () => {\n                unsubscribe();\n              });\n            }\n          },\n          { fire: true },\n        );\n    }\n    await warnAfterTimeout(5_000, 'Finding properties for a space', () =>\n      cancelWithContext(this._ctx, propertiesAvailable.wait()),\n    );\n  }\n\n  /**\n   * Called by EchoProxy close.\n   * @internal Package-private.\n   */\n  @synchronized\n  async _destroy(): Promise<void> {\n    await this._reset();\n  }\n\n  private async _reset(): Promise<void> {\n    log('destroying...');\n    await this._ctx.dispose();\n    this._ctx = new Context();\n    await this._invitationsProxy.close();\n    await this._db.close();\n    this._initializationComplete.reset();\n    this._databaseInitialized.reset();\n    this._initializing = false;\n    this._initialized = false;\n    this._databaseOpen = false;\n    log('destroyed');\n  }\n\n  async open(): Promise<void> {\n    await this._clientServices.services.SpacesService!.updateSpace(\n      { spaceKey: this.key, state: SpaceState.SPACE_ACTIVE },\n      { timeout: RPC_TIMEOUT },\n    );\n  }\n\n  async close(): Promise<void> {\n    if (this._databaseOpen) {\n      await this._db.flush();\n    }\n    await this._clientServices.services.SpacesService!.updateSpace(\n      { spaceKey: this.key, state: SpaceState.SPACE_INACTIVE },\n      { timeout: RPC_TIMEOUT },\n    );\n  }\n\n  /**\n   * Waits until the space is in the ready state, with database initialized.\n   */\n  async waitUntilReady(): Promise<this> {\n    await cancelWithContext(this._ctx, this._initializationComplete.wait());\n    return this;\n  }\n\n  /**\n   * Post a message to the space.\n   */\n  async postMessage(channel: string, message: any): Promise<void> {\n    invariant(this._clientServices.services.SpacesService, 'SpacesService not available');\n    await this._clientServices.services.SpacesService.postMessage(\n      {\n        spaceKey: this.key,\n        channel,\n        message: { ...message, '@type': message['@type'] || 'google.protobuf.Struct' },\n      },\n      { timeout: RPC_TIMEOUT },\n    );\n  }\n\n  /**\n   * Listen for messages posted to the space.\n   */\n  listen(channel: string, callback: (message: GossipMessage) => void): () => Promise<void> {\n    invariant(this._clientServices.services.SpacesService, 'SpacesService not available');\n    const stream = this._clientServices.services.SpacesService.subscribeMessages(\n      { spaceKey: this.key, channel },\n      { timeout: RPC_TIMEOUT },\n    );\n    stream.subscribe(callback);\n    return () => stream.close();\n  }\n\n  /**\n   * Creates a delegated or interactive invitation.\n   */\n  share(options?: Partial<Invitation>) {\n    this._throwIfNotInitialized();\n    log('create invitation', options);\n    return this._invitationsProxy.share({ ...options, spaceKey: this.key });\n  }\n\n  async admitContact(contact: Contact): Promise<void> {\n    await this._clientServices.services.SpacesService!.admitContact({\n      spaceKey: this.key,\n      role: HaloSpaceMember.Role.ADMIN,\n      contact,\n    });\n  }\n\n  /**\n   * Requests member role update.\n   */\n  updateMemberRole(request: Omit<UpdateMemberRoleRequest, 'spaceKey'>): Promise<void> {\n    this._throwIfNotInitialized();\n    return this._clientServices.services.SpacesService!.updateMemberRole({\n      spaceKey: this.key,\n      memberKey: request.memberKey,\n      newRole: request.newRole,\n    });\n  }\n\n  /**\n   * Implementation method.\n   */\n  createSnapshot(): Promise<SpaceSnapshot> {\n    return todo();\n    // return this._serviceProvider.services.SpaceService.createSnapshot({ space_key: this.key });\n  }\n\n  private async _removeMember(memberKey: PublicKey): Promise<void> {\n    return this._clientServices.services.SpacesService!.updateMemberRole({\n      spaceKey: this.key,\n      memberKey,\n      newRole: HaloSpaceMember.Role.REMOVED,\n    });\n  }\n\n  private async _createEpoch({\n    migration,\n    automergeRootUrl,\n  }: { migration?: CreateEpochRequest.Migration; automergeRootUrl?: string } = {}): Promise<void> {\n    log('create epoch', { migration, automergeRootUrl });\n    const { controlTimeframe: targetTimeframe } = await this._clientServices.services.SpacesService!.createEpoch(\n      {\n        spaceKey: this.key,\n        migration,\n        automergeRootUrl,\n      },\n      { timeout: EPOCH_CREATION_TIMEOUT },\n    );\n\n    if (targetTimeframe) {\n      await warnAfterTimeout(5_000, 'Waiting for the created epoch to be applied', () =>\n        this._anySpaceUpdate.waitForCondition(() => {\n          const currentTimeframe = this._data.pipeline?.currentControlTimeframe;\n          return (currentTimeframe && Timeframe.dependencies(targetTimeframe, currentTimeframe).isEmpty()) ?? false;\n        }),\n      );\n    }\n  }\n\n  private async _getCredentials(): Promise<Credential[]> {\n    const stream = this._clientServices.services.SpacesService?.queryCredentials({ spaceKey: this.key, noTail: true });\n    invariant(stream, 'SpacesService not available');\n    return await Stream.consumeData(stream);\n  }\n\n  private async _getEpochs(): Promise<SpecificCredential<Epoch>[]> {\n    const credentials = await this._getCredentials();\n    return credentials.filter((credential) => checkCredentialType(credential, 'dxos.halo.credentials.Epoch'));\n  }\n\n  private async _migrate(): Promise<void> {\n    await this._createEpoch({\n      migration: CreateEpochRequest.Migration.MIGRATE_REFERENCES_TO_DXN,\n    });\n\n    // Needed to have space root set to be able to make next check.\n    await this._databaseInitialized.wait();\n\n    if (this._db.coreDatabase.getNumberOfInlineObjects() > 1) {\n      await this._createEpoch({\n        migration: CreateEpochRequest.Migration.FRAGMENT_AUTOMERGE_ROOT,\n      });\n    }\n  }\n\n  private async _setEdgeReplicationPreference(setting: EdgeReplicationSetting): Promise<void> {\n    await this._clientServices.services.SpacesService!.updateSpace(\n      {\n        spaceKey: this.key,\n        edgeReplication: setting,\n      },\n      { timeout: RPC_TIMEOUT },\n    );\n  }\n\n  private _throwIfNotInitialized(): void {\n    if (!this._initialized) {\n      throw new Error('Space is not initialized.');\n    }\n  }\n\n  private async _export(): Promise<SpaceArchive> {\n    const { archive } = await this._clientServices.services.SpacesService!.exportSpace({ spaceId: this.id });\n    return archive;\n  }\n}\n\nconst shouldUpdate = (prev: SpaceData, next: SpaceData) => {\n  return prev.state !== next.state;\n};\n\nconst shouldPipelineUpdate = (prev: SpaceData, next: SpaceData) => {\n  return !isEqualWith(prev.pipeline, next.pipeline, loadashEqualityFn);\n};\n\nconst shouldMembersUpdate = (prev: SpaceMember[] | undefined, next: SpaceMember[] | undefined) => {\n  if (!next) {\n    return false;\n  }\n\n  return !isEqualWith(prev, next, loadashEqualityFn);\n};\n"],
  "mappings": "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",
  "names": ["import_credentials", "EPOCH_CREATION_TIMEOUT", "SpaceProxy", "_clientServices", "_data", "echoClient", "_ctx", "Context", "_anySpaceUpdate", "Event", "_stateUpdate", "_pipelineUpdate", "_databaseInitialized", "Trigger", "_initializationComplete", "_initializing", "_initialized", "_state", "MulticastObservable", "from", "SpaceState", "SPACE_CLOSED", "_pipeline", "_membersUpdate", "_members", "_databaseOpen", "_error", "undefined", "_properties", "inspectCustom", "depth", "options", "inspect", "stylize", "Symbol", "toStringTag", "id", "state", "get", "log", "key", "spaceKey", "invariant", "services", "InvitationsService", "_invitationsProxy", "InvitationsProxy", "IdentityService", "kind", "Invitation", "Kind", "SPACE", "_db", "constructDatabase", "spaceId", "owningObject", "_queues", "constructQueueFactory", "self", "_internal", "data", "createEpoch", "_createEpoch", "bind", "getCredentials", "_getCredentials", "getEpochs", "_getEpochs", "removeMember", "_removeMember", "migrate", "_migrate", "setEdgeReplicationPreference", "_setEdgeReplicationPreference", "export", "_export", "error", "decodeError", "emit", "_currentState", "pipeline", "members", "toJSON", "db", "queues", "crud", "coreDatabase", "isOpen", "SPACE_READY", "properties", "_throwIfNotInitialized", "invitations", "created", "internal", "SPACE_INITIALIZING", "_processSpaceUpdate", "space", "emitEvent", "shouldUpdate", "emitPipelineEvent", "shouldPipelineUpdate", "emitMembersEvent", "shouldMembersUpdate", "isFirstTimeInitializing", "isReopening", "shouldReset", "SPACE_REQUIRES_MIGRATION", "prevState", "_initialize", "_initializeDb", "_reset", "automergeRoot", "spaceRootUrl", "setSpaceRoot", "open", "wake", "warn", "propertiesAvailable", "unsubscribe", "query", "Filter", "type", "PropertiesType", "dataLocation", "QueryOptions", "DataLocation", "LOCAL", "subscribe", "objects", "length", "scheduleMicroTask", "fire", "warnAfterTimeout", "cancelWithContext", "wait", "_destroy", "dispose", "close", "reset", "SpacesService", "updateSpace", "SPACE_ACTIVE", "timeout", "RPC_TIMEOUT", "flush", "SPACE_INACTIVE", "waitUntilReady", "postMessage", "channel", "message", "listen", "callback", "stream", "subscribeMessages", "share", "admitContact", "contact", "role", "HaloSpaceMember", "Role", "ADMIN", "updateMemberRole", "request", "memberKey", "newRole", "createSnapshot", "todo", "REMOVED", "migration", "automergeRootUrl", "controlTimeframe", "targetTimeframe", "waitForCondition", "currentTimeframe", "currentControlTimeframe", "Timeframe", "dependencies", "isEmpty", "queryCredentials", "noTail", "Stream", "consumeData", "credentials", "filter", "credential", "checkCredentialType", "CreateEpochRequest", "Migration", "MIGRATE_REFERENCES_TO_DXN", "getNumberOfInlineObjects", "FRAGMENT_AUTOMERGE_ROOT", "setting", "edgeReplication", "Error", "archive", "exportSpace", "info", "enum", "span", "showInBrowserTimeline", "resource", "prev", "next", "isEqualWith", "loadashEqualityFn"]
}
