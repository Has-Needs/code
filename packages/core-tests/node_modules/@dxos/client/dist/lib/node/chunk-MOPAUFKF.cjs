"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var chunk_MOPAUFKF_exports = {};
__export(chunk_MOPAUFKF_exports, {
  AuthenticatingInvitation: () => import_client_protocol.AuthenticatingInvitation,
  CancellableInvitation: () => import_client_protocol.CancellableInvitation,
  Invitation: () => import_services.Invitation,
  InvitationEncoder: () => import_client_protocol.InvitationEncoder,
  InvitationsProxy: () => InvitationsProxy
});
module.exports = __toCommonJS(chunk_MOPAUFKF_exports);
var import_chunk_P7Y3AD6I = require("./chunk-P7Y3AD6I.cjs");
var import_client_protocol = require("@dxos/client-protocol");
var import_services = require("@dxos/protocols/proto/dxos/client/services");
var import_async = require("@dxos/async");
var import_client_protocol2 = require("@dxos/client-protocol");
var import_context = require("@dxos/context");
var import_invariant = require("@dxos/invariant");
var import_keys = require("@dxos/keys");
var import_log = require("@dxos/log");
var import_services2 = require("@dxos/protocols/proto/dxos/client/services");
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/sdk/client/src/invitations/invitations-proxy.ts";
var createObservable = (rpcStream) => {
  const pushStream = new import_async.PushStream();
  rpcStream.subscribe((value) => {
    pushStream.next(value);
  }, (err) => {
    if (err) {
      pushStream.error(err);
    } else {
      pushStream.complete();
    }
  });
  return pushStream.observable;
};
var InvitationsProxy = class {
  constructor(_invitationsService, _identityService, _getInvitationContext) {
    this._invitationsService = _invitationsService;
    this._identityService = _identityService;
    this._getInvitationContext = _getInvitationContext;
    this._createdUpdate = new import_async.Event();
    this._acceptedUpdate = new import_async.Event();
    this._savedUpdate = new import_async.Event();
    this._created = import_async.MulticastObservable.from(this._createdUpdate, []);
    this._accepted = import_async.MulticastObservable.from(this._acceptedUpdate, []);
    this._saved = import_async.MulticastObservable.from(this._savedUpdate, []);
    this._invitations = /* @__PURE__ */ new Set();
    this._invitationsLoaded = new import_async.Trigger();
    this._opened = false;
  }
  get created() {
    return this._created;
  }
  get accepted() {
    return this._accepted;
  }
  /**
  * @test-only
  */
  get saved() {
    return this._saved;
  }
  get isOpen() {
    return this._opened;
  }
  async open() {
    if (this._opened) {
      return;
    }
    (0, import_log.log)("opening...", this._getInvitationContext(), {
      F: __dxlog_file,
      L: 94,
      S: this,
      C: (f, a) => f(...a)
    });
    this._ctx = new import_context.Context(void 0, {
      F: __dxlog_file,
      L: 95
    });
    const persistentLoaded = new import_async.Trigger();
    const initialCreatedReceived = new import_async.Trigger();
    const initialAcceptedReceived = new import_async.Trigger();
    const stream = this._invitationsService.queryInvitations(void 0, {
      timeout: import_chunk_P7Y3AD6I.RPC_TIMEOUT
    });
    stream.subscribe(({ action, type, invitations, existing }) => {
      switch (action) {
        case import_services2.QueryInvitationsResponse.Action.ADDED: {
          (0, import_log.log)("remote invitations added", {
            type,
            invitations
          }, {
            F: __dxlog_file,
            L: 105,
            S: this,
            C: (f, a) => f(...a)
          });
          invitations?.filter((invitation) => this._matchesInvitationContext(invitation)).filter((invitation) => !this._invitations.has(invitation.invitationId)).forEach((invitation) => {
            type === import_services2.QueryInvitationsResponse.Type.CREATED ? this.share(invitation) : this.join(invitation);
          });
          if (existing) {
            type === import_services2.QueryInvitationsResponse.Type.CREATED ? initialCreatedReceived.wake() : initialAcceptedReceived.wake();
          }
          break;
        }
        case import_services2.QueryInvitationsResponse.Action.REMOVED: {
          (0, import_log.log)("remote invitations removed", {
            type,
            invitations
          }, {
            F: __dxlog_file,
            L: 120,
            S: this,
            C: (f, a) => f(...a)
          });
          const cache = type === import_services2.QueryInvitationsResponse.Type.CREATED ? this._created : this._accepted;
          const cacheUpdate = type === import_services2.QueryInvitationsResponse.Type.CREATED ? this._createdUpdate : this._acceptedUpdate;
          invitations?.forEach((removed) => {
            const index = cache.get().findIndex((invitation) => invitation.get().invitationId === removed.invitationId);
            void cache.get()[index]?.cancel();
            index >= 0 && cacheUpdate.emit([
              ...cache.get().slice(0, index),
              ...cache.get().slice(index + 1)
            ]);
          });
          existing && initialAcceptedReceived.wake();
          break;
        }
        case import_services2.QueryInvitationsResponse.Action.LOAD_COMPLETE: {
          persistentLoaded.wake();
          break;
        }
        case import_services2.QueryInvitationsResponse.Action.SAVED: {
          (0, import_log.log)("remote invitations saved", {
            invitations
          }, {
            F: __dxlog_file,
            L: 141,
            S: this,
            C: (f, a) => f(...a)
          });
          this._savedUpdate.emit(invitations ?? []);
          break;
        }
      }
    });
    this._ctx.onDispose(() => stream.close());
    await persistentLoaded.wait();
    await initialAcceptedReceived.wait();
    await initialCreatedReceived.wait();
    this._opened = true;
    (0, import_log.log)("opened", this._getInvitationContext(), {
      F: __dxlog_file,
      L: 154,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  async close() {
    if (!this._opened) {
      return;
    }
    (0, import_log.log)("closing...", this._getInvitationContext(), {
      F: __dxlog_file,
      L: 162,
      S: this,
      C: (f, a) => f(...a)
    });
    await this._ctx.dispose();
    this._createdUpdate.emit([]);
    this._acceptedUpdate.emit([]);
    (0, import_log.log)("closed", this._getInvitationContext(), {
      F: __dxlog_file,
      L: 166,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  getInvitationOptions() {
    return {
      invitationId: import_keys.PublicKey.random().toHex(),
      type: import_services2.Invitation.Type.INTERACTIVE,
      authMethod: import_services2.Invitation.AuthMethod.SHARED_SECRET,
      state: import_services2.Invitation.State.INIT,
      swarmKey: import_keys.PublicKey.random(),
      ...this._getInvitationContext()
    };
  }
  // TODO(nf): Some way to retrieve observables for resumed invitations?
  share(options) {
    const invitation = {
      ...this.getInvitationOptions(),
      ...options
    };
    this._invitations.add(invitation.invitationId);
    const existing = this._created.get().find((created) => created.get().invitationId === invitation.invitationId);
    if (existing) {
      return existing;
    }
    const observable = new import_client_protocol2.CancellableInvitation({
      initialInvitation: invitation,
      subscriber: createObservable(this._invitationsService.createInvitation(invitation)),
      onCancel: async () => {
        const invitationId = observable.get().invitationId;
        (0, import_invariant.invariant)(invitationId, "Invitation missing identifier", {
          F: __dxlog_file,
          L: 195,
          S: this,
          A: [
            "invitationId",
            "'Invitation missing identifier'"
          ]
        });
        await this._invitationsService.cancelInvitation({
          invitationId
        });
      }
    });
    this._createdUpdate.emit([
      ...this._created.get(),
      observable
    ]);
    return observable;
  }
  join(invitation, deviceProfile) {
    if (typeof invitation === "string") {
      invitation = import_client_protocol2.InvitationEncoder.decode(invitation);
    }
    (0, import_invariant.invariant)(invitation && invitation.swarmKey, void 0, {
      F: __dxlog_file,
      L: 208,
      S: this,
      A: [
        "invitation && invitation.swarmKey",
        ""
      ]
    });
    this._invitations.add(invitation.invitationId);
    const id = invitation.invitationId;
    const existing = this._accepted.get().find((accepted) => accepted.get().invitationId === id);
    if (existing) {
      return existing;
    }
    const observable = new import_client_protocol2.AuthenticatingInvitation({
      initialInvitation: invitation,
      subscriber: createObservable(this._invitationsService.acceptInvitation({
        invitation,
        deviceProfile
      })),
      onCancel: async () => {
        const invitationId = observable.get().invitationId;
        (0, import_invariant.invariant)(invitationId, "Invitation missing identifier", {
          F: __dxlog_file,
          L: 222,
          S: this,
          A: [
            "invitationId",
            "'Invitation missing identifier'"
          ]
        });
        await this._invitationsService.cancelInvitation({
          invitationId
        });
      },
      onAuthenticate: async (authCode) => {
        const invitationId = observable.get().invitationId;
        (0, import_invariant.invariant)(invitationId, "Invitation missing identifier", {
          F: __dxlog_file,
          L: 227,
          S: this,
          A: [
            "invitationId",
            "'Invitation missing identifier'"
          ]
        });
        await this._invitationsService.authenticate({
          invitationId,
          authCode
        });
      }
    });
    this._acceptedUpdate.emit([
      ...this._accepted.get(),
      observable
    ]);
    return observable;
  }
  _matchesInvitationContext(invitation) {
    const context = this._getInvitationContext();
    (0, import_log.log)("checking invitation context", {
      invitation,
      context
    }, {
      F: __dxlog_file,
      L: 239,
      S: this,
      C: (f, a) => f(...a)
    });
    return Object.entries(context).reduce((acc, [key, value]) => {
      const invitationValue = invitation[key];
      if (invitationValue instanceof import_keys.PublicKey && value instanceof import_keys.PublicKey) {
        return acc && invitationValue.equals(value);
      } else {
        return acc && invitationValue === value;
      }
    }, true);
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AuthenticatingInvitation,
  CancellableInvitation,
  Invitation,
  InvitationEncoder,
  InvitationsProxy
});
//# sourceMappingURL=chunk-MOPAUFKF.cjs.map
