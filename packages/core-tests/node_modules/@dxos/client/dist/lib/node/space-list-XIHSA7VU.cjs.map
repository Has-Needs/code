{
  "version": 3,
  "sources": ["../../../src/echo/space-list.ts", "../../../src/echo/agent.ts"],
  "sourcesContent": ["//\n// Copyright 2021 DXOS.org\n//\n\nimport { inspect } from 'node:util';\n\nimport { Event, MulticastObservable, PushStream, scheduleMicroTask, Trigger } from '@dxos/async';\nimport {\n  CREATE_SPACE_TIMEOUT,\n  PropertiesType,\n  type ClientServicesProvider,\n  type Echo,\n  type Space,\n} from '@dxos/client-protocol';\nimport { type Config } from '@dxos/config';\nimport { Context } from '@dxos/context';\nimport { getCredentialAssertion } from '@dxos/credentials';\nimport { failUndefined, inspectObject } from '@dxos/debug';\nimport { Filter, Query, type EchoClient, type QueryOptions, type QueryFn } from '@dxos/echo-db';\nimport { failedInvariant, invariant } from '@dxos/invariant';\nimport { PublicKey, SpaceId } from '@dxos/keys';\nimport { live } from '@dxos/live-object';\nimport { log } from '@dxos/log';\nimport { ApiError, trace as Trace } from '@dxos/protocols';\nimport {\n  Invitation,\n  SpaceState,\n  type Space as SerializedSpace,\n  type SpaceArchive,\n} from '@dxos/protocols/proto/dxos/client/services';\nimport { type IndexConfig } from '@dxos/protocols/proto/dxos/echo/indexing';\nimport { type Credential } from '@dxos/protocols/proto/dxos/halo/credentials';\nimport { trace } from '@dxos/tracing';\n\nimport { AgentQuerySourceProvider } from './agent';\nimport { SpaceProxy } from './space-proxy';\nimport { RPC_TIMEOUT } from '../common';\nimport { type HaloProxy } from '../halo/halo-proxy';\nimport { InvitationsProxy } from '../invitations';\n\nconst ENABLE_AGENT_QUERY_SOURCE = false;\n\n@trace.resource()\nexport class SpaceList extends MulticastObservable<Space[]> implements Echo {\n  private _ctx!: Context;\n  private _invitationProxy?: InvitationsProxy;\n  private _defaultSpaceId?: SpaceId;\n  private readonly _defaultSpaceAvailable = new PushStream<boolean>();\n  private readonly _isReady = new MulticastObservable(this._defaultSpaceAvailable.observable, false);\n  private readonly _spacesStream: PushStream<Space[]>;\n  private readonly _spaceCreated = new Event<PublicKey>();\n  private readonly _instanceId = PublicKey.random().toHex();\n\n  @trace.info()\n  private get _isReadyState() {\n    return this._isReady.get();\n  }\n\n  constructor(\n    private readonly _config: Config | undefined,\n    private readonly _serviceProvider: ClientServicesProvider,\n    private readonly _echoClient: EchoClient,\n    private readonly _halo: HaloProxy,\n    /**\n     * @internal\n     */\n    readonly _traceParent?: string,\n  ) {\n    const spacesStream = new PushStream<Space[]>();\n    super(spacesStream.observable, []);\n    this._spacesStream = spacesStream;\n  }\n\n  [inspect.custom](): string {\n    return inspectObject(this);\n  }\n\n  get echoClient() {\n    return this._echoClient;\n  }\n\n  @trace.info({ depth: null })\n  toJSON(): { spaces: number | undefined } {\n    return {\n      spaces: this._value?.length,\n    };\n  }\n\n  /**\n   * @internal\n   */\n  @trace.span()\n  async _open(): Promise<void> {\n    log.trace('dxos.sdk.echo-proxy.open', Trace.begin({ id: this._instanceId, parentId: this._traceParent }));\n    this._ctx = new Context({\n      onError: (error) => {\n        log.catch(error);\n      },\n    });\n\n    const credentialsSubscription = this._halo.credentials.subscribe(() => {\n      if (this._updateAndOpenDefaultSpace()) {\n        credentialsSubscription.unsubscribe();\n      }\n    });\n    this._ctx.onDispose(() => credentialsSubscription.unsubscribe());\n\n    invariant(this._serviceProvider.services.SpacesService, 'SpacesService is not available.');\n    invariant(this._serviceProvider.services.InvitationsService, 'InvitationsService is not available.');\n    this._invitationProxy = new InvitationsProxy(\n      this._serviceProvider.services.InvitationsService,\n      this._serviceProvider.services.IdentityService,\n      () => ({\n        kind: Invitation.Kind.SPACE,\n      }),\n    );\n    await this._invitationProxy.open();\n\n    // Subscribe to spaces and create proxies.\n\n    const gotInitialUpdate = new Trigger();\n\n    const spacesStream = this._serviceProvider.services.SpacesService.querySpaces(undefined, { timeout: RPC_TIMEOUT });\n    spacesStream.subscribe((data) => {\n      let emitUpdate = false;\n      const newSpaces = this.get() as SpaceProxy[];\n\n      for (const space of data.spaces ?? []) {\n        if (this._ctx.disposed) {\n          return;\n        }\n\n        let spaceProxy = newSpaces.find(({ key }) => key.equals(space.spaceKey)) as SpaceProxy | undefined;\n        if (!spaceProxy) {\n          spaceProxy = new SpaceProxy(this._serviceProvider, space, this._echoClient);\n\n          if (this._shouldOpenSpace(space)) {\n            this._openSpaceAsync(spaceProxy);\n          }\n\n          // Propagate space state updates to the space list observable.\n          spaceProxy._stateUpdate.on(this._ctx, () => {\n            this._spacesStream.next([...this.get()]);\n          });\n\n          newSpaces.push(spaceProxy);\n          this._spaceCreated.emit(spaceProxy.key);\n\n          if (this._defaultSpaceId && spaceProxy.id === this._defaultSpaceId) {\n            this._defaultSpaceAvailable.next(true);\n          }\n\n          emitUpdate = true;\n        }\n\n        // Process space update in a separate task, also initializing the space if necessary.\n        scheduleMicroTask(this._ctx, async () => {\n          await spaceProxy!._processSpaceUpdate(space);\n        });\n      }\n\n      gotInitialUpdate.wake();\n      if (emitUpdate) {\n        this._spacesStream.next([...newSpaces]);\n      }\n    });\n    this._ctx.onDispose(() => spacesStream.close());\n\n    if (ENABLE_AGENT_QUERY_SOURCE) {\n      const subscription = this._isReady.subscribe(async (ready) => {\n        if (!ready) {\n          return;\n        }\n\n        const agentQuerySourceProvider = new AgentQuerySourceProvider(this.default);\n        await agentQuerySourceProvider.open();\n        this._echoClient.graph.registerQuerySourceProvider(agentQuerySourceProvider);\n        this._ctx.onDispose(() => agentQuerySourceProvider.close());\n        subscription.unsubscribe();\n      });\n      this._ctx.onDispose(() => subscription.unsubscribe());\n    }\n\n    // TODO(nf): implement/verify works\n    // TODO(nf): trigger automatically? feedback on how many were resumed?\n\n    await gotInitialUpdate.wait();\n    log.trace('dxos.sdk.echo-proxy.open', Trace.end({ id: this._instanceId }));\n  }\n\n  private _updateAndOpenDefaultSpace(): boolean {\n    const defaultSpaceCredential: Credential | undefined = this._halo.queryCredentials({\n      type: 'dxos.halo.credentials.DefaultSpace',\n    })[0];\n    const defaultSpaceAssertion = defaultSpaceCredential && getCredentialAssertion(defaultSpaceCredential);\n    if (defaultSpaceAssertion?.['@type'] !== 'dxos.halo.credentials.DefaultSpace') {\n      return false;\n    }\n    if (!SpaceId.isValid(defaultSpaceAssertion.spaceId)) {\n      return false;\n    }\n\n    this._defaultSpaceId = defaultSpaceAssertion.spaceId;\n    const defaultSpace = this._spaces.find((space) => space.id === defaultSpaceAssertion.spaceId);\n    log('defaultSpaceKey read from a credential', {\n      spaceExists: defaultSpace != null,\n      spaceOpen: defaultSpace?.isOpen,\n      spaceId: this._defaultSpaceId,\n    });\n\n    if (defaultSpace) {\n      if (defaultSpace.state.get() === SpaceState.SPACE_CLOSED) {\n        this._openSpaceAsync(defaultSpace);\n      }\n      this._defaultSpaceAvailable.next(true);\n    }\n\n    return true;\n  }\n\n  private _openSpaceAsync(spaceProxy: Space): void {\n    void spaceProxy.open().catch((err) => log.catch(err));\n  }\n\n  private _shouldOpenSpace(space: SerializedSpace): boolean {\n    if (this._ctx.disposed || space.state === SpaceState.SPACE_INACTIVE) {\n      return false;\n    }\n    if (!this._config?.values?.runtime?.client?.lazySpaceOpen) {\n      return true;\n    }\n    // Only open the default space if lazySpaceOpen is set.\n    return space.id === this._defaultSpaceId;\n  }\n\n  async setConfig(config: IndexConfig): Promise<void> {\n    await this._serviceProvider.services.QueryService?.setConfig(config, { timeout: 20_000 }); // TODO(dmaretskyi): Set global timeout instead.\n  }\n\n  /**\n   * @internal\n   */\n  @trace.span()\n  async _close(): Promise<void> {\n    await this._ctx.dispose();\n    await Promise.all(this.get().map((space) => (space as SpaceProxy)._destroy()));\n    this._spacesStream.next([]);\n    await this._invitationProxy?.close();\n    this._invitationProxy = undefined;\n    this._defaultSpaceAvailable.next(false);\n    this._defaultSpaceId = undefined;\n  }\n\n  get isReady() {\n    return this._isReady;\n  }\n\n  async waitUntilReady(): Promise<void> {\n    return new Promise((resolve) => {\n      const subscription = this._isReady.subscribe((isReady) => {\n        if (isReady) {\n          subscription.unsubscribe();\n          resolve();\n        }\n      });\n    });\n  }\n\n  override get(): Space[];\n  override get(spaceIdOrKey: SpaceId | PublicKey): Space | undefined;\n  override get(spaceIdOrKey?: SpaceId | PublicKey): Space | Space[] | undefined {\n    if (!spaceIdOrKey) {\n      return this._value;\n    }\n\n    if (spaceIdOrKey instanceof PublicKey) {\n      return this._value?.find(({ key }) => key.equals(spaceIdOrKey));\n    } else {\n      if (!SpaceId.isValid(spaceIdOrKey)) {\n        throw new ApiError('Invalid space id.');\n      }\n\n      return this._value?.find(({ id }) => id === spaceIdOrKey);\n    }\n  }\n\n  @trace.info()\n  private get _spaces() {\n    return this.get();\n  }\n\n  get default(): Space {\n    invariant(this._defaultSpaceId, 'Default space ID not set.');\n    const space = this.get().find((space) => space.id === this._defaultSpaceId);\n    invariant(space, 'Default space is not yet available. Use `client.spaces.isReady` to wait for the default space.');\n    return space;\n  }\n\n  async create(meta?: PropertiesType): Promise<Space> {\n    invariant(this._serviceProvider.services.SpacesService, 'SpacesService is not available.');\n    const traceId = PublicKey.random().toHex();\n    log.trace('dxos.sdk.echo-proxy.create-space', Trace.begin({ id: traceId }));\n    const space = await this._serviceProvider.services.SpacesService.createSpace(undefined, { timeout: RPC_TIMEOUT });\n\n    await this._spaceCreated.waitForCondition(() => {\n      return this.get().some(({ key }) => key.equals(space.spaceKey));\n    });\n    const spaceProxy = this._findProxy(space);\n\n    await spaceProxy._databaseInitialized.wait({ timeout: CREATE_SPACE_TIMEOUT });\n    spaceProxy.db.add(live(PropertiesType, meta ?? {}), { placeIn: 'root-doc' });\n    await spaceProxy.db.flush();\n    await spaceProxy._initializationComplete.wait();\n\n    log.trace('dxos.sdk.echo-proxy.create-space', Trace.end({ id: traceId }));\n    return spaceProxy;\n  }\n\n  /**\n   * @internal\n   */\n  async import(archive: SpaceArchive): Promise<Space> {\n    invariant(this._serviceProvider.services.SpacesService, 'SpaceService is not available.');\n    const { newSpaceId } = await this._serviceProvider.services.SpacesService.importSpace(\n      { archive },\n      { timeout: CREATE_SPACE_TIMEOUT },\n    );\n    invariant(SpaceId.isValid(newSpaceId), 'Invalid space ID');\n    await this._spaceCreated.waitForCondition(() => {\n      return this.get().some((space) => space.id === newSpaceId);\n    });\n\n    const spaceProxy = this.get(newSpaceId) ?? failedInvariant();\n    await spaceProxy.waitUntilReady();\n    return spaceProxy;\n  }\n\n  join(invitation: Invitation | string) {\n    if (!this._invitationProxy) {\n      throw new ApiError('Client not open.');\n    }\n\n    log('accept invitation', invitation);\n    return this._invitationProxy.join(invitation);\n  }\n\n  async joinBySpaceKey(spaceKey: PublicKey): Promise<Space> {\n    const response = await this._serviceProvider.services.SpacesService!.joinBySpaceKey({ spaceKey });\n    return this._findProxy(response.space);\n  }\n\n  // Odd way to define methods types from a typedef.\n  /**\n   * Query all spaces.\n   */\n  declare query: QueryFn;\n  static {\n    this.prototype.query = this.prototype._query;\n  }\n\n  private _query(query: Query.Any | Filter.Any, options?: QueryOptions) {\n    query = Filter.is(query) ? Query.select(query) : query;\n    return this._echoClient.graph.query(query, options);\n  }\n\n  private _findProxy(space: SerializedSpace): SpaceProxy {\n    return (this.get().find(({ key }) => key.equals(space.spaceKey)) as SpaceProxy) ?? failUndefined();\n  }\n}\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { Event } from '@dxos/async';\nimport { type Space } from '@dxos/client-protocol';\nimport { todo } from '@dxos/debug';\nimport { type AnyLiveObject, type QueryResultEntry, type QuerySource, type QuerySourceProvider } from '@dxos/echo-db';\nimport type { QueryAST } from '@dxos/echo-protocol';\nimport { invariant } from '@dxos/invariant';\nimport { PublicKey, type SpaceId } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { QUERY_CHANNEL } from '@dxos/protocols';\nimport { type EchoObject as EchoObjectProto } from '@dxos/protocols/proto/dxos/echo/object';\nimport { QueryReactivity, type QueryRequest, type QueryResponse } from '@dxos/protocols/proto/dxos/echo/query';\nimport { type GossipMessage } from '@dxos/protocols/proto/dxos/mesh/teleport/gossip';\n\nconst ERR_CLOSING = new Error();\n\nexport class AgentQuerySourceProvider implements QuerySourceProvider {\n  private readonly _responsePromises = new Map<\n    string,\n    { resolve: (response: QueryResponse) => void; reject: (error: Error) => void }\n  >();\n\n  private _unsubscribe?: () => void = undefined;\n\n  /**\n   * Constructor.\n   * @param _space Space instance that will be used for messaging with the agent through the gossip protocol.\n   */\n  constructor(private readonly _space: Space) {}\n\n  async open(): Promise<void> {\n    this._unsubscribe = this._space.listen(QUERY_CHANNEL, (message) => this._handleMessage(message));\n  }\n\n  async close(): Promise<void> {\n    this._unsubscribe?.();\n    this._responsePromises.forEach((promise) => promise.reject(ERR_CLOSING));\n    this._responsePromises.clear();\n  }\n\n  // TODO(burdon): Make async?\n  // TODO(burdon): Define return type.\n  private _sendRequest(query: QueryAST.Query): { response: Promise<QueryResponse>; cancelRequest: () => void } {\n    const request: QueryRequest = {\n      queryId: PublicKey.random().toHex(),\n      query: JSON.stringify(query),\n      reactivity: QueryReactivity.ONE_SHOT,\n    };\n    this._space\n      .postMessage(QUERY_CHANNEL, {\n        '@type': 'dxos.agent.query.QueryRequest',\n        ...request,\n      })\n      .catch((error) => log.catch(error));\n\n    let cancelRequest: () => void;\n    return {\n      response: new Promise<QueryResponse>((resolve, reject) => {\n        invariant(request.queryId);\n        this._responsePromises.set(request.queryId, { resolve, reject });\n        cancelRequest = () => {\n          reject(new Error('Request cancelled.'));\n          this._responsePromises.delete(request.queryId!);\n        };\n      }),\n      cancelRequest: () => {\n        cancelRequest();\n      },\n    };\n  }\n\n  private _handleMessage(message: GossipMessage): void {\n    if (message.payload['@type'] !== 'dxos.agent.query.QueryResponse') {\n      return;\n    }\n\n    const response = message.payload as QueryResponse;\n    invariant(response.queryId, 'QueryId is undefined.');\n    const responsePromise = this._responsePromises.get(response.queryId);\n    if (!responsePromise) {\n      log('Request for this response was canceled.', { response });\n      return;\n    }\n\n    responsePromise.resolve(response);\n    this._responsePromises.delete(response.queryId);\n  }\n\n  create(): AgentQuerySource {\n    return new AgentQuerySource({ sendRequest: this._sendRequest.bind(this) });\n  }\n}\n\nexport class AgentQuerySource implements QuerySource {\n  private _results?: QueryResultEntry[];\n  private _cancelPreviousRequest?: () => void = undefined;\n\n  public readonly changed = new Event<void>();\n\n  constructor(\n    private readonly _params: {\n      sendRequest: (query: QueryAST.Query) => { response: Promise<QueryResponse>; cancelRequest: () => void };\n    },\n  ) {}\n\n  open(): void {\n    // No-op.\n  }\n\n  close(): void {\n    // No-op.\n  }\n\n  getResults(): QueryResultEntry[] {\n    return this._results ?? [];\n  }\n\n  async run(): Promise<QueryResultEntry[]> {\n    return this._results ?? [];\n  }\n\n  update(query: QueryAST.Query): void {\n    // if (query.options.dataLocation === undefined || query.options.dataLocation === QueryOptions.DataLocation.LOCAL) {\n    //   // Disabled by dataLocation filter.\n    //   return;\n    // }\n\n    this._results = undefined;\n    this.changed.emit();\n\n    if (this._cancelPreviousRequest) {\n      this._cancelPreviousRequest();\n    }\n\n    // TODO(burdon): Make async.\n    const startTime = Date.now();\n    const { response, cancelRequest } = this._params.sendRequest(query);\n    this._cancelPreviousRequest = cancelRequest;\n    response\n      .then((response) => {\n        this._results =\n          response.results?.map((result) => {\n            const objSnapshot = response.objects?.find((obj) => obj.objectId === result.id);\n            return {\n              id: result.id,\n              spaceKey: result.spaceKey!,\n              spaceId: result.spaceId as SpaceId,\n              object: objSnapshot && getEchoObjectFromSnapshot(objSnapshot),\n              match: {\n                rank: result.rank,\n              },\n              resolution: {\n                source: 'remote',\n                time: Date.now() - startTime,\n              },\n            };\n          }) ?? [];\n\n        this.changed.emit();\n      })\n      .catch((error) => error === ERR_CLOSING || log.catch(error));\n  }\n}\n\nconst getEchoObjectFromSnapshot = (objSnapshot: EchoObjectProto): AnyLiveObject<any> | undefined => {\n  invariant(objSnapshot.genesis, 'Genesis is undefined.');\n  invariant(objSnapshot.snapshot, 'Genesis model type is undefined.');\n\n  return todo();\n\n  // if (objSnapshot.genesis.modelType === DocumentModel.meta.type) {\n  //   const modelSnapshot: ObjectSnapshot = DocumentModel.meta.snapshotCodec!.decode(objSnapshot.snapshot.model.value);\n  //   const obj = new TypedObject(undefined, {\n  //     type: modelSnapshot.typeRef && Reference.fromValue(modelSnapshot.typeRef),\n  //     immutable: true,\n  //   });\n  //   setStateFromSnapshot(obj, modelSnapshot);\n  //   return obj;\n  // } else if (objSnapshot.genesis.modelType === TextModel.meta.type) {\n  //   return new TextObject();\n  // } else {\n  //   log.warn('Unknown model type', { type: objSnapshot.genesis.modelType });\n  //   return undefined;\n  // }\n};\n"],
  "mappings": "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",
  "names": ["import_async", "import_debug", "import_invariant", "import_keys", "import_log", "import_protocols", "ERR_CLOSING", "Error", "AgentQuerySourceProvider", "_space", "_responsePromises", "Map", "_unsubscribe", "undefined", "open", "listen", "QUERY_CHANNEL", "message", "_handleMessage", "close", "forEach", "promise", "reject", "clear", "_sendRequest", "query", "request", "queryId", "PublicKey", "random", "toHex", "JSON", "stringify", "reactivity", "QueryReactivity", "ONE_SHOT", "postMessage", "catch", "error", "log", "cancelRequest", "response", "Promise", "resolve", "invariant", "set", "delete", "payload", "responsePromise", "get", "create", "AgentQuerySource", "sendRequest", "bind", "_params", "_cancelPreviousRequest", "changed", "Event", "getResults", "_results", "run", "update", "emit", "startTime", "Date", "now", "then", "results", "map", "result", "objSnapshot", "objects", "find", "obj", "objectId", "id", "spaceKey", "spaceId", "object", "getEchoObjectFromSnapshot", "match", "rank", "resolution", "source", "time", "genesis", "snapshot", "todo", "ENABLE_AGENT_QUERY_SOURCE", "SpaceList", "MulticastObservable", "_isReadyState", "_isReady", "_config", "_serviceProvider", "_echoClient", "_halo", "_traceParent", "spacesStream", "PushStream", "observable", "_defaultSpaceAvailable", "_spaceCreated", "_instanceId", "_spacesStream", "inspect", "custom", "inspectObject", "echoClient", "toJSON", "spaces", "_value", "length", "_open", "trace", "Trace", "begin", "parentId", "_ctx", "Context", "onError", "credentialsSubscription", "credentials", "subscribe", "_updateAndOpenDefaultSpace", "unsubscribe", "onDispose", "services", "SpacesService", "InvitationsService", "_invitationProxy", "InvitationsProxy", "IdentityService", "kind", "Invitation", "Kind", "SPACE", "gotInitialUpdate", "Trigger", "querySpaces", "timeout", "RPC_TIMEOUT", "data", "emitUpdate", "newSpaces", "space", "disposed", "spaceProxy", "key", "equals", "SpaceProxy", "_shouldOpenSpace", "_openSpaceAsync", "_stateUpdate", "on", "next", "push", "_defaultSpaceId", "scheduleMicroTask", "_processSpaceUpdate", "wake", "subscription", "ready", "agentQuerySourceProvider", "default", "graph", "registerQuerySourceProvider", "wait", "end", "defaultSpaceCredential", "queryCredentials", "type", "defaultSpaceAssertion", "getCredentialAssertion", "SpaceId", "isValid", "defaultSpace", "_spaces", "spaceExists", "spaceOpen", "isOpen", "state", "SpaceState", "SPACE_CLOSED", "err", "SPACE_INACTIVE", "values", "runtime", "client", "lazySpaceOpen", "setConfig", "config", "QueryService", "_close", "dispose", "all", "_destroy", "isReady", "waitUntilReady", "spaceIdOrKey", "ApiError", "meta", "traceId", "createSpace", "waitForCondition", "some", "_findProxy", "_databaseInitialized", "CREATE_SPACE_TIMEOUT", "db", "add", "live", "PropertiesType", "placeIn", "flush", "_initializationComplete", "import", "archive", "newSpaceId", "importSpace", "failedInvariant", "join", "invitation", "joinBySpaceKey", "prototype", "_query", "options", "Filter", "is", "Query", "select", "failUndefined", "info", "depth", "span", "resource"]
}
