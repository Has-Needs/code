"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var testing_exports = {};
__export(testing_exports, {
  BlockType: () => BlockType,
  ContactType: () => ContactType,
  DocumentType: () => DocumentType,
  MessageType: () => MessageType,
  TestBuilder: () => TestBuilder,
  TextV0Type: () => TextV0Type,
  ThreadType: () => ThreadType,
  createInitializedClientsWithContext: () => createInitializedClientsWithContext,
  joinCommonSpace: () => joinCommonSpace,
  performInvitation: () => import_testing.performInvitation,
  syncItemsAutomerge: () => syncItemsAutomerge,
  testConfigWithLocalSignal: () => testConfigWithLocalSignal,
  testSpaceAutomerge: () => testSpaceAutomerge,
  waitForSpace: () => waitForSpace
});
module.exports = __toCommonJS(testing_exports);
var import_chunk_DTV5D7HV = require("../chunk-DTV5D7HV.cjs");
var import_chunk_GXHU364O = require("../chunk-GXHU364O.cjs");
var import_chunk_MVOI3MV3 = require("../chunk-MVOI3MV3.cjs");
var import_chunk_P7Y3AD6I = require("../chunk-P7Y3AD6I.cjs");
var import_testing = require("@dxos/client-services/testing");
var import_effect = require("effect");
var import_echo_schema = require("@dxos/echo-schema");
var import_async = require("@dxos/async");
var import_client_services = require("@dxos/client-services");
var import_config = require("@dxos/config");
var import_context = require("@dxos/context");
var import_debug = require("@dxos/debug");
var import_echo = require("@dxos/echo");
var import_echo_schema2 = require("@dxos/echo-schema");
var import_invariant = require("@dxos/invariant");
var import_live_object = require("@dxos/live-object");
var import_log = require("@dxos/log");
var import_messaging = require("@dxos/messaging");
var import_network_manager = require("@dxos/network-manager");
var import_tcp = require("@dxos/network-manager/transport/tcp");
var import_services = require("@dxos/protocols/proto/dxos/client/services");
var import_rpc = require("@dxos/rpc");
var import_async2 = require("@dxos/async");
var import_testing2 = require("@dxos/kv-store/testing");
var import_random_access_storage = require("@dxos/random-access-storage");
var import_util = require("@dxos/util");
var TextV0Type = class extends (0, import_echo_schema.TypedObject)({
  typename: "dxos.org/TextV0",
  version: "0.1.0"
})({
  content: import_effect.Schema.String
}) {
};
var DocumentType = class extends (0, import_echo_schema.TypedObject)({
  typename: "braneframe.com/Document",
  version: "0.1.0"
})({
  title: import_effect.Schema.optional(import_effect.Schema.String),
  content: (0, import_echo_schema.Ref)(TextV0Type)
}) {
};
var ContactType = class extends (0, import_echo_schema.TypedObject)({
  typename: "braneframe.com/Contact",
  version: "0.1.0"
})({
  name: import_effect.Schema.optional(import_effect.Schema.String),
  identifiers: import_effect.Schema.mutable(import_effect.Schema.Array(import_effect.Schema.Struct({
    type: import_effect.Schema.String,
    value: import_effect.Schema.String
  })))
}) {
};
var BlockSchema = import_effect.Schema.Struct({
  timestamp: import_effect.Schema.String,
  content: import_effect.Schema.optional((0, import_echo_schema.Ref)(TextV0Type)),
  object: import_effect.Schema.optional((0, import_echo_schema.Ref)(import_echo_schema.Expando))
});
var BlockType = BlockSchema;
var MessageType = class extends (0, import_echo_schema.TypedObject)({
  typename: "braneframe.com/Message",
  version: "0.1.0"
})({
  type: import_effect.Schema.optional(import_effect.Schema.String),
  date: import_effect.Schema.optional(import_effect.Schema.String),
  subject: import_effect.Schema.optional(import_effect.Schema.String),
  blocks: import_effect.Schema.mutable(import_effect.Schema.Array(BlockSchema)),
  links: import_effect.Schema.optional(import_effect.Schema.Array((0, import_echo_schema.Ref)(import_echo_schema.Expando))),
  read: import_effect.Schema.optional(import_effect.Schema.Boolean),
  context: import_effect.Schema.optional(import_effect.Schema.Struct({
    space: import_effect.Schema.optional(import_effect.Schema.String),
    schema: import_effect.Schema.optional(import_effect.Schema.String),
    object: import_effect.Schema.optional(import_effect.Schema.String)
  }))
}) {
};
var ThreadType = class extends (0, import_echo_schema.TypedObject)({
  typename: "braneframe.com/Thread",
  version: "0.1.0"
})({
  title: import_effect.Schema.optional(import_effect.Schema.String),
  messages: import_effect.Schema.mutable(import_effect.Schema.Array((0, import_echo_schema.Ref)(MessageType))),
  context: import_effect.Schema.optional(import_effect.Schema.Struct({
    space: import_effect.Schema.optional(import_effect.Schema.String),
    schema: import_effect.Schema.optional(import_effect.Schema.String),
    object: import_effect.Schema.optional(import_effect.Schema.String)
  }))
}) {
};
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/sdk/client/src/testing/test-builder.ts";
var testConfigWithLocalSignal = new import_config.Config({
  version: 1,
  runtime: {
    services: {
      signaling: [
        {
          // TODO(burdon): Port numbers and global consts?
          server: `ws://localhost:${process.env.SIGNAL_PORT ?? 4e3}/.well-known/dx/signal`
        }
      ]
    }
  }
});
var TestBuilder = class {
  // TODO(burdon): Pass in params as object.
  constructor(config, signalManagerContext = new import_messaging.MemorySignalManagerContext(), transport = import_network_manager.TransportKind.WEB_RTC) {
    this.signalManagerContext = signalManagerContext;
    this._ctx = new import_context.Context({
      name: "TestBuilder"
    }, {
      F: __dxlog_file,
      L: 57
    });
    this.config = config ?? new import_config.Config();
    this._transport = transport;
  }
  get ctx() {
    return this._ctx;
  }
  async destroy() {
    await this._ctx.dispose(false);
  }
  /**
  * Create backend service handlers.
  */
  createClientServicesHost(runtimeParams) {
    const services = new import_client_services.ClientServicesHost({
      config: this.config,
      storage: this?.storage?.(),
      level: this?.level?.(),
      runtimeParams,
      ...this.networking
    });
    this._ctx.onDispose(() => services.close());
    return services;
  }
  /**
  * Create local services host.
  * @param options - fastPeerPresenceUpdate: enable for faster space-member online/offline status changes.
  */
  createLocalClientServices(options) {
    const services = new import_chunk_GXHU364O.LocalClientServices({
      config: this.config,
      storage: this?.storage?.(),
      level: this?.level?.(),
      runtimeParams: {
        ...options?.fastPeerPresenceUpdate ? {
          spaceMemberPresenceAnnounceInterval: 200,
          spaceMemberPresenceOfflineTimeout: 400
        } : {},
        invitationConnectionDefaultParams: {
          teleport: {
            controlHeartbeatInterval: 200
          }
        }
      },
      ...this.networking
    });
    this._ctx.onDispose(() => services.close());
    return services;
  }
  /**
  * Create client/server.
  */
  createClientServer(host = this.createClientServicesHost()) {
    const [proxyPort, hostPort] = (0, import_rpc.createLinkedPorts)();
    const client = new import_chunk_DTV5D7HV.Client({
      config: this.config,
      services: new import_chunk_GXHU364O.ClientServicesProxy(proxyPort)
    });
    const server = (0, import_rpc.createProtoRpcPeer)({
      exposed: host.descriptors,
      handlers: host.services,
      port: hostPort
    });
    this._ctx.onDispose(() => server.close());
    this._ctx.onDispose(() => client.destroy());
    return [
      client,
      server
    ];
  }
  /**
  * Get network manager using local shared memory or remote signal manager.
  */
  get networking() {
    const signals = this.config.get("runtime.services.signaling");
    if (signals) {
      import_log.log.info(`using transport ${this._transport}`, void 0, {
        F: __dxlog_file,
        L: 145,
        S: this,
        C: (f, a) => f(...a)
      });
      let transportFactory;
      switch (this._transport) {
        case import_network_manager.TransportKind.WEB_RTC:
          transportFactory = (0, import_network_manager.createRtcTransportFactory)({
            iceServers: this.config.get("runtime.services.ice")
          }, this.config.get("runtime.services.iceProviders") && (0, import_network_manager.createIceProvider)(this.config.get("runtime.services.iceProviders")));
          break;
        case import_network_manager.TransportKind.TCP:
          transportFactory = import_tcp.TcpTransportFactory;
          break;
        default:
          throw new Error(`Unsupported transport w/ signalling: ${this._transport}`);
      }
      return {
        signalManager: new import_messaging.WebsocketSignalManager(signals),
        transportFactory
      };
    }
    return {
      signalManager: new import_messaging.MemorySignalManager(this.signalManagerContext),
      transportFactory: import_network_manager.MemoryTransportFactory
    };
  }
};
var testSpaceAutomerge = async (expect, createDb, checkDb = createDb) => {
  const object = (0, import_live_object.live)(import_echo_schema2.Expando, {});
  createDb.add(object);
  await expect.poll(() => checkDb.query(import_echo.Filter.ids(object.id)).first({
    timeout: 1e3
  }));
  return {
    objectId: object.id
  };
};
var syncItemsAutomerge = async (expect, db1, db2) => {
  await testSpaceAutomerge(expect, db1, db2);
  await testSpaceAutomerge(expect, db2, db1);
};
var joinCommonSpace = async ([initialPeer, ...peers], spaceKey) => {
  const rootSpace = spaceKey ? initialPeer.spaces.get(spaceKey) : await initialPeer.spaces.create();
  (0, import_invariant.invariant)(rootSpace, "Space not found.", {
    F: __dxlog_file,
    L: 203,
    S: void 0,
    A: [
      "rootSpace",
      "'Space not found.'"
    ]
  });
  await Promise.all(peers.map(async (peer) => {
    const hostDone = new import_async.Trigger();
    const guestDone = new import_async.Trigger();
    const hostObservable = rootSpace.share({
      authMethod: import_services.Invitation.AuthMethod.NONE
    });
    (0, import_log.log)("invitation created", void 0, {
      F: __dxlog_file,
      L: 211,
      S: void 0,
      C: (f, a) => f(...a)
    });
    hostObservable.subscribe((hostInvitation) => {
      switch (hostInvitation.state) {
        case import_services.Invitation.State.CONNECTING: {
          const guestObservable = peer.spaces.join(hostInvitation);
          (0, import_log.log)("invitation accepted", void 0, {
            F: __dxlog_file,
            L: 217,
            S: void 0,
            C: (f, a) => f(...a)
          });
          guestObservable.subscribe((guestInvitation) => {
            switch (guestInvitation.state) {
              case import_services.Invitation.State.SUCCESS: {
                guestDone.wake(guestInvitation);
                (0, import_log.log)("invitation guestDone", void 0, {
                  F: __dxlog_file,
                  L: 224,
                  S: void 0,
                  C: (f, a) => f(...a)
                });
                break;
              }
            }
          }, (err) => (0, import_debug.raise)(err));
          break;
        }
        case import_services.Invitation.State.SUCCESS: {
          hostDone.wake(hostInvitation);
          (0, import_log.log)("invitation hostDone", void 0, {
            F: __dxlog_file,
            L: 236,
            S: void 0,
            C: (f, a) => f(...a)
          });
        }
      }
    }, (err) => (0, import_debug.raise)(err));
    await Promise.all([
      hostDone.wait(),
      guestDone.wait()
    ]);
  }));
  return rootSpace.key;
};
var waitForSpace = async (client, spaceKey, { timeout = 500, ready } = {}) => {
  let space = client.spaces.get(spaceKey);
  if (!space) {
    const spaceTrigger = new import_async2.Trigger();
    const sub = client.spaces.subscribe(() => {
      const space2 = client.spaces.get(spaceKey);
      if (space2) {
        sub.unsubscribe();
        spaceTrigger.wake(space2);
      }
    });
    space = await spaceTrigger.wait({
      timeout
    });
  }
  if (ready) {
    await space.waitUntilReady();
  }
  return space;
};
var createInitializedClientsWithContext = async (ctx, count, options) => {
  const testBuilder = new TestBuilder(options?.config);
  testBuilder.storage = options?.storage ? () => (0, import_random_access_storage.createStorage)({
    type: import_random_access_storage.StorageType.RAM,
    root: String(Math.random())
  }) : void 0;
  testBuilder.level = options?.storage ? () => (0, import_testing2.createTestLevel)() : void 0;
  const clients = (0, import_util.range)(count, () => new import_chunk_DTV5D7HV.Client({
    config: options?.config,
    services: testBuilder.createLocalClientServices(options?.serviceConfig)
  }));
  const initialized = await Promise.all(clients.map(async (client, index) => {
    await client.initialize();
    await client.halo.createIdentity({
      displayName: `Peer ${index}`
    });
    return client;
  }));
  ctx.onDispose(() => Promise.all(initialized.map((c) => c.destroy())));
  return initialized;
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  BlockType,
  ContactType,
  DocumentType,
  MessageType,
  TestBuilder,
  TextV0Type,
  ThreadType,
  createInitializedClientsWithContext,
  joinCommonSpace,
  performInvitation,
  syncItemsAutomerge,
  testConfigWithLocalSignal,
  testSpaceAutomerge,
  waitForSpace
});
//# sourceMappingURL=index.cjs.map
