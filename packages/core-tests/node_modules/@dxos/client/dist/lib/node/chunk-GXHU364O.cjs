"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var chunk_GXHU364O_exports = {};
__export(chunk_GXHU364O_exports, {
  AgentClientServiceProvider: () => AgentClientServiceProvider,
  AgentManagerClient: () => AgentManagerClient,
  ClientServicesProxy: () => ClientServicesProxy,
  FakeAgentHostingProvider: () => FakeAgentHostingProvider,
  IFrameManager: () => IFrameManager,
  LocalClientServices: () => LocalClientServices,
  SharedWorkerConnection: () => SharedWorkerConnection,
  Shell: () => Shell,
  ShellManager: () => ShellManager,
  WorkerClientServices: () => WorkerClientServices,
  createClientServices: () => createClientServices,
  fromAgent: () => fromAgent,
  fromHost: () => fromHost,
  fromSocket: () => fromSocket,
  fromWorker: () => fromWorker,
  getUnixSocket: () => getUnixSocket
});
module.exports = __toCommonJS(chunk_GXHU364O_exports);
var import_chunk_MVOI3MV3 = require("./chunk-MVOI3MV3.cjs");
var import_chunk_P7Y3AD6I = require("./chunk-P7Y3AD6I.cjs");
var import_async = require("@dxos/async");
var import_client_protocol = require("@dxos/client-protocol");
var import_client_protocol2 = require("@dxos/client-protocol");
var import_log = require("@dxos/log");
var import_tracing = require("@dxos/tracing");
var import_ua_parser_js = require("ua-parser-js");
var import_async2 = require("@dxos/async");
var import_client_protocol3 = require("@dxos/client-protocol");
var import_config = require("@dxos/config");
var import_context = require("@dxos/context");
var import_log2 = require("@dxos/log");
var import_network_manager = require("@dxos/network-manager");
var import_tracing2 = require("@dxos/tracing");
var import_async3 = require("@dxos/async");
var import_client_protocol4 = require("@dxos/client-protocol");
var import_log3 = require("@dxos/log");
var import_protocols = require("@dxos/protocols");
var import_async4 = require("@dxos/async");
var import_client_protocol5 = require("@dxos/client-protocol");
var import_config2 = require("@dxos/config");
var import_log4 = require("@dxos/log");
var import_services = require("@dxos/protocols/proto/dxos/client/services");
var import_rpc_tunnel = require("@dxos/rpc-tunnel");
var import_tracing3 = require("@dxos/tracing");
var import_async5 = require("@dxos/async");
var import_client_protocol6 = require("@dxos/client-protocol");
var import_invariant = require("@dxos/invariant");
var import_protocols2 = require("@dxos/protocols");
var import_rpc = require("@dxos/rpc");
var import_tracing4 = require("@dxos/tracing");
var import_async6 = require("@dxos/async");
var import_client_protocol7 = require("@dxos/client-protocol");
var import_log5 = require("@dxos/log");
var import_network_manager2 = require("@dxos/network-manager");
var import_protocols3 = require("@dxos/protocols");
var import_rpc2 = require("@dxos/rpc");
var import_util = require("@dxos/util");
var import_keys = require("@dxos/keys");
var import_rpc_tunnel2 = require("@dxos/rpc-tunnel");
var import_iframe = require("@dxos/protocols/proto/dxos/iframe");
var import_util2 = require("@dxos/util");
var import_async7 = require("@dxos/async");
var import_client_protocol8 = require("@dxos/client-protocol");
var import_invariant2 = require("@dxos/invariant");
var import_log6 = require("@dxos/log");
var import_iframe2 = require("@dxos/protocols/proto/dxos/iframe");
var import_rpc3 = require("@dxos/rpc");
var import_rpc_tunnel3 = require("@dxos/rpc-tunnel");
var import_jwt_decode = require("jwt-decode");
var import_async8 = require("@dxos/async");
var import_invariant3 = require("@dxos/invariant");
var import_keys2 = require("@dxos/keys");
var import_log7 = require("@dxos/log");
var import_proto = require("@dxos/protocols/proto");
var import_agentmanager = require("@dxos/protocols/proto/dxos/service/agentmanager");
var import_async9 = require("@dxos/async");
function _ts_decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/sdk/client/src/services/agent.ts";
var getUnixSocket = (profile, protocol = "unix") => `${protocol}://` + (0, import_client_protocol.getProfilePath)(import_client_protocol.DX_RUNTIME, profile, "agent.sock");
var fromAgent = ({ profile = process.env[import_client_protocol.ENV_DX_PROFILE] ?? import_client_protocol.ENV_DX_PROFILE_DEFAULT } = {}) => {
  return new AgentClientServiceProvider(profile);
};
var AgentClientServiceProvider = class {
  constructor(_profile) {
    this._profile = _profile;
    this.closed = new import_async.Event();
  }
  get descriptors() {
    return import_client_protocol.clientServiceBundle;
  }
  get services() {
    return this._client.rpc;
  }
  async open() {
    const { WebsocketRpcClient } = await import("@dxos/websocket-rpc");
    this._client = new WebsocketRpcClient({
      url: getUnixSocket(this._profile, "ws+unix"),
      requested: import_client_protocol.clientServiceBundle,
      exposed: {},
      handlers: {}
    });
    this._client.error.on((error) => {
      this.closed.emit(error);
    });
    await this._client.open();
  }
  async close() {
    try {
      await this._client?.close();
    } catch (err) {
      import_log.log.warn("Failed to close", err, {
        F: __dxlog_file,
        L: 72,
        S: this,
        C: (f, a) => f(...a)
      });
    }
  }
};
AgentClientServiceProvider = _ts_decorate([
  import_tracing.trace.resource({
    annotation: import_client_protocol2.ClientServicesProviderResource
  })
], AgentClientServiceProvider);
function _ts_decorate2(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file2 = "/home/runner/work/dxos/dxos/packages/sdk/client/src/services/local-client-services.ts";
var fromHost = async (config = new import_config.Config(), params, observabilityGroup, signalTelemetryEnabled) => {
  const networking = await setupNetworking(config, {}, () => signalTelemetryEnabled ? {
    ...services.signalMetadataTags,
    ...observabilityGroup ? {
      group: observabilityGroup
    } : {}
  } : {});
  const services = new LocalClientServices({
    config,
    ...networking,
    ...params
  });
  return services;
};
var setupNetworking = async (config, options = {}, signalMetadata) => {
  const { MemorySignalManager, MemorySignalManagerContext, WebsocketSignalManager } = await import("@dxos/messaging");
  const { createRtcTransportFactory, MemoryTransportFactory } = await import("@dxos/network-manager");
  const signals = config.get("runtime.services.signaling");
  const edgeFeatures = config.get("runtime.client.edgeFeatures");
  if (signals || edgeFeatures?.signaling) {
    const { signalManager: signalManager2 = edgeFeatures?.signaling || !signals ? void 0 : new WebsocketSignalManager(signals, signalMetadata), transportFactory: transportFactory2 = createRtcTransportFactory({
      iceServers: config.get("runtime.services.ice")
    }, config.get("runtime.services.iceProviders") && (0, import_network_manager.createIceProvider)(config.get("runtime.services.iceProviders"))) } = options;
    return {
      signalManager: signalManager2,
      transportFactory: transportFactory2
    };
  }
  (0, import_log2.log)("P2P network is not configured.", void 0, {
    F: __dxlog_file2,
    L: 80,
    S: void 0,
    C: (f, a) => f(...a)
  });
  const signalManager = new MemorySignalManager(new MemorySignalManagerContext());
  const transportFactory = MemoryTransportFactory;
  return {
    signalManager,
    transportFactory
  };
};
var LocalClientServices = class {
  constructor(params) {
    this.closed = new import_async2.Event();
    this._ctx = new import_context.Context(void 0, {
      F: __dxlog_file2,
      L: 95
    });
    this.signalMetadataTags = {
      runtime: "local-client-services"
    };
    this._isOpen = false;
    this._params = params;
    if (typeof window === "undefined" || typeof window.location === "undefined") {
      this.signalMetadataTags.origin = "undefined";
    } else {
      if (globalThis.__args) {
        this.signalMetadataTags.runtime = "native";
        this.signalMetadataTags.origin = window.location.origin;
      } else {
        this.signalMetadataTags.origin = window.location.origin;
      }
    }
  }
  get descriptors() {
    return import_client_protocol3.clientServiceBundle;
  }
  get services() {
    return this._host?.services ?? {};
  }
  get host() {
    return this._host;
  }
  async open() {
    if (this._isOpen) {
      return;
    }
    const { ClientServicesHost } = await import("@dxos/client-services");
    const { setIdentityTags } = await import("@dxos/messaging");
    this._host = new ClientServicesHost({
      ...this._params,
      callbacks: {
        ...this._params.callbacks,
        onReset: async () => {
          this.closed.emit(void 0);
          await this._params.callbacks?.onReset?.();
        }
      }
    });
    await this._host.open(this._ctx);
    this._isOpen = true;
    setIdentityTags({
      identityService: this._host.services.IdentityService,
      devicesService: this._host.services.DevicesService,
      setTag: (k, v) => {
        this.signalMetadataTags[k] = v;
      }
    });
  }
  async close() {
    if (!this._isOpen) {
      return;
    }
    await this._host?.close();
    this._isOpen = false;
  }
};
_ts_decorate2([
  import_tracing2.trace.info()
], LocalClientServices.prototype, "_isOpen", void 0);
_ts_decorate2([
  import_async2.synchronized
], LocalClientServices.prototype, "open", null);
_ts_decorate2([
  import_async2.synchronized
], LocalClientServices.prototype, "close", null);
LocalClientServices = _ts_decorate2([
  import_tracing2.trace.resource({
    annotation: import_client_protocol3.ClientServicesProviderResource
  })
], LocalClientServices);
var __dxlog_file3 = "/home/runner/work/dxos/dxos/packages/sdk/client/src/services/socket.ts";
var fromSocket = async (url, authenticationToken) => {
  const closed = new import_async3.Event();
  let dxRpcClient;
  return {
    get closed() {
      return closed;
    },
    get descriptors() {
      return import_client_protocol4.clientServiceBundle;
    },
    get services() {
      return dxRpcClient.rpc;
    },
    open: async () => {
      const { WebsocketRpcClient } = await import("@dxos/websocket-rpc");
      dxRpcClient = new WebsocketRpcClient({
        url,
        authenticationToken,
        requested: import_client_protocol4.clientServiceBundle,
        exposed: {},
        handlers: {}
      });
      dxRpcClient.error.on(async (error) => {
        import_log3.log.warn("websocket rpc client error", {
          error
        }, {
          F: __dxlog_file3,
          L: 42,
          S: void 0,
          C: (f, a) => f(...a)
        });
        if (error.message.includes("401")) {
          import_log3.log.warn("websocket authentication failed", void 0, {
            F: __dxlog_file3,
            L: 45,
            S: void 0,
            C: (f, a) => f(...a)
          });
        }
        closed.emit(new import_protocols.ApiError("websocket error"));
      });
      await dxRpcClient.open();
    },
    close: async () => {
      await dxRpcClient.close();
    }
  };
};
function _ts_decorate3(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file4 = "/home/runner/work/dxos/dxos/packages/sdk/client/src/services/service-proxy.ts";
var ClientServicesProxy = class {
  constructor(_port, _timeout = 3e4) {
    this._port = _port;
    this._timeout = _timeout;
    this.closed = new import_async5.Event();
  }
  get proxy() {
    (0, import_invariant.invariant)(this._proxy, "Client services not open", {
      F: __dxlog_file4,
      L: 34,
      S: this,
      A: [
        "this._proxy",
        "'Client services not open'"
      ]
    });
    return this._proxy;
  }
  get descriptors() {
    return import_client_protocol6.clientServiceBundle;
  }
  get services() {
    (0, import_invariant.invariant)(this._proxy, "Client services not open", {
      F: __dxlog_file4,
      L: 43,
      S: this,
      A: [
        "this._proxy",
        "'Client services not open'"
      ]
    });
    return this._proxy.rpc;
  }
  async open() {
    if (this._proxy) {
      return;
    }
    this._proxy = (0, import_rpc.createProtoRpcPeer)({
      requested: import_client_protocol6.clientServiceBundle,
      exposed: {},
      handlers: {},
      port: this._port
    });
    await (0, import_async5.asyncTimeout)(this._proxy.open(), this._timeout, new import_protocols2.RemoteServiceConnectionTimeout("Failed to establish dxrpc connection", {
      timeout: this._timeout
    }));
  }
  async close() {
    if (!this._proxy) {
      return;
    }
    await this._proxy.close();
    this._proxy = void 0;
  }
};
ClientServicesProxy = _ts_decorate3([
  import_tracing4.trace.resource({
    annotation: import_client_protocol6.ClientServicesProviderResource
  })
], ClientServicesProxy);
var __dxlog_file5 = "/home/runner/work/dxos/dxos/packages/sdk/client/src/services/shared-worker-connection.ts";
var SharedWorkerConnection = class {
  constructor({ config, systemPort }) {
    this._id = String(Math.floor(Math.random() * 1e6));
    this._release = new import_async6.Trigger();
    this._configProvider = config;
    this._systemPort = systemPort;
  }
  async open(params) {
    const { RtcTransportService } = await import("@dxos/network-manager");
    this._config = await (0, import_util.getAsyncProviderValue)(this._configProvider);
    this._transportService = new RtcTransportService({
      iceServers: [
        ...this._config.get("runtime.services.ice") ?? []
      ]
    }, this._config.get("runtime.services.iceProviders") && (0, import_network_manager2.createIceProvider)(this._config.get("runtime.services.iceProviders")));
    this._systemRpc = (0, import_rpc2.createProtoRpcPeer)({
      requested: import_client_protocol7.workerServiceBundle,
      exposed: import_client_protocol7.iframeServiceBundle,
      handlers: {
        BridgeService: this._transportService
      },
      port: this._systemPort,
      // TODO(wittjosiah): Make longer and factor out to constant.
      // TODO(wittjosiah): If this is too long then it breaks the reset flows in Composer.
      timeout: 200
    });
    let lockKey;
    if (typeof navigator !== "undefined") {
      lockKey = this._lockKey(params.origin);
      this._release = new import_async6.Trigger();
      const ready = new import_async6.Trigger();
      void navigator.locks.request(lockKey, async () => {
        ready.wake();
        await this._release.wait();
      });
      await ready.wait();
    }
    try {
      await this._systemRpc.open();
      await this._systemRpc.rpc.WorkerService.start({
        lockKey,
        ...params
      });
    } catch (err) {
      import_log5.log.catch(err, void 0, {
        F: __dxlog_file5,
        L: 81,
        S: this,
        C: (f, a) => f(...a)
      });
      throw new import_protocols3.RemoteServiceConnectionError("Failed to connect to worker");
    }
  }
  async close() {
    this._release.wake();
    try {
      await this._systemRpc.rpc.WorkerService.stop();
    } catch {
    }
    await this._systemRpc.close();
  }
  _lockKey(origin) {
    return `${origin}-${this._id}`;
  }
};
function _ts_decorate4(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file6 = "/home/runner/work/dxos/dxos/packages/sdk/client/src/services/worker-client-services.ts";
var fromWorker = async (config = new import_config2.Config(), options) => new WorkerClientServices({
  config,
  ...options
});
var WorkerClientServices = class {
  constructor({ config, createWorker, logFilter = "error,warn", observabilityGroup, signalTelemetryEnabled }) {
    this.closed = new import_async4.Event();
    this.joinedSpace = new import_async4.Event();
    this._isOpen = false;
    this._config = config;
    this._createWorker = createWorker;
    this._logFilter = (0, import_log4.parseFilter)(logFilter);
    this._observabilityGroup = observabilityGroup;
    this._signalTelemetryEnabled = signalTelemetryEnabled ?? false;
  }
  get descriptors() {
    return import_client_protocol5.clientServiceBundle;
  }
  get services() {
    return this._services.services;
  }
  get runtime() {
    return this._runtime;
  }
  async open() {
    if (this._isOpen) {
      return;
    }
    (0, import_log4.log)("opening...", void 0, {
      F: __dxlog_file6,
      L: 88,
      S: this,
      C: (f, a) => f(...a)
    });
    const ports = new import_async4.Trigger();
    const worker = this._createWorker();
    worker.port.postMessage({
      dxlog: localStorage.getItem("dxlog")
    });
    worker.port.onmessage = (event) => {
      const { command, payload } = event.data;
      if (command === "init") {
        ports.wake(payload);
      }
    };
    const { systemPort, appPort } = await ports.wait();
    this._runtime = new SharedWorkerConnection({
      config: this._config,
      systemPort: (0, import_rpc_tunnel.createWorkerPort)({
        port: systemPort
      })
    });
    await this._runtime.open({
      origin: location.origin,
      observabilityGroup: this._observabilityGroup,
      signalTelemetryEnabled: this._signalTelemetryEnabled
    });
    this._services = new ClientServicesProxy((0, import_rpc_tunnel.createWorkerPort)({
      port: appPort
    }));
    await this._services.open();
    void navigator.locks.request(import_chunk_MVOI3MV3.LOCK_KEY, () => {
      (0, import_log4.log)("terminated", void 0, {
        F: __dxlog_file6,
        L: 113,
        S: this,
        C: (f, a) => f(...a)
      });
      if (this._isOpen) {
        this.closed.emit(new Error("Shared worker terminated."));
      }
    });
    this._loggingStream = this._services.services.LoggingService.queryLogs({
      filters: this._logFilter
    }, {
      timeout: import_chunk_P7Y3AD6I.RPC_TIMEOUT
    });
    this._loggingStream.subscribe((entry) => {
      switch (entry.level) {
        case import_services.LogLevel.DEBUG:
          import_log4.log.debug(entry.message, entry.context, mapLogMeta(entry.meta));
          break;
        case import_services.LogLevel.VERBOSE:
          import_log4.log.verbose(entry.message, entry.context, mapLogMeta(entry.meta));
          break;
        case import_services.LogLevel.INFO:
          import_log4.log.info(entry.message, entry.context, mapLogMeta(entry.meta));
          break;
        case import_services.LogLevel.WARN:
          import_log4.log.warn(entry.message, entry.context, mapLogMeta(entry.meta));
          break;
        case import_services.LogLevel.ERROR:
          import_log4.log.error(entry.message, entry.context, mapLogMeta(entry.meta));
          break;
      }
    });
    (0, import_log4.log)("opened", void 0, {
      F: __dxlog_file6,
      L: 145,
      S: this,
      C: (f, a) => f(...a)
    });
    this._isOpen = true;
  }
  async close() {
    if (!this._isOpen) {
      return;
    }
    (0, import_log4.log)("closing...", void 0, {
      F: __dxlog_file6,
      L: 155,
      S: this,
      C: (f, a) => f(...a)
    });
    await this._loggingStream?.close();
    await this._runtime.close();
    await this._services.close();
    (0, import_log4.log)("closed", void 0, {
      F: __dxlog_file6,
      L: 160,
      S: this,
      C: (f, a) => f(...a)
    });
    this._isOpen = false;
  }
};
_ts_decorate4([
  import_tracing3.trace.info()
], WorkerClientServices.prototype, "_isOpen", void 0);
_ts_decorate4([
  import_async4.synchronized
], WorkerClientServices.prototype, "open", null);
_ts_decorate4([
  import_async4.synchronized
], WorkerClientServices.prototype, "close", null);
WorkerClientServices = _ts_decorate4([
  import_tracing3.trace.resource()
], WorkerClientServices);
var mapLogMeta = (meta) => {
  return meta && {
    F: meta.file,
    L: meta.line,
    S: {
      ...meta.scope,
      remoteSessionId: meta.scope?.hostSessionId,
      hostSessionId: void 0
    }
  };
};
var createClientServices = (config, createWorker, observabilityGroup, signalTelemetryEnabled) => {
  const remote = config.values.runtime?.client?.remoteSource;
  if (remote) {
    const url = new URL(remote);
    const protocol = url.protocol.slice(0, -1);
    switch (protocol) {
      case "ws":
      case "wss": {
        return fromSocket(remote, config.values.runtime?.client?.remoteSourceAuthenticationToken);
      }
      case "http":
      case "https": {
        throw new Error("IFrame services deprecated.");
      }
    }
  }
  let useWorker = false;
  if (typeof navigator !== "undefined" && navigator.userAgent) {
    const parser = new import_ua_parser_js.UAParser(navigator.userAgent);
    useWorker = typeof SharedWorker !== "undefined" && parser.getOS().name !== "iOS";
  }
  return createWorker && useWorker ? fromWorker(config, {
    createWorker,
    observabilityGroup,
    signalTelemetryEnabled
  }) : fromHost(config, {}, observabilityGroup, signalTelemetryEnabled);
};
var IFrameManager = class {
  constructor({ source, onOpen, onMessage }) {
    this._source = source;
    this._onOpen = onOpen;
    this._onMessage = onMessage;
    this._messageHandler = this._messageHandler.bind(this);
  }
  get source() {
    return this._source;
  }
  get iframe() {
    return this._iframe;
  }
  async open() {
    if (this._iframe) {
      return;
    }
    window.addEventListener("message", this._messageHandler);
    const iframeId = `__DXOS_CLIENT_${import_keys.PublicKey.random().toHex()}__`;
    this._iframe = (0, import_rpc_tunnel2.createIFrame)(this._source.toString(), iframeId, {
      allow: "clipboard-read; clipboard-write"
    });
    await this._onOpen?.();
  }
  async close() {
    window.removeEventListener("message", this._messageHandler);
    this._iframe?.remove();
    this._iframe = void 0;
  }
  async _messageHandler(event) {
    void this._onMessage?.(event);
  }
};
var Shell = class {
  constructor({ shellManager, identity, devices, spaces }) {
    this._shellManager = shellManager;
    this._identity = identity;
    this._devices = devices;
    this._spaces = spaces;
  }
  async setInvitationUrl(request) {
    await this._shellManager.setInvitationUrl(request);
  }
  /**
  * Open the shell with the given layout.
  */
  async open(layout = import_iframe.ShellLayout.IDENTITY, options = {}) {
    await this._shellManager.setLayout({
      layout,
      ...options
    });
  }
  get display() {
    return this._shellManager.display;
  }
  /**
  * Listen for changes to the shell display.
  */
  onDisplayChange(cb) {
    return this._shellManager.contextUpdate.on((data) => {
      if ("display" in data) {
        cb(data.display);
      }
    });
  }
  /**
  * Listen for reset event.
  */
  onReset(cb) {
    return this._shellManager.contextUpdate.on((data) => {
      if ("reset" in data && data.reset) {
        cb(data.target);
      }
    });
  }
  /**
  * Create a new identity.
  * Opens the shell and starts the identity creation flow.
  *
  * @returns Shell result with the new identity.
  */
  async createIdentity() {
    await this._shellManager.setLayout({
      layout: import_iframe.ShellLayout.INITIALIZE_IDENTITY
    });
    return new Promise((resolve) => {
      this._shellManager.contextUpdate.on((context) => {
        if (context.display === import_iframe.ShellDisplay.NONE) {
          resolve({
            cancelled: true
          });
        }
      });
      this._identity.subscribe((identity) => {
        if (identity) {
          resolve({
            identity,
            cancelled: false
          });
        }
      });
    });
  }
  /**
  * Join an existing identity.
  * Opens the shell and starts the device invitation flow based on the given options.
  *
  * @param options.invitationCode If provided, join an existing identity via device invitation.
  *
  * @returns Shell result with the new identity.
  */
  async joinIdentity({ invitationCode } = {}) {
    await this._shellManager.setLayout({
      layout: import_iframe.ShellLayout.INITIALIZE_IDENTITY_FROM_INVITATION,
      invitationCode
    });
    return new Promise((resolve) => {
      this._shellManager.contextUpdate.on((context) => {
        if (context.display === import_iframe.ShellDisplay.NONE) {
          resolve({
            cancelled: true
          });
        }
      });
      this._identity.subscribe((identity) => {
        if (identity) {
          resolve({
            identity,
            cancelled: false
          });
        }
      });
    });
  }
  /**
  * Invite a new device to join the current identity.
  * Opens the shell and presents a device invitation.
  *
  * @returns Shell result with the new device.
  */
  async shareIdentity() {
    if (!this._identity.get()) {
      return {
        error: new Error("Identity does not exist"),
        cancelled: false
      };
    }
    const initialDevices = new import_util2.ComplexSet((key) => key.toHex(), this._devices.get().map((device) => device.deviceKey));
    await this._shellManager.setLayout({
      layout: import_iframe.ShellLayout.SHARE_IDENTITY
    });
    return new Promise((resolve) => {
      this._shellManager.contextUpdate.on((context) => {
        if (context.display === import_iframe.ShellDisplay.NONE) {
          const device = this._devices.get().find((device2) => !initialDevices.has(device2.deviceKey));
          resolve({
            device,
            cancelled: !device
          });
        }
      });
    });
  }
  /**
  * Initialize a new device with an existing identity using a recovery code.
  *
  * @returns Shell result with the identity.
  */
  async recoverIdentity() {
    await this._shellManager.setLayout({
      layout: import_iframe.ShellLayout.INITIALIZE_IDENTITY_FROM_RECOVERY
    });
    return new Promise((resolve) => {
      this._shellManager.contextUpdate.on((context) => {
        if (context.display === import_iframe.ShellDisplay.NONE) {
          resolve({
            cancelled: true
          });
        }
      });
      this._identity.subscribe((identity) => {
        if (identity) {
          resolve({
            identity,
            cancelled: false
          });
        }
      });
    });
  }
  /**
  * Invite new members to join the current space.
  * Opens the shell to the specified space, showing current members and allowing new members to be invited.
  *
  * @param options.spaceKey The space to share. (Deprecated, use spaceId instead.)
  * @param options.spaceId The space to share.
  * @param options.target The target location to share with new members.
  *
  * @returns Shell result with any new members that join while the shell is open.
  */
  async shareSpace({ spaceKey, spaceId, target }) {
    if (!this._identity.get()) {
      return {
        error: new Error("Identity does not exist"),
        cancelled: false
      };
    }
    const space = this._spaces.get().find((space2) => spaceKey?.equals(space2.key) || space2.id === spaceId);
    if (!space) {
      return {
        error: new Error("Space does not exist"),
        cancelled: false
      };
    }
    const initialMembers = new import_util2.ComplexSet((key) => key.toHex(), space.members.get().map((member) => member.identity.identityKey));
    await this._shellManager.setLayout({
      layout: import_iframe.ShellLayout.SPACE,
      spaceKey,
      spaceId,
      target
    });
    return new Promise((resolve) => {
      this._shellManager.contextUpdate.on((context) => {
        if (context.display === import_iframe.ShellDisplay.NONE) {
          const members = space.members.get().filter((member) => !initialMembers.has(member.identity.identityKey));
          resolve({
            members,
            cancelled: members.length === 0
          });
        }
      });
    });
  }
  /**
  * Join an existing space.
  * Opens the shell and starts the space join flow based on the given options.
  *
  * @param options.invitationCode If provided, redeem the invitation code to join the space.
  *
  * @returns The joined space.
  * @throws {Error} If no identity exists.
  */
  async joinSpace({ invitationCode } = {}) {
    if (!this._identity.get()) {
      return {
        error: new Error("Identity does not exist"),
        cancelled: false
      };
    }
    await this._shellManager.setLayout({
      layout: import_iframe.ShellLayout.JOIN_SPACE,
      invitationCode
    });
    return new Promise((resolve) => {
      this._shellManager.contextUpdate.on((context) => {
        const space = context.spaceKey && this._spaces.get().find((space2) => context.spaceKey?.equals(space2.key));
        if (space) {
          resolve({
            space,
            target: context.target,
            cancelled: false
          });
        }
        if (context.display === import_iframe.ShellDisplay.NONE) {
          resolve({
            cancelled: true
          });
        }
      });
    });
  }
};
var __dxlog_file7 = "/home/runner/work/dxos/dxos/packages/sdk/client/src/services/shell-manager.ts";
var shellStyles = Object.entries({
  display: "none",
  position: "fixed",
  top: 0,
  left: 0,
  width: "100vw",
  height: "100vh",
  border: 0,
  "z-index": 60
}).reduce((acc, [key, value]) => `${acc}${key}: ${value};`, "");
var ShellManager = class {
  // prettier-ignore
  constructor(_iframeManager, _channel = import_client_protocol8.DEFAULT_SHELL_CHANNEL) {
    this._iframeManager = _iframeManager;
    this._channel = _channel;
    this.contextUpdate = new import_async7.Event();
    this._display = import_iframe2.ShellDisplay.NONE;
  }
  get display() {
    return this._display;
  }
  async setLayout(request) {
    (0, import_invariant2.invariant)(this._shellRpc, "ShellManager not open", {
      F: __dxlog_file7,
      L: 57,
      S: this,
      A: [
        "this._shellRpc",
        "'ShellManager not open'"
      ]
    });
    (0, import_log6.log)("set layout", request, {
      F: __dxlog_file7,
      L: 58,
      S: this,
      C: (f, a) => f(...a)
    });
    this._display = import_iframe2.ShellDisplay.FULLSCREEN;
    this.contextUpdate.emit({
      display: this._display
    });
    await this._shellRpc.rpc.ShellService.setLayout(request, {
      timeout: import_chunk_P7Y3AD6I.RPC_TIMEOUT
    });
    this._iframeManager.iframe?.contentDocument?.querySelector('a[href], button:not([disabled]), input:not([disabled]), textarea:not([disabled]), select:not([disabled]), [tabindex]:not([tabindex="-1"])')?.focus();
  }
  async setInvitationUrl(request) {
    (0, import_log6.log)("set invitation url", request, {
      F: __dxlog_file7,
      L: 71,
      S: this,
      C: (f, a) => f(...a)
    });
    await this._shellRpc?.rpc.ShellService.setInvitationUrl(request, {
      timeout: import_chunk_P7Y3AD6I.RPC_TIMEOUT
    });
  }
  async open() {
    if (this._shellRpc) {
      return;
    }
    await this._iframeManager.open();
    const iframe = this._iframeManager.iframe;
    iframe.setAttribute("style", shellStyles);
    iframe.setAttribute("name", "dxos-shell");
    iframe.setAttribute("data-testid", "dxos-shell");
    this.contextUpdate.on(({ display }) => {
      iframe.style.display = display === import_iframe2.ShellDisplay.NONE ? "none" : "";
      if (display === import_iframe2.ShellDisplay.NONE) {
        iframe.blur();
      }
    });
    const origin = this._iframeManager.source.origin === "null" ? this._iframeManager.source.toString().split("/").slice(0, 3).join("/") : this._iframeManager.source.origin;
    const port = (0, import_rpc_tunnel3.createIFramePort)({
      origin,
      channel: this._channel,
      iframe: this._iframeManager.iframe
    });
    this._shellRpc = (0, import_rpc3.createProtoRpcPeer)({
      requested: import_client_protocol8.shellServiceBundle,
      exposed: import_client_protocol8.appServiceBundle,
      handlers: {
        AppService: {
          setContext: async (request) => {
            (0, import_log6.log)("set context", request, {
              F: __dxlog_file7,
              L: 112,
              S: this,
              C: (f, a) => f(...a)
            });
            if (request.display) {
              this._display = request.display;
            }
            this.contextUpdate.emit(request);
          }
        }
      },
      port
    });
    await this._shellRpc.open();
  }
  async close() {
    if (!this._shellRpc) {
      return;
    }
    await this._shellRpc?.close();
    this._shellRpc = void 0;
  }
};
function _ts_decorate5(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file8 = "/home/runner/work/dxos/dxos/packages/sdk/client/src/services/agent-hosting-provider.ts";
var ProviderApiError = class extends Error {
};
var defaultConfig = {
  name: "default",
  baseUrl: "http://localhost:8082/v1alpha1/",
  username: "dxos"
};
var COMPOSER_BETA_COOKIE_NAME = "COMPOSER-BETA";
var HUB_SERVICE_ACCESS_CAPABILITY = "agent:beta";
var HUB_SERVICE_ACCESS_MAGIC = "HubServiceAccessCredential";
var AgentManagerClient = class {
  // TODO(nf): just accept Client instead?
  constructor(_clientConfig, _halo) {
    this._clientConfig = _clientConfig;
    this._halo = _halo;
    this.DXRPC_PATH = "dxrpc";
    this._rpcState = "disconnected";
    this._authToken = null;
    const runtimeAgentHostingConfig = this._clientConfig.get("runtime.services.agentHosting");
    (0, import_invariant3.invariant)(runtimeAgentHostingConfig, "agentHosting config not found", {
      F: __dxlog_file8,
      L: 75,
      S: this,
      A: [
        "runtimeAgentHostingConfig",
        "'agentHosting config not found'"
      ]
    });
    (0, import_invariant3.invariant)(runtimeAgentHostingConfig.server, "agentHosting server not found", {
      F: __dxlog_file8,
      L: 76,
      S: this,
      A: [
        "runtimeAgentHostingConfig.server",
        "'agentHosting server not found'"
      ]
    });
    this._config = {
      ...defaultConfig,
      baseUrl: runtimeAgentHostingConfig.server,
      password: this._clientConfig.get("runtime.app.env.DX_AGENTHOSTING_PASSWORD")
    };
    if (!this._config.baseUrl.endsWith("/")) {
      this._config.baseUrl += "/";
    }
    this._wsDxrpcUrl = new URL(this.DXRPC_PATH, this._config.baseUrl.replace("http", "ws")).href;
  }
  init(authToken) {
    if (!this._checkAuthorization(authToken)) {
      return false;
    }
    return true;
  }
  /**
  * Check auth token/credential from CF worker whether identity is allowed to create agent.
  *
  * Note: This will prevent the client from making unnecessary requests to the AgentHostingProvider API.
  * The AgentHostingProvider will also validate the auth token/credential on its own.
  */
  _checkAuthorization(authToken) {
    const validCookie = this._checkAuthCookie(authToken);
    if (validCookie) {
      (0, import_log7.log)("beta JWT found", void 0, {
        F: __dxlog_file8,
        L: 111,
        S: this,
        C: (f, a) => f(...a)
      });
      return true;
    }
    const credential = this._getAuthorizationCredential();
    if (credential) {
      (0, import_log7.log)("beta credential found", {
        credential
      }, {
        F: __dxlog_file8,
        L: 117,
        S: this,
        C: (f, a) => f(...a)
      });
      return true;
    }
    (0, import_log7.log)("neither JWT nor beta credential found", void 0, {
      F: __dxlog_file8,
      L: 121,
      S: this,
      C: (f, a) => f(...a)
    });
    return false;
  }
  _checkAuthCookie(authToken) {
    const cookies = Object.fromEntries(document.cookie.split("; ").map((v) => v.split(/=(.*)/s).map(decodeURIComponent)));
    if (cookies[COMPOSER_BETA_COOKIE_NAME] == null) {
      return false;
    }
    const composerBetaJwt = this._decodeComposerBetaJwt();
    if (composerBetaJwt && composerBetaJwt.auth_agent) {
      return true;
    }
    return false;
  }
  // TODO(nf): use asymmetric key to verify token?
  _decodeComposerBetaJwt() {
    const decoded = (0, import_jwt_decode.jwtDecode)(this._getComposerBetaCookie());
    return decoded;
  }
  _getComposerBetaCookie() {
    const cookies = Object.fromEntries(document.cookie.split("; ").map((v) => v.split(/=(.*)/s).map(decodeURIComponent)));
    if (cookies[COMPOSER_BETA_COOKIE_NAME] == null) {
      return null;
    }
    return cookies[COMPOSER_BETA_COOKIE_NAME];
  }
  _getAuthorizationCredential() {
    return this._halo.queryCredentials().toSorted((a, b) => b.issuanceDate.getTime() - a.issuanceDate.getTime()).find(matchServiceCredential([
      HUB_SERVICE_ACCESS_CAPABILITY
    ]));
  }
  requestInitWithCredentials(req) {
    return {
      ...req,
      headers: {
        ...req.headers,
        Authorization: "Basic " + Buffer.from(`${this._config.username}:${this._config.password}`).toString("base64")
      }
    };
  }
  requestInitWithAuthToken(req) {
    return {
      ...req,
      headers: {
        ...req.headers,
        Authorization: "Bearer " + this._authToken
      }
    };
  }
  async _ensureAuthenticated() {
    if (this._validAuthToken()) {
      return;
    }
    const { deviceKey } = this._halo.device;
    (0, import_invariant3.invariant)(deviceKey, "deviceKey not found", {
      F: __dxlog_file8,
      L: 195,
      S: this,
      A: [
        "deviceKey",
        "'deviceKey not found'"
      ]
    });
    const authDeviceCreds = await this._queryCredentials("dxos.halo.credentials.AuthorizedDevice", (cred) => import_keys2.PublicKey.equals(cred.subject.id, deviceKey));
    (0, import_invariant3.invariant)(authDeviceCreds.length === 1, "Improper number of authorized devices", {
      F: __dxlog_file8,
      L: 200,
      S: this,
      A: [
        "authDeviceCreds.length === 1",
        "'Improper number of authorized devices'"
      ]
    });
    const agentBetaCredential = this._getAuthorizationCredential();
    await this._agentManagerAuth(authDeviceCreds[0], agentBetaCredential);
  }
  async _openRpc() {
    if (this._rpcState === "connected") {
      return;
    }
    const { WebsocketRpcClient } = await import("@dxos/websocket-rpc");
    this._rpc = new WebsocketRpcClient({
      url: this._wsDxrpcUrl,
      requested: {
        AgentManager: import_proto.schema.getService("dxos.service.agentmanager.AgentManager")
      },
      noHandshake: true
    });
    this._rpc.connected.on(() => {
      this._rpcState = "connected";
    });
    this._rpc.disconnected.on(() => {
      this._rpcState = "disconnected";
    });
    this._rpc.error.on((err) => {
      import_log7.log.info("rpc error", {
        err
      }, {
        F: __dxlog_file8,
        L: 226,
        S: this,
        C: (f, a) => f(...a)
      });
      this._rpcState = "disconnected";
    });
    try {
      await this._rpc.open();
    } catch (err) {
      import_log7.log.warn("failed to open rpc", {
        err
      }, {
        F: __dxlog_file8,
        L: 232,
        S: this,
        C: (f, a) => f(...a)
      });
      throw new Error("Failed to open rpc");
    }
  }
  // Authenticate to the agentmanager service using dxrpc and obtain a JWT token for subsequent HTTP requests.
  async _agentManagerAuth(authDeviceCreds, agentAuthzCredential) {
    await this._openRpc();
    (0, import_invariant3.invariant)(this._rpc, "RPC not initialized", {
      F: __dxlog_file8,
      L: 240,
      S: this,
      A: [
        "this._rpc",
        "'RPC not initialized'"
      ]
    });
    const { result, nonce, agentmanagerKey, initAuthResponseReason } = await this._rpc.rpc.AgentManager.initAuthSequence({
      authToken: agentAuthzCredential ? HUB_SERVICE_ACCESS_MAGIC : this._getComposerBetaCookie()
    });
    if (result !== import_agentmanager.InitAuthSequenceResponse.InitAuthSequenceResult.SUCCESS || !nonce || !agentmanagerKey) {
      (0, import_log7.log)("auth init failed", {
        result,
        nonce,
        agentmanagerKey,
        initAuthResponseReason
      }, {
        F: __dxlog_file8,
        L: 247,
        S: this,
        C: (f, a) => f(...a)
      });
      throw new Error("Failed to initialize auth sequence");
    }
    const agentmanagerAccessCreds = await this._queryCredentials("dxos.halo.credentials.ServiceAccess", (cred) => import_keys2.PublicKey.equals(cred.issuer, agentmanagerKey));
    if (!agentmanagerAccessCreds.length) {
      import_log7.log.info("no access credentials - requesting...", void 0, {
        F: __dxlog_file8,
        L: 254,
        S: this,
        C: (f, a) => f(...a)
      });
    } else {
      import_log7.log.info("access credentials found - requesting session token..", void 0, {
        F: __dxlog_file8,
        L: 256,
        S: this,
        C: (f, a) => f(...a)
      });
    }
    const credsToPresent = [
      authDeviceCreds.id,
      agentmanagerAccessCreds[0]?.id,
      agentAuthzCredential?.id
    ].filter(Boolean);
    const presentation = await this._halo.presentCredentials({
      ids: credsToPresent,
      nonce
    });
    const { token, credential } = await this._rpc.rpc.AgentManager.authenticate({
      presentation
    });
    if (token) {
      this._authToken = token;
      if (!this._validAuthToken()) {
        (0, import_log7.log)("received invalid authToken", {
          token
        }, {
          F: __dxlog_file8,
          L: 271,
          S: this,
          C: (f, a) => f(...a)
        });
        throw new ProviderApiError("Received invalid authToken");
      }
    } else {
      (0, import_invariant3.invariant)(credential, "No credential or token received", {
        F: __dxlog_file8,
        L: 275,
        S: this,
        A: [
          "credential",
          "'No credential or token received'"
        ]
      });
      (0, import_log7.log)("received credential, writing to HALO", {
        credential
      }, {
        F: __dxlog_file8,
        L: 276,
        S: this,
        C: (f, a) => f(...a)
      });
      await this._halo.writeCredentials([
        credential
      ]);
      await this._agentManagerAuth(authDeviceCreds, agentAuthzCredential);
    }
  }
  _validAuthToken() {
    if (!this._authToken) {
      return null;
    }
    const decoded = (0, import_jwt_decode.jwtDecode)(this._authToken);
    if (!decoded.exp) {
      import_log7.log.warn("authToken missing expiry", {
        decoded
      }, {
        F: __dxlog_file8,
        L: 289,
        S: this,
        C: (f, a) => f(...a)
      });
      return null;
    }
    if (decoded.exp * 1e3 < Date.now()) {
      (0, import_log7.log)("authToken expired", {
        decoded
      }, {
        F: __dxlog_file8,
        L: 293,
        S: this,
        C: (f, a) => f(...a)
      });
      return null;
    }
    return decoded;
  }
  async _queryCredentials(type, predicate) {
    const haloCredentials = this._halo.credentials.get();
    return haloCredentials.filter((cred) => {
      if (type && cred.subject.assertion["@type"] !== type) {
        return false;
      }
      if (predicate && !predicate(cred)) {
        return false;
      }
      return true;
    });
  }
  async createAgent(invitationCode, identityKey) {
    await this._ensureAuthenticated();
    const res = await fetch(new URL("agent", this._config.baseUrl), this.requestInitWithAuthToken({
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        invitation: invitationCode,
        identityKey
      })
    }));
    try {
      const agent = await res.json();
      return agent.metadata.uid;
    } catch (err) {
      if (err instanceof TypeError) {
        import_log7.log.warn("failed to parse response from agent create", {
          res
        }, {
          F: __dxlog_file8,
          L: 335,
          S: this,
          C: (f, a) => f(...a)
        });
        throw new ProviderApiError("failed to parse response from hosting provider");
      }
      import_log7.log.warn("bad response from agent create", {
        res
      }, {
        F: __dxlog_file8,
        L: 338,
        S: this,
        C: (f, a) => f(...a)
      });
      throw new ProviderApiError("bad response from hosting provider");
    }
  }
  async getAgent(agentID) {
    await this._ensureAuthenticated();
    const res = await fetch(new URL("agent/" + agentID, this._config.baseUrl), this.requestInitWithAuthToken({
      method: "GET"
    }));
    switch (res.status) {
      // TODO(nf): other status codes?
      case 200:
        break;
      case 404:
        return null;
      case 401:
        throw new ProviderApiError("unauthorized");
      case 403:
        throw new ProviderApiError("forbidden");
      case 500:
        import_log7.log.warn("request to agent get failed", {
          res
        }, {
          F: __dxlog_file8,
          L: 363,
          S: this,
          C: (f, a) => f(...a)
        });
        throw new ProviderApiError("internal server error from hosting provider");
      default:
        import_log7.log.warn("request to agent get failed", {
          res
        }, {
          F: __dxlog_file8,
          L: 366,
          S: this,
          C: (f, a) => f(...a)
        });
        throw new ProviderApiError("unknown API error");
    }
    import_log7.log.info("getAgent", {
      res
    }, {
      F: __dxlog_file8,
      L: 370,
      S: this,
      C: (f, a) => f(...a)
    });
    try {
      const agent = await res.json();
      return agent.metadata.uid;
    } catch (err) {
      if (err instanceof TypeError) {
        import_log7.log.warn("failed to parse response from agent get", {
          err
        }, {
          F: __dxlog_file8,
          L: 377,
          S: this,
          C: (f, a) => f(...a)
        });
        throw new ProviderApiError("failed to parse response from hosting provider");
      }
      import_log7.log.warn("bad response from agent get", {
        res
      }, {
        F: __dxlog_file8,
        L: 380,
        S: this,
        C: (f, a) => f(...a)
      });
      throw new ProviderApiError("bad response from hosting provider");
    }
  }
  async destroyAgent(agentID) {
    await this._ensureAuthenticated();
    const res = await fetch(new URL("agent/" + agentID, this._config.baseUrl), this.requestInitWithAuthToken({
      method: "DELETE"
    }));
    switch (res.status) {
      // TODO(nf): other status codes?
      case 204:
        return true;
      case 404:
        import_log7.log.warn("requested destroy on non-existent agent", void 0, {
          F: __dxlog_file8,
          L: 399,
          S: this,
          C: (f, a) => f(...a)
        });
        return false;
      case 403:
        throw new ProviderApiError("forbidden");
      case 500:
        import_log7.log.warn("request to agent destroy failed", {
          res
        }, {
          F: __dxlog_file8,
          L: 404,
          S: this,
          C: (f, a) => f(...a)
        });
        throw new ProviderApiError("internal server error from hosting provider");
      default:
        import_log7.log.warn("request to agent destroy failed", {
          res
        }, {
          F: __dxlog_file8,
          L: 407,
          S: this,
          C: (f, a) => f(...a)
        });
        throw new ProviderApiError("unknown API error");
    }
  }
};
_ts_decorate5([
  import_async8.synchronized
], AgentManagerClient.prototype, "_ensureAuthenticated", null);
var matchServiceCredential = (capabilities = []) => (credential) => {
  if (credential.subject.assertion["@type"] !== "dxos.halo.credentials.ServiceAccess") {
    return false;
  }
  const { capabilities: credentialCapabilities } = credential.subject.assertion;
  return capabilities.every((capability) => credentialCapabilities.includes(capability));
};
var FakeAgentHostingProvider = class {
  constructor(_throw = false) {
    this._throw = _throw;
    this._agents = /* @__PURE__ */ new Map();
  }
  async createAgent(invitationCode, identityKey) {
    await (0, import_async9.sleep)(3e3);
    const agentID = crypto.randomUUID();
    this._agents.set(identityKey, agentID);
    return agentID;
  }
  async getAgent(agentID) {
    await (0, import_async9.sleep)(3e3);
    return this._agents.get(agentID) ?? null;
  }
  async destroyAgent(agentID) {
    await (0, import_async9.sleep)(3e3);
    return this._agents.delete(agentID);
  }
  init(authToken) {
    return true;
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AgentClientServiceProvider,
  AgentManagerClient,
  ClientServicesProxy,
  FakeAgentHostingProvider,
  IFrameManager,
  LocalClientServices,
  SharedWorkerConnection,
  Shell,
  ShellManager,
  WorkerClientServices,
  createClientServices,
  fromAgent,
  fromHost,
  fromSocket,
  fromWorker,
  getUnixSocket
});
//# sourceMappingURL=chunk-GXHU364O.cjs.map
