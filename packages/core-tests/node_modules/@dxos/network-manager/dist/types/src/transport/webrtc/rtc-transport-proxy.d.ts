import { Event } from '@dxos/async';
import { Resource } from '@dxos/context';
import { ErrorStream } from '@dxos/debug';
import { type BridgeService } from '@dxos/protocols/proto/dxos/mesh/bridge';
import { type Signal } from '@dxos/protocols/proto/dxos/mesh/swarm';
import { type Transport, type TransportFactory, type TransportOptions, type TransportStats } from '../transport';
export type RtcTransportProxyOptions = TransportOptions & {
    bridgeService: BridgeService;
};
export declare class RtcTransportProxy extends Resource implements Transport {
    private readonly _options;
    private readonly _proxyId;
    readonly closed: Event<void>;
    readonly connected: Event<void>;
    readonly errors: ErrorStream;
    private _serviceStream;
    constructor(_options: RtcTransportProxyOptions);
    protected _open(): Promise<void>;
    protected _close(): Promise<void>;
    onSignal(signal: Signal): Promise<void>;
    private _handleConnection;
    private _handleData;
    private _handleSignal;
    getDetails(): Promise<string>;
    getStats(): Promise<TransportStats>;
    private _raiseIfOpen;
    /**
     * Called when underlying proxy service becomes unavailable.
     */
    forceClose(): void;
}
export declare class RtcTransportProxyFactory implements TransportFactory {
    private _bridgeService;
    private _connections;
    /**
     * Sets the current BridgeService to be used to open connections.
     * Calling this method will close any existing connections.
     */
    setBridgeService(bridgeService: BridgeService | undefined): this;
    createTransport(options: TransportOptions): Transport;
}
//# sourceMappingURL=rtc-transport-proxy.d.ts.map