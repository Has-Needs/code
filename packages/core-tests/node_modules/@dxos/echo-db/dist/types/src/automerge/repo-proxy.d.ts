import { type AnyDocumentId, type DocumentId } from '@automerge/automerge-repo';
import { Event } from '@dxos/async';
import { Resource } from '@dxos/context';
import { type SpaceId } from '@dxos/keys';
import { type DataService } from '@dxos/protocols/proto/dxos/echo/service';
import { DocHandleProxy } from './doc-handle-proxy';
/**
 * A proxy (thin client) to the Automerge Repo.
 * Inspired by Automerge's `Repo`.
 */
export declare class RepoProxy extends Resource {
    private readonly _dataService;
    private readonly _spaceId;
    private _handles;
    private readonly _subscriptionId;
    /**
     * Subscription id which is used inside the DataService to identify the Client.
     */
    private _subscription?;
    /**
     * Document ids pending for init mutation.
     */
    private readonly _pendingCreateIds;
    /**
     * Document ids that should be subscribed to.
     */
    private readonly _pendingAddIds;
    /**
     * Document ids that should be unsubscribed from.
     */
    private readonly _pendingRemoveIds;
    /**
     * Document ids that have pending updates.
     */
    private readonly _pendingUpdateIds;
    private _sendUpdatesJob?;
    readonly saveStateChanged: Event<SaveStateChangedEvent>;
    constructor(_dataService: DataService, _spaceId: SpaceId);
    get handles(): Record<string, DocHandleProxy<any>>;
    find<T>(id: AnyDocumentId): DocHandleProxy<T>;
    import<T>(dump: Uint8Array): DocHandleProxy<T>;
    create<T>(initialValue?: T): DocHandleProxy<T>;
    flush(): Promise<void>;
    protected _open(): Promise<void>;
    protected _close(): Promise<void>;
    /** Returns an existing handle if we have it; creates one otherwise. */
    private _getHandle;
    private _createHandle;
    private _receiveUpdate;
    private _sendUpdates;
    private _emitSaveStateEvent;
}
export type SaveStateChangedEvent = {
    unsavedDocuments: DocumentId[];
};
//# sourceMappingURL=repo-proxy.d.ts.map