import { next as A } from '@automerge/automerge';
import { type DocHandleOptions, type DocumentId } from '@automerge/automerge-repo';
import { EventEmitter } from 'eventemitter3';
import { type IDocHandle } from '../core-db';
export type ChangeEvent<T> = {
    handle: DocHandleProxy<T>;
    doc: A.Doc<T>;
    patches: A.Patch[];
    patchInfo: {
        before: A.Doc<T>;
        after: A.Doc<T>;
        source: 'change';
    };
};
export type ClientDocHandleEvents<T> = {
    change: ChangeEvent<T>;
    delete: {
        handle: DocHandleProxy<T>;
    };
};
/**
 * A client-side `IDocHandle` implementation.
 * Syncs with a Automerge Repo in shared worker.
 * Inspired by Automerge's `DocHandle`.
 */
export declare class DocHandleProxy<T> extends EventEmitter<ClientDocHandleEvents<T>> implements IDocHandle<T> {
    private readonly _documentId;
    private readonly _callbacks?;
    private readonly _ready;
    private _doc?;
    private _lastSentHeads;
    /**
     * Heads that are currently being synced.
     * If sync is successful, they will be moved to `_lastSentHeads`.
     */
    private _currentlySendingHeads;
    constructor(_documentId: DocumentId, options?: DocHandleOptions<T>, _callbacks?: {
        onDelete: () => void;
    } | undefined);
    get url(): import("@automerge/automerge-repo").AutomergeUrl;
    get documentId(): DocumentId;
    get state(): "ready" | "pending";
    doc(): A.Doc<T>;
    whenReady(): Promise<void>;
    isReady(): boolean;
    change(fn: (doc: A.Doc<T>) => void, opts?: A.ChangeOptions<any>): void;
    changeAt(heads: A.Heads, fn: (doc: A.Doc<T>) => void, opts?: A.ChangeOptions<any>): A.Heads | undefined;
    update(updateCallback: (doc: A.Doc<T>) => A.Doc<T>): void;
    delete(): void;
}
//# sourceMappingURL=doc-handle-proxy.d.ts.map