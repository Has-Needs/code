import { inspect } from 'node:util';
import { Event, type ReadOnlyEvent } from '@dxos/async';
import { Resource } from '@dxos/context';
import { type AnyEchoObject, type AnyObjectData, type BaseObject, type HasId } from '@dxos/echo-schema';
import { type PublicKey, type SpaceId } from '@dxos/keys';
import { type Live } from '@dxos/live-object';
import { type QueryService } from '@dxos/protocols/proto/dxos/echo/query';
import { type DataService } from '@dxos/protocols/proto/dxos/echo/service';
import { EchoSchemaRegistry } from './echo-schema-registry';
import type { ObjectMigration } from './object-migration';
import { CoreDatabase, type FlushOptions, type ObjectPlacement } from '../core-db';
import type { InsertBatch, InsertData, UpdateOperation } from '../core-db/crud-api';
import { type AnyLiveObject } from '../echo-handler';
import { type Hypergraph } from '../hypergraph';
import { Filter, type QueryFn } from '../query';
export type GetObjectByIdOptions = {
    deleted?: boolean;
};
export type AddOptions = {
    /**
     * Where to place the object in the Automerge document tree.
     * Root document is always loaded with the space.
     * Linked documents are loaded lazily.
     * Placing large number of objects in the root document may slow down the initial load.
     *
     * @default 'linked-doc'
     */
    placeIn?: ObjectPlacement;
};
/**
 *
 */
export interface EchoDatabase {
    get graph(): Hypergraph;
    get schemaRegistry(): EchoSchemaRegistry;
    get spaceKey(): PublicKey;
    get spaceId(): SpaceId;
    toJSON(): object;
    getObjectById<T extends BaseObject = any>(id: string, opts?: GetObjectByIdOptions): AnyLiveObject<T> | undefined;
    /**
     * Query objects.
     */
    query: QueryFn;
    /**
     * Adds object to the database.
     */
    add<T extends AnyEchoObject>(obj: Live<T>, opts?: AddOptions): Live<T & HasId>;
    /**
     * Removes object from the database.
     */
    remove<T extends AnyEchoObject>(obj: T): void;
    /**
     * Wait for all pending changes to be saved to disk.
     */
    flush(opts?: FlushOptions): Promise<void>;
    /**
     * Update objects.
     * @deprecated Use `add` instead.
     */
    update(filter: Filter.Any, operation: UpdateOperation): Promise<void>;
    /**
     * Insert new objects.
     * @deprecated Use `add` instead.
     */
    insert(data: InsertData): Promise<AnyObjectData>;
    insert(data: InsertBatch): Promise<AnyObjectData[]>;
    /**
     * Run migrations.
     */
    runMigrations(migrations: ObjectMigration[]): Promise<void>;
    /**
     * @deprecated
     */
    readonly pendingBatch: ReadOnlyEvent<unknown>;
    /**
     * @deprecated
     */
    readonly coreDatabase: CoreDatabase;
}
export type EchoDatabaseParams = {
    graph: Hypergraph;
    dataService: DataService;
    queryService: QueryService;
    spaceId: SpaceId;
    /**
     * Run a reactive query for a set of dynamic schema.
     * @default true
     */
    reactiveSchemaQuery?: boolean;
    preloadSchemaOnOpen?: boolean;
    /** @deprecated Use spaceId */
    spaceKey: PublicKey;
};
/**
 * API for the database.
 * Implements EchoDatabase interface.
 */
export declare class EchoDatabaseImpl extends Resource implements EchoDatabase {
    private readonly _schemaRegistry;
    private _rootUrl;
    constructor(params: EchoDatabaseParams);
    [inspect.custom](): string;
    toJSON(): {
        id: SpaceId;
        objects: number;
    };
    get spaceId(): SpaceId;
    /**
     * @deprecated Use `spaceId`.
     */
    get spaceKey(): PublicKey;
    get rootUrl(): string | undefined;
    get graph(): Hypergraph;
    get schemaRegistry(): EchoSchemaRegistry;
    protected _open(): Promise<void>;
    protected _close(): Promise<void>;
    setSpaceRoot(rootUrl: string): Promise<void>;
    getObjectById(id: string, { deleted }?: {
        deleted?: boolean | undefined;
    }): AnyLiveObject<any> | undefined;
    query: QueryFn;
    private _query;
    /**
     * Update objects.
     */
    update(filter: Filter.Any, operation: UpdateOperation): Promise<void>;
    insert(data: InsertData): Promise<AnyObjectData>;
    insert(data: InsertBatch): Promise<AnyObjectData[]>;
    /**
     * Add reactive object.
     */
    add<T extends BaseObject>(obj: T, opts?: AddOptions): Live<T & HasId>;
    /**
     * Remove reactive object.
     */
    remove<T extends BaseObject>(obj: T): void;
    flush(opts?: FlushOptions): Promise<void>;
    runMigrations(migrations: ObjectMigration[]): Promise<void>;
    /**
     * @deprecated
     */
    readonly pendingBatch: Event<unknown>;
    /**
     * @deprecated
     */
    get coreDatabase(): CoreDatabase;
}
//# sourceMappingURL=database.d.ts.map