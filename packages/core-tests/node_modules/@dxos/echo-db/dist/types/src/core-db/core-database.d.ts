import { Event, Trigger, type ReadOnlyEvent, type CleanupFn } from '@dxos/async';
import { Context } from '@dxos/context';
import { type Filter } from '@dxos/echo';
import { type SpaceState } from '@dxos/echo-protocol';
import { type ObjectId, type AnyObjectData } from '@dxos/echo-schema';
import { DXN, type PublicKey, type SpaceId } from '@dxos/keys';
import type { QueryService } from '@dxos/protocols/proto/dxos/echo/query';
import type { DataService, SpaceSyncState } from '@dxos/protocols/proto/dxos/echo/service';
import { type InsertBatch, type InsertData, type UpdateOperation } from './crud-api';
import { ObjectCore } from './object-core';
import { RepoProxy, type DocHandleProxy, type SaveStateChangedEvent } from '../automerge';
import { type Hypergraph } from '../hypergraph';
import { type QueryFn } from '../query';
export type InitRootProxyFn = (core: ObjectCore) => void;
export type CoreDatabaseParams = {
    graph: Hypergraph;
    dataService: DataService;
    queryService: QueryService;
    spaceId: SpaceId;
    spaceKey: PublicKey;
};
export type ObjectPlacement = 'root-doc' | 'linked-doc';
export type AddCoreOptions = {
    /**
     * Where to place the object in the Automerge document tree.
     * Root document is always loaded with the space.
     * Linked documents are loaded lazily.
     * Placing large number of objects in the root document may slow down the initial load.
     *
     * @default 'linked-doc'
     */
    placeIn?: ObjectPlacement;
};
/**
 *
 */
export declare class CoreDatabase {
    private readonly _hypergraph;
    private readonly _dataService;
    private readonly _queryService;
    private readonly _repoProxy;
    private readonly _spaceId;
    private readonly _spaceKey;
    private readonly _objects;
    /**
     * DXN string -> ObjectId.
     * Stores the targets of strong dependencies to the objects that depend on them.
     * When we load an object that doesn't have it's strong deps resolved, we wait for the deps to be loaded first.
     */
    private readonly _strongDepsIndex;
    readonly _updateEvent: Event<ItemsUpdatedEvent>;
    private _state;
    private _ctx;
    readonly opened: Trigger<void>;
    readonly rootChanged: Event<void>;
    readonly saveStateChanged: ReadOnlyEvent<SaveStateChangedEvent>;
    constructor({ graph, dataService, queryService, spaceId, spaceKey }: CoreDatabaseParams);
    toJSON(): {
        id: SpaceId;
        objects: number;
    };
    get graph(): Hypergraph;
    get spaceId(): SpaceId;
    /**
     * @deprecated
     */
    get spaceKey(): PublicKey;
    get _repo(): RepoProxy;
    open(spaceState: SpaceState): Promise<void>;
    close(): Promise<void>;
    /**
     * Update DB in response to space state change.
     * Can be used to change the root AM document.
     */
    updateSpaceState(spaceState: SpaceState): Promise<void>;
    /**
     * Returns ids for loaded and not loaded objects.
     */
    getAllObjectIds(): string[];
    getNumberOfInlineObjects(): number;
    getNumberOfLinkedObjects(): number;
    getTotalNumberOfObjects(): number;
    /**
     * @deprecated
     * Return only loaded objects.
     */
    allObjectCores(): ObjectCore[];
    getObjectCoreById(id: string, { load }?: GetObjectCoreByIdOptions): ObjectCore | undefined;
    loadObjectCoreById(objectId: string, { timeout, returnWithUnsatisfiedDeps }?: LoadObjectOptions): Promise<ObjectCore | undefined>;
    batchLoadObjectCores(objectIds: string[], { inactivityTimeout, returnDeleted, returnWithUnsatisfiedDeps, failOnTimeout, }?: {
        inactivityTimeout?: number;
        returnDeleted?: boolean;
        returnWithUnsatisfiedDeps?: boolean;
        failOnTimeout?: boolean;
    }): Promise<(ObjectCore | undefined)[]>;
    query: QueryFn;
    private _query;
    /**
     * Update objects.
     */
    update(filter: Filter.Any, operation: UpdateOperation): Promise<void>;
    insert(data: InsertData): Promise<AnyObjectData>;
    insert(data: InsertBatch): Promise<AnyObjectData[]>;
    addCore(core: ObjectCore, opts?: AddCoreOptions): void;
    removeCore(core: ObjectCore): void;
    /**
     * Removes an object link from the space root document.
     */
    unlinkObjects(objectIds: string[]): void;
    /**
     * Removes all objects that are marked as deleted.
     */
    unlinkDeletedObjects({ batchSize }?: {
        batchSize?: number;
    }): Promise<void>;
    /**
     * Resets the object to the new state.
     * Intended way to change the type of the object (for schema migrations).
     * Any concurrent changes made by other peers will be overwritten.
     */
    atomicReplaceObject(id: ObjectId, params: AtomicReplaceObjectParams): Promise<void>;
    flush({ disk, indexes, updates }?: FlushOptions): Promise<void>;
    /**
     * Returns document heads for all documents in the space.
     */
    getDocumentHeads(): Promise<SpaceDocumentHeads>;
    /**
     * Ensures that document heads have been replicated on the ECHO host.
     * Waits for the changes to be flushed to disk.
     * Does not ensure that this data has been propagated to the client.
     *
     * Note:
     *   For queries to return up-to-date results, the client must call `this.updateIndexes()`.
     *   This is also why flushing to disk is important.
     */
    waitUntilHeadsReplicated(heads: SpaceDocumentHeads): Promise<void>;
    /**
     * Returns document heads for all documents in the space.
     */
    reIndexHeads(): Promise<void>;
    /**
     * @deprecated Use `flush({ indexes: true })`.
     */
    updateIndexes(): Promise<void>;
    getSyncState(): Promise<SpaceSyncState>;
    subscribeToSyncState(ctx: Context, callback: (state: SpaceSyncState) => void): CleanupFn;
    getLoadedDocumentHandles(): DocHandleProxy<any>[];
    private _handleSpaceRootDocumentChange;
    private _emitObjectUpdateEvent;
    /**
     * Keep as field to have a reference to pass for unsubscribing from handle changes.
     */
    private readonly _onDocumentUpdate;
    private _processDocumentUpdate;
    private _unsubscribeFromHandles;
    private _onObjectDocumentLoaded;
    /**
     * Loads all objects on open and handles objects that are being created not by this client.
     */
    private _createInlineObjects;
    private _createObjectInDocument;
    private _areDepsSatisfied;
    private _rebindObjects;
    /**
     * Throttled db query updates. Signal updates were already emitted for these objects to immediately
     * update the UI. This happens for locally changed objects (_onDocumentUpdate).
     */
    private _objectsForNextDbUpdate;
    /**
     * Objects for which we throttled a db update event and a signal update event.
     * This happens for objects which were loaded for the first time (_onObjectDocumentLoaded).
     */
    private _objectsForNextUpdate;
    private readonly _updateScheduler;
    private _emitDbUpdateEvents;
    private _scheduleThrottledUpdate;
    private _scheduleThrottledDbUpdate;
}
export interface ItemsUpdatedEvent {
    spaceId: SpaceId;
    itemsUpdated: Array<{
        id: string;
    }>;
}
export type LoadObjectOptions = {
    timeout?: number;
    /**
     * Will not eagerly preload strong deps.
     */
    returnWithUnsatisfiedDeps?: boolean;
};
export type SpaceDocumentHeads = {
    /**
     * DocumentId => Heads.
     */
    heads: Record<string, string[]>;
};
export type GetObjectCoreByIdOptions = {
    /**
     * Request the object to be loaded if it is not already loaded.
     * @default true
     */
    load?: boolean;
};
export type AtomicReplaceObjectParams = {
    /**
     * Update data.
     * NOTE: This is not merged with the existing data.
     */
    data: any;
    /**
     * Update object type.
     */
    type?: DXN;
};
export type FlushOptions = {
    /**
     * Write any pending changes to disk.
     * @default true
     */
    disk?: boolean;
    /**
     * Wait for pending index updates.
     * @default false
     */
    indexes?: boolean;
    /**
     * Flush pending updates to objects and queries.
     * @default false
     */
    updates?: boolean;
};
//# sourceMappingURL=core-database.d.ts.map