import "@dxos/node-std/globals";
import {
  EchoClient,
  Filter,
  MockQueueService,
  Query
} from "../chunk-A5FAUWDM.mjs";

// packages/core/echo/echo-db/src/testing/echo-test-builder.ts
import isEqual from "lodash.isequal";
import { waitForCondition } from "@dxos/async";
import { Resource } from "@dxos/context";
import { EchoHost } from "@dxos/echo-pipeline";
import { createIdFromSpaceKey } from "@dxos/echo-protocol";
import { invariant } from "@dxos/invariant";
import { PublicKey } from "@dxos/keys";
import { createTestLevel } from "@dxos/kv-store/testing";
import { range } from "@dxos/util";
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/core/echo/echo-db/src/testing/echo-test-builder.ts";
var EchoTestBuilder = class extends Resource {
  constructor() {
    super(...arguments);
    this._peers = [];
  }
  get lastPeer() {
    return this._peers.at(-1);
  }
  async _close(ctx) {
    await Promise.all(this._peers.map((peer) => peer.close(ctx)));
  }
  async createPeer(options = {}) {
    const peer = new EchoTestPeer(options);
    this._peers.push(peer);
    await peer.open();
    return peer;
  }
  /**
  * Shorthand for creating a peer and a database.
  */
  async createDatabase(options = {}) {
    const peer = await this.createPeer(options);
    const db = await peer.createDatabase(PublicKey.random());
    return {
      peer,
      host: peer.host,
      db,
      graph: db.graph,
      crud: db.coreDatabase
    };
  }
};
var EchoTestPeer = class extends Resource {
  constructor({ kv = createTestLevel(), indexing = {}, types }) {
    super();
    this._clients = /* @__PURE__ */ new Set();
    this._queuesService = new MockQueueService();
    this._lastDatabaseSpaceKey = void 0;
    this._lastDatabaseRootUrl = void 0;
    this._kv = kv;
    this._indexing = indexing;
    this._types = types ?? [];
    this._initEcho();
  }
  _initEcho() {
    this._echoHost = new EchoHost({
      kv: this._kv,
      indexing: this._indexing
    });
    this._clients.delete(this._echoClient);
    this._echoClient = new EchoClient();
    this._clients.add(this._echoClient);
    this._echoClient.graph.schemaRegistry.addSchema(this._types);
  }
  get client() {
    return this._echoClient;
  }
  get host() {
    return this._echoHost;
  }
  async _open(ctx) {
    await this._kv.open();
    this._echoClient.connectToService({
      dataService: this._echoHost.dataService,
      queryService: this._echoHost.queryService,
      queueService: this._queuesService
    });
    await this._echoHost.open(ctx);
    await this._echoClient.open(ctx);
  }
  async _close(ctx) {
    for (const client of this._clients) {
      await client.close(ctx);
      client.disconnectFromService();
    }
    await this._echoHost.close(ctx);
    await this._kv.close();
  }
  /**
  * Simulates a reload of the process by re-creation ECHO.
  */
  async reload() {
    await this.close();
    this._initEcho();
    await this.open();
  }
  async createClient() {
    const client = new EchoClient();
    client.graph.schemaRegistry.addSchema(this._types);
    this._clients.add(client);
    client.connectToService({
      dataService: this._echoHost.dataService,
      queryService: this._echoHost.queryService
    });
    await client.open();
    return client;
  }
  async createDatabase(spaceKey = PublicKey.random(), { client = this.client, reactiveSchemaQuery, preloadSchemaOnOpen } = {}) {
    const root = await this.host.createSpaceRoot(spaceKey);
    const spaceId = await createIdFromSpaceKey(spaceKey);
    const db = client.constructDatabase({
      spaceId,
      spaceKey,
      reactiveSchemaQuery,
      preloadSchemaOnOpen
    });
    await db.setSpaceRoot(root.url);
    await db.open();
    this._lastDatabaseSpaceKey = spaceKey;
    this._lastDatabaseRootUrl = root.url;
    return db;
  }
  async openDatabase(spaceKey, rootUrl, { client = this.client, reactiveSchemaQuery, preloadSchemaOnOpen } = {}) {
    const spaceId = await createIdFromSpaceKey(spaceKey);
    await this.host.openSpaceRoot(spaceId, rootUrl);
    const db = client.constructDatabase({
      spaceId,
      spaceKey,
      reactiveSchemaQuery,
      preloadSchemaOnOpen
    });
    await db.setSpaceRoot(rootUrl);
    await db.open();
    return db;
  }
  async openLastDatabase({ client = this.client, reactiveSchemaQuery, preloadSchemaOnOpen } = {}) {
    return this.openDatabase(this._lastDatabaseSpaceKey, this._lastDatabaseRootUrl, {
      client,
      reactiveSchemaQuery,
      preloadSchemaOnOpen
    });
  }
};
var createDataAssertion = ({ referenceEquality = false, onlyObject = true, numObjects = 1 } = {}) => {
  let seedObjects;
  const findSeedObject = async (db) => {
    const { objects } = await db.query(Query.select(Filter.everything())).run();
    const received = seedObjects.map((seedObject) => objects.find((object) => object.id === seedObject.id));
    return {
      objects,
      received
    };
  };
  return {
    seed: async (db) => {
      seedObjects = range(numObjects).map((idx) => db.add({
        type: "task",
        title: "A",
        idx
      }));
      await db.flush();
    },
    waitForReplication: (db) => {
      return waitForCondition({
        breakOnError: true,
        condition: async () => {
          const { received } = await findSeedObject(db);
          return received.every((obj) => obj != null);
        }
      });
    },
    verify: async (db) => {
      const { objects } = await findSeedObject(db);
      if (onlyObject) {
        invariant(objects.length === numObjects, void 0, {
          F: __dxlog_file,
          L: 217,
          S: void 0,
          A: [
            "objects.length === numObjects",
            ""
          ]
        });
      }
      for (const seedObject of seedObjects) {
        const received = objects.find((object) => object.id === seedObject.id);
        invariant(isEqual({
          ...received
        }, {
          ...seedObject
        }), [
          "Objects are not equal",
          `Received: ${JSON.stringify(received, null, 2)}`,
          `Expected: ${JSON.stringify(seedObject, null, 2)}`
        ].join("\n"), {
          F: __dxlog_file,
          L: 223,
          S: void 0,
          A: [
            "isEqual({ ...received }, { ...seedObject })",
            "[\n            'Objects are not equal',\n            `Received: ${JSON.stringify(received, null, 2)}`,\n            `Expected: ${JSON.stringify(seedObject, null, 2)}`,\n          ].join('\\n')"
          ]
        });
        if (referenceEquality) {
          invariant(received === seedObject, void 0, {
            F: __dxlog_file,
            L: 232,
            S: void 0,
            A: [
              "received === seedObject",
              ""
            ]
          });
        }
      }
    }
  };
};
export {
  EchoTestBuilder,
  EchoTestPeer,
  createDataAssertion
};
//# sourceMappingURL=index.mjs.map
