"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var testing_exports = {};
__export(testing_exports, {
  EchoTestBuilder: () => EchoTestBuilder,
  EchoTestPeer: () => EchoTestPeer,
  createDataAssertion: () => createDataAssertion
});
module.exports = __toCommonJS(testing_exports);
var import_chunk_WEFFA7O3 = require("../chunk-WEFFA7O3.cjs");
var import_lodash = __toESM(require("lodash.isequal"));
var import_async = require("@dxos/async");
var import_context = require("@dxos/context");
var import_echo_pipeline = require("@dxos/echo-pipeline");
var import_echo_protocol = require("@dxos/echo-protocol");
var import_invariant = require("@dxos/invariant");
var import_keys = require("@dxos/keys");
var import_testing = require("@dxos/kv-store/testing");
var import_util = require("@dxos/util");
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/core/echo/echo-db/src/testing/echo-test-builder.ts";
var EchoTestBuilder = class extends import_context.Resource {
  constructor() {
    super(...arguments);
    this._peers = [];
  }
  get lastPeer() {
    return this._peers.at(-1);
  }
  async _close(ctx) {
    await Promise.all(this._peers.map((peer) => peer.close(ctx)));
  }
  async createPeer(options = {}) {
    const peer = new EchoTestPeer(options);
    this._peers.push(peer);
    await peer.open();
    return peer;
  }
  /**
  * Shorthand for creating a peer and a database.
  */
  async createDatabase(options = {}) {
    const peer = await this.createPeer(options);
    const db = await peer.createDatabase(import_keys.PublicKey.random());
    return {
      peer,
      host: peer.host,
      db,
      graph: db.graph,
      crud: db.coreDatabase
    };
  }
};
var EchoTestPeer = class extends import_context.Resource {
  constructor({ kv = (0, import_testing.createTestLevel)(), indexing = {}, types }) {
    super();
    this._clients = /* @__PURE__ */ new Set();
    this._queuesService = new import_chunk_WEFFA7O3.MockQueueService();
    this._lastDatabaseSpaceKey = void 0;
    this._lastDatabaseRootUrl = void 0;
    this._kv = kv;
    this._indexing = indexing;
    this._types = types ?? [];
    this._initEcho();
  }
  _initEcho() {
    this._echoHost = new import_echo_pipeline.EchoHost({
      kv: this._kv,
      indexing: this._indexing
    });
    this._clients.delete(this._echoClient);
    this._echoClient = new import_chunk_WEFFA7O3.EchoClient();
    this._clients.add(this._echoClient);
    this._echoClient.graph.schemaRegistry.addSchema(this._types);
  }
  get client() {
    return this._echoClient;
  }
  get host() {
    return this._echoHost;
  }
  async _open(ctx) {
    await this._kv.open();
    this._echoClient.connectToService({
      dataService: this._echoHost.dataService,
      queryService: this._echoHost.queryService,
      queueService: this._queuesService
    });
    await this._echoHost.open(ctx);
    await this._echoClient.open(ctx);
  }
  async _close(ctx) {
    for (const client of this._clients) {
      await client.close(ctx);
      client.disconnectFromService();
    }
    await this._echoHost.close(ctx);
    await this._kv.close();
  }
  /**
  * Simulates a reload of the process by re-creation ECHO.
  */
  async reload() {
    await this.close();
    this._initEcho();
    await this.open();
  }
  async createClient() {
    const client = new import_chunk_WEFFA7O3.EchoClient();
    client.graph.schemaRegistry.addSchema(this._types);
    this._clients.add(client);
    client.connectToService({
      dataService: this._echoHost.dataService,
      queryService: this._echoHost.queryService
    });
    await client.open();
    return client;
  }
  async createDatabase(spaceKey = import_keys.PublicKey.random(), { client = this.client, reactiveSchemaQuery, preloadSchemaOnOpen } = {}) {
    const root = await this.host.createSpaceRoot(spaceKey);
    const spaceId = await (0, import_echo_protocol.createIdFromSpaceKey)(spaceKey);
    const db = client.constructDatabase({
      spaceId,
      spaceKey,
      reactiveSchemaQuery,
      preloadSchemaOnOpen
    });
    await db.setSpaceRoot(root.url);
    await db.open();
    this._lastDatabaseSpaceKey = spaceKey;
    this._lastDatabaseRootUrl = root.url;
    return db;
  }
  async openDatabase(spaceKey, rootUrl, { client = this.client, reactiveSchemaQuery, preloadSchemaOnOpen } = {}) {
    const spaceId = await (0, import_echo_protocol.createIdFromSpaceKey)(spaceKey);
    await this.host.openSpaceRoot(spaceId, rootUrl);
    const db = client.constructDatabase({
      spaceId,
      spaceKey,
      reactiveSchemaQuery,
      preloadSchemaOnOpen
    });
    await db.setSpaceRoot(rootUrl);
    await db.open();
    return db;
  }
  async openLastDatabase({ client = this.client, reactiveSchemaQuery, preloadSchemaOnOpen } = {}) {
    return this.openDatabase(this._lastDatabaseSpaceKey, this._lastDatabaseRootUrl, {
      client,
      reactiveSchemaQuery,
      preloadSchemaOnOpen
    });
  }
};
var createDataAssertion = ({ referenceEquality = false, onlyObject = true, numObjects = 1 } = {}) => {
  let seedObjects;
  const findSeedObject = async (db) => {
    const { objects } = await db.query(import_chunk_WEFFA7O3.Query.select(import_chunk_WEFFA7O3.Filter.everything())).run();
    const received = seedObjects.map((seedObject) => objects.find((object) => object.id === seedObject.id));
    return {
      objects,
      received
    };
  };
  return {
    seed: async (db) => {
      seedObjects = (0, import_util.range)(numObjects).map((idx) => db.add({
        type: "task",
        title: "A",
        idx
      }));
      await db.flush();
    },
    waitForReplication: (db) => {
      return (0, import_async.waitForCondition)({
        breakOnError: true,
        condition: async () => {
          const { received } = await findSeedObject(db);
          return received.every((obj) => obj != null);
        }
      });
    },
    verify: async (db) => {
      const { objects } = await findSeedObject(db);
      if (onlyObject) {
        (0, import_invariant.invariant)(objects.length === numObjects, void 0, {
          F: __dxlog_file,
          L: 217,
          S: void 0,
          A: [
            "objects.length === numObjects",
            ""
          ]
        });
      }
      for (const seedObject of seedObjects) {
        const received = objects.find((object) => object.id === seedObject.id);
        (0, import_invariant.invariant)((0, import_lodash.default)({
          ...received
        }, {
          ...seedObject
        }), [
          "Objects are not equal",
          `Received: ${JSON.stringify(received, null, 2)}`,
          `Expected: ${JSON.stringify(seedObject, null, 2)}`
        ].join("\n"), {
          F: __dxlog_file,
          L: 223,
          S: void 0,
          A: [
            "isEqual({ ...received }, { ...seedObject })",
            "[\n            'Objects are not equal',\n            `Received: ${JSON.stringify(received, null, 2)}`,\n            `Expected: ${JSON.stringify(seedObject, null, 2)}`,\n          ].join('\\n')"
          ]
        });
        if (referenceEquality) {
          (0, import_invariant.invariant)(received === seedObject, void 0, {
            F: __dxlog_file,
            L: 232,
            S: void 0,
            A: [
              "received === seedObject",
              ""
            ]
          });
        }
      }
    }
  };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  EchoTestBuilder,
  EchoTestPeer,
  createDataAssertion
});
//# sourceMappingURL=index.cjs.map
