// packages/core/mesh/teleport-extension-automerge-replicator/src/automerge-replicator.ts
import { Trigger, sleep } from "@dxos/async";
import { invariant } from "@dxos/invariant";
import { log } from "@dxos/log";
import { RpcClosedError } from "@dxos/protocols";
import { schema } from "@dxos/protocols/proto";
import { createProtoRpcPeer } from "@dxos/rpc";
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/core/mesh/teleport-extension-automerge-replicator/src/automerge-replicator.ts";
var RPC_TIMEOUT = 1e4;
var DEFAULT_RETRY_POLICY = {
  retriesBeforeBackoff: 3,
  retryBackoff: 1e3,
  maxRetries: 10
};
var AutomergeReplicator = class {
  constructor(_params, _callbacks = {}) {
    this._params = _params;
    this._callbacks = _callbacks;
    this._opened = new Trigger();
    this._destroyed = false;
  }
  async onOpen(context) {
    log("onOpen", {
      localPeerId: context.localPeerId,
      remotePeerId: context.remotePeerId
    }, {
      F: __dxlog_file,
      L: 76,
      S: this,
      C: (f, a) => f(...a)
    });
    this._extensionContext = context;
    this._rpc = createProtoRpcPeer({
      timeout: RPC_TIMEOUT,
      requested: {
        AutomergeReplicatorService: schema.getService("dxos.mesh.teleport.automerge.AutomergeReplicatorService")
      },
      exposed: {
        AutomergeReplicatorService: schema.getService("dxos.mesh.teleport.automerge.AutomergeReplicatorService")
      },
      handlers: {
        AutomergeReplicatorService: {
          startReplication: async (info) => {
            log("startReplication", {
              localPeerId: context.localPeerId,
              remotePeerId: context.remotePeerId,
              info
            }, {
              F: __dxlog_file,
              L: 89,
              S: this,
              C: (f, a) => f(...a)
            });
            await this._callbacks.onStartReplication?.(info, context.remotePeerId);
          },
          sendSyncMessage: async (message) => {
            await this._callbacks.onSyncMessage?.(message);
          }
        }
      },
      port: await context.createPort("rpc", {
        contentType: 'application/x-protobuf; messageType="dxos.rpc.Message"'
      })
    });
    await this._rpc.open();
    await this._rpc.rpc.AutomergeReplicatorService.startReplication({
      id: this._params.peerId
    });
    this._opened.wake();
  }
  async onClose(err) {
    await this._rpc?.close();
    await this._destroy(err);
  }
  async onAbort(err) {
    log("abort", {
      err
    }, {
      F: __dxlog_file,
      L: 113,
      S: this,
      C: (f, a) => f(...a)
    });
    await this._rpc?.abort();
    await this._destroy(err);
  }
  async _destroy(err) {
    this._destroyed = true;
    this._rpc = void 0;
    this._extensionContext = void 0;
    await this._callbacks.onClose?.(err);
  }
  async sendSyncMessage(message) {
    invariant(!this._destroyed, void 0, {
      F: __dxlog_file,
      L: 126,
      S: this,
      A: [
        "!this._destroyed",
        ""
      ]
    });
    await this._opened.wait();
    invariant(this._rpc, "RPC not initialized", {
      F: __dxlog_file,
      L: 128,
      S: this,
      A: [
        "this._rpc",
        "'RPC not initialized'"
      ]
    });
    const retryPolicy = this._params.sendSyncRetryPolicy ?? DEFAULT_RETRY_POLICY;
    let retries = 0;
    while (true) {
      try {
        await this._rpc.rpc.AutomergeReplicatorService.sendSyncMessage(message);
        break;
      } catch (err) {
        if (err instanceof RpcClosedError) {
          return;
        }
        log("sendSyncMessage error", {
          err
        }, {
          F: __dxlog_file,
          L: 141,
          S: this,
          C: (f, a) => f(...a)
        });
        retries++;
        if (retries >= retryPolicy.maxRetries) {
          const numberOfRetriesExceededError = new Error(`Failed to send sync message after ${retryPolicy.maxRetries} retries. Last attempt failed with error: ${err}`);
          this._extensionContext?.close(numberOfRetriesExceededError);
          throw numberOfRetriesExceededError;
        }
        if (retries % retryPolicy.retriesBeforeBackoff === 0) {
          await sleep(retryPolicy.retryBackoff);
        }
      }
    }
  }
};
export {
  AutomergeReplicator
};
//# sourceMappingURL=index.mjs.map
