import { type Config } from '@dxos/config';
import { type RpcPort } from '@dxos/rpc';
import { type MaybePromise } from '@dxos/util';
import { ClientServicesHost } from '../services';
export type CreateSessionParams = {
    appPort: RpcPort;
    systemPort: RpcPort;
    shellPort?: RpcPort;
};
export type WorkerRuntimeOptions = {
    channel?: string;
    configProvider: () => MaybePromise<Config>;
    acquireLock: () => Promise<void>;
    releaseLock: () => void;
    onStop?: () => Promise<void>;
};
/**
 * Runtime for the shared worker.
 * Manages connections from proxies (in tabs).
 * Tabs make requests to the `ClientServicesHost`, and provide a WebRTC gateway.
 */
export declare class WorkerRuntime {
    private readonly _configProvider;
    private readonly _acquireLock;
    private readonly _releaseLock;
    private readonly _onStop?;
    private readonly _transportFactory;
    private readonly _ready;
    private readonly _sessions;
    private readonly _clientServices;
    private readonly _channel;
    private _broadcastChannel?;
    private _sessionForNetworking?;
    private _config;
    private _signalMetadataTags;
    private _signalTelemetryEnabled;
    constructor({ channel, configProvider, acquireLock, releaseLock, onStop, }: WorkerRuntimeOptions);
    get host(): ClientServicesHost;
    start(): Promise<void>;
    stop(): Promise<void>;
    /**
     * Create a new session.
     */
    createSession({ appPort, systemPort, shellPort }: CreateSessionParams): Promise<void>;
    /**
     * Selects one of the existing session for WebRTC networking.
     */
    private _reconnectWebrtc;
}
//# sourceMappingURL=worker-runtime.d.ts.map