"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var node_exports = {};
__export(node_exports, {
  ClientRpcServer: () => import_chunk_LMGLGOUU.ClientRpcServer,
  ClientServicesHost: () => import_chunk_LMGLGOUU.ClientServicesHost,
  DataSpace: () => import_chunk_LMGLGOUU.DataSpace,
  DataSpaceManager: () => import_chunk_LMGLGOUU.DataSpaceManager,
  DeviceInvitationProtocol: () => import_chunk_LMGLGOUU.DeviceInvitationProtocol,
  DevtoolsHostEvents: () => import_chunk_LMGLGOUU.DevtoolsHostEvents,
  DevtoolsServiceImpl: () => import_chunk_LMGLGOUU.DevtoolsServiceImpl,
  DiagnosticsCollector: () => import_chunk_LMGLGOUU.DiagnosticsCollector,
  EdgeAgentManager: () => import_chunk_LMGLGOUU.EdgeAgentManager,
  EdgeAgentServiceImpl: () => import_chunk_LMGLGOUU.EdgeAgentServiceImpl,
  EdgeFeedReplicator: () => import_chunk_LMGLGOUU.EdgeFeedReplicator,
  Identity: () => import_chunk_LMGLGOUU.Identity,
  IdentityManager: () => import_chunk_LMGLGOUU.IdentityManager,
  IdentityServiceImpl: () => import_chunk_LMGLGOUU.IdentityServiceImpl,
  InvitationsHandler: () => import_chunk_LMGLGOUU.InvitationsHandler,
  InvitationsManager: () => import_chunk_LMGLGOUU.InvitationsManager,
  InvitationsServiceImpl: () => import_chunk_LMGLGOUU.InvitationsServiceImpl,
  Lock: () => import_chunk_LMGLGOUU.Lock,
  ServiceContext: () => import_chunk_LMGLGOUU.ServiceContext,
  ServiceRegistry: () => import_chunk_LMGLGOUU.ServiceRegistry,
  SpaceInvitationProtocol: () => import_chunk_LMGLGOUU.SpaceInvitationProtocol,
  SpacesServiceImpl: () => import_chunk_LMGLGOUU.SpacesServiceImpl,
  TrustedKeySetAuthVerifier: () => import_chunk_LMGLGOUU.TrustedKeySetAuthVerifier,
  WorkerRuntime: () => WorkerRuntime,
  WorkerSession: () => WorkerSession,
  createAdmissionKeypair: () => import_chunk_LMGLGOUU.createAdmissionKeypair,
  createAuthProvider: () => import_chunk_LMGLGOUU.createAuthProvider,
  createCollectDiagnosticsBroadcastHandler: () => import_chunk_LMGLGOUU.createCollectDiagnosticsBroadcastHandler,
  createCollectDiagnosticsBroadcastSender: () => import_chunk_LMGLGOUU.createCollectDiagnosticsBroadcastSender,
  createDiagnostics: () => import_chunk_LMGLGOUU.createDiagnostics,
  createLevel: () => import_chunk_LMGLGOUU.createLevel,
  createStorageObjects: () => import_chunk_LMGLGOUU.createStorageObjects,
  decodeProfileArchive: () => import_chunk_LMGLGOUU.decodeProfileArchive,
  encodeProfileArchive: () => import_chunk_LMGLGOUU.encodeProfileArchive,
  exportProfileData: () => import_chunk_LMGLGOUU.exportProfileData,
  getNetworkPeers: () => import_chunk_LMGLGOUU.getNetworkPeers,
  importProfileData: () => import_chunk_LMGLGOUU.importProfileData,
  isLocked: () => import_chunk_LMGLGOUU.isLocked,
  subscribeToFeedBlocks: () => import_chunk_LMGLGOUU.subscribeToFeedBlocks,
  subscribeToFeeds: () => import_chunk_LMGLGOUU.subscribeToFeeds,
  subscribeToNetworkStatus: () => import_chunk_LMGLGOUU.subscribeToNetworkStatus,
  subscribeToNetworkTopics: () => import_chunk_LMGLGOUU.subscribeToNetworkTopics,
  subscribeToSignal: () => import_chunk_LMGLGOUU.subscribeToSignal,
  subscribeToSpaces: () => import_chunk_LMGLGOUU.subscribeToSpaces,
  subscribeToSwarmInfo: () => import_chunk_LMGLGOUU.subscribeToSwarmInfo
});
module.exports = __toCommonJS(node_exports);
var import_chunk_LMGLGOUU = require("./chunk-LMGLGOUU.cjs");
var import_async = require("@dxos/async");
var import_client_protocol = require("@dxos/client-protocol");
var import_context = require("@dxos/context");
var import_invariant = require("@dxos/invariant");
var import_log = require("@dxos/log");
var import_messaging = require("@dxos/messaging");
var import_network_manager = require("@dxos/network-manager");
var import_async2 = require("@dxos/async");
var import_client_protocol2 = require("@dxos/client-protocol");
var import_invariant2 = require("@dxos/invariant");
var import_log2 = require("@dxos/log");
var import_rpc = require("@dxos/rpc");
var import_util = require("@dxos/util");
function _ts_decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/worker/worker-session.ts";
var WorkerSession = class {
  constructor({ serviceHost, systemPort, appPort, shellPort, readySignal }) {
    this._startTrigger = new import_async2.Trigger();
    this.onClose = new import_util.Callback();
    (0, import_invariant2.invariant)(serviceHost, void 0, {
      F: __dxlog_file,
      L: 54,
      S: this,
      A: [
        "serviceHost",
        ""
      ]
    });
    this._serviceHost = serviceHost;
    const middleware = {
      handleCall: async (method, params, handler) => {
        const error = await readySignal.wait({
          timeout: import_client_protocol2.PROXY_CONNECTION_TIMEOUT
        });
        if (error) {
          throw error;
        }
        return handler(method, params);
      },
      handleStream: async (method, params, handler) => {
        const error = await readySignal.wait({
          timeout: import_client_protocol2.PROXY_CONNECTION_TIMEOUT
        });
        if (error) {
          throw error;
        }
        return handler(method, params);
      }
    };
    this._clientRpc = new import_chunk_LMGLGOUU.ClientRpcServer({
      serviceRegistry: this._serviceHost.serviceRegistry,
      port: appPort,
      ...middleware
    });
    this._shellClientRpc = shellPort ? new import_chunk_LMGLGOUU.ClientRpcServer({
      serviceRegistry: this._serviceHost.serviceRegistry,
      port: shellPort,
      ...middleware
    }) : void 0;
    this._iframeRpc = (0, import_rpc.createProtoRpcPeer)({
      requested: import_client_protocol2.iframeServiceBundle,
      exposed: import_client_protocol2.workerServiceBundle,
      handlers: {
        WorkerService: {
          start: async (request) => {
            this.origin = request.origin;
            this.lockKey = request.lockKey;
            this.observabilityGroup = request.observabilityGroup;
            this.signalTelemetryEnabled = request.signalTelemetryEnabled;
            this._startTrigger.wake();
          },
          stop: async () => {
            setTimeout(async () => {
              try {
                await this.close();
              } catch (err) {
                import_log2.log.catch(err, void 0, {
                  F: __dxlog_file,
                  L: 108,
                  S: this,
                  C: (f, a) => f(...a)
                });
              }
            });
          }
        }
      },
      port: systemPort,
      timeout: 1e3
    });
    this.bridgeService = this._iframeRpc.rpc.BridgeService;
  }
  async open() {
    import_log2.log.info("opening...", void 0, {
      F: __dxlog_file,
      L: 122,
      S: this,
      C: (f, a) => f(...a)
    });
    await Promise.all([
      this._clientRpc.open(),
      this._iframeRpc.open(),
      this._maybeOpenShell()
    ]);
    await this._startTrigger.wait({
      timeout: import_client_protocol2.PROXY_CONNECTION_TIMEOUT
    });
    if (this.lockKey) {
      void this._afterLockReleases(this.lockKey, () => this.close());
    }
    import_log2.log.info("opened", void 0, {
      F: __dxlog_file,
      L: 133,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  async close() {
    import_log2.log.info("closing...", void 0, {
      F: __dxlog_file,
      L: 137,
      S: this,
      C: (f, a) => f(...a)
    });
    try {
      await this.onClose.callIfSet();
    } catch (err) {
      import_log2.log.catch(err, void 0, {
        F: __dxlog_file,
        L: 141,
        S: this,
        C: (f, a) => f(...a)
      });
    }
    await Promise.all([
      this._clientRpc.close(),
      this._iframeRpc.close()
    ]);
    import_log2.log.info("closed", void 0, {
      F: __dxlog_file,
      L: 145,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  async _maybeOpenShell() {
    try {
      this._shellClientRpc && await (0, import_async2.asyncTimeout)(this._shellClientRpc.open(), 1e3);
    } catch {
      import_log2.log.info("No shell connected.", void 0, {
        F: __dxlog_file,
        L: 152,
        S: this,
        C: (f, a) => f(...a)
      });
    }
  }
  _afterLockReleases(lockKey, callback) {
    return navigator.locks.request(lockKey, () => {
    }).then(callback);
  }
};
_ts_decorate([
  import_log2.logInfo
], WorkerSession.prototype, "origin", void 0);
_ts_decorate([
  import_log2.logInfo
], WorkerSession.prototype, "lockKey", void 0);
var __dxlog_file2 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/worker/worker-runtime.ts";
var WorkerRuntime = class {
  constructor({ channel = import_client_protocol.DEFAULT_WORKER_BROADCAST_CHANNEL, configProvider, acquireLock, releaseLock, onStop }) {
    this._transportFactory = new import_network_manager.RtcTransportProxyFactory();
    this._ready = new import_async.Trigger();
    this._sessions = /* @__PURE__ */ new Set();
    this._signalMetadataTags = {
      runtime: "worker-runtime"
    };
    this._signalTelemetryEnabled = false;
    this._configProvider = configProvider;
    this._acquireLock = acquireLock;
    this._releaseLock = releaseLock;
    this._onStop = onStop;
    this._channel = channel;
    this._clientServices = new import_chunk_LMGLGOUU.ClientServicesHost({
      callbacks: {
        onReset: async () => this.stop()
      }
    });
  }
  get host() {
    return this._clientServices;
  }
  async start() {
    (0, import_log.log)("starting...", void 0, {
      F: __dxlog_file2,
      L: 84,
      S: this,
      C: (f, a) => f(...a)
    });
    try {
      this._broadcastChannel = new BroadcastChannel(this._channel);
      this._broadcastChannel.postMessage({
        action: "stop"
      });
      this._broadcastChannel.onmessage = async (event) => {
        if (event.data?.action === "stop") {
          await this.stop();
        }
      };
      await this._acquireLock();
      this._config = await this._configProvider();
      const signals = this._config.get("runtime.services.signaling");
      this._clientServices.initialize({
        config: this._config,
        signalManager: this._config.get("runtime.client.edgeFeatures")?.signaling ? void 0 : signals ? new import_messaging.WebsocketSignalManager(signals, () => this._signalTelemetryEnabled ? this._signalMetadataTags : {}) : new import_messaging.MemorySignalManager(new import_messaging.MemorySignalManagerContext()),
        transportFactory: this._transportFactory
      });
      await this._clientServices.open(new import_context.Context(void 0, {
        F: __dxlog_file2,
        L: 107
      }));
      this._ready.wake(void 0);
      (0, import_log.log)("started", void 0, {
        F: __dxlog_file2,
        L: 109,
        S: this,
        C: (f, a) => f(...a)
      });
      (0, import_messaging.setIdentityTags)({
        identityService: this._clientServices.services.IdentityService,
        devicesService: this._clientServices.services.DevicesService,
        setTag: (k, v) => {
          this._signalMetadataTags[k] = v;
        }
      });
    } catch (err) {
      this._ready.wake(err);
      import_log.log.error("starting", err, {
        F: __dxlog_file2,
        L: 119,
        S: this,
        C: (f, a) => f(...a)
      });
    }
  }
  async stop() {
    this._releaseLock();
    this._broadcastChannel?.close();
    this._broadcastChannel = void 0;
    await this._clientServices.close();
    await this._onStop?.();
  }
  /**
  * Create a new session.
  */
  async createSession({ appPort, systemPort, shellPort }) {
    const session = new WorkerSession({
      serviceHost: this._clientServices,
      appPort,
      systemPort,
      shellPort,
      readySignal: this._ready
    });
    session.onClose.set(async () => {
      this._sessions.delete(session);
      if (this._sessions.size === 0) {
        await this.stop();
      } else {
        this._reconnectWebrtc();
      }
    });
    await session.open();
    (0, import_invariant.invariant)(!this._signalMetadataTags.origin || this._signalMetadataTags.origin === session.origin, `worker origin changed from ${this._signalMetadataTags.origin} to ${session.origin}?`, {
      F: __dxlog_file2,
      L: 157,
      S: this,
      A: [
        "!this._signalMetadataTags.origin || this._signalMetadataTags.origin === session.origin",
        "`worker origin changed from ${this._signalMetadataTags.origin} to ${session.origin}?`"
      ]
    });
    if (session.observabilityGroup) {
      this._signalMetadataTags.group = session.observabilityGroup;
    }
    this._signalTelemetryEnabled = session.signalTelemetryEnabled ?? false;
    this._signalMetadataTags.origin = session.origin;
    this._sessions.add(session);
    this._reconnectWebrtc();
  }
  /**
  * Selects one of the existing session for WebRTC networking.
  */
  _reconnectWebrtc() {
    (0, import_log.log)("reconnecting webrtc...", void 0, {
      F: __dxlog_file2,
      L: 175,
      S: this,
      C: (f, a) => f(...a)
    });
    if (this._sessionForNetworking) {
      if (!this._sessions.has(this._sessionForNetworking)) {
        this._sessionForNetworking = void 0;
      }
    }
    if (!this._sessionForNetworking) {
      const selected = Array.from(this._sessions).find((session) => session.bridgeService);
      if (selected) {
        this._sessionForNetworking = selected;
        this._transportFactory.setBridgeService(selected.bridgeService);
      } else {
        this._transportFactory.setBridgeService(void 0);
      }
    }
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ClientRpcServer,
  ClientServicesHost,
  DataSpace,
  DataSpaceManager,
  DeviceInvitationProtocol,
  DevtoolsHostEvents,
  DevtoolsServiceImpl,
  DiagnosticsCollector,
  EdgeAgentManager,
  EdgeAgentServiceImpl,
  EdgeFeedReplicator,
  Identity,
  IdentityManager,
  IdentityServiceImpl,
  InvitationsHandler,
  InvitationsManager,
  InvitationsServiceImpl,
  Lock,
  ServiceContext,
  ServiceRegistry,
  SpaceInvitationProtocol,
  SpacesServiceImpl,
  TrustedKeySetAuthVerifier,
  WorkerRuntime,
  WorkerSession,
  createAdmissionKeypair,
  createAuthProvider,
  createCollectDiagnosticsBroadcastHandler,
  createCollectDiagnosticsBroadcastSender,
  createDiagnostics,
  createLevel,
  createStorageObjects,
  decodeProfileArchive,
  encodeProfileArchive,
  exportProfileData,
  getNetworkPeers,
  importProfileData,
  isLocked,
  subscribeToFeedBlocks,
  subscribeToFeeds,
  subscribeToNetworkStatus,
  subscribeToNetworkTopics,
  subscribeToSignal,
  subscribeToSpaces,
  subscribeToSwarmInfo
});
//# sourceMappingURL=index.cjs.map
