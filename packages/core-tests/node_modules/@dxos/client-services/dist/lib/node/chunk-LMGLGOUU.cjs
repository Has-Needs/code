"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var chunk_LMGLGOUU_exports = {};
__export(chunk_LMGLGOUU_exports, {
  ClientRpcServer: () => ClientRpcServer,
  ClientServicesHost: () => ClientServicesHost,
  DataSpace: () => DataSpace,
  DataSpaceManager: () => DataSpaceManager,
  DeviceInvitationProtocol: () => DeviceInvitationProtocol,
  DevtoolsHostEvents: () => DevtoolsHostEvents,
  DevtoolsServiceImpl: () => DevtoolsServiceImpl,
  DiagnosticsCollector: () => DiagnosticsCollector,
  EdgeAgentManager: () => EdgeAgentManager,
  EdgeAgentServiceImpl: () => EdgeAgentServiceImpl,
  EdgeFeedReplicator: () => EdgeFeedReplicator,
  Identity: () => Identity,
  IdentityManager: () => IdentityManager,
  IdentityServiceImpl: () => IdentityServiceImpl,
  InvitationsHandler: () => InvitationsHandler,
  InvitationsManager: () => InvitationsManager,
  InvitationsServiceImpl: () => InvitationsServiceImpl,
  Lock: () => Lock,
  ServiceContext: () => ServiceContext,
  ServiceRegistry: () => ServiceRegistry,
  SpaceInvitationProtocol: () => SpaceInvitationProtocol,
  SpacesServiceImpl: () => SpacesServiceImpl,
  TrustedKeySetAuthVerifier: () => TrustedKeySetAuthVerifier,
  createAdmissionKeypair: () => createAdmissionKeypair,
  createAuthProvider: () => createAuthProvider,
  createCollectDiagnosticsBroadcastHandler: () => createCollectDiagnosticsBroadcastHandler,
  createCollectDiagnosticsBroadcastSender: () => createCollectDiagnosticsBroadcastSender,
  createDiagnostics: () => createDiagnostics,
  createLevel: () => createLevel,
  createStorageObjects: () => createStorageObjects,
  decodeProfileArchive: () => decodeProfileArchive,
  encodeProfileArchive: () => encodeProfileArchive,
  exportProfileData: () => exportProfileData,
  getNetworkPeers: () => getNetworkPeers,
  importProfileData: () => importProfileData,
  isLocked: () => isLocked,
  subscribeToFeedBlocks: () => subscribeToFeedBlocks,
  subscribeToFeeds: () => subscribeToFeeds,
  subscribeToNetworkStatus: () => subscribeToNetworkStatus,
  subscribeToNetworkTopics: () => subscribeToNetworkTopics,
  subscribeToSignal: () => subscribeToSignal,
  subscribeToSpaces: () => subscribeToSpaces,
  subscribeToSwarmInfo: () => subscribeToSwarmInfo
});
module.exports = __toCommonJS(chunk_LMGLGOUU_exports);
var import_async = require("@dxos/async");
var import_stream = require("@dxos/codec-protobuf/stream");
var import_feed_store = require("@dxos/feed-store");
var import_keys = require("@dxos/keys");
var import_log = require("@dxos/log");
var import_util = require("@dxos/util");
var import_stream2 = require("@dxos/codec-protobuf/stream");
var import_context = require("@dxos/context");
var import_keys2 = require("@dxos/keys");
var import_stream3 = require("@dxos/codec-protobuf/stream");
var import_async2 = require("@dxos/async");
var import_stream4 = require("@dxos/codec-protobuf/stream");
var import_async3 = require("@dxos/async");
var import_stream5 = require("@dxos/codec-protobuf/stream");
var import_stream6 = require("@dxos/codec-protobuf/stream");
var import_async4 = require("@dxos/async");
var import_codec_protobuf = require("@dxos/codec-protobuf");
var import_credentials = require("@dxos/credentials");
var import_invariant = require("@dxos/invariant");
var import_protocols = require("@dxos/protocols");
var import_services = require("@dxos/protocols/proto/dxos/client/services");
var import_tracing = require("@dxos/tracing");
var import_services2 = require("@dxos/protocols/proto/dxos/client/services");
var import_client_protocol = require("@dxos/client-protocol");
var import_config = require("@dxos/config");
var import_services3 = require("@dxos/protocols/proto/dxos/client/services");
var import_tracing2 = require("@dxos/tracing");
var import_util2 = require("@dxos/util");
var import_async5 = require("@dxos/async");
var import_context2 = require("@dxos/context");
var import_credentials2 = require("@dxos/credentials");
var import_log2 = require("@dxos/log");
var import_proto = require("@dxos/protocols/proto");
var import_cbor_x = require("cbor-x");
var import_async6 = require("@dxos/async");
var import_context3 = require("@dxos/context");
var import_edge_client = require("@dxos/edge-client");
var import_invariant2 = require("@dxos/invariant");
var import_keys3 = require("@dxos/keys");
var import_log3 = require("@dxos/log");
var import_protocols2 = require("@dxos/protocols");
var import_buf = require("@dxos/protocols/buf");
var import_messenger_pb = require("@dxos/protocols/buf/dxos/edge/messenger_pb");
var import_services4 = require("@dxos/protocols/proto/dxos/client/services");
var import_util3 = require("@dxos/util");
var import_automerge = require("@automerge/automerge");
var import_async7 = require("@dxos/async");
var import_client_protocol2 = require("@dxos/client-protocol");
var import_context4 = require("@dxos/context");
var import_debug = require("@dxos/debug");
var import_echo_pipeline = require("@dxos/echo-pipeline");
var import_echo_protocol = require("@dxos/echo-protocol");
var import_invariant3 = require("@dxos/invariant");
var import_keys4 = require("@dxos/keys");
var import_log4 = require("@dxos/log");
var import_protocols3 = require("@dxos/protocols");
var import_services5 = require("@dxos/protocols/proto/dxos/client/services");
var import_credentials3 = require("@dxos/protocols/proto/dxos/halo/credentials");
var import_timeframe = require("@dxos/timeframe");
var import_tracing3 = require("@dxos/tracing");
var import_util4 = require("@dxos/util");
var import_async8 = require("@dxos/async");
var import_context5 = require("@dxos/context");
var import_credentials4 = require("@dxos/credentials");
var import_invariant4 = require("@dxos/invariant");
var import_services6 = require("@dxos/protocols/proto/dxos/client/services");
var import_async9 = require("@dxos/async");
var import_context6 = require("@dxos/context");
var import_credentials5 = require("@dxos/credentials");
var import_invariant5 = require("@dxos/invariant");
var import_keys5 = require("@dxos/keys");
var import_log5 = require("@dxos/log");
var import_protocols4 = require("@dxos/protocols");
var import_proto2 = require("@dxos/protocols/proto");
var import_teleport = require("@dxos/teleport");
var import_util5 = require("@dxos/util");
var import_async10 = require("@dxos/async");
var import_client_protocol3 = require("@dxos/client-protocol");
var import_credentials6 = require("@dxos/credentials");
var import_feed_store2 = require("@dxos/feed-store");
var import_invariant6 = require("@dxos/invariant");
var import_keys6 = require("@dxos/keys");
var import_log6 = require("@dxos/log");
var import_credentials7 = require("@dxos/protocols/proto/dxos/halo/credentials");
var import_timeframe2 = require("@dxos/timeframe");
var import_tracing4 = require("@dxos/tracing");
var import_util6 = require("@dxos/util");
var import_credentials8 = require("@dxos/credentials");
var import_keys7 = require("@dxos/keys");
var import_log7 = require("@dxos/log");
var import_automerge_repo = require("@automerge/automerge-repo");
var import_async11 = require("@dxos/async");
var import_client_protocol4 = require("@dxos/client-protocol");
var import_context7 = require("@dxos/context");
var import_credentials9 = require("@dxos/credentials");
var import_echo_pipeline2 = require("@dxos/echo-pipeline");
var import_echo_protocol2 = require("@dxos/echo-protocol");
var import_echo_schema = require("@dxos/echo-schema");
var import_feed_store3 = require("@dxos/feed-store");
var import_invariant7 = require("@dxos/invariant");
var import_keys8 = require("@dxos/keys");
var import_log8 = require("@dxos/log");
var import_protocols5 = require("@dxos/protocols");
var import_services7 = require("@dxos/protocols/proto/dxos/client/services");
var import_metadata = require("@dxos/protocols/proto/dxos/echo/metadata");
var import_credentials10 = require("@dxos/protocols/proto/dxos/halo/credentials");
var import_teleport_extension_gossip = require("@dxos/teleport-extension-gossip");
var import_tracing5 = require("@dxos/tracing");
var import_util7 = require("@dxos/util");
var import_credentials11 = require("@dxos/credentials");
var import_debug2 = require("@dxos/debug");
var import_credentials12 = require("@dxos/protocols/proto/dxos/halo/credentials");
var import_timeframe3 = require("@dxos/timeframe");
var import_async12 = require("@dxos/async");
var import_stream7 = require("@dxos/codec-protobuf/stream");
var import_credentials13 = require("@dxos/credentials");
var import_debug3 = require("@dxos/debug");
var import_feed_store4 = require("@dxos/feed-store");
var import_invariant8 = require("@dxos/invariant");
var import_keys9 = require("@dxos/keys");
var import_log9 = require("@dxos/log");
var import_protocols6 = require("@dxos/protocols");
var import_services8 = require("@dxos/protocols/proto/dxos/client/services");
var import_tracing6 = require("@dxos/tracing");
var import_context8 = require("@dxos/context");
var import_invariant9 = require("@dxos/invariant");
var import_protocols7 = require("@dxos/protocols");
var import_invariant10 = require("@dxos/invariant");
var import_log10 = require("@dxos/log");
var import_protocols8 = require("@dxos/protocols");
var import_platform = __toESM(require("platform"));
var import_async13 = require("@dxos/async");
var import_context9 = require("@dxos/context");
var import_credentials14 = require("@dxos/credentials");
var import_invariant11 = require("@dxos/invariant");
var import_keys10 = require("@dxos/keys");
var import_log11 = require("@dxos/log");
var import_protocols9 = require("@dxos/protocols");
var import_services9 = require("@dxos/protocols/proto/dxos/client/services");
var import_credentials15 = require("@dxos/protocols/proto/dxos/halo/credentials");
var import_teleport_extension_gossip2 = require("@dxos/teleport-extension-gossip");
var import_timeframe4 = require("@dxos/timeframe");
var import_tracing7 = require("@dxos/tracing");
var import_util8 = require("@dxos/util");
var import_async14 = require("@dxos/async");
var import_stream8 = require("@dxos/codec-protobuf/stream");
var import_context10 = require("@dxos/context");
var import_credentials16 = require("@dxos/credentials");
var import_invariant12 = require("@dxos/invariant");
var import_log12 = require("@dxos/log");
var import_services10 = require("@dxos/protocols/proto/dxos/client/services");
var import_util9 = require("@dxos/util");
var import_credentials17 = require("@dxos/credentials");
var import_invariant13 = require("@dxos/invariant");
var import_protocols10 = require("@dxos/protocols");
var import_services11 = require("@dxos/protocols/proto/dxos/client/services");
var import_async15 = require("@dxos/async");
var import_client_protocol5 = require("@dxos/client-protocol");
var import_context11 = require("@dxos/context");
var import_crypto = require("@dxos/crypto");
var import_invariant14 = require("@dxos/invariant");
var import_keys11 = require("@dxos/keys");
var import_log13 = require("@dxos/log");
var import_network_manager = require("@dxos/network-manager");
var import_protocols11 = require("@dxos/protocols");
var import_services12 = require("@dxos/protocols/proto/dxos/client/services");
var import_invitations = require("@dxos/protocols/proto/dxos/halo/invitations");
var import_invitations2 = require("@dxos/protocols/proto/dxos/halo/invitations");
var import_tracing8 = require("@dxos/tracing");
var import_util10 = require("@dxos/util");
var import_async16 = require("@dxos/async");
var import_crypto2 = require("@dxos/crypto");
var import_invariant15 = require("@dxos/invariant");
var import_keys12 = require("@dxos/keys");
var import_log14 = require("@dxos/log");
var import_protocols12 = require("@dxos/protocols");
var import_proto3 = require("@dxos/protocols/proto");
var import_services13 = require("@dxos/protocols/proto/dxos/client/services");
var import_context12 = require("@dxos/context");
var import_services14 = require("@dxos/protocols/proto/dxos/client/services");
var import_async17 = require("@dxos/async");
var import_context13 = require("@dxos/context");
var import_invariant16 = require("@dxos/invariant");
var import_log15 = require("@dxos/log");
var import_protocols13 = require("@dxos/protocols");
var import_proto4 = require("@dxos/protocols/proto");
var import_invitations3 = require("@dxos/protocols/proto/dxos/halo/invitations");
var import_teleport2 = require("@dxos/teleport");
var import_async18 = require("@dxos/async");
var import_context14 = require("@dxos/context");
var import_crypto3 = require("@dxos/crypto");
var import_invariant17 = require("@dxos/invariant");
var import_keys13 = require("@dxos/keys");
var import_log16 = require("@dxos/log");
var import_protocols14 = require("@dxos/protocols");
var import_proto5 = require("@dxos/protocols/proto");
var import_services15 = require("@dxos/protocols/proto/dxos/client/services");
var import_invitations4 = require("@dxos/protocols/proto/dxos/halo/invitations");
var import_teleport3 = require("@dxos/teleport");
var import_async19 = require("@dxos/async");
var import_log17 = require("@dxos/log");
var import_services16 = require("@dxos/protocols/proto/dxos/client/services");
var import_invariant18 = require("@dxos/invariant");
var import_keys14 = require("@dxos/keys");
var import_log18 = require("@dxos/log");
var import_invitations5 = require("@dxos/protocols/proto/dxos/halo/invitations");
var import_util11 = require("@dxos/util");
var import_stream9 = require("@dxos/codec-protobuf/stream");
var import_services17 = require("@dxos/protocols/proto/dxos/client/services");
var import_tracing9 = require("@dxos/tracing");
var import_credentials18 = require("@dxos/credentials");
var import_feed_store5 = require("@dxos/feed-store");
var import_invariant19 = require("@dxos/invariant");
var import_log19 = require("@dxos/log");
var import_protocols15 = require("@dxos/protocols");
var import_services18 = require("@dxos/protocols/proto/dxos/client/services");
var import_credentials19 = require("@dxos/protocols/proto/dxos/halo/credentials");
var import_async20 = require("@dxos/async");
var import_client_protocol6 = require("@dxos/client-protocol");
var import_context15 = require("@dxos/context");
var import_credentials20 = require("@dxos/credentials");
var import_echo_pipeline3 = require("@dxos/echo-pipeline");
var import_invariant20 = require("@dxos/invariant");
var import_keys15 = require("@dxos/keys");
var import_log20 = require("@dxos/log");
var import_services19 = require("@dxos/protocols/proto/dxos/client/services");
var import_credentials21 = require("@dxos/protocols/proto/dxos/halo/credentials");
var import_invariant21 = require("@dxos/invariant");
var import_lock_file = require("@dxos/lock-file");
var import_log21 = require("@dxos/log");
var import_codec_protobuf2 = require("@dxos/codec-protobuf");
var import_debug4 = require("@dxos/debug");
var import_rpc = require("@dxos/rpc");
var import_tracing10 = require("@dxos/tracing");
var import_async21 = require("@dxos/async");
var import_context16 = require("@dxos/context");
var import_invariant22 = require("@dxos/invariant");
var import_keys16 = require("@dxos/keys");
var import_log22 = require("@dxos/log");
var import_protocols16 = require("@dxos/protocols");
var import_services20 = require("@dxos/protocols/proto/dxos/client/services");
var import_metadata2 = require("@dxos/protocols/proto/dxos/echo/metadata");
var import_stream10 = require("@dxos/codec-protobuf/stream");
var import_protocols17 = require("@dxos/protocols");
var import_services21 = require("@dxos/protocols/proto/dxos/client/services");
var import_async22 = require("@dxos/async");
var import_context17 = require("@dxos/context");
var import_credentials22 = require("@dxos/credentials");
var import_debug5 = require("@dxos/debug");
var import_echo_pipeline4 = require("@dxos/echo-pipeline");
var import_edge_client2 = require("@dxos/edge-client");
var import_feed_store6 = require("@dxos/feed-store");
var import_invariant23 = require("@dxos/invariant");
var import_keyring = require("@dxos/keyring");
var import_keys17 = require("@dxos/keys");
var import_log23 = require("@dxos/log");
var import_protocols18 = require("@dxos/protocols");
var import_services22 = require("@dxos/protocols/proto/dxos/client/services");
var import_teleport_extension_object_sync = require("@dxos/teleport-extension-object-sync");
var import_tracing11 = require("@dxos/tracing");
var import_util12 = require("@dxos/util");
var import_credentials23 = require("@dxos/credentials");
var import_crypto4 = require("@dxos/crypto");
var import_invariant24 = require("@dxos/invariant");
var import_keys18 = require("@dxos/keys");
var import_log24 = require("@dxos/log");
var import_protocols19 = require("@dxos/protocols");
var import_proto6 = require("@dxos/protocols/proto");
var import_timeframe5 = require("@dxos/timeframe");
var import_protocols20 = require("@dxos/protocols");
var import_config2 = require("@dxos/protocols/proto/dxos/config");
var import_random_access_storage = require("@dxos/random-access-storage");
var import_client_protocol7 = require("@dxos/client-protocol");
var import_config3 = require("@dxos/protocols/proto/dxos/config");
var import_util13 = require("@dxos/util");
var import_node_path = __toESM(require("node:path"));
var import_keys19 = require("@dxos/keys");
var import_kv_store = require("@dxos/kv-store");
var import_automerge_repo2 = require("@automerge/automerge-repo");
var import_invariant25 = require("@dxos/invariant");
var import_log25 = require("@dxos/log");
var import_protocols21 = require("@dxos/protocols");
var import_util14 = require("@dxos/util");
var import_async23 = require("@dxos/async");
var import_client_protocol8 = require("@dxos/client-protocol");
var import_context18 = require("@dxos/context");
var import_edge_client3 = require("@dxos/edge-client");
var import_invariant26 = require("@dxos/invariant");
var import_keys20 = require("@dxos/keys");
var import_log26 = require("@dxos/log");
var import_messaging = require("@dxos/messaging");
var import_network_manager2 = require("@dxos/network-manager");
var import_protocols22 = require("@dxos/protocols");
var import_services23 = require("@dxos/protocols/proto/dxos/client/services");
var import_tracing12 = require("@dxos/tracing");
var import_websocket_rpc = require("@dxos/websocket-rpc");
var import_async24 = require("@dxos/async");
var import_stream11 = require("@dxos/codec-protobuf/stream");
var import_invariant27 = require("@dxos/invariant");
var import_services24 = require("@dxos/protocols/proto/dxos/client/services");
var import_async25 = require("@dxos/async");
var import_stream12 = require("@dxos/codec-protobuf/stream");
var import_keys21 = require("@dxos/keys");
var import_util15 = require("@dxos/util");
var import_async26 = require("@dxos/async");
var import_stream13 = require("@dxos/codec-protobuf/stream");
var import_keys22 = require("@dxos/keys");
var import_log27 = require("@dxos/log");
var import_services25 = require("@dxos/protocols/proto/dxos/client/services");
var import_util16 = require("@dxos/util");
var import_stream14 = require("@dxos/codec-protobuf/stream");
var import_stream15 = require("@dxos/codec-protobuf/stream");
var import_services26 = require("@dxos/protocols/proto/dxos/client/services");
var import_util17 = require("@dxos/util");
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/devtools/feeds.ts";
var subscribeToFeeds = ({ feedStore, spaceManager }, { feedKeys }) => {
  return new import_stream.Stream(({ next }) => {
    const subscriptions = new import_async.SubscriptionList();
    const feedMap = new import_util.ComplexMap(import_keys.PublicKey.hash);
    const update = () => {
      const { feeds } = feedStore;
      feeds.filter((feed) => !feedKeys?.length || feedKeys.some((feedKey) => feedKey.equals(feed.key))).forEach((feed) => {
        if (!feedMap.has(feed.key)) {
          feedMap.set(feed.key, {
            feed
          });
          feed.on("close", update);
          subscriptions.add(() => feed.off("close", update));
        }
        if (!feedMap.get(feed.key)?.owner) {
          feedMap.get(feed.key).owner = findFeedOwner(spaceManager, feed.key);
        }
      });
      next({
        feeds: Array.from(feedMap.values()).map(({ feed, owner }) => ({
          feedKey: feed.key,
          length: feed.properties.length,
          bytes: feed.core.byteLength,
          downloaded: feed.core.bitfield?.data.toBuffer() ?? new Uint8Array(),
          owner
        }))
      });
    };
    subscriptions.add(feedStore.feedOpened.on(update));
    update();
    return () => {
      subscriptions.clear();
    };
  });
};
var findFeedOwner = (spaceManager, feedKey) => {
  const feedInfo = [
    ...spaceManager.spaces.values()
  ].flatMap((space) => [
    ...space.spaceState.feeds.values()
  ]).find((feed) => feed.key.equals(feedKey));
  (0, import_log.log)("feeds", {
    feedInfo,
    key: feedKey.truncate(),
    allSpaces: spaceManager.spaces.size
  }, {
    F: __dxlog_file,
    L: 75,
    S: void 0,
    C: (f, a) => f(...a)
  });
  if (!feedInfo) {
    return void 0;
  }
  return {
    identity: feedInfo.assertion.identityKey,
    device: feedInfo.assertion.deviceKey
  };
};
var subscribeToFeedBlocks = ({ feedStore }, { feedKey, maxBlocks = 10 }) => {
  return new import_stream.Stream(({ next }) => {
    if (!feedKey) {
      return;
    }
    const subscriptions = new import_async.SubscriptionList();
    const timeout = setTimeout(async () => {
      const feed = feedStore.getFeed(feedKey);
      if (!feed) {
        return;
      }
      const update = async () => {
        if (!feed.properties.length) {
          next({
            blocks: []
          });
          return;
        }
        const iterator = new import_feed_store.FeedIterator(feed);
        await iterator.open();
        const blocks = [];
        for await (const block of iterator) {
          blocks.push(block);
          if (blocks.length >= feed.properties.length) {
            break;
          }
        }
        next({
          blocks: blocks.slice(-maxBlocks)
        });
        await iterator.close();
      };
      feed.on("append", update);
      subscriptions.add(() => feed.off("append", update));
      feed.on("truncate", update);
      subscriptions.add(() => feed.off("truncate", update));
      await update();
    });
    return () => {
      subscriptions.clear();
      clearTimeout(timeout);
    };
  });
};
var __dxlog_file2 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/devtools/network.ts";
var subscribeToNetworkStatus = ({ signalManager }) => new import_stream2.Stream(({ next, close }) => {
  const update = () => {
    try {
      const status = signalManager.getStatus?.();
      next({
        servers: status
      });
    } catch (err) {
      close(err);
    }
  };
  signalManager.statusChanged?.on(() => update());
  update();
});
var subscribeToSignal = ({ signalManager }) => new import_stream2.Stream(({ next }) => {
  const ctx = new import_context.Context(void 0, {
    F: __dxlog_file2,
    L: 36
  });
  signalManager.onMessage.on(ctx, (message) => {
    next({
      message: {
        author: import_keys2.PublicKey.from(message.author.peerKey).asUint8Array(),
        recipient: import_keys2.PublicKey.from(message.recipient.peerKey).asUint8Array(),
        payload: message.payload
      },
      receivedAt: /* @__PURE__ */ new Date()
    });
  });
  signalManager.swarmEvent.on(ctx, (swarmEvent) => {
    next({
      swarmEvent: swarmEvent.peerAvailable ? {
        peerAvailable: {
          peer: import_keys2.PublicKey.from(swarmEvent.peerAvailable.peer.peerKey).asUint8Array(),
          since: swarmEvent.peerAvailable.since
        }
      } : {
        peerLeft: {
          peer: import_keys2.PublicKey.from(swarmEvent.peerLeft.peer.peerKey).asUint8Array()
        }
      },
      topic: swarmEvent.topic.asUint8Array(),
      receivedAt: /* @__PURE__ */ new Date()
    });
  });
  return () => {
    return ctx.dispose();
  };
});
var subscribeToNetworkTopics = ({ networkManager }) => new import_stream2.Stream(({ next, close }) => {
  const update = () => {
    try {
      const topics = networkManager.topics;
      const labeledTopics = topics.map((topic) => ({
        topic,
        label: networkManager.getSwarm(topic)?.label ?? topic.toHex()
      }));
      next({
        topics: labeledTopics
      });
    } catch (err) {
      close(err);
    }
  };
  networkManager.topicsUpdated.on(update);
  update();
});
var subscribeToSwarmInfo = ({ networkManager }) => new import_stream2.Stream(({ next }) => {
  const update = () => {
    const info = networkManager.connectionLog?.swarms;
    if (info) {
      next({
        data: info
      });
    }
  };
  networkManager.connectionLog?.update.on(update);
  update();
});
var getNetworkPeers = ({ networkManager }, request) => {
  if (!request.topic) {
    throw new Error("Expected a network topic");
  }
  const map = networkManager.getSwarmMap(import_keys2.PublicKey.from(request.topic));
  return {
    peers: map?.peers.map((peer) => ({
      ...peer,
      connections: peer.connections.map((connection) => connection.asUint8Array())
    }))
  };
};
var subscribeToSpaces = (context, { spaceKeys = [] }) => {
  return new import_stream3.Stream(({ next }) => {
    let unsubscribe;
    const update = async () => {
      const spaces = [
        ...context.spaceManager.spaces.values()
      ];
      const filteredSpaces = spaces.filter((space) => !spaceKeys?.length || spaceKeys.some((spaceKey) => spaceKey.equals(space.key)));
      next({
        spaces: filteredSpaces.map((space) => {
          const spaceMetadata = context.metadataStore.spaces.find((spaceMetadata2) => spaceMetadata2.key.equals(space.key));
          return {
            key: space.key,
            isOpen: space.isOpen,
            timeframe: spaceMetadata?.dataTimeframe,
            genesisFeed: space.genesisFeedKey,
            controlFeed: space.controlFeedKey,
            dataFeed: space.dataFeedKey
          };
        })
      });
    };
    const timeout = setTimeout(async () => {
      await context.initialized.wait();
      unsubscribe = context.dataSpaceManager.updated.on(() => update());
      await update();
    });
    return () => {
      unsubscribe?.();
      clearTimeout(timeout);
    };
  });
};
var subscribeToKeyringKeys = ({ keyring }) => new import_stream5.Stream(({ next, ctx }) => {
  const update = async () => {
    next({
      keys: await keyring.list()
    });
  };
  keyring.keysUpdate.on(ctx, update);
  (0, import_async3.scheduleTask)(ctx, update);
});
var subscribeToMetadata = ({ context }) => new import_stream6.Stream(({ next, ctx }) => {
  context.metadataStore.update.on(ctx, (data) => next({
    metadata: data
  }));
  next({
    metadata: context.metadataStore.metadata
  });
});
var DevtoolsHostEvents = class {
  constructor() {
    this.ready = new import_async2.Event();
  }
};
var DevtoolsServiceImpl = class {
  constructor(params) {
    this.params = params;
  }
  events(request) {
    return new import_stream4.Stream(({ next }) => {
      this.params.events.ready.on(() => {
        next({
          ready: {}
        });
      });
    });
  }
  async getConfig(request) {
    return {
      config: JSON.stringify(this.params.config.values)
    };
  }
  async getStorageInfo() {
    const storageUsage = await this.params.context.storage.getDiskInfo?.() ?? {
      used: 0
    };
    const navigatorInfo = typeof navigator === "object" ? await navigator.storage.estimate() : void 0;
    return {
      type: this.params.context.storage.type,
      storageUsage: storageUsage.used,
      originUsage: navigatorInfo?.usage ?? 0,
      usageQuota: navigatorInfo?.quota ?? 0
    };
  }
  async getBlobs() {
    return {
      blobs: await this.params.context.blobStore.list()
    };
  }
  async getSnapshots() {
    return {
      snapshots: []
    };
  }
  resetStorage(request) {
    throw new Error();
  }
  enableDebugLogging(request) {
    throw new Error();
  }
  disableDebugLogging(request) {
    throw new Error();
  }
  subscribeToKeyringKeys(request) {
    return subscribeToKeyringKeys({
      keyring: this.params.context.keyring
    });
  }
  subscribeToCredentialMessages(request) {
    throw new Error();
  }
  subscribeToSpaces(request) {
    return subscribeToSpaces(this.params.context, request);
  }
  subscribeToItems(request) {
    throw new Error();
  }
  subscribeToFeeds(request) {
    return subscribeToFeeds(this.params.context, request);
  }
  subscribeToFeedBlocks(request) {
    return subscribeToFeedBlocks({
      feedStore: this.params.context.feedStore
    }, request);
  }
  getSpaceSnapshot(request) {
    throw new Error();
  }
  saveSpaceSnapshot(request) {
    throw new Error();
  }
  clearSnapshots(request) {
    throw new Error();
  }
  getNetworkPeers(request) {
    throw new Error();
  }
  subscribeToNetworkTopics(request) {
    throw new Error();
  }
  subscribeToSignalStatus(request) {
    return subscribeToNetworkStatus({
      signalManager: this.params.context.signalManager
    });
  }
  subscribeToSignal() {
    return subscribeToSignal({
      signalManager: this.params.context.signalManager
    });
  }
  subscribeToSwarmInfo() {
    return subscribeToSwarmInfo({
      networkManager: this.params.context.networkManager
    });
  }
  subscribeToMetadata() {
    return subscribeToMetadata({
      context: this.params.context
    });
  }
};
var DXOS_VERSION = "0.8.3";
var getPlatform = () => {
  if (process.browser) {
    if (typeof window !== "undefined") {
      const { userAgent } = window.navigator;
      return {
        type: import_services2.Platform.PLATFORM_TYPE.BROWSER,
        userAgent,
        uptime: Math.floor((Date.now() - window.performance.timeOrigin) / 1e3)
      };
    } else {
      return {
        type: import_services2.Platform.PLATFORM_TYPE.SHARED_WORKER,
        uptime: Math.floor((Date.now() - performance.timeOrigin) / 1e3)
      };
    }
  } else {
    const { platform: platform2, version, arch } = process;
    return {
      type: import_services2.Platform.PLATFORM_TYPE.NODE,
      platform: platform2,
      arch,
      runtime: version,
      uptime: Math.floor(process.uptime()),
      memory: process.memoryUsage()
    };
  }
};
var __dxlog_file3 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/diagnostics/diagnostics.ts";
var DEFAULT_TIMEOUT = 1e3;
var createDiagnostics = async (clientServices, serviceContext, config) => {
  const diagnostics = {
    created: (/* @__PURE__ */ new Date()).toISOString(),
    platform: getPlatform(),
    client: {
      version: DXOS_VERSION,
      storage: {
        version: import_protocols.STORAGE_VERSION
      }
    },
    trace: import_tracing.TRACE_PROCESSOR.getDiagnostics()
  };
  await Promise.all([
    (async () => {
      (0, import_invariant.invariant)(clientServices.LoggingService, "SystemService is not available.", {
        F: __dxlog_file3,
        L: 110,
        S: void 0,
        A: [
          "clientServices.LoggingService",
          "'SystemService is not available.'"
        ]
      });
      diagnostics.metrics = await (0, import_codec_protobuf.getFirstStreamValue)(clientServices.LoggingService.queryMetrics({}), {
        timeout: DEFAULT_TIMEOUT
      }).catch(() => void 0);
    })(),
    (async () => {
      diagnostics.storage = await (0, import_async4.asyncTimeout)(getStorageDiagnostics(), DEFAULT_TIMEOUT).catch(() => void 0);
    })(),
    async () => {
      const identity = serviceContext.identityManager.identity;
      if (identity) {
        diagnostics.identity = {
          did: identity.did,
          identityKey: identity.identityKey,
          spaceKey: identity.space.key,
          profile: identity.profileDocument
        };
        const { devices } = await (0, import_codec_protobuf.getFirstStreamValue)(clientServices.DevicesService.queryDevices(), {
          timeout: DEFAULT_TIMEOUT
        }).catch(() => void 0) ?? {};
        diagnostics.devices = devices;
        if (serviceContext.dataSpaceManager) {
          diagnostics.spaces = await Promise.all(Array.from(serviceContext.dataSpaceManager.spaces.values()).map((space) => getSpaceStats(space)) ?? []);
        }
        const { feeds = [] } = await (0, import_codec_protobuf.getFirstStreamValue)(clientServices.DevtoolsHost.subscribeToFeeds({}), {
          timeout: DEFAULT_TIMEOUT
        }).catch(() => void 0) ?? {};
        diagnostics.feeds = feeds.map(({ feedKey, bytes, length }) => ({
          feedKey,
          bytes,
          length
        }));
        const status = await (0, import_codec_protobuf.getFirstStreamValue)(clientServices.NetworkService.queryStatus(), {
          timeout: DEFAULT_TIMEOUT
        }).catch(() => void 0);
        diagnostics.networkStatus = status;
        diagnostics.swarms = serviceContext.networkManager.connectionLog?.swarms;
      }
    }
  ]);
  diagnostics.config = config.values;
  return diagnostics;
};
var getSpaceStats = async (space) => {
  const stats = {
    key: space.key,
    metrics: space.metrics,
    epochs: space.inner.spaceState.credentials.filter((0, import_credentials.credentialTypeFilter)("dxos.halo.credentials.Epoch")).map((credential) => ({
      ...credential.subject.assertion,
      id: credential.id
    })),
    members: await Promise.all(Array.from(space.inner.spaceState.members.values()).map(async (member) => ({
      role: member.role,
      identity: {
        did: await (0, import_credentials.createDidFromIdentityKey)(member.key),
        identityKey: member.key,
        profile: {
          displayName: member.assertion.profile?.displayName
        }
      },
      presence: space.presence.getPeersOnline().filter(({ identityKey }) => identityKey.equals(member.key)).length > 0 ? import_services.SpaceMember.PresenceState.ONLINE : import_services.SpaceMember.PresenceState.OFFLINE
    }))),
    pipeline: {
      // TODO(burdon): Pick properties from credentials if needed.
      currentEpoch: space.automergeSpaceState.lastEpoch,
      appliedEpoch: space.automergeSpaceState.lastEpoch,
      controlFeeds: space.inner.controlPipeline.state.feeds.map((feed) => feed.key),
      currentControlTimeframe: space.inner.controlPipeline.state.timeframe,
      targetControlTimeframe: space.inner.controlPipeline.state.targetTimeframe,
      totalControlTimeframe: space.inner.controlPipeline.state.endTimeframe
    }
  };
  if (stats.metrics) {
    const { open, ready } = stats.metrics;
    stats.metrics.startupTime = open && ready && ready.getTime() - open.getTime();
  }
  return stats;
};
var getStorageDiagnostics = async () => {
  if (typeof navigator === "undefined" || !navigator.storage) {
    return void 0;
  }
  const map = /* @__PURE__ */ new Map();
  const dir = await navigator.storage.getDirectory();
  for await (const filename of dir?.keys()) {
    const idx = filename.indexOf("-", filename.indexOf("-") + 1);
    if (idx === -1) {
      continue;
    }
    map.set(filename.slice(0, idx), (map.get(filename.slice(0, idx)) ?? 0) + 1);
  }
  return Array.from(map.entries()).sort((a, b) => b[1] - a[1]).map(([file, count]) => ({
    file,
    count
  }));
};
var createCollectDiagnosticsBroadcastSender = () => {
  return {
    broadcastDiagnosticsRequest: async () => void 0
  };
};
var createCollectDiagnosticsBroadcastHandler = (_) => {
  return {
    start: () => {
    },
    stop: () => {
    }
  };
};
var GET_DIAGNOSTICS_RPC_TIMEOUT = 1e4;
var DiagnosticsCollector = class {
  static {
    this.broadcastSender = createCollectDiagnosticsBroadcastSender();
  }
  static async collect(config = findConfigs(), services = findSystemServiceProvider(), options = {}) {
    const serviceDiagnostics = await services?.services?.SystemService?.getDiagnostics({
      keys: options.humanize ? import_services3.GetDiagnosticsRequest.KEY_OPTION.HUMANIZE : options.truncate ? import_services3.GetDiagnosticsRequest.KEY_OPTION.TRUNCATE : void 0
    }, {
      timeout: GET_DIAGNOSTICS_RPC_TIMEOUT
    });
    const clientDiagnostics = {
      config,
      trace: import_tracing2.TRACE_PROCESSOR.getDiagnostics()
    };
    const diagnostics = serviceDiagnostics != null ? {
      client: clientDiagnostics,
      services: serviceDiagnostics
    } : {
      client: clientDiagnostics,
      broadcast: await this.broadcastSender.broadcastDiagnosticsRequest()
    };
    return JSON.parse(JSON.stringify(diagnostics, (0, import_util2.jsonKeyReplacer)(options)));
  }
};
var findSystemServiceProvider = () => {
  const serviceProviders = import_tracing2.TRACE_PROCESSOR.findResourcesByAnnotation(import_client_protocol.ClientServicesProviderResource);
  const providerResource = serviceProviders.find((r) => r.instance.deref()?.services?.SystemService != null);
  return providerResource?.instance?.deref() ?? null;
};
var findConfigs = () => {
  const configs = import_tracing2.TRACE_PROCESSOR.findResourcesByAnnotation(import_config.ConfigResource);
  return configs.map((r) => r.instance.deref()).filter(import_util2.isNonNullable);
};
var __dxlog_file4 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/identity/authenticator.ts";
var Credential = import_proto.schema.getCodecForType("dxos.halo.credentials.Credential");
var createAuthProvider = (signer) => async (nonce) => {
  const credential = await signer.createCredential({
    assertion: {
      "@type": "dxos.halo.credentials.Auth"
    },
    subject: signer.getIssuer(),
    nonce
  });
  return Credential.encode(credential);
};
var TrustedKeySetAuthVerifier = class {
  constructor(_params) {
    this._params = _params;
    this._ctx = new import_context2.Context(void 0, {
      F: __dxlog_file4,
      L: 45
    });
  }
  async close() {
    await this._ctx.dispose();
  }
  get verifier() {
    return async (nonce, auth) => {
      const credential = Credential.decode(auth);
      (0, import_log2.log)("authenticating...", {
        credential
      }, {
        F: __dxlog_file4,
        L: 56,
        S: this,
        C: (f, a) => f(...a)
      });
      const result = await (0, import_credentials2.verifyCredential)(credential);
      if (result.kind === "fail") {
        (0, import_log2.log)("Invalid credential", {
          result
        }, {
          F: __dxlog_file4,
          L: 60,
          S: this,
          C: (f, a) => f(...a)
        });
        return false;
      }
      if (!credential.proof.nonce || !Buffer.from(nonce).equals(credential.proof.nonce)) {
        (0, import_log2.log)("Invalid nonce", {
          nonce,
          credential
        }, {
          F: __dxlog_file4,
          L: 65,
          S: this,
          C: (f, a) => f(...a)
        });
        return false;
      }
      if (this._isTrustedKey(credential.issuer)) {
        (0, import_log2.log)("key is trusted -- auth success", {
          key: credential.issuer
        }, {
          F: __dxlog_file4,
          L: 70,
          S: this,
          C: (f, a) => f(...a)
        });
        return true;
      }
      const trigger = new import_async5.Trigger();
      this._ctx.onDispose(() => {
        trigger.wake(false);
      });
      const clear = this._params.update.on(this._ctx, () => {
        if (this._isTrustedKey(credential.issuer)) {
          (0, import_log2.log)("auth success", {
            key: credential.issuer
          }, {
            F: __dxlog_file4,
            L: 81,
            S: this,
            C: (f, a) => f(...a)
          });
          trigger.wake(true);
        } else {
          (0, import_log2.log)("key is not currently in trusted set, waiting...", {
            key: credential.issuer,
            trusted: [
              ...this._params.trustedKeysProvider()
            ]
          }, {
            F: __dxlog_file4,
            L: 84,
            S: this,
            C: (f, a) => f(...a)
          });
        }
      });
      try {
        return await trigger.wait({
          timeout: this._params.authTimeout
        });
      } catch {
        return false;
      } finally {
        clear();
      }
    };
  }
  _isTrustedKey(deviceKey) {
    const deviceSet = this._params.trustedKeysProvider();
    return deviceSet.has(deviceKey);
  }
};
function _ts_decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function _ts_add_disposable_resource(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = function() {
      try {
        inner.call(this);
      } catch (e) {
        return Promise.reject(e);
      }
    };
    env.stack.push({
      value,
      dispose,
      async
    });
  } else if (async) {
    env.stack.push({
      async: true
    });
  }
  return value;
}
function _ts_dispose_resources(env) {
  var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  };
  return (_ts_dispose_resources = function _ts_dispose_resources5(env2) {
    function fail(e) {
      env2.error = env2.hasError ? new _SuppressedError(e, env2.error, "An error was suppressed during disposal.") : e;
      env2.hasError = true;
    }
    var r, s = 0;
    function next() {
      while (r = env2.stack.pop()) {
        try {
          if (!r.async && s === 1) return s = 0, env2.stack.push(r), Promise.resolve().then(next);
          if (r.dispose) {
            var result = r.dispose.call(r.value);
            if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
              fail(e);
              return next();
            });
          } else s |= 1;
        } catch (e) {
          fail(e);
        }
      }
      if (s === 1) return env2.hasError ? Promise.reject(env2.error) : Promise.resolve();
      if (env2.hasError) throw env2.error;
    }
    return next();
  })(env);
}
var __dxlog_file5 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/spaces/edge-feed-replicator.ts";
var EdgeFeedReplicator = class extends import_context3.Resource {
  constructor({ messenger, spaceId }) {
    super();
    this._feeds = new import_util3.ComplexMap(import_keys3.PublicKey.hash);
    this._connectionCtx = void 0;
    this._connected = false;
    this._remoteLength = new import_util3.ComplexMap(import_keys3.PublicKey.hash);
    this._pushMutex = new import_util3.ComplexMap(import_keys3.PublicKey.hash);
    this._messenger = messenger;
    this._spaceId = spaceId;
  }
  async _open() {
    (0, import_log3.log)("open", void 0, {
      F: __dxlog_file5,
      L: 57,
      S: this,
      C: (f, a) => f(...a)
    });
    this._ctx.onDispose(this._messenger.onMessage((message) => {
      if (!message.serviceId) {
        return;
      }
      const [service, ...rest] = message.serviceId.split(":");
      if (service !== import_protocols2.EdgeService.FEED_REPLICATOR) {
        return;
      }
      const [spaceId] = rest;
      if (spaceId !== this._spaceId) {
        (0, import_log3.log)("spaceID mismatch", {
          spaceId,
          _spaceId: this._spaceId
        }, {
          F: __dxlog_file5,
          L: 71,
          S: this,
          C: (f, a) => f(...a)
        });
        return;
      }
      const payload = (0, import_cbor_x.decode)(message.payload.value);
      (0, import_log3.log)("receive", {
        from: message.source,
        feedKey: payload.feedKey,
        type: payload.type
      }, {
        F: __dxlog_file5,
        L: 76,
        S: this,
        C: (f, a) => f(...a)
      });
      this._onMessage(payload);
    }));
    this._ctx.onDispose(this._messenger.onReconnected(() => {
      (0, import_async6.scheduleMicroTask)(this._ctx, () => this._handleReconnect());
    }));
  }
  async _handleReconnect() {
    await this._resetConnection();
    if (this._messenger.status === import_services4.EdgeStatus.CONNECTED) {
      this._startReplication();
    }
  }
  async _close() {
    (0, import_log3.log)("close", void 0, {
      F: __dxlog_file5,
      L: 96,
      S: this,
      C: (f, a) => f(...a)
    });
    await this._resetConnection();
  }
  _startReplication() {
    this._connected = true;
    const connectionCtx = this._createConnectionContext();
    this._connectionCtx = connectionCtx;
    (0, import_log3.log)("connection context created", void 0, {
      F: __dxlog_file5,
      L: 104,
      S: this,
      C: (f, a) => f(...a)
    });
    (0, import_async6.scheduleMicroTask)(connectionCtx, async () => {
      for (const feed of this._feeds.values()) {
        await this._replicateFeed(connectionCtx, feed);
      }
    });
  }
  async _resetConnection() {
    (0, import_log3.log)("resetConnection", void 0, {
      F: __dxlog_file5,
      L: 113,
      S: this,
      C: (f, a) => f(...a)
    });
    this._connected = false;
    await this._connectionCtx?.dispose();
    this._connectionCtx = void 0;
    this._remoteLength.clear();
  }
  async addFeed(feed) {
    (0, import_log3.log)("addFeed", {
      key: feed.key,
      connected: this._connected,
      hasConnectionCtx: !!this._connectionCtx
    }, {
      F: __dxlog_file5,
      L: 121,
      S: this,
      C: (f, a) => f(...a)
    });
    this._feeds.set(feed.key, feed);
    if (this._connected && this._connectionCtx) {
      await this._replicateFeed(this._connectionCtx, feed);
    }
  }
  _getPushMutex(key) {
    return (0, import_util3.defaultMap)(this._pushMutex, key, () => new import_async6.Mutex());
  }
  async _replicateFeed(ctx, feed) {
    (0, import_log3.log)("replicateFeed", {
      key: feed.key
    }, {
      F: __dxlog_file5,
      L: 134,
      S: this,
      C: (f, a) => f(...a)
    });
    await this._sendMessage({
      type: "get-metadata",
      feedKey: feed.key.toHex()
    });
    import_async6.Event.wrap(feed.core, "append").on(ctx, async () => {
      await this._pushBlocksIfNeeded(feed);
    });
  }
  async _sendMessage(message) {
    if (!this._connectionCtx) {
      (0, import_log3.log)("message dropped because connection was disposed", void 0, {
        F: __dxlog_file5,
        L: 147,
        S: this,
        C: (f, a) => f(...a)
      });
      return;
    }
    if (message.type === "data") {
      (0, import_log3.log)("sending blocks", {
        feedKey: message.feedKey,
        blocks: message.blocks.map((b) => b.index)
      }, {
        F: __dxlog_file5,
        L: 152,
        S: this,
        C: (f, a) => f(...a)
      });
    }
    (0, import_invariant2.invariant)(message.feedKey, void 0, {
      F: __dxlog_file5,
      L: 158,
      S: this,
      A: [
        "message.feedKey",
        ""
      ]
    });
    const payloadValue = (0, import_util3.bufferToArray)((0, import_cbor_x.encode)(message));
    (0, import_log3.log)("send", {
      type: message.type
    }, {
      F: __dxlog_file5,
      L: 161,
      S: this,
      C: (f, a) => f(...a)
    });
    await this._messenger.send(import_buf.buf.create(import_messenger_pb.MessageSchema, {
      source: {
        identityKey: this._messenger.identityKey,
        peerKey: this._messenger.peerKey
      },
      serviceId: `${import_protocols2.EdgeService.FEED_REPLICATOR}:${this._spaceId}`,
      payload: {
        value: payloadValue
      }
    }));
  }
  _onMessage(message) {
    if (!this._connectionCtx) {
      import_log3.log.warn("received message after connection context was disposed", void 0, {
        F: __dxlog_file5,
        L: 176,
        S: this,
        C: (f, a) => f(...a)
      });
      return;
    }
    (0, import_async6.scheduleMicroTask)(this._connectionCtx, async () => {
      switch (message.type) {
        case "metadata": {
          const env = {
            stack: [],
            error: void 0,
            hasError: false
          };
          try {
            const feedKey = import_keys3.PublicKey.fromHex(message.feedKey);
            const feed = this._feeds.get(feedKey);
            if (!feed) {
              import_log3.log.warn("Feed not found", {
                feedKey
              }, {
                F: __dxlog_file5,
                L: 185,
                S: this,
                C: (f, a) => f(...a)
              });
              return;
            }
            const _guard = _ts_add_disposable_resource(env, await this._getPushMutex(feed.key).acquire(), false);
            this._remoteLength.set(feedKey, message.length);
            const logMeta = {
              localLength: feed.length,
              remoteLength: message.length,
              feedKey
            };
            if (message.length > feed.length) {
              (0, import_log3.log)("requesting missing blocks", logMeta, {
                F: __dxlog_file5,
                L: 195,
                S: this,
                C: (f, a) => f(...a)
              });
              await this._sendMessage({
                type: "request",
                feedKey: feedKey.toHex(),
                range: {
                  from: feed.length,
                  to: message.length
                }
              });
            } else if (message.length < feed.length) {
              (0, import_log3.log)("pushing blocks to remote", logMeta, {
                F: __dxlog_file5,
                L: 203,
                S: this,
                C: (f, a) => f(...a)
              });
              await this._pushBlocks(feed, message.length, feed.length);
            }
            break;
          } catch (e) {
            env.error = e;
            env.hasError = true;
          } finally {
            _ts_dispose_resources(env);
          }
        }
        case "data": {
          (0, import_log3.log)("received data", {
            feed: message.feedKey,
            blocks: message.blocks.map((b) => b.index)
          }, {
            F: __dxlog_file5,
            L: 212,
            S: this,
            C: (f, a) => f(...a)
          });
          const feedKey = import_keys3.PublicKey.fromHex(message.feedKey);
          const feed = this._feeds.get(feedKey);
          if (!feed) {
            import_log3.log.warn("Feed not found", {
              feedKey
            }, {
              F: __dxlog_file5,
              L: 217,
              S: this,
              C: (f, a) => f(...a)
            });
            return;
          }
          await this._integrateBlocks(feed, message.blocks);
          break;
        }
        default: {
          import_log3.log.warn("Unknown message", {
            ...message
          }, {
            F: __dxlog_file5,
            L: 226,
            S: this,
            C: (f, a) => f(...a)
          });
        }
      }
    });
  }
  async _pushBlocks(feed, from, to) {
    (0, import_log3.log)("pushing blocks", {
      feed: feed.key.toHex(),
      from,
      to
    }, {
      F: __dxlog_file5,
      L: 233,
      S: this,
      C: (f, a) => f(...a)
    });
    const blocks = await Promise.all((0, import_util3.rangeFromTo)(from, to).map(async (index) => {
      const data = await feed.get(index, {
        valueEncoding: "binary"
      });
      (0, import_invariant2.invariant)(data instanceof Uint8Array, void 0, {
        F: __dxlog_file5,
        L: 238,
        S: this,
        A: [
          "data instanceof Uint8Array",
          ""
        ]
      });
      const proof = await feed.proof(index);
      return {
        index,
        data,
        nodes: proof.nodes,
        signature: proof.signature
      };
    }));
    await this._sendMessage({
      type: "data",
      feedKey: feed.key.toHex(),
      blocks
    });
    this._remoteLength.set(feed.key, to);
  }
  async _integrateBlocks(feed, blocks) {
    (0, import_log3.log)("integrating blocks", {
      feed: feed.key.toHex(),
      blocks: blocks.length
    }, {
      F: __dxlog_file5,
      L: 259,
      S: this,
      C: (f, a) => f(...a)
    });
    for (const block of blocks) {
      if (feed.has(block.index)) {
        continue;
      }
      const blockBuffer = bufferizeBlock(block);
      await feed.putBuffer(block.index, blockBuffer.data, {
        nodes: blockBuffer.nodes,
        signature: blockBuffer.signature
      }, null);
    }
  }
  async _pushBlocksIfNeeded(feed) {
    const env = {
      stack: [],
      error: void 0,
      hasError: false
    };
    try {
      const _ = _ts_add_disposable_resource(env, await this._getPushMutex(feed.key).acquire(), false);
      if (!this._remoteLength.has(feed.key)) {
        (0, import_log3.log)("blocks not pushed because remote length is unknown", void 0, {
          F: __dxlog_file5,
          L: 280,
          S: this,
          C: (f, a) => f(...a)
        });
        return;
      }
      const remoteLength = this._remoteLength.get(feed.key);
      if (remoteLength < feed.length) {
        await this._pushBlocks(feed, remoteLength, feed.length);
      }
    } catch (e) {
      env.error = e;
      env.hasError = true;
    } finally {
      _ts_dispose_resources(env);
    }
  }
  _createConnectionContext() {
    const connectionCtx = new import_context3.Context({
      onError: async (err) => {
        if (connectionCtx !== this._connectionCtx) {
          return;
        }
        if (err instanceof import_edge_client.EdgeIdentityChangedError || err instanceof import_edge_client.EdgeConnectionClosedError) {
          (0, import_log3.log)("resetting on reconnect", void 0, {
            F: __dxlog_file5,
            L: 297,
            S: this,
            C: (f, a) => f(...a)
          });
          await this._resetConnection();
        } else {
          this._ctx.raise(err);
        }
      }
    }, {
      F: __dxlog_file5,
      L: 291
    });
    return connectionCtx;
  }
};
_ts_decorate([
  import_log3.logInfo
], EdgeFeedReplicator.prototype, "_spaceId", void 0);
var bufferizeBlock = (block) => ({
  index: block.index,
  data: (0, import_util3.arrayToBuffer)(block.data),
  nodes: block.nodes.map((node) => ({
    index: node.index,
    hash: (0, import_util3.arrayToBuffer)(node.hash),
    size: node.size
  })),
  signature: (0, import_util3.arrayToBuffer)(block.signature)
});
var AutomergeSpaceState = class extends import_context5.Resource {
  constructor(_onNewRoot) {
    super(), this._onNewRoot = _onNewRoot, this.rootUrl = void 0, this.lastEpoch = void 0, this.onNewEpoch = new import_async8.Event(), this._isProcessingRootDocs = false;
  }
  async _open(ctx) {
  }
  async _close(ctx) {
    this._isProcessingRootDocs = false;
  }
  async processCredential(credential) {
    if (!(0, import_credentials4.checkCredentialType)(credential, "dxos.halo.credentials.Epoch")) {
      return;
    }
    this.lastEpoch = credential;
    if (credential.subject.assertion.automergeRoot) {
      this.rootUrl = credential.subject.assertion.automergeRoot;
      if (this._isProcessingRootDocs) {
        this._onNewRoot(this.rootUrl);
      }
    }
    this.onNewEpoch.emit(credential);
  }
  startProcessingRootDocs() {
    if (this._isProcessingRootDocs) {
      return;
    }
    if (this.rootUrl) {
      this._onNewRoot(this.rootUrl);
    }
    this._isProcessingRootDocs = true;
  }
  async ensureEpochInitialized() {
    await this.onNewEpoch.waitForCondition(() => !!this.lastEpoch);
  }
};
var __dxlog_file6 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/spaces/epoch-migrations.ts";
var LOAD_DOC_TIMEOUT = 1e4;
var runEpochMigration = async (ctx, context) => {
  switch (context.migration) {
    case import_services6.CreateEpochRequest.Migration.INIT_AUTOMERGE: {
      const document = context.echoHost.createDoc();
      await context.echoHost.flush();
      return {
        newRoot: document.url
      };
    }
    case import_services6.CreateEpochRequest.Migration.PRUNE_AUTOMERGE_ROOT_HISTORY: {
      if (!context.currentRoot) {
        throw new Error("Space does not have an automerge root");
      }
      const rootHandle = await context.echoHost.loadDoc(ctx, context.currentRoot, {
        timeout: LOAD_DOC_TIMEOUT
      });
      const newRoot = context.echoHost.createDoc(rootHandle.doc());
      await context.echoHost.flush();
      return {
        newRoot: newRoot.url
      };
    }
    case import_services6.CreateEpochRequest.Migration.FRAGMENT_AUTOMERGE_ROOT: {
      throw new Error("Migration not available");
    }
    case import_services6.CreateEpochRequest.Migration.MIGRATE_REFERENCES_TO_DXN: {
      throw new Error("Migration not available");
    }
    // TODO(dmaretskyi): This path doesn't seem to fit here. This is not a migration.
    case import_services6.CreateEpochRequest.Migration.REPLACE_AUTOMERGE_ROOT: {
      (0, import_invariant4.invariant)(context.newAutomergeRoot, void 0, {
        F: __dxlog_file6,
        L: 63,
        S: void 0,
        A: [
          "context.newAutomergeRoot",
          ""
        ]
      });
      await context.echoHost.flush();
      return {
        newRoot: context.newAutomergeRoot
      };
    }
  }
  return {};
};
function _ts_decorate2(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file7 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/spaces/notarization-plugin.ts";
var DEFAULT_RETRY_TIMEOUT = 1e3;
var DEFAULT_SUCCESS_DELAY = 1e3;
var DEFAULT_NOTARIZE_TIMEOUT = 1e4;
var DEFAULT_ACTIVE_EDGE_POLLING_INTERVAL = 3e3;
var MAX_EDGE_RETRIES = 2;
var WRITER_NOT_SET_ERROR_CODE = "WRITER_NOT_SET";
var credentialCodec = import_proto2.schema.getCodecForType("dxos.halo.credentials.Credential");
var NotarizationPlugin = class extends import_context6.Resource {
  constructor(params) {
    super();
    this._extensionOpened = new import_async9.Event();
    this._extensions = /* @__PURE__ */ new Set();
    this._processedCredentials = new import_util5.ComplexSet(import_keys5.PublicKey.hash);
    this._processCredentialsTriggers = new import_util5.ComplexMap(import_keys5.PublicKey.hash);
    this._activeEdgePollingIntervalHandle = void 0;
    this._activeEdgePollingEnabled = false;
    this._spaceId = params.spaceId;
    this._activeEdgePollingInterval = params.activeEdgePollingInterval ?? DEFAULT_ACTIVE_EDGE_POLLING_INTERVAL;
    if (params.edgeClient && params.edgeFeatures?.feedReplicator) {
      this._edgeClient = params.edgeClient;
    }
  }
  setActiveEdgePollingEnabled(enabled) {
    const client = this._edgeClient;
    (0, import_invariant5.invariant)(client, void 0, {
      F: __dxlog_file7,
      L: 111,
      S: this,
      A: [
        "client",
        ""
      ]
    });
    this._activeEdgePollingEnabled = enabled;
    if (this.isOpen) {
      if (enabled && !this._activeEdgePollingIntervalHandle) {
        this._startPeriodicEdgePolling(client);
      } else if (!enabled && this._activeEdgePollingIntervalHandle) {
        this._stopPeriodicEdgePolling();
      }
    }
  }
  get hasWriter() {
    return !!this._writer;
  }
  async _open() {
    if (this._edgeClient) {
      if (this._activeEdgePollingEnabled) {
        this._startPeriodicEdgePolling(this._edgeClient);
      }
      if (this._writer) {
        this._notarizePendingEdgeCredentials(this._edgeClient, this._writer);
      }
    }
  }
  async _close() {
    this._stopPeriodicEdgePolling();
    await this._ctx.dispose();
  }
  /**
  * Request credentials to be notarized.
  */
  async notarize({ ctx: opCtx, credentials, timeout = DEFAULT_NOTARIZE_TIMEOUT, retryTimeout = DEFAULT_RETRY_TIMEOUT, successDelay = DEFAULT_SUCCESS_DELAY, edgeRetryJitter }) {
    (0, import_log5.log)("notarize", {
      credentials
    }, {
      F: __dxlog_file7,
      L: 153,
      S: this,
      C: (f, a) => f(...a)
    });
    (0, import_invariant5.invariant)(credentials.every((credential) => credential.id), "Credentials must have an id", {
      F: __dxlog_file7,
      L: 154,
      S: this,
      A: [
        "credentials.every((credential) => credential.id)",
        "'Credentials must have an id'"
      ]
    });
    const errors = new import_async9.Trigger();
    const ctx = this._ctx.derive({
      onError: (err) => {
        import_log5.log.warn("Notarization error", {
          err
        }, {
          F: __dxlog_file7,
          L: 162,
          S: this,
          C: (f, a) => f(...a)
        });
        void ctx.dispose();
        errors.throw(err);
      }
    });
    opCtx?.onDispose(() => ctx.dispose());
    if (timeout !== 0) {
      this._scheduleTimeout(ctx, errors, timeout);
    }
    const allNotarized = Promise.all(credentials.map((credential) => this._waitUntilProcessed(credential.id)));
    this._tryNotarizeCredentialsWithPeers(ctx, credentials, {
      retryTimeout,
      successDelay
    });
    if (this._edgeClient) {
      this._tryNotarizeCredentialsWithEdge(ctx, this._edgeClient, credentials, {
        retryTimeout,
        successDelay,
        jitter: edgeRetryJitter
      });
    }
    try {
      await Promise.race([
        (0, import_context6.rejectOnDispose)(ctx),
        allNotarized,
        errors.wait()
      ]);
      (0, import_log5.log)("done", void 0, {
        F: __dxlog_file7,
        L: 187,
        S: this,
        C: (f, a) => f(...a)
      });
    } finally {
      await ctx.dispose();
    }
  }
  _tryNotarizeCredentialsWithPeers(ctx, credentials, { retryTimeout, successDelay }) {
    const peersTried = /* @__PURE__ */ new Set();
    const notarizeTask = new import_async9.DeferredTask(ctx, async () => {
      try {
        if (this._extensions.size === 0) {
          return;
        }
        const peer = [
          ...this._extensions
        ].find((peer2) => !peersTried.has(peer2));
        if (!peer) {
          import_log5.log.info("Exhausted all peers to notarize with", {
            retryIn: retryTimeout
          }, {
            F: __dxlog_file7,
            L: 210,
            S: this,
            C: (f, a) => f(...a)
          });
          peersTried.clear();
          (0, import_async9.scheduleTask)(ctx, () => notarizeTask.schedule(), retryTimeout);
          return;
        }
        peersTried.add(peer);
        (0, import_log5.log)("try notarizing", {
          peer: peer.localPeerId,
          credentialId: credentials.map((credential) => credential.id)
        }, {
          F: __dxlog_file7,
          L: 217,
          S: this,
          C: (f, a) => f(...a)
        });
        await peer.rpc.NotarizationService.notarize({
          credentials: credentials.filter((credential) => !this._processedCredentials.has(credential.id))
        });
        (0, import_log5.log)("success", void 0, {
          F: __dxlog_file7,
          L: 221,
          S: this,
          C: (f, a) => f(...a)
        });
        await (0, import_async9.sleep)(successDelay);
      } catch (err) {
        if (!ctx.disposed && !err.message.includes(WRITER_NOT_SET_ERROR_CODE)) {
          import_log5.log.info("error notarizing (recoverable)", err, {
            F: __dxlog_file7,
            L: 226,
            S: this,
            C: (f, a) => f(...a)
          });
        }
        notarizeTask.schedule();
      }
    });
    notarizeTask.schedule();
    this._extensionOpened.on(ctx, () => notarizeTask.schedule());
  }
  _tryNotarizeCredentialsWithEdge(ctx, client, credentials, timeouts) {
    const encodedCredentials = credentials.map((credential) => {
      const binary = credentialCodec.encode(credential);
      return Buffer.from(binary).toString("base64");
    });
    (0, import_async9.scheduleTask)(ctx, async () => {
      try {
        await client.notarizeCredentials(this._spaceId, {
          credentials: encodedCredentials
        }, {
          retry: {
            count: MAX_EDGE_RETRIES,
            timeout: timeouts.retryTimeout,
            jitter: timeouts.jitter
          }
        });
        (0, import_log5.log)("edge notarization success", void 0, {
          F: __dxlog_file7,
          L: 254,
          S: this,
          C: (f, a) => f(...a)
        });
      } catch (error) {
        handleEdgeError(error);
      }
    });
  }
  /**
  * Called with credentials arriving from the control pipeline.
  */
  async processCredential(credential) {
    if (!credential.id) {
      return;
    }
    this._processCredentialsTriggers.get(credential.id)?.wake();
    this._processedCredentials.add(credential.id);
    this._processCredentialsTriggers.delete(credential.id);
  }
  setWriter(writer) {
    (0, import_invariant5.invariant)(!this._writer, "Writer already set.", {
      F: __dxlog_file7,
      L: 274,
      S: this,
      A: [
        "!this._writer",
        "'Writer already set.'"
      ]
    });
    this._writer = writer;
    if (this._edgeClient && this.isOpen) {
      this._notarizePendingEdgeCredentials(this._edgeClient, writer);
    }
  }
  _startPeriodicEdgePolling(client) {
    this._activeEdgePollingIntervalHandle = setInterval(() => {
      if (this._writer) {
        this._notarizePendingEdgeCredentials(client, this._writer);
      }
    }, this._activeEdgePollingInterval);
  }
  _stopPeriodicEdgePolling() {
    if (this._activeEdgePollingIntervalHandle) {
      clearInterval(this._activeEdgePollingIntervalHandle);
      this._activeEdgePollingIntervalHandle = void 0;
    }
  }
  /**
  * The method is used only for adding agent feeds to spaces.
  * When an agent is created we can admit them into all the existing spaces. In case the operation fails
  * this method will fix it on the next space open.
  * Given how rarely this happens there's no need to poll the endpoint.
  */
  _notarizePendingEdgeCredentials(client, writer) {
    (0, import_async9.scheduleMicroTask)(this._ctx, async () => {
      try {
        const response = await client.getCredentialsForNotarization(this._spaceId, {
          retry: {
            count: MAX_EDGE_RETRIES
          }
        });
        const credentials = response.awaitingNotarization.credentials;
        if (!credentials.length) {
          (0, import_log5.log)("edge did not return credentials for notarization", void 0, {
            F: __dxlog_file7,
            L: 311,
            S: this,
            C: (f, a) => f(...a)
          });
          return;
        }
        (0, import_log5.log)("got edge credentials for notarization", {
          count: credentials.length
        }, {
          F: __dxlog_file7,
          L: 315,
          S: this,
          C: (f, a) => f(...a)
        });
        const decodedCredentials = credentials.map((credential) => {
          const binary = Buffer.from(credential, "base64");
          return credentialCodec.decode(binary);
        });
        await this._notarizeCredentials(writer, decodedCredentials);
        import_log5.log.info("notarized edge credentials", {
          count: decodedCredentials.length
        }, {
          F: __dxlog_file7,
          L: 324,
          S: this,
          C: (f, a) => f(...a)
        });
      } catch (error) {
        handleEdgeError(error);
      }
    });
  }
  async _waitUntilProcessed(id) {
    if (this._processedCredentials.has(id)) {
      return;
    }
    await (0, import_util5.entry)(this._processCredentialsTriggers, id).orInsert(new import_async9.Trigger()).value.wait();
  }
  /**
  * Requests from other peers to notarize credentials.
  */
  async _onNotarize(request) {
    if (!this._writer) {
      throw new Error(WRITER_NOT_SET_ERROR_CODE);
    }
    await this._notarizeCredentials(this._writer, request.credentials ?? []);
  }
  async _notarizeCredentials(writer, credentials) {
    for (const credential of credentials) {
      (0, import_invariant5.invariant)(credential.id, "Credential must have an id", {
        F: __dxlog_file7,
        L: 350,
        S: this,
        A: [
          "credential.id",
          "'Credential must have an id'"
        ]
      });
      if (this._processedCredentials.has(credential.id)) {
        continue;
      }
      const verificationResult = await (0, import_credentials5.verifyCredential)(credential);
      if (verificationResult.kind === "fail") {
        throw new Error(`Credential verification failed: ${verificationResult.errors.join("\n")}.`);
      }
      await writer.write(credential);
    }
  }
  createExtension() {
    const extension = new NotarizationTeleportExtension({
      onOpen: async () => {
        (0, import_log5.log)("extension opened", {
          peer: extension.localPeerId
        }, {
          F: __dxlog_file7,
          L: 365,
          S: this,
          C: (f, a) => f(...a)
        });
        this._extensions.add(extension);
        this._extensionOpened.emit();
      },
      onClose: async () => {
        (0, import_log5.log)("extension closed", {
          peer: extension.localPeerId
        }, {
          F: __dxlog_file7,
          L: 370,
          S: this,
          C: (f, a) => f(...a)
        });
        this._extensions.delete(extension);
      },
      onNotarize: this._onNotarize.bind(this)
    });
    return extension;
  }
  _scheduleTimeout(ctx, errors, timeout) {
    (0, import_async9.scheduleTask)(ctx, () => {
      import_log5.log.warn("Notarization timeout", {
        timeout,
        peers: Array.from(this._extensions).map((extension) => extension.remotePeerId)
      }, {
        F: __dxlog_file7,
        L: 382,
        S: this,
        C: (f, a) => f(...a)
      });
      void ctx.dispose();
      errors.throw(new import_async9.TimeoutError(timeout, "Notarization timed out"));
    }, timeout);
  }
};
_ts_decorate2([
  import_log5.logInfo
], NotarizationPlugin.prototype, "_spaceId", void 0);
var handleEdgeError = (error) => {
  if (!(error instanceof import_protocols4.EdgeCallFailedError) || error.errorData) {
    import_log5.log.catch(error, void 0, {
      F: __dxlog_file7,
      L: 396,
      S: void 0,
      C: (f, a) => f(...a)
    });
  } else {
    import_log5.log.info("Edge notarization failure", {
      reason: error.reason
    }, {
      F: __dxlog_file7,
      L: 398,
      S: void 0,
      C: (f, a) => f(...a)
    });
  }
};
var NotarizationTeleportExtension = class extends import_teleport.RpcExtension {
  constructor(_params) {
    super({
      requested: {
        NotarizationService: import_proto2.schema.getService("dxos.mesh.teleport.notarization.NotarizationService")
      },
      exposed: {
        NotarizationService: import_proto2.schema.getService("dxos.mesh.teleport.notarization.NotarizationService")
      }
    }), this._params = _params;
  }
  async getHandlers() {
    return {
      NotarizationService: {
        notarize: async (request) => {
          await this._params.onNotarize(request);
        }
      }
    };
  }
  async onOpen(ctx) {
    await super.onOpen(ctx);
    await this._params.onOpen();
  }
  async onClose(err) {
    await this._params.onClose();
    await super.onClose(err);
  }
};
var __dxlog_file8 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/identity/default-space-state-machine.ts";
var DefaultSpaceStateMachine = class {
  constructor(_params) {
    this._params = _params;
  }
  get spaceId() {
    return this._spaceId;
  }
  async processCredential(credential) {
    const assertion = (0, import_credentials8.getCredentialAssertion)(credential);
    switch (assertion["@type"]) {
      case "dxos.halo.credentials.DefaultSpace": {
        if (!credential.subject.id.equals(this._params.identityKey)) {
          import_log7.log.warn("Invalid default space credential", {
            expectedIdentity: this._params.identityKey,
            credential
          }, {
            F: __dxlog_file8,
            L: 32,
            S: this,
            C: (f, a) => f(...a)
          });
          return;
        }
        if (!import_keys7.SpaceId.isValid(assertion.spaceId)) {
          import_log7.log.warn("Invalid default space id", {
            id: assertion.spaceId
          }, {
            F: __dxlog_file8,
            L: 36,
            S: this,
            C: (f, a) => f(...a)
          });
          return;
        }
        this._spaceId = assertion.spaceId;
        break;
      }
    }
  }
};
var spaceGenesis = async (keyring, signingContext, space, automergeRoot) => {
  const credentials = [
    await (0, import_credentials11.createCredential)({
      signer: keyring,
      issuer: space.key,
      subject: space.key,
      assertion: {
        "@type": "dxos.halo.credentials.SpaceGenesis",
        spaceKey: space.key
      }
    }),
    await (0, import_credentials11.createCredential)({
      signer: keyring,
      issuer: space.key,
      subject: signingContext.identityKey,
      assertion: {
        "@type": "dxos.halo.credentials.SpaceMember",
        spaceKey: space.key,
        role: import_credentials12.SpaceMember.Role.OWNER,
        profile: signingContext.getProfile(),
        genesisFeedKey: space.controlFeedKey ?? (0, import_debug2.failUndefined)()
      }
    }),
    await signingContext.credentialSigner.createCredential({
      subject: space.controlFeedKey ?? (0, import_debug2.failUndefined)(),
      assertion: {
        "@type": "dxos.halo.credentials.AdmittedFeed",
        spaceKey: space.key,
        identityKey: signingContext.identityKey,
        deviceKey: signingContext.deviceKey,
        designation: import_credentials12.AdmittedFeed.Designation.CONTROL
      }
    }),
    await signingContext.credentialSigner.createCredential({
      subject: space.dataFeedKey ?? (0, import_debug2.failUndefined)(),
      assertion: {
        "@type": "dxos.halo.credentials.AdmittedFeed",
        spaceKey: space.key,
        identityKey: signingContext.identityKey,
        deviceKey: signingContext.deviceKey,
        designation: import_credentials12.AdmittedFeed.Designation.DATA
      }
    }),
    await signingContext.credentialSigner.createCredential({
      subject: space.key ?? (0, import_debug2.failUndefined)(),
      assertion: {
        "@type": "dxos.halo.credentials.Epoch",
        number: 0,
        previousId: void 0,
        timeframe: new import_timeframe3.Timeframe(),
        snapshotCid: void 0,
        automergeRoot
      }
    })
  ];
  for (const credential of credentials) {
    await space.controlPipeline.writer.write({
      credential: {
        credential
      }
    });
  }
  return credentials;
};
function _ts_decorate3(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file9 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/spaces/data-space-manager.ts";
var PRESENCE_ANNOUNCE_INTERVAL = 1e4;
var PRESENCE_OFFLINE_TIMEOUT = 2e4;
var DEFAULT_SPACE_KEY = "__DEFAULT__";
var DataSpaceManager = class extends import_context7.Resource {
  constructor(params) {
    super();
    this.updated = new import_async11.Event();
    this._spaces = new import_util7.ComplexMap(import_keys8.PublicKey.hash);
    this._instanceId = import_keys8.PublicKey.random().toHex();
    this._edgeConnection = void 0;
    this._edgeHttpClient = void 0;
    this._edgeFeatures = void 0;
    this._meshReplicator = void 0;
    this._echoEdgeReplicator = void 0;
    this._runtimeParams = void 0;
    this._spaceManager = params.spaceManager;
    this._metadataStore = params.metadataStore;
    this._keyring = params.keyring;
    this._signingContext = params.signingContext;
    this._feedStore = params.feedStore;
    this._echoHost = params.echoHost;
    this._meshReplicator = params.meshReplicator;
    this._invitationsManager = params.invitationsManager;
    this._edgeConnection = params.edgeConnection;
    this._edgeFeatures = params.edgeFeatures;
    this._echoEdgeReplicator = params.echoEdgeReplicator;
    this._edgeHttpClient = params.edgeHttpClient;
    this._runtimeParams = params.runtimeParams;
    import_tracing5.trace.diagnostic({
      id: "spaces",
      name: "Spaces",
      fetch: async () => {
        return Promise.all(Array.from(this._spaces.values()).map(async (space) => {
          const rootUrl = space.automergeSpaceState.rootUrl;
          const rootHandle = rootUrl ? await this._echoHost.automergeRepo.find(rootUrl, import_echo_pipeline2.FIND_PARAMS) : void 0;
          await rootHandle?.whenReady();
          const rootDoc = rootHandle?.doc();
          const properties = rootDoc && (0, import_echo_pipeline2.findInlineObjectOfType)(rootDoc, import_client_protocol4.TYPE_PROPERTIES);
          return {
            key: space.key.toHex(),
            state: import_services7.SpaceState[space.state],
            name: properties?.[1].data.name ?? null,
            inlineObjects: rootDoc ? Object.keys(rootDoc.objects ?? {}).length : null,
            linkedObjects: rootDoc ? Object.keys(rootDoc.links ?? {}).length : null,
            credentials: space.inner.spaceState.credentials.length,
            members: space.inner.spaceState.members.size,
            rootUrl
          };
        }));
      }
    });
  }
  // TODO(burdon): Remove.
  get spaces() {
    return this._spaces;
  }
  getSpaceById(spaceId) {
    return [
      ...this._spaces.values()
    ].find((space) => space.id === spaceId);
  }
  async _open() {
    (0, import_log8.log)("open", void 0, {
      F: __dxlog_file9,
      L: 215,
      S: this,
      C: (f, a) => f(...a)
    });
    import_log8.log.trace("dxos.echo.data-space-manager.open", import_protocols5.trace.begin({
      id: this._instanceId
    }), {
      F: __dxlog_file9,
      L: 216,
      S: this,
      C: (f, a) => f(...a)
    });
    (0, import_log8.log)("metadata loaded", {
      spaces: this._metadataStore.spaces.length
    }, {
      F: __dxlog_file9,
      L: 217,
      S: this,
      C: (f, a) => f(...a)
    });
    await (0, import_util7.forEachAsync)(this._metadataStore.spaces, async (spaceMetadata) => {
      try {
        (0, import_log8.log)("load space", {
          spaceMetadata
        }, {
          F: __dxlog_file9,
          L: 221,
          S: this,
          C: (f, a) => f(...a)
        });
        await this._constructSpace(spaceMetadata);
      } catch (err) {
        import_log8.log.error("Error loading space", {
          spaceMetadata,
          err
        }, {
          F: __dxlog_file9,
          L: 224,
          S: this,
          C: (f, a) => f(...a)
        });
      }
    });
    this.updated.emit();
    import_log8.log.trace("dxos.echo.data-space-manager.open", import_protocols5.trace.end({
      id: this._instanceId
    }), {
      F: __dxlog_file9,
      L: 230,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  async _close() {
    (0, import_log8.log)("close", void 0, {
      F: __dxlog_file9,
      L: 235,
      S: this,
      C: (f, a) => f(...a)
    });
    for (const space of this._spaces.values()) {
      await space.close();
    }
    this._spaces.clear();
  }
  /**
  * Creates a new space writing the genesis credentials to the control feed.
  */
  async createSpace(options = {}) {
    (0, import_invariant7.assertArgument)(!!options.rootUrl === !!options.documents, "root url must be required when providing documents");
    (0, import_invariant7.assertState)(this._lifecycleState === import_context7.LifecycleState.OPEN, "Not open.");
    const spaceKey = await this._keyring.createKey();
    const controlFeedKey = await this._keyring.createKey();
    const dataFeedKey = await this._keyring.createKey();
    const spaceId = await (0, import_echo_protocol2.createIdFromSpaceKey)(spaceKey);
    const metadata = {
      key: spaceKey,
      genesisFeedKey: controlFeedKey,
      controlFeedKey,
      dataFeedKey,
      state: import_services7.SpaceState.SPACE_ACTIVE
    };
    (0, import_log8.log)("creating space...", {
      spaceId,
      spaceKey
    }, {
      F: __dxlog_file9,
      L: 264,
      S: this,
      C: (f, a) => f(...a)
    });
    const documentIdMapping = {};
    if (options.documents) {
      (0, import_invariant7.invariant)(Object.keys(options.documents).every((documentId) => /^[a-zA-Z0-9]+$/.test(documentId)), "Invalid document IDs", {
        F: __dxlog_file9,
        L: 269,
        S: this,
        A: [
          "Object.keys(options.documents).every((documentId) => /^[a-zA-Z0-9]+$/.test(documentId))",
          "'Invalid document IDs'"
        ]
      });
      await Promise.all(Object.entries(options.documents).map(async ([documentId, data]) => {
        (0, import_log8.log)("creating document...", {
          documentId
        }, {
          F: __dxlog_file9,
          L: 276,
          S: this,
          C: (f, a) => f(...a)
        });
        const newDoc = await this._echoHost.createDoc(data, {
          preserveHistory: true
        });
        documentIdMapping[documentId] = newDoc.documentId;
      }));
    }
    (0, import_log8.log)("opening space...", {
      spaceKey
    }, {
      F: __dxlog_file9,
      L: 283,
      S: this,
      C: (f, a) => f(...a)
    });
    let root;
    if (options.rootUrl) {
      const newRootDocId = documentIdMapping[(0, import_automerge_repo.interpretAsDocumentId)(options.rootUrl)] ?? (0, import_invariant7.failedInvariant)();
      const rootDocHandle = await this._echoHost.loadDoc(import_context7.Context.default(void 0, {
        F: __dxlog_file9,
        L: 288
      }), newRootDocId);
      import_echo_pipeline2.DatabaseRoot.mapLinks(rootDocHandle, documentIdMapping);
      root = await this._echoHost.openSpaceRoot(spaceId, `automerge:${newRootDocId}`);
    } else {
      root = await this._echoHost.createSpaceRoot(spaceKey);
    }
    (0, import_log8.log)("constructing space...", {
      spaceKey
    }, {
      F: __dxlog_file9,
      L: 296,
      S: this,
      C: (f, a) => f(...a)
    });
    const space = await this._constructSpace(metadata);
    await space.open();
    (0, import_log8.log)("adding space...", {
      spaceKey
    }, {
      F: __dxlog_file9,
      L: 301,
      S: this,
      C: (f, a) => f(...a)
    });
    const credentials = await spaceGenesis(this._keyring, this._signingContext, space.inner, root.url);
    await this._metadataStore.addSpace(metadata);
    const memberCredential = credentials[1];
    (0, import_invariant7.invariant)((0, import_credentials9.getCredentialAssertion)(memberCredential)["@type"] === "dxos.halo.credentials.SpaceMember", void 0, {
      F: __dxlog_file9,
      L: 307,
      S: this,
      A: [
        "getCredentialAssertion(memberCredential)['@type'] === 'dxos.halo.credentials.SpaceMember'",
        ""
      ]
    });
    await this._signingContext.recordCredential(memberCredential);
    await space.initializeDataPipeline();
    (0, import_log8.log)("space ready.", {
      spaceId,
      spaceKey
    }, {
      F: __dxlog_file9,
      L: 312,
      S: this,
      C: (f, a) => f(...a)
    });
    this.updated.emit();
    return space;
  }
  async isDefaultSpace(space) {
    if (!space.databaseRoot) {
      return false;
    }
    switch (space.databaseRoot.getVersion()) {
      case import_echo_protocol2.SpaceDocVersion.CURRENT: {
        if (!space.databaseRoot.handle.isReady()) {
          import_log8.log.warn("waiting for space root to be ready", {
            spaceId: space.id
          }, {
            F: __dxlog_file9,
            L: 325,
            S: this,
            C: (f, a) => f(...a)
          });
          await space.databaseRoot.handle.whenReady();
        }
        const [_, properties] = (0, import_echo_pipeline2.findInlineObjectOfType)(space.databaseRoot.doc(), import_client_protocol4.TYPE_PROPERTIES) ?? [];
        return properties?.data?.[DEFAULT_SPACE_KEY] === this._signingContext.identityKey.toHex();
      }
      case import_echo_protocol2.SpaceDocVersion.LEGACY: {
        throw new Error("Legacy space version is not supported");
      }
      default:
        import_log8.log.warn("unknown space version", {
          version: space.databaseRoot.getVersion(),
          spaceId: space.id
        }, {
          F: __dxlog_file9,
          L: 336,
          S: this,
          C: (f, a) => f(...a)
        });
        return false;
    }
  }
  async createDefaultSpace() {
    const space = await this.createSpace();
    const document = await this._getSpaceRootDocument(space);
    const properties = {
      system: {
        type: (0, import_echo_protocol2.encodeReference)((0, import_echo_schema.getTypeReference)(import_client_protocol4.PropertiesType))
      },
      data: {
        [DEFAULT_SPACE_KEY]: this._signingContext.identityKey.toHex()
      },
      meta: {
        keys: []
      }
    };
    const propertiesId = import_echo_schema.ObjectId.random();
    document.change((doc) => {
      (0, import_util7.setDeep)(doc, [
        "objects",
        propertiesId
      ], properties);
    });
    await this._echoHost.flush();
    return space;
  }
  async _getSpaceRootDocument(space) {
    const automergeIndex = space.automergeSpaceState.rootUrl;
    (0, import_invariant7.invariant)(automergeIndex, void 0, {
      F: __dxlog_file9,
      L: 369,
      S: this,
      A: [
        "automergeIndex",
        ""
      ]
    });
    const document = await this._echoHost.automergeRepo.find(automergeIndex, import_echo_pipeline2.FIND_PARAMS);
    await document.whenReady();
    return document;
  }
  // TODO(burdon): Rename join space.
  async acceptSpace(opts) {
    (0, import_log8.log)("accept space", {
      opts
    }, {
      F: __dxlog_file9,
      L: 378,
      S: this,
      C: (f, a) => f(...a)
    });
    (0, import_invariant7.invariant)(this._lifecycleState === import_context7.LifecycleState.OPEN, "Not open.", {
      F: __dxlog_file9,
      L: 379,
      S: this,
      A: [
        "this._lifecycleState === LifecycleState.OPEN",
        "'Not open.'"
      ]
    });
    (0, import_invariant7.invariant)(!this._spaces.has(opts.spaceKey), "Space already exists.", {
      F: __dxlog_file9,
      L: 380,
      S: this,
      A: [
        "!this._spaces.has(opts.spaceKey)",
        "'Space already exists.'"
      ]
    });
    const metadata = {
      key: opts.spaceKey,
      genesisFeedKey: opts.genesisFeedKey,
      controlTimeframe: opts.controlTimeframe,
      dataTimeframe: opts.dataTimeframe
    };
    const space = await this._constructSpace(metadata);
    await space.open();
    await this._metadataStore.addSpace(metadata);
    space.initializeDataPipelineAsync();
    this.updated.emit();
    return space;
  }
  async admitMember(options) {
    const space = this._spaceManager.spaces.get(options.spaceKey);
    (0, import_invariant7.invariant)(space, void 0, {
      F: __dxlog_file9,
      L: 400,
      S: this,
      A: [
        "space",
        ""
      ]
    });
    if (space.spaceState.getMemberRole(options.identityKey) !== import_credentials10.SpaceMember.Role.REMOVED) {
      throw new import_protocols5.AlreadyJoinedError();
    }
    const credentials = await (0, import_credentials9.createAdmissionCredentials)(this._signingContext.credentialSigner, options.identityKey, space.key, space.genesisFeedKey, options.role, space.spaceState.membershipChainHeads, options.profile, options.delegationCredentialId);
    (0, import_invariant7.invariant)(credentials[0].credential, void 0, {
      F: __dxlog_file9,
      L: 419,
      S: this,
      A: [
        "credentials[0].credential",
        ""
      ]
    });
    const spaceMemberCredential = credentials[0].credential.credential;
    (0, import_invariant7.invariant)((0, import_credentials9.getCredentialAssertion)(spaceMemberCredential)["@type"] === "dxos.halo.credentials.SpaceMember", void 0, {
      F: __dxlog_file9,
      L: 421,
      S: this,
      A: [
        "getCredentialAssertion(spaceMemberCredential)['@type'] === 'dxos.halo.credentials.SpaceMember'",
        ""
      ]
    });
    await (0, import_feed_store3.writeMessages)(space.controlPipeline.writer, credentials);
    return spaceMemberCredential;
  }
  /**
  * Wait until the space data pipeline is fully initialized.
  * Used by invitation handler.
  * TODO(dmaretskyi): Consider removing.
  */
  async waitUntilSpaceReady(spaceKey) {
    await (0, import_context7.cancelWithContext)(this._ctx, this.updated.waitForCondition(() => {
      const space = this._spaces.get(spaceKey);
      return !!space && space.state === import_services7.SpaceState.SPACE_READY;
    }));
  }
  async requestSpaceAdmissionCredential(spaceKey) {
    return this._spaceManager.requestSpaceAdmissionCredential({
      spaceKey,
      identityKey: this._signingContext.identityKey,
      timeout: 15e3,
      swarmIdentity: {
        identityKey: this._signingContext.identityKey,
        peerKey: this._signingContext.deviceKey,
        credentialProvider: createAuthProvider(this._signingContext.credentialSigner),
        credentialAuthenticator: async () => true
      }
    });
  }
  async setSpaceEdgeReplicationSetting(spaceKey, setting) {
    const space = this._spaces.get(spaceKey);
    (0, import_invariant7.invariant)(space, "Space not found.", {
      F: __dxlog_file9,
      L: 458,
      S: this,
      A: [
        "space",
        "'Space not found.'"
      ]
    });
    await this._metadataStore.setSpaceEdgeReplicationSetting(spaceKey, setting);
    if (space.isOpen) {
      switch (setting) {
        case import_metadata.EdgeReplicationSetting.DISABLED:
          await this._echoEdgeReplicator?.disconnectFromSpace(space.id);
          break;
        case import_metadata.EdgeReplicationSetting.ENABLED:
          await this._echoEdgeReplicator?.connectToSpace(space.id);
          break;
      }
    }
    space.stateUpdate.emit();
  }
  async _constructSpace(metadata) {
    (0, import_log8.log)("construct space", {
      metadata
    }, {
      F: __dxlog_file9,
      L: 477,
      S: this,
      C: (f, a) => f(...a)
    });
    const gossip = new import_teleport_extension_gossip.Gossip({
      localPeerId: this._signingContext.deviceKey
    });
    const presence = new import_teleport_extension_gossip.Presence({
      announceInterval: this._runtimeParams?.spaceMemberPresenceAnnounceInterval ?? PRESENCE_ANNOUNCE_INTERVAL,
      offlineTimeout: this._runtimeParams?.spaceMemberPresenceOfflineTimeout ?? PRESENCE_OFFLINE_TIMEOUT,
      identityKey: this._signingContext.identityKey,
      gossip
    });
    const controlFeed = metadata.controlFeedKey && await this._feedStore.openFeed(metadata.controlFeedKey, {
      writable: true
    });
    const dataFeed = metadata.dataFeedKey && await this._feedStore.openFeed(metadata.dataFeedKey, {
      writable: true,
      sparse: true
    });
    const space = await this._spaceManager.constructSpace({
      metadata,
      swarmIdentity: {
        identityKey: this._signingContext.identityKey,
        peerKey: this._signingContext.deviceKey,
        credentialProvider: createAuthProvider(this._signingContext.credentialSigner),
        credentialAuthenticator: (0, import_util7.deferFunction)(() => dataSpace.authVerifier.verifier)
      },
      onAuthorizedConnection: (session) => queueMicrotask(async () => {
        try {
          if (!session.isOpen) {
            return;
          }
          session.addExtension("dxos.mesh.teleport.admission-discovery", new import_echo_pipeline2.CredentialServerExtension(space));
          session.addExtension("dxos.mesh.teleport.gossip", gossip.createExtension({
            remotePeerId: session.remotePeerId
          }));
          session.addExtension("dxos.mesh.teleport.notarization", dataSpace.notarizationPlugin.createExtension());
          await this._connectEchoMeshReplicator(space, session);
        } catch (err) {
          import_log8.log.warn("error on authorized connection", {
            err
          }, {
            F: __dxlog_file9,
            L: 519,
            S: this,
            C: (f, a) => f(...a)
          });
          await session.close(err);
        }
      }),
      onAuthFailure: () => {
        import_log8.log.warn("auth failure", void 0, {
          F: __dxlog_file9,
          L: 524,
          S: this,
          C: (f, a) => f(...a)
        });
      },
      onMemberRolesChanged: async (members) => {
        if (dataSpace?.state === import_services7.SpaceState.SPACE_READY) {
          this._handleMemberRoleChanges(presence, space.protocol, members);
        }
      },
      memberKey: this._signingContext.identityKey,
      onDelegatedInvitationStatusChange: (invitation, isActive) => {
        return this._handleInvitationStatusChange(dataSpace, invitation, isActive);
      }
    });
    controlFeed && await space.setControlFeed(controlFeed);
    dataFeed && await space.setDataFeed(dataFeed);
    const dataSpace = new DataSpace({
      inner: space,
      initialState: metadata.state === import_services7.SpaceState.SPACE_INACTIVE ? import_services7.SpaceState.SPACE_INACTIVE : import_services7.SpaceState.SPACE_CLOSED,
      metadataStore: this._metadataStore,
      gossip,
      presence,
      keyring: this._keyring,
      feedStore: this._feedStore,
      echoHost: this._echoHost,
      signingContext: this._signingContext,
      callbacks: {
        beforeReady: async () => {
          (0, import_log8.log)("before space ready", {
            space: space.key
          }, {
            F: __dxlog_file9,
            L: 551,
            S: this,
            C: (f, a) => f(...a)
          });
        },
        afterReady: async () => {
          (0, import_log8.log)("after space ready", {
            space: space.key,
            open: this._lifecycleState === import_context7.LifecycleState.OPEN
          }, {
            F: __dxlog_file9,
            L: 554,
            S: this,
            C: (f, a) => f(...a)
          });
          if (this._lifecycleState === import_context7.LifecycleState.OPEN) {
            await this._createDelegatedInvitations(dataSpace, [
              ...space.spaceState.invitations.entries()
            ]);
            this._handleMemberRoleChanges(presence, space.protocol, [
              ...space.spaceState.members.values()
            ]);
            this.updated.emit();
          }
        },
        beforeClose: async () => {
          (0, import_log8.log)("before space close", {
            space: space.key
          }, {
            F: __dxlog_file9,
            L: 562,
            S: this,
            C: (f, a) => f(...a)
          });
        }
      },
      cache: metadata.cache,
      edgeConnection: this._edgeConnection,
      edgeHttpClient: this._edgeHttpClient,
      edgeFeatures: this._edgeFeatures,
      activeEdgeNotarizationPollingInterval: this._runtimeParams?.activeEdgeNotarizationPollingInterval
    });
    dataSpace.postOpen.append(async () => {
      const setting = dataSpace.getEdgeReplicationSetting();
      if (!setting || setting === import_metadata.EdgeReplicationSetting.ENABLED) {
        await this._echoEdgeReplicator?.connectToSpace(dataSpace.id);
      } else if (this._echoEdgeReplicator) {
        (0, import_log8.log)("not connecting EchoEdgeReplicator because of EdgeReplicationSetting", {
          spaceId: dataSpace.id
        }, {
          F: __dxlog_file9,
          L: 576,
          S: this,
          C: (f, a) => f(...a)
        });
      }
    });
    dataSpace.preClose.append(async () => {
      const setting = dataSpace.getEdgeReplicationSetting();
      if (!setting || setting === import_metadata.EdgeReplicationSetting.ENABLED) {
        await this._echoEdgeReplicator?.disconnectFromSpace(dataSpace.id);
      }
    });
    presence.newPeer.on((peerState) => {
      if (dataSpace.state === import_services7.SpaceState.SPACE_READY) {
        this._handleNewPeerConnected(space, peerState);
      }
    });
    if (metadata.controlTimeframe) {
      dataSpace.inner.controlPipeline.state.setTargetTimeframe(metadata.controlTimeframe);
    }
    this._spaces.set(metadata.key, dataSpace);
    return dataSpace;
  }
  async _connectEchoMeshReplicator(space, session) {
    const replicator = this._meshReplicator;
    if (!replicator) {
      import_log8.log.warn("p2p automerge replication disabled", {
        space: space.key
      }, {
        F: __dxlog_file9,
        L: 603,
        S: this,
        C: (f, a) => f(...a)
      });
      return;
    }
    await replicator.authorizeDevice(space.key, session.remotePeerId);
    if (session.isOpen) {
      session.addExtension("dxos.mesh.teleport.automerge", replicator.createExtension());
    }
  }
  _handleMemberRoleChanges(presence, spaceProtocol, memberInfo) {
    let closedSessions = 0;
    for (const member of memberInfo) {
      if (member.key.equals(presence.getLocalState().identityKey)) {
        continue;
      }
      const peers = presence.getPeersByIdentityKey(member.key);
      const sessions = peers.map((p) => p.peerId && spaceProtocol.sessions.get(p.peerId));
      const sessionsToClose = sessions.filter((s) => {
        return (s && member.role === import_credentials10.SpaceMember.Role.REMOVED !== (s.authStatus === import_echo_pipeline2.AuthStatus.FAILURE)) ?? false;
      });
      sessionsToClose.forEach((session) => {
        void session.close().catch(import_log8.log.error);
      });
      closedSessions += sessionsToClose.length;
    }
    (0, import_log8.log)("processed member role changes", {
      roleChangeCount: memberInfo.length,
      peersOnline: presence.getPeersOnline().length,
      closedSessions
    }, {
      F: __dxlog_file9,
      L: 629,
      S: this,
      C: (f, a) => f(...a)
    });
    spaceProtocol.updateTopology();
  }
  _handleNewPeerConnected(space, peerState) {
    const role = space.spaceState.getMemberRole(peerState.identityKey);
    if (role === import_credentials10.SpaceMember.Role.REMOVED) {
      const session = peerState.peerId && space.protocol.sessions.get(peerState.peerId);
      if (session != null) {
        (0, import_log8.log)("closing a session with a removed peer", {
          peerId: peerState.peerId
        }, {
          F: __dxlog_file9,
          L: 643,
          S: this,
          C: (f, a) => f(...a)
        });
        void session.close().catch(import_log8.log.error);
      }
    }
  }
  async _handleInvitationStatusChange(dataSpace, delegatedInvitation, isActive) {
    if (dataSpace?.state !== import_services7.SpaceState.SPACE_READY) {
      return;
    }
    if (isActive) {
      await this._createDelegatedInvitations(dataSpace, [
        [
          delegatedInvitation.credentialId,
          delegatedInvitation.invitation
        ]
      ]);
    } else {
      await this._invitationsManager.cancelInvitation(delegatedInvitation.invitation);
    }
  }
  async _createDelegatedInvitations(space, invitations) {
    const tasks = invitations.map(([credentialId, invitation]) => {
      return this._invitationsManager.createInvitation({
        type: import_services7.Invitation.Type.DELEGATED,
        kind: import_services7.Invitation.Kind.SPACE,
        spaceKey: space.key,
        authMethod: invitation.authMethod,
        invitationId: invitation.invitationId,
        swarmKey: invitation.swarmKey,
        guestKeypair: invitation.guestKey ? {
          publicKey: invitation.guestKey
        } : void 0,
        lifetime: invitation.expiresOn ? (invitation.expiresOn.getTime() - Date.now()) / 1e3 : void 0,
        multiUse: invitation.multiUse,
        delegationCredentialId: credentialId,
        persistent: false
      });
    });
    await Promise.all(tasks);
  }
};
_ts_decorate3([
  import_async11.synchronized
], DataSpaceManager.prototype, "_open", null);
_ts_decorate3([
  import_async11.synchronized
], DataSpaceManager.prototype, "_close", null);
_ts_decorate3([
  import_async11.synchronized
], DataSpaceManager.prototype, "createSpace", null);
_ts_decorate3([
  import_async11.synchronized
], DataSpaceManager.prototype, "acceptSpace", null);
DataSpaceManager = _ts_decorate3([
  (0, import_async11.trackLeaks)("open", "close")
], DataSpaceManager);
var CURRENT_VERSION = import_protocols7.SpaceArchiveVersion.V1;
var SpaceArchiveWriter = class extends import_context8.Resource {
  constructor() {
    super(...arguments);
    this._meta = void 0;
    this._currentRootUrl = void 0;
  }
  async _open(ctx) {
    this._tar = await import("@obsidize/tar-browserify");
  }
  async _close() {
    return Promise.resolve();
  }
  async begin(meta) {
    (0, import_invariant9.assertState)(this._tar, "Not open");
    (0, import_invariant9.assertState)(!this._meta, "Already started");
    this._meta = meta;
    this._archive = new this._tar.Archive();
  }
  async setCurrentRootUrl(url) {
    (0, import_invariant9.assertArgument)(url.startsWith("automerge:"), "Invalid root URL");
    (0, import_invariant9.assertState)(this._tar, "Not open");
    (0, import_invariant9.assertState)(this._meta, "Not started");
    this._currentRootUrl = url;
  }
  async writeDocument(documentId, data) {
    (0, import_invariant9.assertArgument)(!documentId.startsWith("automerge:"), "Invalid document ID");
    (0, import_invariant9.assertState)(this._archive, "Not open");
    this._archive.addBinaryFile(`${import_protocols7.SpaceArchiveFileStructure.documents}/${documentId}.bin`, data);
  }
  async finish() {
    (0, import_invariant9.assertState)(this._archive, "Not open");
    (0, import_invariant9.assertState)(this._meta, "Not started");
    (0, import_invariant9.assertState)(this._currentRootUrl, "No root URL set");
    const metadata = {
      version: CURRENT_VERSION,
      createdAt: Date.now(),
      exportedBy: this._meta.exportedBy,
      originalSpaceId: this._meta.spaceId,
      echo: {
        currentRootUrl: this._currentRootUrl
      }
    };
    this._archive.addTextFile(import_protocols7.SpaceArchiveFileStructure.metadata, JSON.stringify(metadata));
    const binary = this._archive.toUint8Array();
    return {
      filename: `${this._meta.spaceId}.tar`,
      contents: binary
    };
  }
};
var __dxlog_file10 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/space-export/space-archive-reader.ts";
var extractSpaceArchive = async (archive) => {
  const { Archive } = await import("@obsidize/tar-browserify");
  const { entries } = await Archive.extract(archive.contents);
  const metadataEntry = entries.find((entry2) => entry2.fileName === import_protocols8.SpaceArchiveFileStructure.metadata);
  (0, import_invariant10.assertArgument)(metadataEntry, "Metadata entry not found");
  const metadata = JSON.parse(metadataEntry.getContentAsText());
  const documents = {};
  for (const entry2 of entries.filter((entry3) => entry3.fileName.startsWith(`${import_protocols8.SpaceArchiveFileStructure.documents}/`))) {
    const documentId = entry2.fileName.replace(`${import_protocols8.SpaceArchiveFileStructure.documents}/`, "").replace(/\.bin$/, "");
    (0, import_invariant10.invariant)(!documentId.includes("/"), void 0, {
      F: __dxlog_file10,
      L: 28,
      S: void 0,
      A: [
        "!documentId.includes('/')",
        ""
      ]
    });
    documents[documentId] = entry2.content ?? (0, import_invariant10.failedInvariant)();
  }
  import_log10.log.info("extracted space archive", {
    metadata,
    documents
  }, {
    F: __dxlog_file10,
    L: 32,
    S: void 0,
    C: (f, a) => f(...a)
  });
  return {
    metadata,
    documents
  };
};
function _ts_add_disposable_resource2(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = function() {
      try {
        inner.call(this);
      } catch (e) {
        return Promise.reject(e);
      }
    };
    env.stack.push({
      value,
      dispose,
      async
    });
  } else if (async) {
    env.stack.push({
      async: true
    });
  }
  return value;
}
function _ts_dispose_resources2(env) {
  var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  };
  return (_ts_dispose_resources2 = function _ts_dispose_resources5(env2) {
    function fail(e) {
      env2.error = env2.hasError ? new _SuppressedError(e, env2.error, "An error was suppressed during disposal.") : e;
      env2.hasError = true;
    }
    var r, s = 0;
    function next() {
      while (r = env2.stack.pop()) {
        try {
          if (!r.async && s === 1) return s = 0, env2.stack.push(r), Promise.resolve().then(next);
          if (r.dispose) {
            var result = r.dispose.call(r.value);
            if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
              fail(e);
              return next();
            });
          } else s |= 1;
        } catch (e) {
          fail(e);
        }
      }
      if (s === 1) return env2.hasError ? Promise.reject(env2.error) : Promise.resolve();
      if (env2.hasError) throw env2.error;
    }
    return next();
  })(env);
}
var __dxlog_file11 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/spaces/spaces-service.ts";
var SpacesServiceImpl = class {
  constructor(_identityManager, _spaceManager, _getDataSpaceManager) {
    this._identityManager = _identityManager;
    this._spaceManager = _spaceManager;
    this._getDataSpaceManager = _getDataSpaceManager;
  }
  async createSpace() {
    this._requireIdentity();
    const dataSpaceManager = await this._getDataSpaceManager();
    const space = await dataSpaceManager.createSpace();
    await this._updateMetrics();
    return this._serializeSpace(space);
  }
  async updateSpace({ spaceKey, state, edgeReplication }) {
    const dataSpaceManager = await this._getDataSpaceManager();
    const space = dataSpaceManager.spaces.get(spaceKey) ?? (0, import_debug3.raise)(new import_protocols6.SpaceNotFoundError(spaceKey));
    if (state) {
      switch (state) {
        case import_services8.SpaceState.SPACE_ACTIVE:
          await space.activate();
          break;
        case import_services8.SpaceState.SPACE_INACTIVE:
          await space.deactivate();
          break;
        default:
          throw new import_protocols6.ApiError("Invalid space state");
      }
    }
    if (edgeReplication !== void 0) {
      await dataSpaceManager.setSpaceEdgeReplicationSetting(spaceKey, edgeReplication);
    }
  }
  async updateMemberRole(request) {
    const identity = this._requireIdentity();
    const space = this._spaceManager.spaces.get(request.spaceKey);
    if (space == null) {
      throw new import_protocols6.SpaceNotFoundError(request.spaceKey);
    }
    if (!space.spaceState.hasMembershipManagementPermission(identity.identityKey)) {
      throw new import_protocols6.AuthorizationError("No member management permission.", {
        spaceKey: space.key,
        role: space.spaceState.getMemberRole(identity.identityKey)
      });
    }
    const credentials = await (0, import_credentials13.createAdmissionCredentials)(identity.getIdentityCredentialSigner(), request.memberKey, space.key, space.genesisFeedKey, request.newRole, space.spaceState.membershipChainHeads);
    (0, import_invariant8.invariant)(credentials[0].credential, void 0, {
      F: __dxlog_file11,
      L: 119,
      S: this,
      A: [
        "credentials[0].credential",
        ""
      ]
    });
    const spaceMemberCredential = credentials[0].credential.credential;
    (0, import_invariant8.invariant)((0, import_credentials13.getCredentialAssertion)(spaceMemberCredential)["@type"] === "dxos.halo.credentials.SpaceMember", void 0, {
      F: __dxlog_file11,
      L: 121,
      S: this,
      A: [
        "getCredentialAssertion(spaceMemberCredential)['@type'] === 'dxos.halo.credentials.SpaceMember'",
        ""
      ]
    });
    await (0, import_feed_store4.writeMessages)(space.controlPipeline.writer, credentials);
  }
  querySpaces() {
    return new import_stream7.Stream(({ next, ctx }) => {
      const scheduler = new import_async12.UpdateScheduler(ctx, async () => {
        const dataSpaceManager = await this._getDataSpaceManager();
        const spaces = await Promise.all(Array.from(dataSpaceManager.spaces.values()).map((space) => this._serializeSpace(space)));
        (0, import_log9.log)("update", () => ({
          ids: spaces.map((space) => space.id)
        }), {
          F: __dxlog_file11,
          L: 134,
          S: this,
          C: (f, a) => f(...a)
        });
        await this._updateMetrics();
        next({
          spaces
        });
      }, {
        maxFrequency: process.env.NODE_ENV === "test" ? void 0 : 2
      });
      (0, import_async12.scheduleTask)(ctx, async () => {
        const dataSpaceManager = await this._getDataSpaceManager();
        const subscriptions = new import_async12.SubscriptionList();
        ctx.onDispose(() => subscriptions.clear());
        const subscribeSpaces = () => {
          subscriptions.clear();
          for (const space of dataSpaceManager.spaces.values()) {
            let lastState;
            subscriptions.add(space.stateUpdate.on(ctx, () => {
              if (space.state !== lastState) {
                scheduler.forceTrigger();
              } else {
                scheduler.trigger();
              }
              lastState = space.state;
            }));
            subscriptions.add(space.presence.updated.on(ctx, () => scheduler.trigger()));
            subscriptions.add(space.automergeSpaceState.onNewEpoch.on(ctx, () => scheduler.trigger()));
            subscriptions.add(space.inner.controlPipeline.state.timeframeUpdate.on(ctx, () => scheduler.trigger()));
          }
        };
        dataSpaceManager.updated.on(ctx, () => {
          subscribeSpaces();
          scheduler.trigger();
        });
        subscribeSpaces();
        scheduler.trigger();
      });
      if (!this._identityManager.identity) {
        next({
          spaces: []
        });
      }
    });
  }
  async postMessage({ spaceKey, channel, message }) {
    const dataSpaceManager = await this._getDataSpaceManager();
    const space = dataSpaceManager.spaces.get(spaceKey) ?? (0, import_debug3.raise)(new import_protocols6.SpaceNotFoundError(spaceKey));
    await space.postMessage(getChannelId(channel), message);
  }
  subscribeMessages({ spaceKey, channel }) {
    return new import_stream7.Stream(({ ctx, next }) => {
      (0, import_async12.scheduleTask)(ctx, async () => {
        const dataSpaceManager = await this._getDataSpaceManager();
        const space = dataSpaceManager.spaces.get(spaceKey) ?? (0, import_debug3.raise)(new import_protocols6.SpaceNotFoundError(spaceKey));
        const handle = space.listen(getChannelId(channel), (message) => {
          next(message);
        });
        ctx.onDispose(() => handle.unsubscribe());
      });
    });
  }
  queryCredentials({ spaceKey, noTail }) {
    return new import_stream7.Stream(({ ctx, next, close }) => {
      const space = this._spaceManager.spaces.get(spaceKey) ?? (0, import_debug3.raise)(new import_protocols6.SpaceNotFoundError(spaceKey));
      const processor = {
        processCredential: async (credential) => {
          next(credential);
        }
      };
      ctx.onDispose(() => space.spaceState.removeCredentialProcessor(processor));
      (0, import_async12.scheduleTask)(ctx, async () => {
        await space.spaceState.addCredentialProcessor(processor);
        if (noTail) {
          close();
        }
      });
    });
  }
  async writeCredentials({ spaceKey, credentials }) {
    const space = this._spaceManager.spaces.get(spaceKey) ?? (0, import_debug3.raise)(new import_protocols6.SpaceNotFoundError(spaceKey));
    for (const credential of credentials ?? []) {
      if (credential.proof) {
        await space.controlPipeline.writer.write({
          credential: {
            credential
          }
        });
      } else {
        (0, import_invariant8.invariant)(!credential.id, "Id on unsigned credentials is not allowed", {
          F: __dxlog_file11,
          L: 232,
          S: this,
          A: [
            "!credential.id",
            "'Id on unsigned credentials is not allowed'"
          ]
        });
        (0, import_invariant8.invariant)(this._identityManager.identity, "Identity is not available", {
          F: __dxlog_file11,
          L: 233,
          S: this,
          A: [
            "this._identityManager.identity",
            "'Identity is not available'"
          ]
        });
        const signer = this._identityManager.identity.getIdentityCredentialSigner();
        (0, import_invariant8.invariant)(credential.issuer.equals(signer.getIssuer()), void 0, {
          F: __dxlog_file11,
          L: 235,
          S: this,
          A: [
            "credential.issuer.equals(signer.getIssuer())",
            ""
          ]
        });
        const signedCredential = await signer.createCredential({
          subject: credential.subject.id,
          assertion: credential.subject.assertion
        });
        await space.controlPipeline.writer.write({
          credential: {
            credential: signedCredential
          }
        });
      }
    }
  }
  async createEpoch({ spaceKey, migration, automergeRootUrl }) {
    const dataSpaceManager = await this._getDataSpaceManager();
    const space = dataSpaceManager.spaces.get(spaceKey) ?? (0, import_debug3.raise)(new import_protocols6.SpaceNotFoundError(spaceKey));
    const result = await space.createEpoch({
      migration,
      newAutomergeRoot: automergeRootUrl
    });
    return {
      epochCredential: result?.credential,
      controlTimeframe: result?.timeframe
    };
  }
  async admitContact(request) {
    const dataSpaceManager = await this._getDataSpaceManager();
    await dataSpaceManager.admitMember({
      spaceKey: request.spaceKey,
      identityKey: request.contact.identityKey,
      role: request.role
    });
  }
  async joinBySpaceKey({ spaceKey }) {
    const dataSpaceManager = await this._getDataSpaceManager();
    const credential = await dataSpaceManager.requestSpaceAdmissionCredential(spaceKey);
    return this._joinByAdmission({
      credential
    });
  }
  async exportSpace(request) {
    const env = {
      stack: [],
      error: void 0,
      hasError: false
    };
    try {
      const writer = _ts_add_disposable_resource2(env, await new SpaceArchiveWriter().open(), true);
      (0, import_invariant8.assertArgument)(import_keys9.SpaceId.isValid(request.spaceId), "Invalid space ID");
      const dataSpaceManager = await this._getDataSpaceManager();
      const space = dataSpaceManager.getSpaceById(request.spaceId) ?? (0, import_debug3.raise)(new Error("Space not found"));
      await writer.begin({
        spaceId: space.id
      });
      const rootUrl = space.automergeSpaceState.lastEpoch?.subject.assertion.automergeRoot;
      (0, import_invariant8.assertState)(rootUrl, "Space does not have a root URL");
      await writer.setCurrentRootUrl(rootUrl);
      for await (const [documentId, data] of space.getAllDocuments()) {
        await writer.writeDocument(documentId, data);
      }
      const archive = await writer.finish();
      return {
        archive
      };
    } catch (e) {
      env.error = e;
      env.hasError = true;
    } finally {
      const result = _ts_dispose_resources2(env);
      if (result) await result;
    }
  }
  async importSpace(request) {
    const dataSpaceManager = await this._getDataSpaceManager();
    const extracted = await extractSpaceArchive(request.archive);
    (0, import_invariant8.invariant)(extracted.metadata.echo?.currentRootUrl, "Space archive does not contain a root URL", {
      F: __dxlog_file11,
      L: 289,
      S: this,
      A: [
        "extracted.metadata.echo?.currentRootUrl",
        "'Space archive does not contain a root URL'"
      ]
    });
    const space = await dataSpaceManager.createSpace({
      documents: extracted.documents,
      rootUrl: extracted.metadata.echo?.currentRootUrl
    });
    await this._updateMetrics();
    return {
      newSpaceId: space.id
    };
  }
  async _joinByAdmission({ credential }) {
    const assertion = (0, import_credentials13.getCredentialAssertion)(credential);
    (0, import_invariant8.invariant)(assertion["@type"] === "dxos.halo.credentials.SpaceMember", "Invalid credential", {
      F: __dxlog_file11,
      L: 300,
      S: this,
      A: [
        "assertion['@type'] === 'dxos.halo.credentials.SpaceMember'",
        "'Invalid credential'"
      ]
    });
    const myIdentity = this._identityManager.identity;
    (0, import_invariant8.invariant)(myIdentity && credential.subject.id.equals(myIdentity.identityKey), void 0, {
      F: __dxlog_file11,
      L: 302,
      S: this,
      A: [
        "myIdentity && credential.subject.id.equals(myIdentity.identityKey)",
        ""
      ]
    });
    const dataSpaceManager = await this._getDataSpaceManager();
    let dataSpace = dataSpaceManager.spaces.get(assertion.spaceKey);
    if (!dataSpace) {
      dataSpace = await dataSpaceManager.acceptSpace({
        spaceKey: assertion.spaceKey,
        genesisFeedKey: assertion.genesisFeedKey
      });
      await myIdentity.controlPipeline.writer.write({
        credential: {
          credential
        }
      });
    }
    return {
      space: await this._serializeSpace(dataSpace)
    };
  }
  async _serializeSpace(space) {
    return {
      id: space.id,
      spaceKey: space.key,
      state: space.state,
      error: space.error ? (0, import_protocols6.encodeError)(space.error) : void 0,
      pipeline: {
        currentEpoch: space.automergeSpaceState.lastEpoch,
        appliedEpoch: space.automergeSpaceState.lastEpoch,
        controlFeeds: space.inner.controlPipeline.state.feeds.map((feed) => feed.key),
        currentControlTimeframe: space.inner.controlPipeline.state.timeframe,
        targetControlTimeframe: space.inner.controlPipeline.state.targetTimeframe,
        totalControlTimeframe: space.inner.controlPipeline.state.endTimeframe,
        dataFeeds: void 0,
        startDataTimeframe: void 0,
        currentDataTimeframe: void 0,
        targetDataTimeframe: void 0,
        totalDataTimeframe: void 0,
        spaceRootUrl: space.databaseRoot?.url
      },
      members: await Promise.all(Array.from(space.inner.spaceState.members.values()).map(async (member) => {
        const peers = space.presence.getPeersOnline().filter(({ identityKey }) => identityKey.equals(member.key));
        const isMe = this._identityManager.identity?.identityKey.equals(member.key);
        if (isMe) {
          peers.push(space.presence.getLocalState());
        }
        return {
          identity: {
            did: await (0, import_credentials13.createDidFromIdentityKey)(member.key),
            identityKey: member.key,
            profile: member.profile ?? {}
          },
          role: member.role,
          presence: peers.length > 0 ? import_services8.SpaceMember.PresenceState.ONLINE : import_services8.SpaceMember.PresenceState.OFFLINE,
          peerStates: peers
        };
      })),
      creator: space.inner.spaceState.creator?.key,
      cache: space.cache,
      metrics: space.metrics,
      edgeReplication: space.getEdgeReplicationSetting()
    };
  }
  _requireIdentity() {
    if (!this._identityManager.identity) {
      throw new import_protocols6.IdentityNotInitializedError("This device has no HALO identity available. See https://docs.dxos.org/guide/platform/halo");
    }
    return this._identityManager.identity;
  }
  async _updateMetrics() {
    const dataSpaceManager = await this._getDataSpaceManager();
    const identity = this._identityManager.identity?.identityKey.truncate();
    if (identity) {
      import_tracing6.trace.metrics.gauge("dxos.echo.space.count", dataSpaceManager.spaces.size, {
        tags: {
          identity
        }
      });
    }
  }
};
var getChannelId = (channel) => `user-channel/${channel}`;
function _ts_decorate4(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file12 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/identity/identity.ts";
var Identity = class {
  constructor(params) {
    this._edgeFeedReplicator = void 0;
    this.stateUpdate = new import_async10.Event();
    this._onFeedAdded = async (feed) => {
      await this._edgeFeedReplicator.addFeed(feed);
    };
    this.space = params.space;
    this._signer = params.signer;
    this._presence = params.presence;
    this.did = params.did;
    this.identityKey = params.identityKey;
    this.deviceKey = params.deviceKey;
    import_log6.log.trace("dxos.halo.device", {
      deviceKey: params.deviceKey
    }, {
      F: __dxlog_file12,
      L: 82,
      S: this,
      C: (f, a) => f(...a)
    });
    this._deviceStateMachine = new import_credentials6.DeviceStateMachine({
      identityKey: this.identityKey,
      deviceKey: this.deviceKey,
      onUpdate: () => this.stateUpdate.emit()
    });
    this._profileStateMachine = new import_credentials6.ProfileStateMachine({
      identityKey: this.identityKey,
      onUpdate: () => this.stateUpdate.emit()
    });
    this._defaultSpaceStateMachine = new DefaultSpaceStateMachine({
      identityKey: this.identityKey,
      onUpdate: () => this.stateUpdate.emit()
    });
    this.authVerifier = new TrustedKeySetAuthVerifier({
      trustedKeysProvider: () => new import_util6.ComplexSet(import_keys6.PublicKey.hash, this.authorizedDeviceKeys.keys()),
      update: this.stateUpdate,
      authTimeout: import_client_protocol3.AUTH_TIMEOUT
    });
    if (params.edgeConnection && params.edgeFeatures?.feedReplicator) {
      this._edgeFeedReplicator = new EdgeFeedReplicator({
        messenger: params.edgeConnection,
        spaceId: this.space.id
      });
    }
  }
  // TODO(burdon): Expose state object?
  get authorizedDeviceKeys() {
    return this._deviceStateMachine.authorizedDeviceKeys;
  }
  get defaultSpaceId() {
    return this._defaultSpaceStateMachine.spaceId;
  }
  async open(ctx) {
    await this._presence?.open();
    await this.space.spaceState.addCredentialProcessor(this._deviceStateMachine);
    await this.space.spaceState.addCredentialProcessor(this._profileStateMachine);
    await this.space.spaceState.addCredentialProcessor(this._defaultSpaceStateMachine);
    if (this._edgeFeedReplicator) {
      this.space.protocol.feedAdded.append(this._onFeedAdded);
    }
    await this.space.open(ctx);
  }
  async joinNetwork() {
    await this.space.startProtocol();
    await this._edgeFeedReplicator?.open();
  }
  async close(ctx) {
    await this._presence?.close();
    await this.authVerifier.close();
    await this.space.spaceState.removeCredentialProcessor(this._defaultSpaceStateMachine);
    await this.space.spaceState.removeCredentialProcessor(this._profileStateMachine);
    await this.space.spaceState.removeCredentialProcessor(this._deviceStateMachine);
    if (this._edgeFeedReplicator) {
      this.space.protocol.feedAdded.remove(this._onFeedAdded);
    }
    await this._edgeFeedReplicator?.close();
    await this.space.close();
  }
  async ready() {
    await this._deviceStateMachine.deviceChainReady.wait();
    await this.controlPipeline.state.waitUntilReachedTargetTimeframe({
      timeout: import_client_protocol3.LOAD_CONTROL_FEEDS_TIMEOUT
    });
  }
  get profileDocument() {
    return this._profileStateMachine.profile;
  }
  /**
  * @test-only
  */
  get controlPipeline() {
    return this.space.controlPipeline;
  }
  get haloSpaceId() {
    return this.space.id;
  }
  get haloSpaceKey() {
    return this.space.key;
  }
  get haloGenesisFeedKey() {
    return this.space.genesisFeedKey;
  }
  get deviceCredentialChain() {
    return this._deviceStateMachine.deviceCredentialChain;
  }
  get presence() {
    return this._presence;
  }
  get signer() {
    return this._signer;
  }
  /**
  * Issues credentials as identity.
  * Requires identity to be ready.
  */
  getIdentityCredentialSigner() {
    (0, import_invariant6.invariant)(this._deviceStateMachine.deviceCredentialChain, "Device credential chain is not ready.", {
      F: __dxlog_file12,
      L: 198,
      S: this,
      A: [
        "this._deviceStateMachine.deviceCredentialChain",
        "'Device credential chain is not ready.'"
      ]
    });
    return (0, import_credentials6.createCredentialSignerWithChain)(this._signer, this._deviceStateMachine.deviceCredentialChain, this.deviceKey);
  }
  /**
  * Issues credentials as device.
  */
  getDeviceCredentialSigner() {
    return (0, import_credentials6.createCredentialSignerWithKey)(this._signer, this.deviceKey);
  }
  async updateDefaultSpace(spaceId) {
    const credential = await this.getDeviceCredentialSigner().createCredential({
      subject: this.identityKey,
      assertion: {
        "@type": "dxos.halo.credentials.DefaultSpace",
        spaceId
      }
    });
    const receipt = await this.controlPipeline.writer.write({
      credential: {
        credential
      }
    });
    await this.controlPipeline.state.waitUntilTimeframe(new import_timeframe2.Timeframe([
      [
        receipt.feedKey,
        receipt.seq
      ]
    ]));
  }
  async admitDevice({ deviceKey, controlFeedKey, dataFeedKey }) {
    (0, import_log6.log)("Admitting device:", {
      identityKey: this.identityKey,
      hostDevice: this.deviceKey,
      deviceKey,
      controlFeedKey,
      dataFeedKey
    }, {
      F: __dxlog_file12,
      L: 223,
      S: this,
      C: (f, a) => f(...a)
    });
    const signer = this.getIdentityCredentialSigner();
    const deviceCredential = await signer.createCredential({
      subject: deviceKey,
      assertion: {
        "@type": "dxos.halo.credentials.AuthorizedDevice",
        identityKey: this.identityKey,
        deviceKey
      }
    });
    await (0, import_feed_store2.writeMessages)(this.controlPipeline.writer, [
      deviceCredential,
      await signer.createCredential({
        subject: controlFeedKey,
        assertion: {
          "@type": "dxos.halo.credentials.AdmittedFeed",
          spaceKey: this.haloSpaceKey,
          deviceKey,
          identityKey: this.identityKey,
          designation: import_credentials7.AdmittedFeed.Designation.CONTROL
        }
      }),
      await signer.createCredential({
        subject: dataFeedKey,
        assertion: {
          "@type": "dxos.halo.credentials.AdmittedFeed",
          spaceKey: this.haloSpaceKey,
          deviceKey,
          identityKey: this.identityKey,
          designation: import_credentials7.AdmittedFeed.Designation.DATA
        }
      })
    ].map((credential) => ({
      credential: {
        credential
      }
    })));
    return deviceCredential;
  }
};
_ts_decorate4([
  import_tracing4.trace.span()
], Identity.prototype, "open", null);
_ts_decorate4([
  import_tracing4.trace.span()
], Identity.prototype, "close", null);
Identity = _ts_decorate4([
  import_tracing4.trace.resource()
], Identity);
function _ts_decorate5(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file13 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/identity/identity-manager.ts";
var DEVICE_PRESENCE_ANNOUNCE_INTERVAL = 1e4;
var DEVICE_PRESENCE_OFFLINE_TIMEOUT = 2e4;
var IdentityManager = class {
  // TODO(dmaretskyi): Perhaps this should take/generate the peerKey outside of an initialized identity.
  constructor(params) {
    this.stateUpdate = new import_async13.Event();
    this._metadataStore = params.metadataStore;
    this._keyring = params.keyring;
    this._feedStore = params.feedStore;
    this._spaceManager = params.spaceManager;
    this._edgeConnection = params.edgeConnection;
    this._edgeFeatures = params.edgeFeatures;
    this._devicePresenceAnnounceInterval = params.devicePresenceAnnounceInterval ?? DEVICE_PRESENCE_ANNOUNCE_INTERVAL;
    this._devicePresenceOfflineTimeout = params.devicePresenceOfflineTimeout ?? DEVICE_PRESENCE_OFFLINE_TIMEOUT;
  }
  get identity() {
    return this._identity;
  }
  async open(ctx) {
    const traceId = import_keys10.PublicKey.random().toHex();
    import_log11.log.trace("dxos.halo.identity-manager.open", import_protocols9.trace.begin({
      id: traceId
    }), {
      F: __dxlog_file13,
      L: 116,
      S: this,
      C: (f, a) => f(...a)
    });
    const identityRecord = this._metadataStore.getIdentityRecord();
    (0, import_log11.log)("identity record", {
      identityRecord
    }, {
      F: __dxlog_file13,
      L: 119,
      S: this,
      C: (f, a) => f(...a)
    });
    if (identityRecord) {
      this._identity = await this._constructIdentity(identityRecord);
      await this._identity.open(ctx);
      await this._identity.ready();
      import_log11.log.trace("dxos.halo.identity", {
        identityKey: identityRecord.identityKey,
        displayName: this._identity.profileDocument?.displayName
      }, {
        F: __dxlog_file13,
        L: 124,
        S: this,
        C: (f, a) => f(...a)
      });
      this.stateUpdate.emit();
    }
    import_log11.log.trace("dxos.halo.identity-manager.open", import_protocols9.trace.end({
      id: traceId
    }), {
      F: __dxlog_file13,
      L: 131,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  async close() {
    await this._identity?.close(new import_context9.Context(void 0, {
      F: __dxlog_file13,
      L: 135
    }));
  }
  async createIdentity({ profile, deviceProfile } = {}) {
    (0, import_invariant11.invariant)(!this._identity, "Identity already exists.", {
      F: __dxlog_file13,
      L: 140,
      S: this,
      A: [
        "!this._identity",
        "'Identity already exists.'"
      ]
    });
    (0, import_log11.log)("creating identity...", void 0, {
      F: __dxlog_file13,
      L: 141,
      S: this,
      C: (f, a) => f(...a)
    });
    const controlFeedKey = await this._keyring.createKey();
    const identityRecord = {
      identityKey: await this._keyring.createKey(),
      deviceKey: await this._keyring.createKey(),
      haloSpace: {
        key: await this._keyring.createKey(),
        genesisFeedKey: controlFeedKey,
        controlFeedKey,
        dataFeedKey: await this._keyring.createKey()
      }
    };
    const identity = await this._constructIdentity(identityRecord);
    await identity.open(new import_context9.Context(void 0, {
      F: __dxlog_file13,
      L: 156
    }));
    {
      const generator = new import_credentials14.CredentialGenerator(this._keyring, identityRecord.identityKey, identityRecord.deviceKey);
      (0, import_invariant11.invariant)(identityRecord.haloSpace.genesisFeedKey, "Genesis feed key is required.", {
        F: __dxlog_file13,
        L: 160,
        S: this,
        A: [
          "identityRecord.haloSpace.genesisFeedKey",
          "'Genesis feed key is required.'"
        ]
      });
      (0, import_invariant11.invariant)(identityRecord.haloSpace.dataFeedKey, "Data feed key is required.", {
        F: __dxlog_file13,
        L: 161,
        S: this,
        A: [
          "identityRecord.haloSpace.dataFeedKey",
          "'Data feed key is required.'"
        ]
      });
      const credentials = [
        // Space genesis.
        ...await generator.createSpaceGenesis(identityRecord.haloSpace.key, identityRecord.haloSpace.genesisFeedKey),
        // Feed admission.
        await generator.createFeedAdmission(identityRecord.haloSpace.key, identityRecord.haloSpace.dataFeedKey, import_credentials15.AdmittedFeed.Designation.DATA)
      ];
      if (profile) {
        credentials.push(await generator.createProfileCredential(profile));
      }
      credentials.push(await generator.createDeviceAuthorization(identityRecord.deviceKey));
      credentials.push(await generator.createDeviceProfile({
        ...this.createDefaultDeviceProfile(),
        ...deviceProfile
      }));
      for (const credential of credentials) {
        await identity.controlPipeline.writer.write({
          credential: {
            credential
          }
        });
      }
    }
    await this._metadataStore.setIdentityRecord(identityRecord);
    this._identity = identity;
    await this._identity.ready();
    import_log11.log.trace("dxos.halo.identity", {
      identityKey: identityRecord.identityKey,
      displayName: this._identity.profileDocument?.displayName
    }, {
      F: __dxlog_file13,
      L: 199,
      S: this,
      C: (f, a) => f(...a)
    });
    this.stateUpdate.emit();
    (0, import_log11.log)("created identity", {
      identityKey: identity.identityKey,
      deviceKey: identity.deviceKey,
      profile: identity.profileDocument
    }, {
      F: __dxlog_file13,
      L: 205,
      S: this,
      C: (f, a) => f(...a)
    });
    return identity;
  }
  // TODO(nf): receive platform info rather than generating it here.
  createDefaultDeviceProfile() {
    let type;
    if ((0, import_util8.isNode)()) {
      type = import_credentials15.DeviceType.AGENT;
    } else {
      if (import_platform.default.name?.startsWith("iOS") || import_platform.default.name?.startsWith("Android")) {
        type = import_credentials15.DeviceType.MOBILE;
      } else if (globalThis.__args) {
        type = import_credentials15.DeviceType.NATIVE;
      } else {
        type = import_credentials15.DeviceType.BROWSER;
      }
    }
    return {
      type,
      platform: import_platform.default.name,
      platformVersion: import_platform.default.version,
      architecture: typeof import_platform.default.os?.architecture === "number" ? String(import_platform.default.os.architecture) : void 0,
      os: import_platform.default.os?.family,
      osVersion: import_platform.default.os?.version
    };
  }
  /**
  * Prepare an identity object as the first step of acceptIdentity flow.
  */
  async prepareIdentity(params) {
    (0, import_log11.log)("accepting identity", {
      params
    }, {
      F: __dxlog_file13,
      L: 244,
      S: this,
      C: (f, a) => f(...a)
    });
    (0, import_invariant11.invariant)(!this._identity, "Identity already exists.", {
      F: __dxlog_file13,
      L: 245,
      S: this,
      A: [
        "!this._identity",
        "'Identity already exists.'"
      ]
    });
    const identityRecord = {
      identityKey: params.identityKey,
      deviceKey: params.deviceKey,
      haloSpace: {
        key: params.haloSpaceKey,
        genesisFeedKey: params.haloGenesisFeedKey,
        controlFeedKey: params.controlFeedKey,
        dataFeedKey: params.dataFeedKey,
        controlTimeframe: params.controlTimeframe
      }
    };
    const identity = await this._constructIdentity(identityRecord);
    await identity.open(new import_context9.Context(void 0, {
      F: __dxlog_file13,
      L: 259
    }));
    return {
      identity,
      identityRecord
    };
  }
  /**
  * Accept an existing identity. Expects its device key to be authorized (now or later).
  */
  async acceptIdentity(identity, identityRecord, profile) {
    this._identity = identity;
    await this._identity.ready();
    await this._metadataStore.setIdentityRecord(identityRecord);
    import_log11.log.trace("dxos.halo.identity", {
      identityKey: this._identity.identityKey,
      displayName: this._identity.profileDocument?.displayName
    }, {
      F: __dxlog_file13,
      L: 277,
      S: this,
      C: (f, a) => f(...a)
    });
    await this.updateDeviceProfile({
      ...this.createDefaultDeviceProfile(),
      ...profile
    });
    this.stateUpdate.emit();
    (0, import_log11.log)("accepted identity", {
      identityKey: identity.identityKey,
      deviceKey: identity.deviceKey
    }, {
      F: __dxlog_file13,
      L: 288,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  /**
  * Update the profile document of an existing identity.
  */
  async updateProfile(profile) {
    (0, import_invariant11.invariant)(this._identity, "Identity not initialized.", {
      F: __dxlog_file13,
      L: 295,
      S: this,
      A: [
        "this._identity",
        "'Identity not initialized.'"
      ]
    });
    const credential = await this._identity.getIdentityCredentialSigner().createCredential({
      subject: this._identity.identityKey,
      assertion: {
        "@type": "dxos.halo.credentials.IdentityProfile",
        profile
      }
    });
    const receipt = await this._identity.controlPipeline.writer.write({
      credential: {
        credential
      }
    });
    await this._identity.controlPipeline.state.waitUntilTimeframe(new import_timeframe4.Timeframe([
      [
        receipt.feedKey,
        receipt.seq
      ]
    ]));
    this.stateUpdate.emit();
    return profile;
  }
  async updateDeviceProfile(profile) {
    (0, import_invariant11.invariant)(this._identity, "Identity not initialized.", {
      F: __dxlog_file13,
      L: 312,
      S: this,
      A: [
        "this._identity",
        "'Identity not initialized.'"
      ]
    });
    const credential = await this._identity.getDeviceCredentialSigner().createCredential({
      subject: this._identity.deviceKey,
      assertion: {
        "@type": "dxos.halo.credentials.DeviceProfile",
        profile
      }
    });
    const receipt = await this._identity.controlPipeline.writer.write({
      credential: {
        credential
      }
    });
    await this._identity.controlPipeline.state.waitUntilTimeframe(new import_timeframe4.Timeframe([
      [
        receipt.feedKey,
        receipt.seq
      ]
    ]));
    this.stateUpdate.emit();
    return {
      deviceKey: this._identity.deviceKey,
      kind: import_services9.DeviceKind.CURRENT,
      presence: import_services9.Device.PresenceState.ONLINE,
      profile
    };
  }
  async _constructIdentity(identityRecord) {
    (0, import_invariant11.invariant)(!this._identity, void 0, {
      F: __dxlog_file13,
      L: 338,
      S: this,
      A: [
        "!this._identity",
        ""
      ]
    });
    (0, import_log11.log)("constructing identity", {
      identityRecord
    }, {
      F: __dxlog_file13,
      L: 339,
      S: this,
      C: (f, a) => f(...a)
    });
    const gossip = new import_teleport_extension_gossip2.Gossip({
      localPeerId: identityRecord.deviceKey
    });
    const presence = new import_teleport_extension_gossip2.Presence({
      announceInterval: this._devicePresenceAnnounceInterval,
      offlineTimeout: this._devicePresenceOfflineTimeout,
      identityKey: identityRecord.deviceKey,
      gossip
    });
    (0, import_invariant11.invariant)(identityRecord.haloSpace.controlFeedKey, void 0, {
      F: __dxlog_file13,
      L: 352,
      S: this,
      A: [
        "identityRecord.haloSpace.controlFeedKey",
        ""
      ]
    });
    const controlFeed = await this._feedStore.openFeed(identityRecord.haloSpace.controlFeedKey, {
      writable: true
    });
    (0, import_invariant11.invariant)(identityRecord.haloSpace.dataFeedKey, void 0, {
      F: __dxlog_file13,
      L: 356,
      S: this,
      A: [
        "identityRecord.haloSpace.dataFeedKey",
        ""
      ]
    });
    const dataFeed = await this._feedStore.openFeed(identityRecord.haloSpace.dataFeedKey, {
      writable: true,
      sparse: true
    });
    const space = await this._constructSpace({
      spaceRecord: identityRecord.haloSpace,
      swarmIdentity: {
        identityKey: identityRecord.identityKey,
        peerKey: identityRecord.deviceKey,
        credentialProvider: createAuthProvider((0, import_credentials14.createCredentialSignerWithKey)(this._keyring, identityRecord.deviceKey)),
        credentialAuthenticator: (0, import_util8.deferFunction)(() => identity.authVerifier.verifier)
      },
      gossip,
      identityKey: identityRecord.identityKey
    });
    await space.setControlFeed(controlFeed);
    await space.setDataFeed(dataFeed);
    const did = await (0, import_credentials14.createDidFromIdentityKey)(identityRecord.identityKey);
    const identity = new Identity({
      space,
      presence,
      signer: this._keyring,
      did,
      identityKey: identityRecord.identityKey,
      deviceKey: identityRecord.deviceKey,
      edgeConnection: this._edgeConnection,
      edgeFeatures: this._edgeFeatures
    });
    (0, import_log11.log)("done", {
      identityKey: identityRecord.identityKey
    }, {
      F: __dxlog_file13,
      L: 387,
      S: this,
      C: (f, a) => f(...a)
    });
    if (identityRecord.haloSpace.controlTimeframe) {
      identity.controlPipeline.state.setTargetTimeframe(identityRecord.haloSpace.controlTimeframe);
    }
    identity.stateUpdate.on(() => this.stateUpdate.emit());
    return identity;
  }
  async _constructSpace({ spaceRecord, swarmIdentity, identityKey, gossip }) {
    return this._spaceManager.constructSpace({
      metadata: {
        key: spaceRecord.key,
        genesisFeedKey: spaceRecord.genesisFeedKey
      },
      swarmIdentity,
      onAuthorizedConnection: (session) => {
        session.addExtension("dxos.mesh.teleport.gossip", gossip.createExtension({
          remotePeerId: session.remotePeerId
        }));
      },
      onAuthFailure: () => {
        import_log11.log.warn("auth failure", void 0, {
          F: __dxlog_file13,
          L: 412,
          S: this,
          C: (f, a) => f(...a)
        });
      },
      memberKey: identityKey,
      onDelegatedInvitationStatusChange: async () => {
      },
      onMemberRolesChanged: async () => {
      }
    });
  }
};
_ts_decorate5([
  import_tracing7.trace.span({
    showInBrowserTimeline: true
  })
], IdentityManager.prototype, "open", null);
IdentityManager = _ts_decorate5([
  import_tracing7.trace.resource()
], IdentityManager);
var __dxlog_file14 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/identity/identity-service.ts";
var DEFAULT_SPACE_SEARCH_TIMEOUT = 1e4;
var IdentityServiceImpl = class extends import_context10.Resource {
  constructor(_identityManager, _recoveryManager, _keyring, _dataSpaceManagerProvider, _createIdentity, _onProfileUpdate) {
    super(), this._identityManager = _identityManager, this._recoveryManager = _recoveryManager, this._keyring = _keyring, this._dataSpaceManagerProvider = _dataSpaceManagerProvider, this._createIdentity = _createIdentity, this._onProfileUpdate = _onProfileUpdate;
  }
  async _open() {
    const identity = this._identityManager.identity;
    if (identity && !identity.defaultSpaceId) {
      await this._fixIdentityWithoutDefaultSpace(identity);
    }
  }
  async createIdentity(request) {
    await this._createIdentity({
      profile: request.profile,
      deviceProfile: request.deviceProfile
    });
    const dataSpaceManager = this._dataSpaceManagerProvider();
    await this._createDefaultSpace(dataSpaceManager);
    return this._getIdentity();
  }
  async _createDefaultSpace(dataSpaceManager) {
    const space = await dataSpaceManager.createDefaultSpace();
    const identity = this._identityManager.identity;
    (0, import_invariant12.invariant)(identity, void 0, {
      F: __dxlog_file14,
      L: 61,
      S: this,
      A: [
        "identity",
        ""
      ]
    });
    await identity.updateDefaultSpace(space.id);
  }
  queryIdentity() {
    return new import_stream8.Stream(({ next }) => {
      const emitNext = () => next({
        identity: this._getIdentity()
      });
      emitNext();
      return this._identityManager.stateUpdate.on(emitNext);
    });
  }
  _getIdentity() {
    if (!this._identityManager.identity) {
      return void 0;
    }
    return {
      did: this._identityManager.identity.did,
      identityKey: this._identityManager.identity.identityKey,
      spaceKey: this._identityManager.identity.space.key,
      profile: this._identityManager.identity.profileDocument
    };
  }
  async updateProfile(profile) {
    (0, import_invariant12.invariant)(this._identityManager.identity, "Identity not initialized.", {
      F: __dxlog_file14,
      L: 88,
      S: this,
      A: [
        "this._identityManager.identity",
        "'Identity not initialized.'"
      ]
    });
    await this._identityManager.updateProfile(profile);
    await this._onProfileUpdate?.(this._identityManager.identity.profileDocument);
    return this._getIdentity();
  }
  async createRecoveryCredential(request) {
    return this._recoveryManager.createRecoveryCredential(request);
  }
  async requestRecoveryChallenge() {
    return this._recoveryManager.requestRecoveryChallenge();
  }
  async recoverIdentity(request) {
    if (request.recoveryCode) {
      await this._recoveryManager.recoverIdentity({
        recoveryCode: request.recoveryCode
      });
    } else if (request.external) {
      await this._recoveryManager.recoverIdentityWithExternalSignature(request.external);
    } else if (request.token) {
      await this._recoveryManager.recoverIdentityWithToken({
        token: request.token
      });
    } else {
      throw new Error("Invalid request.");
    }
    return this._getIdentity();
  }
  // TODO(burdon): Rename createPresentation?
  async signPresentation({ presentation, nonce }) {
    (0, import_invariant12.invariant)(this._identityManager.identity, "Identity not initialized.", {
      F: __dxlog_file14,
      L: 118,
      S: this,
      A: [
        "this._identityManager.identity",
        "'Identity not initialized.'"
      ]
    });
    return await (0, import_credentials16.signPresentation)({
      presentation,
      signer: this._keyring,
      signerKey: this._identityManager.identity.deviceKey,
      chain: this._identityManager.identity.deviceCredentialChain,
      nonce
    });
  }
  async createAuthCredential() {
    const identity = this._identityManager.identity;
    (0, import_invariant12.invariant)(identity, "Identity not initialized.", {
      F: __dxlog_file14,
      L: 132,
      S: this,
      A: [
        "identity",
        "'Identity not initialized.'"
      ]
    });
    return await (0, import_credentials16.createCredential)({
      assertion: {
        "@type": "dxos.halo.credentials.Auth"
      },
      issuer: identity.identityKey,
      subject: identity.identityKey,
      chain: identity.deviceCredentialChain,
      signingKey: identity.deviceKey,
      signer: this._keyring
    });
  }
  async _fixIdentityWithoutDefaultSpace(identity) {
    let recodedDefaultSpace = false;
    let foundDefaultSpace = false;
    const dataSpaceManager = this._dataSpaceManagerProvider();
    const recordedDefaultSpaceTrigger = new import_async14.Trigger();
    const allProcessed = (0, import_util9.safeAwaitAll)(dataSpaceManager.spaces.values(), async (space) => {
      if (space.state === import_services10.SpaceState.SPACE_CLOSED) {
        await space.open();
        const requiresMigration = space.stateUpdate.waitForCondition(() => space.state === import_services10.SpaceState.SPACE_REQUIRES_MIGRATION);
        await Promise.race([
          space.initializeDataPipeline(),
          requiresMigration
        ]);
      }
      if (await dataSpaceManager.isDefaultSpace(space)) {
        if (foundDefaultSpace) {
          import_log12.log.warn("Multiple default spaces found. Using the first one.", {
            duplicate: space.id
          }, {
            F: __dxlog_file14,
            L: 166,
            S: this,
            C: (f, a) => f(...a)
          });
          return;
        }
        foundDefaultSpace = true;
        await identity.updateDefaultSpace(space.id);
        recodedDefaultSpace = true;
        recordedDefaultSpaceTrigger.wake();
      }
    }, (err) => {
      import_log12.log.catch(err, void 0, {
        F: __dxlog_file14,
        L: 177,
        S: this,
        C: (f, a) => f(...a)
      });
    });
    await Promise.race([
      allProcessed,
      recordedDefaultSpaceTrigger.wait(),
      (0, import_async14.sleep)(DEFAULT_SPACE_SEARCH_TIMEOUT)
    ]);
    if (!recodedDefaultSpace) {
      await this._createDefaultSpace(dataSpaceManager);
    }
  }
};
function _ts_decorate6(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function _ts_add_disposable_resource3(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = function() {
      try {
        inner.call(this);
      } catch (e) {
        return Promise.reject(e);
      }
    };
    env.stack.push({
      value,
      dispose,
      async
    });
  } else if (async) {
    env.stack.push({
      async: true
    });
  }
  return value;
}
function _ts_dispose_resources3(env) {
  var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  };
  return (_ts_dispose_resources3 = function _ts_dispose_resources5(env2) {
    function fail(e) {
      env2.error = env2.hasError ? new _SuppressedError(e, env2.error, "An error was suppressed during disposal.") : e;
      env2.hasError = true;
    }
    var r, s = 0;
    function next() {
      while (r = env2.stack.pop()) {
        try {
          if (!r.async && s === 1) return s = 0, env2.stack.push(r), Promise.resolve().then(next);
          if (r.dispose) {
            var result = r.dispose.call(r.value);
            if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
              fail(e);
              return next();
            });
          } else s |= 1;
        } catch (e) {
          fail(e);
        }
      }
      if (s === 1) return env2.hasError ? Promise.reject(env2.error) : Promise.resolve();
      if (env2.hasError) throw env2.error;
    }
    return next();
  })(env);
}
var __dxlog_file15 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/spaces/data-space.ts";
var DataSpace = class {
  constructor(params) {
    this._ctx = new import_context4.Context(void 0, {
      F: __dxlog_file15,
      L: 100
    });
    this._cache = void 0;
    this._edgeFeedReplicator = void 0;
    this._automergeSpaceState = new AutomergeSpaceState((rootUrl) => this._onNewAutomergeRoot(rootUrl));
    this._epochProcessingMutex = new import_async7.Mutex();
    this._state = import_services5.SpaceState.SPACE_CLOSED;
    this._databaseRoot = null;
    this.error = void 0;
    this.stateUpdate = new import_async7.Event();
    this.postOpen = new import_util4.CallbackCollection();
    this.preClose = new import_util4.CallbackCollection();
    this.metrics = {};
    this._onFeedAdded = async (feed) => {
      await this._edgeFeedReplicator.addFeed(feed);
    };
    this._inner = params.inner;
    this._inner.stateUpdate.on(this._ctx, () => this.stateUpdate.emit());
    this._gossip = params.gossip;
    this._presence = params.presence;
    this._keyring = params.keyring;
    this._feedStore = params.feedStore;
    this._metadataStore = params.metadataStore;
    this._signingContext = params.signingContext;
    this._callbacks = params.callbacks ?? {};
    this._echoHost = params.echoHost;
    this._notarizationPlugin = new NotarizationPlugin({
      spaceId: this._inner.id,
      edgeClient: params.edgeHttpClient,
      edgeFeatures: params.edgeFeatures,
      activeEdgePollingInterval: params.activeEdgeNotarizationPollingInterval
    });
    this.authVerifier = new TrustedKeySetAuthVerifier({
      trustedKeysProvider: () => new import_util4.ComplexSet(import_keys4.PublicKey.hash, Array.from(this._inner.spaceState.members.values()).filter((member) => member.role !== import_credentials3.SpaceMember.Role.REMOVED).map((member) => member.key)),
      update: this._inner.stateUpdate,
      authTimeout: import_client_protocol2.AUTH_TIMEOUT
    });
    this._cache = params.cache;
    if (params.edgeConnection && params.edgeFeatures?.feedReplicator) {
      this._edgeFeedReplicator = new EdgeFeedReplicator({
        messenger: params.edgeConnection,
        spaceId: this.id
      });
    }
    this._state = params.initialState;
    (0, import_log4.log)("new state", {
      state: import_services5.SpaceState[this._state]
    }, {
      F: __dxlog_file15,
      L: 176,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  get id() {
    return this._inner.id;
  }
  get key() {
    return this._inner.key;
  }
  get isOpen() {
    return this._inner.isOpen;
  }
  get state() {
    return this._state;
  }
  // TODO(burdon): Can we mark this for debugging only?
  get inner() {
    return this._inner;
  }
  get presence() {
    return this._presence;
  }
  get notarizationPlugin() {
    return this._notarizationPlugin;
  }
  get cache() {
    return this._cache;
  }
  get automergeSpaceState() {
    return this._automergeSpaceState;
  }
  get databaseRoot() {
    return this._databaseRoot;
  }
  get _automergeInfo() {
    return {
      rootUrl: this._automergeSpaceState.rootUrl,
      lastEpoch: this._automergeSpaceState.lastEpoch
    };
  }
  async open() {
    if (this._state === import_services5.SpaceState.SPACE_CLOSED) {
      await this._open();
    }
  }
  async _open() {
    await this._presence.open();
    await this._gossip.open();
    await this._notarizationPlugin.open();
    await this._inner.spaceState.addCredentialProcessor(this._notarizationPlugin);
    await this._automergeSpaceState.open();
    await this._inner.spaceState.addCredentialProcessor(this._automergeSpaceState);
    if (this._edgeFeedReplicator) {
      this.inner.protocol.feedAdded.append(this._onFeedAdded);
    }
    await this._inner.open(new import_context4.Context(void 0, {
      F: __dxlog_file15,
      L: 250
    }));
    await this._inner.startProtocol();
    await this._edgeFeedReplicator?.open();
    this._state = import_services5.SpaceState.SPACE_CONTROL_ONLY;
    (0, import_log4.log)("new state", {
      state: import_services5.SpaceState[this._state]
    }, {
      F: __dxlog_file15,
      L: 256,
      S: this,
      C: (f, a) => f(...a)
    });
    this.stateUpdate.emit();
    this.metrics = {};
    this.metrics.open = /* @__PURE__ */ new Date();
    await this.postOpen.callSerial();
  }
  async close() {
    await this._close();
  }
  async _close() {
    await this._callbacks.beforeClose?.();
    await this.preClose.callSerial();
    this._state = import_services5.SpaceState.SPACE_CLOSED;
    (0, import_log4.log)("new state", {
      state: import_services5.SpaceState[this._state]
    }, {
      F: __dxlog_file15,
      L: 275,
      S: this,
      C: (f, a) => f(...a)
    });
    await this._ctx.dispose();
    this._ctx = new import_context4.Context(void 0, {
      F: __dxlog_file15,
      L: 277
    });
    if (this._edgeFeedReplicator) {
      this.inner.protocol.feedAdded.remove(this._onFeedAdded);
    }
    await this._edgeFeedReplicator?.close();
    await this.authVerifier.close();
    await this._inner.close();
    await this._inner.spaceState.removeCredentialProcessor(this._automergeSpaceState);
    await this._automergeSpaceState.close();
    await this._inner.spaceState.removeCredentialProcessor(this._notarizationPlugin);
    await this._notarizationPlugin.close();
    await this._presence.close();
    await this._gossip.close();
  }
  async postMessage(channel, message) {
    return this._gossip.postMessage(channel, message);
  }
  listen(channel, callback) {
    return this._gossip.listen(channel, callback);
  }
  /**
  * Initialize the data pipeline in a separate task.
  */
  initializeDataPipelineAsync() {
    (0, import_async7.scheduleTask)(this._ctx, async () => {
      try {
        this.metrics.pipelineInitBegin = /* @__PURE__ */ new Date();
        await this.initializeDataPipeline();
      } catch (err) {
        if (err instanceof import_protocols3.CancelledError || err instanceof import_context4.ContextDisposedError) {
          (0, import_log4.log)("data pipeline initialization cancelled", err, {
            F: __dxlog_file15,
            L: 315,
            S: this,
            C: (f, a) => f(...a)
          });
          return;
        }
        import_log4.log.error("Error initializing data pipeline", err, {
          F: __dxlog_file15,
          L: 319,
          S: this,
          C: (f, a) => f(...a)
        });
        this._state = import_services5.SpaceState.SPACE_ERROR;
        (0, import_log4.log)("new state", {
          state: import_services5.SpaceState[this._state]
        }, {
          F: __dxlog_file15,
          L: 321,
          S: this,
          C: (f, a) => f(...a)
        });
        this.error = err;
        this.stateUpdate.emit();
      } finally {
        this.metrics.ready = /* @__PURE__ */ new Date();
      }
    });
  }
  async initializeDataPipeline() {
    if (this._state !== import_services5.SpaceState.SPACE_CONTROL_ONLY) {
      throw new import_protocols3.SystemError("Invalid operation");
    }
    this._state = import_services5.SpaceState.SPACE_INITIALIZING;
    (0, import_log4.log)("new state", {
      state: import_services5.SpaceState[this._state]
    }, {
      F: __dxlog_file15,
      L: 337,
      S: this,
      C: (f, a) => f(...a)
    });
    (0, import_log4.log)("initializing control pipeline", void 0, {
      F: __dxlog_file15,
      L: 339,
      S: this,
      C: (f, a) => f(...a)
    });
    await this._initializeAndReadControlPipeline();
    await (0, import_async7.sleep)(1);
    const ready = this.stateUpdate.waitForCondition(() => this._state === import_services5.SpaceState.SPACE_READY);
    (0, import_log4.log)("initializing automerge root", void 0, {
      F: __dxlog_file15,
      L: 347,
      S: this,
      C: (f, a) => f(...a)
    });
    this._automergeSpaceState.startProcessingRootDocs();
    (0, import_log4.log)("waiting for space to be ready", void 0, {
      F: __dxlog_file15,
      L: 351,
      S: this,
      C: (f, a) => f(...a)
    });
    await ready;
    (0, import_log4.log)("space is ready", void 0, {
      F: __dxlog_file15,
      L: 353,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  async *getAllDocuments() {
    (0, import_invariant3.invariant)(this._databaseRoot, "Space is not ready", {
      F: __dxlog_file15,
      L: 357,
      S: this,
      A: [
        "this._databaseRoot",
        "'Space is not ready'"
      ]
    });
    const doc = this._databaseRoot.doc() ?? (0, import_invariant3.failedInvariant)();
    const root = (0, import_automerge.save)(doc);
    yield [
      this._databaseRoot.documentId,
      root
    ];
    for (const documentUrl of this._databaseRoot.getAllLinkedDocuments()) {
      const data = await this._echoHost.exportDoc(import_context4.Context.default(void 0, {
        F: __dxlog_file15,
        L: 363
      }), documentUrl);
      yield [
        documentUrl.replace(/^automerge:/, ""),
        data
      ];
    }
  }
  async _enterReadyState() {
    await this._callbacks.beforeReady?.();
    this._state = import_services5.SpaceState.SPACE_READY;
    (0, import_log4.log)("new state", {
      state: import_services5.SpaceState[this._state]
    }, {
      F: __dxlog_file15,
      L: 372,
      S: this,
      C: (f, a) => f(...a)
    });
    this.stateUpdate.emit();
    await this._callbacks.afterReady?.();
  }
  async _initializeAndReadControlPipeline() {
    await this._inner.controlPipeline.state.waitUntilReachedTargetTimeframe({
      ctx: this._ctx,
      timeout: 1e4,
      breakOnStall: false
    });
    this.metrics.controlPipelineReady = /* @__PURE__ */ new Date();
    await this._createWritableFeeds();
    (0, import_log4.log)("writable feeds created", void 0, {
      F: __dxlog_file15,
      L: 389,
      S: this,
      C: (f, a) => f(...a)
    });
    this.stateUpdate.emit();
    if (!this.notarizationPlugin.hasWriter) {
      this.notarizationPlugin.setWriter((0, import_echo_pipeline.createMappedFeedWriter)((credential) => ({
        credential: {
          credential
        }
      }), this._inner.controlPipeline.writer));
    }
  }
  async _createWritableFeeds() {
    const credentials = [];
    if (!this.inner.controlFeedKey) {
      const controlFeed = await this._feedStore.openFeed(await this._keyring.createKey(), {
        writable: true
      });
      await this.inner.setControlFeed(controlFeed);
      credentials.push(await this._signingContext.credentialSigner.createCredential({
        subject: controlFeed.key,
        assertion: {
          "@type": "dxos.halo.credentials.AdmittedFeed",
          spaceKey: this.key,
          deviceKey: this._signingContext.deviceKey,
          identityKey: this._signingContext.identityKey,
          designation: import_credentials3.AdmittedFeed.Designation.CONTROL
        }
      }));
    }
    if (!this.inner.dataFeedKey) {
      const dataFeed = await this._feedStore.openFeed(await this._keyring.createKey(), {
        writable: true,
        sparse: true
      });
      await this.inner.setDataFeed(dataFeed);
      credentials.push(await this._signingContext.credentialSigner.createCredential({
        subject: dataFeed.key,
        assertion: {
          "@type": "dxos.halo.credentials.AdmittedFeed",
          spaceKey: this.key,
          deviceKey: this._signingContext.deviceKey,
          identityKey: this._signingContext.identityKey,
          designation: import_credentials3.AdmittedFeed.Designation.DATA
        }
      }));
    }
    if (credentials.length > 0) {
      try {
        (0, import_log4.log)("will notarize credentials for feed admission", {
          count: credentials.length
        }, {
          F: __dxlog_file15,
          L: 447,
          S: this,
          C: (f, a) => f(...a)
        });
        await this.notarizationPlugin.notarize({
          ctx: this._ctx,
          credentials,
          timeout: 0
        });
        (0, import_log4.log)("credentials notarized", void 0, {
          F: __dxlog_file15,
          L: 451,
          S: this,
          C: (f, a) => f(...a)
        });
      } catch (err) {
        import_log4.log.error("error notarizing credentials for feed admission", err, {
          F: __dxlog_file15,
          L: 453,
          S: this,
          C: (f, a) => f(...a)
        });
        throw err;
      }
      await this._metadataStore.setWritableFeedKeys(this.key, this.inner.controlFeedKey, this.inner.dataFeedKey);
    }
  }
  _onNewAutomergeRoot(rootUrl) {
    (0, import_log4.log)("loading automerge root doc for space", {
      space: this.key,
      rootUrl
    }, {
      F: __dxlog_file15,
      L: 463,
      S: this,
      C: (f, a) => f(...a)
    });
    let handle;
    queueMicrotask(async () => {
      try {
        const env = {
          stack: [],
          error: void 0,
          hasError: false
        };
        try {
          await (0, import_debug.warnAfterTimeout)(5e3, "Automerge root doc load timeout (DataSpace)", async () => {
            handle = await (0, import_context4.cancelWithContext)(this._ctx, this._echoHost.automergeRepo.find(rootUrl, import_echo_pipeline.FIND_PARAMS));
            await (0, import_context4.cancelWithContext)(this._ctx, handle.whenReady());
          });
          if (this._ctx.disposed) {
            return;
          }
          const _guard = _ts_add_disposable_resource3(env, await this._epochProcessingMutex.acquire(), false);
          const doc = handle.doc() ?? (0, import_invariant3.failedInvariant)();
          if (!doc.access?.spaceKey) {
            handle.change((doc2) => {
              doc2.access = {
                spaceKey: this.key.toHex()
              };
            });
          }
          const root = await this._echoHost.openSpaceRoot(this.id, handle.url);
          this._databaseRoot = root;
          if (root.getVersion() !== import_echo_protocol.SpaceDocVersion.CURRENT) {
            this._state = import_services5.SpaceState.SPACE_REQUIRES_MIGRATION;
            this.stateUpdate.emit();
          } else if (this._state !== import_services5.SpaceState.SPACE_READY) {
            await this._enterReadyState();
          } else {
            this.stateUpdate.emit();
          }
        } catch (e) {
          env.error = e;
          env.hasError = true;
        } finally {
          _ts_dispose_resources3(env);
        }
      } catch (err) {
        if (err instanceof import_context4.ContextDisposedError) {
          return;
        }
        import_log4.log.warn("error loading automerge root doc", {
          space: this.key,
          rootUrl,
          err
        }, {
          F: __dxlog_file15,
          L: 510,
          S: this,
          C: (f, a) => f(...a)
        });
      }
    });
  }
  // TODO(dmaretskyi): Use profile from signing context.
  async updateOwnProfile(profile) {
    const credential = await this._signingContext.credentialSigner.createCredential({
      subject: this._signingContext.identityKey,
      assertion: {
        "@type": "dxos.halo.credentials.MemberProfile",
        profile
      }
    });
    await this.inner.controlPipeline.writer.write({
      credential: {
        credential
      }
    });
  }
  async createEpoch(options) {
    const ctx = this._ctx.derive();
    if (!options?.migration) {
      return null;
    }
    const { newRoot } = await runEpochMigration(ctx, {
      echoHost: this._echoHost,
      spaceId: this.id,
      spaceKey: this.key,
      migration: options.migration,
      currentRoot: this._automergeSpaceState.rootUrl ?? null,
      newAutomergeRoot: options.newAutomergeRoot
    });
    const epoch = {
      previousId: this._automergeSpaceState.lastEpoch?.id,
      number: (this._automergeSpaceState.lastEpoch?.subject.assertion.number ?? -1) + 1,
      timeframe: this._automergeSpaceState.lastEpoch?.subject.assertion.timeframe ?? new import_timeframe.Timeframe(),
      automergeRoot: newRoot ?? this._automergeSpaceState.rootUrl
    };
    const credential = await this._signingContext.credentialSigner.createCredential({
      subject: this.key,
      assertion: {
        "@type": "dxos.halo.credentials.Epoch",
        ...epoch
      }
    });
    const receipt = await this.inner.controlPipeline.writer.write({
      credential: {
        credential
      }
    });
    const timeframe = new import_timeframe.Timeframe([
      [
        receipt.feedKey,
        receipt.seq
      ]
    ]);
    await this.inner.controlPipeline.state.waitUntilTimeframe(timeframe);
    await this._echoHost.updateIndexes();
    return {
      credential,
      timeframe
    };
  }
  async activate() {
    if (![
      import_services5.SpaceState.SPACE_CLOSED,
      import_services5.SpaceState.SPACE_INACTIVE
    ].includes(this._state)) {
      return;
    }
    await this._metadataStore.setSpaceState(this.key, import_services5.SpaceState.SPACE_ACTIVE);
    await this._open();
    this.initializeDataPipelineAsync();
  }
  async deactivate() {
    if (this._state === import_services5.SpaceState.SPACE_INACTIVE) {
      return;
    }
    await this._metadataStore.setSpaceState(this.key, import_services5.SpaceState.SPACE_INACTIVE);
    if (this._state !== import_services5.SpaceState.SPACE_CLOSED) {
      await this._close();
    }
    this._state = import_services5.SpaceState.SPACE_INACTIVE;
    (0, import_log4.log)("new state", {
      state: import_services5.SpaceState[this._state]
    }, {
      F: __dxlog_file15,
      L: 592,
      S: this,
      C: (f, a) => f(...a)
    });
    this.stateUpdate.emit();
  }
  getEdgeReplicationSetting() {
    return this._metadataStore.getSpaceEdgeReplicationSetting(this.key);
  }
};
_ts_decorate6([
  import_tracing3.trace.info()
], DataSpace.prototype, "_inner", void 0);
_ts_decorate6([
  import_tracing3.trace.info()
], DataSpace.prototype, "id", null);
_ts_decorate6([
  import_tracing3.trace.info()
], DataSpace.prototype, "key", null);
_ts_decorate6([
  import_tracing3.trace.info({
    enum: import_services5.SpaceState
  })
], DataSpace.prototype, "state", null);
_ts_decorate6([
  import_tracing3.trace.info({
    depth: null
  })
], DataSpace.prototype, "_automergeInfo", null);
_ts_decorate6([
  import_async7.synchronized
], DataSpace.prototype, "open", null);
_ts_decorate6([
  import_async7.synchronized
], DataSpace.prototype, "close", null);
_ts_decorate6([
  import_tracing3.trace.span({
    showInBrowserTimeline: true
  })
], DataSpace.prototype, "initializeDataPipeline", null);
_ts_decorate6([
  import_tracing3.trace.span({
    showInBrowserTimeline: true
  })
], DataSpace.prototype, "_initializeAndReadControlPipeline", null);
_ts_decorate6([
  (0, import_debug.timed)(1e4)
], DataSpace.prototype, "_createWritableFeeds", null);
_ts_decorate6([
  import_async7.synchronized
], DataSpace.prototype, "activate", null);
_ts_decorate6([
  import_async7.synchronized
], DataSpace.prototype, "deactivate", null);
DataSpace = _ts_decorate6([
  (0, import_async7.trackLeaks)("open", "close"),
  import_tracing3.trace.resource()
], DataSpace);
var __dxlog_file16 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/device-invitation-protocol.ts";
var DeviceInvitationProtocol = class {
  constructor(_keyring, _getIdentity, _acceptIdentity) {
    this._keyring = _keyring;
    this._getIdentity = _getIdentity;
    this._acceptIdentity = _acceptIdentity;
  }
  toJSON() {
    return {
      kind: "device"
    };
  }
  checkCanInviteNewMembers() {
    return void 0;
  }
  getInvitationContext() {
    return {
      kind: import_services11.Invitation.Kind.DEVICE
    };
  }
  async delegate() {
    throw new Error("delegation not supported");
  }
  async cancelDelegation() {
    throw new Error("delegation not supported");
  }
  async admit(_, request) {
    (0, import_invariant13.invariant)(request.device, void 0, {
      F: __dxlog_file16,
      L: 53,
      S: this,
      A: [
        "request.device",
        ""
      ]
    });
    const identity = this._getIdentity();
    const credential = await identity.admitDevice(request.device);
    (0, import_invariant13.invariant)((0, import_credentials17.getCredentialAssertion)(credential)["@type"] === "dxos.halo.credentials.AuthorizedDevice", void 0, {
      F: __dxlog_file16,
      L: 56,
      S: this,
      A: [
        "getCredentialAssertion(credential)['@type'] === 'dxos.halo.credentials.AuthorizedDevice'",
        ""
      ]
    });
    return {
      device: {
        identityKey: identity.identityKey,
        haloSpaceKey: identity.haloSpaceKey,
        genesisFeedKey: identity.haloGenesisFeedKey,
        controlTimeframe: identity.controlPipeline.state.timeframe,
        credential
      }
    };
  }
  checkInvitation(invitation) {
    try {
      const identity = this._getIdentity();
      if (identity) {
        return new import_protocols10.AlreadyJoinedError("Currently only one identity per client is supported.");
      }
    } catch {
    }
  }
  createIntroduction() {
    return {};
  }
  async createAdmissionRequest(deviceProfile) {
    const deviceKey = await this._keyring.createKey();
    const controlFeedKey = await this._keyring.createKey();
    const dataFeedKey = await this._keyring.createKey();
    return {
      device: {
        deviceKey,
        controlFeedKey,
        dataFeedKey,
        profile: deviceProfile
      }
    };
  }
  async accept(response, request) {
    (0, import_invariant13.invariant)(response.device, void 0, {
      F: __dxlog_file16,
      L: 100,
      S: this,
      A: [
        "response.device",
        ""
      ]
    });
    const { identityKey, haloSpaceKey, genesisFeedKey, controlTimeframe } = response.device;
    (0, import_invariant13.invariant)(request.device, void 0, {
      F: __dxlog_file16,
      L: 103,
      S: this,
      A: [
        "request.device",
        ""
      ]
    });
    const { deviceKey, controlFeedKey, dataFeedKey, profile } = request.device;
    await this._acceptIdentity({
      identityKey,
      deviceKey,
      haloSpaceKey,
      haloGenesisFeedKey: genesisFeedKey,
      controlFeedKey,
      dataFeedKey,
      controlTimeframe,
      deviceProfile: profile,
      authorizedDeviceCredential: response.device.credential
    });
    return {
      identityKey
    };
  }
};
var stateToString = (state) => {
  return Object.entries(import_services14.Invitation.State).find(([key, val]) => val === state)?.[0] ?? "unknown";
};
var computeExpirationTime = (invitation) => {
  if (!invitation.lifetime) {
    return;
  }
  return new Date((invitation.created?.getTime() ?? Date.now()) + invitation.lifetime * 1e3);
};
var tryAcquireBeforeContextDisposed = async (ctx, mutex) => {
  let guard;
  return (0, import_context12.cancelWithContext)(ctx, (async () => {
    guard = await mutex.acquire();
    if (ctx.disposed) {
      guard.release();
      guard = void 0;
      throw new import_context12.ContextDisposedError();
    }
    return guard;
  })());
};
var __dxlog_file17 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/edge-invitation-handler.ts";
var MAX_RETRIES_PER_INVITATION = 5;
var DEFAULT_REQUEST_RETRY_INTERVAL_MS = 3e3;
var DEFAULT_REQUEST_RETRY_JITTER_MS = 500;
var EdgeInvitationHandler = class {
  constructor(config, _client, _callbacks) {
    this._client = _client;
    this._callbacks = _callbacks;
    this._retryInterval = config?.retryInterval ?? DEFAULT_REQUEST_RETRY_INTERVAL_MS;
    this._retryJitter = config?.retryJitter ?? DEFAULT_REQUEST_RETRY_JITTER_MS;
  }
  handle(ctx, guardedState, protocol, deviceProfile) {
    if (!this._client) {
      (0, import_log14.log)("edge disabled", void 0, {
        F: __dxlog_file17,
        L: 66,
        S: this,
        C: (f, a) => f(...a)
      });
      return;
    }
    const invitation = guardedState.current;
    const spaceId = invitation.spaceId;
    const canBeHandledByEdge = invitation.authMethod !== import_services13.Invitation.AuthMethod.SHARED_SECRET && invitation.type === import_services13.Invitation.Type.DELEGATED && invitation.kind === import_services13.Invitation.Kind.SPACE && spaceId != null && import_keys12.SpaceId.isValid(spaceId);
    if (!canBeHandledByEdge) {
      (0, import_log14.log)("invitation could not be handled by edge", {
        invitation
      }, {
        F: __dxlog_file17,
        L: 80,
        S: this,
        C: (f, a) => f(...a)
      });
      return;
    }
    ctx.onDispose(() => {
      this._flowLock?.release();
      this._flowLock = void 0;
    });
    let requestCount = 0;
    const tryHandleInvitation = async () => {
      requestCount++;
      const admissionRequest = await protocol.createAdmissionRequest(deviceProfile);
      if (admissionRequest.space) {
        try {
          await this._handleSpaceInvitationFlow(ctx, guardedState, admissionRequest.space, spaceId);
        } catch (error) {
          if (error instanceof import_protocols12.EdgeCallFailedError) {
            import_log14.log.info("join space with edge unsuccessful", {
              reason: error.message,
              retryable: error.isRetryable,
              after: error.retryAfterMs ?? this._calculateNextRetryMs()
            }, {
              F: __dxlog_file17,
              L: 98,
              S: this,
              C: (f, a) => f(...a)
            });
            if (error.isRetryable && requestCount < MAX_RETRIES_PER_INVITATION) {
              (0, import_async16.scheduleTask)(ctx, tryHandleInvitation, error.retryAfterMs ?? this._calculateNextRetryMs());
            }
          } else if (requestCount < MAX_RETRIES_PER_INVITATION) {
            import_log14.log.info("failed to handle invitation with edge", {
              error
            }, {
              F: __dxlog_file17,
              L: 107,
              S: this,
              C: (f, a) => f(...a)
            });
            (0, import_async16.scheduleTask)(ctx, tryHandleInvitation, this._calculateNextRetryMs());
          }
        }
      }
    };
    (0, import_async16.scheduleMicroTask)(ctx, tryHandleInvitation);
  }
  async _handleSpaceInvitationFlow(ctx, guardedState, admissionRequest, spaceId) {
    try {
      (0, import_log14.log)("edge invitation flow", void 0, {
        F: __dxlog_file17,
        L: 123,
        S: this,
        C: (f, a) => f(...a)
      });
      this._flowLock = await tryAcquireBeforeContextDisposed(ctx, guardedState.mutex);
      import_log14.log.verbose("edge invitation flow acquired the lock", void 0, {
        F: __dxlog_file17,
        L: 125,
        S: this,
        C: (f, a) => f(...a)
      });
      guardedState.set(this, import_services13.Invitation.State.CONNECTING);
      const response = await this._joinSpaceByInvitation(guardedState, spaceId, {
        identityKey: admissionRequest.identityKey.toHex(),
        invitationId: guardedState.current.invitationId
      });
      const admissionResponse = await this._mapToAdmissionResponse(response);
      await this._callbacks.onInvitationSuccess(admissionResponse, {
        space: admissionRequest
      });
    } catch (error) {
      guardedState.set(this, import_services13.Invitation.State.ERROR);
      throw error;
    } finally {
      this._flowLock?.release();
      this._flowLock = void 0;
    }
  }
  async _mapToAdmissionResponse(edgeResponse) {
    const credentialBytes = Buffer.from(edgeResponse.spaceMemberCredential, "base64");
    const codec = import_proto3.schema.getCodecForType("dxos.halo.credentials.Credential");
    return {
      space: {
        credential: codec.decode(credentialBytes)
      }
    };
  }
  async _joinSpaceByInvitation(guardedState, spaceId, request) {
    (0, import_invariant15.invariant)(this._client, void 0, {
      F: __dxlog_file17,
      L: 160,
      S: this,
      A: [
        "this._client",
        ""
      ]
    });
    try {
      return await this._client.joinSpaceByInvitation(spaceId, request);
    } catch (error) {
      if (error instanceof import_protocols12.EdgeAuthChallengeError) {
        const publicKey = guardedState.current.guestKeypair?.publicKey;
        const privateKey = guardedState.current.guestKeypair?.privateKey;
        if (!privateKey || !publicKey) {
          throw error;
        }
        const signature = (0, import_crypto2.sign)(Buffer.from(error.challenge, "base64"), privateKey);
        return this._client.joinSpaceByInvitation(spaceId, {
          ...request,
          signature: Buffer.from(signature).toString("base64")
        });
      } else {
        throw error;
      }
    }
  }
  hasFlowLock() {
    return this._flowLock != null;
  }
  _calculateNextRetryMs() {
    return this._retryInterval + Math.random() * this._retryJitter;
  }
};
var __dxlog_file18 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/invitation-guest-extenstion.ts";
var OPTIONS_TIMEOUT = 1e4;
var InvitationGuestExtension = class extends import_teleport2.RpcExtension {
  constructor(_invitationFlowMutex, _callbacks) {
    super({
      requested: {
        InvitationHostService: import_proto4.schema.getService("dxos.halo.invitations.InvitationHostService")
      },
      exposed: {
        InvitationHostService: import_proto4.schema.getService("dxos.halo.invitations.InvitationHostService")
      }
    }), this._invitationFlowMutex = _invitationFlowMutex, this._callbacks = _callbacks, this._ctx = new import_context13.Context(void 0, {
      F: __dxlog_file18,
      L: 38
    }), this._remoteOptionsTrigger = new import_async17.Trigger(), this._invitationFlowLock = null;
  }
  hasFlowLock() {
    return this._invitationFlowLock != null;
  }
  async getHandlers() {
    return {
      InvitationHostService: {
        options: async (options) => {
          (0, import_invariant16.invariant)(!this._remoteOptions, "Remote options already set.", {
            F: __dxlog_file18,
            L: 68,
            S: this,
            A: [
              "!this._remoteOptions",
              "'Remote options already set.'"
            ]
          });
          this._remoteOptions = options;
          this._remoteOptionsTrigger.wake();
        },
        introduce: () => {
          throw new Error("Method not allowed.");
        },
        authenticate: () => {
          throw new Error("Method not allowed.");
        },
        admit: () => {
          throw new Error("Method not allowed.");
        }
      }
    };
  }
  async onOpen(context) {
    await super.onOpen(context);
    try {
      import_log15.log.verbose("guest acquire lock", void 0, {
        F: __dxlog_file18,
        L: 89,
        S: this,
        C: (f, a) => f(...a)
      });
      this._invitationFlowLock = await tryAcquireBeforeContextDisposed(this._ctx, this._invitationFlowMutex);
      import_log15.log.verbose("guest lock acquired", void 0, {
        F: __dxlog_file18,
        L: 91,
        S: this,
        C: (f, a) => f(...a)
      });
      await (0, import_context13.cancelWithContext)(this._ctx, this.rpc.InvitationHostService.options({
        role: import_invitations3.InvitationOptions.Role.GUEST
      }));
      import_log15.log.verbose("options sent", void 0, {
        F: __dxlog_file18,
        L: 96,
        S: this,
        C: (f, a) => f(...a)
      });
      await (0, import_context13.cancelWithContext)(this._ctx, this._remoteOptionsTrigger.wait({
        timeout: OPTIONS_TIMEOUT
      }));
      import_log15.log.verbose("options received", void 0, {
        F: __dxlog_file18,
        L: 98,
        S: this,
        C: (f, a) => f(...a)
      });
      if (this._remoteOptions?.role !== import_invitations3.InvitationOptions.Role.HOST) {
        throw new import_protocols13.InvalidInvitationExtensionRoleError(void 0, {
          expected: import_invitations3.InvitationOptions.Role.HOST,
          remoteOptions: this._remoteOptions,
          remotePeerId: context.remotePeerId
        });
      }
      this._callbacks.onOpen(this._ctx, context);
    } catch (err) {
      if (this._invitationFlowLock != null) {
        this._callbacks.onError(err);
      }
      if (!this._ctx.disposed) {
        context.close(err);
      }
    }
  }
  async onClose() {
    await this._destroy();
  }
  async onAbort() {
    await this._destroy();
  }
  async _destroy() {
    await this._ctx.dispose();
    if (this._invitationFlowLock != null) {
      this._invitationFlowLock.release();
      this._invitationFlowLock = null;
      import_log15.log.verbose("invitation flow lock released", void 0, {
        F: __dxlog_file18,
        L: 131,
        S: this,
        C: (f, a) => f(...a)
      });
    }
  }
};
var __dxlog_file19 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/invitation-host-extension.ts";
var OPTIONS_TIMEOUT2 = 1e4;
var MAX_OTP_ATTEMPTS = 3;
var InvitationHostExtension = class extends import_teleport3.RpcExtension {
  constructor(_invitationFlowMutex, _callbacks) {
    super({
      requested: {
        InvitationHostService: import_proto5.schema.getService("dxos.halo.invitations.InvitationHostService")
      },
      exposed: {
        InvitationHostService: import_proto5.schema.getService("dxos.halo.invitations.InvitationHostService")
      }
    }), this._invitationFlowMutex = _invitationFlowMutex, this._callbacks = _callbacks, this._ctx = new import_context14.Context(void 0, {
      F: __dxlog_file19,
      L: 57
    }), this._remoteOptionsTrigger = new import_async18.Trigger(), this._challenge = void 0, this.guestProfile = void 0, this.authenticationPassed = false, this.authenticationRetry = 0, this.completedTrigger = new import_async18.Trigger(), this._invitationFlowLock = null;
  }
  hasFlowLock() {
    return this._invitationFlowLock != null;
  }
  async getHandlers() {
    return {
      // TODO(dmaretskyi): For now this is just forwarding the data to callbacks since we don't have session-specific logic.
      // Perhaps in the future we will have more complex logic here.
      InvitationHostService: {
        options: async (options) => {
          (0, import_invariant17.invariant)(!this._remoteOptions, "Remote options already set.", {
            F: __dxlog_file19,
            L: 106,
            S: this,
            A: [
              "!this._remoteOptions",
              "'Remote options already set.'"
            ]
          });
          this._remoteOptions = options;
          this._remoteOptionsTrigger.wake();
        },
        introduce: async (request) => {
          const { profile, invitationId } = request;
          const traceId = import_keys13.PublicKey.random().toHex();
          import_log16.log.trace("dxos.sdk.invitation-handler.host.introduce", import_protocols14.trace.begin({
            id: traceId
          }), {
            F: __dxlog_file19,
            L: 114,
            S: this,
            C: (f, a) => f(...a)
          });
          const invitation = this._requireActiveInvitation();
          this._assertInvitationState(import_services15.Invitation.State.CONNECTED);
          if (invitationId !== invitation?.invitationId) {
            import_log16.log.warn("incorrect invitationId", {
              expected: invitation.invitationId,
              actual: invitationId
            }, {
              F: __dxlog_file19,
              L: 119,
              S: this,
              C: (f, a) => f(...a)
            });
            this._callbacks.onError(new Error("Incorrect invitationId."));
            (0, import_async18.scheduleTask)(this._ctx, () => this.close());
            return {
              authMethod: import_services15.Invitation.AuthMethod.NONE
            };
          }
          import_log16.log.verbose("guest introduced themselves", {
            guestProfile: profile
          }, {
            F: __dxlog_file19,
            L: 128,
            S: this,
            C: (f, a) => f(...a)
          });
          this.guestProfile = profile;
          this._callbacks.onStateUpdate(import_services15.Invitation.State.READY_FOR_AUTHENTICATION);
          this._challenge = invitation.authMethod === import_services15.Invitation.AuthMethod.KNOWN_PUBLIC_KEY ? (0, import_crypto3.randomBytes)(32) : void 0;
          import_log16.log.trace("dxos.sdk.invitation-handler.host.introduce", import_protocols14.trace.end({
            id: traceId
          }), {
            F: __dxlog_file19,
            L: 134,
            S: this,
            C: (f, a) => f(...a)
          });
          return {
            authMethod: invitation.authMethod,
            challenge: this._challenge
          };
        },
        authenticate: async ({ authCode: code, signedChallenge }) => {
          const traceId = import_keys13.PublicKey.random().toHex();
          import_log16.log.trace("dxos.sdk.invitation-handler.host.authenticate", import_protocols14.trace.begin({
            id: traceId
          }), {
            F: __dxlog_file19,
            L: 143,
            S: this,
            C: (f, a) => f(...a)
          });
          const invitation = this._requireActiveInvitation();
          import_log16.log.verbose("received authentication request", {
            authCode: code
          }, {
            F: __dxlog_file19,
            L: 146,
            S: this,
            C: (f, a) => f(...a)
          });
          let status = import_invitations4.AuthenticationResponse.Status.OK;
          this._assertInvitationState([
            import_services15.Invitation.State.AUTHENTICATING,
            import_services15.Invitation.State.READY_FOR_AUTHENTICATION
          ]);
          this._callbacks.onStateUpdate(import_services15.Invitation.State.AUTHENTICATING);
          switch (invitation.authMethod) {
            case import_services15.Invitation.AuthMethod.NONE: {
              (0, import_log16.log)("authentication not required", void 0, {
                F: __dxlog_file19,
                L: 154,
                S: this,
                C: (f, a) => f(...a)
              });
              return {
                status: import_invitations4.AuthenticationResponse.Status.OK
              };
            }
            case import_services15.Invitation.AuthMethod.SHARED_SECRET: {
              if (invitation.authCode) {
                if (this.authenticationRetry++ > MAX_OTP_ATTEMPTS) {
                  status = import_invitations4.AuthenticationResponse.Status.INVALID_OPT_ATTEMPTS;
                } else if (code !== invitation.authCode) {
                  status = import_invitations4.AuthenticationResponse.Status.INVALID_OTP;
                } else {
                  this.authenticationPassed = true;
                }
              }
              break;
            }
            case import_services15.Invitation.AuthMethod.KNOWN_PUBLIC_KEY: {
              if (!invitation.guestKeypair) {
                status = import_invitations4.AuthenticationResponse.Status.INTERNAL_ERROR;
                break;
              }
              const isSignatureValid = this._challenge && (0, import_crypto3.verify)(this._challenge, Buffer.from(signedChallenge ?? []), invitation.guestKeypair.publicKey.asBuffer());
              if (isSignatureValid) {
                this.authenticationPassed = true;
              } else {
                status = import_invitations4.AuthenticationResponse.Status.INVALID_SIGNATURE;
              }
              break;
            }
            default: {
              import_log16.log.error("invalid authentication method", {
                authMethod: invitation.authMethod
              }, {
                F: __dxlog_file19,
                L: 192,
                S: this,
                C: (f, a) => f(...a)
              });
              status = import_invitations4.AuthenticationResponse.Status.INTERNAL_ERROR;
              break;
            }
          }
          if (![
            import_invitations4.AuthenticationResponse.Status.OK,
            import_invitations4.AuthenticationResponse.Status.INVALID_OTP
          ].includes(status)) {
            this._callbacks.onError(new Error(`Authentication failed, with status=${status}`));
            (0, import_async18.scheduleTask)(this._ctx, () => this.close());
            return {
              status
            };
          }
          import_log16.log.trace("dxos.sdk.invitation-handler.host.authenticate", import_protocols14.trace.end({
            id: traceId,
            data: {
              status
            }
          }), {
            F: __dxlog_file19,
            L: 204,
            S: this,
            C: (f, a) => f(...a)
          });
          return {
            status
          };
        },
        admit: async (request) => {
          const traceId = import_keys13.PublicKey.random().toHex();
          import_log16.log.trace("dxos.sdk.invitation-handler.host.admit", import_protocols14.trace.begin({
            id: traceId
          }), {
            F: __dxlog_file19,
            L: 210,
            S: this,
            C: (f, a) => f(...a)
          });
          const invitation = this._requireActiveInvitation();
          try {
            if (isAuthenticationRequired(invitation)) {
              this._assertInvitationState(import_services15.Invitation.State.AUTHENTICATING);
              if (!this.authenticationPassed) {
                throw new Error("Not authenticated");
              }
            }
            const response = await this._callbacks.admit(request);
            import_log16.log.trace("dxos.sdk.invitation-handler.host.admit", import_protocols14.trace.end({
              id: traceId
            }), {
              F: __dxlog_file19,
              L: 224,
              S: this,
              C: (f, a) => f(...a)
            });
            return response;
          } catch (err) {
            this._callbacks.onError(err);
            throw err;
          }
        }
      }
    };
  }
  async onOpen(context) {
    await super.onOpen(context);
    try {
      import_log16.log.verbose("host acquire lock", void 0, {
        F: __dxlog_file19,
        L: 239,
        S: this,
        C: (f, a) => f(...a)
      });
      this._invitationFlowLock = await tryAcquireBeforeContextDisposed(this._ctx, this._invitationFlowMutex);
      import_log16.log.verbose("host lock acquired", void 0, {
        F: __dxlog_file19,
        L: 241,
        S: this,
        C: (f, a) => f(...a)
      });
      this._callbacks.onStateUpdate(import_services15.Invitation.State.CONNECTING);
      await this.rpc.InvitationHostService.options({
        role: import_invitations4.InvitationOptions.Role.HOST
      });
      import_log16.log.verbose("options sent", void 0, {
        F: __dxlog_file19,
        L: 244,
        S: this,
        C: (f, a) => f(...a)
      });
      await (0, import_context14.cancelWithContext)(this._ctx, this._remoteOptionsTrigger.wait({
        timeout: OPTIONS_TIMEOUT2
      }));
      import_log16.log.verbose("options received", void 0, {
        F: __dxlog_file19,
        L: 246,
        S: this,
        C: (f, a) => f(...a)
      });
      if (this._remoteOptions?.role !== import_invitations4.InvitationOptions.Role.GUEST) {
        throw new import_protocols14.InvalidInvitationExtensionRoleError(void 0, {
          expected: import_invitations4.InvitationOptions.Role.GUEST,
          remoteOptions: this._remoteOptions,
          remotePeerId: context.remotePeerId
        });
      }
      this._callbacks.onStateUpdate(import_services15.Invitation.State.CONNECTED);
      this._callbacks.onOpen(this._ctx, context);
    } catch (err) {
      if (this._invitationFlowLock != null) {
        this._callbacks.onError(err);
      }
      if (!this._ctx.disposed) {
        context.close(err);
      }
    }
  }
  _requireActiveInvitation() {
    const invitation = this._callbacks.activeInvitation;
    if (invitation == null) {
      (0, import_async18.scheduleTask)(this._ctx, () => this.close());
      throw new Error("Active invitation not found");
    }
    return invitation;
  }
  _assertInvitationState(stateOrMany) {
    const invitation = this._requireActiveInvitation();
    const validStates = Array.isArray(stateOrMany) ? stateOrMany : [
      stateOrMany
    ];
    if (!validStates.includes(invitation.state)) {
      (0, import_async18.scheduleTask)(this._ctx, () => this.close());
      throw new import_invariant17.InvariantViolation(`Expected ${stateToString(invitation.state)} to be one of [${validStates.map(stateToString).join(", ")}]`);
    }
  }
  async onClose() {
    await this._destroy();
  }
  async onAbort() {
    await this._destroy();
  }
  async _destroy() {
    await this._ctx.dispose();
    if (this._invitationFlowLock != null) {
      this._invitationFlowLock?.release();
      this._invitationFlowLock = null;
      import_log16.log.verbose("invitation flow lock released", void 0, {
        F: __dxlog_file19,
        L: 299,
        S: this,
        C: (f, a) => f(...a)
      });
    }
  }
};
var isAuthenticationRequired = (invitation) => invitation.authMethod !== import_services15.Invitation.AuthMethod.NONE;
var __dxlog_file20 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/invitation-state.ts";
var createGuardedInvitationState = (ctx, invitation, stream) => {
  const mutex = new import_async19.Mutex();
  let lastActiveLockHolder = null;
  let currentInvitation = {
    ...invitation
  };
  const isStateChangeAllowed = (lockHolder) => {
    if (ctx.disposed || lockHolder !== null && mutex.isLocked() && !lockHolder.hasFlowLock()) {
      return false;
    }
    return lockHolder == null || lastActiveLockHolder !== lockHolder || isNonTerminalState(currentInvitation.state);
  };
  return {
    mutex,
    get current() {
      return currentInvitation;
    },
    // disposing context prevents any further state updates
    complete: (newState) => {
      logStateUpdate(currentInvitation, void 0, invitation.state);
      currentInvitation = {
        ...currentInvitation,
        ...newState
      };
      stream.next(currentInvitation);
      return ctx.dispose();
    },
    set: (lockHolder, newState) => {
      if (isStateChangeAllowed(lockHolder)) {
        logStateUpdate(currentInvitation, lockHolder, newState);
        currentInvitation = {
          ...currentInvitation,
          state: newState
        };
        stream.next(currentInvitation);
        lastActiveLockHolder = lockHolder;
        return true;
      }
      return false;
    },
    error: (lockHolder, error) => {
      if (isStateChangeAllowed(lockHolder)) {
        logStateUpdate(currentInvitation, lockHolder, import_services16.Invitation.State.ERROR, error);
        currentInvitation = {
          ...currentInvitation,
          state: import_services16.Invitation.State.ERROR
        };
        stream.next(currentInvitation);
        stream.error(error);
        lastActiveLockHolder = lockHolder;
        return true;
      }
      return false;
    }
  };
};
var logStateUpdate = (invitation, actor, newState, error) => {
  const logContext = {
    invitationId: invitation.invitationId,
    actor: actor?.constructor.name,
    newState: stateToString(newState),
    oldState: stateToString(invitation.state),
    error: error?.message,
    errorStack: error?.stack
  };
  if (isNonTerminalState(newState)) {
    import_log17.log.verbose("dxos.sdk.invitations-handler.state.update", logContext, {
      F: __dxlog_file20,
      L: 98,
      S: void 0,
      C: (f, a) => f(...a)
    });
  } else {
    import_log17.log.info("dxos.sdk.invitations-handler.state.update", logContext, {
      F: __dxlog_file20,
      L: 100,
      S: void 0,
      C: (f, a) => f(...a)
    });
  }
};
var isNonTerminalState = (currentState) => {
  return ![
    import_services16.Invitation.State.SUCCESS,
    import_services16.Invitation.State.ERROR,
    import_services16.Invitation.State.CANCELLED,
    import_services16.Invitation.State.TIMEOUT,
    import_services16.Invitation.State.EXPIRED
  ].includes(currentState);
};
var __dxlog_file21 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/invitation-topology.ts";
var InvitationTopology = class {
  constructor(_role) {
    this._role = _role;
    this._seenPeers = new import_util11.ComplexSet(import_keys14.PublicKey.hash);
  }
  init(controller) {
    (0, import_invariant18.invariant)(!this._controller, "Already initialized.", {
      F: __dxlog_file21,
      L: 42,
      S: this,
      A: [
        "!this._controller",
        "'Already initialized.'"
      ]
    });
    this._controller = controller;
  }
  update() {
    (0, import_invariant18.invariant)(this._controller, "Not initialized.", {
      F: __dxlog_file21,
      L: 47,
      S: this,
      A: [
        "this._controller",
        "'Not initialized.'"
      ]
    });
    const { ownPeerId, candidates, connected, allPeers } = this._controller.getState();
    if (this._role === import_invitations5.InvitationOptions.Role.GUEST) {
      return;
    }
    if (connected.length > 0) {
      connected.forEach((c) => this._seenPeers.add(c));
      return;
    }
    const firstUnknownPeer = candidates.find((peerId) => !this._seenPeers.has(peerId));
    this._seenPeers = new import_util11.ComplexSet(import_keys14.PublicKey.hash, allPeers.filter((peerId) => this._seenPeers.has(peerId)));
    if (firstUnknownPeer != null) {
      (0, import_log18.log)("invitation connect", {
        ownPeerId,
        remotePeerId: firstUnknownPeer
      }, {
        F: __dxlog_file21,
        L: 69,
        S: this,
        C: (f, a) => f(...a)
      });
      this._controller.connect(firstUnknownPeer);
      this._seenPeers.add(firstUnknownPeer);
    }
  }
  async onOffer(peer) {
    (0, import_invariant18.invariant)(this._controller, "Not initialized.", {
      F: __dxlog_file21,
      L: 76,
      S: this,
      A: [
        "this._controller",
        "'Not initialized.'"
      ]
    });
    return !this._seenPeers.has(peer);
  }
  async destroy() {
    this._seenPeers.clear();
  }
  toString() {
    return `InvitationTopology(${this._role === import_invitations5.InvitationOptions.Role.GUEST ? "guest" : "host"})`;
  }
};
var __dxlog_file22 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/invitations-handler.ts";
var metrics = import_tracing8.trace.metrics;
var MAX_DELEGATED_INVITATION_HOST_TRIES = 3;
var InvitationsHandler = class {
  /**
  * @internal
  */
  constructor(_networkManager, _edgeClient, _connectionParams) {
    this._networkManager = _networkManager;
    this._edgeClient = _edgeClient;
    this._connectionParams = _connectionParams;
  }
  handleInvitationFlow(ctx, stream, protocol, invitation) {
    import_log13.log.verbose("dxos.sdk.invitations-handler.handleInvitationFlow", {
      state: invitation.state,
      invitationId: invitation.invitationId,
      kind: invitation.kind,
      type: invitation.type
    }, {
      F: __dxlog_file22,
      L: 83,
      S: this,
      C: (f, a) => f(...a)
    });
    metrics.increment("dxos.invitation.host");
    const guardedState = createGuardedInvitationState(ctx, invitation, stream);
    const createExtension = () => {
      const extension = new InvitationHostExtension(guardedState.mutex, {
        get activeInvitation() {
          return ctx.disposed ? null : guardedState.current;
        },
        onStateUpdate: (newState) => {
          if (newState !== import_services12.Invitation.State.ERROR && newState !== import_services12.Invitation.State.TIMEOUT) {
            guardedState.set(extension, newState);
          }
          return guardedState.current;
        },
        admit: async (admissionRequest) => {
          try {
            import_log13.log.verbose("dxos.sdk.invitations-handler.host.admit", {
              invitationId: invitation.invitationId,
              ...protocol.toJSON()
            }, {
              F: __dxlog_file22,
              L: 107,
              S: this,
              C: (f, a) => f(...a)
            });
            const deviceKey = admissionRequest.device?.deviceKey ?? admissionRequest.space?.deviceKey;
            (0, import_invariant14.invariant)(deviceKey, void 0, {
              F: __dxlog_file22,
              L: 112,
              S: this,
              A: [
                "deviceKey",
                ""
              ]
            });
            const admissionResponse = await protocol.admit(invitation, admissionRequest, extension.guestProfile);
            extension.completedTrigger.wake(deviceKey);
            return admissionResponse;
          } catch (err) {
            guardedState.error(extension, err);
            throw err;
          }
        },
        onOpen: (connectionCtx, extensionsCtx) => {
          let admitted = false;
          connectionCtx.onDispose(() => {
            if (!admitted) {
              guardedState.set(extension, import_services12.Invitation.State.CONNECTING);
            }
          });
          (0, import_async15.scheduleTask)(connectionCtx, async () => {
            const traceId = import_keys11.PublicKey.random().toHex();
            try {
              import_log13.log.trace("dxos.sdk.invitations-handler.host.onOpen", import_protocols11.trace.begin({
                id: traceId
              }), {
                F: __dxlog_file22,
                L: 137,
                S: this,
                C: (f, a) => f(...a)
              });
              import_log13.log.verbose("connected", {
                ...protocol.toJSON()
              }, {
                F: __dxlog_file22,
                L: 138,
                S: this,
                C: (f, a) => f(...a)
              });
              const deviceKey = await extension.completedTrigger.wait({
                timeout: invitation.timeout
              });
              import_log13.log.verbose("admitted guest", {
                guest: deviceKey,
                ...protocol.toJSON()
              }, {
                F: __dxlog_file22,
                L: 140,
                S: this,
                C: (f, a) => f(...a)
              });
              guardedState.set(extension, import_services12.Invitation.State.SUCCESS);
              metrics.increment("dxos.invitation.success");
              import_log13.log.trace("dxos.sdk.invitations-handler.host.onOpen", import_protocols11.trace.end({
                id: traceId
              }), {
                F: __dxlog_file22,
                L: 143,
                S: this,
                C: (f, a) => f(...a)
              });
              admitted = true;
              if (!invitation.multiUse) {
                await ctx.dispose();
              }
            } catch (err) {
              const stateChanged = guardedState.set(extension, import_services12.Invitation.State.CONNECTING);
              if (err instanceof import_async15.TimeoutError) {
                if (stateChanged) {
                  metrics.increment("dxos.invitation.timeout");
                  import_log13.log.verbose("timeout", {
                    ...protocol.toJSON()
                  }, {
                    F: __dxlog_file22,
                    L: 154,
                    S: this,
                    C: (f, a) => f(...a)
                  });
                }
              } else {
                if (stateChanged) {
                  metrics.increment("dxos.invitation.failed");
                  import_log13.log.error("failed", err, {
                    F: __dxlog_file22,
                    L: 159,
                    S: this,
                    C: (f, a) => f(...a)
                  });
                }
              }
              import_log13.log.trace("dxos.sdk.invitations-handler.host.onOpen", import_protocols11.trace.error({
                id: traceId,
                error: err
              }), {
                F: __dxlog_file22,
                L: 162,
                S: this,
                C: (f, a) => f(...a)
              });
              extensionsCtx.close(err);
            }
          });
        },
        onError: (err) => {
          const stateChanged = guardedState.set(extension, import_services12.Invitation.State.CONNECTING);
          if (err instanceof import_protocols11.InvalidInvitationExtensionRoleError) {
            (0, import_log13.log)("invalid role", {
              ...err.context
            }, {
              F: __dxlog_file22,
              L: 171,
              S: this,
              C: (f, a) => f(...a)
            });
            return;
          }
          if (err instanceof import_async15.TimeoutError) {
            if (stateChanged) {
              metrics.increment("dxos.invitation.timeout");
              import_log13.log.verbose("timeout", {
                err
              }, {
                F: __dxlog_file22,
                L: 177,
                S: this,
                C: (f, a) => f(...a)
              });
            }
          } else {
            if (stateChanged) {
              metrics.increment("dxos.invitation.failed");
              import_log13.log.error("failed", err, {
                F: __dxlog_file22,
                L: 182,
                S: this,
                C: (f, a) => f(...a)
              });
            }
          }
        }
      });
      return extension;
    };
    const expiresOn = (0, import_client_protocol5.getExpirationTime)(invitation);
    if (expiresOn) {
      if (expiresOn.getTime() < Date.now()) {
        import_log13.log.warn("invitation has already expired", void 0, {
          F: __dxlog_file22,
          L: 194,
          S: this,
          C: (f, a) => f(...a)
        });
        guardedState.set(null, import_services12.Invitation.State.EXPIRED);
        void ctx.dispose().catch((err) => import_log13.log.catch(err, void 0, {
          F: __dxlog_file22,
          L: 196,
          S: this,
          C: (f, a) => f(...a)
        }));
        return;
      }
      (0, import_async15.scheduleTask)(ctx, async () => {
        await swarmConnection.close();
        guardedState.set(null, import_services12.Invitation.State.EXPIRED);
        metrics.increment("dxos.invitation.expired");
        await ctx.dispose();
      }, expiresOn.getTime() - Date.now());
    }
    let swarmConnection;
    (0, import_async15.scheduleTask)(ctx, async () => {
      swarmConnection = await this._joinSwarm(ctx, invitation, import_invitations2.InvitationOptions.Role.HOST, createExtension);
      guardedState.set(null, import_services12.Invitation.State.CONNECTING);
    });
  }
  acceptInvitation(ctx, stream, protocol, invitation, otpEnteredTrigger, deviceProfile) {
    import_log13.log.verbose("dxos.sdk.invitations-handler.acceptInvitation", {
      state: invitation.state,
      invitationId: invitation.invitationId,
      kind: invitation.kind,
      type: invitation.type
    }, {
      F: __dxlog_file22,
      L: 227,
      S: this,
      C: (f, a) => f(...a)
    });
    const { timeout = import_client_protocol5.INVITATION_TIMEOUT } = invitation;
    if (deviceProfile) {
      (0, import_invariant14.invariant)(invitation.kind === import_services12.Invitation.Kind.DEVICE, "deviceProfile provided for non-device invitation", {
        F: __dxlog_file22,
        L: 236,
        S: this,
        A: [
          "invitation.kind === Invitation.Kind.DEVICE",
          "'deviceProfile provided for non-device invitation'"
        ]
      });
    }
    const triedPeersIds = new import_util10.ComplexSet(import_keys11.PublicKey.hash);
    const guardedState = createGuardedInvitationState(ctx, invitation, stream);
    const shouldCancelInvitationFlow = (extension) => {
      const isLockedByAnotherConnection = guardedState.mutex.isLocked() && !extension.hasFlowLock();
      (0, import_log13.log)("should cancel invitation flow", {
        isLockedByAnotherConnection,
        invitationType: import_services12.Invitation.Type.DELEGATED,
        triedPeers: triedPeersIds.size
      }, {
        F: __dxlog_file22,
        L: 244,
        S: this,
        C: (f, a) => f(...a)
      });
      if (isLockedByAnotherConnection) {
        return false;
      }
      return invitation.type !== import_services12.Invitation.Type.DELEGATED || triedPeersIds.size >= MAX_DELEGATED_INVITATION_HOST_TRIES;
    };
    let admitted = false;
    const createExtension = () => {
      const extension = new InvitationGuestExtension(guardedState.mutex, {
        onStateUpdate: (newState) => {
          guardedState.set(extension, newState);
        },
        onOpen: (connectionCtx, extensionCtx) => {
          triedPeersIds.add(extensionCtx.remotePeerId);
          if (admitted) {
            extensionCtx.close();
            return;
          }
          connectionCtx.onDispose(async () => {
            import_log13.log.verbose("extension disposed", {
              admitted,
              currentState: guardedState.current.state
            }, {
              F: __dxlog_file22,
              L: 272,
              S: this,
              C: (f, a) => f(...a)
            });
            if (!admitted) {
              guardedState.error(extension, new import_context11.ContextDisposedError());
              if (shouldCancelInvitationFlow(extension)) {
                await ctx.dispose();
              }
            }
          });
          (0, import_async15.scheduleTask)(connectionCtx, async () => {
            const traceId = import_keys11.PublicKey.random().toHex();
            try {
              import_log13.log.trace("dxos.sdk.invitations-handler.guest.onOpen", import_protocols11.trace.begin({
                id: traceId
              }), {
                F: __dxlog_file22,
                L: 284,
                S: this,
                C: (f, a) => f(...a)
              });
              (0, import_async15.scheduleTask)(connectionCtx, () => {
                guardedState.set(extension, import_services12.Invitation.State.TIMEOUT);
                extensionCtx.close();
              }, timeout);
              import_log13.log.verbose("dxos.sdk.invitations-handler.guest.connected", {
                ...protocol.toJSON()
              }, {
                F: __dxlog_file22,
                L: 295,
                S: this,
                C: (f, a) => f(...a)
              });
              guardedState.set(extension, import_services12.Invitation.State.CONNECTED);
              import_log13.log.verbose("dxos.sdk.invitations-handler.guest.introduce", {
                invitationId: invitation.invitationId,
                ...protocol.toJSON()
              }, {
                F: __dxlog_file22,
                L: 299,
                S: this,
                C: (f, a) => f(...a)
              });
              const introductionResponse = await extension.rpc.InvitationHostService.introduce({
                invitationId: invitation.invitationId,
                ...protocol.createIntroduction()
              });
              import_log13.log.verbose("dxos.sdk.invitations-handler.guest.introduce-response", {
                invitationId: invitation.invitationId,
                ...protocol.toJSON(),
                authMethod: introductionResponse.authMethod
              }, {
                F: __dxlog_file22,
                L: 307,
                S: this,
                C: (f, a) => f(...a)
              });
              invitation.authMethod = introductionResponse.authMethod;
              if (isAuthenticationRequired(invitation)) {
                switch (invitation.authMethod) {
                  case import_services12.Invitation.AuthMethod.SHARED_SECRET:
                    await this._handleGuestOtpAuth(extension, (state) => guardedState.set(extension, state), otpEnteredTrigger, {
                      timeout
                    });
                    break;
                  case import_services12.Invitation.AuthMethod.KNOWN_PUBLIC_KEY:
                    await this._handleGuestKpkAuth(extension, (state) => guardedState.set(extension, state), invitation, introductionResponse);
                    break;
                }
              }
              import_log13.log.verbose("dxos.sdk.invitations-handler.guest.request-admission", {
                invitationId: invitation.invitationId,
                ...protocol.toJSON()
              }, {
                F: __dxlog_file22,
                L: 337,
                S: this,
                C: (f, a) => f(...a)
              });
              const admissionRequest = await protocol.createAdmissionRequest(deviceProfile);
              const admissionResponse = await extension.rpc.InvitationHostService.admit(admissionRequest);
              admitted = true;
              const result = await protocol.accept(admissionResponse, admissionRequest);
              import_log13.log.verbose("dxos.sdk.invitations-handler.guest.admitted-by-host", {
                invitationId: invitation.invitationId,
                ...protocol.toJSON()
              }, {
                F: __dxlog_file22,
                L: 351,
                S: this,
                C: (f, a) => f(...a)
              });
              guardedState.complete({
                ...guardedState.current,
                ...result,
                state: import_services12.Invitation.State.SUCCESS
              });
              import_log13.log.trace("dxos.sdk.invitations-handler.guest.onOpen", import_protocols11.trace.end({
                id: traceId
              }), {
                F: __dxlog_file22,
                L: 360,
                S: this,
                C: (f, a) => f(...a)
              });
            } catch (err) {
              if (err instanceof import_async15.TimeoutError) {
                import_log13.log.verbose("timeout", {
                  ...protocol.toJSON()
                }, {
                  F: __dxlog_file22,
                  L: 363,
                  S: this,
                  C: (f, a) => f(...a)
                });
                guardedState.set(extension, import_services12.Invitation.State.TIMEOUT);
              } else {
                import_log13.log.verbose("auth failed", err, {
                  F: __dxlog_file22,
                  L: 366,
                  S: this,
                  C: (f, a) => f(...a)
                });
                guardedState.error(extension, err);
              }
              extensionCtx.close(err);
              import_log13.log.trace("dxos.sdk.invitations-handler.guest.onOpen", import_protocols11.trace.error({
                id: traceId,
                error: err
              }), {
                F: __dxlog_file22,
                L: 370,
                S: this,
                C: (f, a) => f(...a)
              });
            }
          });
        },
        onError: (err) => {
          if (err instanceof import_protocols11.InvalidInvitationExtensionRoleError) {
            return;
          }
          if (err instanceof import_async15.TimeoutError) {
            import_log13.log.verbose("timeout", {
              ...protocol.toJSON()
            }, {
              F: __dxlog_file22,
              L: 379,
              S: this,
              C: (f, a) => f(...a)
            });
            guardedState.set(extension, import_services12.Invitation.State.TIMEOUT);
          } else {
            import_log13.log.verbose("auth failed", err, {
              F: __dxlog_file22,
              L: 382,
              S: this,
              C: (f, a) => f(...a)
            });
            guardedState.error(extension, err);
          }
        }
      });
      return extension;
    };
    const edgeInvitationHandler = new EdgeInvitationHandler(this._connectionParams?.edgeInvitations, this._edgeClient, {
      onInvitationSuccess: async (admissionResponse, admissionRequest) => {
        const result = await protocol.accept(admissionResponse, admissionRequest);
        import_log13.log.info("admitted by edge", {
          ...protocol.toJSON()
        }, {
          F: __dxlog_file22,
          L: 394,
          S: this,
          C: (f, a) => f(...a)
        });
        guardedState.complete({
          ...guardedState.current,
          ...result,
          state: import_services12.Invitation.State.SUCCESS
        });
      }
    });
    edgeInvitationHandler.handle(ctx, guardedState, protocol, deviceProfile);
    (0, import_async15.scheduleTask)(ctx, async () => {
      const error = checkInvitation(protocol, invitation);
      if (error) {
        stream.error(error);
        await ctx.dispose();
      } else {
        (0, import_invariant14.invariant)(invitation.swarmKey, void 0, {
          F: __dxlog_file22,
          L: 406,
          S: this,
          A: [
            "invitation.swarmKey",
            ""
          ]
        });
        const timeoutInactive = () => {
          if (guardedState.mutex.isLocked()) {
            (0, import_async15.scheduleTask)(ctx, timeoutInactive, timeout);
          } else {
            guardedState.set(null, import_services12.Invitation.State.TIMEOUT);
          }
        };
        (0, import_async15.scheduleTask)(ctx, timeoutInactive, timeout);
        await this._joinSwarm(ctx, invitation, import_invitations2.InvitationOptions.Role.GUEST, createExtension);
        guardedState.set(null, import_services12.Invitation.State.CONNECTING);
      }
    });
  }
  async _joinSwarm(ctx, invitation, role, extensionFactory) {
    let label;
    if (role === import_invitations2.InvitationOptions.Role.GUEST) {
      label = "invitation guest";
    } else if (invitation.kind === import_services12.Invitation.Kind.DEVICE) {
      label = "invitation host for device";
    } else {
      label = `invitation host for space ${invitation.spaceKey?.truncate()}`;
    }
    const swarmConnection = await this._networkManager.joinSwarm({
      topic: invitation.swarmKey,
      protocolProvider: (0, import_network_manager.createTeleportProtocolFactory)(async (teleport) => {
        teleport.addExtension("dxos.halo.invitations", extensionFactory());
      }, this._connectionParams?.teleport),
      topology: new InvitationTopology(role),
      label
    });
    ctx.onDispose(() => swarmConnection.close());
    return swarmConnection;
  }
  async _handleGuestOtpAuth(extension, setState, authenticated, options) {
    for (let attempt = 1; attempt <= MAX_OTP_ATTEMPTS; attempt++) {
      (0, import_log13.log)("guest waiting for authentication code...", void 0, {
        F: __dxlog_file22,
        L: 458,
        S: this,
        C: (f, a) => f(...a)
      });
      setState(import_services12.Invitation.State.READY_FOR_AUTHENTICATION);
      const authCode = await authenticated.wait(options);
      (0, import_log13.log)("sending authentication request", void 0, {
        F: __dxlog_file22,
        L: 462,
        S: this,
        C: (f, a) => f(...a)
      });
      setState(import_services12.Invitation.State.AUTHENTICATING);
      const response = await extension.rpc.InvitationHostService.authenticate({
        authCode
      });
      if (response.status === void 0 || response.status === import_invitations.AuthenticationResponse.Status.OK) {
        break;
      }
      if (response.status === import_invitations.AuthenticationResponse.Status.INVALID_OTP) {
        if (attempt === MAX_OTP_ATTEMPTS) {
          throw new Error(`Maximum retry attempts: ${MAX_OTP_ATTEMPTS}`);
        } else {
          (0, import_log13.log)("retrying invalid code", {
            attempt
          }, {
            F: __dxlog_file22,
            L: 473,
            S: this,
            C: (f, a) => f(...a)
          });
          authenticated.reset();
        }
      }
    }
  }
  async _handleGuestKpkAuth(extension, setState, invitation, introductionResponse) {
    if (invitation.guestKeypair?.privateKey == null) {
      throw new Error("keypair missing in the invitation");
    }
    if (introductionResponse.challenge == null) {
      throw new Error("challenge missing in the introduction");
    }
    (0, import_log13.log)("sending authentication request", void 0, {
      F: __dxlog_file22,
      L: 492,
      S: this,
      C: (f, a) => f(...a)
    });
    const signature = (0, import_crypto.sign)(Buffer.from(introductionResponse.challenge), invitation.guestKeypair.privateKey);
    const response = await extension.rpc.InvitationHostService.authenticate({
      signedChallenge: signature
    });
    if (response.status !== import_invitations.AuthenticationResponse.Status.OK) {
      throw new Error(`Authentication failed with code: ${response.status}`);
    }
  }
};
var checkInvitation = (protocol, invitation) => {
  const expiresOn = (0, import_client_protocol5.getExpirationTime)(invitation);
  if (expiresOn && expiresOn.getTime() < Date.now()) {
    return new import_protocols11.InvalidInvitationError("Invitation already expired.");
  }
  return protocol.checkInvitation(invitation);
};
var createAdmissionKeypair = () => {
  const keypair = (0, import_crypto.createKeyPair)();
  return {
    publicKey: import_keys11.PublicKey.from(keypair.publicKey),
    privateKey: keypair.secretKey
  };
};
var InvitationsServiceImpl = class {
  constructor(_invitationsManager) {
    this._invitationsManager = _invitationsManager;
  }
  // TODO(burdon): Guest/host label.
  getLoggingContext() {
    return {};
  }
  createInvitation(options) {
    return new import_stream9.Stream(({ next, close }) => {
      void this._invitationsManager.createInvitation(options).then((invitation) => {
        import_tracing9.trace.metrics.increment("dxos.invitation.created");
        invitation.subscribe(next, close, close);
      }).catch(close);
    });
  }
  acceptInvitation(request) {
    const invitation = this._invitationsManager.acceptInvitation(request);
    return new import_stream9.Stream(({ next, close }) => {
      invitation.subscribe(next, close, close);
    });
  }
  async authenticate(request) {
    return this._invitationsManager.authenticate(request);
  }
  async cancelInvitation(request) {
    return this._invitationsManager.cancelInvitation(request);
  }
  queryInvitations() {
    return new import_stream9.Stream(({ next, ctx }) => {
      this._invitationsManager.invitationCreated.on(ctx, (invitation) => {
        next({
          action: import_services17.QueryInvitationsResponse.Action.ADDED,
          type: import_services17.QueryInvitationsResponse.Type.CREATED,
          invitations: [
            invitation
          ]
        });
      });
      this._invitationsManager.invitationAccepted.on(ctx, (invitation) => {
        next({
          action: import_services17.QueryInvitationsResponse.Action.ADDED,
          type: import_services17.QueryInvitationsResponse.Type.ACCEPTED,
          invitations: [
            invitation
          ]
        });
      });
      this._invitationsManager.removedCreated.on(ctx, (invitation) => {
        next({
          action: import_services17.QueryInvitationsResponse.Action.REMOVED,
          type: import_services17.QueryInvitationsResponse.Type.CREATED,
          invitations: [
            invitation
          ]
        });
      });
      this._invitationsManager.removedAccepted.on(ctx, (invitation) => {
        next({
          action: import_services17.QueryInvitationsResponse.Action.REMOVED,
          type: import_services17.QueryInvitationsResponse.Type.ACCEPTED,
          invitations: [
            invitation
          ]
        });
      });
      this._invitationsManager.saved.on(ctx, (invitation) => {
        next({
          action: import_services17.QueryInvitationsResponse.Action.SAVED,
          type: import_services17.QueryInvitationsResponse.Type.CREATED,
          invitations: [
            invitation
          ]
        });
      });
      next({
        action: import_services17.QueryInvitationsResponse.Action.ADDED,
        type: import_services17.QueryInvitationsResponse.Type.CREATED,
        invitations: this._invitationsManager.getCreatedInvitations(),
        existing: true
      });
      next({
        action: import_services17.QueryInvitationsResponse.Action.ADDED,
        type: import_services17.QueryInvitationsResponse.Type.ACCEPTED,
        invitations: this._invitationsManager.getAcceptedInvitations(),
        existing: true
      });
      this._invitationsManager.onPersistentInvitationsLoaded(ctx, () => {
        next({
          action: import_services17.QueryInvitationsResponse.Action.LOAD_COMPLETE,
          type: import_services17.QueryInvitationsResponse.Type.CREATED
        });
      });
    });
  }
};
var __dxlog_file23 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/space-invitation-protocol.ts";
var SpaceInvitationProtocol = class {
  constructor(_spaceManager, _signingContext, _keyring, _spaceKey) {
    this._spaceManager = _spaceManager;
    this._signingContext = _signingContext;
    this._keyring = _keyring;
    this._spaceKey = _spaceKey;
  }
  toJSON() {
    return {
      kind: "space",
      deviceKey: this._signingContext.deviceKey,
      spaceKey: this._spaceKey
    };
  }
  checkCanInviteNewMembers() {
    if (this._spaceKey == null) {
      return new import_protocols15.InvalidInvitationError("No spaceKey was provided for a space invitation.");
    }
    const space = this._spaceManager.spaces.get(this._spaceKey);
    if (space == null) {
      return new import_protocols15.SpaceNotFoundError(this._spaceKey);
    }
    if (!space?.inner.spaceState.hasMembershipManagementPermission(this._signingContext.identityKey)) {
      return new import_protocols15.AuthorizationError("No member management permission.");
    }
    return void 0;
  }
  getInvitationContext() {
    (0, import_invariant19.invariant)(this._spaceKey, void 0, {
      F: __dxlog_file23,
      L: 65,
      S: this,
      A: [
        "this._spaceKey",
        ""
      ]
    });
    const space = this._spaceManager.spaces.get(this._spaceKey);
    (0, import_invariant19.invariant)(space, void 0, {
      F: __dxlog_file23,
      L: 67,
      S: this,
      A: [
        "space",
        ""
      ]
    });
    return {
      kind: import_services18.Invitation.Kind.SPACE,
      spaceKey: this._spaceKey,
      spaceId: space.id
    };
  }
  async admit(invitation, request, guestProfile) {
    (0, import_invariant19.invariant)(this._spaceKey && request.space, void 0, {
      F: __dxlog_file23,
      L: 80,
      S: this,
      A: [
        "this._spaceKey && request.space",
        ""
      ]
    });
    (0, import_log19.log)("writing guest credentials", {
      host: this._signingContext.deviceKey,
      guest: request.space.deviceKey
    }, {
      F: __dxlog_file23,
      L: 81,
      S: this,
      C: (f, a) => f(...a)
    });
    const spaceMemberCredential = await this._spaceManager.admitMember({
      spaceKey: this._spaceKey,
      identityKey: request.space.identityKey,
      role: invitation.role ?? import_credentials19.SpaceMember.Role.ADMIN,
      profile: guestProfile,
      delegationCredentialId: invitation.delegationCredentialId
    });
    const space = this._spaceManager.spaces.get(this._spaceKey);
    return {
      space: {
        credential: spaceMemberCredential,
        controlTimeframe: space?.inner.controlPipeline.state.timeframe
      }
    };
  }
  async delegate(invitation) {
    (0, import_invariant19.invariant)(this._spaceKey, void 0, {
      F: __dxlog_file23,
      L: 101,
      S: this,
      A: [
        "this._spaceKey",
        ""
      ]
    });
    const space = this._spaceManager.spaces.get(this._spaceKey);
    (0, import_invariant19.invariant)(space, void 0, {
      F: __dxlog_file23,
      L: 103,
      S: this,
      A: [
        "space",
        ""
      ]
    });
    if (invitation.authMethod === import_services18.Invitation.AuthMethod.KNOWN_PUBLIC_KEY) {
      (0, import_invariant19.invariant)(invitation.guestKeypair?.publicKey, void 0, {
        F: __dxlog_file23,
        L: 105,
        S: this,
        A: [
          "invitation.guestKeypair?.publicKey",
          ""
        ]
      });
    }
    (0, import_log19.log)("writing delegate space invitation", {
      host: this._signingContext.deviceKey,
      id: invitation.invitationId
    }, {
      F: __dxlog_file23,
      L: 108,
      S: this,
      C: (f, a) => f(...a)
    });
    const credential = await (0, import_credentials18.createDelegatedSpaceInvitationCredential)(this._signingContext.credentialSigner, space.key, {
      invitationId: invitation.invitationId,
      authMethod: invitation.authMethod,
      swarmKey: invitation.swarmKey,
      role: invitation.role ?? import_credentials19.SpaceMember.Role.ADMIN,
      expiresOn: computeExpirationTime(invitation),
      multiUse: invitation.multiUse ?? false,
      guestKey: invitation.authMethod === import_services18.Invitation.AuthMethod.KNOWN_PUBLIC_KEY ? invitation.guestKeypair.publicKey : void 0
    });
    (0, import_invariant19.invariant)(credential.credential, void 0, {
      F: __dxlog_file23,
      L: 126,
      S: this,
      A: [
        "credential.credential",
        ""
      ]
    });
    await (0, import_feed_store5.writeMessages)(space.inner.controlPipeline.writer, [
      credential
    ]);
    return credential.credential.credential.id;
  }
  async cancelDelegation(invitation) {
    (0, import_invariant19.invariant)(this._spaceKey, void 0, {
      F: __dxlog_file23,
      L: 132,
      S: this,
      A: [
        "this._spaceKey",
        ""
      ]
    });
    (0, import_invariant19.invariant)(invitation.type === import_services18.Invitation.Type.DELEGATED && invitation.delegationCredentialId, void 0, {
      F: __dxlog_file23,
      L: 133,
      S: this,
      A: [
        "invitation.type === Invitation.Type.DELEGATED && invitation.delegationCredentialId",
        ""
      ]
    });
    const space = this._spaceManager.spaces.get(this._spaceKey);
    (0, import_invariant19.invariant)(space, void 0, {
      F: __dxlog_file23,
      L: 135,
      S: this,
      A: [
        "space",
        ""
      ]
    });
    (0, import_log19.log)("cancelling delegated space invitation", {
      host: this._signingContext.deviceKey,
      id: invitation.invitationId
    }, {
      F: __dxlog_file23,
      L: 137,
      S: this,
      C: (f, a) => f(...a)
    });
    const credential = await (0, import_credentials18.createCancelDelegatedSpaceInvitationCredential)(this._signingContext.credentialSigner, space.key, invitation.delegationCredentialId);
    (0, import_invariant19.invariant)(credential.credential, void 0, {
      F: __dxlog_file23,
      L: 144,
      S: this,
      A: [
        "credential.credential",
        ""
      ]
    });
    await (0, import_feed_store5.writeMessages)(space.inner.controlPipeline.writer, [
      credential
    ]);
  }
  checkInvitation(invitation) {
    if (invitation.spaceKey == null) {
      return new import_protocols15.InvalidInvitationError("No spaceKey was provided for a space invitation.");
    }
    if (this._spaceManager.spaces.has(invitation.spaceKey)) {
      return new import_protocols15.AlreadyJoinedError("Already joined space.");
    }
  }
  createIntroduction() {
    return {
      profile: this._signingContext.getProfile()
    };
  }
  async createAdmissionRequest() {
    const controlFeedKey = await this._keyring.createKey();
    const dataFeedKey = await this._keyring.createKey();
    return {
      space: {
        identityKey: this._signingContext.identityKey,
        deviceKey: this._signingContext.deviceKey,
        controlFeedKey,
        dataFeedKey
      }
    };
  }
  async accept(response) {
    (0, import_invariant19.invariant)(response.space, void 0, {
      F: __dxlog_file23,
      L: 179,
      S: this,
      A: [
        "response.space",
        ""
      ]
    });
    const { credential, controlTimeframe, dataTimeframe } = response.space;
    const assertion = (0, import_credentials18.getCredentialAssertion)(credential);
    (0, import_invariant19.invariant)(assertion["@type"] === "dxos.halo.credentials.SpaceMember", "Invalid credential", {
      F: __dxlog_file23,
      L: 182,
      S: this,
      A: [
        "assertion['@type'] === 'dxos.halo.credentials.SpaceMember'",
        "'Invalid credential'"
      ]
    });
    (0, import_invariant19.invariant)(credential.subject.id.equals(this._signingContext.identityKey), void 0, {
      F: __dxlog_file23,
      L: 183,
      S: this,
      A: [
        "credential.subject.id.equals(this._signingContext.identityKey)",
        ""
      ]
    });
    if (this._spaceManager.spaces.has(assertion.spaceKey)) {
      throw new import_protocols15.AlreadyJoinedError("Already joined space.");
    }
    await this._spaceManager.acceptSpace({
      spaceKey: assertion.spaceKey,
      genesisFeedKey: assertion.genesisFeedKey,
      controlTimeframe,
      dataTimeframe
    });
    await this._signingContext.recordCredential(credential);
    return {
      spaceKey: assertion.spaceKey
    };
  }
};
var __dxlog_file24 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/invitations-manager.ts";
var InvitationsManager = class {
  constructor(_invitationsHandler, _getHandler, _metadataStore) {
    this._invitationsHandler = _invitationsHandler;
    this._getHandler = _getHandler;
    this._metadataStore = _metadataStore;
    this._createInvitations = /* @__PURE__ */ new Map();
    this._acceptInvitations = /* @__PURE__ */ new Map();
    this.invitationCreated = new import_async20.Event();
    this.invitationAccepted = new import_async20.Event();
    this.removedCreated = new import_async20.Event();
    this.removedAccepted = new import_async20.Event();
    this.saved = new import_async20.Event();
    this._persistentInvitationsLoadedEvent = new import_async20.Event();
    this._persistentInvitationsLoaded = false;
  }
  async createInvitation(options) {
    if (options.invitationId) {
      const existingInvitation = this._createInvitations.get(options.invitationId);
      if (existingInvitation) {
        return existingInvitation;
      }
    }
    const handler = this._getHandler(options);
    const invitationError = handler.checkCanInviteNewMembers();
    if (invitationError != null) {
      throw invitationError;
    }
    const invitation = this._createInvitation(handler, options);
    const { ctx, stream, observableInvitation } = this._createObservableInvitation(handler, invitation);
    this._createInvitations.set(invitation.invitationId, observableInvitation);
    this.invitationCreated.emit(invitation);
    this._onInvitationComplete(observableInvitation, async () => {
      this._createInvitations.delete(observableInvitation.get().invitationId);
      this.removedCreated.emit(observableInvitation.get());
      if (observableInvitation.get().persistent) {
        await this._safeDeleteInvitation(observableInvitation.get());
      }
    });
    try {
      await this._persistIfRequired(handler, stream, invitation);
    } catch (err) {
      import_log20.log.catch(err, void 0, {
        F: __dxlog_file24,
        L: 82,
        S: this,
        C: (f, a) => f(...a)
      });
      await observableInvitation.cancel();
      return observableInvitation;
    }
    this._invitationsHandler.handleInvitationFlow(ctx, stream, handler, observableInvitation.get());
    return observableInvitation;
  }
  async loadPersistentInvitations() {
    if (this._persistentInvitationsLoaded) {
      const invitations = this.getCreatedInvitations().filter((i) => i.persistent);
      return {
        invitations
      };
    }
    try {
      const persistentInvitations = this._metadataStore.getInvitations();
      const freshInvitations = persistentInvitations.filter((invitation) => !(0, import_echo_pipeline3.hasInvitationExpired)(invitation));
      const loadTasks = freshInvitations.map((persistentInvitation) => {
        (0, import_invariant20.invariant)(!this._createInvitations.get(persistentInvitation.invitationId), "invitation already exists", {
          F: __dxlog_file24,
          L: 103,
          S: this,
          A: [
            "!this._createInvitations.get(persistentInvitation.invitationId)",
            "'invitation already exists'"
          ]
        });
        return this.createInvitation({
          ...persistentInvitation,
          persistent: false
        });
      });
      const cInvitations = await Promise.all(loadTasks);
      return {
        invitations: cInvitations.map((invitation) => invitation.get())
      };
    } catch (err) {
      import_log20.log.catch(err, void 0, {
        F: __dxlog_file24,
        L: 110,
        S: this,
        C: (f, a) => f(...a)
      });
      return {
        invitations: []
      };
    } finally {
      this._persistentInvitationsLoadedEvent.emit();
      this._persistentInvitationsLoaded = true;
    }
  }
  acceptInvitation(request) {
    const options = request.invitation;
    const existingInvitation = this._acceptInvitations.get(options.invitationId);
    if (existingInvitation) {
      return existingInvitation;
    }
    const handler = this._getHandler(options);
    const { ctx, invitation, stream, otpEnteredTrigger } = this._createObservableAcceptingInvitation(handler, options);
    this._invitationsHandler.acceptInvitation(ctx, stream, handler, options, otpEnteredTrigger, request.deviceProfile);
    this._acceptInvitations.set(invitation.get().invitationId, invitation);
    this.invitationAccepted.emit(invitation.get());
    this._onInvitationComplete(invitation, () => {
      this._acceptInvitations.delete(invitation.get().invitationId);
      this.removedAccepted.emit(invitation.get());
    });
    return invitation;
  }
  async authenticate({ invitationId, authCode }) {
    (0, import_log20.log)("authenticating...", void 0, {
      F: __dxlog_file24,
      L: 140,
      S: this,
      C: (f, a) => f(...a)
    });
    (0, import_invariant20.invariant)(invitationId, void 0, {
      F: __dxlog_file24,
      L: 141,
      S: this,
      A: [
        "invitationId",
        ""
      ]
    });
    const observable = this._acceptInvitations.get(invitationId);
    if (!observable) {
      import_log20.log.warn("invalid invitation", {
        invitationId
      }, {
        F: __dxlog_file24,
        L: 144,
        S: this,
        C: (f, a) => f(...a)
      });
    } else {
      await observable.authenticate(authCode);
    }
  }
  async cancelInvitation({ invitationId }) {
    (0, import_log20.log)("cancelInvitation...", {
      invitationId
    }, {
      F: __dxlog_file24,
      L: 151,
      S: this,
      C: (f, a) => f(...a)
    });
    (0, import_invariant20.invariant)(invitationId, void 0, {
      F: __dxlog_file24,
      L: 152,
      S: this,
      A: [
        "invitationId",
        ""
      ]
    });
    const created = this._createInvitations.get(invitationId);
    if (created) {
      if (created.get().persistent) {
        await this._metadataStore.removeInvitation(invitationId);
      }
      if (created.get().type === import_services19.Invitation.Type.DELEGATED) {
        const handler = this._getHandler(created.get());
        await handler.cancelDelegation(created.get());
      }
      await created.cancel();
      this._createInvitations.delete(invitationId);
      this.removedCreated.emit(created.get());
      return;
    }
    const accepted = this._acceptInvitations.get(invitationId);
    if (accepted) {
      await accepted.cancel();
      this._acceptInvitations.delete(invitationId);
      this.removedAccepted.emit(accepted.get());
    }
  }
  getCreatedInvitations() {
    return [
      ...this._createInvitations.values()
    ].map((i) => i.get());
  }
  getAcceptedInvitations() {
    return [
      ...this._acceptInvitations.values()
    ].map((i) => i.get());
  }
  onPersistentInvitationsLoaded(ctx, callback) {
    if (this._persistentInvitationsLoaded) {
      callback();
    } else {
      this._persistentInvitationsLoadedEvent.once(ctx, () => callback());
    }
  }
  _createInvitation(protocol, _options) {
    const { invitationId = import_keys15.PublicKey.random().toHex(), type = import_services19.Invitation.Type.INTERACTIVE, authMethod = import_services19.Invitation.AuthMethod.SHARED_SECRET, state = import_services19.Invitation.State.INIT, timeout = import_client_protocol6.INVITATION_TIMEOUT, swarmKey = import_keys15.PublicKey.random(), persistent = _options?.authMethod !== import_services19.Invitation.AuthMethod.KNOWN_PUBLIC_KEY, created = /* @__PURE__ */ new Date(), guestKeypair = void 0, role = import_credentials21.SpaceMember.Role.ADMIN, lifetime = 86400 * 7, multiUse = false, ...options } = _options ?? {};
    const authCode = options?.authCode ?? (authMethod === import_services19.Invitation.AuthMethod.SHARED_SECRET ? (0, import_credentials20.generatePasscode)(import_client_protocol6.AUTHENTICATION_CODE_LENGTH) : void 0);
    return {
      invitationId,
      type,
      authMethod,
      state,
      swarmKey,
      authCode,
      timeout,
      persistent: persistent && type !== import_services19.Invitation.Type.DELEGATED,
      guestKeypair: guestKeypair ?? (authMethod === import_services19.Invitation.AuthMethod.KNOWN_PUBLIC_KEY ? createAdmissionKeypair() : void 0),
      created,
      lifetime,
      role,
      multiUse,
      delegationCredentialId: options?.delegationCredentialId,
      ...options,
      ...protocol.getInvitationContext()
    };
  }
  _createObservableInvitation(handler, invitation) {
    const stream = new import_async20.PushStream();
    const ctx = new import_context15.Context({
      onError: (err) => {
        stream.error(err);
        void ctx.dispose();
      }
    }, {
      F: __dxlog_file24,
      L: 239
    });
    ctx.onDispose(() => {
      (0, import_log20.log)("complete", {
        ...handler.toJSON()
      }, {
        F: __dxlog_file24,
        L: 246,
        S: this,
        C: (f, a) => f(...a)
      });
      stream.complete();
    });
    const observableInvitation = new import_client_protocol6.CancellableInvitation({
      initialInvitation: invitation,
      subscriber: stream.observable,
      onCancel: async () => {
        stream.next({
          ...invitation,
          state: import_services19.Invitation.State.CANCELLED
        });
        await ctx.dispose();
      }
    });
    return {
      ctx,
      stream,
      observableInvitation
    };
  }
  _createObservableAcceptingInvitation(handler, initialState) {
    const otpEnteredTrigger = new import_async20.Trigger();
    const stream = new import_async20.PushStream();
    const ctx = new import_context15.Context({
      onError: (err) => {
        if (err instanceof import_async20.TimeoutError) {
          (0, import_log20.log)("timeout", {
            ...handler.toJSON()
          }, {
            F: __dxlog_file24,
            L: 274,
            S: this,
            C: (f, a) => f(...a)
          });
          stream.next({
            ...initialState,
            state: import_services19.Invitation.State.TIMEOUT
          });
        } else {
          import_log20.log.warn("auth failed", err, {
            F: __dxlog_file24,
            L: 277,
            S: this,
            C: (f, a) => f(...a)
          });
          stream.next({
            ...initialState,
            state: import_services19.Invitation.State.ERROR
          });
        }
        void ctx.dispose();
      }
    }, {
      F: __dxlog_file24,
      L: 271
    });
    ctx.onDispose(() => {
      (0, import_log20.log)("complete", {
        ...handler.toJSON()
      }, {
        F: __dxlog_file24,
        L: 284,
        S: this,
        C: (f, a) => f(...a)
      });
      stream.complete();
    });
    const invitation = new import_client_protocol6.AuthenticatingInvitation({
      initialInvitation: initialState,
      subscriber: stream.observable,
      onCancel: async () => {
        stream.next({
          ...initialState,
          state: import_services19.Invitation.State.CANCELLED
        });
        await ctx.dispose();
      },
      onAuthenticate: async (code) => {
        otpEnteredTrigger.wake(code);
      }
    });
    return {
      ctx,
      invitation,
      stream,
      otpEnteredTrigger
    };
  }
  async _persistIfRequired(handler, changeStream, invitation) {
    if (invitation.type === import_services19.Invitation.Type.DELEGATED && invitation.delegationCredentialId == null) {
      const delegationCredentialId = await handler.delegate(invitation);
      changeStream.next({
        ...invitation,
        delegationCredentialId
      });
    } else if (invitation.persistent) {
      await this._metadataStore.addInvitation(invitation);
      this.saved.emit(invitation);
    }
  }
  async _safeDeleteInvitation(invitation) {
    try {
      await this._metadataStore.removeInvitation(invitation.invitationId);
    } catch (err) {
      import_log20.log.catch(err, void 0, {
        F: __dxlog_file24,
        L: 320,
        S: this,
        C: (f, a) => f(...a)
      });
    }
  }
  _onInvitationComplete(invitation, callback) {
    invitation.subscribe(() => {
    }, () => {
    }, callback);
  }
};
function _ts_decorate7(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file25 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/locks/node.ts";
var Lock = class {
  constructor({ lockKey: lockPath, onAcquire, onRelease }) {
    this._lockPath = lockPath;
    this._onAcquire = onAcquire;
    this._onRelease = onRelease;
  }
  get lockKey() {
    return this._lockPath;
  }
  async acquire() {
    (0, import_log21.log)("acquiring lock...", void 0, {
      F: __dxlog_file25,
      L: 32,
      S: this,
      C: (f, a) => f(...a)
    });
    this._fileHandle = await import_lock_file.LockFile.acquire(this._lockPath);
    await this._onAcquire?.();
    (0, import_log21.log)("acquired lock", void 0, {
      F: __dxlog_file25,
      L: 37,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  async release() {
    await this._onRelease?.();
    (0, import_invariant21.invariant)(this._fileHandle, "Lock is not acquired", {
      F: __dxlog_file25,
      L: 42,
      S: this,
      A: [
        "this._fileHandle",
        "'Lock is not acquired'"
      ]
    });
    await import_lock_file.LockFile.release(this._fileHandle);
  }
};
_ts_decorate7([
  import_log21.logInfo
], Lock.prototype, "lockKey", null);
var isLocked = (lockPath) => import_lock_file.LockFile.isLocked(lockPath);
function _ts_decorate8(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var ClientRpcServer = class {
  constructor(params) {
    this._handlerCache = /* @__PURE__ */ new Map();
    this._callMetrics = new import_tracing10.MapCounter();
    const { serviceRegistry, handleCall, handleStream, ...rpcOptions } = params;
    this._handleCall = handleCall;
    this._handleStream = handleStream;
    this._serviceRegistry = serviceRegistry;
    this._rpcPeer = new import_rpc.RpcPeer({
      ...rpcOptions,
      callHandler: (method, params2) => {
        const [serviceName, methodName] = (0, import_rpc.parseMethodName)(method);
        const handler = (method2, params3) => this._getServiceHandler(serviceName).call(method2, params3);
        this._callMetrics.inc(`${serviceName}.${methodName} request`);
        if (this._handleCall) {
          return this._handleCall(methodName, params2, handler);
        } else {
          return handler(methodName, params2);
        }
      },
      streamHandler: (method, params2) => {
        const [serviceName, methodName] = (0, import_rpc.parseMethodName)(method);
        const handler = (method2, params3) => this._getServiceHandler(serviceName).callStream(method2, params3);
        this._callMetrics.inc(`${serviceName}.${methodName} request stream`);
        if (this._handleStream) {
          return import_codec_protobuf2.Stream.map(import_codec_protobuf2.Stream.unwrapPromise(this._handleStream(methodName, params2, handler)), (data) => {
            this._callMetrics.inc(`${serviceName}.${methodName} response stream`);
            return data;
          });
        } else {
          return handler(methodName, params2);
        }
      }
    });
  }
  get _services() {
    return Object.keys(this._serviceRegistry.services);
  }
  async open() {
    await this._rpcPeer.open();
  }
  async close() {
    await this._rpcPeer.close();
  }
  _getServiceHandler(serviceName) {
    if (!this._handlerCache.has(serviceName)) {
      const [key, descriptor] = Object.entries(this._serviceRegistry.descriptors).find(([key2, descriptor2]) => descriptor2.name === serviceName) ?? (0, import_debug4.raise)(new Error(`Service not available: ${serviceName}`));
      const service = this._serviceRegistry.services[key];
      if (!service) {
        throw new Error(`Service not available: ${serviceName}`);
      }
      this._handlerCache.set(serviceName, descriptor.createServer(service));
    }
    return this._handlerCache.get(serviceName);
  }
};
_ts_decorate8([
  import_tracing10.trace.metricsCounter()
], ClientRpcServer.prototype, "_callMetrics", void 0);
_ts_decorate8([
  import_tracing10.trace.info()
], ClientRpcServer.prototype, "_services", null);
ClientRpcServer = _ts_decorate8([
  import_tracing10.trace.resource()
], ClientRpcServer);
function _ts_decorate9(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file26 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/agents/edge-agent-manager.ts";
var AGENT_STATUS_QUERY_RETRY_INTERVAL = 5e3;
var AGENT_STATUS_QUERY_RETRY_JITTER = 1e3;
var AGENT_FEED_ADDED_CHECK_INTERVAL_MS = 3e3;
var EdgeAgentManager = class extends import_context16.Resource {
  constructor(_edgeFeatures, _edgeHttpClient, _dataSpaceManager, _identity) {
    super(), this._edgeFeatures = _edgeFeatures, this._edgeHttpClient = _edgeHttpClient, this._dataSpaceManager = _dataSpaceManager, this._identity = _identity, this.agentStatusChanged = new import_async21.Event(), this._lastKnownDeviceCount = 0;
  }
  get agentStatus() {
    return this._agentStatus;
  }
  get agentExists() {
    return this._agentStatus && this._agentStatus !== import_protocols16.EdgeAgentStatus.NOT_FOUND;
  }
  async createAgent() {
    (0, import_invariant22.invariant)(this.isOpen, void 0, {
      F: __dxlog_file26,
      L: 54,
      S: this,
      A: [
        "this.isOpen",
        ""
      ]
    });
    (0, import_invariant22.invariant)(this._edgeHttpClient, void 0, {
      F: __dxlog_file26,
      L: 55,
      S: this,
      A: [
        "this._edgeHttpClient",
        ""
      ]
    });
    (0, import_invariant22.invariant)(this._edgeFeatures?.agents, void 0, {
      F: __dxlog_file26,
      L: 56,
      S: this,
      A: [
        "this._edgeFeatures?.agents",
        ""
      ]
    });
    const response = await this._edgeHttpClient.createAgent({
      identityKey: this._identity.identityKey.toHex(),
      haloSpaceId: this._identity.haloSpaceId,
      haloSpaceKey: this._identity.haloSpaceKey.toHex()
    });
    const deviceKey = import_keys16.PublicKey.fromHex(response.deviceKey);
    if (await this._identity.authorizedDeviceKeys.has(deviceKey)) {
      import_log22.log.info("agent was already added to HALO, ignoring response", {
        response
      }, {
        F: __dxlog_file26,
        L: 67,
        S: this,
        C: (f, a) => f(...a)
      });
      this._updateStatus(import_protocols16.EdgeAgentStatus.ACTIVE, deviceKey);
      return;
    }
    await this._identity.admitDevice({
      deviceKey,
      controlFeedKey: import_keys16.PublicKey.fromHex(response.feedKey),
      // TODO: agents don't have data feed, should be removed
      dataFeedKey: import_keys16.PublicKey.random()
    });
    (0, import_log22.log)("agent created", response, {
      F: __dxlog_file26,
      L: 79,
      S: this,
      C: (f, a) => f(...a)
    });
    this._updateStatus(import_protocols16.EdgeAgentStatus.ACTIVE, deviceKey);
  }
  async _open() {
    const isEnabled = this._edgeHttpClient && this._edgeFeatures?.agents;
    (0, import_log22.log)("edge agent manager open", {
      isEnabled
    }, {
      F: __dxlog_file26,
      L: 87,
      S: this,
      C: (f, a) => f(...a)
    });
    if (!isEnabled) {
      return;
    }
    this._lastKnownDeviceCount = this._identity.authorizedDeviceKeys.size;
    this._fetchAgentStatusTask = new import_async21.DeferredTask(this._ctx, async () => {
      await this._fetchAgentStatus();
    });
    this._fetchAgentStatusTask.schedule();
    this._dataSpaceManager.updated.on(this._ctx, () => {
      if (this._agentDeviceKey) {
        this._ensureAgentIsInSpaces(this._agentDeviceKey);
      }
    });
    this._identity.stateUpdate.on(this._ctx, () => {
      const maybeAgentWasCreated = this._identity.authorizedDeviceKeys.size > this._lastKnownDeviceCount;
      if (this.agentExists || !maybeAgentWasCreated) {
        return;
      }
      this._lastKnownDeviceCount = this._identity.authorizedDeviceKeys.size;
      this._fetchAgentStatusTask?.schedule();
    });
  }
  async _close() {
    this._fetchAgentStatusTask = void 0;
    this._lastKnownDeviceCount = 0;
  }
  async _fetchAgentStatus() {
    (0, import_invariant22.invariant)(this._edgeHttpClient, void 0, {
      F: __dxlog_file26,
      L: 121,
      S: this,
      A: [
        "this._edgeHttpClient",
        ""
      ]
    });
    try {
      (0, import_log22.log)("fetching agent status", void 0, {
        F: __dxlog_file26,
        L: 123,
        S: this,
        C: (f, a) => f(...a)
      });
      const { agent } = await this._edgeHttpClient.getAgentStatus({
        ownerIdentityKey: this._identity.identityKey
      });
      const wasAgentCreatedDuringQuery = this._agentStatus === import_protocols16.EdgeAgentStatus.ACTIVE;
      if (!wasAgentCreatedDuringQuery) {
        const deviceKey = agent.deviceKey ? import_keys16.PublicKey.fromHex(agent.deviceKey) : void 0;
        this._updateStatus(agent.status, deviceKey);
      }
    } catch (err) {
      if (err instanceof import_protocols16.EdgeCallFailedError) {
        if (!err.isRetryable) {
          import_log22.log.warn("non retryable error on agent status fetch attempt", {
            err
          }, {
            F: __dxlog_file26,
            L: 133,
            S: this,
            C: (f, a) => f(...a)
          });
          return;
        }
      }
      const retryAfterMs = AGENT_STATUS_QUERY_RETRY_INTERVAL + Math.random() * AGENT_STATUS_QUERY_RETRY_JITTER;
      import_log22.log.info("agent status fetching failed", {
        err,
        retryAfterMs
      }, {
        F: __dxlog_file26,
        L: 138,
        S: this,
        C: (f, a) => f(...a)
      });
      (0, import_async21.scheduleTask)(this._ctx, () => this._fetchAgentStatusTask?.schedule(), retryAfterMs);
    }
  }
  /**
  * We don't want notarization plugin to always actively poll edge looking for credentials to notarize,
  * because most of the time we'll be getting an empty response.
  * Instead, we stay in active polling mode while there are spaces where we don't see our agent's feed.
  */
  _ensureAgentIsInSpaces(agentDeviceKey) {
    let activePollingEnabled = false;
    for (const space of this._dataSpaceManager.spaces.values()) {
      if (space.getEdgeReplicationSetting() === import_metadata2.EdgeReplicationSetting.DISABLED) {
        space.notarizationPlugin.setActiveEdgePollingEnabled(false);
        continue;
      }
      if ([
        import_services20.SpaceState.SPACE_INACTIVE,
        import_services20.SpaceState.SPACE_CLOSED
      ].includes(space.state)) {
        space.notarizationPlugin.setActiveEdgePollingEnabled(false);
        continue;
      }
      const agentFeedNeedsNotarization = ![
        ...space.inner.spaceState.feeds.values()
      ].some((feed) => feed.assertion.deviceKey.equals(agentDeviceKey));
      space.notarizationPlugin.setActiveEdgePollingEnabled(agentFeedNeedsNotarization);
      activePollingEnabled = activePollingEnabled || agentFeedNeedsNotarization;
      import_log22.log.info("set active edge polling", {
        enabled: agentFeedNeedsNotarization,
        spaceId: space.id
      }, {
        F: __dxlog_file26,
        L: 165,
        S: this,
        C: (f, a) => f(...a)
      });
    }
    if (activePollingEnabled) {
      (0, import_async21.scheduleTask)(this._ctx, () => this._ensureAgentIsInSpaces(agentDeviceKey), AGENT_FEED_ADDED_CHECK_INTERVAL_MS);
    }
  }
  _updateStatus(status, deviceKey) {
    this._agentStatus = status;
    this._agentDeviceKey = deviceKey;
    this.agentStatusChanged.emit(status);
    if (deviceKey) {
      this._ensureAgentIsInSpaces(deviceKey);
    }
    import_log22.log.info("agent status update", {
      status
    }, {
      F: __dxlog_file26,
      L: 181,
      S: this,
      C: (f, a) => f(...a)
    });
  }
};
_ts_decorate9([
  import_async21.synchronized
], EdgeAgentManager.prototype, "createAgent", null);
var EdgeAgentServiceImpl = class {
  constructor(_agentManagerProvider, _edgeConnection) {
    this._agentManagerProvider = _agentManagerProvider;
    this._edgeConnection = _edgeConnection;
  }
  // TODO(mykola): Reconcile with NetworkService.queryStatus.
  queryEdgeStatus() {
    return new import_stream10.Stream(({ ctx, next }) => {
      const update = () => {
        next({
          status: this._edgeConnection?.status ?? import_services21.EdgeStatus.NOT_CONNECTED
        });
      };
      this._edgeConnection?.statusChanged.on(ctx, update);
      update();
    });
  }
  async createAgent() {
    return (await this._agentManagerProvider()).createAgent();
  }
  queryAgentStatus() {
    return new import_stream10.Stream(({ ctx, next }) => {
      next({
        status: import_services21.QueryAgentStatusResponse.AgentStatus.UNKNOWN
      });
      void this._agentManagerProvider().then((agentManager) => {
        next({
          status: mapStatus(agentManager.agentStatus)
        });
        agentManager.agentStatusChanged.on(ctx, (newStatus) => {
          next({
            status: mapStatus(newStatus)
          });
        });
      });
    });
  }
};
var mapStatus = (agentStatus) => {
  switch (agentStatus) {
    case import_protocols17.EdgeAgentStatus.ACTIVE:
      return import_services21.QueryAgentStatusResponse.AgentStatus.ACTIVE;
    case import_protocols17.EdgeAgentStatus.INACTIVE:
      return import_services21.QueryAgentStatusResponse.AgentStatus.INACTIVE;
    case import_protocols17.EdgeAgentStatus.NOT_FOUND:
      return import_services21.QueryAgentStatusResponse.AgentStatus.NOT_FOUND;
    case void 0:
      return import_services21.QueryAgentStatusResponse.AgentStatus.UNKNOWN;
  }
};
var __dxlog_file27 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/identity/identity-recovery-manager.ts";
var EdgeIdentityRecoveryManager = class {
  constructor(_keyring, _edgeClient, _identityProvider, _acceptRecoveredIdentity) {
    this._keyring = _keyring;
    this._edgeClient = _edgeClient;
    this._identityProvider = _identityProvider;
    this._acceptRecoveredIdentity = _acceptRecoveredIdentity;
  }
  async createRecoveryCredential({ data }) {
    const identity = this._identityProvider();
    (0, import_invariant24.invariant)(identity, void 0, {
      F: __dxlog_file27,
      L: 39,
      S: this,
      A: [
        "identity",
        ""
      ]
    });
    let recoveryKey;
    let lookupKey;
    let algorithm;
    let recoveryCode;
    if (data) {
      recoveryKey = data.recoveryKey;
      lookupKey = data.lookupKey;
      algorithm = data.algorithm;
    } else {
      recoveryCode = (0, import_credentials23.generateSeedPhrase)();
      const keypair = (0, import_credentials23.keyPairFromSeedPhrase)(recoveryCode);
      recoveryKey = import_keys18.PublicKey.from(keypair.publicKey);
      lookupKey = import_keys18.PublicKey.from(keypair.publicKey);
      algorithm = "ED25519";
    }
    const identityKey = identity.identityKey;
    const credential = await identity.getIdentityCredentialSigner().createCredential({
      subject: identityKey,
      assertion: {
        "@type": "dxos.halo.credentials.IdentityRecovery",
        recoveryKey,
        identityKey,
        algorithm,
        lookupKey
      }
    });
    const receipt = await identity.controlPipeline.writer.write({
      credential: {
        credential
      }
    });
    await identity.controlPipeline.state.waitUntilTimeframe(new import_timeframe5.Timeframe([
      [
        receipt.feedKey,
        receipt.seq
      ]
    ]));
    return {
      recoveryCode
    };
  }
  async requestRecoveryChallenge() {
    (0, import_invariant24.invariant)(this._edgeClient, "Not connected to EDGE.", {
      F: __dxlog_file27,
      L: 76,
      S: this,
      A: [
        "this._edgeClient",
        "'Not connected to EDGE.'"
      ]
    });
    const deviceKey = await this._keyring.createKey();
    const controlFeedKey = await this._keyring.createKey();
    const request = {
      deviceKey: deviceKey.toHex(),
      controlFeedKey: controlFeedKey.toHex()
    };
    try {
      await this._edgeClient.recoverIdentity(request);
      throw new Error("No challenge received.");
    } catch (error) {
      if (!(error instanceof import_protocols19.EdgeAuthChallengeError)) {
        throw error;
      }
      return {
        deviceKey,
        controlFeedKey,
        challenge: error.challenge
      };
    }
  }
  async recoverIdentityWithExternalSignature({ lookupKey, deviceKey, controlFeedKey, signature, clientDataJson, authenticatorData }) {
    (0, import_invariant24.invariant)(this._edgeClient, "Not connected to EDGE.", {
      F: __dxlog_file27,
      L: 108,
      S: this,
      A: [
        "this._edgeClient",
        "'Not connected to EDGE.'"
      ]
    });
    const request = {
      lookupKey: lookupKey.toHex(),
      deviceKey: deviceKey.toHex(),
      controlFeedKey: controlFeedKey.toHex(),
      signature: clientDataJson && authenticatorData ? {
        signature: Buffer.from(signature).toString("base64"),
        clientDataJson: Buffer.from(clientDataJson).toString("base64"),
        authenticatorData: Buffer.from(authenticatorData).toString("base64")
      } : Buffer.from(signature).toString("base64")
    };
    const response = await this._edgeClient.recoverIdentity(request);
    await this._acceptRecoveredIdentity({
      authorizedDeviceCredential: decodeCredential(response.deviceAuthCredential),
      haloGenesisFeedKey: import_keys18.PublicKey.fromHex(response.genesisFeedKey),
      haloSpaceKey: import_keys18.PublicKey.fromHex(response.haloSpaceKey),
      identityKey: import_keys18.PublicKey.fromHex(response.identityKey),
      deviceKey,
      controlFeedKey,
      dataFeedKey: await this._keyring.createKey()
    });
  }
  /**
  * Recovery identity using an opaque token sent to the user's email.
  */
  async recoverIdentityWithToken({ token }) {
    (0, import_invariant24.invariant)(this._edgeClient, "Not connected to EDGE.", {
      F: __dxlog_file27,
      L: 141,
      S: this,
      A: [
        "this._edgeClient",
        "'Not connected to EDGE.'"
      ]
    });
    const deviceKey = await this._keyring.createKey();
    const controlFeedKey = await this._keyring.createKey();
    const request = {
      deviceKey: deviceKey.toHex(),
      controlFeedKey: controlFeedKey.toHex(),
      token
    };
    const response = await this._edgeClient.recoverIdentity(request);
    await this._acceptRecoveredIdentity({
      authorizedDeviceCredential: decodeCredential(response.deviceAuthCredential),
      haloGenesisFeedKey: import_keys18.PublicKey.fromHex(response.genesisFeedKey),
      haloSpaceKey: import_keys18.PublicKey.fromHex(response.haloSpaceKey),
      identityKey: import_keys18.PublicKey.fromHex(response.identityKey),
      deviceKey,
      controlFeedKey,
      dataFeedKey: await this._keyring.createKey()
    });
  }
  async recoverIdentity({ recoveryCode }) {
    (0, import_invariant24.invariant)(this._edgeClient, "Not connected to EDGE.", {
      F: __dxlog_file27,
      L: 165,
      S: this,
      A: [
        "this._edgeClient",
        "'Not connected to EDGE.'"
      ]
    });
    const recoveryKeypair = (0, import_credentials23.keyPairFromSeedPhrase)(recoveryCode);
    const recoveryKey = import_keys18.PublicKey.from(recoveryKeypair.publicKey);
    const deviceKey = await this._keyring.createKey();
    const controlFeedKey = await this._keyring.createKey();
    const request = {
      lookupKey: recoveryKey.toHex(),
      deviceKey: deviceKey.toHex(),
      controlFeedKey: controlFeedKey.toHex()
    };
    let response;
    try {
      response = await this._edgeClient.recoverIdentity(request);
    } catch (error) {
      if (!(error instanceof import_protocols19.EdgeAuthChallengeError)) {
        throw error;
      }
      const signature = (0, import_crypto4.sign)(Buffer.from(error.challenge, "base64"), recoveryKeypair.secretKey);
      response = await this._edgeClient.recoverIdentity({
        ...request,
        signature: Buffer.from(signature).toString("base64")
      });
    }
    import_log24.log.info("recovering identity", response, {
      F: __dxlog_file27,
      L: 191,
      S: this,
      C: (f, a) => f(...a)
    });
    await this._acceptRecoveredIdentity({
      authorizedDeviceCredential: decodeCredential(response.deviceAuthCredential),
      haloGenesisFeedKey: import_keys18.PublicKey.fromHex(response.genesisFeedKey),
      haloSpaceKey: import_keys18.PublicKey.fromHex(response.haloSpaceKey),
      identityKey: import_keys18.PublicKey.fromHex(response.identityKey),
      deviceKey,
      controlFeedKey,
      dataFeedKey: await this._keyring.createKey()
    });
  }
};
var decodeCredential = (credentialBase64) => {
  const credentialBytes = Buffer.from(credentialBase64, "base64");
  const codec = import_proto6.schema.getCodecForType("dxos.halo.credentials.Credential");
  return codec.decode(credentialBytes);
};
function _ts_decorate10(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function _ts_add_disposable_resource4(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = function() {
      try {
        inner.call(this);
      } catch (e) {
        return Promise.reject(e);
      }
    };
    env.stack.push({
      value,
      dispose,
      async
    });
  } else if (async) {
    env.stack.push({
      async: true
    });
  }
  return value;
}
function _ts_dispose_resources4(env) {
  var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  };
  return (_ts_dispose_resources4 = function _ts_dispose_resources5(env2) {
    function fail(e) {
      env2.error = env2.hasError ? new _SuppressedError(e, env2.error, "An error was suppressed during disposal.") : e;
      env2.hasError = true;
    }
    var r, s = 0;
    function next() {
      while (r = env2.stack.pop()) {
        try {
          if (!r.async && s === 1) return s = 0, env2.stack.push(r), Promise.resolve().then(next);
          if (r.dispose) {
            var result = r.dispose.call(r.value);
            if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
              fail(e);
              return next();
            });
          } else s |= 1;
        } catch (e) {
          fail(e);
        }
      }
      if (s === 1) return env2.hasError ? Promise.reject(env2.error) : Promise.resolve();
      if (env2.hasError) throw env2.error;
    }
    return next();
  })(env);
}
var __dxlog_file28 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/services/service-context.ts";
var ServiceContext = class extends import_context17.Resource {
  constructor(storage, level, networkManager, signalManager, _edgeConnection, _edgeHttpClient, _runtimeParams, _edgeFeatures) {
    super(), this.storage = storage, this.level = level, this.networkManager = networkManager, this.signalManager = signalManager, this._edgeConnection = _edgeConnection, this._edgeHttpClient = _edgeHttpClient, this._runtimeParams = _runtimeParams, this._edgeFeatures = _edgeFeatures, this._edgeIdentityUpdateMutex = new import_async22.Mutex(), this.initialized = new import_async22.Trigger(), this._meshReplicator = void 0, this._echoEdgeReplicator = void 0, this._handlerFactories = /* @__PURE__ */ new Map(), this._instanceId = import_keys17.PublicKey.random().toHex();
    this.metadataStore = new import_echo_pipeline4.MetadataStore(storage.createDirectory("metadata"));
    this.blobStore = new import_teleport_extension_object_sync.BlobStore(storage.createDirectory("blobs"));
    this.keyring = new import_keyring.Keyring(storage.createDirectory("keyring"));
    this.feedStore = new import_feed_store6.FeedStore({
      factory: new import_feed_store6.FeedFactory({
        root: storage.createDirectory("feeds"),
        signer: this.keyring,
        hypercore: {
          valueEncoding: import_echo_pipeline4.valueEncoding,
          stats: true
        }
      })
    });
    this.spaceManager = new import_echo_pipeline4.SpaceManager({
      feedStore: this.feedStore,
      networkManager: this.networkManager,
      blobStore: this.blobStore,
      metadataStore: this.metadataStore,
      disableP2pReplication: this._runtimeParams?.disableP2pReplication
    });
    this.identityManager = new IdentityManager({
      metadataStore: this.metadataStore,
      keyring: this.keyring,
      feedStore: this.feedStore,
      spaceManager: this.spaceManager,
      devicePresenceOfflineTimeout: this._runtimeParams?.devicePresenceOfflineTimeout,
      devicePresenceAnnounceInterval: this._runtimeParams?.devicePresenceAnnounceInterval,
      edgeConnection: this._edgeConnection,
      edgeFeatures: this._edgeFeatures
    });
    this.recoveryManager = new EdgeIdentityRecoveryManager(this.keyring, this._edgeHttpClient, () => this.identityManager.identity, this._acceptIdentity.bind(this));
    this.echoHost = new import_echo_pipeline4.EchoHost({
      kv: this.level,
      peerIdProvider: () => this.identityManager.identity?.deviceKey?.toHex(),
      getSpaceKeyByRootDocumentId: (documentId) => this.spaceManager.findSpaceByRootDocumentId(documentId)?.key,
      indexing: {
        vector: this._runtimeParams?.enableVectorIndexing
      }
    });
    this._meshReplicator = new import_echo_pipeline4.MeshEchoReplicator();
    this.invitations = new InvitationsHandler(this.networkManager, this._edgeHttpClient, _runtimeParams?.invitationConnectionDefaultParams);
    this.invitationsManager = new InvitationsManager(this.invitations, (invitation) => this.getInvitationHandler(invitation), this.metadataStore);
    this._handlerFactories.set(import_services22.Invitation.Kind.DEVICE, () => new DeviceInvitationProtocol(this.keyring, () => this.identityManager.identity ?? (0, import_debug5.failUndefined)(), this._acceptIdentity.bind(this)));
    if (!this._runtimeParams?.disableP2pReplication) {
      this._meshReplicator = new import_echo_pipeline4.MeshEchoReplicator();
    }
    if (this._edgeConnection && this._edgeFeatures?.echoReplicator) {
      this._echoEdgeReplicator = new import_echo_pipeline4.EchoEdgeReplicator({
        edgeConnection: this._edgeConnection
      });
    }
  }
  async _open(ctx) {
    await this._checkStorageVersion();
    (0, import_log23.log)("opening...", void 0, {
      F: __dxlog_file28,
      L: 203,
      S: this,
      C: (f, a) => f(...a)
    });
    import_log23.log.trace("dxos.sdk.service-context.open", import_protocols18.trace.begin({
      id: this._instanceId
    }), {
      F: __dxlog_file28,
      L: 204,
      S: this,
      C: (f, a) => f(...a)
    });
    await this.identityManager.open(ctx);
    await this._setNetworkIdentity();
    await this._edgeConnection?.open();
    await this.signalManager.open();
    await this.networkManager.open();
    await this.echoHost.open(ctx);
    if (this._meshReplicator) {
      await this.echoHost.addReplicator(this._meshReplicator);
    }
    if (this._echoEdgeReplicator) {
      await this.echoHost.addReplicator(this._echoEdgeReplicator);
    }
    await this.metadataStore.load();
    await this.spaceManager.open();
    if (this.identityManager.identity) {
      await this.identityManager.identity.joinNetwork();
      await this._initialize(ctx);
    }
    const loadedInvitations = await this.invitationsManager.loadPersistentInvitations();
    (0, import_log23.log)("loaded persistent invitations", {
      count: loadedInvitations.invitations?.length
    }, {
      F: __dxlog_file28,
      L: 232,
      S: this,
      C: (f, a) => f(...a)
    });
    import_log23.log.trace("dxos.sdk.service-context.open", import_protocols18.trace.end({
      id: this._instanceId
    }), {
      F: __dxlog_file28,
      L: 234,
      S: this,
      C: (f, a) => f(...a)
    });
    (0, import_log23.log)("opened", void 0, {
      F: __dxlog_file28,
      L: 235,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  async _close(ctx) {
    (0, import_log23.log)("closing...", void 0, {
      F: __dxlog_file28,
      L: 239,
      S: this,
      C: (f, a) => f(...a)
    });
    if (this._deviceSpaceSync && this.identityManager.identity) {
      await this.identityManager.identity.space.spaceState.removeCredentialProcessor(this._deviceSpaceSync);
    }
    await this.dataSpaceManager?.close();
    await this.edgeAgentManager?.close();
    await this.identityManager.close();
    await this.spaceManager.close();
    await this.feedStore.close();
    await this.metadataStore.close();
    await this.echoHost.close(ctx);
    await this.networkManager.close();
    await this.signalManager.close();
    await this._edgeConnection?.close();
    (0, import_log23.log)("closed", void 0, {
      F: __dxlog_file28,
      L: 255,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  async createIdentity(params = {}) {
    const identity = await this.identityManager.createIdentity(params);
    await this._setNetworkIdentity();
    await identity.joinNetwork();
    await this._initialize(new import_context17.Context(void 0, {
      F: __dxlog_file28,
      L: 262
    }));
    return identity;
  }
  getInvitationHandler(invitation) {
    if (this.identityManager.identity == null && invitation.kind === import_services22.Invitation.Kind.SPACE) {
      throw new Error("Identity must be created before joining a space.");
    }
    const factory = this._handlerFactories.get(invitation.kind);
    (0, import_invariant23.invariant)(factory, `Unknown invitation kind: ${invitation.kind}`, {
      F: __dxlog_file28,
      L: 271,
      S: this,
      A: [
        "factory",
        "`Unknown invitation kind: ${invitation.kind}`"
      ]
    });
    return factory(invitation);
  }
  async broadcastProfileUpdate(profile) {
    if (!profile || !this.dataSpaceManager) {
      return;
    }
    for (const space of this.dataSpaceManager.spaces.values()) {
      await space.updateOwnProfile(profile);
    }
  }
  async _acceptIdentity(params) {
    const { identity, identityRecord } = await this.identityManager.prepareIdentity(params);
    await this._setNetworkIdentity({
      deviceCredential: params.authorizedDeviceCredential
    });
    await identity.joinNetwork();
    await this.identityManager.acceptIdentity(identity, identityRecord, params.deviceProfile);
    await this._initialize(new import_context17.Context(void 0, {
      F: __dxlog_file28,
      L: 290
    }));
    return identity;
  }
  async _checkStorageVersion() {
    await this.metadataStore.load();
    if (this.metadataStore.version !== import_protocols18.STORAGE_VERSION) {
      throw new import_protocols18.InvalidStorageVersionError(import_protocols18.STORAGE_VERSION, this.metadataStore.version);
    }
  }
  // Called when identity is created.
  async _initialize(ctx) {
    (0, import_log23.log)("initializing spaces...", void 0, {
      F: __dxlog_file28,
      L: 305,
      S: this,
      C: (f, a) => f(...a)
    });
    const identity = this.identityManager.identity ?? (0, import_debug5.failUndefined)();
    const signingContext = {
      credentialSigner: identity.getIdentityCredentialSigner(),
      identityKey: identity.identityKey,
      deviceKey: identity.deviceKey,
      getProfile: () => identity.profileDocument,
      recordCredential: async (credential) => {
        await identity.controlPipeline.writer.write({
          credential: {
            credential
          }
        });
      }
    };
    this.dataSpaceManager = new DataSpaceManager({
      spaceManager: this.spaceManager,
      metadataStore: this.metadataStore,
      keyring: this.keyring,
      signingContext,
      feedStore: this.feedStore,
      echoHost: this.echoHost,
      invitationsManager: this.invitationsManager,
      edgeConnection: this._edgeConnection,
      edgeHttpClient: this._edgeHttpClient,
      echoEdgeReplicator: this._echoEdgeReplicator,
      meshReplicator: this._meshReplicator,
      runtimeParams: this._runtimeParams,
      edgeFeatures: this._edgeFeatures
    });
    await this.dataSpaceManager.open();
    this.edgeAgentManager = new EdgeAgentManager(this._edgeFeatures, this._edgeHttpClient, this.dataSpaceManager, identity);
    await this.edgeAgentManager.open();
    this._handlerFactories.set(import_services22.Invitation.Kind.SPACE, (invitation) => {
      (0, import_invariant23.invariant)(this.dataSpaceManager, "dataSpaceManager not initialized yet", {
        F: __dxlog_file28,
        L: 343,
        S: this,
        A: [
          "this.dataSpaceManager",
          "'dataSpaceManager not initialized yet'"
        ]
      });
      return new SpaceInvitationProtocol(this.dataSpaceManager, signingContext, this.keyring, invitation.spaceKey);
    });
    this.initialized.wake();
    this._deviceSpaceSync = {
      processCredential: async (credential) => {
        const assertion = (0, import_credentials22.getCredentialAssertion)(credential);
        if (assertion["@type"] !== "dxos.halo.credentials.SpaceMember") {
          return;
        }
        if (assertion.spaceKey.equals(identity.space.key)) {
          return;
        }
        if (!this.dataSpaceManager) {
          (0, import_log23.log)("dataSpaceManager not initialized yet, ignoring space admission", {
            details: assertion
          }, {
            F: __dxlog_file28,
            L: 359,
            S: this,
            C: (f, a) => f(...a)
          });
          return;
        }
        if (this.dataSpaceManager.spaces.has(assertion.spaceKey)) {
          (0, import_log23.log)("space already exists, ignoring space admission", {
            details: assertion
          }, {
            F: __dxlog_file28,
            L: 363,
            S: this,
            C: (f, a) => f(...a)
          });
          return;
        }
        try {
          (0, import_log23.log)("accepting space recorded in halo", {
            details: assertion
          }, {
            F: __dxlog_file28,
            L: 368,
            S: this,
            C: (f, a) => f(...a)
          });
          await this.dataSpaceManager.acceptSpace({
            spaceKey: assertion.spaceKey,
            genesisFeedKey: assertion.genesisFeedKey
          });
        } catch (err) {
          import_log23.log.catch(err, void 0, {
            F: __dxlog_file28,
            L: 374,
            S: this,
            C: (f, a) => f(...a)
          });
        }
      }
    };
    await identity.space.spaceState.addCredentialProcessor(this._deviceSpaceSync);
  }
  async _setNetworkIdentity(params) {
    const env = {
      stack: [],
      error: void 0,
      hasError: false
    };
    try {
      const _ = _ts_add_disposable_resource4(env, await this._edgeIdentityUpdateMutex.acquire(), false);
      let edgeIdentity;
      const identity = this.identityManager.identity;
      if (identity) {
        (0, import_log23.log)("setting identity on edge connection", {
          identity: identity.identityKey.toHex(),
          swarms: this.networkManager.topics
        }, {
          F: __dxlog_file28,
          L: 388,
          S: this,
          C: (f, a) => f(...a)
        });
        if (params?.deviceCredential) {
          edgeIdentity = await (0, import_edge_client2.createChainEdgeIdentity)(identity.signer, identity.identityKey, identity.deviceKey, params?.deviceCredential && {
            credential: params.deviceCredential
          }, []);
        } else {
          await (0, import_debug5.warnAfterTimeout)(1e4, "Waiting for identity to be ready for edge connection", async () => {
            await identity.ready();
          });
          (0, import_invariant23.invariant)(identity.deviceCredentialChain, void 0, {
            F: __dxlog_file28,
            L: 407,
            S: this,
            A: [
              "identity.deviceCredentialChain",
              ""
            ]
          });
          edgeIdentity = await (0, import_edge_client2.createChainEdgeIdentity)(identity.signer, identity.identityKey, identity.deviceKey, identity.deviceCredentialChain, []);
        }
      } else {
        edgeIdentity = await (0, import_edge_client2.createEphemeralEdgeIdentity)();
      }
      this._edgeConnection?.setIdentity(edgeIdentity);
      this._edgeHttpClient?.setIdentity(edgeIdentity);
      this.networkManager.setPeerInfo({
        identityKey: edgeIdentity.identityKey,
        peerKey: edgeIdentity.peerKey
      });
    } catch (e) {
      env.error = e;
      env.hasError = true;
    } finally {
      _ts_dispose_resources4(env);
    }
  }
};
_ts_decorate10([
  import_tracing11.trace.span()
], ServiceContext.prototype, "_open", null);
_ts_decorate10([
  import_tracing11.trace.span()
], ServiceContext.prototype, "_initialize", null);
ServiceContext = _ts_decorate10([
  (0, import_util12.safeInstanceof)("dxos.client-services.ServiceContext"),
  import_tracing11.trace.resource()
], ServiceContext);
var ServiceRegistry = class {
  // prettier-ignore
  constructor(_serviceBundle, _handlers = {}) {
    this._serviceBundle = _serviceBundle;
    this._handlers = _handlers;
  }
  get descriptors() {
    return this._serviceBundle;
  }
  get services() {
    return this._handlers;
  }
  setServices(services) {
    this._handlers = services;
  }
  addService(name, service) {
    this._handlers[name] = service;
  }
  removeService(name) {
    delete this._handlers[name];
  }
};
var getRootPath = (config) => {
  const { dataRoot = (0, import_util13.isNode)() ? import_client_protocol7.DX_DATA : "dxos/storage" } = config ?? {};
  return `${dataRoot}/`;
};
var isPersistent = (config) => {
  const { persistent = false } = config ?? {};
  return config.dataStore !== void 0 && config.dataStore !== import_config3.Runtime.Client.Storage.StorageDriver.RAM || persistent;
};
var StorageDriver = import_config2.Runtime.Client.Storage.StorageDriver;
var createStorageObjects = (config) => {
  const { persistent = false, keyStore, dataStore } = config ?? {};
  if (persistent && dataStore === StorageDriver.RAM) {
    throw new import_protocols20.InvalidConfigError("RAM storage cannot be used in persistent mode.");
  }
  if (!persistent && dataStore !== void 0 && dataStore !== StorageDriver.RAM) {
    throw new import_protocols20.InvalidConfigError("Cannot use a persistent storage in not persistent mode.");
  }
  if (persistent && keyStore === StorageDriver.RAM) {
    throw new import_protocols20.InvalidConfigError("RAM key storage cannot be used in persistent mode.");
  }
  if (!persistent && keyStore !== StorageDriver.RAM && keyStore !== void 0) {
    throw new import_protocols20.InvalidConfigError("Cannot use a persistent key storage in not persistent mode.");
  }
  return {
    storage: (0, import_random_access_storage.createStorage)({
      type: persistent ? toStorageType(dataStore) : import_random_access_storage.StorageType.RAM,
      root: getRootPath(config)
    })
  };
};
var toStorageType = (type) => {
  switch (type) {
    case void 0:
      return void 0;
    case StorageDriver.RAM:
      return import_random_access_storage.StorageType.RAM;
    case StorageDriver.CHROME:
      return import_random_access_storage.StorageType.CHROME;
    case StorageDriver.FIREFOX:
      return import_random_access_storage.StorageType.FIREFOX;
    case StorageDriver.IDB:
      return import_random_access_storage.StorageType.IDB;
    case StorageDriver.NODE:
      return import_random_access_storage.StorageType.NODE;
    case StorageDriver.WEBFS:
      return import_random_access_storage.StorageType.WEBFS;
    default:
      throw new Error(`Invalid storage type: ${StorageDriver[type]}`);
  }
};
var createLevel = async (config) => {
  const persistent = isPersistent(config);
  const storagePath = persistent ? import_node_path.default.join(getRootPath(config), "level") : `/tmp/dxos-${import_keys19.PublicKey.random().toHex()}`;
  const level = (0, import_kv_store.createLevel)(storagePath);
  await level.open();
  return level;
};
var __dxlog_file29 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/storage/profile-archive.ts";
var encodeProfileArchive = (profile) => import_automerge_repo2.cbor.encode(profile);
var decodeProfileArchive = (data) => import_automerge_repo2.cbor.decode(data);
var exportProfileData = async ({ storage, level }) => {
  const archive = {
    storage: [],
    meta: {
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    }
  };
  {
    const directory = await storage.createDirectory();
    const files = await directory.list();
    import_log25.log.info("begin exporting files", {
      count: files.length
    }, {
      F: __dxlog_file29,
      L: 31,
      S: void 0,
      C: (f, a) => f(...a)
    });
    for (const filename of files) {
      const file = await directory.getOrCreateFile(filename);
      const { size } = await file.stat();
      const data = await file.read(0, size);
      archive.storage.push({
        type: import_protocols21.ProfileArchiveEntryType.FILE,
        key: filename,
        value: data
      });
    }
    import_log25.log.info("done exporting files", {
      count: files.length
    }, {
      F: __dxlog_file29,
      L: 42,
      S: void 0,
      C: (f, a) => f(...a)
    });
  }
  {
    import_log25.log.info("begin exporting kv pairs", void 0, {
      F: __dxlog_file29,
      L: 46,
      S: void 0,
      C: (f, a) => f(...a)
    });
    const iter = await level.iterator({
      keyEncoding: "binary",
      valueEncoding: "binary"
    });
    let count = 0;
    for await (const [key, value] of iter) {
      archive.storage.push({
        type: import_protocols21.ProfileArchiveEntryType.KEY_VALUE,
        key,
        value
      });
      count++;
    }
    import_log25.log.info("done exporting kv pairs", {
      count
    }, {
      F: __dxlog_file29,
      L: 57,
      S: void 0,
      C: (f, a) => f(...a)
    });
  }
  return archive;
};
var importProfileData = async ({ storage, level }, archive) => {
  let batch = level.batch();
  let count = 0;
  for (const entry2 of archive.storage) {
    switch (entry2.type) {
      case import_protocols21.ProfileArchiveEntryType.FILE: {
        const directory = await storage.createDirectory();
        (0, import_invariant25.invariant)(typeof entry2.key === "string", "Invalid key type", {
          F: __dxlog_file29,
          L: 80,
          S: void 0,
          A: [
            "typeof entry.key === 'string'",
            "'Invalid key type'"
          ]
        });
        const file = await directory.getOrCreateFile(entry2.key);
        (0, import_invariant25.invariant)(entry2.value instanceof Uint8Array, "Invalid value type", {
          F: __dxlog_file29,
          L: 82,
          S: void 0,
          A: [
            "entry.value instanceof Uint8Array",
            "'Invalid value type'"
          ]
        });
        await file.write(0, (0, import_util14.arrayToBuffer)(entry2.value));
        await file.close();
        break;
      }
      case import_protocols21.ProfileArchiveEntryType.KEY_VALUE: {
        (0, import_invariant25.invariant)(entry2.key instanceof Uint8Array, "Invalid key type", {
          F: __dxlog_file29,
          L: 88,
          S: void 0,
          A: [
            "entry.key instanceof Uint8Array",
            "'Invalid key type'"
          ]
        });
        (0, import_invariant25.invariant)(entry2.value instanceof Uint8Array, "Invalid value type", {
          F: __dxlog_file29,
          L: 89,
          S: void 0,
          A: [
            "entry.value instanceof Uint8Array",
            "'Invalid value type'"
          ]
        });
        batch.put(entry2.key, entry2.value, {
          keyEncoding: "binary",
          valueEncoding: "binary"
        });
        break;
      }
      default:
        throw new Error(`Invalid entry type: ${entry2.type}`);
    }
    if (++count % 1e3 === 0) {
      await batch.write();
      batch = level.batch();
      import_log25.log.info("importing", {
        count,
        total: archive.storage.length,
        progress: `${(count / archive.storage.length * 100).toFixed()}%`
      }, {
        F: __dxlog_file29,
        L: 102,
        S: void 0,
        C: (f, a) => f(...a)
      });
    }
  }
  import_log25.log.info("committing changes..", void 0, {
    F: __dxlog_file29,
    L: 110,
    S: void 0,
    C: (f, a) => f(...a)
  });
  await batch.write();
};
var __dxlog_file30 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/devices/devices-service.ts";
var DevicesServiceImpl = class {
  constructor(_identityManager, _edgeConnection) {
    this._identityManager = _identityManager;
    this._edgeConnection = _edgeConnection;
  }
  async updateDevice(profile) {
    return this._identityManager.updateDeviceProfile(profile);
  }
  queryDevices() {
    return new import_stream11.Stream(({ next }) => {
      const update = () => {
        const deviceKeys = this._identityManager.identity?.authorizedDeviceKeys;
        if (!deviceKeys) {
          next({
            devices: []
          });
        } else {
          (0, import_invariant27.invariant)(this._identityManager.identity?.presence, "presence not present", {
            F: __dxlog_file30,
            L: 37,
            S: this,
            A: [
              "this._identityManager.identity?.presence",
              "'presence not present'"
            ]
          });
          const peers = this._identityManager.identity.presence.getPeersOnline();
          next({
            devices: Array.from(deviceKeys.entries()).map(([key, profile]) => {
              const isMe = this._identityManager.identity?.deviceKey.equals(key);
              let presence;
              if (isMe) {
                presence = import_services24.Device.PresenceState.ONLINE;
              } else if (profile.os?.toUpperCase() === "EDGE") {
                presence = this._edgeConnection?.status === import_services24.EdgeStatus.CONNECTED ? import_services24.Device.PresenceState.ONLINE : import_services24.Device.PresenceState.OFFLINE;
              } else {
                presence = peers.some((peer) => peer.identityKey.equals(key)) ? import_services24.Device.PresenceState.ONLINE : import_services24.Device.PresenceState.OFFLINE;
              }
              return {
                deviceKey: key,
                kind: this._identityManager.identity?.deviceKey.equals(key) ? import_services24.DeviceKind.CURRENT : import_services24.DeviceKind.TRUSTED,
                profile,
                presence
              };
            })
          });
        }
      };
      let identitySubscribed = false;
      let presenceSubscribed = false;
      const subscribeIdentity = () => {
        if (!identitySubscribed) {
          this._identityManager.identity?.stateUpdate.on(() => {
            update();
          });
          identitySubscribed = true;
        }
      };
      const subscribePresence = () => {
        if (!presenceSubscribed) {
          this._identityManager.identity?.presence?.updated.on(() => {
            update();
          });
          presenceSubscribed = true;
        }
      };
      const subscriptions = new import_async24.SubscriptionList();
      if (this._identityManager.identity) {
        subscribeIdentity();
        subscribePresence();
      }
      subscriptions.add(this._identityManager.stateUpdate.on(() => {
        update();
        if (this._identityManager.identity) {
          subscribeIdentity();
          subscribePresence();
        }
      }));
      update();
      return () => subscriptions.clear();
    });
  }
};
var ContactsServiceImpl = class {
  constructor(_identityManager, _spaceManager, _dataSpaceManagerProvider) {
    this._identityManager = _identityManager;
    this._spaceManager = _spaceManager;
    this._dataSpaceManagerProvider = _dataSpaceManagerProvider;
  }
  async getContacts() {
    const identity = this._identityManager.identity;
    if (identity == null) {
      return {
        contacts: []
      };
    }
    const contacts = [
      ...this._spaceManager.spaces.values()
    ].flatMap((s) => [
      ...s.spaceState.members.values()
    ].map((m) => [
      s.key,
      m
    ])).reduce((acc, v) => {
      const [spaceKey, memberInfo] = v;
      if (memberInfo.key.equals(identity.identityKey)) {
        return acc;
      }
      const existing = acc.get(memberInfo.key);
      if (existing != null) {
        existing.profile ??= memberInfo.profile;
        existing.commonSpaces?.push(spaceKey);
      } else {
        acc.set(memberInfo.key, {
          identityKey: memberInfo.key,
          profile: memberInfo.profile,
          commonSpaces: [
            spaceKey
          ]
        });
      }
      return acc;
    }, new import_util15.ComplexMap(import_keys21.PublicKey.hash));
    return {
      contacts: [
        ...contacts.values()
      ]
    };
  }
  queryContacts() {
    const subscribedSpaceKeySet = new import_util15.ComplexSet(import_keys21.PublicKey.hash);
    return new import_stream12.Stream(({ next, ctx }) => {
      const pushUpdateTask = new import_async25.UpdateScheduler(ctx, async () => {
        const contacts = await this.getContacts();
        next(contacts);
      }, {
        maxFrequency: 2
      });
      (0, import_async25.scheduleTask)(ctx, async () => {
        const subscriptions = new import_async25.SubscriptionList();
        ctx.onDispose(() => subscriptions.clear());
        const subscribeToSpaceAndUpdate = () => {
          const oldSetSize = subscribedSpaceKeySet.size;
          for (const space of this._spaceManager.spaces.values()) {
            if (!subscribedSpaceKeySet.has(space.key)) {
              subscriptions.add(space.stateUpdate.on(ctx, () => pushUpdateTask.trigger()));
              subscribedSpaceKeySet.add(space.key);
            }
          }
          if (oldSetSize !== subscribedSpaceKeySet.size) {
            pushUpdateTask.trigger();
          }
        };
        const unsubscribe = (await this._dataSpaceManagerProvider()).updated.on(ctx, subscribeToSpaceAndUpdate);
        ctx.onDispose(unsubscribe);
        subscribeToSpaceAndUpdate();
      });
    });
  }
};
var LoggingServiceImpl = class {
  constructor() {
    this._logs = new import_async26.Event();
    this._started = Date.now();
    this._sessionId = import_keys22.PublicKey.random().toHex();
    this._logProcessor = (_config, entry2) => {
      this._logs.emit(entry2);
    };
  }
  async open() {
    import_log27.log.runtimeConfig.processors.push(this._logProcessor);
  }
  async close() {
    const index = import_log27.log.runtimeConfig.processors.findIndex((processor) => processor === this._logProcessor);
    import_log27.log.runtimeConfig.processors.splice(index, 1);
  }
  async controlMetrics({ reset, record }) {
    if (reset) {
      import_util16.tracer.clear();
    }
    if (record === true) {
      import_util16.tracer.start();
    } else if (record === false) {
      import_util16.tracer.stop();
    }
    return {
      recording: import_util16.tracer.recording
    };
  }
  /**
  * @deprecated (Move to diagnostics).
  */
  queryMetrics({ interval = 5e3 }) {
    const getNumericalValues = (key) => {
      const events = import_util16.tracer.get(key) ?? [];
      return {
        key,
        stats: (0, import_util16.numericalValues)(events, "duration")
      };
    };
    return new import_stream13.Stream(({ next }) => {
      const update = () => {
        const metrics2 = {
          timestamp: /* @__PURE__ */ new Date(),
          values: [
            getNumericalValues("dxos.echo.pipeline.control"),
            getNumericalValues("dxos.echo.pipeline.data")
          ].filter(Boolean)
        };
        next({
          timestamp: /* @__PURE__ */ new Date(),
          metrics: metrics2
        });
      };
      update();
      const i = setInterval(update, Math.max(interval, 1e3));
      return () => {
        clearInterval(i);
      };
    });
  }
  queryLogs(request) {
    return new import_stream13.Stream(({ ctx, next }) => {
      const handler = (entry2) => {
        if (LOG_PROCESSING > 0) {
          return;
        }
        if (entry2.meta?.F.includes("logging-service") || entry2.context && Object.values(entry2.context).some((value) => typeof value === "string" && value.includes("LoggingService"))) {
          return;
        }
        if (!shouldLog(entry2, request)) {
          return;
        }
        const record = {
          ...entry2,
          context: (0, import_util16.jsonify)((0, import_log27.getContextFromEntry)(entry2)),
          timestamp: /* @__PURE__ */ new Date(),
          meta: {
            // TODO(dmaretskyi): Fix proto.
            file: entry2.meta?.F ?? "",
            line: entry2.meta?.L ?? 0,
            scope: {
              hostSessionId: this._sessionId,
              uptimeSeconds: (Date.now() - this._started) / 1e3,
              name: (0, import_util16.getDebugName)(entry2.meta?.S)
            }
          }
        };
        try {
          LOG_PROCESSING++;
          next(record);
        } finally {
          LOG_PROCESSING--;
        }
      };
      this._logs.on(ctx, handler);
    });
  }
};
var matchFilter = (filter, level, path2, options) => {
  switch (options) {
    case import_services25.QueryLogsRequest.MatchingOptions.INCLUSIVE:
      return level >= filter.level && (!filter.pattern || path2.includes(filter.pattern));
    case import_services25.QueryLogsRequest.MatchingOptions.EXPLICIT:
      return level === filter.level && (!filter.pattern || path2.includes(filter.pattern));
  }
};
var shouldLog = (entry2, request) => {
  const options = request.options ?? import_services25.QueryLogsRequest.MatchingOptions.INCLUSIVE;
  if (request.filters === void 0) {
    return options === import_services25.QueryLogsRequest.MatchingOptions.INCLUSIVE;
  } else {
    return request.filters.some((filter) => matchFilter(filter, entry2.level, entry2.meta?.F ?? "", options));
  }
};
var LOG_PROCESSING = 0;
var NetworkServiceImpl = class {
  constructor(networkManager, signalManager, edgeConnection) {
    this.networkManager = networkManager;
    this.signalManager = signalManager;
    this.edgeConnection = edgeConnection;
  }
  queryStatus() {
    return new import_stream14.Stream(({ ctx, next }) => {
      const update = () => {
        next({
          swarm: this.networkManager.connectionState,
          connectionInfo: this.networkManager.connectionLog?.swarms,
          signaling: this.signalManager.getStatus?.().map(({ host, state }) => ({
            server: host,
            state
          }))
        });
      };
      this.networkManager.connectionStateChanged.on(ctx, () => update());
      this.signalManager.statusChanged?.on(ctx, () => update());
      update();
    });
  }
  async updateConfig(request) {
    await this.networkManager.setConnectionState(request.swarm);
  }
  async joinSwarm(request) {
    return this.signalManager.join(request);
  }
  async leaveSwarm(request) {
    return this.signalManager.leave(request);
  }
  async querySwarm(request) {
    return this.signalManager.query(request);
  }
  subscribeSwarmState(request) {
    return new import_stream14.Stream(({ ctx, next }) => {
      this.signalManager.swarmState?.on(ctx, (state) => {
        if (request.topic.equals(state.swarmKey)) {
          next(state);
        }
      });
    });
  }
  async sendMessage(message) {
    return this.signalManager.sendMessage(message);
  }
  subscribeMessages(peer) {
    return new import_stream14.Stream(({ ctx, next }) => {
      this.signalManager.onMessage.on(ctx, (message) => {
        if (message.recipient.peerKey === peer.peerKey) {
          next(message);
        }
      });
    });
  }
};
var SystemServiceImpl = class {
  constructor({ config, statusUpdate, getDiagnostics, onUpdateStatus, getCurrentStatus, onReset }) {
    this._config = config;
    this._statusUpdate = statusUpdate;
    this._getCurrentStatus = getCurrentStatus;
    this._getDiagnostics = getDiagnostics;
    this._onUpdateStatus = onUpdateStatus;
    this._onReset = onReset;
  }
  async getConfig() {
    return (await this._config?.())?.values ?? {};
  }
  /**
  * NOTE: Since this is serialized as a JSON object, we allow the option to serialize keys.
  */
  async getDiagnostics({ keys } = {}) {
    const diagnostics = await this._getDiagnostics();
    return {
      timestamp: /* @__PURE__ */ new Date(),
      diagnostics: JSON.parse(JSON.stringify(diagnostics, (0, import_util17.jsonKeyReplacer)({
        truncate: keys === import_services26.GetDiagnosticsRequest.KEY_OPTION.TRUNCATE,
        humanize: keys === import_services26.GetDiagnosticsRequest.KEY_OPTION.HUMANIZE
      })))
    };
  }
  async getPlatform() {
    return getPlatform();
  }
  async updateStatus({ status }) {
    await this._onUpdateStatus(status);
  }
  // TODO(burdon): Standardize interval option in stream request?
  queryStatus({ interval = 3e3 } = {}) {
    return new import_stream15.Stream(({ next }) => {
      const update = () => {
        next({
          status: this._getCurrentStatus()
        });
      };
      update();
      const unsubscribe = this._statusUpdate.on(() => update());
      const i = setInterval(update, interval);
      return () => {
        clearInterval(i);
        unsubscribe();
      };
    });
  }
  async reset() {
    await this._onReset();
  }
};
function _ts_decorate11(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file31 = "/home/runner/work/dxos/dxos/packages/sdk/client-services/src/packlets/services/service-host.ts";
var ClientServicesHost = class {
  constructor({
    config,
    transportFactory,
    signalManager,
    storage,
    level,
    // TODO(wittjosiah): Turn this on by default.
    lockKey,
    callbacks,
    runtimeParams
  } = {}) {
    this._tracingService = import_tracing12.TRACE_PROCESSOR.createTraceSender();
    this._statusUpdate = new import_async23.Event();
    this._edgeConnection = void 0;
    this._edgeHttpClient = void 0;
    this._opening = false;
    this._open = false;
    this._resetting = false;
    this._storage = storage;
    this._level = level;
    this._callbacks = callbacks;
    this._runtimeParams = runtimeParams ?? {};
    if (this._runtimeParams.disableP2pReplication === void 0) {
      this._runtimeParams.disableP2pReplication = config?.get("runtime.client.disableP2pReplication", false);
    }
    if (this._runtimeParams.enableVectorIndexing === void 0) {
      this._runtimeParams.enableVectorIndexing = config?.get("runtime.client.enableVectorIndexing", false);
    }
    if (config) {
      this.initialize({
        config,
        transportFactory,
        signalManager
      });
    }
    if (lockKey) {
      this._resourceLock = new Lock({
        lockKey,
        onAcquire: () => {
          if (!this._opening) {
            void this.open(new import_context18.Context(void 0, {
              F: __dxlog_file31,
              L: 141
            }));
          }
        },
        onRelease: () => this.close()
      });
    }
    this._systemService = new SystemServiceImpl({
      config: () => this._config,
      statusUpdate: this._statusUpdate,
      getCurrentStatus: () => this.isOpen && !this._resetting ? import_services23.SystemStatus.ACTIVE : import_services23.SystemStatus.INACTIVE,
      getDiagnostics: () => {
        return createDiagnostics(this._serviceRegistry.services, this._serviceContext, this._config);
      },
      onUpdateStatus: async (status) => {
        if (!this.isOpen && status === import_services23.SystemStatus.ACTIVE) {
          await this._resourceLock?.acquire();
        } else if (this.isOpen && status === import_services23.SystemStatus.INACTIVE) {
          await this._resourceLock?.release();
        }
      },
      onReset: async () => {
        await this.reset();
      }
    });
    this.diagnosticsBroadcastHandler = createCollectDiagnosticsBroadcastHandler(this._systemService);
    this._loggingService = new LoggingServiceImpl();
    this._serviceRegistry = new ServiceRegistry(import_client_protocol8.clientServiceBundle, {
      SystemService: this._systemService,
      TracingService: this._tracingService
    });
  }
  get isOpen() {
    return this._open;
  }
  get config() {
    return this._config;
  }
  get context() {
    return this._serviceContext;
  }
  get serviceRegistry() {
    return this._serviceRegistry;
  }
  get descriptors() {
    return this._serviceRegistry.descriptors;
  }
  get services() {
    return this._serviceRegistry.services;
  }
  /**
  * Initialize the service host with the config.
  * Config can also be provided in the constructor.
  * Can only be called once.
  */
  initialize({ config, ...options }) {
    (0, import_invariant26.invariant)(!this._open, "service host is open", {
      F: __dxlog_file31,
      L: 207,
      S: this,
      A: [
        "!this._open",
        "'service host is open'"
      ]
    });
    (0, import_log26.log)("initializing...", void 0, {
      F: __dxlog_file31,
      L: 208,
      S: this,
      C: (f, a) => f(...a)
    });
    if (config) {
      (0, import_invariant26.invariant)(!this._config, "config already set", {
        F: __dxlog_file31,
        L: 211,
        S: this,
        A: [
          "!this._config",
          "'config already set'"
        ]
      });
      this._config = config;
      if (!this._storage) {
        this._storage = createStorageObjects(config.get("runtime.client.storage", {})).storage;
      }
    }
    if (!options.signalManager) {
      import_log26.log.warn("running signaling without telemetry metadata.", void 0, {
        F: __dxlog_file31,
        L: 219,
        S: this,
        C: (f, a) => f(...a)
      });
    }
    const edgeEndpoint = config?.get("runtime.services.edge.url");
    if (edgeEndpoint) {
      this._edgeConnection = new import_edge_client3.EdgeClient((0, import_edge_client3.createStubEdgeIdentity)(), {
        socketEndpoint: edgeEndpoint
      });
      this._edgeHttpClient = new import_edge_client3.EdgeHttpClient(edgeEndpoint);
    }
    const { connectionLog = true, transportFactory = (0, import_network_manager2.createRtcTransportFactory)({
      iceServers: this._config?.get("runtime.services.ice")
    }, this._config?.get("runtime.services.iceProviders") && (0, import_network_manager2.createIceProvider)(this._config.get("runtime.services.iceProviders"))), signalManager = this._edgeConnection && this._config?.get("runtime.client.edgeFeatures")?.signaling ? new import_messaging.EdgeSignalManager({
      edgeConnection: this._edgeConnection
    }) : new import_messaging.WebsocketSignalManager(this._config?.get("runtime.services.signaling") ?? []) } = options;
    this._signalManager = signalManager;
    (0, import_invariant26.invariant)(!this._networkManager, "network manager already set", {
      F: __dxlog_file31,
      L: 241,
      S: this,
      A: [
        "!this._networkManager",
        "'network manager already set'"
      ]
    });
    this._networkManager = new import_network_manager2.SwarmNetworkManager({
      enableDevtoolsLogging: connectionLog,
      transportFactory,
      signalManager,
      peerInfo: this._edgeConnection ? {
        identityKey: this._edgeConnection.identityKey,
        peerKey: this._edgeConnection.peerKey
      } : void 0
    });
    (0, import_log26.log)("initialized", void 0, {
      F: __dxlog_file31,
      L: 254,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  async open(ctx) {
    if (this._open) {
      return;
    }
    const traceId = import_keys20.PublicKey.random().toHex();
    import_log26.log.trace("dxos.client-services.host.open", import_protocols22.trace.begin({
      id: traceId
    }), {
      F: __dxlog_file31,
      L: 265,
      S: this,
      C: (f, a) => f(...a)
    });
    (0, import_invariant26.invariant)(this._config, "config not set", {
      F: __dxlog_file31,
      L: 267,
      S: this,
      A: [
        "this._config",
        "'config not set'"
      ]
    });
    (0, import_invariant26.invariant)(this._storage, "storage not set", {
      F: __dxlog_file31,
      L: 268,
      S: this,
      A: [
        "this._storage",
        "'storage not set'"
      ]
    });
    (0, import_invariant26.invariant)(this._signalManager, "signal manager not set", {
      F: __dxlog_file31,
      L: 269,
      S: this,
      A: [
        "this._signalManager",
        "'signal manager not set'"
      ]
    });
    (0, import_invariant26.invariant)(this._networkManager, "network manager not set", {
      F: __dxlog_file31,
      L: 270,
      S: this,
      A: [
        "this._networkManager",
        "'network manager not set'"
      ]
    });
    this._opening = true;
    (0, import_log26.log)("opening...", {
      lockKey: this._resourceLock?.lockKey
    }, {
      F: __dxlog_file31,
      L: 273,
      S: this,
      C: (f, a) => f(...a)
    });
    await this._resourceLock?.acquire();
    if (!this._level) {
      this._level = await createLevel(this._config.get("runtime.client.storage", {}));
    }
    await this._level.open();
    await this._loggingService.open();
    this._serviceContext = new ServiceContext(this._storage, this._level, this._networkManager, this._signalManager, this._edgeConnection, this._edgeHttpClient, this._runtimeParams, this._config.get("runtime.client.edgeFeatures"));
    const dataSpaceManagerProvider = async () => {
      await this._serviceContext.initialized.wait();
      return this._serviceContext.dataSpaceManager;
    };
    const agentManagerProvider = async () => {
      await this._serviceContext.initialized.wait();
      return this._serviceContext.edgeAgentManager;
    };
    const identityService = new IdentityServiceImpl(this._serviceContext.identityManager, this._serviceContext.recoveryManager, this._serviceContext.keyring, () => this._serviceContext.dataSpaceManager, (params) => this._createIdentity(params), (profile) => this._serviceContext.broadcastProfileUpdate(profile));
    this._serviceRegistry.setServices({
      SystemService: this._systemService,
      IdentityService: identityService,
      ContactsService: new ContactsServiceImpl(this._serviceContext.identityManager, this._serviceContext.spaceManager, dataSpaceManagerProvider),
      InvitationsService: new InvitationsServiceImpl(this._serviceContext.invitationsManager),
      DevicesService: new DevicesServiceImpl(this._serviceContext.identityManager, this._edgeConnection),
      SpacesService: new SpacesServiceImpl(this._serviceContext.identityManager, this._serviceContext.spaceManager, dataSpaceManagerProvider),
      DataService: this._serviceContext.echoHost.dataService,
      QueryService: this._serviceContext.echoHost.queryService,
      NetworkService: new NetworkServiceImpl(this._serviceContext.networkManager, this._serviceContext.signalManager, this._edgeConnection),
      LoggingService: this._loggingService,
      TracingService: this._tracingService,
      // TODO(burdon): Move to new protobuf definitions.
      DevtoolsHost: new DevtoolsServiceImpl({
        events: new DevtoolsHostEvents(),
        config: this._config,
        context: this._serviceContext
      }),
      EdgeAgentService: new EdgeAgentServiceImpl(agentManagerProvider, this._edgeConnection)
    });
    await this._serviceContext.open(ctx);
    await identityService.open();
    const devtoolsProxy = this._config?.get("runtime.client.devtoolsProxy");
    if (devtoolsProxy) {
      this._devtoolsProxy = new import_websocket_rpc.WebsocketRpcClient({
        url: devtoolsProxy,
        requested: {},
        exposed: import_client_protocol8.clientServiceBundle,
        handlers: this.services
      });
      void this._devtoolsProxy.open();
    }
    this.diagnosticsBroadcastHandler.start();
    this._opening = false;
    this._open = true;
    this._statusUpdate.emit();
    const deviceKey = this._serviceContext.identityManager.identity?.deviceKey;
    (0, import_log26.log)("opened", {
      deviceKey
    }, {
      F: __dxlog_file31,
      L: 374,
      S: this,
      C: (f, a) => f(...a)
    });
    import_log26.log.trace("dxos.client-services.host.open", import_protocols22.trace.end({
      id: traceId
    }), {
      F: __dxlog_file31,
      L: 375,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  async close() {
    if (!this._open) {
      return;
    }
    const deviceKey = this._serviceContext.identityManager.identity?.deviceKey;
    (0, import_log26.log)("closing...", {
      deviceKey
    }, {
      F: __dxlog_file31,
      L: 386,
      S: this,
      C: (f, a) => f(...a)
    });
    this.diagnosticsBroadcastHandler.stop();
    await this._devtoolsProxy?.close();
    this._serviceRegistry.setServices({
      SystemService: this._systemService
    });
    await this._loggingService.close();
    await this._serviceContext.close();
    await this._level?.close();
    this._open = false;
    this._statusUpdate.emit();
    (0, import_log26.log)("closed", {
      deviceKey
    }, {
      F: __dxlog_file31,
      L: 395,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  async reset() {
    const traceId = import_keys20.PublicKey.random().toHex();
    import_log26.log.trace("dxos.sdk.client-services-host.reset", import_protocols22.trace.begin({
      id: traceId
    }), {
      F: __dxlog_file31,
      L: 400,
      S: this,
      C: (f, a) => f(...a)
    });
    import_log26.log.info("resetting...", void 0, {
      F: __dxlog_file31,
      L: 402,
      S: this,
      C: (f, a) => f(...a)
    });
    this._resetting = true;
    this._statusUpdate.emit();
    await this._serviceContext?.close();
    await this._storage.reset();
    import_log26.log.info("reset", void 0, {
      F: __dxlog_file31,
      L: 409,
      S: this,
      C: (f, a) => f(...a)
    });
    import_log26.log.trace("dxos.sdk.client-services-host.reset", import_protocols22.trace.end({
      id: traceId
    }), {
      F: __dxlog_file31,
      L: 410,
      S: this,
      C: (f, a) => f(...a)
    });
    await this._callbacks?.onReset?.();
  }
  async _createIdentity(params) {
    const identity = await this._serviceContext.createIdentity(params);
    await this._serviceContext.initialized.wait();
    return identity;
  }
};
_ts_decorate11([
  import_tracing12.trace.info()
], ClientServicesHost.prototype, "_opening", void 0);
_ts_decorate11([
  import_tracing12.trace.info()
], ClientServicesHost.prototype, "_open", void 0);
_ts_decorate11([
  import_tracing12.trace.info()
], ClientServicesHost.prototype, "_resetting", void 0);
_ts_decorate11([
  import_async23.synchronized,
  import_tracing12.trace.span()
], ClientServicesHost.prototype, "open", null);
_ts_decorate11([
  import_async23.synchronized,
  import_tracing12.trace.span()
], ClientServicesHost.prototype, "close", null);
ClientServicesHost = _ts_decorate11([
  import_tracing12.trace.resource()
], ClientServicesHost);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ClientRpcServer,
  ClientServicesHost,
  DataSpace,
  DataSpaceManager,
  DeviceInvitationProtocol,
  DevtoolsHostEvents,
  DevtoolsServiceImpl,
  DiagnosticsCollector,
  EdgeAgentManager,
  EdgeAgentServiceImpl,
  EdgeFeedReplicator,
  Identity,
  IdentityManager,
  IdentityServiceImpl,
  InvitationsHandler,
  InvitationsManager,
  InvitationsServiceImpl,
  Lock,
  ServiceContext,
  ServiceRegistry,
  SpaceInvitationProtocol,
  SpacesServiceImpl,
  TrustedKeySetAuthVerifier,
  createAdmissionKeypair,
  createAuthProvider,
  createCollectDiagnosticsBroadcastHandler,
  createCollectDiagnosticsBroadcastSender,
  createDiagnostics,
  createLevel,
  createStorageObjects,
  decodeProfileArchive,
  encodeProfileArchive,
  exportProfileData,
  getNetworkPeers,
  importProfileData,
  isLocked,
  subscribeToFeedBlocks,
  subscribeToFeeds,
  subscribeToNetworkStatus,
  subscribeToNetworkTopics,
  subscribeToSignal,
  subscribeToSpaces,
  subscribeToSwarmInfo
});
//# sourceMappingURL=chunk-LMGLGOUU.cjs.map
