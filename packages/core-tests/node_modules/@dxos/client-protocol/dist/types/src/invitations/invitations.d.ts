import { MulticastObservable, type Observable, type Subscriber } from '@dxos/async';
import { Invitation } from '@dxos/protocols/proto/dxos/client/services';
export declare const AUTHENTICATION_CODE_LENGTH = 6;
export declare const INVITATION_TIMEOUT: number;
export interface Invitations {
    created: MulticastObservable<CancellableInvitation[]>;
    accepted: MulticastObservable<AuthenticatingInvitation[]>;
    share(options?: Partial<Invitation>): CancellableInvitation;
    join(invitation: Invitation): AuthenticatingInvitation;
}
/**
 * Base class for all invitation observables and providers.
 */
export declare class CancellableInvitation extends MulticastObservable<Invitation> {
    private readonly _onCancel;
    constructor({ subscriber, initialInvitation, onCancel, }: {
        subscriber: Observable<Invitation> | Subscriber<Invitation>;
        initialInvitation: Invitation;
        onCancel: () => Promise<void>;
    });
    cancel(): Promise<void>;
    get expired(): boolean | undefined;
    get expiry(): Date | undefined;
}
/**
 * Cancelable observer that relays authentication requests.
 */
export declare class AuthenticatingInvitation extends CancellableInvitation {
    private readonly _onAuthenticate;
    constructor({ subscriber, initialInvitation, onCancel, onAuthenticate, }: {
        subscriber: Observable<Invitation> | Subscriber<Invitation>;
        initialInvitation: Invitation;
        onCancel: () => Promise<void>;
        onAuthenticate: (authCode: string) => Promise<void>;
    });
    authenticate(authCode: string): Promise<void>;
}
/**
 * Testing util to wrap non-authenticating observable with promise.
 * Don't use this in production code.
 * @deprecated
 */
export declare const wrapObservable: (observable: CancellableInvitation) => Promise<Invitation>;
export declare const getExpirationTime: (invitation: Partial<Invitation>) => Date | undefined;
//# sourceMappingURL=invitations.d.ts.map