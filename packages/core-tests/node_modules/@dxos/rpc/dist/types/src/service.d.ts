import { type EncodingOptions, type ServiceDescriptor, type ServiceProvider } from '@dxos/codec-protobuf';
import { RpcPeer, type RpcPeerOptions } from './rpc';
/**
 * Map of service definitions.
 */
export type ServiceBundle<Services> = {
    [Key in keyof Services]: ServiceDescriptor<Services[Key]>;
};
export type ServiceHandlers<Services> = {
    [ServiceName in keyof Services]: ServiceProvider<Services[ServiceName]>;
};
export type ServiceTypesOf<Bundle extends ServiceBundle<any>> = Bundle extends ServiceBundle<infer Services> ? Services : never;
/**
 * Groups multiple services together to be served by a single RPC peer.
 */
export declare const createServiceBundle: <Service>(services: ServiceBundle<Service>) => ServiceBundle<Service>;
/**
 * Type-safe RPC peer.
 */
export declare class ProtoRpcPeer<Service> {
    readonly rpc: Service;
    private readonly _peer;
    constructor(rpc: Service, _peer: RpcPeer);
    open(): Promise<void>;
    close(): Promise<void>;
    abort(): Promise<void>;
}
export interface ProtoRpcPeerOptions<Client, Server> extends Omit<RpcPeerOptions, 'callHandler' | 'streamHandler'> {
    /**
     * Services that are expected to be implemented by the counter-space.
     */
    requested?: ServiceBundle<Client>;
    /**
     * Services exposed to the counter-space.
     */
    exposed?: ServiceBundle<Server>;
    /**
     * Handlers for the exposed services
     */
    handlers?: ServiceHandlers<Server>;
    /**
     * Encoding options passed to the underlying proto codec.
     */
    encodingOptions?: EncodingOptions;
}
/**
 * Create type-safe RPC peer from a service bundle.
 * Can both handle and issue requests.
 */
export declare const createProtoRpcPeer: <Client = {}, Server = {}>({ requested, exposed, handlers, encodingOptions, ...rest }: ProtoRpcPeerOptions<Client, Server>) => ProtoRpcPeer<Client>;
export declare const parseMethodName: (method: string) => [serviceName: string, methodName: string];
/**
 * Create a type-safe RPC client.
 * @deprecated Use createProtoRpcPeer instead.
 */
export declare const createRpcClient: <S>(serviceDef: ServiceDescriptor<S>, options: Omit<RpcPeerOptions, "callHandler">) => ProtoRpcPeer<S>;
/**
 * @deprecated
 */
export interface RpcServerOptions<S> extends Omit<RpcPeerOptions, 'callHandler'> {
    service: ServiceDescriptor<S>;
    handlers: S;
}
/**
 * Create a type-safe RPC server.
 * @deprecated Use createProtoRpcPeer instead.
 */
export declare const createRpcServer: <S>({ service, handlers, ...rest }: RpcServerOptions<S>) => RpcPeer;
/**
 * Create type-safe RPC client from a service bundle.
 * @deprecated Use createProtoRpcPeer instead.
 */
export declare const createBundledRpcClient: <S>(descriptors: ServiceBundle<S>, options: Omit<RpcPeerOptions, "callHandler" | "streamHandler">) => ProtoRpcPeer<S>;
/**
 * @deprecated
 */
export interface RpcBundledServerOptions<S> extends Omit<RpcPeerOptions, 'callHandler'> {
    services: ServiceBundle<S>;
    handlers: S;
}
/**
 * Create type-safe RPC server from a service bundle.
 * @deprecated Use createProtoRpcPeer instead.
 */
export declare const createBundledRpcServer: <S>({ services, handlers, ...rest }: RpcBundledServerOptions<S>) => RpcPeer;
//# sourceMappingURL=service.d.ts.map