import { type Any, type Stream } from '@dxos/codec-protobuf';
import { PublicKey } from '@dxos/keys';
import { type Message as SignalMessage } from '@dxos/protocols/proto/dxos/mesh/signal';
export type SignalCallbacks = {
    onConnected?: () => void;
    /**
     * Called on disconnect.
     * In case of error, `onError` will be called first and then `onDisconnected`.
     */
    onDisconnected?: () => void;
    onError?: (error: Error) => void;
    getMetadata?: () => any;
};
export type SignalRPCClientParams = {
    url: string;
    callbacks?: SignalCallbacks;
};
/**
 * Signal RPC client.
 * TODO(mykola): Delete.
 * @deprecated
 */
export declare class SignalRPCClient {
    private readonly _socket;
    private readonly _rpc;
    private readonly _connectTrigger;
    private _keepaliveCtx?;
    private _closed;
    private readonly _url;
    private readonly _callbacks;
    private readonly _closeComplete;
    private readonly _monitor;
    constructor({ url, callbacks }: SignalRPCClientParams);
    close(): Promise<void>;
    join({ topic, peerId }: {
        topic: PublicKey;
        peerId: PublicKey;
    }): Promise<Stream<import("@dxos/protocols/proto/dxos/mesh/signal").SwarmEvent>>;
    receiveMessages(peerId: PublicKey): Promise<Stream<SignalMessage>>;
    sendMessage({ author, recipient, payload, }: {
        author: PublicKey;
        recipient: PublicKey;
        payload: Any;
    }): Promise<void>;
    private _safeCloseRpc;
}
//# sourceMappingURL=signal-rpc-client.d.ts.map