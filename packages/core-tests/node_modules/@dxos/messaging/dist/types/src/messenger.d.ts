import { type SignalManager } from './signal-manager';
import { type PeerInfo, type Message } from './signal-methods';
export type OnMessage = (params: Message) => Promise<void>;
export interface MessengerOptions {
    signalManager: SignalManager;
    retryDelay?: number;
}
/**
 * Reliable messenger that works trough signal network.
 */
export declare class Messenger {
    private readonly _monitor;
    private readonly _signalManager;
    private readonly _listeners;
    private readonly _defaultListeners;
    private readonly _onAckCallbacks;
    private readonly _receivedMessages;
    /**
     * Keys scheduled to be cleared from _receivedMessages on the next iteration.
     */
    private readonly _toClear;
    private _ctx;
    private _closed;
    private readonly _retryDelay;
    constructor({ signalManager, retryDelay }: MessengerOptions);
    open(): void;
    close(): Promise<void>;
    sendMessage({ author, recipient, payload }: Message): Promise<void>;
    /**
     * Subscribes onMessage function to messages that contains payload with payloadType.
     * @param payloadType if not specified, onMessage will be subscribed to all types of messages.
     */
    listen({ peer, payloadType, onMessage, }: {
        peer: PeerInfo;
        payloadType?: string;
        onMessage: OnMessage;
    }): Promise<ListeningHandle>;
    private _encodeAndSend;
    private _handleMessage;
    private _handleReliablePayload;
    private _handleAcknowledgement;
    private _sendAcknowledgement;
    private _callListeners;
    private _performGc;
}
export interface ListeningHandle {
    unsubscribe: () => Promise<void>;
}
//# sourceMappingURL=messenger.d.ts.map