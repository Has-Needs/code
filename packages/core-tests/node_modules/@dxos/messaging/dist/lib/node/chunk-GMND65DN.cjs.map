{
  "version": 3,
  "sources": ["../../../src/messenger.ts", "../../../src/messenger-monitor.ts", "../../../src/timeouts.ts", "../../../src/signal-client/signal-client.ts", "../../../src/signal-client/signal-client-monitor.ts", "../../../src/signal-client/signal-local-state.ts", "../../../src/signal-client/signal-rpc-client.ts", "../../../src/signal-client/signal-rpc-client-monitor.ts", "../../../src/signal-methods.ts", "../../../src/signal-manager/memory-signal-manager.ts", "../../../src/signal-manager/websocket-signal-manager.ts", "../../../src/signal-manager/websocket-signal-manager-monitor.ts", "../../../src/signal-manager/edge-signal-manager.ts", "../../../src/signal-manager/utils.ts"],
  "sourcesContent": ["//\n// Copyright 2022 DXOS.org\n//\n\nimport { TimeoutError, scheduleExponentialBackoffTaskInterval, scheduleTask, scheduleTaskInterval } from '@dxos/async';\nimport { type Any } from '@dxos/codec-protobuf';\nimport { Context } from '@dxos/context';\nimport { invariant } from '@dxos/invariant';\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { TimeoutError as ProtocolTimeoutError, trace } from '@dxos/protocols';\nimport { schema } from '@dxos/protocols/proto';\nimport { type ReliablePayload } from '@dxos/protocols/proto/dxos/mesh/messaging';\nimport { ComplexMap, ComplexSet } from '@dxos/util';\n\nimport { MessengerMonitor } from './messenger-monitor';\nimport { type SignalManager } from './signal-manager';\nimport { type PeerInfo, type Message } from './signal-methods';\nimport { MESSAGE_TIMEOUT } from './timeouts';\n\nexport type OnMessage = (params: Message) => Promise<void>;\n\nexport interface MessengerOptions {\n  signalManager: SignalManager;\n  retryDelay?: number;\n}\n\nconst ReliablePayload = schema.getCodecForType('dxos.mesh.messaging.ReliablePayload');\nconst Acknowledgement = schema.getCodecForType('dxos.mesh.messaging.Acknowledgement');\n\nconst RECEIVED_MESSAGES_GC_INTERVAL = 120_000;\n\n/**\n * Reliable messenger that works trough signal network.\n */\nexport class Messenger {\n  private readonly _monitor = new MessengerMonitor();\n  private readonly _signalManager: SignalManager;\n  // { peerId, payloadType } => listeners set\n  private readonly _listeners = new ComplexMap<{ peerId: string; payloadType: string }, Set<OnMessage>>(\n    ({ peerId, payloadType }) => peerId + payloadType,\n  );\n\n  // peerId => listeners set\n  private readonly _defaultListeners = new Map<string, Set<OnMessage>>();\n\n  private readonly _onAckCallbacks = new ComplexMap<PublicKey, () => void>(PublicKey.hash);\n\n  private readonly _receivedMessages = new ComplexSet<PublicKey>(PublicKey.hash);\n\n  /**\n   * Keys scheduled to be cleared from _receivedMessages on the next iteration.\n   */\n  private readonly _toClear = new ComplexSet<PublicKey>(PublicKey.hash);\n\n  private _ctx!: Context;\n  private _closed = true;\n  private readonly _retryDelay: number;\n\n  constructor({ signalManager, retryDelay = 1000 }: MessengerOptions) {\n    this._signalManager = signalManager;\n    this._retryDelay = retryDelay;\n\n    this.open();\n  }\n\n  open(): void {\n    if (!this._closed) {\n      return;\n    }\n    const traceId = PublicKey.random().toHex();\n    log.trace('dxos.mesh.messenger.open', trace.begin({ id: traceId }));\n    this._ctx = new Context({\n      onError: (err) => log.catch(err),\n    });\n    this._ctx.onDispose(\n      this._signalManager.onMessage.on(async (message) => {\n        log('received message', { from: message.author });\n        await this._handleMessage(message);\n      }),\n    );\n\n    // Clear the map periodically.\n    scheduleTaskInterval(\n      this._ctx,\n      async () => {\n        this._performGc();\n      },\n      RECEIVED_MESSAGES_GC_INTERVAL,\n    );\n\n    this._closed = false;\n    log.trace('dxos.mesh.messenger.open', trace.end({ id: traceId }));\n  }\n\n  async close(): Promise<void> {\n    if (this._closed) {\n      return;\n    }\n    this._closed = true;\n    await this._ctx.dispose();\n  }\n\n  async sendMessage({ author, recipient, payload }: Message): Promise<void> {\n    invariant(!this._closed, 'Closed');\n    const messageContext = this._ctx.derive();\n\n    const reliablePayload: ReliablePayload = {\n      messageId: PublicKey.random(),\n      payload,\n    };\n    invariant(!this._onAckCallbacks.has(reliablePayload.messageId!));\n    log('send message', { messageId: reliablePayload.messageId, author, recipient });\n\n    let messageReceived: () => void;\n    let timeoutHit: (err: Error) => void;\n    let sendAttempts = 0;\n\n    const promise = new Promise<void>((resolve, reject) => {\n      messageReceived = resolve;\n      timeoutHit = reject;\n    });\n\n    // Setting retry interval if signal was not acknowledged.\n    scheduleExponentialBackoffTaskInterval(\n      messageContext,\n      async () => {\n        log('retrying message', { messageId: reliablePayload.messageId });\n        sendAttempts++;\n        await this._encodeAndSend({ author, recipient, reliablePayload }).catch((err) =>\n          log('failed to send message', { err }),\n        );\n      },\n      this._retryDelay,\n    );\n\n    scheduleTask(\n      messageContext,\n      () => {\n        log('message not delivered', { messageId: reliablePayload.messageId });\n        this._onAckCallbacks.delete(reliablePayload.messageId!);\n        timeoutHit(\n          new ProtocolTimeoutError(\n            'signaling message not delivered',\n            new TimeoutError(MESSAGE_TIMEOUT, 'Message not delivered'),\n          ),\n        );\n        void messageContext.dispose();\n        this._monitor.recordReliableMessage({ sendAttempts, sent: false });\n      },\n      MESSAGE_TIMEOUT,\n    );\n\n    this._onAckCallbacks.set(reliablePayload.messageId, () => {\n      messageReceived();\n      this._onAckCallbacks.delete(reliablePayload.messageId!);\n      void messageContext.dispose();\n      this._monitor.recordReliableMessage({ sendAttempts, sent: true });\n    });\n\n    await this._encodeAndSend({ author, recipient, reliablePayload });\n    return promise;\n  }\n\n  /**\n   * Subscribes onMessage function to messages that contains payload with payloadType.\n   * @param payloadType if not specified, onMessage will be subscribed to all types of messages.\n   */\n  async listen({\n    peer,\n    payloadType,\n    onMessage,\n  }: {\n    peer: PeerInfo;\n    payloadType?: string;\n    onMessage: OnMessage;\n  }): Promise<ListeningHandle> {\n    invariant(!this._closed, 'Closed');\n\n    await this._signalManager.subscribeMessages(peer);\n    let listeners: Set<OnMessage> | undefined;\n    invariant(peer.peerKey, 'Peer key is required');\n\n    if (!payloadType) {\n      listeners = this._defaultListeners.get(peer.peerKey);\n      if (!listeners) {\n        listeners = new Set();\n        this._defaultListeners.set(peer.peerKey, listeners);\n      }\n    } else {\n      listeners = this._listeners.get({ peerId: peer.peerKey, payloadType });\n      if (!listeners) {\n        listeners = new Set();\n        this._listeners.set({ peerId: peer.peerKey, payloadType }, listeners);\n      }\n    }\n\n    listeners.add(onMessage);\n\n    return {\n      unsubscribe: async () => {\n        listeners!.delete(onMessage);\n      },\n    };\n  }\n\n  private async _encodeAndSend({\n    author,\n    recipient,\n    reliablePayload,\n  }: {\n    author: PeerInfo;\n    recipient: PeerInfo;\n    reliablePayload: ReliablePayload;\n  }): Promise<void> {\n    await this._signalManager.sendMessage({\n      author,\n      recipient,\n      payload: {\n        type_url: 'dxos.mesh.messaging.ReliablePayload',\n        value: ReliablePayload.encode(reliablePayload, { preserveAny: true }),\n      },\n    });\n  }\n\n  private async _handleMessage(message: Message): Promise<void> {\n    switch (message.payload.type_url) {\n      case 'dxos.mesh.messaging.ReliablePayload': {\n        await this._handleReliablePayload(message);\n        break;\n      }\n      case 'dxos.mesh.messaging.Acknowledgement': {\n        await this._handleAcknowledgement({ payload: message.payload });\n        break;\n      }\n    }\n  }\n\n  private async _handleReliablePayload({ author, recipient, payload }: Message): Promise<void> {\n    invariant(payload.type_url === 'dxos.mesh.messaging.ReliablePayload');\n    const reliablePayload: ReliablePayload = ReliablePayload.decode(payload.value, { preserveAny: true });\n\n    log('handling message', { messageId: reliablePayload.messageId });\n\n    try {\n      await this._sendAcknowledgement({\n        author,\n        recipient,\n        messageId: reliablePayload.messageId,\n      });\n    } catch (err) {\n      this._monitor.recordMessageAckFailed();\n      throw err;\n    }\n\n    // Ignore message if it was already received, i.e. from multiple signal servers.\n    if (this._receivedMessages.has(reliablePayload.messageId!)) {\n      return;\n    }\n\n    this._receivedMessages.add(reliablePayload.messageId!);\n\n    await this._callListeners({\n      author,\n      recipient,\n      payload: reliablePayload.payload,\n    });\n  }\n\n  private async _handleAcknowledgement({ payload }: { payload: Any }): Promise<void> {\n    invariant(payload.type_url === 'dxos.mesh.messaging.Acknowledgement');\n    this._onAckCallbacks.get(Acknowledgement.decode(payload.value).messageId)?.();\n  }\n\n  private async _sendAcknowledgement({\n    author,\n    recipient,\n    messageId,\n  }: {\n    author: PeerInfo;\n    recipient: PeerInfo;\n    messageId: PublicKey;\n  }): Promise<void> {\n    log('sending ACK', { messageId, from: recipient, to: author });\n\n    await this._signalManager.sendMessage({\n      author: recipient,\n      recipient: author,\n      payload: {\n        type_url: 'dxos.mesh.messaging.Acknowledgement',\n        value: Acknowledgement.encode({ messageId }),\n      },\n    });\n  }\n\n  private async _callListeners(message: Message): Promise<void> {\n    {\n      invariant(message.recipient.peerKey, 'Peer key is required');\n      const defaultListenerMap = this._defaultListeners.get(message.recipient.peerKey);\n      if (defaultListenerMap) {\n        for (const listener of defaultListenerMap) {\n          await listener(message);\n        }\n      }\n    }\n\n    {\n      const listenerMap = this._listeners.get({\n        peerId: message.recipient.peerKey,\n        payloadType: message.payload.type_url,\n      });\n      if (listenerMap) {\n        for (const listener of listenerMap) {\n          await listener(message);\n        }\n      }\n    }\n  }\n\n  private _performGc(): void {\n    const start = performance.now();\n\n    for (const key of this._toClear.keys()) {\n      this._receivedMessages.delete(key);\n    }\n    this._toClear.clear();\n    for (const key of this._receivedMessages.keys()) {\n      this._toClear.add(key);\n    }\n\n    const elapsed = performance.now() - start;\n    if (elapsed > 100) {\n      log.warn('GC took too long', { elapsed });\n    }\n  }\n}\n\nexport interface ListeningHandle {\n  unsubscribe: () => Promise<void>;\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { trace } from '@dxos/tracing';\n\nexport class MessengerMonitor {\n  public recordMessageAckFailed(): void {\n    trace.metrics.increment('dxos.mesh.signal.messenger.failed-ack', 1);\n  }\n\n  public recordReliableMessage(params: { sendAttempts: number; sent: boolean }): void {\n    trace.metrics.increment('dxos.mesh.signal.messenger.reliable-send', 1, {\n      tags: {\n        success: params.sent,\n        attempts: params.sendAttempts,\n      },\n    });\n  }\n}\n", "//\n// Copyright 2023 DXOS.org\n//\n\n/**\n * Timeout for retrying messages.\n */\nexport const MESSAGE_TIMEOUT = 10_000;\n", "//\n// Copyright 2020 DXOS.org\n//\n\nimport { DeferredTask, Event, Trigger, scheduleTask, scheduleTaskInterval, sleep } from '@dxos/async';\nimport { type Context, cancelWithContext, Resource } from '@dxos/context';\nimport { invariant } from '@dxos/invariant';\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { trace } from '@dxos/protocols';\nimport { type SwarmResponse } from '@dxos/protocols/proto/dxos/edge/messenger';\nimport { type QueryRequest, type JoinRequest, type LeaveRequest } from '@dxos/protocols/proto/dxos/edge/signal';\nimport { SignalState } from '@dxos/protocols/proto/dxos/mesh/signal';\n\nimport { SignalClientMonitor } from './signal-client-monitor';\nimport { SignalLocalState } from './signal-local-state';\nimport { SignalRPCClient } from './signal-rpc-client';\nimport {\n  type PeerInfo,\n  type Message,\n  type SignalClientMethods,\n  type SignalStatus,\n  type SwarmEvent,\n} from '../signal-methods';\n\nconst DEFAULT_RECONNECT_TIMEOUT = 100;\nconst MAX_RECONNECT_TIMEOUT = 5_000;\nconst ERROR_RECONCILE_DELAY = 1_000;\nconst RECONCILE_INTERVAL = 5_000;\n\n/**\n * KUBE-specific signaling client.\n * Establishes a websocket connection to signal server and provides RPC methods.\n * Subscription state updates are executed immediately against the local state which\n * is reconciled periodically.\n * TODO(mykola): Delete.\n * @deprecated\n */\n// TODO(burdon): Rename impl.\nexport class SignalClient extends Resource implements SignalClientMethods {\n  private readonly _monitor = new SignalClientMonitor();\n\n  private _state = SignalState.CLOSED;\n  private _lastError?: Error;\n  private _lastReconciliationFailed = false;\n\n  private readonly _clientReady = new Trigger();\n  private _connectionCtx?: Context;\n  private _client?: SignalRPCClient;\n\n  private _reconcileTask?: DeferredTask;\n  private _reconnectTask?: DeferredTask;\n\n  /**\n   * Number of milliseconds after which the connection will be attempted again in case of error.\n   */\n  private _reconnectAfter = DEFAULT_RECONNECT_TIMEOUT;\n\n  private readonly _instanceId = PublicKey.random().toHex();\n\n  /**\n   * @internal\n   */\n  readonly localState: SignalLocalState;\n\n  readonly statusChanged = new Event<SignalStatus>();\n\n  public readonly onMessage = new Event<Message>();\n  public readonly swarmEvent = new Event<SwarmEvent>();\n\n  /**\n   * @param _host Signal server websocket URL.\n   * @param onMessage called when a new message is received.\n   * @param onSwarmEvent called when a new swarm event is received.\n   * @param _getMetadata signal-message metadata provider, called for every message.\n   */\n  constructor(\n    private readonly _host: string,\n    private readonly _getMetadata?: () => any,\n  ) {\n    super();\n    if (!this._host.startsWith('wss://') && !this._host.startsWith('ws://')) {\n      throw new Error(`Signal server requires a websocket URL. Provided: ${this._host}`);\n    }\n\n    this.localState = new SignalLocalState(\n      async (message) => {\n        this._monitor.recordMessageReceived(message);\n        this.onMessage.emit(message);\n      },\n      async (event) => this.swarmEvent.emit(event),\n    );\n  }\n\n  protected override async _open(): Promise<void> {\n    log.trace('dxos.mesh.signal-client.open', trace.begin({ id: this._instanceId }));\n\n    if ([SignalState.CONNECTED, SignalState.CONNECTING].includes(this._state)) {\n      return;\n    }\n    this._setState(SignalState.CONNECTING);\n\n    this._reconcileTask = new DeferredTask(this._ctx, async () => {\n      try {\n        await cancelWithContext(this._connectionCtx!, this._clientReady.wait({ timeout: 5_000 }));\n        invariant(this._state === SignalState.CONNECTED, 'Not connected to Signal Server');\n        await this.localState.reconcile(this._connectionCtx!, this._client!);\n        this._monitor.recordReconciliation({ success: true });\n        this._lastReconciliationFailed = false;\n      } catch (err) {\n        this._lastReconciliationFailed = true;\n        this._monitor.recordReconciliation({ success: false });\n        throw err;\n      }\n    });\n\n    // Reconcile subscriptions periodically.\n    scheduleTaskInterval(\n      this._ctx,\n      async () => {\n        if (this._state === SignalState.CONNECTED) {\n          this._reconcileTask!.schedule();\n        }\n      },\n      RECONCILE_INTERVAL,\n    );\n\n    this._reconnectTask = new DeferredTask(this._ctx, async () => {\n      try {\n        await this._reconnect();\n        this._monitor.recordReconnect({ success: true });\n      } catch (err) {\n        this._monitor.recordReconnect({ success: false });\n        throw err;\n      }\n    });\n\n    this._createClient();\n    log.trace('dxos.mesh.signal-client.open', trace.end({ id: this._instanceId }));\n  }\n\n  protected override async _catch(err: Error): Promise<void> {\n    if (this._state === SignalState.CLOSED || this._ctx.disposed) {\n      return;\n    }\n    // Don't log consecutive reconciliation failures.\n    if (this._state === SignalState.CONNECTED && !this._lastReconciliationFailed) {\n      log.warn('SignalClient error:', err);\n    }\n    this._scheduleReconcileAfterError();\n  }\n\n  protected override async _close(): Promise<void> {\n    log('closing...');\n    if ([SignalState.CLOSED].includes(this._state)) {\n      return;\n    }\n\n    this._setState(SignalState.CLOSED);\n    await this._safeResetClient();\n\n    log('closed');\n  }\n\n  getStatus(): SignalStatus {\n    return {\n      host: this._host,\n      state: this._state,\n      error: this._lastError?.message,\n      reconnectIn: this._reconnectAfter,\n      ...this._monitor.getRecordedTimestamps(),\n    };\n  }\n\n  async join(args: JoinRequest): Promise<void> {\n    log('joining', { topic: args.topic, peerId: args.peer.peerKey });\n    this._monitor.recordJoin();\n    this.localState.join({ topic: args.topic, peerId: PublicKey.from(args.peer.peerKey) });\n    this._reconcileTask?.schedule();\n  }\n\n  async leave(args: LeaveRequest): Promise<void> {\n    log('leaving', { topic: args.topic, peerId: args.peer.peerKey });\n    this._monitor.recordLeave();\n    this.localState.leave({ topic: args.topic, peerId: PublicKey.from(args.peer.peerKey) });\n  }\n\n  async query(params: QueryRequest): Promise<SwarmResponse> {\n    throw new Error('Not implemented');\n  }\n\n  async sendMessage(msg: Message): Promise<void> {\n    return this._monitor.recordMessageSending(msg, async () => {\n      await this._clientReady.wait();\n      invariant(this._state === SignalState.CONNECTED, 'Not connected to Signal Server');\n      invariant(msg.author.peerKey, 'Author key required');\n      invariant(msg.recipient.peerKey, 'Recipient key required');\n      await this._client!.sendMessage({\n        author: PublicKey.from(msg.author.peerKey),\n        recipient: PublicKey.from(msg.recipient.peerKey),\n        payload: msg.payload,\n      });\n    });\n  }\n\n  async subscribeMessages(peer: PeerInfo): Promise<void> {\n    invariant(peer.peerKey, 'Peer key required');\n    log('subscribing to messages', { peer });\n    this.localState.subscribeMessages(PublicKey.from(peer.peerKey));\n    this._reconcileTask?.schedule();\n  }\n\n  async unsubscribeMessages(peer: PeerInfo): Promise<void> {\n    invariant(peer.peerKey, 'Peer key required');\n    log('unsubscribing from messages', { peer });\n    this.localState.unsubscribeMessages(PublicKey.from(peer.peerKey));\n  }\n\n  private _scheduleReconcileAfterError(): void {\n    scheduleTask(this._ctx, () => this._reconcileTask!.schedule(), ERROR_RECONCILE_DELAY);\n  }\n\n  private _createClient(): void {\n    log('creating client', { host: this._host, state: this._state });\n    invariant(!this._client, 'Client already created');\n\n    this._monitor.recordConnectionStartTime();\n\n    // Create new context for each connection.\n    this._connectionCtx = this._ctx.derive();\n    this._connectionCtx.onDispose(async () => {\n      log('connection context disposed');\n      const { failureCount } = await this.localState.safeCloseStreams();\n      this._monitor.recordStreamCloseErrors(failureCount);\n    });\n\n    try {\n      const client = new SignalRPCClient({\n        url: this._host,\n        callbacks: {\n          onConnected: () => {\n            if (client === this._client) {\n              log('socket connected');\n              this._onConnected();\n            }\n          },\n\n          onDisconnected: () => {\n            if (client !== this._client) {\n              return;\n            }\n            log('socket disconnected', { state: this._state });\n            if (this._state === SignalState.ERROR) {\n              // Ignore disconnects after error.\n              // Handled by error handler before disconnect handler.\n              this._setState(SignalState.DISCONNECTED);\n            } else {\n              this._onDisconnected();\n            }\n          },\n\n          onError: (error) => {\n            if (client === this._client) {\n              log('socket error', { error, state: this._state });\n              this._onDisconnected({ error });\n            }\n          },\n          getMetadata: this._getMetadata,\n        },\n      });\n      this._client = client;\n    } catch (error: any) {\n      this._client = undefined;\n      this._onDisconnected({ error });\n    }\n  }\n\n  private async _reconnect(): Promise<void> {\n    log(`reconnecting in ${this._reconnectAfter}ms`, { state: this._state });\n\n    if (this._state === SignalState.RECONNECTING) {\n      log.info('Signal api already reconnecting.');\n      return;\n    }\n    if (this._state === SignalState.CLOSED) {\n      return;\n    }\n    this._setState(SignalState.RECONNECTING);\n\n    await this._safeResetClient();\n\n    await cancelWithContext(this._ctx!, sleep(this._reconnectAfter));\n\n    this._createClient();\n  }\n\n  private _onConnected(): void {\n    this._lastError = undefined;\n    this._lastReconciliationFailed = false;\n    this._reconnectAfter = DEFAULT_RECONNECT_TIMEOUT;\n    this._setState(SignalState.CONNECTED);\n    this._clientReady.wake();\n    this._reconcileTask!.schedule();\n  }\n\n  private _onDisconnected(options?: { error: Error }): void {\n    this._updateReconnectTimeout();\n    if (this._state === SignalState.CLOSED) {\n      return;\n    }\n    if (options?.error) {\n      this._lastError = options.error;\n      this._setState(SignalState.ERROR);\n    } else {\n      this._setState(SignalState.DISCONNECTED);\n    }\n    this._reconnectTask!.schedule();\n  }\n\n  private _setState(newState: SignalState): void {\n    this._state = newState;\n    this._monitor.recordStateChangeTime();\n    log('signal state changed', { status: this.getStatus() });\n    this.statusChanged.emit(this.getStatus());\n  }\n\n  private _updateReconnectTimeout(): void {\n    if (this._state !== SignalState.CONNECTED && this._state !== SignalState.CONNECTING) {\n      this._reconnectAfter *= 2;\n      this._reconnectAfter = Math.min(this._reconnectAfter, MAX_RECONNECT_TIMEOUT);\n    }\n  }\n\n  private async _safeResetClient(): Promise<void> {\n    await this._connectionCtx?.dispose();\n    this._connectionCtx = undefined;\n\n    this._clientReady.reset();\n    await this._client?.close().catch(() => {});\n    this._client = undefined;\n  }\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { trace } from '@dxos/tracing';\n\nimport type { Message } from '../signal-methods';\n\nexport class SignalClientMonitor {\n  private readonly _performance = {\n    sentMessages: 0,\n    receivedMessages: 0,\n    reconnectCounter: 0,\n    joinCounter: 0,\n    leaveCounter: 0,\n  };\n\n  /**\n   * Timestamp of when the connection attempt was began.\n   */\n  private _connectionStarted = new Date();\n  /**\n   * Timestamp of last state change.\n   */\n  private _lastStateChange = new Date();\n\n  public getRecordedTimestamps(): { connectionStarted: Date; lastStateChange: Date } {\n    return {\n      connectionStarted: this._connectionStarted,\n      lastStateChange: this._lastStateChange,\n    };\n  }\n\n  public recordStateChangeTime(): void {\n    this._lastStateChange = new Date();\n  }\n\n  public recordConnectionStartTime(): void {\n    this._connectionStarted = new Date();\n  }\n\n  public recordReconnect(params: { success: boolean }): void {\n    this._performance.reconnectCounter++;\n    trace.metrics.increment('dxos.mesh.signal.signal-client.reconnect', 1, {\n      tags: {\n        success: params.success,\n      },\n    });\n  }\n\n  public recordJoin(): void {\n    this._performance.joinCounter++;\n  }\n\n  public recordLeave(): void {\n    this._performance.leaveCounter++;\n  }\n\n  public recordMessageReceived(message: Message): void {\n    this._performance.receivedMessages++;\n    trace.metrics.increment('dxos.mesh.signal.signal-client.received-total', 1, {\n      tags: createIdentityTags(message),\n    });\n    trace.metrics.distribution('dxos.mesh.signal.signal-client.bytes-in', getByteCount(message), {\n      tags: createIdentityTags(message),\n    });\n  }\n\n  public async recordMessageSending(message: Message, sendMessage: () => Promise<void>): Promise<void> {\n    this._performance.sentMessages++;\n    const tags = createIdentityTags(message);\n    let success = true;\n    try {\n      const reqStart = Date.now();\n      await sendMessage();\n      const reqDuration = Date.now() - reqStart;\n      trace.metrics.distribution('dxos.mesh.signal.signal-client.send-duration', reqDuration, { tags });\n      trace.metrics.distribution('dxos.mesh.signal.signal-client.bytes-out', getByteCount(message), { tags });\n    } catch (err) {\n      success = false;\n    }\n    trace.metrics.increment('dxos.mesh.signal.signal-client.sent-total', 1, {\n      tags: { ...tags, success },\n    });\n  }\n\n  public recordStreamCloseErrors(count: number): void {\n    trace.metrics.increment('dxos.mesh.signal.signal-client.stream-close-errors', count);\n  }\n\n  public recordReconciliation(params: { success: boolean }): void {\n    trace.metrics.increment('dxos.mesh.signal.signal-client.reconciliation', 1, {\n      tags: {\n        success: params.success,\n      },\n    });\n  }\n}\n\nconst getByteCount = (message: Message): number => {\n  return (\n    message.author.peerKey.length +\n    message.recipient.peerKey.length +\n    message.payload.type_url.length +\n    message.payload.value.length\n  );\n};\n\nconst createIdentityTags = (message: Message) => {\n  return { peer: message.author.peerKey };\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { asyncTimeout, Event } from '@dxos/async';\nimport type { Stream } from '@dxos/codec-protobuf/stream';\nimport { cancelWithContext, type Context } from '@dxos/context';\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport {\n  type Message as SignalMessage,\n  type SwarmEvent as SwarmEventProto,\n} from '@dxos/protocols/proto/dxos/mesh/signal';\nimport { ComplexMap, ComplexSet, safeAwaitAll } from '@dxos/util';\n\nimport { type SignalRPCClient } from './signal-rpc-client';\nimport type { Message, SwarmEvent } from '../signal-methods';\n\nexport class SignalLocalState {\n  /**\n   * Swarm events streams. Keys represent actually joined topic and peerId.\n   */\n  private readonly _swarmStreams = new ComplexMap<{ topic: PublicKey; peerId: PublicKey }, Stream<SwarmEventProto>>(\n    ({ topic, peerId }) => topic.toHex() + peerId.toHex(),\n  );\n\n  /**\n   * Represent desired joined topic and peerId.\n   */\n  private readonly _joinedTopics = new ComplexSet<{ topic: PublicKey; peerId: PublicKey }>(\n    ({ topic, peerId }) => topic.toHex() + peerId.toHex(),\n  );\n\n  /**\n   * Represent desired message subscriptions.\n   */\n  private readonly _subscribedMessages = new ComplexSet<{ peerId: PublicKey }>(({ peerId }) => peerId.toHex());\n\n  /**\n   * Message streams. Keys represents actually subscribed peers.\n   * @internal\n   */\n  readonly messageStreams = new ComplexMap<PublicKey, Stream<SignalMessage>>((key) => key.toHex());\n\n  /**\n   * Event to use in tests to wait till subscription is successfully established.\n   * @internal\n   */\n  readonly reconciled = new Event();\n\n  constructor(\n    private readonly _onMessage: (params: Message) => Promise<void>,\n    private readonly _onSwarmEvent: (params: SwarmEvent) => Promise<void>,\n  ) {}\n\n  async safeCloseStreams(): Promise<{ failureCount: number }> {\n    const streams = ([...this._swarmStreams.values()] as Stream<any>[]).concat([...this.messageStreams.values()]);\n    this._swarmStreams.clear();\n    this.messageStreams.clear();\n    const failureCount = (await safeAwaitAll(streams, (s) => s.close())).length;\n    return { failureCount };\n  }\n\n  join({ topic, peerId }: { topic: PublicKey; peerId: PublicKey }): void {\n    this._joinedTopics.add({ topic, peerId });\n  }\n\n  leave({ topic, peerId }: { topic: PublicKey; peerId: PublicKey }): void {\n    void this._swarmStreams.get({ topic, peerId })?.close();\n    this._swarmStreams.delete({ topic, peerId });\n    this._joinedTopics.delete({ topic, peerId });\n  }\n\n  subscribeMessages(peerId: PublicKey): void {\n    this._subscribedMessages.add({ peerId });\n  }\n\n  unsubscribeMessages(peerId: PublicKey): void {\n    log('unsubscribing from messages', { peerId });\n    this._subscribedMessages.delete({ peerId });\n    void this.messageStreams.get(peerId)?.close();\n    this.messageStreams.delete(peerId);\n  }\n\n  public async reconcile(ctx: Context, client: SignalRPCClient): Promise<void> {\n    await this._reconcileSwarmSubscriptions(ctx, client);\n    await this._reconcileMessageSubscriptions(ctx, client);\n    this.reconciled.emit();\n  }\n\n  private async _reconcileSwarmSubscriptions(ctx: Context, client: SignalRPCClient): Promise<void> {\n    // Unsubscribe from topics that are no longer needed.\n    for (const { topic, peerId } of this._swarmStreams.keys()) {\n      // Join desired topics.\n      if (this._joinedTopics.has({ topic, peerId })) {\n        continue;\n      }\n\n      void this._swarmStreams.get({ topic, peerId })?.close();\n      this._swarmStreams.delete({ topic, peerId });\n    }\n\n    // Subscribe to topics that are needed.\n    for (const { topic, peerId } of this._joinedTopics.values()) {\n      // Join desired topics.\n      if (this._swarmStreams.has({ topic, peerId })) {\n        continue;\n      }\n\n      const swarmStream = await asyncTimeout(cancelWithContext(ctx, client.join({ topic, peerId })), 5_000);\n      // Subscribing to swarm events.\n      // TODO(mykola): What happens when the swarm stream is closed? Maybe send leave event for each peer?\n      swarmStream.subscribe(async (swarmEvent: SwarmEventProto) => {\n        if (this._joinedTopics.has({ topic, peerId })) {\n          log('swarm event', { swarmEvent });\n          const event: SwarmEvent = swarmEvent.peerAvailable\n            ? {\n                topic,\n                peerAvailable: {\n                  ...swarmEvent.peerAvailable,\n                  peer: { peerKey: PublicKey.from(swarmEvent.peerAvailable.peer).toHex() },\n                },\n              }\n            : {\n                topic,\n                peerLeft: {\n                  ...swarmEvent.peerLeft,\n                  peer: { peerKey: PublicKey.from(swarmEvent.peerLeft!.peer).toHex() },\n                },\n              };\n          await this._onSwarmEvent(event);\n        }\n      });\n\n      // Saving swarm stream.\n      this._swarmStreams.set({ topic, peerId }, swarmStream);\n    }\n  }\n\n  private async _reconcileMessageSubscriptions(ctx: Context, client: SignalRPCClient): Promise<void> {\n    // Unsubscribe from messages that are no longer needed.\n    for (const peerId of this.messageStreams.keys()) {\n      // Join desired topics.\n      if (this._subscribedMessages.has({ peerId })) {\n        continue;\n      }\n\n      void this.messageStreams.get(peerId)?.close();\n      this.messageStreams.delete(peerId);\n    }\n\n    // Subscribe to messages that are needed.\n    for (const { peerId } of this._subscribedMessages.values()) {\n      if (this.messageStreams.has(peerId)) {\n        continue;\n      }\n\n      const messageStream = await asyncTimeout(cancelWithContext(ctx, client.receiveMessages(peerId)), 5_000);\n      messageStream.subscribe(async (signalMessage: SignalMessage) => {\n        if (this._subscribedMessages.has({ peerId })) {\n          const message: Message = {\n            author: { peerKey: PublicKey.from(signalMessage.author).toHex() },\n            recipient: { peerKey: PublicKey.from(signalMessage.recipient).toHex() },\n            payload: signalMessage.payload,\n          };\n          await this._onMessage(message);\n        }\n      });\n\n      // Saving message stream.\n      this.messageStreams.set(peerId, messageStream);\n    }\n  }\n}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport WebSocket from 'isomorphic-ws';\n\nimport { scheduleTaskInterval, TimeoutError, Trigger } from '@dxos/async';\nimport { type Any, type Stream } from '@dxos/codec-protobuf';\nimport { Context } from '@dxos/context';\nimport { invariant } from '@dxos/invariant';\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { trace } from '@dxos/protocols';\nimport { schema } from '@dxos/protocols/proto';\nimport { type Message as SignalMessage, type Signal } from '@dxos/protocols/proto/dxos/mesh/signal';\nimport { createProtoRpcPeer, type ProtoRpcPeer } from '@dxos/rpc';\n\nimport { SignalRpcClientMonitor } from './signal-rpc-client-monitor';\n\nconst SIGNAL_KEEPALIVE_INTERVAL = 10000;\n\ninterface Services {\n  Signal: Signal;\n}\n\nexport type SignalCallbacks = {\n  onConnected?: () => void;\n\n  /**\n   * Called on disconnect.\n   * In case of error, `onError` will be called first and then `onDisconnected`.\n   */\n  onDisconnected?: () => void;\n\n  onError?: (error: Error) => void;\n  getMetadata?: () => any;\n};\n\nexport type SignalRPCClientParams = {\n  url: string;\n  callbacks?: SignalCallbacks;\n};\n\n/**\n * Signal RPC client.\n * TODO(mykola): Delete.\n * @deprecated\n */\nexport class SignalRPCClient {\n  private readonly _socket: WebSocket;\n  private readonly _rpc: ProtoRpcPeer<Services>;\n  private readonly _connectTrigger = new Trigger();\n\n  private _keepaliveCtx?: Context;\n\n  private _closed = false;\n\n  private readonly _url: string;\n  private readonly _callbacks: SignalCallbacks;\n  private readonly _closeComplete = new Trigger();\n\n  private readonly _monitor = new SignalRpcClientMonitor();\n\n  constructor({ url, callbacks = {} }: SignalRPCClientParams) {\n    const traceId = PublicKey.random().toHex();\n    log.trace('dxos.mesh.signal-rpc-client.constructor', trace.begin({ id: traceId }));\n    this._url = url;\n    this._callbacks = callbacks;\n    this._socket = new WebSocket(this._url);\n\n    this._rpc = createProtoRpcPeer({\n      requested: {\n        Signal: schema.getService('dxos.mesh.signal.Signal'),\n      },\n      noHandshake: true,\n      port: {\n        send: (msg) => {\n          if (this._closed) {\n            // Do not send messages after close.\n            return;\n          }\n          try {\n            this._socket!.send(msg);\n          } catch (err) {\n            log.warn('send error', err);\n          }\n        },\n        subscribe: (cb) => {\n          this._socket!.onmessage = async (msg: WebSocket.MessageEvent) => {\n            if (typeof Blob !== 'undefined' && msg.data instanceof Blob) {\n              cb(Buffer.from(await msg.data.arrayBuffer()));\n            } else {\n              cb(msg.data as any);\n            }\n          };\n        },\n      },\n      encodingOptions: {\n        preserveAny: true,\n      },\n    });\n\n    this._socket.onopen = async () => {\n      try {\n        await this._rpc!.open();\n        if (this._closed) {\n          await this._safeCloseRpc();\n          return;\n        }\n        log(`RPC open ${this._url}`);\n        this._callbacks.onConnected?.();\n        this._connectTrigger.wake();\n        this._keepaliveCtx = new Context();\n        scheduleTaskInterval(\n          this._keepaliveCtx,\n          async () => {\n            // TODO(nf): use RFC6455 ping/pong once implemented in the browser?\n            // TODO(nf): check for pong response from server (once implemented)\n            // Current implementation of signal server ignores all text data messages, and does not send a response.\n            // However this is enough to detect breakages in the connection as TCP will reset the connection if ACKs are not received.\n            this._socket?.send('__ping__');\n          },\n          SIGNAL_KEEPALIVE_INTERVAL,\n        );\n      } catch (err: any) {\n        this._callbacks.onError?.(err);\n        this._socket.close();\n        this._closed = true;\n      }\n    };\n\n    this._socket.onclose = async () => {\n      log(`Disconnected ${this._url}`);\n      this._callbacks.onDisconnected?.();\n      this._closeComplete.wake();\n      await this.close();\n    };\n\n    this._socket.onerror = async (event: WebSocket.ErrorEvent) => {\n      if (this._closed) {\n        this._socket.close();\n        return;\n      }\n      this._closed = true;\n\n      this._callbacks.onError?.(event.error ?? new Error(event.message));\n      await this._safeCloseRpc();\n\n      log.warn(`Socket ${event.type ?? 'unknown'} error`, { message: event.message, url: this._url });\n    };\n\n    log.trace('dxos.mesh.signal-rpc-client.constructor', trace.end({ id: traceId }));\n  }\n\n  async close(): Promise<void> {\n    if (this._closed) {\n      return;\n    }\n    this._closed = true;\n\n    await this._keepaliveCtx?.dispose();\n    try {\n      await this._safeCloseRpc();\n\n      if (this._socket.readyState === WebSocket.OPEN || this._socket.readyState === WebSocket.CONNECTING) {\n        // close() only starts the closing handshake.\n        this._socket.close();\n      }\n\n      await this._closeComplete.wait({ timeout: 1_000 });\n    } catch (err) {\n      const failureReason = err instanceof TimeoutError ? 'timeout' : err?.constructor?.name ?? 'unknown';\n      this._monitor.recordClientCloseFailure({ failureReason });\n    }\n  }\n\n  async join({ topic, peerId }: { topic: PublicKey; peerId: PublicKey }) {\n    log('join', { topic, peerId, metadata: this._callbacks?.getMetadata?.() });\n    invariant(!this._closed, 'SignalRPCClient is closed');\n    await this._connectTrigger.wait();\n    const swarmStream = this._rpc.rpc.Signal.join({\n      swarm: topic.asUint8Array(),\n      peer: peerId.asUint8Array(),\n      metadata: this._callbacks?.getMetadata?.(),\n    });\n    await swarmStream.waitUntilReady();\n    return swarmStream;\n  }\n\n  async receiveMessages(peerId: PublicKey): Promise<Stream<SignalMessage>> {\n    log('receiveMessages', { peerId });\n    invariant(!this._closed, 'SignalRPCClient is closed');\n    await this._connectTrigger.wait();\n    const messageStream = this._rpc.rpc.Signal.receiveMessages({\n      peer: peerId.asUint8Array(),\n    });\n    await messageStream.waitUntilReady();\n    return messageStream;\n  }\n\n  async sendMessage({\n    author,\n    recipient,\n    payload,\n  }: {\n    author: PublicKey;\n    recipient: PublicKey;\n    payload: Any;\n  }): Promise<void> {\n    log('sendMessage', { author, recipient, payload, metadata: this._callbacks?.getMetadata?.() });\n    invariant(!this._closed, 'SignalRPCClient is closed');\n    await this._connectTrigger.wait();\n    await this._rpc.rpc.Signal.sendMessage({\n      author: author.asUint8Array(),\n      recipient: recipient.asUint8Array(),\n      payload,\n      metadata: this._callbacks?.getMetadata?.(),\n    });\n  }\n\n  private async _safeCloseRpc(): Promise<void> {\n    try {\n      this._connectTrigger.reset();\n      await this._rpc.close();\n    } catch (err) {\n      log.catch(err);\n    }\n  }\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { trace } from '@dxos/tracing';\n\nexport class SignalRpcClientMonitor {\n  public recordClientCloseFailure(params: { failureReason: string }): void {\n    trace.metrics.increment('dxos.mesh.signal.signal-rpc-client.close-failure', 1, {\n      tags: {\n        reason: params.failureReason,\n      },\n    });\n  }\n}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { type Event } from '@dxos/async';\nimport { type Lifecycle } from '@dxos/context';\nimport { type SwarmResponse, type Peer } from '@dxos/protocols/proto/dxos/edge/messenger';\nimport {\n  type LeaveRequest,\n  type Message,\n  type SwarmEvent,\n  type JoinRequest,\n  type QueryRequest,\n} from '@dxos/protocols/proto/dxos/edge/signal';\nimport { type SignalState } from '@dxos/protocols/proto/dxos/mesh/signal';\n\nexport type { Message, SwarmEvent };\nexport type PeerInfo = Peer;\nexport const PeerInfoHash = ({ peerKey }: PeerInfo) => peerKey;\n\nexport type SignalStatus = {\n  host: string;\n  state: SignalState;\n  error?: string;\n  reconnectIn: number;\n  connectionStarted: Date;\n  lastStateChange: Date;\n};\n\n/**\n * Message routing interface.\n */\nexport interface SignalMethods {\n  /**\n   * Emits when other peers join or leave the swarm.\n   * @deprecated\n   * TODO(mykola): Use swarmState in network-manager instead.\n   */\n  swarmEvent: Event<SwarmEvent>;\n\n  /**\n   * Emits when a message is received.\n   */\n  onMessage: Event<Message>;\n\n  /**\n   * Emits when the swarm state changes.\n   */\n  swarmState?: Event<SwarmResponse>;\n\n  /**\n   * Join topic on signal network, to be discoverable by other peers.\n   */\n  join: (params: JoinRequest) => Promise<void>;\n\n  /**\n   * Leave topic on signal network, to stop being discoverable by other peers.\n   */\n  leave: (params: LeaveRequest) => Promise<void>;\n\n  /**\n   * Query peers in the swarm without joining it.\n   */\n  query: (params: QueryRequest) => Promise<SwarmResponse>;\n\n  /**\n   * Send message to peer.\n   */\n  sendMessage: (message: Message) => Promise<void>;\n\n  /**\n   * Start receiving messages from peer.\n   * @deprecated\n   */\n  // TODO(burdon): Return unsubscribe function. Encapsulate callback/routing here.\n  subscribeMessages: (peer: PeerInfo) => Promise<void>;\n\n  /**\n   * Stop receiving messages from peer.\n   * @deprecated\n   */\n  unsubscribeMessages: (peer: PeerInfo) => Promise<void>;\n}\n\n/**\n * Signaling client.\n * TODO(mykola): Delete.\n * @deprecated\n */\nexport interface SignalClientMethods extends SignalMethods, Required<Lifecycle> {\n  getStatus(): SignalStatus;\n}\n", "//\n// Copyright 2020 DXOS.org\n//\n\nimport { Event, Trigger } from '@dxos/async';\nimport { type Any } from '@dxos/codec-protobuf';\nimport { Context } from '@dxos/context';\nimport { invariant } from '@dxos/invariant';\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { schema } from '@dxos/protocols/proto';\nimport { type SwarmResponse } from '@dxos/protocols/proto/dxos/edge/messenger';\nimport { type QueryRequest } from '@dxos/protocols/proto/dxos/edge/signal';\nimport { ComplexMap, ComplexSet } from '@dxos/util';\n\nimport { type SignalManager } from './signal-manager';\nimport { type SwarmEvent, type PeerInfo, type SignalStatus, type Message, PeerInfoHash } from '../signal-methods';\n\n/**\n * Common signaling context that connects multiple MemorySignalManager instances.\n */\nexport class MemorySignalManagerContext {\n  // Swarm messages.\n  readonly swarmEvent = new Event<SwarmEvent>();\n\n  // Mapping from topic to set of peers.\n  readonly swarms = new ComplexMap<PublicKey, ComplexSet<PeerInfo>>(PublicKey.hash);\n\n  // Map of connections for each peer for signaling.\n  readonly connections = new ComplexMap<PeerInfo, MemorySignalManager>(PeerInfoHash);\n}\n\n/**\n * In memory signal manager for testing.\n */\nexport class MemorySignalManager implements SignalManager {\n  readonly statusChanged = new Event<SignalStatus[]>();\n  readonly swarmEvent = new Event<SwarmEvent>();\n\n  readonly onMessage = new Event<Message>();\n\n  /**  Will be used to emit SwarmEvents on .open() and .close() */\n  private _joinedSwarms = new ComplexSet<{ topic: PublicKey; peer: PeerInfo }>(\n    ({ topic, peer }) => topic.toHex() + peer.peerKey,\n  );\n\n  private _ctx!: Context;\n\n  // TODO(dmaretskyi): Replace with callback.\n  private readonly _freezeTrigger = new Trigger().wake();\n\n  constructor(private readonly _context: MemorySignalManagerContext) {\n    this._ctx = new Context();\n\n    this._ctx.onDispose(this._context.swarmEvent.on((data) => this.swarmEvent.emit(data)));\n  }\n\n  async open(): Promise<void> {\n    if (!this._ctx.disposed) {\n      return;\n    }\n    this._ctx = new Context();\n    this._ctx.onDispose(this._context.swarmEvent.on((data) => this.swarmEvent.emit(data)));\n\n    await Promise.all([...this._joinedSwarms.values()].map((value) => this.join(value)));\n  }\n\n  async close(): Promise<void> {\n    if (this._ctx.disposed) {\n      return;\n    }\n    // save copy of joined swarms.\n    const joinedSwarmsCopy = new ComplexSet<{ topic: PublicKey; peer: PeerInfo }>(\n      ({ topic, peer }) => topic.toHex() + peer.peerKey,\n      [...this._joinedSwarms.values()],\n    );\n\n    await Promise.all([...this._joinedSwarms.values()].map((value) => this.leave(value)));\n\n    // assign joined swarms back because .leave() deletes it.\n    this._joinedSwarms = joinedSwarmsCopy;\n\n    await this._ctx.dispose();\n  }\n\n  getStatus(): SignalStatus[] {\n    return [];\n  }\n\n  async join({ topic, peer }: { topic: PublicKey; peer: PeerInfo }): Promise<void> {\n    invariant(!this._ctx.disposed, 'Closed');\n\n    this._joinedSwarms.add({ topic, peer });\n\n    if (!this._context.swarms.has(topic)) {\n      this._context.swarms.set(topic, new ComplexSet(PeerInfoHash));\n    }\n\n    this._context.swarms.get(topic)!.add(peer);\n    this._context.swarmEvent.emit({\n      topic,\n      peerAvailable: {\n        peer,\n        since: new Date(),\n      },\n    });\n\n    // Emitting swarm events for each peer.\n    for (const [topic, peers] of this._context.swarms) {\n      Array.from(peers).forEach((peer) => {\n        this.swarmEvent.emit({\n          topic,\n          peerAvailable: {\n            peer,\n            since: new Date(),\n          },\n        });\n      });\n    }\n  }\n\n  async leave({ topic, peer }: { topic: PublicKey; peer: PeerInfo }): Promise<void> {\n    invariant(!this._ctx.disposed, 'Closed');\n\n    this._joinedSwarms.delete({ topic, peer });\n\n    if (!this._context.swarms.has(topic)) {\n      this._context.swarms.set(topic, new ComplexSet(PeerInfoHash));\n    }\n\n    this._context.swarms.get(topic)!.delete(peer);\n\n    const swarmEvent: SwarmEvent = {\n      topic,\n      peerLeft: {\n        peer,\n      },\n    };\n\n    this._context.swarmEvent.emit(swarmEvent);\n  }\n\n  async query(request: QueryRequest): Promise<SwarmResponse> {\n    throw new Error('Not implemented');\n  }\n\n  async sendMessage({\n    author,\n    recipient,\n    payload,\n  }: {\n    author: PeerInfo;\n    recipient: PeerInfo;\n    payload: Any;\n  }): Promise<void> {\n    log('send message', { author, recipient, ...dec(payload) });\n\n    invariant(recipient);\n    invariant(!this._ctx.disposed, 'Closed');\n\n    await this._freezeTrigger.wait();\n\n    const remote = this._context.connections.get(recipient);\n    if (!remote) {\n      log.warn('recipient is not subscribed for messages', { author, recipient });\n      return;\n    }\n\n    if (remote._ctx.disposed) {\n      log.warn('recipient is disposed', { author, recipient });\n      return;\n    }\n\n    remote._freezeTrigger\n      .wait()\n      .then(() => {\n        if (remote._ctx.disposed) {\n          log.warn('recipient is disposed', { author, recipient });\n          return;\n        }\n\n        log('receive message', { author, recipient, ...dec(payload) });\n\n        remote.onMessage.emit({ author, recipient, payload });\n      })\n      .catch((err) => {\n        log.error('error while waiting for freeze', { err });\n      });\n  }\n\n  async subscribeMessages(peerInfo: PeerInfo): Promise<void> {\n    log('subscribing', { peerInfo });\n    this._context.connections.set(peerInfo, this);\n  }\n\n  async unsubscribeMessages(peerInfo: PeerInfo): Promise<void> {\n    log('unsubscribing', { peerInfo });\n    this._context.connections.delete(peerInfo);\n  }\n\n  freeze(): void {\n    this._freezeTrigger.reset();\n  }\n\n  unfreeze(): void {\n    this._freezeTrigger.wake();\n  }\n}\nconst dec = (payload: Any) => {\n  if (!payload.type_url.endsWith('ReliablePayload')) {\n    return {};\n  }\n\n  const relPayload = schema.getCodecForType('dxos.mesh.messaging.ReliablePayload').decode(payload.value);\n\n  if (typeof relPayload?.payload?.data === 'object') {\n    return { payload: Object.keys(relPayload?.payload?.data)[0], sessionId: relPayload?.payload?.sessionId };\n  }\n\n  return {};\n};\n", "//\n// Copyright 2020 DXOS.org\n//\n\nimport { Event, sleep, synchronized } from '@dxos/async';\nimport { LifecycleState, Resource } from '@dxos/context';\nimport { invariant } from '@dxos/invariant';\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { RateLimitExceededError, TimeoutError, trace } from '@dxos/protocols';\nimport { type Runtime } from '@dxos/protocols/proto/dxos/config';\nimport { type SwarmResponse } from '@dxos/protocols/proto/dxos/edge/messenger';\nimport { type JoinRequest, type LeaveRequest, type QueryRequest } from '@dxos/protocols/proto/dxos/edge/signal';\nimport { BitField, safeAwaitAll } from '@dxos/util';\n\nimport { type SignalManager } from './signal-manager';\nimport { WebsocketSignalManagerMonitor } from './websocket-signal-manager-monitor';\nimport { SignalClient } from '../signal-client';\nimport {\n  type PeerInfo,\n  type Message,\n  type SignalClientMethods,\n  type SignalMethods,\n  type SignalStatus,\n  type SwarmEvent,\n} from '../signal-methods';\n\nconst MAX_SERVER_FAILURES = 5;\nconst WSS_SIGNAL_SERVER_REBOOT_DELAY = 3_000;\n\n/**\n * Manages connection to multiple Signal Servers over WebSocket\n * TODO(mykola): Delete.\n * @deprecated\n */\nexport class WebsocketSignalManager extends Resource implements SignalManager {\n  private readonly _servers = new Map<string, SignalClientMethods>();\n  private readonly _monitor = new WebsocketSignalManagerMonitor();\n\n  /**\n   * Used to avoid logging failed server restarts more than once until the server actually recovers.\n   */\n  private readonly _failedServersBitfield: Uint8Array;\n\n  readonly failureCount = new Map<string, number>();\n  readonly statusChanged = new Event<SignalStatus[]>();\n  readonly swarmEvent = new Event<SwarmEvent>();\n\n  readonly onMessage = new Event<Message>();\n\n  private readonly _instanceId = PublicKey.random().toHex();\n\n  constructor(\n    private readonly _hosts: Runtime.Services.Signal[],\n    private readonly _getMetadata?: () => any,\n  ) {\n    super();\n    log('Created WebsocketSignalManager', { hosts: this._hosts });\n    for (const host of this._hosts) {\n      if (this._servers.has(host.server)) {\n        continue;\n      }\n\n      // TODO(burdon): Create factory to support different variants.\n      const server = new SignalClient(host.server, this._getMetadata);\n      server.swarmEvent.on((data) => this.swarmEvent.emit(data));\n      server.onMessage.on((data) => this.onMessage.emit(data));\n\n      server.statusChanged.on(() => this.statusChanged.emit(this.getStatus()));\n\n      this._servers.set(host.server, server);\n      this.failureCount.set(host.server, 0);\n    }\n    this._failedServersBitfield = BitField.zeros(this._hosts.length);\n  }\n\n  protected override async _open(): Promise<void> {\n    log('open signal manager', { hosts: this._hosts });\n    log.trace('dxos.mesh.websocket-signal-manager.open', trace.begin({ id: this._instanceId }));\n\n    await safeAwaitAll(this._servers.values(), (server) => server.open());\n\n    log.trace('dxos.mesh.websocket-signal-manager.open', trace.end({ id: this._instanceId }));\n  }\n\n  protected override async _close(): Promise<void> {\n    await safeAwaitAll(this._servers.values(), (server) => server.close());\n  }\n\n  async restartServer(serverName: string): Promise<void> {\n    log('restarting server', { serverName });\n    invariant(this._lifecycleState === LifecycleState.OPEN);\n\n    const server = this._servers.get(serverName);\n    invariant(server, 'server not found');\n\n    await server.close();\n    await sleep(WSS_SIGNAL_SERVER_REBOOT_DELAY);\n    await server.open();\n  }\n\n  getStatus(): SignalStatus[] {\n    return Array.from(this._servers.values()).map((server) => server.getStatus());\n  }\n\n  @synchronized\n  async join({ topic, peer }: JoinRequest): Promise<void> {\n    log('join', { topic, peer });\n    invariant(this._lifecycleState === LifecycleState.OPEN);\n    await this._forEachServer((server) => server.join({ topic, peer }));\n  }\n\n  @synchronized\n  async leave({ topic, peer }: LeaveRequest): Promise<void> {\n    log('leaving', { topic, peer });\n    invariant(this._lifecycleState === LifecycleState.OPEN);\n    await this._forEachServer((server) => server.leave({ topic, peer }));\n  }\n\n  async query({ topic }: QueryRequest): Promise<SwarmResponse> {\n    throw new Error('Not implemented');\n  }\n\n  async sendMessage({ author, recipient, payload }: Message): Promise<void> {\n    log('signal', { recipient });\n    invariant(this._lifecycleState === LifecycleState.OPEN);\n\n    void this._forEachServer(async (server, serverName, index) => {\n      void server\n        .sendMessage({ author, recipient, payload })\n        .then(() => this._clearServerFailedFlag(serverName, index))\n        .catch((err) => {\n          if (err instanceof RateLimitExceededError) {\n            log.info('WSS rate limit exceeded', { err });\n            this._monitor.recordRateLimitExceeded();\n          } else if (err instanceof TimeoutError || err.constructor.name === 'TimeoutError') {\n            log.info('WSS sendMessage timeout', { err });\n            void this.checkServerFailure(serverName, index);\n          } else {\n            log.warn(`error sending to ${serverName}`, { err });\n            void this.checkServerFailure(serverName, index);\n          }\n        });\n    });\n  }\n\n  @synchronized\n  async checkServerFailure(serverName: string, index: number): Promise<void> {\n    const failureCount = this.failureCount.get(serverName!) ?? 0;\n    const isRestartRequired = failureCount > MAX_SERVER_FAILURES;\n    this._monitor.recordServerFailure({ serverName, willRestart: isRestartRequired });\n    if (isRestartRequired) {\n      if (!BitField.get(this._failedServersBitfield, index)) {\n        log.warn('too many failures for ws-server, restarting', { serverName, failureCount });\n        BitField.set(this._failedServersBitfield, index, true);\n      }\n      await this.restartServer(serverName!);\n      this.failureCount.set(serverName!, 0);\n      return;\n    }\n\n    this.failureCount.set(serverName!, (this.failureCount.get(serverName!) ?? 0) + 1);\n  }\n\n  private _clearServerFailedFlag(serverName: string, index: number): void {\n    if (BitField.get(this._failedServersBitfield, index)) {\n      log.info('server connection restored', { serverName });\n      BitField.set(this._failedServersBitfield, index, false);\n      this.failureCount.set(serverName!, 0);\n    }\n  }\n\n  async subscribeMessages(peer: PeerInfo): Promise<void> {\n    log('subscribed for message stream', { peer });\n    invariant(this._lifecycleState === LifecycleState.OPEN);\n\n    await this._forEachServer(async (server) => server.subscribeMessages(peer));\n  }\n\n  async unsubscribeMessages(peer: PeerInfo): Promise<void> {\n    log('subscribed for message stream', { peer });\n    invariant(this._lifecycleState === LifecycleState.OPEN);\n\n    await this._forEachServer(async (server) => server.unsubscribeMessages(peer));\n  }\n\n  private async _forEachServer<ReturnType>(\n    fn: (server: SignalMethods, serverName: string, index: number) => Promise<ReturnType>,\n  ): Promise<ReturnType[]> {\n    return Promise.all(\n      Array.from(this._servers.entries()).map(([serverName, server], idx) => fn(server, serverName, idx)),\n    );\n  }\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { trace } from '@dxos/tracing';\n\nexport class WebsocketSignalManagerMonitor {\n  public recordRateLimitExceeded(): void {\n    trace.metrics.increment('dxos.mesh.signal.signal-manager.rate-limit-hit', 1);\n  }\n\n  public recordServerFailure(params: { serverName: string; willRestart: boolean }): void {\n    trace.metrics.increment('dxos.mesh.signal.signal-manager.server-failure', 1, {\n      tags: {\n        server: params.serverName,\n        restarted: params.willRestart,\n      },\n    });\n  }\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { Event, scheduleMicroTask } from '@dxos/async';\nimport { cancelWithContext, Resource } from '@dxos/context';\nimport { type EdgeConnection, protocol } from '@dxos/edge-client';\nimport { invariant } from '@dxos/invariant';\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { EdgeService } from '@dxos/protocols';\nimport { type buf, bufWkt } from '@dxos/protocols/buf';\nimport {\n  SwarmRequestSchema,\n  SwarmRequest_Action as SwarmRequestAction,\n  SwarmResponseSchema,\n  type Message as EdgeMessage,\n  type PeerSchema,\n} from '@dxos/protocols/buf/dxos/edge/messenger_pb';\nimport { type SwarmResponse } from '@dxos/protocols/proto/dxos/edge/messenger';\nimport { ComplexMap, ComplexSet } from '@dxos/util';\n\nimport { type SignalManager } from './signal-manager';\nimport { type PeerInfo, type Message, type SwarmEvent, PeerInfoHash } from '../signal-methods';\n\nexport class EdgeSignalManager extends Resource implements SignalManager {\n  /**\n   * @deprecated\n   */\n  public swarmEvent = new Event<SwarmEvent>();\n  public swarmState = new Event<SwarmResponse>();\n  public onMessage = new Event<Message>();\n\n  /**\n   * Swarm key -> { peer: <own state payload>, joinedPeers: <state of swarm> }.\n   */\n  // TODO(mykola): This class should not contain swarm state joinedPeers. Temporary before network-manager API changes to accept list of peers.\n  private readonly _swarmPeers = new ComplexMap<\n    PublicKey,\n    { lastState?: Uint8Array; joinedPeers: ComplexSet<PeerInfo> }\n  >(PublicKey.hash);\n\n  private readonly _edgeConnection: EdgeConnection;\n\n  constructor({ edgeConnection }: { edgeConnection: EdgeConnection }) {\n    super();\n    this._edgeConnection = edgeConnection;\n  }\n\n  protected override async _open(): Promise<void> {\n    this._ctx.onDispose(this._edgeConnection.onMessage((message) => this._onMessage(message)));\n    this._ctx.onDispose(\n      this._edgeConnection.onReconnected(() => {\n        scheduleMicroTask(this._ctx, () => this._rejoinAllSwarms());\n      }),\n    );\n  }\n\n  /**\n   * Warning: PeerInfo is inferred from edgeConnection.\n   */\n  async join({ topic, peer }: { topic: PublicKey; peer: PeerInfo }): Promise<void> {\n    if (!this._matchSelfPeerInfo(peer)) {\n      // NOTE: Could only join swarm with the same peer info as the edge connection.\n      log.warn('ignoring peer info on join request', {\n        peer,\n        expected: {\n          peerKey: this._edgeConnection.peerKey,\n          identityKey: this._edgeConnection.identityKey,\n        },\n      });\n\n      peer.identityKey = this._edgeConnection.identityKey;\n      peer.peerKey = this._edgeConnection.peerKey;\n    }\n\n    this._swarmPeers.set(topic, { lastState: peer.state, joinedPeers: new ComplexSet<PeerInfo>(PeerInfoHash) });\n    await this._edgeConnection.send(\n      protocol.createMessage(SwarmRequestSchema, {\n        serviceId: EdgeService.SWARM,\n        source: createMessageSource(topic, peer),\n        payload: { action: SwarmRequestAction.JOIN, swarmKeys: [topic.toHex()] },\n      }),\n    );\n  }\n\n  async leave({ topic, peer }: { topic: PublicKey; peer: PeerInfo }): Promise<void> {\n    this._swarmPeers.delete(topic);\n    await this._edgeConnection.send(\n      protocol.createMessage(SwarmRequestSchema, {\n        serviceId: EdgeService.SWARM,\n        source: createMessageSource(topic, peer),\n        payload: { action: SwarmRequestAction.LEAVE, swarmKeys: [topic.toHex()] },\n      }),\n    );\n  }\n\n  async query({ topic }: { topic: PublicKey }): Promise<SwarmResponse> {\n    const response = cancelWithContext(\n      this._ctx,\n      this.swarmState.waitFor((state) => state.swarmKey === topic.toHex()),\n    );\n\n    await this._edgeConnection.send(\n      protocol.createMessage(SwarmRequestSchema, {\n        serviceId: EdgeService.SWARM,\n        source: createMessageSource(topic, {\n          peerKey: this._edgeConnection.peerKey,\n          identityKey: this._edgeConnection.identityKey,\n        }),\n        payload: { action: SwarmRequestAction.INFO, swarmKeys: [topic.toHex()] },\n      }),\n    );\n\n    return response;\n  }\n\n  async sendMessage(message: Message): Promise<void> {\n    if (!this._matchSelfPeerInfo(message.author)) {\n      // NOTE: Could only join swarm with the same peer info as the edge connection.\n      log.warn('ignoring author on send request', {\n        author: message.author,\n        expected: { peerKey: this._edgeConnection.peerKey, identityKey: this._edgeConnection.identityKey },\n      });\n    }\n\n    await this._edgeConnection.send(\n      protocol.createMessage(bufWkt.AnySchema, {\n        serviceId: EdgeService.SIGNAL,\n        source: message.author,\n        target: [message.recipient],\n        payload: { typeUrl: message.payload.type_url, value: message.payload.value },\n      }),\n    );\n  }\n\n  async subscribeMessages(peerInfo: PeerInfo): Promise<void> {\n    // No-op.\n  }\n\n  async unsubscribeMessages(peerInfo: PeerInfo): Promise<void> {\n    // No-op.\n  }\n\n  private _onMessage(message: EdgeMessage): void {\n    switch (message.serviceId) {\n      case EdgeService.SWARM: {\n        this._processSwarmResponse(message);\n        break;\n      }\n      case EdgeService.SIGNAL: {\n        this._processMessage(message);\n      }\n    }\n  }\n\n  private _processSwarmResponse(message: EdgeMessage): void {\n    invariant(protocol.getPayloadType(message) === SwarmResponseSchema.typeName, 'Wrong payload type');\n    const payload = protocol.getPayload(message, SwarmResponseSchema);\n    this.swarmState.emit(payload);\n    const topic = PublicKey.from(payload.swarmKey);\n    if (!this._swarmPeers.has(topic)) {\n      return;\n    }\n\n    const { joinedPeers: oldPeers } = this._swarmPeers.get(topic)!;\n    const timestamp = message.timestamp ? new Date(Date.parse(message.timestamp)) : new Date();\n    const newPeers = new ComplexSet<PeerInfo>(PeerInfoHash, payload.peers);\n\n    // Emit new available peers in the swarm.\n    for (const peer of newPeers) {\n      if (oldPeers.has(peer)) {\n        continue;\n      }\n      this.swarmEvent.emit({\n        topic,\n        peerAvailable: { peer, since: timestamp },\n      });\n    }\n\n    // Emit peer that left the swarm.\n    for (const peer of oldPeers) {\n      if (newPeers.has(peer)) {\n        continue;\n      }\n      this.swarmEvent.emit({\n        topic,\n        peerLeft: { peer },\n      });\n    }\n\n    this._swarmPeers.get(topic)!.joinedPeers = newPeers;\n  }\n\n  private _processMessage(message: EdgeMessage): void {\n    invariant(protocol.getPayloadType(message) === bufWkt.AnySchema.typeName, 'Wrong payload type');\n    const payload = protocol.getPayload(message, bufWkt.AnySchema);\n    invariant(message.source, 'source is missing');\n    invariant(message.target, 'target is missing');\n    invariant(message.target.length === 1, 'target should have exactly one item');\n\n    this.onMessage.emit({\n      author: message.source,\n      recipient: message.target[0],\n      payload: {\n        type_url: payload.typeUrl,\n        value: payload.value,\n      },\n    });\n  }\n\n  private _matchSelfPeerInfo(peer: PeerInfo): boolean {\n    return (\n      peer && (peer.peerKey === this._edgeConnection.peerKey || peer.identityKey === this._edgeConnection.identityKey)\n    );\n  }\n\n  private async _rejoinAllSwarms(): Promise<void> {\n    log('rejoin swarms', { swarms: Array.from(this._swarmPeers.keys()) });\n    for (const [topic, { lastState }] of this._swarmPeers.entries()) {\n      await this.join({\n        topic,\n        peer: {\n          peerKey: this._edgeConnection.peerKey,\n          identityKey: this._edgeConnection.identityKey,\n          state: lastState,\n        },\n      });\n    }\n  }\n}\n\nconst createMessageSource = (topic: PublicKey, peerInfo: PeerInfo): buf.MessageInitShape<typeof PeerSchema> => {\n  return {\n    swarmKey: topic.toHex(),\n    ...peerInfo,\n  };\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { invariant } from '@dxos/invariant';\nimport { log } from '@dxos/log';\nimport { type DevicesService, type IdentityService } from '@dxos/protocols/proto/dxos/client/services';\nimport { DeviceKind } from '@dxos/protocols/proto/dxos/client/services';\n\nexport const setIdentityTags = ({\n  identityService,\n  devicesService,\n  setTag,\n}: {\n  identityService: IdentityService;\n  devicesService: DevicesService;\n  setTag: (k: string, v: string) => void;\n}) => {\n  identityService.queryIdentity().subscribe((idqr) => {\n    if (!idqr?.identity?.identityKey) {\n      log('empty response from identity service', { idqr });\n      return;\n    }\n\n    setTag('identityKey', idqr.identity.identityKey.truncate());\n  });\n\n  devicesService.queryDevices().subscribe((dqr) => {\n    if (!dqr || !dqr.devices || dqr.devices.length === 0) {\n      log('empty response from device service', { device: dqr });\n      return;\n    }\n    invariant(dqr, 'empty response from device service');\n\n    const thisDevice = dqr.devices.find((device) => device.kind === DeviceKind.CURRENT);\n    if (!thisDevice) {\n      log('no current device', { device: dqr });\n      return;\n    }\n    setTag('deviceKey', thisDevice.deviceKey.truncate());\n  });\n};\n"],
  "mappings": "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",
  "names": ["import_async", "import_context", "import_invariant", "import_keys", "import_log", "import_protocols", "import_tracing", "import_util", "import_proto", "MessengerMonitor", "recordMessageAckFailed", "trace", "metrics", "increment", "recordReliableMessage", "params", "tags", "success", "sent", "attempts", "sendAttempts", "MESSAGE_TIMEOUT", "ReliablePayload", "schema", "getCodecForType", "Acknowledgement", "RECEIVED_MESSAGES_GC_INTERVAL", "Messenger", "signalManager", "retryDelay", "_monitor", "ComplexMap", "peerId", "payloadType", "Map", "_onAckCallbacks", "PublicKey", "hash", "_receivedMessages", "ComplexSet", "_closed", "_signalManager", "_retryDelay", "open", "traceId", "random", "toHex", "log", "begin", "id", "_ctx", "Context", "onError", "err", "catch", "onDispose", "onMessage", "on", "message", "from", "author", "_handleMessage", "scheduleTaskInterval", "_performGc", "end", "close", "dispose", "sendMessage", "recipient", "payload", "invariant", "messageContext", "derive", "reliablePayload", "messageId", "has", "messageReceived", "timeoutHit", "promise", "Promise", "resolve", "reject", "scheduleExponentialBackoffTaskInterval", "_encodeAndSend", "scheduleTask", "delete", "ProtocolTimeoutError", "TimeoutError", "set", "listen", "peer", "subscribeMessages", "listeners", "peerKey", "_defaultListeners", "get", "Set", "_listeners", "add", "unsubscribe", "type_url", "value", "encode", "preserveAny", "_handleReliablePayload", "_handleAcknowledgement", "decode", "_sendAcknowledgement", "_callListeners", "to", "defaultListenerMap", "listener", "listenerMap", "start", "performance", "now", "key", "_toClear", "keys", "clear", "elapsed", "warn", "SignalClientMonitor", "_performance", "sentMessages", "receivedMessages", "reconnectCounter", "joinCounter", "leaveCounter", "Date", "getRecordedTimestamps", "connectionStarted", "_connectionStarted", "lastStateChange", "_lastStateChange", "recordStateChangeTime", "recordConnectionStartTime", "recordReconnect", "recordJoin", "recordLeave", "recordMessageReceived", "createIdentityTags", "distribution", "getByteCount", "recordMessageSending", "reqStart", "reqDuration", "recordStreamCloseErrors", "count", "recordReconciliation", "length", "SignalLocalState", "_onMessage", "_onSwarmEvent", "_swarmStreams", "topic", "_joinedTopics", "_subscribedMessages", "messageStreams", "reconciled", "Event", "safeCloseStreams", "streams", "values", "concat", "failureCount", "safeAwaitAll", "s", "join", "leave", "unsubscribeMessages", "reconcile", "ctx", "client", "_reconcileSwarmSubscriptions", "_reconcileMessageSubscriptions", "emit", "swarmStream", "asyncTimeout", "cancelWithContext", "subscribe", "swarmEvent", "event", "peerAvailable", "peerLeft", "messageStream", "receiveMessages", "signalMessage", "SignalRpcClientMonitor", "recordClientCloseFailure", "reason", "failureReason", "SIGNAL_KEEPALIVE_INTERVAL", "SignalRPCClient", "url", "callbacks", "_connectTrigger", "Trigger", "_closeComplete", "_url", "_callbacks", "_socket", "WebSocket", "_rpc", "createProtoRpcPeer", "requested", "Signal", "getService", "noHandshake", "port", "send", "msg", "cb", "onmessage", "Blob", "data", "Buffer", "arrayBuffer", "encodingOptions", "onopen", "_safeCloseRpc", "onConnected", "wake", "_keepaliveCtx", "onclose", "onDisconnected", "onerror", "error", "Error", "type", "readyState", "OPEN", "CONNECTING", "wait", "timeout", "name", "metadata", "getMetadata", "rpc", "swarm", "asUint8Array", "waitUntilReady", "reset", "DEFAULT_RECONNECT_TIMEOUT", "MAX_RECONNECT_TIMEOUT", "ERROR_RECONCILE_DELAY", "RECONCILE_INTERVAL", "SignalClient", "Resource", "_host", "_getMetadata", "_state", "SignalState", "CLOSED", "_lastReconciliationFailed", "_clientReady", "_reconnectAfter", "_instanceId", "statusChanged", "startsWith", "localState", "_open", "CONNECTED", "includes", "_setState", "_reconcileTask", "DeferredTask", "_connectionCtx", "_client", "schedule", "_reconnectTask", "_reconnect", "_createClient", "_catch", "disposed", "_scheduleReconcileAfterError", "_close", "_safeResetClient", "getStatus", "host", "state", "_lastError", "reconnectIn", "args", "query", "_onConnected", "ERROR", "DISCONNECTED", "_onDisconnected", "undefined", "RECONNECTING", "info", "sleep", "options", "_updateReconnectTimeout", "newState", "status", "Math", "min", "PeerInfoHash", "MemorySignalManagerContext", "MemorySignalManager", "_context", "_joinedSwarms", "_freezeTrigger", "all", "map", "joinedSwarmsCopy", "swarms", "since", "peers", "Array", "forEach", "request", "dec", "remote", "connections", "then", "peerInfo", "freeze", "unfreeze", "endsWith", "relPayload", "Object", "sessionId", "WebsocketSignalManagerMonitor", "recordRateLimitExceeded", "recordServerFailure", "server", "serverName", "restarted", "willRestart", "MAX_SERVER_FAILURES", "WSS_SIGNAL_SERVER_REBOOT_DELAY", "WebsocketSignalManager", "_hosts", "_servers", "hosts", "_failedServersBitfield", "BitField", "zeros", "restartServer", "_lifecycleState", "LifecycleState", "_forEachServer", "index", "_clearServerFailedFlag", "RateLimitExceededError", "checkServerFailure", "isRestartRequired", "fn", "entries", "idx", "EdgeSignalManager", "edgeConnection", "swarmState", "_edgeConnection", "onReconnected", "scheduleMicroTask", "_rejoinAllSwarms", "_matchSelfPeerInfo", "expected", "identityKey", "_swarmPeers", "lastState", "joinedPeers", "protocol", "createMessage", "SwarmRequestSchema", "serviceId", "EdgeService", "SWARM", "source", "createMessageSource", "action", "SwarmRequestAction", "JOIN", "swarmKeys", "LEAVE", "response", "waitFor", "swarmKey", "INFO", "bufWkt", "AnySchema", "SIGNAL", "target", "typeUrl", "_processSwarmResponse", "_processMessage", "getPayloadType", "SwarmResponseSchema", "typeName", "getPayload", "oldPeers", "timestamp", "parse", "newPeers", "setIdentityTags", "identityService", "devicesService", "setTag", "queryIdentity", "idqr", "identity", "truncate", "queryDevices", "dqr", "devices", "device", "thisDevice", "find", "kind", "DeviceKind", "CURRENT", "deviceKey"]
}
