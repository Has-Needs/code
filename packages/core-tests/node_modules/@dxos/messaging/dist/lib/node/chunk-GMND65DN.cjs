"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var chunk_GMND65DN_exports = {};
__export(chunk_GMND65DN_exports, {
  EdgeSignalManager: () => EdgeSignalManager,
  MemorySignalManager: () => MemorySignalManager,
  MemorySignalManagerContext: () => MemorySignalManagerContext,
  Messenger: () => Messenger,
  PeerInfoHash: () => PeerInfoHash,
  SignalClient: () => SignalClient,
  WebsocketSignalManager: () => WebsocketSignalManager,
  setIdentityTags: () => setIdentityTags
});
module.exports = __toCommonJS(chunk_GMND65DN_exports);
var import_async = require("@dxos/async");
var import_context = require("@dxos/context");
var import_invariant = require("@dxos/invariant");
var import_keys = require("@dxos/keys");
var import_log = require("@dxos/log");
var import_protocols = require("@dxos/protocols");
var import_proto = require("@dxos/protocols/proto");
var import_util = require("@dxos/util");
var import_tracing = require("@dxos/tracing");
var import_async2 = require("@dxos/async");
var import_context2 = require("@dxos/context");
var import_invariant2 = require("@dxos/invariant");
var import_keys2 = require("@dxos/keys");
var import_log2 = require("@dxos/log");
var import_protocols2 = require("@dxos/protocols");
var import_signal = require("@dxos/protocols/proto/dxos/mesh/signal");
var import_tracing2 = require("@dxos/tracing");
var import_async3 = require("@dxos/async");
var import_context3 = require("@dxos/context");
var import_keys3 = require("@dxos/keys");
var import_log3 = require("@dxos/log");
var import_util2 = require("@dxos/util");
var import_isomorphic_ws = __toESM(require("isomorphic-ws"));
var import_async4 = require("@dxos/async");
var import_context4 = require("@dxos/context");
var import_invariant3 = require("@dxos/invariant");
var import_keys4 = require("@dxos/keys");
var import_log4 = require("@dxos/log");
var import_protocols3 = require("@dxos/protocols");
var import_proto2 = require("@dxos/protocols/proto");
var import_rpc = require("@dxos/rpc");
var import_tracing3 = require("@dxos/tracing");
var import_async5 = require("@dxos/async");
var import_context5 = require("@dxos/context");
var import_invariant4 = require("@dxos/invariant");
var import_keys5 = require("@dxos/keys");
var import_log5 = require("@dxos/log");
var import_proto3 = require("@dxos/protocols/proto");
var import_util3 = require("@dxos/util");
var import_async6 = require("@dxos/async");
var import_context6 = require("@dxos/context");
var import_invariant5 = require("@dxos/invariant");
var import_keys6 = require("@dxos/keys");
var import_log6 = require("@dxos/log");
var import_protocols4 = require("@dxos/protocols");
var import_util4 = require("@dxos/util");
var import_tracing4 = require("@dxos/tracing");
var import_async7 = require("@dxos/async");
var import_context7 = require("@dxos/context");
var import_edge_client = require("@dxos/edge-client");
var import_invariant6 = require("@dxos/invariant");
var import_keys7 = require("@dxos/keys");
var import_log7 = require("@dxos/log");
var import_protocols5 = require("@dxos/protocols");
var import_buf = require("@dxos/protocols/buf");
var import_messenger_pb = require("@dxos/protocols/buf/dxos/edge/messenger_pb");
var import_util5 = require("@dxos/util");
var import_invariant7 = require("@dxos/invariant");
var import_log8 = require("@dxos/log");
var import_services = require("@dxos/protocols/proto/dxos/client/services");
var MessengerMonitor = class {
  recordMessageAckFailed() {
    import_tracing.trace.metrics.increment("dxos.mesh.signal.messenger.failed-ack", 1);
  }
  recordReliableMessage(params) {
    import_tracing.trace.metrics.increment("dxos.mesh.signal.messenger.reliable-send", 1, {
      tags: {
        success: params.sent,
        attempts: params.sendAttempts
      }
    });
  }
};
var MESSAGE_TIMEOUT = 1e4;
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/core/mesh/messaging/src/messenger.ts";
var ReliablePayload = import_proto.schema.getCodecForType("dxos.mesh.messaging.ReliablePayload");
var Acknowledgement = import_proto.schema.getCodecForType("dxos.mesh.messaging.Acknowledgement");
var RECEIVED_MESSAGES_GC_INTERVAL = 12e4;
var Messenger = class {
  constructor({ signalManager, retryDelay = 1e3 }) {
    this._monitor = new MessengerMonitor();
    this._listeners = new import_util.ComplexMap(({ peerId, payloadType }) => peerId + payloadType);
    this._defaultListeners = /* @__PURE__ */ new Map();
    this._onAckCallbacks = new import_util.ComplexMap(import_keys.PublicKey.hash);
    this._receivedMessages = new import_util.ComplexSet(import_keys.PublicKey.hash);
    this._toClear = new import_util.ComplexSet(import_keys.PublicKey.hash);
    this._closed = true;
    this._signalManager = signalManager;
    this._retryDelay = retryDelay;
    this.open();
  }
  open() {
    if (!this._closed) {
      return;
    }
    const traceId = import_keys.PublicKey.random().toHex();
    import_log.log.trace("dxos.mesh.messenger.open", import_protocols.trace.begin({
      id: traceId
    }), {
      F: __dxlog_file,
      L: 72,
      S: this,
      C: (f, a) => f(...a)
    });
    this._ctx = new import_context.Context({
      onError: (err) => import_log.log.catch(err, void 0, {
        F: __dxlog_file,
        L: 74,
        S: this,
        C: (f, a) => f(...a)
      })
    }, {
      F: __dxlog_file,
      L: 73
    });
    this._ctx.onDispose(this._signalManager.onMessage.on(async (message) => {
      (0, import_log.log)("received message", {
        from: message.author
      }, {
        F: __dxlog_file,
        L: 78,
        S: this,
        C: (f, a) => f(...a)
      });
      await this._handleMessage(message);
    }));
    (0, import_async.scheduleTaskInterval)(this._ctx, async () => {
      this._performGc();
    }, RECEIVED_MESSAGES_GC_INTERVAL);
    this._closed = false;
    import_log.log.trace("dxos.mesh.messenger.open", import_protocols.trace.end({
      id: traceId
    }), {
      F: __dxlog_file,
      L: 93,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  async close() {
    if (this._closed) {
      return;
    }
    this._closed = true;
    await this._ctx.dispose();
  }
  async sendMessage({ author, recipient, payload }) {
    (0, import_invariant.invariant)(!this._closed, "Closed", {
      F: __dxlog_file,
      L: 105,
      S: this,
      A: [
        "!this._closed",
        "'Closed'"
      ]
    });
    const messageContext = this._ctx.derive();
    const reliablePayload = {
      messageId: import_keys.PublicKey.random(),
      payload
    };
    (0, import_invariant.invariant)(!this._onAckCallbacks.has(reliablePayload.messageId), void 0, {
      F: __dxlog_file,
      L: 112,
      S: this,
      A: [
        "!this._onAckCallbacks.has(reliablePayload.messageId!)",
        ""
      ]
    });
    (0, import_log.log)("send message", {
      messageId: reliablePayload.messageId,
      author,
      recipient
    }, {
      F: __dxlog_file,
      L: 113,
      S: this,
      C: (f, a) => f(...a)
    });
    let messageReceived;
    let timeoutHit;
    let sendAttempts = 0;
    const promise = new Promise((resolve, reject) => {
      messageReceived = resolve;
      timeoutHit = reject;
    });
    (0, import_async.scheduleExponentialBackoffTaskInterval)(messageContext, async () => {
      (0, import_log.log)("retrying message", {
        messageId: reliablePayload.messageId
      }, {
        F: __dxlog_file,
        L: 128,
        S: this,
        C: (f, a) => f(...a)
      });
      sendAttempts++;
      await this._encodeAndSend({
        author,
        recipient,
        reliablePayload
      }).catch((err) => (0, import_log.log)("failed to send message", {
        err
      }, {
        F: __dxlog_file,
        L: 131,
        S: this,
        C: (f, a) => f(...a)
      }));
    }, this._retryDelay);
    (0, import_async.scheduleTask)(messageContext, () => {
      (0, import_log.log)("message not delivered", {
        messageId: reliablePayload.messageId
      }, {
        F: __dxlog_file,
        L: 140,
        S: this,
        C: (f, a) => f(...a)
      });
      this._onAckCallbacks.delete(reliablePayload.messageId);
      timeoutHit(new import_protocols.TimeoutError("signaling message not delivered", new import_async.TimeoutError(MESSAGE_TIMEOUT, "Message not delivered")));
      void messageContext.dispose();
      this._monitor.recordReliableMessage({
        sendAttempts,
        sent: false
      });
    }, MESSAGE_TIMEOUT);
    this._onAckCallbacks.set(reliablePayload.messageId, () => {
      messageReceived();
      this._onAckCallbacks.delete(reliablePayload.messageId);
      void messageContext.dispose();
      this._monitor.recordReliableMessage({
        sendAttempts,
        sent: true
      });
    });
    await this._encodeAndSend({
      author,
      recipient,
      reliablePayload
    });
    return promise;
  }
  /**
  * Subscribes onMessage function to messages that contains payload with payloadType.
  * @param payloadType if not specified, onMessage will be subscribed to all types of messages.
  */
  async listen({ peer, payloadType, onMessage }) {
    (0, import_invariant.invariant)(!this._closed, "Closed", {
      F: __dxlog_file,
      L: 178,
      S: this,
      A: [
        "!this._closed",
        "'Closed'"
      ]
    });
    await this._signalManager.subscribeMessages(peer);
    let listeners;
    (0, import_invariant.invariant)(peer.peerKey, "Peer key is required", {
      F: __dxlog_file,
      L: 182,
      S: this,
      A: [
        "peer.peerKey",
        "'Peer key is required'"
      ]
    });
    if (!payloadType) {
      listeners = this._defaultListeners.get(peer.peerKey);
      if (!listeners) {
        listeners = /* @__PURE__ */ new Set();
        this._defaultListeners.set(peer.peerKey, listeners);
      }
    } else {
      listeners = this._listeners.get({
        peerId: peer.peerKey,
        payloadType
      });
      if (!listeners) {
        listeners = /* @__PURE__ */ new Set();
        this._listeners.set({
          peerId: peer.peerKey,
          payloadType
        }, listeners);
      }
    }
    listeners.add(onMessage);
    return {
      unsubscribe: async () => {
        listeners.delete(onMessage);
      }
    };
  }
  async _encodeAndSend({ author, recipient, reliablePayload }) {
    await this._signalManager.sendMessage({
      author,
      recipient,
      payload: {
        type_url: "dxos.mesh.messaging.ReliablePayload",
        value: ReliablePayload.encode(reliablePayload, {
          preserveAny: true
        })
      }
    });
  }
  async _handleMessage(message) {
    switch (message.payload.type_url) {
      case "dxos.mesh.messaging.ReliablePayload": {
        await this._handleReliablePayload(message);
        break;
      }
      case "dxos.mesh.messaging.Acknowledgement": {
        await this._handleAcknowledgement({
          payload: message.payload
        });
        break;
      }
    }
  }
  async _handleReliablePayload({ author, recipient, payload }) {
    (0, import_invariant.invariant)(payload.type_url === "dxos.mesh.messaging.ReliablePayload", void 0, {
      F: __dxlog_file,
      L: 240,
      S: this,
      A: [
        "payload.type_url === 'dxos.mesh.messaging.ReliablePayload'",
        ""
      ]
    });
    const reliablePayload = ReliablePayload.decode(payload.value, {
      preserveAny: true
    });
    (0, import_log.log)("handling message", {
      messageId: reliablePayload.messageId
    }, {
      F: __dxlog_file,
      L: 243,
      S: this,
      C: (f, a) => f(...a)
    });
    try {
      await this._sendAcknowledgement({
        author,
        recipient,
        messageId: reliablePayload.messageId
      });
    } catch (err) {
      this._monitor.recordMessageAckFailed();
      throw err;
    }
    if (this._receivedMessages.has(reliablePayload.messageId)) {
      return;
    }
    this._receivedMessages.add(reliablePayload.messageId);
    await this._callListeners({
      author,
      recipient,
      payload: reliablePayload.payload
    });
  }
  async _handleAcknowledgement({ payload }) {
    (0, import_invariant.invariant)(payload.type_url === "dxos.mesh.messaging.Acknowledgement", void 0, {
      F: __dxlog_file,
      L: 271,
      S: this,
      A: [
        "payload.type_url === 'dxos.mesh.messaging.Acknowledgement'",
        ""
      ]
    });
    this._onAckCallbacks.get(Acknowledgement.decode(payload.value).messageId)?.();
  }
  async _sendAcknowledgement({ author, recipient, messageId }) {
    (0, import_log.log)("sending ACK", {
      messageId,
      from: recipient,
      to: author
    }, {
      F: __dxlog_file,
      L: 284,
      S: this,
      C: (f, a) => f(...a)
    });
    await this._signalManager.sendMessage({
      author: recipient,
      recipient: author,
      payload: {
        type_url: "dxos.mesh.messaging.Acknowledgement",
        value: Acknowledgement.encode({
          messageId
        })
      }
    });
  }
  async _callListeners(message) {
    {
      (0, import_invariant.invariant)(message.recipient.peerKey, "Peer key is required", {
        F: __dxlog_file,
        L: 298,
        S: this,
        A: [
          "message.recipient.peerKey",
          "'Peer key is required'"
        ]
      });
      const defaultListenerMap = this._defaultListeners.get(message.recipient.peerKey);
      if (defaultListenerMap) {
        for (const listener of defaultListenerMap) {
          await listener(message);
        }
      }
    }
    {
      const listenerMap = this._listeners.get({
        peerId: message.recipient.peerKey,
        payloadType: message.payload.type_url
      });
      if (listenerMap) {
        for (const listener of listenerMap) {
          await listener(message);
        }
      }
    }
  }
  _performGc() {
    const start = performance.now();
    for (const key of this._toClear.keys()) {
      this._receivedMessages.delete(key);
    }
    this._toClear.clear();
    for (const key of this._receivedMessages.keys()) {
      this._toClear.add(key);
    }
    const elapsed = performance.now() - start;
    if (elapsed > 100) {
      import_log.log.warn("GC took too long", {
        elapsed
      }, {
        F: __dxlog_file,
        L: 333,
        S: this,
        C: (f, a) => f(...a)
      });
    }
  }
};
var SignalClientMonitor = class {
  constructor() {
    this._performance = {
      sentMessages: 0,
      receivedMessages: 0,
      reconnectCounter: 0,
      joinCounter: 0,
      leaveCounter: 0
    };
    this._connectionStarted = /* @__PURE__ */ new Date();
    this._lastStateChange = /* @__PURE__ */ new Date();
  }
  getRecordedTimestamps() {
    return {
      connectionStarted: this._connectionStarted,
      lastStateChange: this._lastStateChange
    };
  }
  recordStateChangeTime() {
    this._lastStateChange = /* @__PURE__ */ new Date();
  }
  recordConnectionStartTime() {
    this._connectionStarted = /* @__PURE__ */ new Date();
  }
  recordReconnect(params) {
    this._performance.reconnectCounter++;
    import_tracing2.trace.metrics.increment("dxos.mesh.signal.signal-client.reconnect", 1, {
      tags: {
        success: params.success
      }
    });
  }
  recordJoin() {
    this._performance.joinCounter++;
  }
  recordLeave() {
    this._performance.leaveCounter++;
  }
  recordMessageReceived(message) {
    this._performance.receivedMessages++;
    import_tracing2.trace.metrics.increment("dxos.mesh.signal.signal-client.received-total", 1, {
      tags: createIdentityTags(message)
    });
    import_tracing2.trace.metrics.distribution("dxos.mesh.signal.signal-client.bytes-in", getByteCount(message), {
      tags: createIdentityTags(message)
    });
  }
  async recordMessageSending(message, sendMessage) {
    this._performance.sentMessages++;
    const tags = createIdentityTags(message);
    let success = true;
    try {
      const reqStart = Date.now();
      await sendMessage();
      const reqDuration = Date.now() - reqStart;
      import_tracing2.trace.metrics.distribution("dxos.mesh.signal.signal-client.send-duration", reqDuration, {
        tags
      });
      import_tracing2.trace.metrics.distribution("dxos.mesh.signal.signal-client.bytes-out", getByteCount(message), {
        tags
      });
    } catch (err) {
      success = false;
    }
    import_tracing2.trace.metrics.increment("dxos.mesh.signal.signal-client.sent-total", 1, {
      tags: {
        ...tags,
        success
      }
    });
  }
  recordStreamCloseErrors(count) {
    import_tracing2.trace.metrics.increment("dxos.mesh.signal.signal-client.stream-close-errors", count);
  }
  recordReconciliation(params) {
    import_tracing2.trace.metrics.increment("dxos.mesh.signal.signal-client.reconciliation", 1, {
      tags: {
        success: params.success
      }
    });
  }
};
var getByteCount = (message) => {
  return message.author.peerKey.length + message.recipient.peerKey.length + message.payload.type_url.length + message.payload.value.length;
};
var createIdentityTags = (message) => {
  return {
    peer: message.author.peerKey
  };
};
var __dxlog_file2 = "/home/runner/work/dxos/dxos/packages/core/mesh/messaging/src/signal-client/signal-local-state.ts";
var SignalLocalState = class {
  constructor(_onMessage, _onSwarmEvent) {
    this._onMessage = _onMessage;
    this._onSwarmEvent = _onSwarmEvent;
    this._swarmStreams = new import_util2.ComplexMap(({ topic, peerId }) => topic.toHex() + peerId.toHex());
    this._joinedTopics = new import_util2.ComplexSet(({ topic, peerId }) => topic.toHex() + peerId.toHex());
    this._subscribedMessages = new import_util2.ComplexSet(({ peerId }) => peerId.toHex());
    this.messageStreams = new import_util2.ComplexMap((key) => key.toHex());
    this.reconciled = new import_async3.Event();
  }
  async safeCloseStreams() {
    const streams = [
      ...this._swarmStreams.values()
    ].concat([
      ...this.messageStreams.values()
    ]);
    this._swarmStreams.clear();
    this.messageStreams.clear();
    const failureCount = (await (0, import_util2.safeAwaitAll)(streams, (s) => s.close())).length;
    return {
      failureCount
    };
  }
  join({ topic, peerId }) {
    this._joinedTopics.add({
      topic,
      peerId
    });
  }
  leave({ topic, peerId }) {
    void this._swarmStreams.get({
      topic,
      peerId
    })?.close();
    this._swarmStreams.delete({
      topic,
      peerId
    });
    this._joinedTopics.delete({
      topic,
      peerId
    });
  }
  subscribeMessages(peerId) {
    this._subscribedMessages.add({
      peerId
    });
  }
  unsubscribeMessages(peerId) {
    (0, import_log3.log)("unsubscribing from messages", {
      peerId
    }, {
      F: __dxlog_file2,
      L: 79,
      S: this,
      C: (f, a) => f(...a)
    });
    this._subscribedMessages.delete({
      peerId
    });
    void this.messageStreams.get(peerId)?.close();
    this.messageStreams.delete(peerId);
  }
  async reconcile(ctx, client) {
    await this._reconcileSwarmSubscriptions(ctx, client);
    await this._reconcileMessageSubscriptions(ctx, client);
    this.reconciled.emit();
  }
  async _reconcileSwarmSubscriptions(ctx, client) {
    for (const { topic, peerId } of this._swarmStreams.keys()) {
      if (this._joinedTopics.has({
        topic,
        peerId
      })) {
        continue;
      }
      void this._swarmStreams.get({
        topic,
        peerId
      })?.close();
      this._swarmStreams.delete({
        topic,
        peerId
      });
    }
    for (const { topic, peerId } of this._joinedTopics.values()) {
      if (this._swarmStreams.has({
        topic,
        peerId
      })) {
        continue;
      }
      const swarmStream = await (0, import_async3.asyncTimeout)((0, import_context3.cancelWithContext)(ctx, client.join({
        topic,
        peerId
      })), 5e3);
      swarmStream.subscribe(async (swarmEvent) => {
        if (this._joinedTopics.has({
          topic,
          peerId
        })) {
          (0, import_log3.log)("swarm event", {
            swarmEvent
          }, {
            F: __dxlog_file2,
            L: 115,
            S: this,
            C: (f, a) => f(...a)
          });
          const event = swarmEvent.peerAvailable ? {
            topic,
            peerAvailable: {
              ...swarmEvent.peerAvailable,
              peer: {
                peerKey: import_keys3.PublicKey.from(swarmEvent.peerAvailable.peer).toHex()
              }
            }
          } : {
            topic,
            peerLeft: {
              ...swarmEvent.peerLeft,
              peer: {
                peerKey: import_keys3.PublicKey.from(swarmEvent.peerLeft.peer).toHex()
              }
            }
          };
          await this._onSwarmEvent(event);
        }
      });
      this._swarmStreams.set({
        topic,
        peerId
      }, swarmStream);
    }
  }
  async _reconcileMessageSubscriptions(ctx, client) {
    for (const peerId of this.messageStreams.keys()) {
      if (this._subscribedMessages.has({
        peerId
      })) {
        continue;
      }
      void this.messageStreams.get(peerId)?.close();
      this.messageStreams.delete(peerId);
    }
    for (const { peerId } of this._subscribedMessages.values()) {
      if (this.messageStreams.has(peerId)) {
        continue;
      }
      const messageStream = await (0, import_async3.asyncTimeout)((0, import_context3.cancelWithContext)(ctx, client.receiveMessages(peerId)), 5e3);
      messageStream.subscribe(async (signalMessage) => {
        if (this._subscribedMessages.has({
          peerId
        })) {
          const message = {
            author: {
              peerKey: import_keys3.PublicKey.from(signalMessage.author).toHex()
            },
            recipient: {
              peerKey: import_keys3.PublicKey.from(signalMessage.recipient).toHex()
            },
            payload: signalMessage.payload
          };
          await this._onMessage(message);
        }
      });
      this.messageStreams.set(peerId, messageStream);
    }
  }
};
var SignalRpcClientMonitor = class {
  recordClientCloseFailure(params) {
    import_tracing3.trace.metrics.increment("dxos.mesh.signal.signal-rpc-client.close-failure", 1, {
      tags: {
        reason: params.failureReason
      }
    });
  }
};
var __dxlog_file3 = "/home/runner/work/dxos/dxos/packages/core/mesh/messaging/src/signal-client/signal-rpc-client.ts";
var SIGNAL_KEEPALIVE_INTERVAL = 1e4;
var SignalRPCClient = class {
  constructor({ url, callbacks = {} }) {
    this._connectTrigger = new import_async4.Trigger();
    this._closed = false;
    this._closeComplete = new import_async4.Trigger();
    this._monitor = new SignalRpcClientMonitor();
    const traceId = import_keys4.PublicKey.random().toHex();
    import_log4.log.trace("dxos.mesh.signal-rpc-client.constructor", import_protocols3.trace.begin({
      id: traceId
    }), {
      F: __dxlog_file3,
      L: 66,
      S: this,
      C: (f, a) => f(...a)
    });
    this._url = url;
    this._callbacks = callbacks;
    this._socket = new import_isomorphic_ws.default(this._url);
    this._rpc = (0, import_rpc.createProtoRpcPeer)({
      requested: {
        Signal: import_proto2.schema.getService("dxos.mesh.signal.Signal")
      },
      noHandshake: true,
      port: {
        send: (msg) => {
          if (this._closed) {
            return;
          }
          try {
            this._socket.send(msg);
          } catch (err) {
            import_log4.log.warn("send error", err, {
              F: __dxlog_file3,
              L: 85,
              S: this,
              C: (f, a) => f(...a)
            });
          }
        },
        subscribe: (cb) => {
          this._socket.onmessage = async (msg) => {
            if (typeof Blob !== "undefined" && msg.data instanceof Blob) {
              cb(Buffer.from(await msg.data.arrayBuffer()));
            } else {
              cb(msg.data);
            }
          };
        }
      },
      encodingOptions: {
        preserveAny: true
      }
    });
    this._socket.onopen = async () => {
      try {
        await this._rpc.open();
        if (this._closed) {
          await this._safeCloseRpc();
          return;
        }
        (0, import_log4.log)(`RPC open ${this._url}`, void 0, {
          F: __dxlog_file3,
          L: 110,
          S: this,
          C: (f, a) => f(...a)
        });
        this._callbacks.onConnected?.();
        this._connectTrigger.wake();
        this._keepaliveCtx = new import_context4.Context(void 0, {
          F: __dxlog_file3,
          L: 113
        });
        (0, import_async4.scheduleTaskInterval)(this._keepaliveCtx, async () => {
          this._socket?.send("__ping__");
        }, SIGNAL_KEEPALIVE_INTERVAL);
      } catch (err) {
        this._callbacks.onError?.(err);
        this._socket.close();
        this._closed = true;
      }
    };
    this._socket.onclose = async () => {
      (0, import_log4.log)(`Disconnected ${this._url}`, void 0, {
        F: __dxlog_file3,
        L: 133,
        S: this,
        C: (f, a) => f(...a)
      });
      this._callbacks.onDisconnected?.();
      this._closeComplete.wake();
      await this.close();
    };
    this._socket.onerror = async (event) => {
      if (this._closed) {
        this._socket.close();
        return;
      }
      this._closed = true;
      this._callbacks.onError?.(event.error ?? new Error(event.message));
      await this._safeCloseRpc();
      import_log4.log.warn(`Socket ${event.type ?? "unknown"} error`, {
        message: event.message,
        url: this._url
      }, {
        F: __dxlog_file3,
        L: 149,
        S: this,
        C: (f, a) => f(...a)
      });
    };
    import_log4.log.trace("dxos.mesh.signal-rpc-client.constructor", import_protocols3.trace.end({
      id: traceId
    }), {
      F: __dxlog_file3,
      L: 152,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  async close() {
    if (this._closed) {
      return;
    }
    this._closed = true;
    await this._keepaliveCtx?.dispose();
    try {
      await this._safeCloseRpc();
      if (this._socket.readyState === import_isomorphic_ws.default.OPEN || this._socket.readyState === import_isomorphic_ws.default.CONNECTING) {
        this._socket.close();
      }
      await this._closeComplete.wait({
        timeout: 1e3
      });
    } catch (err) {
      const failureReason = err instanceof import_async4.TimeoutError ? "timeout" : err?.constructor?.name ?? "unknown";
      this._monitor.recordClientCloseFailure({
        failureReason
      });
    }
  }
  async join({ topic, peerId }) {
    (0, import_log4.log)("join", {
      topic,
      peerId,
      metadata: this._callbacks?.getMetadata?.()
    }, {
      F: __dxlog_file3,
      L: 178,
      S: this,
      C: (f, a) => f(...a)
    });
    (0, import_invariant3.invariant)(!this._closed, "SignalRPCClient is closed", {
      F: __dxlog_file3,
      L: 179,
      S: this,
      A: [
        "!this._closed",
        "'SignalRPCClient is closed'"
      ]
    });
    await this._connectTrigger.wait();
    const swarmStream = this._rpc.rpc.Signal.join({
      swarm: topic.asUint8Array(),
      peer: peerId.asUint8Array(),
      metadata: this._callbacks?.getMetadata?.()
    });
    await swarmStream.waitUntilReady();
    return swarmStream;
  }
  async receiveMessages(peerId) {
    (0, import_log4.log)("receiveMessages", {
      peerId
    }, {
      F: __dxlog_file3,
      L: 191,
      S: this,
      C: (f, a) => f(...a)
    });
    (0, import_invariant3.invariant)(!this._closed, "SignalRPCClient is closed", {
      F: __dxlog_file3,
      L: 192,
      S: this,
      A: [
        "!this._closed",
        "'SignalRPCClient is closed'"
      ]
    });
    await this._connectTrigger.wait();
    const messageStream = this._rpc.rpc.Signal.receiveMessages({
      peer: peerId.asUint8Array()
    });
    await messageStream.waitUntilReady();
    return messageStream;
  }
  async sendMessage({ author, recipient, payload }) {
    (0, import_log4.log)("sendMessage", {
      author,
      recipient,
      payload,
      metadata: this._callbacks?.getMetadata?.()
    }, {
      F: __dxlog_file3,
      L: 210,
      S: this,
      C: (f, a) => f(...a)
    });
    (0, import_invariant3.invariant)(!this._closed, "SignalRPCClient is closed", {
      F: __dxlog_file3,
      L: 211,
      S: this,
      A: [
        "!this._closed",
        "'SignalRPCClient is closed'"
      ]
    });
    await this._connectTrigger.wait();
    await this._rpc.rpc.Signal.sendMessage({
      author: author.asUint8Array(),
      recipient: recipient.asUint8Array(),
      payload,
      metadata: this._callbacks?.getMetadata?.()
    });
  }
  async _safeCloseRpc() {
    try {
      this._connectTrigger.reset();
      await this._rpc.close();
    } catch (err) {
      import_log4.log.catch(err, void 0, {
        F: __dxlog_file3,
        L: 226,
        S: this,
        C: (f, a) => f(...a)
      });
    }
  }
};
var __dxlog_file4 = "/home/runner/work/dxos/dxos/packages/core/mesh/messaging/src/signal-client/signal-client.ts";
var DEFAULT_RECONNECT_TIMEOUT = 100;
var MAX_RECONNECT_TIMEOUT = 5e3;
var ERROR_RECONCILE_DELAY = 1e3;
var RECONCILE_INTERVAL = 5e3;
var SignalClient = class extends import_context2.Resource {
  /**
  * @param _host Signal server websocket URL.
  * @param onMessage called when a new message is received.
  * @param onSwarmEvent called when a new swarm event is received.
  * @param _getMetadata signal-message metadata provider, called for every message.
  */
  constructor(_host, _getMetadata) {
    super(), this._host = _host, this._getMetadata = _getMetadata, this._monitor = new SignalClientMonitor(), this._state = import_signal.SignalState.CLOSED, this._lastReconciliationFailed = false, this._clientReady = new import_async2.Trigger(), this._reconnectAfter = DEFAULT_RECONNECT_TIMEOUT, this._instanceId = import_keys2.PublicKey.random().toHex(), this.statusChanged = new import_async2.Event(), this.onMessage = new import_async2.Event(), this.swarmEvent = new import_async2.Event();
    if (!this._host.startsWith("wss://") && !this._host.startsWith("ws://")) {
      throw new Error(`Signal server requires a websocket URL. Provided: ${this._host}`);
    }
    this.localState = new SignalLocalState(async (message) => {
      this._monitor.recordMessageReceived(message);
      this.onMessage.emit(message);
    }, async (event) => this.swarmEvent.emit(event));
  }
  async _open() {
    import_log2.log.trace("dxos.mesh.signal-client.open", import_protocols2.trace.begin({
      id: this._instanceId
    }), {
      F: __dxlog_file4,
      L: 96,
      S: this,
      C: (f, a) => f(...a)
    });
    if ([
      import_signal.SignalState.CONNECTED,
      import_signal.SignalState.CONNECTING
    ].includes(this._state)) {
      return;
    }
    this._setState(import_signal.SignalState.CONNECTING);
    this._reconcileTask = new import_async2.DeferredTask(this._ctx, async () => {
      try {
        await (0, import_context2.cancelWithContext)(this._connectionCtx, this._clientReady.wait({
          timeout: 5e3
        }));
        (0, import_invariant2.invariant)(this._state === import_signal.SignalState.CONNECTED, "Not connected to Signal Server", {
          F: __dxlog_file4,
          L: 106,
          S: this,
          A: [
            "this._state === SignalState.CONNECTED",
            "'Not connected to Signal Server'"
          ]
        });
        await this.localState.reconcile(this._connectionCtx, this._client);
        this._monitor.recordReconciliation({
          success: true
        });
        this._lastReconciliationFailed = false;
      } catch (err) {
        this._lastReconciliationFailed = true;
        this._monitor.recordReconciliation({
          success: false
        });
        throw err;
      }
    });
    (0, import_async2.scheduleTaskInterval)(this._ctx, async () => {
      if (this._state === import_signal.SignalState.CONNECTED) {
        this._reconcileTask.schedule();
      }
    }, RECONCILE_INTERVAL);
    this._reconnectTask = new import_async2.DeferredTask(this._ctx, async () => {
      try {
        await this._reconnect();
        this._monitor.recordReconnect({
          success: true
        });
      } catch (err) {
        this._monitor.recordReconnect({
          success: false
        });
        throw err;
      }
    });
    this._createClient();
    import_log2.log.trace("dxos.mesh.signal-client.open", import_protocols2.trace.end({
      id: this._instanceId
    }), {
      F: __dxlog_file4,
      L: 139,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  async _catch(err) {
    if (this._state === import_signal.SignalState.CLOSED || this._ctx.disposed) {
      return;
    }
    if (this._state === import_signal.SignalState.CONNECTED && !this._lastReconciliationFailed) {
      import_log2.log.warn("SignalClient error:", err, {
        F: __dxlog_file4,
        L: 148,
        S: this,
        C: (f, a) => f(...a)
      });
    }
    this._scheduleReconcileAfterError();
  }
  async _close() {
    (0, import_log2.log)("closing...", void 0, {
      F: __dxlog_file4,
      L: 154,
      S: this,
      C: (f, a) => f(...a)
    });
    if ([
      import_signal.SignalState.CLOSED
    ].includes(this._state)) {
      return;
    }
    this._setState(import_signal.SignalState.CLOSED);
    await this._safeResetClient();
    (0, import_log2.log)("closed", void 0, {
      F: __dxlog_file4,
      L: 162,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  getStatus() {
    return {
      host: this._host,
      state: this._state,
      error: this._lastError?.message,
      reconnectIn: this._reconnectAfter,
      ...this._monitor.getRecordedTimestamps()
    };
  }
  async join(args) {
    (0, import_log2.log)("joining", {
      topic: args.topic,
      peerId: args.peer.peerKey
    }, {
      F: __dxlog_file4,
      L: 176,
      S: this,
      C: (f, a) => f(...a)
    });
    this._monitor.recordJoin();
    this.localState.join({
      topic: args.topic,
      peerId: import_keys2.PublicKey.from(args.peer.peerKey)
    });
    this._reconcileTask?.schedule();
  }
  async leave(args) {
    (0, import_log2.log)("leaving", {
      topic: args.topic,
      peerId: args.peer.peerKey
    }, {
      F: __dxlog_file4,
      L: 183,
      S: this,
      C: (f, a) => f(...a)
    });
    this._monitor.recordLeave();
    this.localState.leave({
      topic: args.topic,
      peerId: import_keys2.PublicKey.from(args.peer.peerKey)
    });
  }
  async query(params) {
    throw new Error("Not implemented");
  }
  async sendMessage(msg) {
    return this._monitor.recordMessageSending(msg, async () => {
      await this._clientReady.wait();
      (0, import_invariant2.invariant)(this._state === import_signal.SignalState.CONNECTED, "Not connected to Signal Server", {
        F: __dxlog_file4,
        L: 195,
        S: this,
        A: [
          "this._state === SignalState.CONNECTED",
          "'Not connected to Signal Server'"
        ]
      });
      (0, import_invariant2.invariant)(msg.author.peerKey, "Author key required", {
        F: __dxlog_file4,
        L: 196,
        S: this,
        A: [
          "msg.author.peerKey",
          "'Author key required'"
        ]
      });
      (0, import_invariant2.invariant)(msg.recipient.peerKey, "Recipient key required", {
        F: __dxlog_file4,
        L: 197,
        S: this,
        A: [
          "msg.recipient.peerKey",
          "'Recipient key required'"
        ]
      });
      await this._client.sendMessage({
        author: import_keys2.PublicKey.from(msg.author.peerKey),
        recipient: import_keys2.PublicKey.from(msg.recipient.peerKey),
        payload: msg.payload
      });
    });
  }
  async subscribeMessages(peer) {
    (0, import_invariant2.invariant)(peer.peerKey, "Peer key required", {
      F: __dxlog_file4,
      L: 207,
      S: this,
      A: [
        "peer.peerKey",
        "'Peer key required'"
      ]
    });
    (0, import_log2.log)("subscribing to messages", {
      peer
    }, {
      F: __dxlog_file4,
      L: 208,
      S: this,
      C: (f, a) => f(...a)
    });
    this.localState.subscribeMessages(import_keys2.PublicKey.from(peer.peerKey));
    this._reconcileTask?.schedule();
  }
  async unsubscribeMessages(peer) {
    (0, import_invariant2.invariant)(peer.peerKey, "Peer key required", {
      F: __dxlog_file4,
      L: 214,
      S: this,
      A: [
        "peer.peerKey",
        "'Peer key required'"
      ]
    });
    (0, import_log2.log)("unsubscribing from messages", {
      peer
    }, {
      F: __dxlog_file4,
      L: 215,
      S: this,
      C: (f, a) => f(...a)
    });
    this.localState.unsubscribeMessages(import_keys2.PublicKey.from(peer.peerKey));
  }
  _scheduleReconcileAfterError() {
    (0, import_async2.scheduleTask)(this._ctx, () => this._reconcileTask.schedule(), ERROR_RECONCILE_DELAY);
  }
  _createClient() {
    (0, import_log2.log)("creating client", {
      host: this._host,
      state: this._state
    }, {
      F: __dxlog_file4,
      L: 224,
      S: this,
      C: (f, a) => f(...a)
    });
    (0, import_invariant2.invariant)(!this._client, "Client already created", {
      F: __dxlog_file4,
      L: 225,
      S: this,
      A: [
        "!this._client",
        "'Client already created'"
      ]
    });
    this._monitor.recordConnectionStartTime();
    this._connectionCtx = this._ctx.derive();
    this._connectionCtx.onDispose(async () => {
      (0, import_log2.log)("connection context disposed", void 0, {
        F: __dxlog_file4,
        L: 232,
        S: this,
        C: (f, a) => f(...a)
      });
      const { failureCount } = await this.localState.safeCloseStreams();
      this._monitor.recordStreamCloseErrors(failureCount);
    });
    try {
      const client = new SignalRPCClient({
        url: this._host,
        callbacks: {
          onConnected: () => {
            if (client === this._client) {
              (0, import_log2.log)("socket connected", void 0, {
                F: __dxlog_file4,
                L: 243,
                S: this,
                C: (f, a) => f(...a)
              });
              this._onConnected();
            }
          },
          onDisconnected: () => {
            if (client !== this._client) {
              return;
            }
            (0, import_log2.log)("socket disconnected", {
              state: this._state
            }, {
              F: __dxlog_file4,
              L: 252,
              S: this,
              C: (f, a) => f(...a)
            });
            if (this._state === import_signal.SignalState.ERROR) {
              this._setState(import_signal.SignalState.DISCONNECTED);
            } else {
              this._onDisconnected();
            }
          },
          onError: (error) => {
            if (client === this._client) {
              (0, import_log2.log)("socket error", {
                error,
                state: this._state
              }, {
                F: __dxlog_file4,
                L: 264,
                S: this,
                C: (f, a) => f(...a)
              });
              this._onDisconnected({
                error
              });
            }
          },
          getMetadata: this._getMetadata
        }
      });
      this._client = client;
    } catch (error) {
      this._client = void 0;
      this._onDisconnected({
        error
      });
    }
  }
  async _reconnect() {
    (0, import_log2.log)(`reconnecting in ${this._reconnectAfter}ms`, {
      state: this._state
    }, {
      F: __dxlog_file4,
      L: 279,
      S: this,
      C: (f, a) => f(...a)
    });
    if (this._state === import_signal.SignalState.RECONNECTING) {
      import_log2.log.info("Signal api already reconnecting.", void 0, {
        F: __dxlog_file4,
        L: 282,
        S: this,
        C: (f, a) => f(...a)
      });
      return;
    }
    if (this._state === import_signal.SignalState.CLOSED) {
      return;
    }
    this._setState(import_signal.SignalState.RECONNECTING);
    await this._safeResetClient();
    await (0, import_context2.cancelWithContext)(this._ctx, (0, import_async2.sleep)(this._reconnectAfter));
    this._createClient();
  }
  _onConnected() {
    this._lastError = void 0;
    this._lastReconciliationFailed = false;
    this._reconnectAfter = DEFAULT_RECONNECT_TIMEOUT;
    this._setState(import_signal.SignalState.CONNECTED);
    this._clientReady.wake();
    this._reconcileTask.schedule();
  }
  _onDisconnected(options) {
    this._updateReconnectTimeout();
    if (this._state === import_signal.SignalState.CLOSED) {
      return;
    }
    if (options?.error) {
      this._lastError = options.error;
      this._setState(import_signal.SignalState.ERROR);
    } else {
      this._setState(import_signal.SignalState.DISCONNECTED);
    }
    this._reconnectTask.schedule();
  }
  _setState(newState) {
    this._state = newState;
    this._monitor.recordStateChangeTime();
    (0, import_log2.log)("signal state changed", {
      status: this.getStatus()
    }, {
      F: __dxlog_file4,
      L: 323,
      S: this,
      C: (f, a) => f(...a)
    });
    this.statusChanged.emit(this.getStatus());
  }
  _updateReconnectTimeout() {
    if (this._state !== import_signal.SignalState.CONNECTED && this._state !== import_signal.SignalState.CONNECTING) {
      this._reconnectAfter *= 2;
      this._reconnectAfter = Math.min(this._reconnectAfter, MAX_RECONNECT_TIMEOUT);
    }
  }
  async _safeResetClient() {
    await this._connectionCtx?.dispose();
    this._connectionCtx = void 0;
    this._clientReady.reset();
    await this._client?.close().catch(() => {
    });
    this._client = void 0;
  }
};
var PeerInfoHash = ({ peerKey }) => peerKey;
var __dxlog_file5 = "/home/runner/work/dxos/dxos/packages/core/mesh/messaging/src/signal-manager/memory-signal-manager.ts";
var MemorySignalManagerContext = class {
  constructor() {
    this.swarmEvent = new import_async5.Event();
    this.swarms = new import_util3.ComplexMap(import_keys5.PublicKey.hash);
    this.connections = new import_util3.ComplexMap(PeerInfoHash);
  }
};
var MemorySignalManager = class {
  constructor(_context) {
    this._context = _context;
    this.statusChanged = new import_async5.Event();
    this.swarmEvent = new import_async5.Event();
    this.onMessage = new import_async5.Event();
    this._joinedSwarms = new import_util3.ComplexSet(({ topic, peer }) => topic.toHex() + peer.peerKey);
    this._freezeTrigger = new import_async5.Trigger().wake();
    this._ctx = new import_context5.Context(void 0, {
      F: __dxlog_file5,
      L: 53
    });
    this._ctx.onDispose(this._context.swarmEvent.on((data) => this.swarmEvent.emit(data)));
  }
  async open() {
    if (!this._ctx.disposed) {
      return;
    }
    this._ctx = new import_context5.Context(void 0, {
      F: __dxlog_file5,
      L: 62
    });
    this._ctx.onDispose(this._context.swarmEvent.on((data) => this.swarmEvent.emit(data)));
    await Promise.all([
      ...this._joinedSwarms.values()
    ].map((value) => this.join(value)));
  }
  async close() {
    if (this._ctx.disposed) {
      return;
    }
    const joinedSwarmsCopy = new import_util3.ComplexSet(({ topic, peer }) => topic.toHex() + peer.peerKey, [
      ...this._joinedSwarms.values()
    ]);
    await Promise.all([
      ...this._joinedSwarms.values()
    ].map((value) => this.leave(value)));
    this._joinedSwarms = joinedSwarmsCopy;
    await this._ctx.dispose();
  }
  getStatus() {
    return [];
  }
  async join({ topic, peer }) {
    (0, import_invariant4.invariant)(!this._ctx.disposed, "Closed", {
      F: __dxlog_file5,
      L: 91,
      S: this,
      A: [
        "!this._ctx.disposed",
        "'Closed'"
      ]
    });
    this._joinedSwarms.add({
      topic,
      peer
    });
    if (!this._context.swarms.has(topic)) {
      this._context.swarms.set(topic, new import_util3.ComplexSet(PeerInfoHash));
    }
    this._context.swarms.get(topic).add(peer);
    this._context.swarmEvent.emit({
      topic,
      peerAvailable: {
        peer,
        since: /* @__PURE__ */ new Date()
      }
    });
    for (const [topic2, peers] of this._context.swarms) {
      Array.from(peers).forEach((peer2) => {
        this.swarmEvent.emit({
          topic: topic2,
          peerAvailable: {
            peer: peer2,
            since: /* @__PURE__ */ new Date()
          }
        });
      });
    }
  }
  async leave({ topic, peer }) {
    (0, import_invariant4.invariant)(!this._ctx.disposed, "Closed", {
      F: __dxlog_file5,
      L: 123,
      S: this,
      A: [
        "!this._ctx.disposed",
        "'Closed'"
      ]
    });
    this._joinedSwarms.delete({
      topic,
      peer
    });
    if (!this._context.swarms.has(topic)) {
      this._context.swarms.set(topic, new import_util3.ComplexSet(PeerInfoHash));
    }
    this._context.swarms.get(topic).delete(peer);
    const swarmEvent = {
      topic,
      peerLeft: {
        peer
      }
    };
    this._context.swarmEvent.emit(swarmEvent);
  }
  async query(request) {
    throw new Error("Not implemented");
  }
  async sendMessage({ author, recipient, payload }) {
    (0, import_log5.log)("send message", {
      author,
      recipient,
      ...dec(payload)
    }, {
      F: __dxlog_file5,
      L: 156,
      S: this,
      C: (f, a) => f(...a)
    });
    (0, import_invariant4.invariant)(recipient, void 0, {
      F: __dxlog_file5,
      L: 158,
      S: this,
      A: [
        "recipient",
        ""
      ]
    });
    (0, import_invariant4.invariant)(!this._ctx.disposed, "Closed", {
      F: __dxlog_file5,
      L: 159,
      S: this,
      A: [
        "!this._ctx.disposed",
        "'Closed'"
      ]
    });
    await this._freezeTrigger.wait();
    const remote = this._context.connections.get(recipient);
    if (!remote) {
      import_log5.log.warn("recipient is not subscribed for messages", {
        author,
        recipient
      }, {
        F: __dxlog_file5,
        L: 165,
        S: this,
        C: (f, a) => f(...a)
      });
      return;
    }
    if (remote._ctx.disposed) {
      import_log5.log.warn("recipient is disposed", {
        author,
        recipient
      }, {
        F: __dxlog_file5,
        L: 170,
        S: this,
        C: (f, a) => f(...a)
      });
      return;
    }
    remote._freezeTrigger.wait().then(() => {
      if (remote._ctx.disposed) {
        import_log5.log.warn("recipient is disposed", {
          author,
          recipient
        }, {
          F: __dxlog_file5,
          L: 178,
          S: this,
          C: (f, a) => f(...a)
        });
        return;
      }
      (0, import_log5.log)("receive message", {
        author,
        recipient,
        ...dec(payload)
      }, {
        F: __dxlog_file5,
        L: 182,
        S: this,
        C: (f, a) => f(...a)
      });
      remote.onMessage.emit({
        author,
        recipient,
        payload
      });
    }).catch((err) => {
      import_log5.log.error("error while waiting for freeze", {
        err
      }, {
        F: __dxlog_file5,
        L: 187,
        S: this,
        C: (f, a) => f(...a)
      });
    });
  }
  async subscribeMessages(peerInfo) {
    (0, import_log5.log)("subscribing", {
      peerInfo
    }, {
      F: __dxlog_file5,
      L: 192,
      S: this,
      C: (f, a) => f(...a)
    });
    this._context.connections.set(peerInfo, this);
  }
  async unsubscribeMessages(peerInfo) {
    (0, import_log5.log)("unsubscribing", {
      peerInfo
    }, {
      F: __dxlog_file5,
      L: 197,
      S: this,
      C: (f, a) => f(...a)
    });
    this._context.connections.delete(peerInfo);
  }
  freeze() {
    this._freezeTrigger.reset();
  }
  unfreeze() {
    this._freezeTrigger.wake();
  }
};
var dec = (payload) => {
  if (!payload.type_url.endsWith("ReliablePayload")) {
    return {};
  }
  const relPayload = import_proto3.schema.getCodecForType("dxos.mesh.messaging.ReliablePayload").decode(payload.value);
  if (typeof relPayload?.payload?.data === "object") {
    return {
      payload: Object.keys(relPayload?.payload?.data)[0],
      sessionId: relPayload?.payload?.sessionId
    };
  }
  return {};
};
var WebsocketSignalManagerMonitor = class {
  recordRateLimitExceeded() {
    import_tracing4.trace.metrics.increment("dxos.mesh.signal.signal-manager.rate-limit-hit", 1);
  }
  recordServerFailure(params) {
    import_tracing4.trace.metrics.increment("dxos.mesh.signal.signal-manager.server-failure", 1, {
      tags: {
        server: params.serverName,
        restarted: params.willRestart
      }
    });
  }
};
function _ts_decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file6 = "/home/runner/work/dxos/dxos/packages/core/mesh/messaging/src/signal-manager/websocket-signal-manager.ts";
var MAX_SERVER_FAILURES = 5;
var WSS_SIGNAL_SERVER_REBOOT_DELAY = 3e3;
var WebsocketSignalManager = class extends import_context6.Resource {
  constructor(_hosts, _getMetadata) {
    super(), this._hosts = _hosts, this._getMetadata = _getMetadata, this._servers = /* @__PURE__ */ new Map(), this._monitor = new WebsocketSignalManagerMonitor(), this.failureCount = /* @__PURE__ */ new Map(), this.statusChanged = new import_async6.Event(), this.swarmEvent = new import_async6.Event(), this.onMessage = new import_async6.Event(), this._instanceId = import_keys6.PublicKey.random().toHex();
    (0, import_log6.log)("Created WebsocketSignalManager", {
      hosts: this._hosts
    }, {
      F: __dxlog_file6,
      L: 58,
      S: this,
      C: (f, a) => f(...a)
    });
    for (const host of this._hosts) {
      if (this._servers.has(host.server)) {
        continue;
      }
      const server = new SignalClient(host.server, this._getMetadata);
      server.swarmEvent.on((data) => this.swarmEvent.emit(data));
      server.onMessage.on((data) => this.onMessage.emit(data));
      server.statusChanged.on(() => this.statusChanged.emit(this.getStatus()));
      this._servers.set(host.server, server);
      this.failureCount.set(host.server, 0);
    }
    this._failedServersBitfield = import_util4.BitField.zeros(this._hosts.length);
  }
  async _open() {
    (0, import_log6.log)("open signal manager", {
      hosts: this._hosts
    }, {
      F: __dxlog_file6,
      L: 78,
      S: this,
      C: (f, a) => f(...a)
    });
    import_log6.log.trace("dxos.mesh.websocket-signal-manager.open", import_protocols4.trace.begin({
      id: this._instanceId
    }), {
      F: __dxlog_file6,
      L: 79,
      S: this,
      C: (f, a) => f(...a)
    });
    await (0, import_util4.safeAwaitAll)(this._servers.values(), (server) => server.open());
    import_log6.log.trace("dxos.mesh.websocket-signal-manager.open", import_protocols4.trace.end({
      id: this._instanceId
    }), {
      F: __dxlog_file6,
      L: 83,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  async _close() {
    await (0, import_util4.safeAwaitAll)(this._servers.values(), (server) => server.close());
  }
  async restartServer(serverName) {
    (0, import_log6.log)("restarting server", {
      serverName
    }, {
      F: __dxlog_file6,
      L: 91,
      S: this,
      C: (f, a) => f(...a)
    });
    (0, import_invariant5.invariant)(this._lifecycleState === import_context6.LifecycleState.OPEN, void 0, {
      F: __dxlog_file6,
      L: 92,
      S: this,
      A: [
        "this._lifecycleState === LifecycleState.OPEN",
        ""
      ]
    });
    const server = this._servers.get(serverName);
    (0, import_invariant5.invariant)(server, "server not found", {
      F: __dxlog_file6,
      L: 95,
      S: this,
      A: [
        "server",
        "'server not found'"
      ]
    });
    await server.close();
    await (0, import_async6.sleep)(WSS_SIGNAL_SERVER_REBOOT_DELAY);
    await server.open();
  }
  getStatus() {
    return Array.from(this._servers.values()).map((server) => server.getStatus());
  }
  async join({ topic, peer }) {
    (0, import_log6.log)("join", {
      topic,
      peer
    }, {
      F: __dxlog_file6,
      L: 108,
      S: this,
      C: (f, a) => f(...a)
    });
    (0, import_invariant5.invariant)(this._lifecycleState === import_context6.LifecycleState.OPEN, void 0, {
      F: __dxlog_file6,
      L: 109,
      S: this,
      A: [
        "this._lifecycleState === LifecycleState.OPEN",
        ""
      ]
    });
    await this._forEachServer((server) => server.join({
      topic,
      peer
    }));
  }
  async leave({ topic, peer }) {
    (0, import_log6.log)("leaving", {
      topic,
      peer
    }, {
      F: __dxlog_file6,
      L: 115,
      S: this,
      C: (f, a) => f(...a)
    });
    (0, import_invariant5.invariant)(this._lifecycleState === import_context6.LifecycleState.OPEN, void 0, {
      F: __dxlog_file6,
      L: 116,
      S: this,
      A: [
        "this._lifecycleState === LifecycleState.OPEN",
        ""
      ]
    });
    await this._forEachServer((server) => server.leave({
      topic,
      peer
    }));
  }
  async query({ topic }) {
    throw new Error("Not implemented");
  }
  async sendMessage({ author, recipient, payload }) {
    (0, import_log6.log)("signal", {
      recipient
    }, {
      F: __dxlog_file6,
      L: 125,
      S: this,
      C: (f, a) => f(...a)
    });
    (0, import_invariant5.invariant)(this._lifecycleState === import_context6.LifecycleState.OPEN, void 0, {
      F: __dxlog_file6,
      L: 126,
      S: this,
      A: [
        "this._lifecycleState === LifecycleState.OPEN",
        ""
      ]
    });
    void this._forEachServer(async (server, serverName, index) => {
      void server.sendMessage({
        author,
        recipient,
        payload
      }).then(() => this._clearServerFailedFlag(serverName, index)).catch((err) => {
        if (err instanceof import_protocols4.RateLimitExceededError) {
          import_log6.log.info("WSS rate limit exceeded", {
            err
          }, {
            F: __dxlog_file6,
            L: 134,
            S: this,
            C: (f, a) => f(...a)
          });
          this._monitor.recordRateLimitExceeded();
        } else if (err instanceof import_protocols4.TimeoutError || err.constructor.name === "TimeoutError") {
          import_log6.log.info("WSS sendMessage timeout", {
            err
          }, {
            F: __dxlog_file6,
            L: 137,
            S: this,
            C: (f, a) => f(...a)
          });
          void this.checkServerFailure(serverName, index);
        } else {
          import_log6.log.warn(`error sending to ${serverName}`, {
            err
          }, {
            F: __dxlog_file6,
            L: 140,
            S: this,
            C: (f, a) => f(...a)
          });
          void this.checkServerFailure(serverName, index);
        }
      });
    });
  }
  async checkServerFailure(serverName, index) {
    const failureCount = this.failureCount.get(serverName) ?? 0;
    const isRestartRequired = failureCount > MAX_SERVER_FAILURES;
    this._monitor.recordServerFailure({
      serverName,
      willRestart: isRestartRequired
    });
    if (isRestartRequired) {
      if (!import_util4.BitField.get(this._failedServersBitfield, index)) {
        import_log6.log.warn("too many failures for ws-server, restarting", {
          serverName,
          failureCount
        }, {
          F: __dxlog_file6,
          L: 154,
          S: this,
          C: (f, a) => f(...a)
        });
        import_util4.BitField.set(this._failedServersBitfield, index, true);
      }
      await this.restartServer(serverName);
      this.failureCount.set(serverName, 0);
      return;
    }
    this.failureCount.set(serverName, (this.failureCount.get(serverName) ?? 0) + 1);
  }
  _clearServerFailedFlag(serverName, index) {
    if (import_util4.BitField.get(this._failedServersBitfield, index)) {
      import_log6.log.info("server connection restored", {
        serverName
      }, {
        F: __dxlog_file6,
        L: 167,
        S: this,
        C: (f, a) => f(...a)
      });
      import_util4.BitField.set(this._failedServersBitfield, index, false);
      this.failureCount.set(serverName, 0);
    }
  }
  async subscribeMessages(peer) {
    (0, import_log6.log)("subscribed for message stream", {
      peer
    }, {
      F: __dxlog_file6,
      L: 174,
      S: this,
      C: (f, a) => f(...a)
    });
    (0, import_invariant5.invariant)(this._lifecycleState === import_context6.LifecycleState.OPEN, void 0, {
      F: __dxlog_file6,
      L: 175,
      S: this,
      A: [
        "this._lifecycleState === LifecycleState.OPEN",
        ""
      ]
    });
    await this._forEachServer(async (server) => server.subscribeMessages(peer));
  }
  async unsubscribeMessages(peer) {
    (0, import_log6.log)("subscribed for message stream", {
      peer
    }, {
      F: __dxlog_file6,
      L: 181,
      S: this,
      C: (f, a) => f(...a)
    });
    (0, import_invariant5.invariant)(this._lifecycleState === import_context6.LifecycleState.OPEN, void 0, {
      F: __dxlog_file6,
      L: 182,
      S: this,
      A: [
        "this._lifecycleState === LifecycleState.OPEN",
        ""
      ]
    });
    await this._forEachServer(async (server) => server.unsubscribeMessages(peer));
  }
  async _forEachServer(fn) {
    return Promise.all(Array.from(this._servers.entries()).map(([serverName, server], idx) => fn(server, serverName, idx)));
  }
};
_ts_decorate([
  import_async6.synchronized
], WebsocketSignalManager.prototype, "join", null);
_ts_decorate([
  import_async6.synchronized
], WebsocketSignalManager.prototype, "leave", null);
_ts_decorate([
  import_async6.synchronized
], WebsocketSignalManager.prototype, "checkServerFailure", null);
var __dxlog_file7 = "/home/runner/work/dxos/dxos/packages/core/mesh/messaging/src/signal-manager/edge-signal-manager.ts";
var EdgeSignalManager = class extends import_context7.Resource {
  constructor({ edgeConnection }) {
    super();
    this.swarmEvent = new import_async7.Event();
    this.swarmState = new import_async7.Event();
    this.onMessage = new import_async7.Event();
    this._swarmPeers = new import_util5.ComplexMap(import_keys7.PublicKey.hash);
    this._edgeConnection = edgeConnection;
  }
  async _open() {
    this._ctx.onDispose(this._edgeConnection.onMessage((message) => this._onMessage(message)));
    this._ctx.onDispose(this._edgeConnection.onReconnected(() => {
      (0, import_async7.scheduleMicroTask)(this._ctx, () => this._rejoinAllSwarms());
    }));
  }
  /**
  * Warning: PeerInfo is inferred from edgeConnection.
  */
  async join({ topic, peer }) {
    if (!this._matchSelfPeerInfo(peer)) {
      import_log7.log.warn("ignoring peer info on join request", {
        peer,
        expected: {
          peerKey: this._edgeConnection.peerKey,
          identityKey: this._edgeConnection.identityKey
        }
      }, {
        F: __dxlog_file7,
        L: 65,
        S: this,
        C: (f, a) => f(...a)
      });
      peer.identityKey = this._edgeConnection.identityKey;
      peer.peerKey = this._edgeConnection.peerKey;
    }
    this._swarmPeers.set(topic, {
      lastState: peer.state,
      joinedPeers: new import_util5.ComplexSet(PeerInfoHash)
    });
    await this._edgeConnection.send(import_edge_client.protocol.createMessage(import_messenger_pb.SwarmRequestSchema, {
      serviceId: import_protocols5.EdgeService.SWARM,
      source: createMessageSource(topic, peer),
      payload: {
        action: import_messenger_pb.SwarmRequest_Action.JOIN,
        swarmKeys: [
          topic.toHex()
        ]
      }
    }));
  }
  async leave({ topic, peer }) {
    this._swarmPeers.delete(topic);
    await this._edgeConnection.send(import_edge_client.protocol.createMessage(import_messenger_pb.SwarmRequestSchema, {
      serviceId: import_protocols5.EdgeService.SWARM,
      source: createMessageSource(topic, peer),
      payload: {
        action: import_messenger_pb.SwarmRequest_Action.LEAVE,
        swarmKeys: [
          topic.toHex()
        ]
      }
    }));
  }
  async query({ topic }) {
    const response = (0, import_context7.cancelWithContext)(this._ctx, this.swarmState.waitFor((state) => state.swarmKey === topic.toHex()));
    await this._edgeConnection.send(import_edge_client.protocol.createMessage(import_messenger_pb.SwarmRequestSchema, {
      serviceId: import_protocols5.EdgeService.SWARM,
      source: createMessageSource(topic, {
        peerKey: this._edgeConnection.peerKey,
        identityKey: this._edgeConnection.identityKey
      }),
      payload: {
        action: import_messenger_pb.SwarmRequest_Action.INFO,
        swarmKeys: [
          topic.toHex()
        ]
      }
    }));
    return response;
  }
  async sendMessage(message) {
    if (!this._matchSelfPeerInfo(message.author)) {
      import_log7.log.warn("ignoring author on send request", {
        author: message.author,
        expected: {
          peerKey: this._edgeConnection.peerKey,
          identityKey: this._edgeConnection.identityKey
        }
      }, {
        F: __dxlog_file7,
        L: 121,
        S: this,
        C: (f, a) => f(...a)
      });
    }
    await this._edgeConnection.send(import_edge_client.protocol.createMessage(import_buf.bufWkt.AnySchema, {
      serviceId: import_protocols5.EdgeService.SIGNAL,
      source: message.author,
      target: [
        message.recipient
      ],
      payload: {
        typeUrl: message.payload.type_url,
        value: message.payload.value
      }
    }));
  }
  async subscribeMessages(peerInfo) {
  }
  async unsubscribeMessages(peerInfo) {
  }
  _onMessage(message) {
    switch (message.serviceId) {
      case import_protocols5.EdgeService.SWARM: {
        this._processSwarmResponse(message);
        break;
      }
      case import_protocols5.EdgeService.SIGNAL: {
        this._processMessage(message);
      }
    }
  }
  _processSwarmResponse(message) {
    (0, import_invariant6.invariant)(import_edge_client.protocol.getPayloadType(message) === import_messenger_pb.SwarmResponseSchema.typeName, "Wrong payload type", {
      F: __dxlog_file7,
      L: 158,
      S: this,
      A: [
        "protocol.getPayloadType(message) === SwarmResponseSchema.typeName",
        "'Wrong payload type'"
      ]
    });
    const payload = import_edge_client.protocol.getPayload(message, import_messenger_pb.SwarmResponseSchema);
    this.swarmState.emit(payload);
    const topic = import_keys7.PublicKey.from(payload.swarmKey);
    if (!this._swarmPeers.has(topic)) {
      return;
    }
    const { joinedPeers: oldPeers } = this._swarmPeers.get(topic);
    const timestamp = message.timestamp ? new Date(Date.parse(message.timestamp)) : /* @__PURE__ */ new Date();
    const newPeers = new import_util5.ComplexSet(PeerInfoHash, payload.peers);
    for (const peer of newPeers) {
      if (oldPeers.has(peer)) {
        continue;
      }
      this.swarmEvent.emit({
        topic,
        peerAvailable: {
          peer,
          since: timestamp
        }
      });
    }
    for (const peer of oldPeers) {
      if (newPeers.has(peer)) {
        continue;
      }
      this.swarmEvent.emit({
        topic,
        peerLeft: {
          peer
        }
      });
    }
    this._swarmPeers.get(topic).joinedPeers = newPeers;
  }
  _processMessage(message) {
    (0, import_invariant6.invariant)(import_edge_client.protocol.getPayloadType(message) === import_buf.bufWkt.AnySchema.typeName, "Wrong payload type", {
      F: __dxlog_file7,
      L: 196,
      S: this,
      A: [
        "protocol.getPayloadType(message) === bufWkt.AnySchema.typeName",
        "'Wrong payload type'"
      ]
    });
    const payload = import_edge_client.protocol.getPayload(message, import_buf.bufWkt.AnySchema);
    (0, import_invariant6.invariant)(message.source, "source is missing", {
      F: __dxlog_file7,
      L: 198,
      S: this,
      A: [
        "message.source",
        "'source is missing'"
      ]
    });
    (0, import_invariant6.invariant)(message.target, "target is missing", {
      F: __dxlog_file7,
      L: 199,
      S: this,
      A: [
        "message.target",
        "'target is missing'"
      ]
    });
    (0, import_invariant6.invariant)(message.target.length === 1, "target should have exactly one item", {
      F: __dxlog_file7,
      L: 200,
      S: this,
      A: [
        "message.target.length === 1",
        "'target should have exactly one item'"
      ]
    });
    this.onMessage.emit({
      author: message.source,
      recipient: message.target[0],
      payload: {
        type_url: payload.typeUrl,
        value: payload.value
      }
    });
  }
  _matchSelfPeerInfo(peer) {
    return peer && (peer.peerKey === this._edgeConnection.peerKey || peer.identityKey === this._edgeConnection.identityKey);
  }
  async _rejoinAllSwarms() {
    (0, import_log7.log)("rejoin swarms", {
      swarms: Array.from(this._swarmPeers.keys())
    }, {
      F: __dxlog_file7,
      L: 219,
      S: this,
      C: (f, a) => f(...a)
    });
    for (const [topic, { lastState }] of this._swarmPeers.entries()) {
      await this.join({
        topic,
        peer: {
          peerKey: this._edgeConnection.peerKey,
          identityKey: this._edgeConnection.identityKey,
          state: lastState
        }
      });
    }
  }
};
var createMessageSource = (topic, peerInfo) => {
  return {
    swarmKey: topic.toHex(),
    ...peerInfo
  };
};
var __dxlog_file8 = "/home/runner/work/dxos/dxos/packages/core/mesh/messaging/src/signal-manager/utils.ts";
var setIdentityTags = ({ identityService, devicesService, setTag }) => {
  identityService.queryIdentity().subscribe((idqr) => {
    if (!idqr?.identity?.identityKey) {
      (0, import_log8.log)("empty response from identity service", {
        idqr
      }, {
        F: __dxlog_file8,
        L: 21,
        S: void 0,
        C: (f, a) => f(...a)
      });
      return;
    }
    setTag("identityKey", idqr.identity.identityKey.truncate());
  });
  devicesService.queryDevices().subscribe((dqr) => {
    if (!dqr || !dqr.devices || dqr.devices.length === 0) {
      (0, import_log8.log)("empty response from device service", {
        device: dqr
      }, {
        F: __dxlog_file8,
        L: 30,
        S: void 0,
        C: (f, a) => f(...a)
      });
      return;
    }
    (0, import_invariant7.invariant)(dqr, "empty response from device service", {
      F: __dxlog_file8,
      L: 33,
      S: void 0,
      A: [
        "dqr",
        "'empty response from device service'"
      ]
    });
    const thisDevice = dqr.devices.find((device) => device.kind === import_services.DeviceKind.CURRENT);
    if (!thisDevice) {
      (0, import_log8.log)("no current device", {
        device: dqr
      }, {
        F: __dxlog_file8,
        L: 37,
        S: void 0,
        C: (f, a) => f(...a)
      });
      return;
    }
    setTag("deviceKey", thisDevice.deviceKey.truncate());
  });
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  EdgeSignalManager,
  MemorySignalManager,
  MemorySignalManagerContext,
  Messenger,
  PeerInfoHash,
  SignalClient,
  WebsocketSignalManager,
  setIdentityTags
});
//# sourceMappingURL=chunk-GMND65DN.cjs.map
