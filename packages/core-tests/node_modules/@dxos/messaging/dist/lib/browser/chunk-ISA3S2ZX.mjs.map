{
  "version": 3,
  "sources": ["../../../src/messenger.ts", "../../../src/messenger-monitor.ts", "../../../src/timeouts.ts", "../../../src/signal-client/signal-client.ts", "../../../src/signal-client/signal-client-monitor.ts", "../../../src/signal-client/signal-local-state.ts", "../../../src/signal-client/signal-rpc-client.ts", "../../../src/signal-client/signal-rpc-client-monitor.ts", "../../../src/signal-methods.ts", "../../../src/signal-manager/memory-signal-manager.ts", "../../../src/signal-manager/websocket-signal-manager.ts", "../../../src/signal-manager/websocket-signal-manager-monitor.ts", "../../../src/signal-manager/edge-signal-manager.ts", "../../../src/signal-manager/utils.ts"],
  "sourcesContent": ["//\n// Copyright 2022 DXOS.org\n//\n\nimport { TimeoutError, scheduleExponentialBackoffTaskInterval, scheduleTask, scheduleTaskInterval } from '@dxos/async';\nimport { type Any } from '@dxos/codec-protobuf';\nimport { Context } from '@dxos/context';\nimport { invariant } from '@dxos/invariant';\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { TimeoutError as ProtocolTimeoutError, trace } from '@dxos/protocols';\nimport { schema } from '@dxos/protocols/proto';\nimport { type ReliablePayload } from '@dxos/protocols/proto/dxos/mesh/messaging';\nimport { ComplexMap, ComplexSet } from '@dxos/util';\n\nimport { MessengerMonitor } from './messenger-monitor';\nimport { type SignalManager } from './signal-manager';\nimport { type PeerInfo, type Message } from './signal-methods';\nimport { MESSAGE_TIMEOUT } from './timeouts';\n\nexport type OnMessage = (params: Message) => Promise<void>;\n\nexport interface MessengerOptions {\n  signalManager: SignalManager;\n  retryDelay?: number;\n}\n\nconst ReliablePayload = schema.getCodecForType('dxos.mesh.messaging.ReliablePayload');\nconst Acknowledgement = schema.getCodecForType('dxos.mesh.messaging.Acknowledgement');\n\nconst RECEIVED_MESSAGES_GC_INTERVAL = 120_000;\n\n/**\n * Reliable messenger that works trough signal network.\n */\nexport class Messenger {\n  private readonly _monitor = new MessengerMonitor();\n  private readonly _signalManager: SignalManager;\n  // { peerId, payloadType } => listeners set\n  private readonly _listeners = new ComplexMap<{ peerId: string; payloadType: string }, Set<OnMessage>>(\n    ({ peerId, payloadType }) => peerId + payloadType,\n  );\n\n  // peerId => listeners set\n  private readonly _defaultListeners = new Map<string, Set<OnMessage>>();\n\n  private readonly _onAckCallbacks = new ComplexMap<PublicKey, () => void>(PublicKey.hash);\n\n  private readonly _receivedMessages = new ComplexSet<PublicKey>(PublicKey.hash);\n\n  /**\n   * Keys scheduled to be cleared from _receivedMessages on the next iteration.\n   */\n  private readonly _toClear = new ComplexSet<PublicKey>(PublicKey.hash);\n\n  private _ctx!: Context;\n  private _closed = true;\n  private readonly _retryDelay: number;\n\n  constructor({ signalManager, retryDelay = 1000 }: MessengerOptions) {\n    this._signalManager = signalManager;\n    this._retryDelay = retryDelay;\n\n    this.open();\n  }\n\n  open(): void {\n    if (!this._closed) {\n      return;\n    }\n    const traceId = PublicKey.random().toHex();\n    log.trace('dxos.mesh.messenger.open', trace.begin({ id: traceId }));\n    this._ctx = new Context({\n      onError: (err) => log.catch(err),\n    });\n    this._ctx.onDispose(\n      this._signalManager.onMessage.on(async (message) => {\n        log('received message', { from: message.author });\n        await this._handleMessage(message);\n      }),\n    );\n\n    // Clear the map periodically.\n    scheduleTaskInterval(\n      this._ctx,\n      async () => {\n        this._performGc();\n      },\n      RECEIVED_MESSAGES_GC_INTERVAL,\n    );\n\n    this._closed = false;\n    log.trace('dxos.mesh.messenger.open', trace.end({ id: traceId }));\n  }\n\n  async close(): Promise<void> {\n    if (this._closed) {\n      return;\n    }\n    this._closed = true;\n    await this._ctx.dispose();\n  }\n\n  async sendMessage({ author, recipient, payload }: Message): Promise<void> {\n    invariant(!this._closed, 'Closed');\n    const messageContext = this._ctx.derive();\n\n    const reliablePayload: ReliablePayload = {\n      messageId: PublicKey.random(),\n      payload,\n    };\n    invariant(!this._onAckCallbacks.has(reliablePayload.messageId!));\n    log('send message', { messageId: reliablePayload.messageId, author, recipient });\n\n    let messageReceived: () => void;\n    let timeoutHit: (err: Error) => void;\n    let sendAttempts = 0;\n\n    const promise = new Promise<void>((resolve, reject) => {\n      messageReceived = resolve;\n      timeoutHit = reject;\n    });\n\n    // Setting retry interval if signal was not acknowledged.\n    scheduleExponentialBackoffTaskInterval(\n      messageContext,\n      async () => {\n        log('retrying message', { messageId: reliablePayload.messageId });\n        sendAttempts++;\n        await this._encodeAndSend({ author, recipient, reliablePayload }).catch((err) =>\n          log('failed to send message', { err }),\n        );\n      },\n      this._retryDelay,\n    );\n\n    scheduleTask(\n      messageContext,\n      () => {\n        log('message not delivered', { messageId: reliablePayload.messageId });\n        this._onAckCallbacks.delete(reliablePayload.messageId!);\n        timeoutHit(\n          new ProtocolTimeoutError(\n            'signaling message not delivered',\n            new TimeoutError(MESSAGE_TIMEOUT, 'Message not delivered'),\n          ),\n        );\n        void messageContext.dispose();\n        this._monitor.recordReliableMessage({ sendAttempts, sent: false });\n      },\n      MESSAGE_TIMEOUT,\n    );\n\n    this._onAckCallbacks.set(reliablePayload.messageId, () => {\n      messageReceived();\n      this._onAckCallbacks.delete(reliablePayload.messageId!);\n      void messageContext.dispose();\n      this._monitor.recordReliableMessage({ sendAttempts, sent: true });\n    });\n\n    await this._encodeAndSend({ author, recipient, reliablePayload });\n    return promise;\n  }\n\n  /**\n   * Subscribes onMessage function to messages that contains payload with payloadType.\n   * @param payloadType if not specified, onMessage will be subscribed to all types of messages.\n   */\n  async listen({\n    peer,\n    payloadType,\n    onMessage,\n  }: {\n    peer: PeerInfo;\n    payloadType?: string;\n    onMessage: OnMessage;\n  }): Promise<ListeningHandle> {\n    invariant(!this._closed, 'Closed');\n\n    await this._signalManager.subscribeMessages(peer);\n    let listeners: Set<OnMessage> | undefined;\n    invariant(peer.peerKey, 'Peer key is required');\n\n    if (!payloadType) {\n      listeners = this._defaultListeners.get(peer.peerKey);\n      if (!listeners) {\n        listeners = new Set();\n        this._defaultListeners.set(peer.peerKey, listeners);\n      }\n    } else {\n      listeners = this._listeners.get({ peerId: peer.peerKey, payloadType });\n      if (!listeners) {\n        listeners = new Set();\n        this._listeners.set({ peerId: peer.peerKey, payloadType }, listeners);\n      }\n    }\n\n    listeners.add(onMessage);\n\n    return {\n      unsubscribe: async () => {\n        listeners!.delete(onMessage);\n      },\n    };\n  }\n\n  private async _encodeAndSend({\n    author,\n    recipient,\n    reliablePayload,\n  }: {\n    author: PeerInfo;\n    recipient: PeerInfo;\n    reliablePayload: ReliablePayload;\n  }): Promise<void> {\n    await this._signalManager.sendMessage({\n      author,\n      recipient,\n      payload: {\n        type_url: 'dxos.mesh.messaging.ReliablePayload',\n        value: ReliablePayload.encode(reliablePayload, { preserveAny: true }),\n      },\n    });\n  }\n\n  private async _handleMessage(message: Message): Promise<void> {\n    switch (message.payload.type_url) {\n      case 'dxos.mesh.messaging.ReliablePayload': {\n        await this._handleReliablePayload(message);\n        break;\n      }\n      case 'dxos.mesh.messaging.Acknowledgement': {\n        await this._handleAcknowledgement({ payload: message.payload });\n        break;\n      }\n    }\n  }\n\n  private async _handleReliablePayload({ author, recipient, payload }: Message): Promise<void> {\n    invariant(payload.type_url === 'dxos.mesh.messaging.ReliablePayload');\n    const reliablePayload: ReliablePayload = ReliablePayload.decode(payload.value, { preserveAny: true });\n\n    log('handling message', { messageId: reliablePayload.messageId });\n\n    try {\n      await this._sendAcknowledgement({\n        author,\n        recipient,\n        messageId: reliablePayload.messageId,\n      });\n    } catch (err) {\n      this._monitor.recordMessageAckFailed();\n      throw err;\n    }\n\n    // Ignore message if it was already received, i.e. from multiple signal servers.\n    if (this._receivedMessages.has(reliablePayload.messageId!)) {\n      return;\n    }\n\n    this._receivedMessages.add(reliablePayload.messageId!);\n\n    await this._callListeners({\n      author,\n      recipient,\n      payload: reliablePayload.payload,\n    });\n  }\n\n  private async _handleAcknowledgement({ payload }: { payload: Any }): Promise<void> {\n    invariant(payload.type_url === 'dxos.mesh.messaging.Acknowledgement');\n    this._onAckCallbacks.get(Acknowledgement.decode(payload.value).messageId)?.();\n  }\n\n  private async _sendAcknowledgement({\n    author,\n    recipient,\n    messageId,\n  }: {\n    author: PeerInfo;\n    recipient: PeerInfo;\n    messageId: PublicKey;\n  }): Promise<void> {\n    log('sending ACK', { messageId, from: recipient, to: author });\n\n    await this._signalManager.sendMessage({\n      author: recipient,\n      recipient: author,\n      payload: {\n        type_url: 'dxos.mesh.messaging.Acknowledgement',\n        value: Acknowledgement.encode({ messageId }),\n      },\n    });\n  }\n\n  private async _callListeners(message: Message): Promise<void> {\n    {\n      invariant(message.recipient.peerKey, 'Peer key is required');\n      const defaultListenerMap = this._defaultListeners.get(message.recipient.peerKey);\n      if (defaultListenerMap) {\n        for (const listener of defaultListenerMap) {\n          await listener(message);\n        }\n      }\n    }\n\n    {\n      const listenerMap = this._listeners.get({\n        peerId: message.recipient.peerKey,\n        payloadType: message.payload.type_url,\n      });\n      if (listenerMap) {\n        for (const listener of listenerMap) {\n          await listener(message);\n        }\n      }\n    }\n  }\n\n  private _performGc(): void {\n    const start = performance.now();\n\n    for (const key of this._toClear.keys()) {\n      this._receivedMessages.delete(key);\n    }\n    this._toClear.clear();\n    for (const key of this._receivedMessages.keys()) {\n      this._toClear.add(key);\n    }\n\n    const elapsed = performance.now() - start;\n    if (elapsed > 100) {\n      log.warn('GC took too long', { elapsed });\n    }\n  }\n}\n\nexport interface ListeningHandle {\n  unsubscribe: () => Promise<void>;\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { trace } from '@dxos/tracing';\n\nexport class MessengerMonitor {\n  public recordMessageAckFailed(): void {\n    trace.metrics.increment('dxos.mesh.signal.messenger.failed-ack', 1);\n  }\n\n  public recordReliableMessage(params: { sendAttempts: number; sent: boolean }): void {\n    trace.metrics.increment('dxos.mesh.signal.messenger.reliable-send', 1, {\n      tags: {\n        success: params.sent,\n        attempts: params.sendAttempts,\n      },\n    });\n  }\n}\n", "//\n// Copyright 2023 DXOS.org\n//\n\n/**\n * Timeout for retrying messages.\n */\nexport const MESSAGE_TIMEOUT = 10_000;\n", "//\n// Copyright 2020 DXOS.org\n//\n\nimport { DeferredTask, Event, Trigger, scheduleTask, scheduleTaskInterval, sleep } from '@dxos/async';\nimport { type Context, cancelWithContext, Resource } from '@dxos/context';\nimport { invariant } from '@dxos/invariant';\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { trace } from '@dxos/protocols';\nimport { type SwarmResponse } from '@dxos/protocols/proto/dxos/edge/messenger';\nimport { type QueryRequest, type JoinRequest, type LeaveRequest } from '@dxos/protocols/proto/dxos/edge/signal';\nimport { SignalState } from '@dxos/protocols/proto/dxos/mesh/signal';\n\nimport { SignalClientMonitor } from './signal-client-monitor';\nimport { SignalLocalState } from './signal-local-state';\nimport { SignalRPCClient } from './signal-rpc-client';\nimport {\n  type PeerInfo,\n  type Message,\n  type SignalClientMethods,\n  type SignalStatus,\n  type SwarmEvent,\n} from '../signal-methods';\n\nconst DEFAULT_RECONNECT_TIMEOUT = 100;\nconst MAX_RECONNECT_TIMEOUT = 5_000;\nconst ERROR_RECONCILE_DELAY = 1_000;\nconst RECONCILE_INTERVAL = 5_000;\n\n/**\n * KUBE-specific signaling client.\n * Establishes a websocket connection to signal server and provides RPC methods.\n * Subscription state updates are executed immediately against the local state which\n * is reconciled periodically.\n * TODO(mykola): Delete.\n * @deprecated\n */\n// TODO(burdon): Rename impl.\nexport class SignalClient extends Resource implements SignalClientMethods {\n  private readonly _monitor = new SignalClientMonitor();\n\n  private _state = SignalState.CLOSED;\n  private _lastError?: Error;\n  private _lastReconciliationFailed = false;\n\n  private readonly _clientReady = new Trigger();\n  private _connectionCtx?: Context;\n  private _client?: SignalRPCClient;\n\n  private _reconcileTask?: DeferredTask;\n  private _reconnectTask?: DeferredTask;\n\n  /**\n   * Number of milliseconds after which the connection will be attempted again in case of error.\n   */\n  private _reconnectAfter = DEFAULT_RECONNECT_TIMEOUT;\n\n  private readonly _instanceId = PublicKey.random().toHex();\n\n  /**\n   * @internal\n   */\n  readonly localState: SignalLocalState;\n\n  readonly statusChanged = new Event<SignalStatus>();\n\n  public readonly onMessage = new Event<Message>();\n  public readonly swarmEvent = new Event<SwarmEvent>();\n\n  /**\n   * @param _host Signal server websocket URL.\n   * @param onMessage called when a new message is received.\n   * @param onSwarmEvent called when a new swarm event is received.\n   * @param _getMetadata signal-message metadata provider, called for every message.\n   */\n  constructor(\n    private readonly _host: string,\n    private readonly _getMetadata?: () => any,\n  ) {\n    super();\n    if (!this._host.startsWith('wss://') && !this._host.startsWith('ws://')) {\n      throw new Error(`Signal server requires a websocket URL. Provided: ${this._host}`);\n    }\n\n    this.localState = new SignalLocalState(\n      async (message) => {\n        this._monitor.recordMessageReceived(message);\n        this.onMessage.emit(message);\n      },\n      async (event) => this.swarmEvent.emit(event),\n    );\n  }\n\n  protected override async _open(): Promise<void> {\n    log.trace('dxos.mesh.signal-client.open', trace.begin({ id: this._instanceId }));\n\n    if ([SignalState.CONNECTED, SignalState.CONNECTING].includes(this._state)) {\n      return;\n    }\n    this._setState(SignalState.CONNECTING);\n\n    this._reconcileTask = new DeferredTask(this._ctx, async () => {\n      try {\n        await cancelWithContext(this._connectionCtx!, this._clientReady.wait({ timeout: 5_000 }));\n        invariant(this._state === SignalState.CONNECTED, 'Not connected to Signal Server');\n        await this.localState.reconcile(this._connectionCtx!, this._client!);\n        this._monitor.recordReconciliation({ success: true });\n        this._lastReconciliationFailed = false;\n      } catch (err) {\n        this._lastReconciliationFailed = true;\n        this._monitor.recordReconciliation({ success: false });\n        throw err;\n      }\n    });\n\n    // Reconcile subscriptions periodically.\n    scheduleTaskInterval(\n      this._ctx,\n      async () => {\n        if (this._state === SignalState.CONNECTED) {\n          this._reconcileTask!.schedule();\n        }\n      },\n      RECONCILE_INTERVAL,\n    );\n\n    this._reconnectTask = new DeferredTask(this._ctx, async () => {\n      try {\n        await this._reconnect();\n        this._monitor.recordReconnect({ success: true });\n      } catch (err) {\n        this._monitor.recordReconnect({ success: false });\n        throw err;\n      }\n    });\n\n    this._createClient();\n    log.trace('dxos.mesh.signal-client.open', trace.end({ id: this._instanceId }));\n  }\n\n  protected override async _catch(err: Error): Promise<void> {\n    if (this._state === SignalState.CLOSED || this._ctx.disposed) {\n      return;\n    }\n    // Don't log consecutive reconciliation failures.\n    if (this._state === SignalState.CONNECTED && !this._lastReconciliationFailed) {\n      log.warn('SignalClient error:', err);\n    }\n    this._scheduleReconcileAfterError();\n  }\n\n  protected override async _close(): Promise<void> {\n    log('closing...');\n    if ([SignalState.CLOSED].includes(this._state)) {\n      return;\n    }\n\n    this._setState(SignalState.CLOSED);\n    await this._safeResetClient();\n\n    log('closed');\n  }\n\n  getStatus(): SignalStatus {\n    return {\n      host: this._host,\n      state: this._state,\n      error: this._lastError?.message,\n      reconnectIn: this._reconnectAfter,\n      ...this._monitor.getRecordedTimestamps(),\n    };\n  }\n\n  async join(args: JoinRequest): Promise<void> {\n    log('joining', { topic: args.topic, peerId: args.peer.peerKey });\n    this._monitor.recordJoin();\n    this.localState.join({ topic: args.topic, peerId: PublicKey.from(args.peer.peerKey) });\n    this._reconcileTask?.schedule();\n  }\n\n  async leave(args: LeaveRequest): Promise<void> {\n    log('leaving', { topic: args.topic, peerId: args.peer.peerKey });\n    this._monitor.recordLeave();\n    this.localState.leave({ topic: args.topic, peerId: PublicKey.from(args.peer.peerKey) });\n  }\n\n  async query(params: QueryRequest): Promise<SwarmResponse> {\n    throw new Error('Not implemented');\n  }\n\n  async sendMessage(msg: Message): Promise<void> {\n    return this._monitor.recordMessageSending(msg, async () => {\n      await this._clientReady.wait();\n      invariant(this._state === SignalState.CONNECTED, 'Not connected to Signal Server');\n      invariant(msg.author.peerKey, 'Author key required');\n      invariant(msg.recipient.peerKey, 'Recipient key required');\n      await this._client!.sendMessage({\n        author: PublicKey.from(msg.author.peerKey),\n        recipient: PublicKey.from(msg.recipient.peerKey),\n        payload: msg.payload,\n      });\n    });\n  }\n\n  async subscribeMessages(peer: PeerInfo): Promise<void> {\n    invariant(peer.peerKey, 'Peer key required');\n    log('subscribing to messages', { peer });\n    this.localState.subscribeMessages(PublicKey.from(peer.peerKey));\n    this._reconcileTask?.schedule();\n  }\n\n  async unsubscribeMessages(peer: PeerInfo): Promise<void> {\n    invariant(peer.peerKey, 'Peer key required');\n    log('unsubscribing from messages', { peer });\n    this.localState.unsubscribeMessages(PublicKey.from(peer.peerKey));\n  }\n\n  private _scheduleReconcileAfterError(): void {\n    scheduleTask(this._ctx, () => this._reconcileTask!.schedule(), ERROR_RECONCILE_DELAY);\n  }\n\n  private _createClient(): void {\n    log('creating client', { host: this._host, state: this._state });\n    invariant(!this._client, 'Client already created');\n\n    this._monitor.recordConnectionStartTime();\n\n    // Create new context for each connection.\n    this._connectionCtx = this._ctx.derive();\n    this._connectionCtx.onDispose(async () => {\n      log('connection context disposed');\n      const { failureCount } = await this.localState.safeCloseStreams();\n      this._monitor.recordStreamCloseErrors(failureCount);\n    });\n\n    try {\n      const client = new SignalRPCClient({\n        url: this._host,\n        callbacks: {\n          onConnected: () => {\n            if (client === this._client) {\n              log('socket connected');\n              this._onConnected();\n            }\n          },\n\n          onDisconnected: () => {\n            if (client !== this._client) {\n              return;\n            }\n            log('socket disconnected', { state: this._state });\n            if (this._state === SignalState.ERROR) {\n              // Ignore disconnects after error.\n              // Handled by error handler before disconnect handler.\n              this._setState(SignalState.DISCONNECTED);\n            } else {\n              this._onDisconnected();\n            }\n          },\n\n          onError: (error) => {\n            if (client === this._client) {\n              log('socket error', { error, state: this._state });\n              this._onDisconnected({ error });\n            }\n          },\n          getMetadata: this._getMetadata,\n        },\n      });\n      this._client = client;\n    } catch (error: any) {\n      this._client = undefined;\n      this._onDisconnected({ error });\n    }\n  }\n\n  private async _reconnect(): Promise<void> {\n    log(`reconnecting in ${this._reconnectAfter}ms`, { state: this._state });\n\n    if (this._state === SignalState.RECONNECTING) {\n      log.info('Signal api already reconnecting.');\n      return;\n    }\n    if (this._state === SignalState.CLOSED) {\n      return;\n    }\n    this._setState(SignalState.RECONNECTING);\n\n    await this._safeResetClient();\n\n    await cancelWithContext(this._ctx!, sleep(this._reconnectAfter));\n\n    this._createClient();\n  }\n\n  private _onConnected(): void {\n    this._lastError = undefined;\n    this._lastReconciliationFailed = false;\n    this._reconnectAfter = DEFAULT_RECONNECT_TIMEOUT;\n    this._setState(SignalState.CONNECTED);\n    this._clientReady.wake();\n    this._reconcileTask!.schedule();\n  }\n\n  private _onDisconnected(options?: { error: Error }): void {\n    this._updateReconnectTimeout();\n    if (this._state === SignalState.CLOSED) {\n      return;\n    }\n    if (options?.error) {\n      this._lastError = options.error;\n      this._setState(SignalState.ERROR);\n    } else {\n      this._setState(SignalState.DISCONNECTED);\n    }\n    this._reconnectTask!.schedule();\n  }\n\n  private _setState(newState: SignalState): void {\n    this._state = newState;\n    this._monitor.recordStateChangeTime();\n    log('signal state changed', { status: this.getStatus() });\n    this.statusChanged.emit(this.getStatus());\n  }\n\n  private _updateReconnectTimeout(): void {\n    if (this._state !== SignalState.CONNECTED && this._state !== SignalState.CONNECTING) {\n      this._reconnectAfter *= 2;\n      this._reconnectAfter = Math.min(this._reconnectAfter, MAX_RECONNECT_TIMEOUT);\n    }\n  }\n\n  private async _safeResetClient(): Promise<void> {\n    await this._connectionCtx?.dispose();\n    this._connectionCtx = undefined;\n\n    this._clientReady.reset();\n    await this._client?.close().catch(() => {});\n    this._client = undefined;\n  }\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { trace } from '@dxos/tracing';\n\nimport type { Message } from '../signal-methods';\n\nexport class SignalClientMonitor {\n  private readonly _performance = {\n    sentMessages: 0,\n    receivedMessages: 0,\n    reconnectCounter: 0,\n    joinCounter: 0,\n    leaveCounter: 0,\n  };\n\n  /**\n   * Timestamp of when the connection attempt was began.\n   */\n  private _connectionStarted = new Date();\n  /**\n   * Timestamp of last state change.\n   */\n  private _lastStateChange = new Date();\n\n  public getRecordedTimestamps(): { connectionStarted: Date; lastStateChange: Date } {\n    return {\n      connectionStarted: this._connectionStarted,\n      lastStateChange: this._lastStateChange,\n    };\n  }\n\n  public recordStateChangeTime(): void {\n    this._lastStateChange = new Date();\n  }\n\n  public recordConnectionStartTime(): void {\n    this._connectionStarted = new Date();\n  }\n\n  public recordReconnect(params: { success: boolean }): void {\n    this._performance.reconnectCounter++;\n    trace.metrics.increment('dxos.mesh.signal.signal-client.reconnect', 1, {\n      tags: {\n        success: params.success,\n      },\n    });\n  }\n\n  public recordJoin(): void {\n    this._performance.joinCounter++;\n  }\n\n  public recordLeave(): void {\n    this._performance.leaveCounter++;\n  }\n\n  public recordMessageReceived(message: Message): void {\n    this._performance.receivedMessages++;\n    trace.metrics.increment('dxos.mesh.signal.signal-client.received-total', 1, {\n      tags: createIdentityTags(message),\n    });\n    trace.metrics.distribution('dxos.mesh.signal.signal-client.bytes-in', getByteCount(message), {\n      tags: createIdentityTags(message),\n    });\n  }\n\n  public async recordMessageSending(message: Message, sendMessage: () => Promise<void>): Promise<void> {\n    this._performance.sentMessages++;\n    const tags = createIdentityTags(message);\n    let success = true;\n    try {\n      const reqStart = Date.now();\n      await sendMessage();\n      const reqDuration = Date.now() - reqStart;\n      trace.metrics.distribution('dxos.mesh.signal.signal-client.send-duration', reqDuration, { tags });\n      trace.metrics.distribution('dxos.mesh.signal.signal-client.bytes-out', getByteCount(message), { tags });\n    } catch (err) {\n      success = false;\n    }\n    trace.metrics.increment('dxos.mesh.signal.signal-client.sent-total', 1, {\n      tags: { ...tags, success },\n    });\n  }\n\n  public recordStreamCloseErrors(count: number): void {\n    trace.metrics.increment('dxos.mesh.signal.signal-client.stream-close-errors', count);\n  }\n\n  public recordReconciliation(params: { success: boolean }): void {\n    trace.metrics.increment('dxos.mesh.signal.signal-client.reconciliation', 1, {\n      tags: {\n        success: params.success,\n      },\n    });\n  }\n}\n\nconst getByteCount = (message: Message): number => {\n  return (\n    message.author.peerKey.length +\n    message.recipient.peerKey.length +\n    message.payload.type_url.length +\n    message.payload.value.length\n  );\n};\n\nconst createIdentityTags = (message: Message) => {\n  return { peer: message.author.peerKey };\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { asyncTimeout, Event } from '@dxos/async';\nimport type { Stream } from '@dxos/codec-protobuf/stream';\nimport { cancelWithContext, type Context } from '@dxos/context';\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport {\n  type Message as SignalMessage,\n  type SwarmEvent as SwarmEventProto,\n} from '@dxos/protocols/proto/dxos/mesh/signal';\nimport { ComplexMap, ComplexSet, safeAwaitAll } from '@dxos/util';\n\nimport { type SignalRPCClient } from './signal-rpc-client';\nimport type { Message, SwarmEvent } from '../signal-methods';\n\nexport class SignalLocalState {\n  /**\n   * Swarm events streams. Keys represent actually joined topic and peerId.\n   */\n  private readonly _swarmStreams = new ComplexMap<{ topic: PublicKey; peerId: PublicKey }, Stream<SwarmEventProto>>(\n    ({ topic, peerId }) => topic.toHex() + peerId.toHex(),\n  );\n\n  /**\n   * Represent desired joined topic and peerId.\n   */\n  private readonly _joinedTopics = new ComplexSet<{ topic: PublicKey; peerId: PublicKey }>(\n    ({ topic, peerId }) => topic.toHex() + peerId.toHex(),\n  );\n\n  /**\n   * Represent desired message subscriptions.\n   */\n  private readonly _subscribedMessages = new ComplexSet<{ peerId: PublicKey }>(({ peerId }) => peerId.toHex());\n\n  /**\n   * Message streams. Keys represents actually subscribed peers.\n   * @internal\n   */\n  readonly messageStreams = new ComplexMap<PublicKey, Stream<SignalMessage>>((key) => key.toHex());\n\n  /**\n   * Event to use in tests to wait till subscription is successfully established.\n   * @internal\n   */\n  readonly reconciled = new Event();\n\n  constructor(\n    private readonly _onMessage: (params: Message) => Promise<void>,\n    private readonly _onSwarmEvent: (params: SwarmEvent) => Promise<void>,\n  ) {}\n\n  async safeCloseStreams(): Promise<{ failureCount: number }> {\n    const streams = ([...this._swarmStreams.values()] as Stream<any>[]).concat([...this.messageStreams.values()]);\n    this._swarmStreams.clear();\n    this.messageStreams.clear();\n    const failureCount = (await safeAwaitAll(streams, (s) => s.close())).length;\n    return { failureCount };\n  }\n\n  join({ topic, peerId }: { topic: PublicKey; peerId: PublicKey }): void {\n    this._joinedTopics.add({ topic, peerId });\n  }\n\n  leave({ topic, peerId }: { topic: PublicKey; peerId: PublicKey }): void {\n    void this._swarmStreams.get({ topic, peerId })?.close();\n    this._swarmStreams.delete({ topic, peerId });\n    this._joinedTopics.delete({ topic, peerId });\n  }\n\n  subscribeMessages(peerId: PublicKey): void {\n    this._subscribedMessages.add({ peerId });\n  }\n\n  unsubscribeMessages(peerId: PublicKey): void {\n    log('unsubscribing from messages', { peerId });\n    this._subscribedMessages.delete({ peerId });\n    void this.messageStreams.get(peerId)?.close();\n    this.messageStreams.delete(peerId);\n  }\n\n  public async reconcile(ctx: Context, client: SignalRPCClient): Promise<void> {\n    await this._reconcileSwarmSubscriptions(ctx, client);\n    await this._reconcileMessageSubscriptions(ctx, client);\n    this.reconciled.emit();\n  }\n\n  private async _reconcileSwarmSubscriptions(ctx: Context, client: SignalRPCClient): Promise<void> {\n    // Unsubscribe from topics that are no longer needed.\n    for (const { topic, peerId } of this._swarmStreams.keys()) {\n      // Join desired topics.\n      if (this._joinedTopics.has({ topic, peerId })) {\n        continue;\n      }\n\n      void this._swarmStreams.get({ topic, peerId })?.close();\n      this._swarmStreams.delete({ topic, peerId });\n    }\n\n    // Subscribe to topics that are needed.\n    for (const { topic, peerId } of this._joinedTopics.values()) {\n      // Join desired topics.\n      if (this._swarmStreams.has({ topic, peerId })) {\n        continue;\n      }\n\n      const swarmStream = await asyncTimeout(cancelWithContext(ctx, client.join({ topic, peerId })), 5_000);\n      // Subscribing to swarm events.\n      // TODO(mykola): What happens when the swarm stream is closed? Maybe send leave event for each peer?\n      swarmStream.subscribe(async (swarmEvent: SwarmEventProto) => {\n        if (this._joinedTopics.has({ topic, peerId })) {\n          log('swarm event', { swarmEvent });\n          const event: SwarmEvent = swarmEvent.peerAvailable\n            ? {\n                topic,\n                peerAvailable: {\n                  ...swarmEvent.peerAvailable,\n                  peer: { peerKey: PublicKey.from(swarmEvent.peerAvailable.peer).toHex() },\n                },\n              }\n            : {\n                topic,\n                peerLeft: {\n                  ...swarmEvent.peerLeft,\n                  peer: { peerKey: PublicKey.from(swarmEvent.peerLeft!.peer).toHex() },\n                },\n              };\n          await this._onSwarmEvent(event);\n        }\n      });\n\n      // Saving swarm stream.\n      this._swarmStreams.set({ topic, peerId }, swarmStream);\n    }\n  }\n\n  private async _reconcileMessageSubscriptions(ctx: Context, client: SignalRPCClient): Promise<void> {\n    // Unsubscribe from messages that are no longer needed.\n    for (const peerId of this.messageStreams.keys()) {\n      // Join desired topics.\n      if (this._subscribedMessages.has({ peerId })) {\n        continue;\n      }\n\n      void this.messageStreams.get(peerId)?.close();\n      this.messageStreams.delete(peerId);\n    }\n\n    // Subscribe to messages that are needed.\n    for (const { peerId } of this._subscribedMessages.values()) {\n      if (this.messageStreams.has(peerId)) {\n        continue;\n      }\n\n      const messageStream = await asyncTimeout(cancelWithContext(ctx, client.receiveMessages(peerId)), 5_000);\n      messageStream.subscribe(async (signalMessage: SignalMessage) => {\n        if (this._subscribedMessages.has({ peerId })) {\n          const message: Message = {\n            author: { peerKey: PublicKey.from(signalMessage.author).toHex() },\n            recipient: { peerKey: PublicKey.from(signalMessage.recipient).toHex() },\n            payload: signalMessage.payload,\n          };\n          await this._onMessage(message);\n        }\n      });\n\n      // Saving message stream.\n      this.messageStreams.set(peerId, messageStream);\n    }\n  }\n}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport WebSocket from 'isomorphic-ws';\n\nimport { scheduleTaskInterval, TimeoutError, Trigger } from '@dxos/async';\nimport { type Any, type Stream } from '@dxos/codec-protobuf';\nimport { Context } from '@dxos/context';\nimport { invariant } from '@dxos/invariant';\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { trace } from '@dxos/protocols';\nimport { schema } from '@dxos/protocols/proto';\nimport { type Message as SignalMessage, type Signal } from '@dxos/protocols/proto/dxos/mesh/signal';\nimport { createProtoRpcPeer, type ProtoRpcPeer } from '@dxos/rpc';\n\nimport { SignalRpcClientMonitor } from './signal-rpc-client-monitor';\n\nconst SIGNAL_KEEPALIVE_INTERVAL = 10000;\n\ninterface Services {\n  Signal: Signal;\n}\n\nexport type SignalCallbacks = {\n  onConnected?: () => void;\n\n  /**\n   * Called on disconnect.\n   * In case of error, `onError` will be called first and then `onDisconnected`.\n   */\n  onDisconnected?: () => void;\n\n  onError?: (error: Error) => void;\n  getMetadata?: () => any;\n};\n\nexport type SignalRPCClientParams = {\n  url: string;\n  callbacks?: SignalCallbacks;\n};\n\n/**\n * Signal RPC client.\n * TODO(mykola): Delete.\n * @deprecated\n */\nexport class SignalRPCClient {\n  private readonly _socket: WebSocket;\n  private readonly _rpc: ProtoRpcPeer<Services>;\n  private readonly _connectTrigger = new Trigger();\n\n  private _keepaliveCtx?: Context;\n\n  private _closed = false;\n\n  private readonly _url: string;\n  private readonly _callbacks: SignalCallbacks;\n  private readonly _closeComplete = new Trigger();\n\n  private readonly _monitor = new SignalRpcClientMonitor();\n\n  constructor({ url, callbacks = {} }: SignalRPCClientParams) {\n    const traceId = PublicKey.random().toHex();\n    log.trace('dxos.mesh.signal-rpc-client.constructor', trace.begin({ id: traceId }));\n    this._url = url;\n    this._callbacks = callbacks;\n    this._socket = new WebSocket(this._url);\n\n    this._rpc = createProtoRpcPeer({\n      requested: {\n        Signal: schema.getService('dxos.mesh.signal.Signal'),\n      },\n      noHandshake: true,\n      port: {\n        send: (msg) => {\n          if (this._closed) {\n            // Do not send messages after close.\n            return;\n          }\n          try {\n            this._socket!.send(msg);\n          } catch (err) {\n            log.warn('send error', err);\n          }\n        },\n        subscribe: (cb) => {\n          this._socket!.onmessage = async (msg: WebSocket.MessageEvent) => {\n            if (typeof Blob !== 'undefined' && msg.data instanceof Blob) {\n              cb(Buffer.from(await msg.data.arrayBuffer()));\n            } else {\n              cb(msg.data as any);\n            }\n          };\n        },\n      },\n      encodingOptions: {\n        preserveAny: true,\n      },\n    });\n\n    this._socket.onopen = async () => {\n      try {\n        await this._rpc!.open();\n        if (this._closed) {\n          await this._safeCloseRpc();\n          return;\n        }\n        log(`RPC open ${this._url}`);\n        this._callbacks.onConnected?.();\n        this._connectTrigger.wake();\n        this._keepaliveCtx = new Context();\n        scheduleTaskInterval(\n          this._keepaliveCtx,\n          async () => {\n            // TODO(nf): use RFC6455 ping/pong once implemented in the browser?\n            // TODO(nf): check for pong response from server (once implemented)\n            // Current implementation of signal server ignores all text data messages, and does not send a response.\n            // However this is enough to detect breakages in the connection as TCP will reset the connection if ACKs are not received.\n            this._socket?.send('__ping__');\n          },\n          SIGNAL_KEEPALIVE_INTERVAL,\n        );\n      } catch (err: any) {\n        this._callbacks.onError?.(err);\n        this._socket.close();\n        this._closed = true;\n      }\n    };\n\n    this._socket.onclose = async () => {\n      log(`Disconnected ${this._url}`);\n      this._callbacks.onDisconnected?.();\n      this._closeComplete.wake();\n      await this.close();\n    };\n\n    this._socket.onerror = async (event: WebSocket.ErrorEvent) => {\n      if (this._closed) {\n        this._socket.close();\n        return;\n      }\n      this._closed = true;\n\n      this._callbacks.onError?.(event.error ?? new Error(event.message));\n      await this._safeCloseRpc();\n\n      log.warn(`Socket ${event.type ?? 'unknown'} error`, { message: event.message, url: this._url });\n    };\n\n    log.trace('dxos.mesh.signal-rpc-client.constructor', trace.end({ id: traceId }));\n  }\n\n  async close(): Promise<void> {\n    if (this._closed) {\n      return;\n    }\n    this._closed = true;\n\n    await this._keepaliveCtx?.dispose();\n    try {\n      await this._safeCloseRpc();\n\n      if (this._socket.readyState === WebSocket.OPEN || this._socket.readyState === WebSocket.CONNECTING) {\n        // close() only starts the closing handshake.\n        this._socket.close();\n      }\n\n      await this._closeComplete.wait({ timeout: 1_000 });\n    } catch (err) {\n      const failureReason = err instanceof TimeoutError ? 'timeout' : err?.constructor?.name ?? 'unknown';\n      this._monitor.recordClientCloseFailure({ failureReason });\n    }\n  }\n\n  async join({ topic, peerId }: { topic: PublicKey; peerId: PublicKey }) {\n    log('join', { topic, peerId, metadata: this._callbacks?.getMetadata?.() });\n    invariant(!this._closed, 'SignalRPCClient is closed');\n    await this._connectTrigger.wait();\n    const swarmStream = this._rpc.rpc.Signal.join({\n      swarm: topic.asUint8Array(),\n      peer: peerId.asUint8Array(),\n      metadata: this._callbacks?.getMetadata?.(),\n    });\n    await swarmStream.waitUntilReady();\n    return swarmStream;\n  }\n\n  async receiveMessages(peerId: PublicKey): Promise<Stream<SignalMessage>> {\n    log('receiveMessages', { peerId });\n    invariant(!this._closed, 'SignalRPCClient is closed');\n    await this._connectTrigger.wait();\n    const messageStream = this._rpc.rpc.Signal.receiveMessages({\n      peer: peerId.asUint8Array(),\n    });\n    await messageStream.waitUntilReady();\n    return messageStream;\n  }\n\n  async sendMessage({\n    author,\n    recipient,\n    payload,\n  }: {\n    author: PublicKey;\n    recipient: PublicKey;\n    payload: Any;\n  }): Promise<void> {\n    log('sendMessage', { author, recipient, payload, metadata: this._callbacks?.getMetadata?.() });\n    invariant(!this._closed, 'SignalRPCClient is closed');\n    await this._connectTrigger.wait();\n    await this._rpc.rpc.Signal.sendMessage({\n      author: author.asUint8Array(),\n      recipient: recipient.asUint8Array(),\n      payload,\n      metadata: this._callbacks?.getMetadata?.(),\n    });\n  }\n\n  private async _safeCloseRpc(): Promise<void> {\n    try {\n      this._connectTrigger.reset();\n      await this._rpc.close();\n    } catch (err) {\n      log.catch(err);\n    }\n  }\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { trace } from '@dxos/tracing';\n\nexport class SignalRpcClientMonitor {\n  public recordClientCloseFailure(params: { failureReason: string }): void {\n    trace.metrics.increment('dxos.mesh.signal.signal-rpc-client.close-failure', 1, {\n      tags: {\n        reason: params.failureReason,\n      },\n    });\n  }\n}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { type Event } from '@dxos/async';\nimport { type Lifecycle } from '@dxos/context';\nimport { type SwarmResponse, type Peer } from '@dxos/protocols/proto/dxos/edge/messenger';\nimport {\n  type LeaveRequest,\n  type Message,\n  type SwarmEvent,\n  type JoinRequest,\n  type QueryRequest,\n} from '@dxos/protocols/proto/dxos/edge/signal';\nimport { type SignalState } from '@dxos/protocols/proto/dxos/mesh/signal';\n\nexport type { Message, SwarmEvent };\nexport type PeerInfo = Peer;\nexport const PeerInfoHash = ({ peerKey }: PeerInfo) => peerKey;\n\nexport type SignalStatus = {\n  host: string;\n  state: SignalState;\n  error?: string;\n  reconnectIn: number;\n  connectionStarted: Date;\n  lastStateChange: Date;\n};\n\n/**\n * Message routing interface.\n */\nexport interface SignalMethods {\n  /**\n   * Emits when other peers join or leave the swarm.\n   * @deprecated\n   * TODO(mykola): Use swarmState in network-manager instead.\n   */\n  swarmEvent: Event<SwarmEvent>;\n\n  /**\n   * Emits when a message is received.\n   */\n  onMessage: Event<Message>;\n\n  /**\n   * Emits when the swarm state changes.\n   */\n  swarmState?: Event<SwarmResponse>;\n\n  /**\n   * Join topic on signal network, to be discoverable by other peers.\n   */\n  join: (params: JoinRequest) => Promise<void>;\n\n  /**\n   * Leave topic on signal network, to stop being discoverable by other peers.\n   */\n  leave: (params: LeaveRequest) => Promise<void>;\n\n  /**\n   * Query peers in the swarm without joining it.\n   */\n  query: (params: QueryRequest) => Promise<SwarmResponse>;\n\n  /**\n   * Send message to peer.\n   */\n  sendMessage: (message: Message) => Promise<void>;\n\n  /**\n   * Start receiving messages from peer.\n   * @deprecated\n   */\n  // TODO(burdon): Return unsubscribe function. Encapsulate callback/routing here.\n  subscribeMessages: (peer: PeerInfo) => Promise<void>;\n\n  /**\n   * Stop receiving messages from peer.\n   * @deprecated\n   */\n  unsubscribeMessages: (peer: PeerInfo) => Promise<void>;\n}\n\n/**\n * Signaling client.\n * TODO(mykola): Delete.\n * @deprecated\n */\nexport interface SignalClientMethods extends SignalMethods, Required<Lifecycle> {\n  getStatus(): SignalStatus;\n}\n", "//\n// Copyright 2020 DXOS.org\n//\n\nimport { Event, Trigger } from '@dxos/async';\nimport { type Any } from '@dxos/codec-protobuf';\nimport { Context } from '@dxos/context';\nimport { invariant } from '@dxos/invariant';\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { schema } from '@dxos/protocols/proto';\nimport { type SwarmResponse } from '@dxos/protocols/proto/dxos/edge/messenger';\nimport { type QueryRequest } from '@dxos/protocols/proto/dxos/edge/signal';\nimport { ComplexMap, ComplexSet } from '@dxos/util';\n\nimport { type SignalManager } from './signal-manager';\nimport { type SwarmEvent, type PeerInfo, type SignalStatus, type Message, PeerInfoHash } from '../signal-methods';\n\n/**\n * Common signaling context that connects multiple MemorySignalManager instances.\n */\nexport class MemorySignalManagerContext {\n  // Swarm messages.\n  readonly swarmEvent = new Event<SwarmEvent>();\n\n  // Mapping from topic to set of peers.\n  readonly swarms = new ComplexMap<PublicKey, ComplexSet<PeerInfo>>(PublicKey.hash);\n\n  // Map of connections for each peer for signaling.\n  readonly connections = new ComplexMap<PeerInfo, MemorySignalManager>(PeerInfoHash);\n}\n\n/**\n * In memory signal manager for testing.\n */\nexport class MemorySignalManager implements SignalManager {\n  readonly statusChanged = new Event<SignalStatus[]>();\n  readonly swarmEvent = new Event<SwarmEvent>();\n\n  readonly onMessage = new Event<Message>();\n\n  /**  Will be used to emit SwarmEvents on .open() and .close() */\n  private _joinedSwarms = new ComplexSet<{ topic: PublicKey; peer: PeerInfo }>(\n    ({ topic, peer }) => topic.toHex() + peer.peerKey,\n  );\n\n  private _ctx!: Context;\n\n  // TODO(dmaretskyi): Replace with callback.\n  private readonly _freezeTrigger = new Trigger().wake();\n\n  constructor(private readonly _context: MemorySignalManagerContext) {\n    this._ctx = new Context();\n\n    this._ctx.onDispose(this._context.swarmEvent.on((data) => this.swarmEvent.emit(data)));\n  }\n\n  async open(): Promise<void> {\n    if (!this._ctx.disposed) {\n      return;\n    }\n    this._ctx = new Context();\n    this._ctx.onDispose(this._context.swarmEvent.on((data) => this.swarmEvent.emit(data)));\n\n    await Promise.all([...this._joinedSwarms.values()].map((value) => this.join(value)));\n  }\n\n  async close(): Promise<void> {\n    if (this._ctx.disposed) {\n      return;\n    }\n    // save copy of joined swarms.\n    const joinedSwarmsCopy = new ComplexSet<{ topic: PublicKey; peer: PeerInfo }>(\n      ({ topic, peer }) => topic.toHex() + peer.peerKey,\n      [...this._joinedSwarms.values()],\n    );\n\n    await Promise.all([...this._joinedSwarms.values()].map((value) => this.leave(value)));\n\n    // assign joined swarms back because .leave() deletes it.\n    this._joinedSwarms = joinedSwarmsCopy;\n\n    await this._ctx.dispose();\n  }\n\n  getStatus(): SignalStatus[] {\n    return [];\n  }\n\n  async join({ topic, peer }: { topic: PublicKey; peer: PeerInfo }): Promise<void> {\n    invariant(!this._ctx.disposed, 'Closed');\n\n    this._joinedSwarms.add({ topic, peer });\n\n    if (!this._context.swarms.has(topic)) {\n      this._context.swarms.set(topic, new ComplexSet(PeerInfoHash));\n    }\n\n    this._context.swarms.get(topic)!.add(peer);\n    this._context.swarmEvent.emit({\n      topic,\n      peerAvailable: {\n        peer,\n        since: new Date(),\n      },\n    });\n\n    // Emitting swarm events for each peer.\n    for (const [topic, peers] of this._context.swarms) {\n      Array.from(peers).forEach((peer) => {\n        this.swarmEvent.emit({\n          topic,\n          peerAvailable: {\n            peer,\n            since: new Date(),\n          },\n        });\n      });\n    }\n  }\n\n  async leave({ topic, peer }: { topic: PublicKey; peer: PeerInfo }): Promise<void> {\n    invariant(!this._ctx.disposed, 'Closed');\n\n    this._joinedSwarms.delete({ topic, peer });\n\n    if (!this._context.swarms.has(topic)) {\n      this._context.swarms.set(topic, new ComplexSet(PeerInfoHash));\n    }\n\n    this._context.swarms.get(topic)!.delete(peer);\n\n    const swarmEvent: SwarmEvent = {\n      topic,\n      peerLeft: {\n        peer,\n      },\n    };\n\n    this._context.swarmEvent.emit(swarmEvent);\n  }\n\n  async query(request: QueryRequest): Promise<SwarmResponse> {\n    throw new Error('Not implemented');\n  }\n\n  async sendMessage({\n    author,\n    recipient,\n    payload,\n  }: {\n    author: PeerInfo;\n    recipient: PeerInfo;\n    payload: Any;\n  }): Promise<void> {\n    log('send message', { author, recipient, ...dec(payload) });\n\n    invariant(recipient);\n    invariant(!this._ctx.disposed, 'Closed');\n\n    await this._freezeTrigger.wait();\n\n    const remote = this._context.connections.get(recipient);\n    if (!remote) {\n      log.warn('recipient is not subscribed for messages', { author, recipient });\n      return;\n    }\n\n    if (remote._ctx.disposed) {\n      log.warn('recipient is disposed', { author, recipient });\n      return;\n    }\n\n    remote._freezeTrigger\n      .wait()\n      .then(() => {\n        if (remote._ctx.disposed) {\n          log.warn('recipient is disposed', { author, recipient });\n          return;\n        }\n\n        log('receive message', { author, recipient, ...dec(payload) });\n\n        remote.onMessage.emit({ author, recipient, payload });\n      })\n      .catch((err) => {\n        log.error('error while waiting for freeze', { err });\n      });\n  }\n\n  async subscribeMessages(peerInfo: PeerInfo): Promise<void> {\n    log('subscribing', { peerInfo });\n    this._context.connections.set(peerInfo, this);\n  }\n\n  async unsubscribeMessages(peerInfo: PeerInfo): Promise<void> {\n    log('unsubscribing', { peerInfo });\n    this._context.connections.delete(peerInfo);\n  }\n\n  freeze(): void {\n    this._freezeTrigger.reset();\n  }\n\n  unfreeze(): void {\n    this._freezeTrigger.wake();\n  }\n}\nconst dec = (payload: Any) => {\n  if (!payload.type_url.endsWith('ReliablePayload')) {\n    return {};\n  }\n\n  const relPayload = schema.getCodecForType('dxos.mesh.messaging.ReliablePayload').decode(payload.value);\n\n  if (typeof relPayload?.payload?.data === 'object') {\n    return { payload: Object.keys(relPayload?.payload?.data)[0], sessionId: relPayload?.payload?.sessionId };\n  }\n\n  return {};\n};\n", "//\n// Copyright 2020 DXOS.org\n//\n\nimport { Event, sleep, synchronized } from '@dxos/async';\nimport { LifecycleState, Resource } from '@dxos/context';\nimport { invariant } from '@dxos/invariant';\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { RateLimitExceededError, TimeoutError, trace } from '@dxos/protocols';\nimport { type Runtime } from '@dxos/protocols/proto/dxos/config';\nimport { type SwarmResponse } from '@dxos/protocols/proto/dxos/edge/messenger';\nimport { type JoinRequest, type LeaveRequest, type QueryRequest } from '@dxos/protocols/proto/dxos/edge/signal';\nimport { BitField, safeAwaitAll } from '@dxos/util';\n\nimport { type SignalManager } from './signal-manager';\nimport { WebsocketSignalManagerMonitor } from './websocket-signal-manager-monitor';\nimport { SignalClient } from '../signal-client';\nimport {\n  type PeerInfo,\n  type Message,\n  type SignalClientMethods,\n  type SignalMethods,\n  type SignalStatus,\n  type SwarmEvent,\n} from '../signal-methods';\n\nconst MAX_SERVER_FAILURES = 5;\nconst WSS_SIGNAL_SERVER_REBOOT_DELAY = 3_000;\n\n/**\n * Manages connection to multiple Signal Servers over WebSocket\n * TODO(mykola): Delete.\n * @deprecated\n */\nexport class WebsocketSignalManager extends Resource implements SignalManager {\n  private readonly _servers = new Map<string, SignalClientMethods>();\n  private readonly _monitor = new WebsocketSignalManagerMonitor();\n\n  /**\n   * Used to avoid logging failed server restarts more than once until the server actually recovers.\n   */\n  private readonly _failedServersBitfield: Uint8Array;\n\n  readonly failureCount = new Map<string, number>();\n  readonly statusChanged = new Event<SignalStatus[]>();\n  readonly swarmEvent = new Event<SwarmEvent>();\n\n  readonly onMessage = new Event<Message>();\n\n  private readonly _instanceId = PublicKey.random().toHex();\n\n  constructor(\n    private readonly _hosts: Runtime.Services.Signal[],\n    private readonly _getMetadata?: () => any,\n  ) {\n    super();\n    log('Created WebsocketSignalManager', { hosts: this._hosts });\n    for (const host of this._hosts) {\n      if (this._servers.has(host.server)) {\n        continue;\n      }\n\n      // TODO(burdon): Create factory to support different variants.\n      const server = new SignalClient(host.server, this._getMetadata);\n      server.swarmEvent.on((data) => this.swarmEvent.emit(data));\n      server.onMessage.on((data) => this.onMessage.emit(data));\n\n      server.statusChanged.on(() => this.statusChanged.emit(this.getStatus()));\n\n      this._servers.set(host.server, server);\n      this.failureCount.set(host.server, 0);\n    }\n    this._failedServersBitfield = BitField.zeros(this._hosts.length);\n  }\n\n  protected override async _open(): Promise<void> {\n    log('open signal manager', { hosts: this._hosts });\n    log.trace('dxos.mesh.websocket-signal-manager.open', trace.begin({ id: this._instanceId }));\n\n    await safeAwaitAll(this._servers.values(), (server) => server.open());\n\n    log.trace('dxos.mesh.websocket-signal-manager.open', trace.end({ id: this._instanceId }));\n  }\n\n  protected override async _close(): Promise<void> {\n    await safeAwaitAll(this._servers.values(), (server) => server.close());\n  }\n\n  async restartServer(serverName: string): Promise<void> {\n    log('restarting server', { serverName });\n    invariant(this._lifecycleState === LifecycleState.OPEN);\n\n    const server = this._servers.get(serverName);\n    invariant(server, 'server not found');\n\n    await server.close();\n    await sleep(WSS_SIGNAL_SERVER_REBOOT_DELAY);\n    await server.open();\n  }\n\n  getStatus(): SignalStatus[] {\n    return Array.from(this._servers.values()).map((server) => server.getStatus());\n  }\n\n  @synchronized\n  async join({ topic, peer }: JoinRequest): Promise<void> {\n    log('join', { topic, peer });\n    invariant(this._lifecycleState === LifecycleState.OPEN);\n    await this._forEachServer((server) => server.join({ topic, peer }));\n  }\n\n  @synchronized\n  async leave({ topic, peer }: LeaveRequest): Promise<void> {\n    log('leaving', { topic, peer });\n    invariant(this._lifecycleState === LifecycleState.OPEN);\n    await this._forEachServer((server) => server.leave({ topic, peer }));\n  }\n\n  async query({ topic }: QueryRequest): Promise<SwarmResponse> {\n    throw new Error('Not implemented');\n  }\n\n  async sendMessage({ author, recipient, payload }: Message): Promise<void> {\n    log('signal', { recipient });\n    invariant(this._lifecycleState === LifecycleState.OPEN);\n\n    void this._forEachServer(async (server, serverName, index) => {\n      void server\n        .sendMessage({ author, recipient, payload })\n        .then(() => this._clearServerFailedFlag(serverName, index))\n        .catch((err) => {\n          if (err instanceof RateLimitExceededError) {\n            log.info('WSS rate limit exceeded', { err });\n            this._monitor.recordRateLimitExceeded();\n          } else if (err instanceof TimeoutError || err.constructor.name === 'TimeoutError') {\n            log.info('WSS sendMessage timeout', { err });\n            void this.checkServerFailure(serverName, index);\n          } else {\n            log.warn(`error sending to ${serverName}`, { err });\n            void this.checkServerFailure(serverName, index);\n          }\n        });\n    });\n  }\n\n  @synchronized\n  async checkServerFailure(serverName: string, index: number): Promise<void> {\n    const failureCount = this.failureCount.get(serverName!) ?? 0;\n    const isRestartRequired = failureCount > MAX_SERVER_FAILURES;\n    this._monitor.recordServerFailure({ serverName, willRestart: isRestartRequired });\n    if (isRestartRequired) {\n      if (!BitField.get(this._failedServersBitfield, index)) {\n        log.warn('too many failures for ws-server, restarting', { serverName, failureCount });\n        BitField.set(this._failedServersBitfield, index, true);\n      }\n      await this.restartServer(serverName!);\n      this.failureCount.set(serverName!, 0);\n      return;\n    }\n\n    this.failureCount.set(serverName!, (this.failureCount.get(serverName!) ?? 0) + 1);\n  }\n\n  private _clearServerFailedFlag(serverName: string, index: number): void {\n    if (BitField.get(this._failedServersBitfield, index)) {\n      log.info('server connection restored', { serverName });\n      BitField.set(this._failedServersBitfield, index, false);\n      this.failureCount.set(serverName!, 0);\n    }\n  }\n\n  async subscribeMessages(peer: PeerInfo): Promise<void> {\n    log('subscribed for message stream', { peer });\n    invariant(this._lifecycleState === LifecycleState.OPEN);\n\n    await this._forEachServer(async (server) => server.subscribeMessages(peer));\n  }\n\n  async unsubscribeMessages(peer: PeerInfo): Promise<void> {\n    log('subscribed for message stream', { peer });\n    invariant(this._lifecycleState === LifecycleState.OPEN);\n\n    await this._forEachServer(async (server) => server.unsubscribeMessages(peer));\n  }\n\n  private async _forEachServer<ReturnType>(\n    fn: (server: SignalMethods, serverName: string, index: number) => Promise<ReturnType>,\n  ): Promise<ReturnType[]> {\n    return Promise.all(\n      Array.from(this._servers.entries()).map(([serverName, server], idx) => fn(server, serverName, idx)),\n    );\n  }\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { trace } from '@dxos/tracing';\n\nexport class WebsocketSignalManagerMonitor {\n  public recordRateLimitExceeded(): void {\n    trace.metrics.increment('dxos.mesh.signal.signal-manager.rate-limit-hit', 1);\n  }\n\n  public recordServerFailure(params: { serverName: string; willRestart: boolean }): void {\n    trace.metrics.increment('dxos.mesh.signal.signal-manager.server-failure', 1, {\n      tags: {\n        server: params.serverName,\n        restarted: params.willRestart,\n      },\n    });\n  }\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { Event, scheduleMicroTask } from '@dxos/async';\nimport { cancelWithContext, Resource } from '@dxos/context';\nimport { type EdgeConnection, protocol } from '@dxos/edge-client';\nimport { invariant } from '@dxos/invariant';\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { EdgeService } from '@dxos/protocols';\nimport { type buf, bufWkt } from '@dxos/protocols/buf';\nimport {\n  SwarmRequestSchema,\n  SwarmRequest_Action as SwarmRequestAction,\n  SwarmResponseSchema,\n  type Message as EdgeMessage,\n  type PeerSchema,\n} from '@dxos/protocols/buf/dxos/edge/messenger_pb';\nimport { type SwarmResponse } from '@dxos/protocols/proto/dxos/edge/messenger';\nimport { ComplexMap, ComplexSet } from '@dxos/util';\n\nimport { type SignalManager } from './signal-manager';\nimport { type PeerInfo, type Message, type SwarmEvent, PeerInfoHash } from '../signal-methods';\n\nexport class EdgeSignalManager extends Resource implements SignalManager {\n  /**\n   * @deprecated\n   */\n  public swarmEvent = new Event<SwarmEvent>();\n  public swarmState = new Event<SwarmResponse>();\n  public onMessage = new Event<Message>();\n\n  /**\n   * Swarm key -> { peer: <own state payload>, joinedPeers: <state of swarm> }.\n   */\n  // TODO(mykola): This class should not contain swarm state joinedPeers. Temporary before network-manager API changes to accept list of peers.\n  private readonly _swarmPeers = new ComplexMap<\n    PublicKey,\n    { lastState?: Uint8Array; joinedPeers: ComplexSet<PeerInfo> }\n  >(PublicKey.hash);\n\n  private readonly _edgeConnection: EdgeConnection;\n\n  constructor({ edgeConnection }: { edgeConnection: EdgeConnection }) {\n    super();\n    this._edgeConnection = edgeConnection;\n  }\n\n  protected override async _open(): Promise<void> {\n    this._ctx.onDispose(this._edgeConnection.onMessage((message) => this._onMessage(message)));\n    this._ctx.onDispose(\n      this._edgeConnection.onReconnected(() => {\n        scheduleMicroTask(this._ctx, () => this._rejoinAllSwarms());\n      }),\n    );\n  }\n\n  /**\n   * Warning: PeerInfo is inferred from edgeConnection.\n   */\n  async join({ topic, peer }: { topic: PublicKey; peer: PeerInfo }): Promise<void> {\n    if (!this._matchSelfPeerInfo(peer)) {\n      // NOTE: Could only join swarm with the same peer info as the edge connection.\n      log.warn('ignoring peer info on join request', {\n        peer,\n        expected: {\n          peerKey: this._edgeConnection.peerKey,\n          identityKey: this._edgeConnection.identityKey,\n        },\n      });\n\n      peer.identityKey = this._edgeConnection.identityKey;\n      peer.peerKey = this._edgeConnection.peerKey;\n    }\n\n    this._swarmPeers.set(topic, { lastState: peer.state, joinedPeers: new ComplexSet<PeerInfo>(PeerInfoHash) });\n    await this._edgeConnection.send(\n      protocol.createMessage(SwarmRequestSchema, {\n        serviceId: EdgeService.SWARM,\n        source: createMessageSource(topic, peer),\n        payload: { action: SwarmRequestAction.JOIN, swarmKeys: [topic.toHex()] },\n      }),\n    );\n  }\n\n  async leave({ topic, peer }: { topic: PublicKey; peer: PeerInfo }): Promise<void> {\n    this._swarmPeers.delete(topic);\n    await this._edgeConnection.send(\n      protocol.createMessage(SwarmRequestSchema, {\n        serviceId: EdgeService.SWARM,\n        source: createMessageSource(topic, peer),\n        payload: { action: SwarmRequestAction.LEAVE, swarmKeys: [topic.toHex()] },\n      }),\n    );\n  }\n\n  async query({ topic }: { topic: PublicKey }): Promise<SwarmResponse> {\n    const response = cancelWithContext(\n      this._ctx,\n      this.swarmState.waitFor((state) => state.swarmKey === topic.toHex()),\n    );\n\n    await this._edgeConnection.send(\n      protocol.createMessage(SwarmRequestSchema, {\n        serviceId: EdgeService.SWARM,\n        source: createMessageSource(topic, {\n          peerKey: this._edgeConnection.peerKey,\n          identityKey: this._edgeConnection.identityKey,\n        }),\n        payload: { action: SwarmRequestAction.INFO, swarmKeys: [topic.toHex()] },\n      }),\n    );\n\n    return response;\n  }\n\n  async sendMessage(message: Message): Promise<void> {\n    if (!this._matchSelfPeerInfo(message.author)) {\n      // NOTE: Could only join swarm with the same peer info as the edge connection.\n      log.warn('ignoring author on send request', {\n        author: message.author,\n        expected: { peerKey: this._edgeConnection.peerKey, identityKey: this._edgeConnection.identityKey },\n      });\n    }\n\n    await this._edgeConnection.send(\n      protocol.createMessage(bufWkt.AnySchema, {\n        serviceId: EdgeService.SIGNAL,\n        source: message.author,\n        target: [message.recipient],\n        payload: { typeUrl: message.payload.type_url, value: message.payload.value },\n      }),\n    );\n  }\n\n  async subscribeMessages(peerInfo: PeerInfo): Promise<void> {\n    // No-op.\n  }\n\n  async unsubscribeMessages(peerInfo: PeerInfo): Promise<void> {\n    // No-op.\n  }\n\n  private _onMessage(message: EdgeMessage): void {\n    switch (message.serviceId) {\n      case EdgeService.SWARM: {\n        this._processSwarmResponse(message);\n        break;\n      }\n      case EdgeService.SIGNAL: {\n        this._processMessage(message);\n      }\n    }\n  }\n\n  private _processSwarmResponse(message: EdgeMessage): void {\n    invariant(protocol.getPayloadType(message) === SwarmResponseSchema.typeName, 'Wrong payload type');\n    const payload = protocol.getPayload(message, SwarmResponseSchema);\n    this.swarmState.emit(payload);\n    const topic = PublicKey.from(payload.swarmKey);\n    if (!this._swarmPeers.has(topic)) {\n      return;\n    }\n\n    const { joinedPeers: oldPeers } = this._swarmPeers.get(topic)!;\n    const timestamp = message.timestamp ? new Date(Date.parse(message.timestamp)) : new Date();\n    const newPeers = new ComplexSet<PeerInfo>(PeerInfoHash, payload.peers);\n\n    // Emit new available peers in the swarm.\n    for (const peer of newPeers) {\n      if (oldPeers.has(peer)) {\n        continue;\n      }\n      this.swarmEvent.emit({\n        topic,\n        peerAvailable: { peer, since: timestamp },\n      });\n    }\n\n    // Emit peer that left the swarm.\n    for (const peer of oldPeers) {\n      if (newPeers.has(peer)) {\n        continue;\n      }\n      this.swarmEvent.emit({\n        topic,\n        peerLeft: { peer },\n      });\n    }\n\n    this._swarmPeers.get(topic)!.joinedPeers = newPeers;\n  }\n\n  private _processMessage(message: EdgeMessage): void {\n    invariant(protocol.getPayloadType(message) === bufWkt.AnySchema.typeName, 'Wrong payload type');\n    const payload = protocol.getPayload(message, bufWkt.AnySchema);\n    invariant(message.source, 'source is missing');\n    invariant(message.target, 'target is missing');\n    invariant(message.target.length === 1, 'target should have exactly one item');\n\n    this.onMessage.emit({\n      author: message.source,\n      recipient: message.target[0],\n      payload: {\n        type_url: payload.typeUrl,\n        value: payload.value,\n      },\n    });\n  }\n\n  private _matchSelfPeerInfo(peer: PeerInfo): boolean {\n    return (\n      peer && (peer.peerKey === this._edgeConnection.peerKey || peer.identityKey === this._edgeConnection.identityKey)\n    );\n  }\n\n  private async _rejoinAllSwarms(): Promise<void> {\n    log('rejoin swarms', { swarms: Array.from(this._swarmPeers.keys()) });\n    for (const [topic, { lastState }] of this._swarmPeers.entries()) {\n      await this.join({\n        topic,\n        peer: {\n          peerKey: this._edgeConnection.peerKey,\n          identityKey: this._edgeConnection.identityKey,\n          state: lastState,\n        },\n      });\n    }\n  }\n}\n\nconst createMessageSource = (topic: PublicKey, peerInfo: PeerInfo): buf.MessageInitShape<typeof PeerSchema> => {\n  return {\n    swarmKey: topic.toHex(),\n    ...peerInfo,\n  };\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { invariant } from '@dxos/invariant';\nimport { log } from '@dxos/log';\nimport { type DevicesService, type IdentityService } from '@dxos/protocols/proto/dxos/client/services';\nimport { DeviceKind } from '@dxos/protocols/proto/dxos/client/services';\n\nexport const setIdentityTags = ({\n  identityService,\n  devicesService,\n  setTag,\n}: {\n  identityService: IdentityService;\n  devicesService: DevicesService;\n  setTag: (k: string, v: string) => void;\n}) => {\n  identityService.queryIdentity().subscribe((idqr) => {\n    if (!idqr?.identity?.identityKey) {\n      log('empty response from identity service', { idqr });\n      return;\n    }\n\n    setTag('identityKey', idqr.identity.identityKey.truncate());\n  });\n\n  devicesService.queryDevices().subscribe((dqr) => {\n    if (!dqr || !dqr.devices || dqr.devices.length === 0) {\n      log('empty response from device service', { device: dqr });\n      return;\n    }\n    invariant(dqr, 'empty response from device service');\n\n    const thisDevice = dqr.devices.find((device) => device.kind === DeviceKind.CURRENT);\n    if (!thisDevice) {\n      log('no current device', { device: dqr });\n      return;\n    }\n    setTag('deviceKey', thisDevice.deviceKey.truncate());\n  });\n};\n"],
  "mappings": "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",
  "names": ["TimeoutError", "scheduleExponentialBackoffTaskInterval", "scheduleTask", "scheduleTaskInterval", "Context", "invariant", "PublicKey", "log", "ProtocolTimeoutError", "trace", "schema", "ComplexMap", "ComplexSet", "trace", "MessengerMonitor", "recordMessageAckFailed", "trace", "metrics", "increment", "recordReliableMessage", "params", "tags", "success", "sent", "attempts", "sendAttempts", "MESSAGE_TIMEOUT", "ReliablePayload", "schema", "getCodecForType", "Acknowledgement", "RECEIVED_MESSAGES_GC_INTERVAL", "Messenger", "signalManager", "retryDelay", "_monitor", "MessengerMonitor", "_listeners", "ComplexMap", "peerId", "payloadType", "_defaultListeners", "Map", "_onAckCallbacks", "PublicKey", "hash", "_receivedMessages", "ComplexSet", "_toClear", "_closed", "_signalManager", "_retryDelay", "open", "traceId", "random", "toHex", "log", "trace", "begin", "id", "_ctx", "Context", "onError", "err", "catch", "onDispose", "onMessage", "on", "message", "from", "author", "_handleMessage", "scheduleTaskInterval", "_performGc", "end", "close", "dispose", "sendMessage", "recipient", "payload", "invariant", "messageContext", "derive", "reliablePayload", "messageId", "has", "messageReceived", "timeoutHit", "sendAttempts", "promise", "Promise", "resolve", "reject", "scheduleExponentialBackoffTaskInterval", "_encodeAndSend", "scheduleTask", "delete", "ProtocolTimeoutError", "TimeoutError", "MESSAGE_TIMEOUT", "recordReliableMessage", "sent", "set", "listen", "peer", "subscribeMessages", "listeners", "peerKey", "get", "Set", "add", "unsubscribe", "type_url", "value", "encode", "preserveAny", "_handleReliablePayload", "_handleAcknowledgement", "decode", "_sendAcknowledgement", "recordMessageAckFailed", "_callListeners", "to", "defaultListenerMap", "listener", "listenerMap", "start", "performance", "now", "key", "keys", "clear", "elapsed", "warn", "DeferredTask", "Event", "Trigger", "scheduleTask", "scheduleTaskInterval", "sleep", "cancelWithContext", "Resource", "invariant", "PublicKey", "log", "trace", "SignalState", "trace", "SignalClientMonitor", "_performance", "sentMessages", "receivedMessages", "reconnectCounter", "joinCounter", "leaveCounter", "_connectionStarted", "Date", "_lastStateChange", "getRecordedTimestamps", "connectionStarted", "lastStateChange", "recordStateChangeTime", "recordConnectionStartTime", "recordReconnect", "params", "trace", "metrics", "increment", "tags", "success", "recordJoin", "recordLeave", "recordMessageReceived", "message", "createIdentityTags", "distribution", "getByteCount", "recordMessageSending", "sendMessage", "reqStart", "now", "reqDuration", "err", "recordStreamCloseErrors", "count", "recordReconciliation", "author", "peerKey", "length", "recipient", "payload", "type_url", "value", "peer", "asyncTimeout", "Event", "cancelWithContext", "PublicKey", "log", "ComplexMap", "ComplexSet", "safeAwaitAll", "SignalLocalState", "_onMessage", "_onSwarmEvent", "_swarmStreams", "topic", "peerId", "toHex", "_joinedTopics", "_subscribedMessages", "messageStreams", "key", "reconciled", "safeCloseStreams", "streams", "values", "concat", "clear", "failureCount", "s", "close", "length", "join", "add", "leave", "get", "delete", "subscribeMessages", "unsubscribeMessages", "reconcile", "ctx", "client", "_reconcileSwarmSubscriptions", "_reconcileMessageSubscriptions", "emit", "keys", "has", "swarmStream", "subscribe", "swarmEvent", "event", "peerAvailable", "peer", "peerKey", "from", "peerLeft", "set", "messageStream", "receiveMessages", "signalMessage", "message", "author", "recipient", "payload", "WebSocket", "scheduleTaskInterval", "TimeoutError", "Trigger", "Context", "invariant", "PublicKey", "log", "trace", "schema", "createProtoRpcPeer", "trace", "SignalRpcClientMonitor", "recordClientCloseFailure", "params", "trace", "metrics", "increment", "tags", "reason", "failureReason", "SIGNAL_KEEPALIVE_INTERVAL", "SignalRPCClient", "url", "callbacks", "_connectTrigger", "Trigger", "_closed", "_closeComplete", "_monitor", "SignalRpcClientMonitor", "traceId", "PublicKey", "random", "toHex", "log", "trace", "begin", "id", "_url", "_callbacks", "_socket", "WebSocket", "_rpc", "createProtoRpcPeer", "requested", "Signal", "schema", "getService", "noHandshake", "port", "send", "msg", "err", "warn", "subscribe", "cb", "onmessage", "Blob", "data", "Buffer", "from", "arrayBuffer", "encodingOptions", "preserveAny", "onopen", "open", "_safeCloseRpc", "onConnected", "wake", "_keepaliveCtx", "Context", "scheduleTaskInterval", "onError", "close", "onclose", "onDisconnected", "onerror", "event", "error", "Error", "message", "type", "end", "dispose", "readyState", "OPEN", "CONNECTING", "wait", "timeout", "failureReason", "TimeoutError", "name", "recordClientCloseFailure", "join", "topic", "peerId", "metadata", "getMetadata", "invariant", "swarmStream", "rpc", "swarm", "asUint8Array", "peer", "waitUntilReady", "receiveMessages", "messageStream", "sendMessage", "author", "recipient", "payload", "reset", "catch", "DEFAULT_RECONNECT_TIMEOUT", "MAX_RECONNECT_TIMEOUT", "ERROR_RECONCILE_DELAY", "RECONCILE_INTERVAL", "SignalClient", "Resource", "_host", "_getMetadata", "_monitor", "SignalClientMonitor", "_state", "SignalState", "CLOSED", "_lastReconciliationFailed", "_clientReady", "Trigger", "_reconnectAfter", "_instanceId", "PublicKey", "random", "toHex", "statusChanged", "Event", "onMessage", "swarmEvent", "startsWith", "Error", "localState", "SignalLocalState", "message", "recordMessageReceived", "emit", "event", "_open", "log", "trace", "begin", "id", "CONNECTED", "CONNECTING", "includes", "_setState", "_reconcileTask", "DeferredTask", "_ctx", "cancelWithContext", "_connectionCtx", "wait", "timeout", "invariant", "reconcile", "_client", "recordReconciliation", "success", "err", "scheduleTaskInterval", "schedule", "_reconnectTask", "_reconnect", "recordReconnect", "_createClient", "end", "_catch", "disposed", "warn", "_scheduleReconcileAfterError", "_close", "_safeResetClient", "getStatus", "host", "state", "error", "_lastError", "reconnectIn", "getRecordedTimestamps", "join", "args", "topic", "peerId", "peer", "peerKey", "recordJoin", "from", "leave", "recordLeave", "query", "params", "sendMessage", "msg", "recordMessageSending", "author", "recipient", "payload", "subscribeMessages", "unsubscribeMessages", "scheduleTask", "recordConnectionStartTime", "derive", "onDispose", "failureCount", "safeCloseStreams", "recordStreamCloseErrors", "client", "SignalRPCClient", "url", "callbacks", "onConnected", "_onConnected", "onDisconnected", "ERROR", "DISCONNECTED", "_onDisconnected", "onError", "getMetadata", "undefined", "RECONNECTING", "info", "sleep", "wake", "options", "_updateReconnectTimeout", "newState", "recordStateChangeTime", "status", "Math", "min", "dispose", "reset", "close", "catch", "PeerInfoHash", "peerKey", "Event", "Trigger", "Context", "invariant", "PublicKey", "log", "schema", "ComplexMap", "ComplexSet", "MemorySignalManagerContext", "swarmEvent", "Event", "swarms", "ComplexMap", "PublicKey", "hash", "connections", "PeerInfoHash", "MemorySignalManager", "_context", "statusChanged", "onMessage", "_joinedSwarms", "ComplexSet", "topic", "peer", "toHex", "peerKey", "_freezeTrigger", "Trigger", "wake", "_ctx", "Context", "onDispose", "on", "data", "emit", "open", "disposed", "Promise", "all", "values", "map", "value", "join", "close", "joinedSwarmsCopy", "leave", "dispose", "getStatus", "invariant", "add", "has", "set", "get", "peerAvailable", "since", "Date", "peers", "Array", "from", "forEach", "delete", "peerLeft", "query", "request", "Error", "sendMessage", "author", "recipient", "payload", "log", "dec", "wait", "remote", "warn", "then", "catch", "err", "error", "subscribeMessages", "peerInfo", "unsubscribeMessages", "freeze", "reset", "unfreeze", "type_url", "endsWith", "relPayload", "schema", "getCodecForType", "decode", "Object", "keys", "sessionId", "Event", "sleep", "synchronized", "LifecycleState", "Resource", "invariant", "PublicKey", "log", "RateLimitExceededError", "TimeoutError", "trace", "BitField", "safeAwaitAll", "trace", "WebsocketSignalManagerMonitor", "recordRateLimitExceeded", "trace", "metrics", "increment", "recordServerFailure", "params", "tags", "server", "serverName", "restarted", "willRestart", "MAX_SERVER_FAILURES", "WSS_SIGNAL_SERVER_REBOOT_DELAY", "WebsocketSignalManager", "Resource", "_hosts", "_getMetadata", "_servers", "Map", "_monitor", "WebsocketSignalManagerMonitor", "failureCount", "statusChanged", "Event", "swarmEvent", "onMessage", "_instanceId", "PublicKey", "random", "toHex", "log", "hosts", "host", "has", "server", "SignalClient", "on", "data", "emit", "getStatus", "set", "_failedServersBitfield", "BitField", "zeros", "length", "_open", "trace", "begin", "id", "safeAwaitAll", "values", "open", "end", "_close", "close", "restartServer", "serverName", "invariant", "_lifecycleState", "LifecycleState", "OPEN", "get", "sleep", "Array", "from", "map", "join", "topic", "peer", "_forEachServer", "leave", "query", "Error", "sendMessage", "author", "recipient", "payload", "index", "then", "_clearServerFailedFlag", "catch", "err", "RateLimitExceededError", "info", "recordRateLimitExceeded", "TimeoutError", "name", "checkServerFailure", "warn", "isRestartRequired", "recordServerFailure", "willRestart", "subscribeMessages", "unsubscribeMessages", "fn", "Promise", "all", "entries", "idx", "Event", "scheduleMicroTask", "cancelWithContext", "Resource", "protocol", "invariant", "PublicKey", "log", "EdgeService", "bufWkt", "SwarmRequestSchema", "SwarmRequest_Action", "SwarmRequestAction", "SwarmResponseSchema", "ComplexMap", "ComplexSet", "EdgeSignalManager", "Resource", "edgeConnection", "swarmEvent", "Event", "swarmState", "onMessage", "_swarmPeers", "ComplexMap", "PublicKey", "hash", "_edgeConnection", "_open", "_ctx", "onDispose", "message", "_onMessage", "onReconnected", "scheduleMicroTask", "_rejoinAllSwarms", "join", "topic", "peer", "_matchSelfPeerInfo", "log", "warn", "expected", "peerKey", "identityKey", "set", "lastState", "state", "joinedPeers", "ComplexSet", "PeerInfoHash", "send", "protocol", "createMessage", "SwarmRequestSchema", "serviceId", "EdgeService", "SWARM", "source", "createMessageSource", "payload", "action", "SwarmRequestAction", "JOIN", "swarmKeys", "toHex", "leave", "delete", "LEAVE", "query", "response", "cancelWithContext", "waitFor", "swarmKey", "INFO", "sendMessage", "author", "bufWkt", "AnySchema", "SIGNAL", "target", "recipient", "typeUrl", "type_url", "value", "subscribeMessages", "peerInfo", "unsubscribeMessages", "_processSwarmResponse", "_processMessage", "invariant", "getPayloadType", "SwarmResponseSchema", "typeName", "getPayload", "emit", "from", "has", "oldPeers", "get", "timestamp", "Date", "parse", "newPeers", "peers", "peerAvailable", "since", "peerLeft", "length", "swarms", "Array", "keys", "entries", "invariant", "log", "DeviceKind", "setIdentityTags", "identityService", "devicesService", "setTag", "queryIdentity", "subscribe", "idqr", "identity", "identityKey", "truncate", "queryDevices", "dqr", "devices", "length", "device", "thisDevice", "find", "kind", "CURRENT", "deviceKey"]
}
