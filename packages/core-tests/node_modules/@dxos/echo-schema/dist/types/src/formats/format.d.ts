import { Schema } from 'effect';
import * as Keys from '@dxos/keys';
import * as NumberUtil from './number';
import * as ObjectUtil from './object';
/**
 * Formats.
 * https://json-schema.org/understanding-json-schema/reference/string#built-in-formats
 * NOTE: A JSON Schema validator will ignore any format type that it does not understand.
 */
export declare namespace Format {
    const DXN: typeof Keys.DXN;
    const Email: Schema.refine<string, typeof Schema.String>;
    const Formula: typeof Schema.String;
    const Hostname: typeof Schema.String;
    const JSON: typeof Schema.String;
    const Markdown: typeof Schema.String;
    const Regex: typeof Schema.String;
    const URL: Schema.refine<string, typeof Schema.String>;
    const UUID: typeof Schema.UUID;
    const Currency: ({ decimals, code }?: NumberUtil.CurrencyAnnotation) => Schema.Schema<number, number, never>;
    const Integer: () => Schema.refine<number, typeof Schema.Number>;
    const Percent: ({ decimals }?: NumberUtil.PercentAnnotation) => Schema.Schema<number, number, never>;
    const Timestamp: Schema.SchemaClass<number, number, never>;
    const DateTime: Schema.SchemaClass<string, string, never>;
    const Date: Schema.SchemaClass<string, string, never>;
    const Time: Schema.SchemaClass<string, string, never>;
    const Duration: Schema.SchemaClass<string, string, never>;
    const GeoPoint: Schema.Tuple<[Schema.refine<number, Schema.transform<typeof Schema.Number, Schema.filter<Schema.SchemaClass<number, number, never>>>>, Schema.refine<number, Schema.transform<typeof Schema.Number, Schema.filter<Schema.SchemaClass<number, number, never>>>>, Schema.Element<typeof Schema.Number, "?">]>;
    type GeoPoint = ObjectUtil.GeoPoint;
}
//# sourceMappingURL=format.d.ts.map