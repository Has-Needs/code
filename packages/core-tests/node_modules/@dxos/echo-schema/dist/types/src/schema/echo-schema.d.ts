import { Schema, SchemaAST } from 'effect';
import { type ObjectId } from '@dxos/keys';
import { StoredSchema } from './stored-schema';
import { SchemaMetaSymbol, type SchemaMeta } from '../ast';
import { type JsonSchemaType } from '../json-schema';
import { type TypedObject, type TypedObjectPrototype } from '../object';
/**
 * Base schema type.
 */
export interface BaseSchema<A = any, I = any> extends TypedObject<A, I> {
    get readonly(): boolean;
    get mutable(): EchoSchema<A, I>;
    get snapshot(): Schema.Schema<A, I>;
    get jsonSchema(): JsonSchemaType;
}
/**
 * Immutable schema type.
 * @deprecated Use `Schema.Schema.AnyNoContext` instead.
 */
export declare class ImmutableSchema<A = any, I = any> implements BaseSchema<A, I> {
    private readonly _schema;
    private readonly _objectAnnotation;
    constructor(_schema: Schema.Schema<A, I>);
    get [Schema.TypeId](): {
        _A: (_: any) => any;
        _I: (_: any) => any;
        _R: (_: never) => never;
    };
    get Type(): A;
    get Encoded(): I;
    get Context(): never;
    get ast(): SchemaAST.AST;
    get annotations(): (annotations: Schema.Annotations.GenericSchema<A>) => Schema.Schema<A, I, never>;
    get pipe(): {
        <A_1>(this: A_1): A_1;
        <A_1, B = never>(this: A_1, ab: (_: A_1) => B): B;
        <A_1, B = never, C = never>(this: A_1, ab: (_: A_1) => B, bc: (_: B) => C): C;
        <A_1, B = never, C = never, D = never>(this: A_1, ab: (_: A_1) => B, bc: (_: B) => C, cd: (_: C) => D): D;
        <A_1, B = never, C = never, D = never, E = never>(this: A_1, ab: (_: A_1) => B, bc: (_: B) => C, cd: (_: C) => D, de: (_: D) => E): E;
        <A_1, B = never, C = never, D = never, E = never, F = never>(this: A_1, ab: (_: A_1) => B, bc: (_: B) => C, cd: (_: C) => D, de: (_: D) => E, ef: (_: E) => F): F;
        <A_1, B = never, C = never, D = never, E = never, F = never, G = never>(this: A_1, ab: (_: A_1) => B, bc: (_: B) => C, cd: (_: C) => D, de: (_: D) => E, ef: (_: E) => F, fg: (_: F) => G): G;
        <A_1, B = never, C = never, D = never, E = never, F = never, G = never, H = never>(this: A_1, ab: (_: A_1) => B, bc: (_: B) => C, cd: (_: C) => D, de: (_: D) => E, ef: (_: E) => F, fg: (_: F) => G, gh: (_: G) => H): H;
        <A_1, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I_1 = never>(this: A_1, ab: (_: A_1) => B, bc: (_: B) => C, cd: (_: C) => D, de: (_: D) => E, ef: (_: E) => F, fg: (_: F) => G, gh: (_: G) => H, hi: (_: H) => I_1): I_1;
        <A_1, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I_1 = never, J = never>(this: A_1, ab: (_: A_1) => B, bc: (_: B) => C, cd: (_: C) => D, de: (_: D) => E, ef: (_: E) => F, fg: (_: F) => G, gh: (_: G) => H, hi: (_: H) => I_1, ij: (_: I_1) => J): J;
        <A_1, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I_1 = never, J = never, K = never>(this: A_1, ab: (_: A_1) => B, bc: (_: B) => C, cd: (_: C) => D, de: (_: D) => E, ef: (_: E) => F, fg: (_: F) => G, gh: (_: G) => H, hi: (_: H) => I_1, ij: (_: I_1) => J, jk: (_: J) => K): K;
        <A_1, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I_1 = never, J = never, K = never, L = never>(this: A_1, ab: (_: A_1) => B, bc: (_: B) => C, cd: (_: C) => D, de: (_: D) => E, ef: (_: E) => F, fg: (_: F) => G, gh: (_: G) => H, hi: (_: H) => I_1, ij: (_: I_1) => J, jk: (_: J) => K, kl: (_: K) => L): L;
        <A_1, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I_1 = never, J = never, K = never, L = never, M = never>(this: A_1, ab: (_: A_1) => B, bc: (_: B) => C, cd: (_: C) => D, de: (_: D) => E, ef: (_: E) => F, fg: (_: F) => G, gh: (_: G) => H, hi: (_: H) => I_1, ij: (_: I_1) => J, jk: (_: J) => K, kl: (_: K) => L, lm: (_: L) => M): M;
        <A_1, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I_1 = never, J = never, K = never, L = never, M = never, N = never>(this: A_1, ab: (_: A_1) => B, bc: (_: B) => C, cd: (_: C) => D, de: (_: D) => E, ef: (_: E) => F, fg: (_: F) => G, gh: (_: G) => H, hi: (_: H) => I_1, ij: (_: I_1) => J, jk: (_: J) => K, kl: (_: K) => L, lm: (_: L) => M, mn: (_: M) => N): N;
        <A_1, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I_1 = never, J = never, K = never, L = never, M = never, N = never, O = never>(this: A_1, ab: (_: A_1) => B, bc: (_: B) => C, cd: (_: C) => D, de: (_: D) => E, ef: (_: E) => F, fg: (_: F) => G, gh: (_: G) => H, hi: (_: H) => I_1, ij: (_: I_1) => J, jk: (_: J) => K, kl: (_: K) => L, lm: (_: L) => M, mn: (_: M) => N, no: (_: N) => O): O;
        <A_1, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I_1 = never, J = never, K = never, L = never, M = never, N = never, O = never, P = never>(this: A_1, ab: (_: A_1) => B, bc: (_: B) => C, cd: (_: C) => D, de: (_: D) => E, ef: (_: E) => F, fg: (_: F) => G, gh: (_: G) => H, hi: (_: H) => I_1, ij: (_: I_1) => J, jk: (_: J) => K, kl: (_: K) => L, lm: (_: L) => M, mn: (_: M) => N, no: (_: N) => O, op: (_: O) => P): P;
        <A_1, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I_1 = never, J = never, K = never, L = never, M = never, N = never, O = never, P = never, Q = never>(this: A_1, ab: (_: A_1) => B, bc: (_: B) => C, cd: (_: C) => D, de: (_: D) => E, ef: (_: E) => F, fg: (_: F) => G, gh: (_: G) => H, hi: (_: H) => I_1, ij: (_: I_1) => J, jk: (_: J) => K, kl: (_: K) => L, lm: (_: L) => M, mn: (_: M) => N, no: (_: N) => O, op: (_: O) => P, pq: (_: P) => Q): Q;
        <A_1, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I_1 = never, J = never, K = never, L = never, M = never, N = never, O = never, P = never, Q = never, R = never>(this: A_1, ab: (_: A_1) => B, bc: (_: B) => C, cd: (_: C) => D, de: (_: D) => E, ef: (_: E) => F, fg: (_: F) => G, gh: (_: G) => H, hi: (_: H) => I_1, ij: (_: I_1) => J, jk: (_: J) => K, kl: (_: K) => L, lm: (_: L) => M, mn: (_: M) => N, no: (_: N) => O, op: (_: O) => P, pq: (_: P) => Q, qr: (_: Q) => R): R;
        <A_1, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I_1 = never, J = never, K = never, L = never, M = never, N = never, O = never, P = never, Q = never, R = never, S = never>(this: A_1, ab: (_: A_1) => B, bc: (_: B) => C, cd: (_: C) => D, de: (_: D) => E, ef: (_: E) => F, fg: (_: F) => G, gh: (_: G) => H, hi: (_: H) => I_1, ij: (_: I_1) => J, jk: (_: J) => K, kl: (_: K) => L, lm: (_: L) => M, mn: (_: M) => N, no: (_: N) => O, op: (_: O) => P, pq: (_: P) => Q, qr: (_: Q) => R, rs: (_: R) => S): S;
        <A_1, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I_1 = never, J = never, K = never, L = never, M = never, N = never, O = never, P = never, Q = never, R = never, S = never, T = never>(this: A_1, ab: (_: A_1) => B, bc: (_: B) => C, cd: (_: C) => D, de: (_: D) => E, ef: (_: E) => F, fg: (_: F) => G, gh: (_: G) => H, hi: (_: H) => I_1, ij: (_: I_1) => J, jk: (_: J) => K, kl: (_: K) => L, lm: (_: L) => M, mn: (_: M) => N, no: (_: N) => O, op: (_: O) => P, pq: (_: P) => Q, qr: (_: Q) => R, rs: (_: R) => S, st: (_: S) => T): T;
        <A_1, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I_1 = never, J = never, K = never, L = never, M = never, N = never, O = never, P = never, Q = never, R = never, S = never, T = never, U = never>(this: A_1, ab: (_: A_1) => B, bc: (_: B) => C, cd: (_: C) => D, de: (_: D) => E, ef: (_: E) => F, fg: (_: F) => G, gh: (_: G) => H, hi: (_: H) => I_1, ij: (_: I_1) => J, jk: (_: J) => K, kl: (_: K) => L, lm: (_: L) => M, mn: (_: M) => N, no: (_: N) => O, op: (_: O) => P, pq: (_: P) => Q, qr: (_: Q) => R, rs: (_: R) => S, st: (_: S) => T, tu: (_: T) => U): U;
        <A_1, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I_1 = never, J = never, K = never, L = never, M = never, N = never, O = never, P = never, Q = never, R = never, S = never, T = never, U = never>(this: A_1, ab: (_: A_1) => B, bc: (_: B) => C, cd: (_: C) => D, de: (_: D) => E, ef: (_: E) => F, fg: (_: F) => G, gh: (_: G) => H, hi: (_: H) => I_1, ij: (_: I_1) => J, jk: (_: J) => K, kl: (_: K) => L, lm: (_: L) => M, mn: (_: M) => N, no: (_: N) => O, op: (_: O) => P, pq: (_: P) => Q, qr: (_: Q) => R, rs: (_: R) => S, st: (_: S) => T, tu: (_: T) => U): U;
    };
    get typename(): string;
    get version(): string;
    get readonly(): boolean;
    get snapshot(): Schema.Schema.AnyNoContext;
    get jsonSchema(): JsonSchemaType;
    get mutable(): EchoSchema;
}
export declare const isMutable: (schema: Schema.Schema.AnyNoContext) => schema is EchoSchema;
declare const EchoSchema_base: TypedObjectPrototype<any, any>;
/**
 * Represents a schema that is stored in the ECHO database.
 * Schema can me mutable or readonly (specified by the {@link EchoSchema.readonly} field).
 *
 * Schema that can be modified at runtime via the API.
 * Is an instance of effect-schema (`Schema.Schema.AnyNoContext`) so it can be used in the same way as a regular schema.
 * IMPORTANT: The schema AST will change reactively when the schema is updated, including synced updates from remote peers.
 *
 * The class constructor is a schema instance itself, and can be used in the echo object definitions:
 *
 * @example
 * ```ts
 * export class TableType extends TypedObject({ typename: 'example.org/type/Table', version: '0.1.0' })({
 *   title: Schema.String,
 *   schema: Schema.optional(ref(EchoSchema)),
 *   props: Schema.mutable(S.Array(TablePropSchema)),
 * }) {}
 * ```
 *
 * The ECHO API will translate any references to StoredSchema objects to be resolved as EchoSchema objects.
 */
export declare class EchoSchema<A = any, I = any> extends EchoSchema_base implements BaseSchema<A, I> {
    private readonly _storedSchema;
    private _schema;
    private _isDirty;
    constructor(_storedSchema: StoredSchema);
    get [Schema.TypeId](): {
        _A: (_: any) => any;
        _I: (_: any) => any;
        _R: (_: never) => never;
    };
    get Type(): A;
    get Encoded(): I;
    get Context(): never;
    get ast(): SchemaAST.AST;
    get annotations(): (annotations: Schema.Annotations.GenericSchema<any>) => Schema.Schema<any, any, never>;
    get pipe(): Schema.Schema.AnyNoContext['pipe'];
    get typename(): string;
    get version(): string;
    get readonly(): boolean;
    /**
     * Returns an immutable schema snapshot of the current state of the schema.
     */
    get snapshot(): Schema.Schema.AnyNoContext;
    /**
     * @reactive
     */
    get jsonSchema(): JsonSchemaType;
    /**
     * Returns a mutable schema.
     */
    get mutable(): EchoSchema;
    /**
     * Id of the ECHO object containing the schema.
     */
    get id(): ObjectId;
    get [SchemaMetaSymbol](): SchemaMeta;
    /**
     * Reference to the underlying stored schema object.
     */
    get storedSchema(): StoredSchema;
    getProperties(): SchemaAST.PropertySignature[];
    /**
     * @throws Error if the schema is readonly.
     */
    updateTypename(typename: string): void;
    /**
     * @throws Error if the schema is readonly.
     */
    addFields(fields: Schema.Struct.Fields): void;
    /**
     * @throws Error if the schema is readonly.
     */
    updateFields(fields: Schema.Struct.Fields): void;
    /**
     * @throws Error if the schema is readonly.
     */
    updateFieldPropertyName({ before, after }: {
        before: PropertyKey;
        after: PropertyKey;
    }): void;
    /**
     * @throws Error if the schema is readonly.
     */
    removeFields(fieldNames: string[]): void;
    /**
     * Called by EchoSchemaRegistry on update.
     */
    _invalidate(): void;
    /**
     * Rebuilds this schema if it is dirty.
     */
    _rebuild(): void;
    private _getSchema;
}
export {};
//# sourceMappingURL=echo-schema.d.ts.map