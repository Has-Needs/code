{
  "version": 3,
  "sources": ["../../../src/ast/annotation-helper.ts", "../../../src/ast/entity-kind.ts", "../../../src/ast/annotations.ts", "../../../src/ast/types.ts", "../../../src/object/model.ts", "../../../src/object/accessors.ts", "../../../src/object/typename.ts", "../../../src/object/common.ts", "../../../src/object/meta.ts", "../../../src/ref/ref.ts", "../../../src/ref/ref-array.ts", "../../../src/utils.ts", "../../../src/object/json-serializer.ts", "../../../src/object/create.ts", "../../../src/object/inspect.ts", "../../../src/object/entity.ts", "../../../src/object/expando.ts", "../../../src/object/ids.ts", "../../../src/object/typed-object.ts", "../../../src/object/typed-relation.ts", "../../../src/object/deleted.ts", "../../../src/object/schema-validator.ts"],
  "sourcesContent": ["//\n// Copyright 2025 DXOS.org\n//\n\nimport { type Schema, SchemaAST, type Option } from 'effect';\n\nexport interface AnnotationHelper<T> {\n  get: (schema: Schema.Schema.Any) => Option.Option<T>;\n  set: (value: T) => <S extends Schema.Schema.Any>(schema: S) => S;\n}\n\nexport const createAnnotationHelper = <T>(id: symbol): AnnotationHelper<T> => {\n  return {\n    get: (schema) => SchemaAST.getAnnotation(schema as any, id),\n    set:\n      (value) =>\n      <S extends Schema.Schema.Any>(schema: S) =>\n        schema.annotations({ [id]: value }) as S,\n  };\n};\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { Schema } from 'effect';\n\n/**\n * Kinds of entities stored in ECHO: objects and relations.\n */\nexport enum EntityKind {\n  Object = 'object',\n  Relation = 'relation',\n}\n\nexport const EntityKindSchema = Schema.Enums(EntityKind);\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { flow, Option, pipe, Schema, SchemaAST } from 'effect';\n\nimport { assertArgument } from '@dxos/invariant';\nimport { DXN } from '@dxos/keys';\nimport { type Primitive } from '@dxos/util';\n\nimport { createAnnotationHelper } from './annotation-helper';\nimport { EntityKind } from './entity-kind';\n\n/**\n * ECHO identifier (for a stored schema).\n * Must be a `dxn:echo:` URI.\n */\nexport const TypeIdentifierAnnotationId = Symbol.for('@dxos/schema/annotation/TypeIdentifier');\n\nexport const getTypeIdentifierAnnotation = (schema: Schema.Schema.All) =>\n  flow(\n    SchemaAST.getAnnotation<string>(TypeIdentifierAnnotationId),\n    Option.getOrElse(() => undefined),\n  )(schema.ast);\n\n/**\n * ECHO type.\n */\nexport const TypeAnnotationId = Symbol.for('@dxos/schema/annotation/Type');\n\nexport const Typename = Schema.String.pipe(Schema.pattern(/^[a-zA-Z]\\w+\\.[a-zA-Z]\\w{1,}\\/[\\w/_-]+$/));\nexport const Version = Schema.String.pipe(Schema.pattern(/^\\d+.\\d+.\\d+$/));\n\n/**\n * Payload stored under {@link TypeAnnotationId}.\n */\n// TODO(dmaretskyi): Rename getTypeAnnotation to represent commonality between objects and relations (e.g. `entity`).\nexport const TypeAnnotation = Schema.Struct({\n  kind: Schema.Enums(EntityKind),\n  typename: Typename,\n  version: Version,\n\n  /**\n   * If this is a relation, the schema of the source object.\n   * Must be present if entity kind is {@link EntityKind.Relation}.\n   */\n  sourceSchema: Schema.optional(DXN.Schema),\n\n  /**\n   * If this is a relation, the schema of the target object.\n   * Must be present if entity kind is {@link EntityKind.Relation}.\n   */\n  targetSchema: Schema.optional(DXN.Schema),\n});\n\nexport interface TypeAnnotation extends Schema.Schema.Type<typeof TypeAnnotation> {}\n\nexport type TypeMeta = Pick<TypeAnnotation, 'typename' | 'version'>;\n\n/**\n * @returns {@link TypeAnnotation} from a schema.\n * Schema must have been created with {@link TypedObject} or {@link TypedLink} or manually assigned an appropriate annotation.\n */\nexport const getTypeAnnotation = (schema: Schema.Schema.All): TypeAnnotation | undefined => {\n  assertArgument(schema != null && schema.ast != null, 'invalid schema');\n  return flow(\n    SchemaAST.getAnnotation<TypeAnnotation>(TypeAnnotationId),\n    Option.getOrElse(() => undefined),\n  )(schema.ast);\n};\n\n/**\n * @returns {@link EntityKind} from a schema.\n */\nexport const getEntityKind = (schema: Schema.Schema.All): EntityKind | undefined => getTypeAnnotation(schema)?.kind;\n\n/**\n * @deprecated Use {@link Type.getTypename} instead.\n * @returns Schema typename (without dxn: prefix or version number).\n */\nexport const getSchemaTypename = (schema: Schema.Schema.All): string | undefined => getTypeAnnotation(schema)?.typename;\n\n/**\n * @deprecated Use {@link Type.getVersion} instead.\n * @returns Schema version in semver format.\n */\nexport const getSchemaVersion = (schema: Schema.Schema.All): string | undefined => getTypeAnnotation(schema)?.version;\n\n/**\n * PropertyMeta (metadata for dynamic schema properties).\n * For user-defined annotations.\n */\nexport const PropertyMetaAnnotationId = Symbol.for('@dxos/schema/annotation/PropertyMeta');\n\nexport type PropertyMetaValue = Primitive | Record<string, Primitive> | Primitive[];\n\nexport type PropertyMetaAnnotation = {\n  [name: string]: PropertyMetaValue;\n};\n\nexport const PropertyMeta = (name: string, value: PropertyMetaValue) => {\n  return <A, I, R>(self: Schema.Schema<A, I, R>): Schema.Schema<A, I, R> => {\n    const existingMeta = self.ast.annotations[PropertyMetaAnnotationId] as PropertyMetaAnnotation;\n    return self.annotations({\n      [PropertyMetaAnnotationId]: {\n        ...existingMeta,\n        [name]: value,\n      },\n    });\n  };\n};\n\nexport const getPropertyMetaAnnotation = <T>(prop: SchemaAST.PropertySignature, name: string) =>\n  pipe(\n    SchemaAST.getAnnotation<PropertyMetaAnnotation>(PropertyMetaAnnotationId)(prop.type),\n    Option.map((meta) => meta[name] as T),\n    Option.getOrElse(() => undefined),\n  );\n\n/**\n * Schema reference.\n */\nexport const ReferenceAnnotationId = Symbol.for('@dxos/schema/annotation/Reference');\n\nexport type ReferenceAnnotationValue = TypeAnnotation;\n\nexport const getReferenceAnnotation = (schema: Schema.Schema.AnyNoContext) =>\n  pipe(\n    SchemaAST.getAnnotation<ReferenceAnnotationValue>(ReferenceAnnotationId)(schema.ast),\n    Option.getOrElse(() => undefined),\n  );\n\n/**\n * SchemaMeta.\n */\nexport const SchemaMetaSymbol = Symbol.for('@dxos/schema/SchemaMeta');\n\nexport type SchemaMeta = TypeMeta & { id: string };\n\n/**\n * Identifies label property or JSON path expression.\n * Either a string or an array of strings representing field accessors each matched in priority order.\n */\nexport const LabelAnnotationId = Symbol.for('@dxos/schema/annotation/Label');\n\nexport const LabelAnnotation = createAnnotationHelper<string[]>(LabelAnnotationId);\n\n/**\n * Default field to be used on referenced schema to lookup the value.\n */\nexport const FieldLookupAnnotationId = Symbol.for('@dxos/schema/annotation/FieldLookup');\n\n/**\n * Generate test data.\n */\nexport const GeneratorAnnotationId = Symbol.for('@dxos/schema/annotation/Generator');\n\n/** [path, probability] */\nexport type GeneratorAnnotationValue = string | [string, number];\n\nexport const GeneratorAnnotation = createAnnotationHelper<GeneratorAnnotationValue>(GeneratorAnnotationId);\n\n/**\n * @returns DXN of the schema.\n *\n * For non-stored schema returns `dxn:type:`.\n * For stored schema returns `dxn:echo:`.\n * @deprecated Use `Type.getDXN`.\n */\nexport const getSchemaDXN = (schema: Schema.Schema.All): DXN | undefined => {\n  assertArgument(Schema.isSchema(schema), 'invalid schema');\n\n  const id = getTypeIdentifierAnnotation(schema);\n  if (id) {\n    return DXN.parse(id);\n  }\n\n  // TODO(dmaretskyi): Add support for dynamic schema.\n  const objectAnnotation = getTypeAnnotation(schema);\n  if (!objectAnnotation) {\n    return undefined;\n  }\n\n  return DXN.fromTypenameAndVersion(objectAnnotation.typename, objectAnnotation.version);\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { PropertyMeta } from './annotations';\n\n/**\n * @internal\n */\nexport const FIELD_PATH_ANNOTATION = 'path';\n\n/**\n * Sets the path for the field.\n * @param path Data source path in the json path format. This is the field path in the source object.\n */\n// TODO(burdon): Field, vs. path vs. property.\nexport const FieldPath = (path: string) => PropertyMeta(FIELD_PATH_ANNOTATION, path);\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { type Schema } from 'effect';\n\nimport { type ForeignKey } from '@dxos/echo-protocol';\nimport { invariant } from '@dxos/invariant';\nimport { DXN, ObjectId } from '@dxos/keys';\nimport { assumeType } from '@dxos/util';\n\nimport { type ObjectMeta } from './meta';\nimport { EntityKind } from '../ast';\n\n//\n// Defines the internal model of the echo object.\n//\n\n/**\n * Entity kind.\n */\nexport const EntityKindId = Symbol('@dxos/echo/EntityKind');\n\n/**\n * DXN to the object itself.\n */\nexport const SelfDXNId = Symbol('@dxos/echo/Self');\n\n/**\n * Property name for self DXN when object is serialized to JSON.\n */\nexport const ATTR_SELF_DXN = '@self';\n\n/**\n * DXN to the object type.\n */\nexport const TypeId = Symbol('@dxos/echo/Type');\n\n/**\n * Property name for typename when object is serialized to JSON.\n */\nexport const ATTR_TYPE = '@type';\n\n/**\n * Reference to the object schema.\n */\nexport const SchemaId = Symbol('@dxos/echo/Schema');\n\n/**\n * Deletion marker.\n */\nexport const DeletedId = Symbol('@dxos/echo/Deleted');\n\n/**\n * Property name for deleted when object is serialized to JSON.\n */\nexport const ATTR_DELETED = '@deleted';\n\n/**\n * Metadata section.\n */\nexport const MetaId = Symbol('@dxos/echo/Meta');\n\n/**\n * Property name for meta when object is serialized to JSON.\n */\nexport const ATTR_META = '@meta';\n\n/**\n * Used to access relation source ref on live ECHO objects.\n * Reading this symbol must return `Live<EchoObject<any>>` or a DXN.\n */\nexport const RelationSourceDXNId: unique symbol = Symbol('@dxos/echo/RelationSourceDXN');\n\n/**\n * Property name for relation source when object is serialized to JSON.\n */\nexport const ATTR_RELATION_SOURCE = '@relationSource';\n\n/**\n * Used to access relation target ref on live ECHO objects.\n * Reading this symbol must return `Live<EchoObject<any>>` or a DXN.\n */\nexport const RelationTargetDXNId: unique symbol = Symbol('@dxos/echo/RelationTargetDXN');\n\n/**\n * Property name for relation target when object is serialized to JSON.\n */\nexport const ATTR_RELATION_TARGET = '@relationTarget';\n\n/**\n * Used to access relation source ref on live ECHO objects.\n * Reading this symbol must return `Live<EchoObject<any>>` or a DXN.\n */\nexport const RelationSourceId: unique symbol = Symbol('@dxos/echo/RelationSource');\n\n/**\n * Used to access relation target ref on live ECHO objects.\n * Reading this symbol must return `Live<EchoObject<any>>` or a DXN.\n */\nexport const RelationTargetId: unique symbol = Symbol('@dxos/echo/RelationTarget');\n\n/**\n * Internal runtime representation of an object.\n * The fields are accessed through getter functions.\n */\nexport interface InternalObjectProps {\n  id: ObjectId;\n  readonly [SelfDXNId]?: DXN;\n\n  // Echo supports untyped objects O_O.\n  readonly [TypeId]?: DXN;\n\n  /**\n   * Returns the schema for the object.\n   */\n  readonly [SchemaId]?: Schema.Schema.AnyNoContext;\n  readonly [EntityKindId]: EntityKind;\n  readonly [DeletedId]?: boolean;\n  readonly [MetaId]?: ObjectMeta;\n  readonly [RelationSourceDXNId]?: DXN;\n  readonly [RelationTargetDXNId]?: DXN;\n  readonly [RelationSourceId]?: InternalObjectProps;\n  readonly [RelationTargetId]?: InternalObjectProps;\n}\n\n/**\n * JSON representation of an object or relation.\n */\nexport interface ObjectJSON {\n  id: string;\n  [ATTR_SELF_DXN]?: DXN.String;\n  [ATTR_TYPE]: DXN.String;\n  [ATTR_DELETED]?: boolean;\n  [ATTR_META]?: ObjectMetaJSON;\n  [ATTR_RELATION_SOURCE]?: DXN.String;\n  [ATTR_RELATION_TARGET]?: DXN.String;\n}\n\nexport interface ObjectMetaJSON {\n  keys: ForeignKey[];\n}\n\n// NOTE: Keep as `function` to avoid type inference issues.\n// eslint-disable-next-line @stayradiated/prefer-arrow-functions/prefer-arrow-functions\nexport function assertObjectModelShape(obj: unknown): asserts obj is InternalObjectProps {\n  invariant(typeof obj === 'object' && obj !== null, 'Invalid object model: not an object');\n  assumeType<InternalObjectProps>(obj);\n  invariant(ObjectId.isValid(obj.id), 'Invalid object model: invalid id');\n  invariant(obj[TypeId] === undefined || obj[TypeId] instanceof DXN, 'Invalid object model: invalid type');\n  invariant(\n    obj[EntityKindId] === EntityKind.Object || obj[EntityKindId] === EntityKind.Relation,\n    'Invalid object model: invalid entity kind',\n  );\n  if (obj[EntityKindId] === EntityKind.Relation) {\n    invariant(obj[RelationSourceDXNId] instanceof DXN, 'Invalid object model: invalid relation source');\n    invariant(obj[RelationTargetDXNId] instanceof DXN, 'Invalid object model: invalid relation target');\n    invariant(!(obj[RelationSourceId] instanceof DXN), 'Invalid object model: source pointer is a DXN');\n    invariant(!(obj[RelationTargetId] instanceof DXN), 'Invalid object model: target pointer is a DXN');\n  }\n}\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { Schema } from 'effect';\n\nimport { getField, type JsonPath } from '@dxos/effect';\nimport { assertArgument, invariant } from '@dxos/invariant';\nimport { DXN, ObjectId } from '@dxos/keys';\nimport { assumeType } from '@dxos/util';\n\nimport { type InternalObjectProps, SchemaId } from './model';\nimport { LabelAnnotationId } from '../ast';\n\n//\n// Accessors based on model.\n//\n\n/**\n * Returns a DXN for an object or schema.\n * @deprecated Use `Obj.getDXN`.\n */\nexport const getObjectDXN = (object: any): DXN | undefined => {\n  invariant(!Schema.isSchema(object), 'schema not allowed in this function');\n  assertArgument(typeof object === 'object' && object != null, 'expected object');\n  assumeType<InternalObjectProps>(object);\n\n  // TODO(dmaretskyi): Use SelfDXNId.\n\n  if (!ObjectId.isValid(object.id)) {\n    throw new TypeError('Object id is not valid.');\n  }\n\n  return DXN.fromLocalObjectId(object.id);\n};\n\n/**\n * Returns the schema for the given object if one is defined.\n */\n// TODO(burdon): Reconcile with `getTypename`.\n// TODO(dmaretskyi): For echo objects, this always returns the root schema.\nexport const getSchema = (obj: unknown | undefined): Schema.Schema.AnyNoContext | undefined => {\n  if (obj) {\n    return (obj as any)[SchemaId];\n  }\n};\n\n/**\n * Internal use only.\n */\nexport const setSchema = (obj: any, schema: Schema.Schema.AnyNoContext) => {\n  Object.defineProperty(obj, SchemaId, {\n    value: schema,\n    writable: false,\n    enumerable: false,\n    configurable: false,\n  });\n};\n\n/**\n * @deprecated Use {@link Obj.getLabel} instead.\n * Returns the label for a given object based on {@link LabelAnnotationId}.\n */\nexport const getLabelForObject = (obj: unknown | undefined): string | undefined => {\n  const schema = getSchema(obj);\n  if (schema) {\n    return getLabel(schema, obj);\n  }\n};\n\n/**\n * Returns the label for a given object based on {@link LabelAnnotationId}.\n */\n// TODO(burdon): Convert to JsonPath?\nexport const getLabel = <S extends Schema.Schema.Any>(schema: S, object: Schema.Schema.Type<S>): string | undefined => {\n  let annotation = schema.ast.annotations[LabelAnnotationId];\n  if (!annotation) {\n    return undefined;\n  }\n  if (!Array.isArray(annotation)) {\n    annotation = [annotation];\n  }\n\n  for (const accessor of annotation as string[]) {\n    assertArgument(typeof accessor === 'string', 'Label annotation must be a string or an array of strings');\n    const value = getField(object, accessor as JsonPath);\n    switch (typeof value) {\n      case 'string':\n      case 'number':\n      case 'boolean':\n      case 'bigint':\n      case 'symbol':\n        return value.toString();\n      case 'undefined':\n      case 'object':\n      case 'function':\n        continue;\n    }\n  }\n\n  return undefined;\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { invariant } from '@dxos/invariant';\nimport { DXN } from '@dxos/keys';\n\nimport { getSchema } from './accessors';\nimport { TypeId } from './model';\nimport { getSchemaTypename } from '../ast';\nimport { type BaseObject } from '../types';\n\n/**\n * Gets the typename of the object without the version.\n * Returns only the name portion, not the DXN.\n * @example \"example.org/type/Contact\"\n */\nexport const getTypename = (obj: BaseObject): string | undefined => {\n  const schema = getSchema(obj);\n  if (schema != null) {\n    // Try to extract typename from DXN.\n    return getSchemaTypename(schema);\n  } else {\n    const type = getType(obj);\n    return type?.asTypeDXN()?.type;\n  }\n};\n\n/**\n * @internal\n */\n// TODO(dmaretskyi): Rename setTypeDXN.\nexport const setTypename = (obj: any, typename: DXN) => {\n  invariant(typename instanceof DXN, 'Invalid type.');\n  Object.defineProperty(obj, TypeId, {\n    value: typename,\n    writable: false,\n    enumerable: false,\n    configurable: false,\n  });\n};\n\n/**\n * @returns Object type as {@link DXN}.\n * @returns undefined if the object doesn't have a type.\n * @example `dxn:example.com/type/Contact:1.0.0`\n */\nexport const getType = (obj: BaseObject): DXN | undefined => {\n  if (!obj) {\n    return undefined;\n  }\n\n  const type = (obj as any)[TypeId];\n  if (!type) {\n    return undefined;\n  }\n\n  invariant(type instanceof DXN, 'Invalid object.');\n  return type;\n};\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { Schema } from 'effect';\n\nimport { getTypename } from './typename';\nimport { type BaseObject } from '../types';\n\n// TODO(dmaretskyi): Rename to represent commonality between objects and relations (e.g. `entity`).\nexport type TypedObjectOptions = {\n  // TODO(burdon): Document.\n  partial?: true;\n  // TODO(burdon): Document.\n  record?: true;\n};\n\n/**\n *\n */\n// TODO(burdon): Comment required.\n// TODO(dmaretskyi): Rename to represent commonality between objects and relations (e.g. `entity`).\ntype SimplifiedSchemaFields<\n  SchemaFields extends Schema.Struct.Fields,\n  Options extends TypedObjectOptions,\n> = Options['partial'] extends boolean\n  ? Schema.SimplifyMutable<Partial<Schema.Struct.Type<SchemaFields>>>\n  : Schema.SimplifyMutable<Schema.Struct.Type<SchemaFields>>;\n\n/**\n *\n */\n// TODO(burdon): Comment required.\n// TODO(dmaretskyi): Rename to represent commonality between objects and relations (e.g. `entity`).\nexport type TypedObjectFields<\n  SchemaFields extends Schema.Struct.Fields,\n  Options extends TypedObjectOptions,\n> = SimplifiedSchemaFields<SchemaFields, Options> & { id: string } & (Options['record'] extends boolean\n    ? Schema.SimplifyMutable<Schema.IndexSignature.Type<Schema.IndexSignature.Records>>\n    : {});\n\nexport const makeTypedEntityClass = (\n  typename: string,\n  version: string,\n  baseSchema: Schema.Schema.AnyNoContext,\n): Schema.SchemaClass<any> => {\n  return class {\n    // Implement TypedObject properties.\n    static readonly typename = typename;\n    static readonly version = version;\n\n    // Implement Schema.Schema properties.\n    // TODO(burdon): Comment required.\n    static readonly [Schema.TypeId] = schemaVariance;\n    static readonly ast = baseSchema.ast;\n    static readonly annotations = baseSchema.annotations.bind(baseSchema);\n    static readonly pipe = baseSchema.pipe.bind(baseSchema);\n\n    // TODO(burdon): Comment required.\n    static [Symbol.hasInstance](obj: BaseObject) {\n      return obj != null && getTypename(obj) === typename;\n    }\n\n    // TODO(burdon): Throw APIError.\n    private constructor() {\n      throw new Error('Use live(Typename, { ...fields }) to instantiate an object.');\n    }\n  } as any;\n};\n\nconst schemaVariance = {\n  _A: (_: any) => _,\n  _I: (_: any) => _,\n  _R: (_: never) => _,\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { Schema } from 'effect';\n\nimport { ForeignKey } from '@dxos/echo-protocol';\nimport { invariant } from '@dxos/invariant';\nimport { type Comparator, intersection } from '@dxos/util';\n\nimport { MetaId } from './model';\nimport type { BaseObject } from '../types';\n\n//\n// ObjectMeta\n//\n\n// TODO(dmaretskyi): Rename to ObjectMeta\nexport const ObjectMetaSchema = Schema.Struct({\n  keys: Schema.mutable(Schema.Array(ForeignKey)),\n});\n\nexport type ObjectMeta = Schema.Schema.Type<typeof ObjectMetaSchema>;\n\nexport const foreignKey = (source: string, id: string): ForeignKey => ({ source, id });\nexport const foreignKeyEquals = (a: ForeignKey, b: ForeignKey) => a.source === b.source && a.id === b.id;\n\n/**\n * Get metadata from object.\n * Only callable on the object root.\n * @deprecated Use {@link getMeta}.\n */\n// TODO(dmaretskyi): Remove.\nexport const getObjectMeta = (object: any): ObjectMeta => {\n  return getMeta(object);\n};\n\n/*\n * Get metadata from object.\n * Only callable on the object root.\n */\nexport const getMeta = (obj: BaseObject): ObjectMeta => {\n  const metadata = (obj as any)[MetaId];\n  invariant(metadata, 'ObjectMeta not found.');\n  return metadata;\n};\n\n// TODO(dmaretskyi): Move to echo-schema.\nexport const compareForeignKeys: Comparator<BaseObject> = (a: BaseObject, b: BaseObject) =>\n  intersection(getMeta(a).keys, getMeta(b).keys, foreignKeyEquals).length > 0;\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { Effect, Option, ParseResult, Schema, SchemaAST } from 'effect';\n\nimport { Reference, type EncodedReference } from '@dxos/echo-protocol';\nimport { compositeRuntime } from '@dxos/echo-signals/runtime';\nimport { assertArgument, invariant } from '@dxos/invariant';\nimport { DXN, ObjectId } from '@dxos/keys';\n\nimport { getSchemaDXN, getTypeAnnotation, getTypeIdentifierAnnotation, ReferenceAnnotationId } from '../ast';\nimport { type JsonSchemaType } from '../json-schema';\nimport type { BaseObject, WithId } from '../types';\n\n/**\n * The `$id` field for an ECHO reference schema.\n */\nexport const JSON_SCHEMA_ECHO_REF_ID = '/schemas/echo/ref';\n\n// TODO(burdon): Define return type.\nexport const getSchemaReference = (property: JsonSchemaType): { typename: string } | undefined => {\n  const { $id, reference: { schema: { $ref } = {} } = {} } = property;\n  if ($id === JSON_SCHEMA_ECHO_REF_ID && $ref) {\n    return { typename: DXN.parse($ref).typename };\n  }\n};\n\nexport const createSchemaReference = (typename: string): JsonSchemaType => {\n  return {\n    $id: JSON_SCHEMA_ECHO_REF_ID,\n    reference: {\n      schema: {\n        $ref: DXN.fromTypename(typename).toString(),\n      },\n    },\n  };\n};\n\nexport const RefTypeId: unique symbol = Symbol('@dxos/echo-schema/Ref');\n\n/**\n * Reference Schema.\n */\nexport interface Ref$<T extends WithId> extends Schema.SchemaClass<Ref<T>, EncodedReference> {}\n\n// Type of the `Ref` function and extra methods attached to it.\nexport interface RefFn {\n  <S extends Schema.Schema.Any>(schema: S): Ref$<Schema.Schema.Type<S>>;\n\n  /**\n   * @returns True if the object is a reference.\n   */\n  isRef: (obj: any) => obj is Ref<any>;\n\n  /**\n   * @returns True if the reference points to the given object id.\n   */\n  hasObjectId: (id: ObjectId) => (ref: Ref<any>) => boolean;\n\n  /**\n   * @returns True if the schema is a reference schema.\n   */\n  isRefSchema: (schema: Schema.Schema<any, any>) => schema is Ref$<any>;\n\n  /**\n   * @returns True if the schema AST is a reference schema.\n   */\n  isRefSchemaAST: (ast: SchemaAST.AST) => boolean;\n\n  /**\n   * Constructs a reference that points to the given object.\n   */\n  // TODO(burdon): Tighten type of T?\n  make: <T extends WithId>(object: T) => Ref<T>;\n\n  /**\n   * Constructs a reference that points to the object specified by the provided DXN.\n   */\n  fromDXN: (dxn: DXN) => Ref<any>;\n}\n/**\n * Schema builder for references.\n */\nexport const Ref: RefFn = <S extends Schema.Schema.Any>(schema: S): Ref$<Schema.Schema.Type<S>> => {\n  assertArgument(Schema.isSchema(schema), 'Must call with an instance of effect-schema');\n\n  const annotation = getTypeAnnotation(schema);\n  if (annotation == null) {\n    throw new Error('Reference target must be an ECHO schema.');\n  }\n\n  return createEchoReferenceSchema(\n    getTypeIdentifierAnnotation(schema),\n    annotation.typename,\n    annotation.version,\n    getSchemaExpectedName(schema.ast),\n  );\n};\n\n/**\n * Represents materialized reference to a target.\n * This is the data type for the fields marked as ref.\n */\nexport interface Ref<T> {\n  /**\n   * Target object DXN.\n   */\n  get dxn(): DXN;\n\n  /**\n   * @returns The reference target.\n   * May return `undefined` if the object is not loaded in the working set.\n   * Accessing this property, even if it returns `undefined` will trigger the object to be loaded to the working set.\n   *\n   * @reactive Supports signal subscriptions.\n   */\n  get target(): T | undefined;\n\n  /**\n   * @returns Promise that will resolves with the target object.\n   * Will load the object from disk if it is not present in the working set.\n   * @throws If the object is not available locally.\n   */\n  load(): Promise<T>;\n\n  /**\n   * @returns Promise that will resolves with the target object or undefined if the object is not loaded locally.\n   */\n  tryLoad(): Promise<T | undefined>;\n\n  /**\n   * Do not inline the target object in the reference.\n   * Makes .target unavailable unless the reference is connected to a database context.\n   *\n   * When serialized with toJSON, the difference is between:\n   * `{ \"/\": \"dxn:...\" }`\n   * and\n   * `{ \"/\": \"dxn:...\", \"target\": { ... } }`\n   */\n  noInline(): this;\n\n  /**\n   * Serializes the reference to a JSON object.\n   * The serialization format is compatible with the IPLD-style encoded references.\n   * When a reference has a saved target (i.e. the target or object holding the reference is not in the database),\n   * the target is included in the serialized object.\n   *\n   * Examples:\n   * `{ \"/\": \"dxn:...\" }`\n   * `{ \"/\": \"dxn:...\", \"target\": { ... } }`\n   */\n  encode(): EncodedReference;\n\n  [RefTypeId]: {\n    _T: T;\n  };\n}\n\nexport declare namespace Ref {\n  /**\n   * Target of the reference.\n   */\n  export type Target<R> = R extends Ref<infer U> ? U : never;\n}\n\nRef.isRef = (obj: any): obj is Ref<any> => {\n  return obj && typeof obj === 'object' && RefTypeId in obj;\n};\n\nRef.hasObjectId = (id: ObjectId) => (ref: Ref<any>) => ref.dxn.isLocalObjectId() && ref.dxn.parts[1] === id;\n\nRef.isRefSchema = (schema: Schema.Schema<any, any>): schema is Ref$<any> => {\n  return Ref.isRefSchemaAST(schema.ast);\n};\n\nRef.isRefSchemaAST = (ast: SchemaAST.AST): boolean => {\n  return SchemaAST.getAnnotation(ast, ReferenceAnnotationId).pipe(Option.isSome);\n};\n\nRef.make = <T extends BaseObject>(obj: T): Ref<T> => {\n  if (typeof obj !== 'object' || obj === null) {\n    throw new TypeError('Expected: ECHO object.');\n  }\n\n  // TODO(dmaretskyi): Extract to `getObjectDXN` function.\n  const id = obj.id;\n  invariant(ObjectId.isValid(id), 'Invalid object ID');\n  const dxn = Reference.localObjectReference(id).toDXN();\n  return new RefImpl(dxn, obj);\n};\n\nRef.fromDXN = (dxn: DXN): Ref<any> => {\n  return new RefImpl(dxn);\n};\n\n/**\n * `reference` field on the schema object.\n */\nexport type JsonSchemaReferenceInfo = {\n  schema: { $ref: string };\n  schemaVersion?: string;\n};\n\n/**\n * @internal\n */\n// TODO(burdon): Move to json schema and make private?\nexport const createEchoReferenceSchema = (\n  echoId: string | undefined,\n  typename: string | undefined,\n  version: string | undefined,\n  schemaName?: string,\n): Schema.SchemaClass<Ref<any>, EncodedReference> => {\n  if (!echoId && !typename) {\n    throw new TypeError('Either echoId or typename must be provided.');\n  }\n\n  const referenceInfo: JsonSchemaReferenceInfo = {\n    schema: {\n      // TODO(dmaretskyi): Include version?\n      $ref: echoId ?? DXN.fromTypename(typename!).toString(),\n    },\n    schemaVersion: version,\n  };\n\n  // TODO(dmaretskyi): Add name and description.\n  const refSchema = Schema.declare<Ref<any>, EncodedReference, []>(\n    [],\n    {\n      encode: () => {\n        return (value) => {\n          return Effect.succeed({\n            '/': (value as Ref<any>).dxn.toString(),\n          });\n        };\n      },\n      decode: () => {\n        return (value) => {\n          // TODO(dmaretskyi): This branch seems to be taken by Schema.is\n          if (Ref.isRef(value)) {\n            return Effect.succeed(value);\n          }\n\n          if (typeof value !== 'object' || value == null || typeof (value as any)['/'] !== 'string') {\n            return Effect.fail(new ParseResult.Unexpected(value, 'reference'));\n          }\n\n          return Effect.succeed(Ref.fromDXN(DXN.parse((value as any)['/'])));\n        };\n      },\n    },\n    {\n      jsonSchema: {\n        $id: JSON_SCHEMA_ECHO_REF_ID,\n        reference: referenceInfo,\n      },\n      [ReferenceAnnotationId]: {\n        typename: typename ?? '',\n        version,\n      },\n    },\n  );\n\n  return refSchema;\n};\n\nconst getSchemaExpectedName = (ast: SchemaAST.Annotated): string | undefined => {\n  return SchemaAST.getIdentifierAnnotation(ast).pipe(\n    Option.orElse(() => SchemaAST.getTitleAnnotation(ast)),\n    Option.orElse(() => SchemaAST.getDescriptionAnnotation(ast)),\n    Option.getOrElse(() => undefined),\n  );\n};\n\nexport interface RefResolver {\n  /**\n   * Resolve ref synchronously from the objects in the working set.\n   *\n   * @param dxn\n   * @param load If true the resolver should attempt to load the object from disk.\n   * @param onLoad Callback to call when the object is loaded.\n   */\n  resolveSync(dxn: DXN, load: boolean, onLoad?: () => void): BaseObject | undefined;\n\n  /**\n   * Resolver ref asynchronously.\n   */\n  resolve(dxn: DXN): Promise<BaseObject | undefined>;\n\n  // TODO(dmaretskyi): Combine with `resolve`.\n  resolveSchema(dxn: DXN): Promise<Schema.Schema.AnyNoContext | undefined>;\n}\n\nexport class RefImpl<T> implements Ref<T> {\n  #dxn: DXN;\n  #resolver?: RefResolver = undefined;\n  #signal = compositeRuntime.createSignal();\n\n  /**\n   * Target is set when the reference is created from a specific object.\n   * In this case, the target might not be in the database.\n   */\n  #target: T | undefined = undefined;\n\n  /**\n   * Callback to issue a reactive notification when object is resolved.\n   */\n  #resolverCallback = () => {\n    this.#signal.notifyWrite();\n  };\n\n  constructor(dxn: DXN, target?: T) {\n    this.#dxn = dxn;\n    this.#target = target;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  get dxn(): DXN {\n    return this.#dxn;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  get target(): T | undefined {\n    this.#signal.notifyRead();\n    if (this.#target) {\n      return this.#target;\n    }\n\n    invariant(this.#resolver, 'Resolver is not set');\n    return this.#resolver.resolveSync(this.#dxn, true, this.#resolverCallback) as T | undefined;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async load(): Promise<T> {\n    invariant(this.#resolver, 'Resolver is not set');\n    const obj = await this.#resolver.resolve(this.#dxn);\n    if (obj == null) {\n      throw new Error('Object not found');\n    }\n    return obj as T;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async tryLoad(): Promise<T | undefined> {\n    invariant(this.#resolver, 'Resolver is not set');\n    return (await this.#resolver.resolve(this.#dxn)) as T | undefined;\n  }\n\n  /**\n   * Do not inline the target object in the reference.\n   * Makes .target unavailable unless the reference is connected to a database context.\n   */\n  noInline(): this {\n    this.#target = undefined;\n    return this;\n  }\n\n  encode(): EncodedReference {\n    return {\n      '/': this.#dxn.toString(),\n      ...(this.#target ? { target: this.#target } : {}),\n    };\n  }\n\n  /**\n   * Serializes the reference to a JSON object.\n   * The serialization format is compatible with the IPLD-style encoded references.\n   * When a reference has a saved target (i.e. the target or object holding the reference is not in the database),\n   * the target is included in the serialized object.\n   */\n  toJSON(): EncodedReference {\n    return this.encode();\n  }\n\n  toString(): string {\n    if (this.#target) {\n      return `Ref(${this.#target.toString()})`;\n    }\n\n    return `Ref(${this.#dxn.toString()})`;\n  }\n\n  [RefTypeId] = refVariance;\n\n  /**\n   * Internal method to set the resolver.\n   * @internal\n   */\n  _setResolver(resolver: RefResolver): void {\n    this.#resolver = resolver;\n  }\n\n  /**\n   * Internal method to get the saved target.\n   * Not the same as `target` which is resolved from the resolver.\n   * @internal\n   */\n  _getSavedTarget(): T | undefined {\n    return this.#target;\n  }\n}\n\n/**\n * Internal API for setting the reference resolver.\n */\nexport const setRefResolver = (ref: Ref<any>, resolver: RefResolver) => {\n  invariant(ref instanceof RefImpl, 'Ref is not an instance of RefImpl');\n  ref._setResolver(resolver);\n};\n\n/**\n * Internal API for getting the saved target on a reference.\n */\nexport const getRefSavedTarget = (ref: Ref<any>): BaseObject | undefined => {\n  invariant(ref instanceof RefImpl, 'Ref is not an instance of RefImpl');\n  return ref._getSavedTarget();\n};\n\n// Used to validate reference target type.\nconst refVariance: Ref<any>[typeof RefTypeId] = {\n  _T: null as any,\n};\n\nexport const refFromEncodedReference = (encodedReference: EncodedReference, resolver?: RefResolver): Ref<any> => {\n  const dxn = DXN.parse(encodedReference['/']);\n  const ref = new RefImpl(dxn);\n\n  // TODO(dmaretskyi): Handle inline target in the encoded reference.\n\n  if (resolver) {\n    setRefResolver(ref, resolver);\n  }\n  return ref;\n};\n\nexport class StaticRefResolver implements RefResolver {\n  public objects = new Map<ObjectId, BaseObject>();\n  public schemas = new Map<DXN.String, Schema.Schema.AnyNoContext>();\n\n  addObject(obj: BaseObject): this {\n    this.objects.set(obj.id, obj);\n    return this;\n  }\n\n  addSchema(schema: Schema.Schema.AnyNoContext): this {\n    const dxn = getSchemaDXN(schema);\n    invariant(dxn, 'Schema has no DXN');\n    this.schemas.set(dxn.toString(), schema);\n    return this;\n  }\n\n  resolveSync(dxn: DXN, _load: boolean, _onLoad?: () => void): BaseObject | undefined {\n    const id = dxn?.asEchoDXN()?.echoId;\n    if (id == null) {\n      return undefined;\n    }\n\n    return this.objects.get(id);\n  }\n\n  async resolve(dxn: DXN): Promise<BaseObject | undefined> {\n    const id = dxn?.asEchoDXN()?.echoId;\n    if (id == null) {\n      return undefined;\n    }\n\n    return this.objects.get(id);\n  }\n\n  async resolveSchema(dxn: DXN): Promise<Schema.Schema.AnyNoContext | undefined> {\n    return this.schemas.get(dxn.toString());\n  }\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { type ObjectId } from '@dxos/keys';\nimport { isNonNullable } from '@dxos/util';\n\nimport { Ref } from './ref';\nimport type { AnyEchoObject } from '../types';\n\n/**\n * Helper functions for working with arrays of refs.\n */\nexport const RefArray = Object.freeze({\n  /**\n   * @returns all resolved targets.\n   */\n  targets: <T extends AnyEchoObject>(refs: Ref<T>[]): T[] => {\n    return refs.map((ref) => ref.target).filter(isNonNullable);\n  },\n\n  /**\n   * Load all referenced objects.\n   */\n  loadAll: <T extends AnyEchoObject>(refs: Ref<T>[]): Promise<T[]> => {\n    return Promise.all(refs.map((ref) => ref.load()));\n  },\n\n  /**\n   * Removes the ref with the given id.\n   */\n  removeById: (refs: Ref<AnyEchoObject>[], id: ObjectId) => {\n    const index = refs.findIndex(Ref.hasObjectId(id));\n    if (index >= 0) {\n      refs.splice(index, 1);\n    }\n  },\n});\n", "//\n// Copyright 2024 DXOS.org\n//\n\n// TODO(burdon): Document.\nexport const defineHiddenProperty = (object: any, key: string | symbol, value: any) => {\n  Object.defineProperty(object, key, {\n    enumerable: false,\n    configurable: true,\n    value,\n  });\n};\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { Schema } from 'effect';\n\nimport { raise } from '@dxos/debug';\nimport { isEncodedReference, type EncodedReference } from '@dxos/echo-protocol';\nimport { assertArgument, invariant } from '@dxos/invariant';\nimport { DXN, ObjectId } from '@dxos/keys';\nimport { assumeType, deepMapValues, visitValues } from '@dxos/util';\n\nimport { setSchema } from './accessors';\nimport { ObjectMetaSchema } from './meta';\nimport {\n  ATTR_DELETED,\n  ATTR_META,\n  ATTR_RELATION_SOURCE,\n  ATTR_RELATION_TARGET,\n  ATTR_SELF_DXN,\n  ATTR_TYPE,\n  EntityKindId,\n  MetaId,\n  RelationSourceDXNId,\n  RelationTargetDXNId,\n  RelationSourceId,\n  RelationTargetId,\n  TypeId,\n  type ObjectJSON,\n  assertObjectModelShape,\n} from './model';\nimport { getType, setTypename } from './typename';\nimport { EntityKind } from '../ast';\nimport { Ref, refFromEncodedReference, setRefResolver, type RefResolver } from '../ref';\nimport { type AnyEchoObject } from '../types';\nimport { defineHiddenProperty } from '../utils';\n\ntype DeepReplaceRef<T> =\n  T extends Ref<any> ? EncodedReference : T extends object ? { [K in keyof T]: DeepReplaceRef<T[K]> } : T;\n\ntype SerializedObject<T extends { id: string }> = { [K in keyof T]: DeepReplaceRef<T[K]> } & ObjectJSON;\n\n/**\n * Converts object to it's JSON representation.\n */\nexport const objectToJSON = <T extends AnyEchoObject>(obj: T): SerializedObject<T> => {\n  const typename = getType(obj)?.toString();\n  invariant(typename && typeof typename === 'string');\n  return typedJsonSerializer.call(obj);\n};\n\n/**\n * Creates an object from it's json representation.\n * Performs schema validation.\n * References and schema will be resolvable if the `refResolver` is provided.\n *\n * The function need to be async to support resolving the schema as well as the relation endpoints.\n */\nexport const objectFromJSON = async (\n  jsonData: unknown,\n  { refResolver }: { refResolver?: RefResolver } = {},\n): Promise<AnyEchoObject> => {\n  assumeType<ObjectJSON>(jsonData);\n  assertArgument(typeof jsonData === 'object' && jsonData !== null, 'expect object');\n  assertArgument(typeof jsonData[ATTR_TYPE] === 'string', 'expected object to have a type');\n  assertArgument(typeof jsonData.id === 'string', 'expected object to have an id');\n\n  const type = DXN.parse(jsonData[ATTR_TYPE]);\n  const schema = await refResolver?.resolveSchema(type);\n  invariant(schema === undefined || Schema.isSchema(schema));\n\n  let obj: any;\n  if (schema != null) {\n    obj = await schema.pipe(Schema.decodeUnknownPromise)(jsonData);\n    if (refResolver) {\n      setRefResolverOnData(obj, refResolver);\n    }\n  } else {\n    obj = decodeGeneric(jsonData, { refResolver });\n  }\n\n  invariant(ObjectId.isValid(obj.id), 'Invalid object id');\n\n  setTypename(obj, type);\n  if (schema) {\n    setSchema(obj, schema);\n  }\n\n  const isRelation =\n    typeof jsonData[ATTR_RELATION_SOURCE] === 'string' || typeof jsonData[ATTR_RELATION_TARGET] === 'string';\n  if (isRelation) {\n    const sourceDxn: DXN = DXN.parse(jsonData[ATTR_RELATION_SOURCE] ?? raise(new TypeError('Missing relation source')));\n    const targetDxn: DXN = DXN.parse(jsonData[ATTR_RELATION_TARGET] ?? raise(new TypeError('Missing relation target')));\n\n    // TODO(dmaretskyi): Async!\n    const source = (await refResolver?.resolve(sourceDxn)) as AnyEchoObject | undefined;\n    const target = (await refResolver?.resolve(targetDxn)) as AnyEchoObject | undefined;\n\n    defineHiddenProperty(obj, EntityKindId, EntityKind.Relation);\n    defineHiddenProperty(obj, RelationSourceDXNId, sourceDxn);\n    defineHiddenProperty(obj, RelationTargetDXNId, targetDxn);\n    defineHiddenProperty(obj, RelationSourceId, source);\n    defineHiddenProperty(obj, RelationTargetId, target);\n  } else {\n    defineHiddenProperty(obj, EntityKindId, EntityKind.Object);\n  }\n\n  if (typeof jsonData[ATTR_META] === 'object') {\n    const meta = await ObjectMetaSchema.pipe(Schema.decodeUnknownPromise)(jsonData[ATTR_META]);\n\n    // Defensive programming.\n    invariant(Array.isArray(meta.keys));\n\n    defineHiddenProperty(obj, MetaId, meta);\n  }\n\n  assertObjectModelShape(obj);\n  invariant((obj as any)[ATTR_TYPE] === undefined, 'Invalid object model');\n  invariant((obj as any)[ATTR_SELF_DXN] === undefined, 'Invalid object model');\n  invariant((obj as any)[ATTR_DELETED] === undefined, 'Invalid object model');\n  invariant((obj as any)[ATTR_RELATION_SOURCE] === undefined, 'Invalid object model');\n  invariant((obj as any)[ATTR_RELATION_TARGET] === undefined, 'Invalid object model');\n  invariant((obj as any)[ATTR_META] === undefined, 'Invalid object model');\n  return obj;\n};\n\nconst decodeGeneric = (jsonData: unknown, options: { refResolver?: RefResolver }) => {\n  const {\n    [ATTR_TYPE]: _type,\n    [ATTR_META]: _meta,\n    [ATTR_DELETED]: _deleted,\n    [ATTR_RELATION_SOURCE]: _relationSource,\n    [ATTR_RELATION_TARGET]: _relationTarget,\n    [ATTR_SELF_DXN]: _selfDxn,\n    ...props\n  } = jsonData as any;\n\n  return deepMapValues(props, (value, recurse) => {\n    if (isEncodedReference(value)) {\n      return refFromEncodedReference(value, options.refResolver);\n    }\n    return recurse(value);\n  });\n};\n\nconst setRefResolverOnData = (obj: AnyEchoObject, refResolver: RefResolver) => {\n  const go = (value: unknown) => {\n    if (Ref.isRef(value)) {\n      setRefResolver(value, refResolver);\n    } else {\n      visitValues(value, go);\n    }\n  };\n\n  go(obj);\n};\n\n/**\n * @internal\n */\nexport const attachTypedJsonSerializer = (obj: any) => {\n  const descriptor = Object.getOwnPropertyDescriptor(obj, 'toJSON');\n  if (descriptor) {\n    return;\n  }\n\n  Object.defineProperty(obj, 'toJSON', {\n    value: typedJsonSerializer,\n    writable: false,\n    enumerable: false,\n    configurable: false,\n  });\n};\n\n// NOTE: KEEP as function.\nconst typedJsonSerializer = function (this: any) {\n  const { id, [TypeId]: typename, [MetaId]: meta, ...rest } = this;\n  const result: any = {\n    id,\n    [ATTR_TYPE]: typename.toString(),\n  };\n\n  if (this[RelationSourceDXNId]) {\n    const sourceDXN = this[RelationSourceDXNId];\n    invariant(sourceDXN instanceof DXN);\n    result[ATTR_RELATION_SOURCE] = sourceDXN.toString();\n  }\n  if (this[RelationTargetDXNId]) {\n    const targetDXN = this[RelationTargetDXNId];\n    invariant(targetDXN instanceof DXN);\n    result[ATTR_RELATION_TARGET] = targetDXN.toString();\n  }\n\n  if (meta) {\n    result[ATTR_META] = serializeData(meta);\n  }\n\n  Object.assign(result, serializeData(rest));\n  return result;\n};\n\nconst serializeData = (data: unknown) => {\n  return deepMapValues(data, (value, recurse) => {\n    if (Ref.isRef(value)) {\n      // TODO(dmaretskyi): Should this be configurable?\n      return value.noInline().encode();\n    }\n    return recurse(value);\n  });\n};\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { type Schema } from 'effect';\n\nimport { raise } from '@dxos/debug';\nimport { assertArgument, failedInvariant } from '@dxos/invariant';\nimport { ObjectId } from '@dxos/keys';\n\nimport { getObjectDXN, setSchema } from './accessors';\nimport { attachedTypedObjectInspector } from './inspect';\nimport { attachTypedJsonSerializer } from './json-serializer';\nimport {\n  assertObjectModelShape,\n  EntityKindId,\n  MetaId,\n  RelationSourceDXNId,\n  RelationSourceId,\n  RelationTargetDXNId,\n  RelationTargetId,\n} from './model';\nimport { setTypename } from './typename';\nimport { EntityKind, getSchemaDXN, getTypeAnnotation } from '../ast';\nimport { defineHiddenProperty } from '../utils';\n\n// Make `id` optional.\ntype CreateData<T> = T extends { id: string } ? Omit<T, 'id' | typeof EntityKindId> & { id?: string } : T;\n\n/**\n * Creates a new object instance from a schema and data, without signal reactivity.\n * This static version creates plain JavaScript objects that are not reactive/observable.\n * For reactive objects that automatically update UI when changed, use the regular live() function.\n *\n * @param schema - The Effect schema that defines the object's structure and type, piped into EchoObject\n * @param data - The data to initialize the object with. The id and @type fields are handled automatically.\n * @returns A new non-reactive object instance conforming to the schema\n * @throws {Error} If the schema is not an object schema\n * @throws {TypeError} If data contains an @type field\n *\n * @example\n * ```ts\n * const Contact = Schema.Struct({\n *   name: Schema.String,\n *   email: Schema.String,\n * }).pipe(Type.Obj({\n *   typename: 'example.com/type/Contact',\n *   version: '0.1.0',\n * }))\n *\n * // Creates a non-reactive contact object\n * const contact = create(Contact, {\n *   name: \"John\",\n *   email: \"john@example.com\",\n * })\n * ```\n */\n// TODO(burdon): Rename make.\n// TODO(burdon): Handle defaults (see Schema.make).\n// TODO(dmaretskyi): Use `Obj.make` and `Relation.make` from '@dxos/echo' instead.\nexport const create = <S extends Schema.Schema.AnyNoContext>(\n  schema: S,\n  data: CreateData<Schema.Schema.Type<S>>,\n): CreateData<Schema.Schema.Type<S>> & { id: string } => {\n  const annotation = getTypeAnnotation(schema);\n  if (!annotation) {\n    throw new Error('Schema is not an object schema');\n  }\n  assertArgument(!('@type' in data), '@type is not allowed');\n  assertArgument(!(RelationSourceDXNId in data), 'Relation source DXN is not allowed in the constructor');\n  assertArgument(!(RelationTargetDXNId in data), 'Relation target DXN is not allowed in the constructor');\n  assertArgument(\n    RelationSourceId in data === RelationTargetId in data,\n    'Relation source and target must be provided together',\n  );\n\n  const obj = { ...data, id: data.id ?? ObjectId.random() };\n  const kind = RelationSourceId in data ? EntityKind.Relation : EntityKind.Object;\n  defineHiddenProperty(obj, EntityKindId, kind);\n  setTypename(obj, getSchemaDXN(schema) ?? failedInvariant('Missing schema DXN'));\n  setSchema(obj, schema);\n  attachTypedJsonSerializer(obj);\n  attachedTypedObjectInspector(obj);\n  defineHiddenProperty(obj, MetaId, { keys: [] });\n  if (kind === EntityKind.Relation) {\n    const sourceDXN = getObjectDXN(data[RelationSourceId]) ?? raise(new Error('Unresolved relation source'));\n    const targetDXN = getObjectDXN(data[RelationTargetId]) ?? raise(new Error('Unresolved relation target'));\n    defineHiddenProperty(obj, RelationSourceDXNId, sourceDXN);\n    defineHiddenProperty(obj, RelationTargetDXNId, targetDXN);\n  }\n\n  assertObjectModelShape(obj);\n  return obj;\n};\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport type { inspect as inspectFn, InspectOptionsStylized } from 'node:util';\n\nimport { inspectCustom, type CustomInspectFunction } from '@dxos/debug';\n\nimport { ATTR_META, ATTR_TYPE, MetaId } from './model';\nimport { getType } from './typename';\nimport { type BaseEchoObject } from '../types';\n\n/*\n * @internal\n */\nexport const attachedTypedObjectInspector = (obj: any) => {\n  const descriptor = Object.getOwnPropertyDescriptor(obj, inspectCustom);\n  if (descriptor) {\n    return;\n  }\n\n  Object.defineProperty(obj, inspectCustom, {\n    value: typedObjectInspectFunction,\n    writable: false,\n    enumerable: false,\n    configurable: true,\n  });\n};\n\n// NOTE: KEEP as function.\nconst typedObjectInspectFunction: CustomInspectFunction<BaseEchoObject> = function (\n  this: BaseEchoObject,\n  depth: number,\n  options: InspectOptionsStylized,\n  inspect: typeof inspectFn,\n) {\n  const { id, ...props } = this;\n  return inspect(\n    {\n      id,\n      [ATTR_TYPE]: getType(this),\n      ...props,\n      [ATTR_META]: (this as any)[MetaId], // TODO(dmaretskyi): Couldn't use getMeta since that throw's if the object has no meta.\n    },\n    options,\n  );\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { Schema, SchemaAST, type Types } from 'effect';\n\nimport { raise } from '@dxos/debug';\nimport { invariant } from '@dxos/invariant';\nimport { DXN } from '@dxos/keys';\n\nimport { type RelationSourceTargetRefs } from './relation';\nimport {\n  getEntityKind,\n  getSchemaTypename,\n  getTypeIdentifierAnnotation,\n  EntityKind,\n  type TypeAnnotation,\n  TypeAnnotationId,\n  type TypeMeta,\n} from '../ast';\nimport { type HasId, type ToMutable } from '../types';\n\n/**\n * Pipeable function to add ECHO object annotations to a schema.\n */\n// TODO(burdon): Rename EchoType.\nexport const EchoObject: {\n  // TODO(burdon): Tighten Self type to Schema.TypeLiteral or Schema.Struct to facilitate definition of `make` method.\n  // (meta: TypeMeta): <Self extends Schema.Struct<Fields>, Fields extends Schema.Struct.Fields>(self: Self) => EchoObjectSchema<Self, Fields>;\n  (meta: TypeMeta): <Self extends Schema.Schema.Any>(self: Self) => EchoTypeSchema<Self>;\n} = ({ typename, version }) => {\n  return <Self extends Schema.Schema.Any>(self: Self): EchoTypeSchema<Self> => {\n    invariant(typeof TypeAnnotationId === 'symbol', 'Sanity.');\n    invariant(SchemaAST.isTypeLiteral(self.ast), 'Schema must be a TypeLiteral.');\n\n    // TODO(dmaretskyi): Does `Schema.mutable` work for deep mutability here?\n    // TODO(dmaretskyi): Do not do mutable here.\n    const schemaWithId = Schema.extend(Schema.mutable(self), Schema.Struct({ id: Schema.String }));\n    const ast = SchemaAST.annotations(schemaWithId.ast, {\n      // TODO(dmaretskyi): `extend` kills the annotations.\n      ...self.ast.annotations,\n      [TypeAnnotationId]: { kind: EntityKind.Object, typename, version } satisfies TypeAnnotation,\n      // TODO(dmaretskyi): TypeIdentifierAnnotationId?\n    });\n\n    return makeEchoObjectSchema<Self>(/* self.fields, */ ast, typename, version);\n  };\n};\n\nexport type EchoRelationOptions<\n  TSource extends Schema.Schema.AnyNoContext,\n  TTarget extends Schema.Schema.AnyNoContext,\n> = {\n  typename: string;\n  version: string;\n  source: TSource;\n  target: TTarget;\n};\n\nconst getDXNForRelationSchemaRef = (schema: Schema.Schema.Any): string => {\n  const identifier = getTypeIdentifierAnnotation(schema);\n  if (identifier) {\n    return identifier;\n  }\n\n  const typename = getSchemaTypename(schema);\n  if (!typename) {\n    throw new Error('Schema must have a typename');\n  }\n  return DXN.fromTypename(typename).toString();\n};\n\n// TODO(dmaretskyi): Rename?\nexport const EchoRelation = <Source extends Schema.Schema.AnyNoContext, Target extends Schema.Schema.AnyNoContext>(\n  options: EchoRelationOptions<Source, Target>,\n) => {\n  const sourceDXN = getDXNForRelationSchemaRef(options.source);\n  const targetDXN = getDXNForRelationSchemaRef(options.target);\n  if (getEntityKind(options.source) !== EntityKind.Object) {\n    raise(new Error('Source schema must be an echo object schema.'));\n  }\n  if (getEntityKind(options.target) !== EntityKind.Object) {\n    raise(new Error('Target schema must be an echo object schema.'));\n  }\n\n  return <Self extends Schema.Schema.Any>(\n    self: Self,\n  ): EchoTypeSchema<Self, RelationSourceTargetRefs<Schema.Schema.Type<Source>, Schema.Schema.Type<Target>>> => {\n    invariant(SchemaAST.isTypeLiteral(self.ast), 'Schema must be a TypeLiteral.');\n\n    // TODO(dmaretskyi): Does `Schema.mutable` work for deep mutability here?\n    // TODO(dmaretskyi): Do not do mutable here.\n    const schemaWithId = Schema.extend(Schema.mutable(self), Schema.Struct({ id: Schema.String }));\n    const ast = SchemaAST.annotations(schemaWithId.ast, {\n      // TODO(dmaretskyi): `extend` kills the annotations.\n      ...self.ast.annotations,\n      [TypeAnnotationId]: {\n        kind: EntityKind.Relation,\n        typename: options.typename,\n        version: options.version,\n        sourceSchema: sourceDXN,\n        targetSchema: targetDXN,\n      } satisfies TypeAnnotation,\n      // TODO(dmaretskyi): TypeIdentifierAnnotationId?\n    });\n\n    return makeEchoObjectSchema<Self>(/* self.fields, */ ast, options.typename, options.version);\n  };\n};\n\n// type RequiredKeys<T> = { [K in keyof T]-?: {} extends Pick<T, K> ? never : K }[keyof T];\ntype EchoTypeSchemaProps<T, ExtraFields = {}> = Types.Simplify<HasId & ToMutable<T> & ExtraFields>;\n\n// type MakeOptions =\n//   | boolean\n//   | {\n//       readonly disableValidation?: boolean;\n//     };\n\n// NOTE: Utils copied from Effect `Schema.ts`.\n// const _ownKeys = (o: object): Array<PropertyKey> =>\n//   (Object.keys(o) as Array<PropertyKey>).concat(Object.getOwnPropertySymbols(o));\n\n// const _lazilyMergeDefaults = (\n//   fields: Schema.Struct.Fields,\n//   out: Record<PropertyKey, unknown>,\n// ): { [x: string | symbol]: unknown } => {\n//   const ownKeys = _ownKeys(fields);\n//   for (const key of ownKeys) {\n//     const field = fields[key];\n//     if (out[key] === undefined && Schema.isPropertySignature(field)) {\n//       const ast = field.ast;\n//       const defaultValue = ast._tag === 'PropertySignatureDeclaration' ? ast.defaultValue : ast.to.defaultValue;\n//       if (defaultValue !== undefined) {\n//         out[key] = defaultValue();\n//       }\n//     }\n//   }\n//   return out;\n// };\n\n// const _getDisableValidationMakeOption = (options: MakeOptions | undefined): boolean =>\n//   Predicate.isBoolean(options) ? options : options?.disableValidation ?? false;\n\nexport interface EchoTypeSchema<Self extends Schema.Schema.Any, ExtraFields = {}>\n  extends TypeMeta,\n    Schema.AnnotableClass<\n      EchoTypeSchema<Self, ExtraFields>,\n      EchoTypeSchemaProps<Schema.Schema.Type<Self>, ExtraFields>,\n      EchoTypeSchemaProps<Schema.Schema.Encoded<Self>, ExtraFields>,\n      Schema.Schema.Context<Self>\n    > {\n  // make(\n  //   props: RequiredKeys<Schema.TypeLiteral.Constructor<Fields, []>> extends never\n  //     ? void | Simplify<Schema.TypeLiteral.Constructor<Fields, []>>\n  //     : Simplify<Schema.TypeLiteral.Constructor<Fields, []>>,\n  //   options?: MakeOptions,\n  // ): Simplify<Schema.TypeLiteral.Type<Fields, []>>;\n\n  instanceOf(value: unknown): boolean;\n}\n\nconst makeEchoObjectSchema = <Self extends Schema.Schema.Any>(\n  // fields: Fields,\n  ast: SchemaAST.AST,\n  typename: string,\n  version: string,\n): EchoTypeSchema<Self> => {\n  return class EchoObjectSchemaClass extends Schema.make<\n    EchoTypeSchemaProps<Schema.Schema.Type<Self>>,\n    EchoTypeSchemaProps<Schema.Schema.Encoded<Self>>,\n    Schema.Schema.Context<Self>\n  >(ast) {\n    static readonly typename = typename;\n    static readonly version = version;\n\n    static override annotations(\n      annotations: Schema.Annotations.GenericSchema<EchoTypeSchemaProps<Schema.Schema.Type<Self>>>,\n    ): EchoTypeSchema<Self> {\n      const schema = Schema.make<EchoTypeSchemaProps<Schema.Schema.Type<Self>>>(ast).annotations(annotations);\n      return makeEchoObjectSchema<Self>(/* fields, */ schema.ast, typename, version);\n    }\n\n    // static make(\n    //   props: RequiredKeys<Schema.TypeLiteral.Constructor<Fields, []>> extends never\n    //     ? void | Simplify<Schema.TypeLiteral.Constructor<Fields, []>>\n    //     : Simplify<Schema.TypeLiteral.Constructor<Fields, []>>,\n    //   options?: MakeOptions,\n    // ): Simplify<Schema.TypeLiteral.Type<Fields, []>> {\n    //   const propsWithDefaults: any = _lazilyMergeDefaults(fields, { ...(props as any) });\n    //   return _getDisableValidationMakeOption(options)\n    //     ? propsWithDefaults\n    //     : ParseResult.validateSync(this)(propsWithDefaults);\n    // }\n\n    static instanceOf(value: unknown): boolean {\n      return Schema.is(this)(value);\n    }\n  };\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { Schema } from 'effect';\n\nimport { EchoObject } from './entity';\n\nexport const EXPANDO_TYPENAME = 'dxos.org/type/Expando';\n\nconst ExpandoSchema = Schema.Struct({}, { key: Schema.String, value: Schema.Any }).pipe(\n  EchoObject({ typename: EXPANDO_TYPENAME, version: '0.1.0' }),\n);\n\n/**\n * Expando object is an object with an arbitrary set of properties.\n */\n// TODO(dmaretskyi): Can we consider expando a top-type, i.e. have a ref to expando potentially be a valid ref to any object?\nexport interface Expando extends Schema.Schema.Type<typeof ExpandoSchema> {}\n\nexport const Expando: Schema.Schema<Expando> = ExpandoSchema;\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { DXN, ObjectId, QueueSubspaceTags, SpaceId } from '@dxos/keys';\n\n// TODO(burdon): Move to @dxos/keys once ObjectId is moved there.\n/**\n * @deprecated Use `db.queues.create()`\n */\nexport const createQueueDXN = (spaceId = SpaceId.random(), queueId = ObjectId.random()) =>\n  new DXN(DXN.kind.QUEUE, [QueueSubspaceTags.DATA, spaceId, queueId]);\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { Schema } from 'effect';\n\nimport { invariant } from '@dxos/invariant';\n\nimport { makeTypedEntityClass, type TypedObjectFields, type TypedObjectOptions } from './common';\nimport { type TypeAnnotation, EntityKind, TypeAnnotationId, type TypeMeta, Typename, Version } from '../ast';\nimport { type HasId } from '../types';\n\n/**\n * Definition for an object type that can be stored in an ECHO database.\n * Implements effect schema to define object properties.\n * Has a typename and version.\n *\n * In contrast to {@link EchoSchema} this definition is not recorded in the database.\n */\nexport interface TypedObject<A = any, I = any> extends TypeMeta, Schema.Schema<A, I> {}\n\n/**\n * Typed object that could be used as a prototype in class definitions.\n * This is an internal API type.\n * Use {@link TypedObject} for the common use-cases.\n */\nexport interface TypedObjectPrototype<A = any, I = any> extends TypedObject<A, I> {\n  /** Type constructor. */\n  new (): HasId & A;\n}\n\nexport type TypedObjectProps = TypeMeta & {\n  // TODO(dmaretskyi): Remove after all legacy types has been removed.\n  disableValidation?: boolean;\n};\n\n/**\n * Base class factory for typed objects.\n * @deprecated Use pipe(Type.Obj) instead.\n */\nexport const TypedObject = ({ typename: _typename, version: _version, disableValidation }: TypedObjectProps) => {\n  const typename = Typename.make(_typename, { disableValidation });\n  const version = Version.make(_version, { disableValidation });\n\n  /**\n   * Return class definition factory.\n   */\n  return <SchemaFields extends Schema.Struct.Fields, Options extends TypedObjectOptions>(\n    fields: SchemaFields,\n    options?: Options,\n  ): TypedObjectPrototype<TypedObjectFields<SchemaFields, Options>, Schema.Struct.Encoded<SchemaFields>> => {\n    // Create schema from fields.\n    const schema: Schema.Schema.All = options?.record\n      ? Schema.Struct(fields, { key: Schema.String, value: Schema.Any })\n      : Schema.Struct(fields);\n\n    // Set ECHO object id property.\n    const typeSchema = Schema.extend(\n      Schema.mutable(options?.partial ? Schema.partial(schema) : schema),\n      Schema.Struct({ id: Schema.String }),\n    );\n\n    // Set ECHO annotations.\n    invariant(typeof EntityKind.Object === 'string');\n    const annotatedSchema = typeSchema.annotations({\n      [TypeAnnotationId]: { kind: EntityKind.Object, typename, version } satisfies TypeAnnotation,\n    });\n\n    /**\n     * Return class definition.\n     * NOTE: Actual reactive ECHO objects must be created via the `live(Type)` function.\n     */\n    // TODO(burdon): This is missing fields required by TypedObject (e.g., Type, Encoded, Context)?\n    return class TypedObject extends makeTypedEntityClass(typename, version, annotatedSchema as any) {} as any;\n  };\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { Schema } from 'effect';\n\nimport { invariant } from '@dxos/invariant';\n\nimport { makeTypedEntityClass, type TypedObjectFields, type TypedObjectOptions } from './common';\nimport { type RelationSourceTargetRefs } from './relation';\nimport { EntityKind, TypeAnnotationId, Typename, Version, type TypeAnnotation, type TypeMeta } from '../ast';\nimport { type HasId } from '../types';\n\n/**\n * Definition for an object type that can be stored in an ECHO database.\n * Implements effect schema to define object properties.\n * Has a typename and version.\n *\n * In contrast to {@link EchoSchema} this definition is not recorded in the database.\n */\nexport interface TypedRelation<A = any, I = any> extends TypeMeta, Schema.Schema<A, I> {}\n\n/**\n * Typed object that could be used as a prototype in class definitions.\n * This is an internal API type.\n * Use {@link TypedRelation} for the common use-cases.\n */\nexport interface TypedRelationPrototype<A = any, I = any> extends TypedRelation<A, I> {\n  /** Type constructor. */\n  new (): HasId & A;\n}\n\nexport type TypedRelationProps = TypeMeta & {\n  // TODO(dmaretskyi): Remove after all legacy types has been removed.\n  disableValidation?: boolean;\n};\n\n/**\n * Base class factory for typed objects.\n * @deprecated Use {@link EchoRelation} instead.\n */\nexport const TypedRelation = ({ typename: _typename, version: _version, disableValidation }: TypedRelationProps) => {\n  const typename = Typename.make(_typename, { disableValidation });\n  const version = Version.make(_version, { disableValidation });\n\n  /**\n   * Return class definition factory.\n   */\n  return <SchemaFields extends Schema.Struct.Fields, Options extends TypedObjectOptions>(\n    fields: SchemaFields,\n    options?: Options,\n  ): TypedRelationPrototype<\n    TypedObjectFields<SchemaFields, Options> & RelationSourceTargetRefs,\n    Schema.Struct.Encoded<SchemaFields>\n  > => {\n    // Create schema from fields.\n    const schema: Schema.Schema.All = options?.record\n      ? Schema.Struct(fields, { key: Schema.String, value: Schema.Any })\n      : Schema.Struct(fields);\n\n    // Set ECHO object id property.\n    const typeSchema = Schema.extend(\n      Schema.mutable(options?.partial ? Schema.partial(schema) : schema),\n      Schema.Struct({ id: Schema.String }),\n    );\n\n    // Set ECHO annotations.\n    invariant(typeof EntityKind.Relation === 'string');\n    const annotatedSchema = typeSchema.annotations({\n      [TypeAnnotationId]: { kind: EntityKind.Relation, typename, version } satisfies TypeAnnotation,\n    });\n\n    /**\n     * Return class definition.\n     * NOTE: Actual reactive ECHO objects must be created via the `live(Type)` function.\n     */\n    // TODO(burdon): This is missing fields required by TypedRelation (e.g., Type, Encoded, Context)?\n    return class TypedRelation extends makeTypedEntityClass(typename, version, annotatedSchema as any) {} as any;\n  };\n};\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { DeletedId } from './model';\nimport type { BaseObject } from '../types';\n\n/**\n * @returns `true` if the object has been marked as deleted.\n */\nexport const isDeleted = (obj: BaseObject): boolean => {\n  if ((obj as any)[DeletedId] === undefined) {\n    throw new Error('Object does not support deletion marker');\n  }\n  return (obj as any)[DeletedId] ?? false;\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { SchemaAST, Schema } from 'effect';\n\nimport { invariant } from '@dxos/invariant';\n\nimport { SchemaId } from './model';\n\n// TODO(burdon): Reconcile with @dxos/effect visit().\n\nexport class SchemaValidator {\n  /**\n   * Recursively check that schema specifies constructions we can handle.\n   * Validates there are no ambiguous discriminated union types.\n   */\n  public static validateSchema(schema: Schema.Schema.AnyNoContext): void {\n    const visitAll = (nodes: SchemaAST.AST[]) => nodes.forEach((node) => this.validateSchema(Schema.make(node)));\n    if (SchemaAST.isUnion(schema.ast)) {\n      const typeAstList = schema.ast.types.filter((type) => SchemaAST.isTypeLiteral(type)) as SchemaAST.TypeLiteral[];\n      // Check we can handle a discriminated union.\n      if (typeAstList.length > 1) {\n        getTypeDiscriminators(typeAstList);\n      }\n      visitAll(typeAstList);\n    } else if (SchemaAST.isTupleType(schema.ast)) {\n      const positionalTypes = schema.ast.elements.map((t) => t.type);\n      const allTypes = positionalTypes.concat(schema.ast.rest.map((t) => t.type));\n      visitAll(allTypes);\n    } else if (SchemaAST.isTypeLiteral(schema.ast)) {\n      visitAll(SchemaAST.getPropertySignatures(schema.ast).map((p) => p.type));\n    }\n  }\n\n  public static hasTypeAnnotation(\n    rootObjectSchema: Schema.Schema.AnyNoContext,\n    property: string,\n    annotation: symbol,\n  ): boolean {\n    try {\n      let type = this.getPropertySchema(rootObjectSchema, [property]);\n      if (SchemaAST.isTupleType(type.ast)) {\n        type = this.getPropertySchema(rootObjectSchema, [property, '0']);\n      }\n\n      return type.ast.annotations[annotation] != null;\n    } catch (err) {\n      return false;\n    }\n  }\n\n  public static getPropertySchema(\n    rootObjectSchema: Schema.Schema.AnyNoContext,\n    propertyPath: KeyPath,\n    getProperty: (path: KeyPath) => any = () => null,\n  ): Schema.Schema.AnyNoContext {\n    let schema: Schema.Schema.AnyNoContext = rootObjectSchema;\n    for (let i = 0; i < propertyPath.length; i++) {\n      const propertyName = propertyPath[i];\n      const tupleAst = unwrapArray(schema.ast);\n      if (tupleAst != null) {\n        schema = getArrayElementSchema(tupleAst, propertyName);\n      } else {\n        const propertyType = getPropertyType(schema.ast, propertyName.toString(), (propertyName) =>\n          getProperty([...propertyPath.slice(0, i), propertyName]),\n        );\n        if (propertyType == null) {\n          throw new TypeError(`unknown property: ${String(propertyName)} on object. Path: ${propertyPath}`);\n        }\n\n        schema = Schema.make(propertyType).annotations(propertyType.annotations);\n      }\n    }\n\n    return schema;\n  }\n\n  public static getTargetPropertySchema(target: any, prop: string | symbol): Schema.Schema.AnyNoContext {\n    const schema: Schema.Schema.AnyNoContext | undefined = (target as any)[SchemaId];\n    invariant(schema, 'target has no schema');\n    const arrayAst = unwrapArray(schema.ast);\n    if (arrayAst != null) {\n      return getArrayElementSchema(arrayAst, prop);\n    }\n\n    const propertyType = getPropertyType(schema.ast, prop.toString(), (prop) => target[prop]);\n    if (propertyType == null) {\n      return Schema.Any; // TODO(burdon): HACK.\n    }\n\n    invariant(propertyType, `invalid property: ${prop.toString()}`);\n    return Schema.make(propertyType);\n  }\n}\n\n/**\n * Tuple AST is used both for:\n * fixed-length tuples ([string, number]) in which case AST will be { elements: [Schema.String, Schema.Number] }\n * variable-length arrays (Array<string | number>) in which case AST will be { rest: [Schema.Union(Schema.String, Schema.Number)] }\n */\nconst getArrayElementSchema = (\n  tupleAst: SchemaAST.TupleType,\n  property: string | symbol | number,\n): Schema.Schema.AnyNoContext => {\n  const elementIndex = typeof property === 'string' ? parseInt(property, 10) : Number.NaN;\n  if (Number.isNaN(elementIndex)) {\n    invariant(property === 'length', `invalid array property: ${String(property)}`);\n    return Schema.Number;\n  }\n  if (elementIndex < tupleAst.elements.length) {\n    const elementType = tupleAst.elements[elementIndex].type;\n    return Schema.make(elementType).annotations(elementType.annotations);\n  }\n\n  const restType = tupleAst.rest;\n  return Schema.make(restType[0].type).annotations(restType[0].annotations);\n};\n\nconst flattenUnion = (typeAst: SchemaAST.AST): SchemaAST.AST[] =>\n  SchemaAST.isUnion(typeAst) ? typeAst.types.flatMap(flattenUnion) : [typeAst];\n\nconst getProperties = (\n  typeAst: SchemaAST.AST,\n  getTargetPropertyFn: (propertyName: string) => any,\n): SchemaAST.PropertySignature[] => {\n  const astCandidates = flattenUnion(typeAst);\n  const typeAstList = astCandidates.filter((type) => SchemaAST.isTypeLiteral(type)) as SchemaAST.TypeLiteral[];\n  if (typeAstList.length === 0) {\n    return [];\n  }\n  if (typeAstList.length === 1) {\n    return SchemaAST.getPropertySignatures(typeAstList[0]);\n  }\n\n  const typeDiscriminators = getTypeDiscriminators(typeAstList);\n  const targetPropertyValue = getTargetPropertyFn(String(typeDiscriminators[0].name));\n  const typeIndex = typeDiscriminators.findIndex((p) => targetPropertyValue === (p.type as SchemaAST.Literal).literal);\n  invariant(typeIndex !== -1, 'discriminator field not set on target');\n  return SchemaAST.getPropertySignatures(typeAstList[typeIndex]);\n};\n\nconst getPropertyType = (\n  ast: SchemaAST.AST,\n  propertyName: string,\n  getTargetPropertyFn: (propertyName: string) => any,\n): SchemaAST.AST | null => {\n  const anyOrObject = unwrapAst(\n    ast,\n    (candidate) => SchemaAST.isAnyKeyword(candidate) || SchemaAST.isObjectKeyword(candidate),\n  );\n  if (anyOrObject != null) {\n    return ast;\n  }\n\n  const typeOrDiscriminatedUnion = unwrapAst(ast, (t) => {\n    return SchemaAST.isTypeLiteral(t) || (SchemaAST.isUnion(t) && t.types.some((t) => SchemaAST.isTypeLiteral(t)));\n  });\n  if (typeOrDiscriminatedUnion == null) {\n    return null;\n  }\n\n  const targetProperty = getProperties(typeOrDiscriminatedUnion, getTargetPropertyFn).find(\n    (p) => p.name === propertyName,\n  );\n  if (targetProperty != null) {\n    return unwrapAst(targetProperty.type);\n  }\n\n  const indexSignatureType = unwrapAst(ast, SchemaAST.isTypeLiteral);\n  if (\n    indexSignatureType &&\n    SchemaAST.isTypeLiteral(indexSignatureType) &&\n    indexSignatureType.indexSignatures.length > 0\n  ) {\n    return unwrapAst(indexSignatureType.indexSignatures[0].type);\n  }\n\n  return null;\n};\n\nconst getTypeDiscriminators = (typeAstList: SchemaAST.TypeLiteral[]): SchemaAST.PropertySignature[] => {\n  const discriminatorPropCandidates = typeAstList\n    .flatMap(SchemaAST.getPropertySignatures)\n    .filter((p) => SchemaAST.isLiteral(p.type));\n  const propertyName = discriminatorPropCandidates[0].name;\n  const isValidDiscriminator = discriminatorPropCandidates.every((p) => p.name === propertyName && !p.isOptional);\n  const everyTypeHasDiscriminator = discriminatorPropCandidates.length === typeAstList.length;\n  const isDiscriminatedUnion = isValidDiscriminator && everyTypeHasDiscriminator;\n  invariant(isDiscriminatedUnion, 'type ambiguity: every type in a union must have a single unique-literal field');\n  return discriminatorPropCandidates;\n};\n\n/**\n * Used to check that rootAst is for a type matching the provided predicate.\n * That's not always straightforward because types of optionality and recursive types.\n * const Task = Schema.Struct({\n *   ...,\n *   previous?: Schema.optional(Schema.suspend(() => Task)),\n * });\n * Here the AST for `previous` field is going to be Union(Suspend(Type), Undefined).\n * SchemaAST.isTypeLiteral(field) will return false, but unwrapAst(field, (ast) => SchemaAST.isTypeLiteral(ast))\n * will return true.\n */\nconst unwrapAst = (rootAst: SchemaAST.AST, predicate?: (ast: SchemaAST.AST) => boolean): SchemaAST.AST | null => {\n  let ast: SchemaAST.AST | undefined = rootAst;\n  while (ast != null) {\n    if (predicate?.(ast)) {\n      return ast;\n    }\n\n    if (SchemaAST.isUnion(ast)) {\n      const next: any = ast.types.find((t) => (predicate != null && predicate(t)) || SchemaAST.isSuspend(t));\n      if (next != null) {\n        ast = next;\n        continue;\n      }\n    }\n\n    if (SchemaAST.isSuspend(ast)) {\n      ast = ast.f();\n    } else {\n      return predicate == null ? ast : null;\n    }\n  }\n\n  return null;\n};\n\nconst unwrapArray = (ast: SchemaAST.AST) => unwrapAst(ast, SchemaAST.isTupleType) as SchemaAST.TupleType | null;\n\nexport const checkIdNotPresentOnSchema = (schema: Schema.Schema<any, any, any>) => {\n  invariant(SchemaAST.isTypeLiteral(schema.ast));\n  const idProperty = SchemaAST.getPropertySignatures(schema.ast).find((prop) => prop.name === 'id');\n  if (idProperty != null) {\n    throw new Error('\"id\" property name is reserved');\n  }\n};\n\ntype KeyPath = readonly (string | number)[];\n"],
  "mappings": "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",
  "names": ["SchemaAST", "createAnnotationHelper", "id", "get", "schema", "SchemaAST", "getAnnotation", "set", "value", "annotations", "Schema", "EntityKind", "EntityKindSchema", "Schema", "Enums", "flow", "Option", "pipe", "Schema", "SchemaAST", "assertArgument", "DXN", "TypeIdentifierAnnotationId", "Symbol", "for", "getTypeIdentifierAnnotation", "schema", "flow", "SchemaAST", "getAnnotation", "Option", "getOrElse", "undefined", "ast", "TypeAnnotationId", "Typename", "Schema", "String", "pipe", "pattern", "Version", "TypeAnnotation", "Struct", "kind", "Enums", "EntityKind", "typename", "version", "sourceSchema", "optional", "DXN", "targetSchema", "getTypeAnnotation", "assertArgument", "getEntityKind", "getSchemaTypename", "getSchemaVersion", "PropertyMetaAnnotationId", "PropertyMeta", "name", "value", "self", "existingMeta", "annotations", "getPropertyMetaAnnotation", "prop", "type", "map", "meta", "ReferenceAnnotationId", "getReferenceAnnotation", "SchemaMetaSymbol", "LabelAnnotationId", "LabelAnnotation", "createAnnotationHelper", "FieldLookupAnnotationId", "GeneratorAnnotationId", "GeneratorAnnotation", "getSchemaDXN", "isSchema", "id", "parse", "objectAnnotation", "fromTypenameAndVersion", "FIELD_PATH_ANNOTATION", "FieldPath", "path", "PropertyMeta", "invariant", "DXN", "ObjectId", "assumeType", "EntityKindId", "Symbol", "SelfDXNId", "ATTR_SELF_DXN", "TypeId", "ATTR_TYPE", "SchemaId", "DeletedId", "ATTR_DELETED", "MetaId", "ATTR_META", "RelationSourceDXNId", "ATTR_RELATION_SOURCE", "RelationTargetDXNId", "ATTR_RELATION_TARGET", "RelationSourceId", "RelationTargetId", "assertObjectModelShape", "obj", "invariant", "assumeType", "ObjectId", "isValid", "id", "undefined", "DXN", "EntityKind", "Object", "Relation", "Schema", "getField", "assertArgument", "invariant", "DXN", "ObjectId", "assumeType", "getObjectDXN", "object", "invariant", "Schema", "isSchema", "assertArgument", "assumeType", "ObjectId", "isValid", "id", "TypeError", "DXN", "fromLocalObjectId", "getSchema", "obj", "SchemaId", "setSchema", "schema", "Object", "defineProperty", "value", "writable", "enumerable", "configurable", "getLabelForObject", "getLabel", "annotation", "ast", "annotations", "LabelAnnotationId", "undefined", "Array", "isArray", "accessor", "getField", "toString", "invariant", "DXN", "getTypename", "obj", "schema", "getSchema", "getSchemaTypename", "type", "getType", "asTypeDXN", "setTypename", "typename", "invariant", "DXN", "Object", "defineProperty", "TypeId", "value", "writable", "enumerable", "configurable", "undefined", "Schema", "makeTypedEntityClass", "typename", "version", "baseSchema", "_a", "Schema", "schemaVariance", "ast", "annotations", "bind", "pipe", "TypeId", "Symbol", "hasInstance", "obj", "getTypename", "Error", "_A", "_", "_I", "_R", "Schema", "ForeignKey", "invariant", "intersection", "ObjectMetaSchema", "Schema", "Struct", "keys", "mutable", "Array", "ForeignKey", "foreignKey", "source", "id", "foreignKeyEquals", "a", "b", "getObjectMeta", "object", "getMeta", "obj", "metadata", "MetaId", "invariant", "compareForeignKeys", "intersection", "length", "Effect", "Option", "ParseResult", "Schema", "SchemaAST", "Reference", "compositeRuntime", "assertArgument", "invariant", "DXN", "ObjectId", "JSON_SCHEMA_ECHO_REF_ID", "getSchemaReference", "property", "$id", "reference", "schema", "$ref", "typename", "DXN", "parse", "createSchemaReference", "fromTypename", "toString", "RefTypeId", "Symbol", "Ref", "assertArgument", "Schema", "isSchema", "annotation", "getTypeAnnotation", "Error", "createEchoReferenceSchema", "getTypeIdentifierAnnotation", "version", "getSchemaExpectedName", "ast", "isRef", "obj", "hasObjectId", "id", "ref", "dxn", "isLocalObjectId", "parts", "isRefSchema", "isRefSchemaAST", "SchemaAST", "getAnnotation", "ReferenceAnnotationId", "pipe", "Option", "isSome", "make", "TypeError", "invariant", "ObjectId", "isValid", "Reference", "localObjectReference", "toDXN", "RefImpl", "fromDXN", "echoId", "schemaName", "referenceInfo", "schemaVersion", "refSchema", "declare", "encode", "value", "Effect", "succeed", "decode", "fail", "ParseResult", "Unexpected", "jsonSchema", "getIdentifierAnnotation", "orElse", "getTitleAnnotation", "getDescriptionAnnotation", "getOrElse", "undefined", "target", "compositeRuntime", "createSignal", "notifyWrite", "refVariance", "notifyRead", "resolveSync", "load", "resolve", "tryLoad", "noInline", "toJSON", "_setResolver", "resolver", "_getSavedTarget", "setRefResolver", "getRefSavedTarget", "_T", "refFromEncodedReference", "encodedReference", "StaticRefResolver", "objects", "Map", "schemas", "addObject", "set", "addSchema", "getSchemaDXN", "_load", "_onLoad", "asEchoDXN", "get", "resolveSchema", "isNonNullable", "RefArray", "Object", "freeze", "targets", "refs", "map", "ref", "target", "filter", "isNonNullable", "loadAll", "Promise", "all", "load", "removeById", "id", "index", "findIndex", "Ref", "hasObjectId", "splice", "defineHiddenProperty", "object", "key", "value", "Object", "defineProperty", "enumerable", "configurable", "Schema", "raise", "isEncodedReference", "assertArgument", "invariant", "DXN", "ObjectId", "assumeType", "deepMapValues", "visitValues", "objectToJSON", "obj", "typename", "getType", "toString", "invariant", "typedJsonSerializer", "call", "objectFromJSON", "jsonData", "refResolver", "assumeType", "assertArgument", "ATTR_TYPE", "id", "type", "DXN", "parse", "schema", "resolveSchema", "undefined", "Schema", "isSchema", "pipe", "decodeUnknownPromise", "setRefResolverOnData", "decodeGeneric", "ObjectId", "isValid", "setTypename", "setSchema", "isRelation", "ATTR_RELATION_SOURCE", "ATTR_RELATION_TARGET", "sourceDxn", "raise", "TypeError", "targetDxn", "source", "resolve", "target", "defineHiddenProperty", "EntityKindId", "EntityKind", "Relation", "RelationSourceDXNId", "RelationTargetDXNId", "RelationSourceId", "RelationTargetId", "Object", "ATTR_META", "meta", "ObjectMetaSchema", "Array", "isArray", "keys", "MetaId", "assertObjectModelShape", "ATTR_SELF_DXN", "ATTR_DELETED", "options", "_type", "_meta", "_deleted", "_relationSource", "_relationTarget", "_selfDxn", "props", "deepMapValues", "value", "recurse", "isEncodedReference", "refFromEncodedReference", "go", "Ref", "isRef", "setRefResolver", "visitValues", "attachTypedJsonSerializer", "descriptor", "getOwnPropertyDescriptor", "defineProperty", "writable", "enumerable", "configurable", "TypeId", "rest", "result", "sourceDXN", "targetDXN", "serializeData", "assign", "data", "noInline", "encode", "raise", "assertArgument", "failedInvariant", "ObjectId", "inspectCustom", "attachedTypedObjectInspector", "obj", "descriptor", "Object", "getOwnPropertyDescriptor", "inspectCustom", "defineProperty", "value", "typedObjectInspectFunction", "writable", "enumerable", "configurable", "depth", "options", "inspect", "id", "props", "ATTR_TYPE", "getType", "ATTR_META", "MetaId", "create", "schema", "data", "annotation", "getTypeAnnotation", "Error", "assertArgument", "RelationSourceDXNId", "RelationTargetDXNId", "RelationSourceId", "RelationTargetId", "obj", "id", "ObjectId", "random", "kind", "EntityKind", "Relation", "Object", "defineHiddenProperty", "EntityKindId", "setTypename", "getSchemaDXN", "failedInvariant", "setSchema", "attachTypedJsonSerializer", "attachedTypedObjectInspector", "MetaId", "keys", "sourceDXN", "getObjectDXN", "raise", "targetDXN", "assertObjectModelShape", "Schema", "SchemaAST", "raise", "invariant", "DXN", "EchoObject", "typename", "version", "self", "invariant", "TypeAnnotationId", "SchemaAST", "isTypeLiteral", "ast", "schemaWithId", "Schema", "extend", "mutable", "Struct", "id", "String", "annotations", "kind", "EntityKind", "Object", "makeEchoObjectSchema", "getDXNForRelationSchemaRef", "schema", "identifier", "getTypeIdentifierAnnotation", "getSchemaTypename", "Error", "DXN", "fromTypename", "toString", "EchoRelation", "options", "sourceDXN", "source", "targetDXN", "target", "getEntityKind", "raise", "Relation", "sourceSchema", "targetSchema", "EchoObjectSchemaClass", "make", "instanceOf", "value", "is", "Schema", "EXPANDO_TYPENAME", "ExpandoSchema", "Schema", "Struct", "key", "String", "value", "Any", "pipe", "EchoObject", "typename", "version", "Expando", "DXN", "ObjectId", "QueueSubspaceTags", "SpaceId", "createQueueDXN", "spaceId", "SpaceId", "random", "queueId", "ObjectId", "DXN", "kind", "QUEUE", "QueueSubspaceTags", "DATA", "Schema", "invariant", "TypedObject", "typename", "_typename", "version", "_version", "disableValidation", "Typename", "make", "Version", "fields", "options", "schema", "record", "Schema", "Struct", "key", "String", "value", "Any", "typeSchema", "extend", "mutable", "partial", "id", "invariant", "EntityKind", "Object", "annotatedSchema", "annotations", "TypeAnnotationId", "kind", "makeTypedEntityClass", "Schema", "invariant", "TypedRelation", "typename", "_typename", "version", "_version", "disableValidation", "Typename", "make", "Version", "fields", "options", "schema", "record", "Schema", "Struct", "key", "String", "value", "Any", "typeSchema", "extend", "mutable", "partial", "id", "invariant", "EntityKind", "Relation", "annotatedSchema", "annotations", "TypeAnnotationId", "kind", "makeTypedEntityClass", "isDeleted", "obj", "DeletedId", "undefined", "Error", "SchemaAST", "Schema", "invariant", "SchemaValidator", "validateSchema", "schema", "visitAll", "nodes", "forEach", "node", "Schema", "make", "SchemaAST", "isUnion", "ast", "typeAstList", "types", "filter", "type", "isTypeLiteral", "length", "getTypeDiscriminators", "isTupleType", "positionalTypes", "elements", "map", "t", "allTypes", "concat", "rest", "getPropertySignatures", "p", "hasTypeAnnotation", "rootObjectSchema", "property", "annotation", "getPropertySchema", "annotations", "err", "propertyPath", "getProperty", "i", "propertyName", "tupleAst", "unwrapArray", "getArrayElementSchema", "propertyType", "getPropertyType", "toString", "slice", "TypeError", "String", "getTargetPropertySchema", "target", "prop", "SchemaId", "invariant", "arrayAst", "Any", "elementIndex", "parseInt", "Number", "NaN", "isNaN", "elementType", "restType", "flattenUnion", "typeAst", "flatMap", "getProperties", "getTargetPropertyFn", "astCandidates", "typeDiscriminators", "targetPropertyValue", "name", "typeIndex", "findIndex", "literal", "anyOrObject", "unwrapAst", "candidate", "isAnyKeyword", "isObjectKeyword", "typeOrDiscriminatedUnion", "some", "targetProperty", "find", "indexSignatureType", "indexSignatures", "discriminatorPropCandidates", "isLiteral", "isValidDiscriminator", "every", "isOptional", "everyTypeHasDiscriminator", "isDiscriminatedUnion", "rootAst", "predicate", "next", "isSuspend", "f", "checkIdNotPresentOnSchema", "idProperty", "Error"]
}
