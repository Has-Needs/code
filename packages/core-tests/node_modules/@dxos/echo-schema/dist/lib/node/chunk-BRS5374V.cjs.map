{
  "version": 3,
  "sources": ["../../../src/ast/annotation-helper.ts", "../../../src/ast/entity-kind.ts", "../../../src/ast/annotations.ts", "../../../src/ast/types.ts", "../../../src/object/model.ts", "../../../src/object/accessors.ts", "../../../src/object/typename.ts", "../../../src/object/common.ts", "../../../src/object/meta.ts", "../../../src/ref/ref.ts", "../../../src/ref/ref-array.ts", "../../../src/utils.ts", "../../../src/object/json-serializer.ts", "../../../src/object/create.ts", "../../../src/object/inspect.ts", "../../../src/object/entity.ts", "../../../src/object/expando.ts", "../../../src/object/ids.ts", "../../../src/object/typed-object.ts", "../../../src/object/typed-relation.ts", "../../../src/object/deleted.ts", "../../../src/object/schema-validator.ts"],
  "sourcesContent": ["//\n// Copyright 2025 DXOS.org\n//\n\nimport { type Schema, SchemaAST, type Option } from 'effect';\n\nexport interface AnnotationHelper<T> {\n  get: (schema: Schema.Schema.Any) => Option.Option<T>;\n  set: (value: T) => <S extends Schema.Schema.Any>(schema: S) => S;\n}\n\nexport const createAnnotationHelper = <T>(id: symbol): AnnotationHelper<T> => {\n  return {\n    get: (schema) => SchemaAST.getAnnotation(schema as any, id),\n    set:\n      (value) =>\n      <S extends Schema.Schema.Any>(schema: S) =>\n        schema.annotations({ [id]: value }) as S,\n  };\n};\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { Schema } from 'effect';\n\n/**\n * Kinds of entities stored in ECHO: objects and relations.\n */\nexport enum EntityKind {\n  Object = 'object',\n  Relation = 'relation',\n}\n\nexport const EntityKindSchema = Schema.Enums(EntityKind);\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { flow, Option, pipe, Schema, SchemaAST } from 'effect';\n\nimport { assertArgument } from '@dxos/invariant';\nimport { DXN } from '@dxos/keys';\nimport { type Primitive } from '@dxos/util';\n\nimport { createAnnotationHelper } from './annotation-helper';\nimport { EntityKind } from './entity-kind';\n\n/**\n * ECHO identifier (for a stored schema).\n * Must be a `dxn:echo:` URI.\n */\nexport const TypeIdentifierAnnotationId = Symbol.for('@dxos/schema/annotation/TypeIdentifier');\n\nexport const getTypeIdentifierAnnotation = (schema: Schema.Schema.All) =>\n  flow(\n    SchemaAST.getAnnotation<string>(TypeIdentifierAnnotationId),\n    Option.getOrElse(() => undefined),\n  )(schema.ast);\n\n/**\n * ECHO type.\n */\nexport const TypeAnnotationId = Symbol.for('@dxos/schema/annotation/Type');\n\nexport const Typename = Schema.String.pipe(Schema.pattern(/^[a-zA-Z]\\w+\\.[a-zA-Z]\\w{1,}\\/[\\w/_-]+$/));\nexport const Version = Schema.String.pipe(Schema.pattern(/^\\d+.\\d+.\\d+$/));\n\n/**\n * Payload stored under {@link TypeAnnotationId}.\n */\n// TODO(dmaretskyi): Rename getTypeAnnotation to represent commonality between objects and relations (e.g. `entity`).\nexport const TypeAnnotation = Schema.Struct({\n  kind: Schema.Enums(EntityKind),\n  typename: Typename,\n  version: Version,\n\n  /**\n   * If this is a relation, the schema of the source object.\n   * Must be present if entity kind is {@link EntityKind.Relation}.\n   */\n  sourceSchema: Schema.optional(DXN.Schema),\n\n  /**\n   * If this is a relation, the schema of the target object.\n   * Must be present if entity kind is {@link EntityKind.Relation}.\n   */\n  targetSchema: Schema.optional(DXN.Schema),\n});\n\nexport interface TypeAnnotation extends Schema.Schema.Type<typeof TypeAnnotation> {}\n\nexport type TypeMeta = Pick<TypeAnnotation, 'typename' | 'version'>;\n\n/**\n * @returns {@link TypeAnnotation} from a schema.\n * Schema must have been created with {@link TypedObject} or {@link TypedLink} or manually assigned an appropriate annotation.\n */\nexport const getTypeAnnotation = (schema: Schema.Schema.All): TypeAnnotation | undefined => {\n  assertArgument(schema != null && schema.ast != null, 'invalid schema');\n  return flow(\n    SchemaAST.getAnnotation<TypeAnnotation>(TypeAnnotationId),\n    Option.getOrElse(() => undefined),\n  )(schema.ast);\n};\n\n/**\n * @returns {@link EntityKind} from a schema.\n */\nexport const getEntityKind = (schema: Schema.Schema.All): EntityKind | undefined => getTypeAnnotation(schema)?.kind;\n\n/**\n * @deprecated Use {@link Type.getTypename} instead.\n * @returns Schema typename (without dxn: prefix or version number).\n */\nexport const getSchemaTypename = (schema: Schema.Schema.All): string | undefined => getTypeAnnotation(schema)?.typename;\n\n/**\n * @deprecated Use {@link Type.getVersion} instead.\n * @returns Schema version in semver format.\n */\nexport const getSchemaVersion = (schema: Schema.Schema.All): string | undefined => getTypeAnnotation(schema)?.version;\n\n/**\n * PropertyMeta (metadata for dynamic schema properties).\n * For user-defined annotations.\n */\nexport const PropertyMetaAnnotationId = Symbol.for('@dxos/schema/annotation/PropertyMeta');\n\nexport type PropertyMetaValue = Primitive | Record<string, Primitive> | Primitive[];\n\nexport type PropertyMetaAnnotation = {\n  [name: string]: PropertyMetaValue;\n};\n\nexport const PropertyMeta = (name: string, value: PropertyMetaValue) => {\n  return <A, I, R>(self: Schema.Schema<A, I, R>): Schema.Schema<A, I, R> => {\n    const existingMeta = self.ast.annotations[PropertyMetaAnnotationId] as PropertyMetaAnnotation;\n    return self.annotations({\n      [PropertyMetaAnnotationId]: {\n        ...existingMeta,\n        [name]: value,\n      },\n    });\n  };\n};\n\nexport const getPropertyMetaAnnotation = <T>(prop: SchemaAST.PropertySignature, name: string) =>\n  pipe(\n    SchemaAST.getAnnotation<PropertyMetaAnnotation>(PropertyMetaAnnotationId)(prop.type),\n    Option.map((meta) => meta[name] as T),\n    Option.getOrElse(() => undefined),\n  );\n\n/**\n * Schema reference.\n */\nexport const ReferenceAnnotationId = Symbol.for('@dxos/schema/annotation/Reference');\n\nexport type ReferenceAnnotationValue = TypeAnnotation;\n\nexport const getReferenceAnnotation = (schema: Schema.Schema.AnyNoContext) =>\n  pipe(\n    SchemaAST.getAnnotation<ReferenceAnnotationValue>(ReferenceAnnotationId)(schema.ast),\n    Option.getOrElse(() => undefined),\n  );\n\n/**\n * SchemaMeta.\n */\nexport const SchemaMetaSymbol = Symbol.for('@dxos/schema/SchemaMeta');\n\nexport type SchemaMeta = TypeMeta & { id: string };\n\n/**\n * Identifies label property or JSON path expression.\n * Either a string or an array of strings representing field accessors each matched in priority order.\n */\nexport const LabelAnnotationId = Symbol.for('@dxos/schema/annotation/Label');\n\nexport const LabelAnnotation = createAnnotationHelper<string[]>(LabelAnnotationId);\n\n/**\n * Default field to be used on referenced schema to lookup the value.\n */\nexport const FieldLookupAnnotationId = Symbol.for('@dxos/schema/annotation/FieldLookup');\n\n/**\n * Generate test data.\n */\nexport const GeneratorAnnotationId = Symbol.for('@dxos/schema/annotation/Generator');\n\n/** [path, probability] */\nexport type GeneratorAnnotationValue = string | [string, number];\n\nexport const GeneratorAnnotation = createAnnotationHelper<GeneratorAnnotationValue>(GeneratorAnnotationId);\n\n/**\n * @returns DXN of the schema.\n *\n * For non-stored schema returns `dxn:type:`.\n * For stored schema returns `dxn:echo:`.\n * @deprecated Use `Type.getDXN`.\n */\nexport const getSchemaDXN = (schema: Schema.Schema.All): DXN | undefined => {\n  assertArgument(Schema.isSchema(schema), 'invalid schema');\n\n  const id = getTypeIdentifierAnnotation(schema);\n  if (id) {\n    return DXN.parse(id);\n  }\n\n  // TODO(dmaretskyi): Add support for dynamic schema.\n  const objectAnnotation = getTypeAnnotation(schema);\n  if (!objectAnnotation) {\n    return undefined;\n  }\n\n  return DXN.fromTypenameAndVersion(objectAnnotation.typename, objectAnnotation.version);\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { PropertyMeta } from './annotations';\n\n/**\n * @internal\n */\nexport const FIELD_PATH_ANNOTATION = 'path';\n\n/**\n * Sets the path for the field.\n * @param path Data source path in the json path format. This is the field path in the source object.\n */\n// TODO(burdon): Field, vs. path vs. property.\nexport const FieldPath = (path: string) => PropertyMeta(FIELD_PATH_ANNOTATION, path);\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { type Schema } from 'effect';\n\nimport { type ForeignKey } from '@dxos/echo-protocol';\nimport { invariant } from '@dxos/invariant';\nimport { DXN, ObjectId } from '@dxos/keys';\nimport { assumeType } from '@dxos/util';\n\nimport { type ObjectMeta } from './meta';\nimport { EntityKind } from '../ast';\n\n//\n// Defines the internal model of the echo object.\n//\n\n/**\n * Entity kind.\n */\nexport const EntityKindId = Symbol('@dxos/echo/EntityKind');\n\n/**\n * DXN to the object itself.\n */\nexport const SelfDXNId = Symbol('@dxos/echo/Self');\n\n/**\n * Property name for self DXN when object is serialized to JSON.\n */\nexport const ATTR_SELF_DXN = '@self';\n\n/**\n * DXN to the object type.\n */\nexport const TypeId = Symbol('@dxos/echo/Type');\n\n/**\n * Property name for typename when object is serialized to JSON.\n */\nexport const ATTR_TYPE = '@type';\n\n/**\n * Reference to the object schema.\n */\nexport const SchemaId = Symbol('@dxos/echo/Schema');\n\n/**\n * Deletion marker.\n */\nexport const DeletedId = Symbol('@dxos/echo/Deleted');\n\n/**\n * Property name for deleted when object is serialized to JSON.\n */\nexport const ATTR_DELETED = '@deleted';\n\n/**\n * Metadata section.\n */\nexport const MetaId = Symbol('@dxos/echo/Meta');\n\n/**\n * Property name for meta when object is serialized to JSON.\n */\nexport const ATTR_META = '@meta';\n\n/**\n * Used to access relation source ref on live ECHO objects.\n * Reading this symbol must return `Live<EchoObject<any>>` or a DXN.\n */\nexport const RelationSourceDXNId: unique symbol = Symbol('@dxos/echo/RelationSourceDXN');\n\n/**\n * Property name for relation source when object is serialized to JSON.\n */\nexport const ATTR_RELATION_SOURCE = '@relationSource';\n\n/**\n * Used to access relation target ref on live ECHO objects.\n * Reading this symbol must return `Live<EchoObject<any>>` or a DXN.\n */\nexport const RelationTargetDXNId: unique symbol = Symbol('@dxos/echo/RelationTargetDXN');\n\n/**\n * Property name for relation target when object is serialized to JSON.\n */\nexport const ATTR_RELATION_TARGET = '@relationTarget';\n\n/**\n * Used to access relation source ref on live ECHO objects.\n * Reading this symbol must return `Live<EchoObject<any>>` or a DXN.\n */\nexport const RelationSourceId: unique symbol = Symbol('@dxos/echo/RelationSource');\n\n/**\n * Used to access relation target ref on live ECHO objects.\n * Reading this symbol must return `Live<EchoObject<any>>` or a DXN.\n */\nexport const RelationTargetId: unique symbol = Symbol('@dxos/echo/RelationTarget');\n\n/**\n * Internal runtime representation of an object.\n * The fields are accessed through getter functions.\n */\nexport interface InternalObjectProps {\n  id: ObjectId;\n  readonly [SelfDXNId]?: DXN;\n\n  // Echo supports untyped objects O_O.\n  readonly [TypeId]?: DXN;\n\n  /**\n   * Returns the schema for the object.\n   */\n  readonly [SchemaId]?: Schema.Schema.AnyNoContext;\n  readonly [EntityKindId]: EntityKind;\n  readonly [DeletedId]?: boolean;\n  readonly [MetaId]?: ObjectMeta;\n  readonly [RelationSourceDXNId]?: DXN;\n  readonly [RelationTargetDXNId]?: DXN;\n  readonly [RelationSourceId]?: InternalObjectProps;\n  readonly [RelationTargetId]?: InternalObjectProps;\n}\n\n/**\n * JSON representation of an object or relation.\n */\nexport interface ObjectJSON {\n  id: string;\n  [ATTR_SELF_DXN]?: DXN.String;\n  [ATTR_TYPE]: DXN.String;\n  [ATTR_DELETED]?: boolean;\n  [ATTR_META]?: ObjectMetaJSON;\n  [ATTR_RELATION_SOURCE]?: DXN.String;\n  [ATTR_RELATION_TARGET]?: DXN.String;\n}\n\nexport interface ObjectMetaJSON {\n  keys: ForeignKey[];\n}\n\n// NOTE: Keep as `function` to avoid type inference issues.\n// eslint-disable-next-line @stayradiated/prefer-arrow-functions/prefer-arrow-functions\nexport function assertObjectModelShape(obj: unknown): asserts obj is InternalObjectProps {\n  invariant(typeof obj === 'object' && obj !== null, 'Invalid object model: not an object');\n  assumeType<InternalObjectProps>(obj);\n  invariant(ObjectId.isValid(obj.id), 'Invalid object model: invalid id');\n  invariant(obj[TypeId] === undefined || obj[TypeId] instanceof DXN, 'Invalid object model: invalid type');\n  invariant(\n    obj[EntityKindId] === EntityKind.Object || obj[EntityKindId] === EntityKind.Relation,\n    'Invalid object model: invalid entity kind',\n  );\n  if (obj[EntityKindId] === EntityKind.Relation) {\n    invariant(obj[RelationSourceDXNId] instanceof DXN, 'Invalid object model: invalid relation source');\n    invariant(obj[RelationTargetDXNId] instanceof DXN, 'Invalid object model: invalid relation target');\n    invariant(!(obj[RelationSourceId] instanceof DXN), 'Invalid object model: source pointer is a DXN');\n    invariant(!(obj[RelationTargetId] instanceof DXN), 'Invalid object model: target pointer is a DXN');\n  }\n}\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { Schema } from 'effect';\n\nimport { getField, type JsonPath } from '@dxos/effect';\nimport { assertArgument, invariant } from '@dxos/invariant';\nimport { DXN, ObjectId } from '@dxos/keys';\nimport { assumeType } from '@dxos/util';\n\nimport { type InternalObjectProps, SchemaId } from './model';\nimport { LabelAnnotationId } from '../ast';\n\n//\n// Accessors based on model.\n//\n\n/**\n * Returns a DXN for an object or schema.\n * @deprecated Use `Obj.getDXN`.\n */\nexport const getObjectDXN = (object: any): DXN | undefined => {\n  invariant(!Schema.isSchema(object), 'schema not allowed in this function');\n  assertArgument(typeof object === 'object' && object != null, 'expected object');\n  assumeType<InternalObjectProps>(object);\n\n  // TODO(dmaretskyi): Use SelfDXNId.\n\n  if (!ObjectId.isValid(object.id)) {\n    throw new TypeError('Object id is not valid.');\n  }\n\n  return DXN.fromLocalObjectId(object.id);\n};\n\n/**\n * Returns the schema for the given object if one is defined.\n */\n// TODO(burdon): Reconcile with `getTypename`.\n// TODO(dmaretskyi): For echo objects, this always returns the root schema.\nexport const getSchema = (obj: unknown | undefined): Schema.Schema.AnyNoContext | undefined => {\n  if (obj) {\n    return (obj as any)[SchemaId];\n  }\n};\n\n/**\n * Internal use only.\n */\nexport const setSchema = (obj: any, schema: Schema.Schema.AnyNoContext) => {\n  Object.defineProperty(obj, SchemaId, {\n    value: schema,\n    writable: false,\n    enumerable: false,\n    configurable: false,\n  });\n};\n\n/**\n * @deprecated Use {@link Obj.getLabel} instead.\n * Returns the label for a given object based on {@link LabelAnnotationId}.\n */\nexport const getLabelForObject = (obj: unknown | undefined): string | undefined => {\n  const schema = getSchema(obj);\n  if (schema) {\n    return getLabel(schema, obj);\n  }\n};\n\n/**\n * Returns the label for a given object based on {@link LabelAnnotationId}.\n */\n// TODO(burdon): Convert to JsonPath?\nexport const getLabel = <S extends Schema.Schema.Any>(schema: S, object: Schema.Schema.Type<S>): string | undefined => {\n  let annotation = schema.ast.annotations[LabelAnnotationId];\n  if (!annotation) {\n    return undefined;\n  }\n  if (!Array.isArray(annotation)) {\n    annotation = [annotation];\n  }\n\n  for (const accessor of annotation as string[]) {\n    assertArgument(typeof accessor === 'string', 'Label annotation must be a string or an array of strings');\n    const value = getField(object, accessor as JsonPath);\n    switch (typeof value) {\n      case 'string':\n      case 'number':\n      case 'boolean':\n      case 'bigint':\n      case 'symbol':\n        return value.toString();\n      case 'undefined':\n      case 'object':\n      case 'function':\n        continue;\n    }\n  }\n\n  return undefined;\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { invariant } from '@dxos/invariant';\nimport { DXN } from '@dxos/keys';\n\nimport { getSchema } from './accessors';\nimport { TypeId } from './model';\nimport { getSchemaTypename } from '../ast';\nimport { type BaseObject } from '../types';\n\n/**\n * Gets the typename of the object without the version.\n * Returns only the name portion, not the DXN.\n * @example \"example.org/type/Contact\"\n */\nexport const getTypename = (obj: BaseObject): string | undefined => {\n  const schema = getSchema(obj);\n  if (schema != null) {\n    // Try to extract typename from DXN.\n    return getSchemaTypename(schema);\n  } else {\n    const type = getType(obj);\n    return type?.asTypeDXN()?.type;\n  }\n};\n\n/**\n * @internal\n */\n// TODO(dmaretskyi): Rename setTypeDXN.\nexport const setTypename = (obj: any, typename: DXN) => {\n  invariant(typename instanceof DXN, 'Invalid type.');\n  Object.defineProperty(obj, TypeId, {\n    value: typename,\n    writable: false,\n    enumerable: false,\n    configurable: false,\n  });\n};\n\n/**\n * @returns Object type as {@link DXN}.\n * @returns undefined if the object doesn't have a type.\n * @example `dxn:example.com/type/Contact:1.0.0`\n */\nexport const getType = (obj: BaseObject): DXN | undefined => {\n  if (!obj) {\n    return undefined;\n  }\n\n  const type = (obj as any)[TypeId];\n  if (!type) {\n    return undefined;\n  }\n\n  invariant(type instanceof DXN, 'Invalid object.');\n  return type;\n};\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { Schema } from 'effect';\n\nimport { getTypename } from './typename';\nimport { type BaseObject } from '../types';\n\n// TODO(dmaretskyi): Rename to represent commonality between objects and relations (e.g. `entity`).\nexport type TypedObjectOptions = {\n  // TODO(burdon): Document.\n  partial?: true;\n  // TODO(burdon): Document.\n  record?: true;\n};\n\n/**\n *\n */\n// TODO(burdon): Comment required.\n// TODO(dmaretskyi): Rename to represent commonality between objects and relations (e.g. `entity`).\ntype SimplifiedSchemaFields<\n  SchemaFields extends Schema.Struct.Fields,\n  Options extends TypedObjectOptions,\n> = Options['partial'] extends boolean\n  ? Schema.SimplifyMutable<Partial<Schema.Struct.Type<SchemaFields>>>\n  : Schema.SimplifyMutable<Schema.Struct.Type<SchemaFields>>;\n\n/**\n *\n */\n// TODO(burdon): Comment required.\n// TODO(dmaretskyi): Rename to represent commonality between objects and relations (e.g. `entity`).\nexport type TypedObjectFields<\n  SchemaFields extends Schema.Struct.Fields,\n  Options extends TypedObjectOptions,\n> = SimplifiedSchemaFields<SchemaFields, Options> & { id: string } & (Options['record'] extends boolean\n    ? Schema.SimplifyMutable<Schema.IndexSignature.Type<Schema.IndexSignature.Records>>\n    : {});\n\nexport const makeTypedEntityClass = (\n  typename: string,\n  version: string,\n  baseSchema: Schema.Schema.AnyNoContext,\n): Schema.SchemaClass<any> => {\n  return class {\n    // Implement TypedObject properties.\n    static readonly typename = typename;\n    static readonly version = version;\n\n    // Implement Schema.Schema properties.\n    // TODO(burdon): Comment required.\n    static readonly [Schema.TypeId] = schemaVariance;\n    static readonly ast = baseSchema.ast;\n    static readonly annotations = baseSchema.annotations.bind(baseSchema);\n    static readonly pipe = baseSchema.pipe.bind(baseSchema);\n\n    // TODO(burdon): Comment required.\n    static [Symbol.hasInstance](obj: BaseObject) {\n      return obj != null && getTypename(obj) === typename;\n    }\n\n    // TODO(burdon): Throw APIError.\n    private constructor() {\n      throw new Error('Use live(Typename, { ...fields }) to instantiate an object.');\n    }\n  } as any;\n};\n\nconst schemaVariance = {\n  _A: (_: any) => _,\n  _I: (_: any) => _,\n  _R: (_: never) => _,\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { Schema } from 'effect';\n\nimport { ForeignKey } from '@dxos/echo-protocol';\nimport { invariant } from '@dxos/invariant';\nimport { type Comparator, intersection } from '@dxos/util';\n\nimport { MetaId } from './model';\nimport type { BaseObject } from '../types';\n\n//\n// ObjectMeta\n//\n\n// TODO(dmaretskyi): Rename to ObjectMeta\nexport const ObjectMetaSchema = Schema.Struct({\n  keys: Schema.mutable(Schema.Array(ForeignKey)),\n});\n\nexport type ObjectMeta = Schema.Schema.Type<typeof ObjectMetaSchema>;\n\nexport const foreignKey = (source: string, id: string): ForeignKey => ({ source, id });\nexport const foreignKeyEquals = (a: ForeignKey, b: ForeignKey) => a.source === b.source && a.id === b.id;\n\n/**\n * Get metadata from object.\n * Only callable on the object root.\n * @deprecated Use {@link getMeta}.\n */\n// TODO(dmaretskyi): Remove.\nexport const getObjectMeta = (object: any): ObjectMeta => {\n  return getMeta(object);\n};\n\n/*\n * Get metadata from object.\n * Only callable on the object root.\n */\nexport const getMeta = (obj: BaseObject): ObjectMeta => {\n  const metadata = (obj as any)[MetaId];\n  invariant(metadata, 'ObjectMeta not found.');\n  return metadata;\n};\n\n// TODO(dmaretskyi): Move to echo-schema.\nexport const compareForeignKeys: Comparator<BaseObject> = (a: BaseObject, b: BaseObject) =>\n  intersection(getMeta(a).keys, getMeta(b).keys, foreignKeyEquals).length > 0;\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { Effect, Option, ParseResult, Schema, SchemaAST } from 'effect';\n\nimport { Reference, type EncodedReference } from '@dxos/echo-protocol';\nimport { compositeRuntime } from '@dxos/echo-signals/runtime';\nimport { assertArgument, invariant } from '@dxos/invariant';\nimport { DXN, ObjectId } from '@dxos/keys';\n\nimport { getSchemaDXN, getTypeAnnotation, getTypeIdentifierAnnotation, ReferenceAnnotationId } from '../ast';\nimport { type JsonSchemaType } from '../json-schema';\nimport type { BaseObject, WithId } from '../types';\n\n/**\n * The `$id` field for an ECHO reference schema.\n */\nexport const JSON_SCHEMA_ECHO_REF_ID = '/schemas/echo/ref';\n\n// TODO(burdon): Define return type.\nexport const getSchemaReference = (property: JsonSchemaType): { typename: string } | undefined => {\n  const { $id, reference: { schema: { $ref } = {} } = {} } = property;\n  if ($id === JSON_SCHEMA_ECHO_REF_ID && $ref) {\n    return { typename: DXN.parse($ref).typename };\n  }\n};\n\nexport const createSchemaReference = (typename: string): JsonSchemaType => {\n  return {\n    $id: JSON_SCHEMA_ECHO_REF_ID,\n    reference: {\n      schema: {\n        $ref: DXN.fromTypename(typename).toString(),\n      },\n    },\n  };\n};\n\nexport const RefTypeId: unique symbol = Symbol('@dxos/echo-schema/Ref');\n\n/**\n * Reference Schema.\n */\nexport interface Ref$<T extends WithId> extends Schema.SchemaClass<Ref<T>, EncodedReference> {}\n\n// Type of the `Ref` function and extra methods attached to it.\nexport interface RefFn {\n  <S extends Schema.Schema.Any>(schema: S): Ref$<Schema.Schema.Type<S>>;\n\n  /**\n   * @returns True if the object is a reference.\n   */\n  isRef: (obj: any) => obj is Ref<any>;\n\n  /**\n   * @returns True if the reference points to the given object id.\n   */\n  hasObjectId: (id: ObjectId) => (ref: Ref<any>) => boolean;\n\n  /**\n   * @returns True if the schema is a reference schema.\n   */\n  isRefSchema: (schema: Schema.Schema<any, any>) => schema is Ref$<any>;\n\n  /**\n   * @returns True if the schema AST is a reference schema.\n   */\n  isRefSchemaAST: (ast: SchemaAST.AST) => boolean;\n\n  /**\n   * Constructs a reference that points to the given object.\n   */\n  // TODO(burdon): Tighten type of T?\n  make: <T extends WithId>(object: T) => Ref<T>;\n\n  /**\n   * Constructs a reference that points to the object specified by the provided DXN.\n   */\n  fromDXN: (dxn: DXN) => Ref<any>;\n}\n/**\n * Schema builder for references.\n */\nexport const Ref: RefFn = <S extends Schema.Schema.Any>(schema: S): Ref$<Schema.Schema.Type<S>> => {\n  assertArgument(Schema.isSchema(schema), 'Must call with an instance of effect-schema');\n\n  const annotation = getTypeAnnotation(schema);\n  if (annotation == null) {\n    throw new Error('Reference target must be an ECHO schema.');\n  }\n\n  return createEchoReferenceSchema(\n    getTypeIdentifierAnnotation(schema),\n    annotation.typename,\n    annotation.version,\n    getSchemaExpectedName(schema.ast),\n  );\n};\n\n/**\n * Represents materialized reference to a target.\n * This is the data type for the fields marked as ref.\n */\nexport interface Ref<T> {\n  /**\n   * Target object DXN.\n   */\n  get dxn(): DXN;\n\n  /**\n   * @returns The reference target.\n   * May return `undefined` if the object is not loaded in the working set.\n   * Accessing this property, even if it returns `undefined` will trigger the object to be loaded to the working set.\n   *\n   * @reactive Supports signal subscriptions.\n   */\n  get target(): T | undefined;\n\n  /**\n   * @returns Promise that will resolves with the target object.\n   * Will load the object from disk if it is not present in the working set.\n   * @throws If the object is not available locally.\n   */\n  load(): Promise<T>;\n\n  /**\n   * @returns Promise that will resolves with the target object or undefined if the object is not loaded locally.\n   */\n  tryLoad(): Promise<T | undefined>;\n\n  /**\n   * Do not inline the target object in the reference.\n   * Makes .target unavailable unless the reference is connected to a database context.\n   *\n   * When serialized with toJSON, the difference is between:\n   * `{ \"/\": \"dxn:...\" }`\n   * and\n   * `{ \"/\": \"dxn:...\", \"target\": { ... } }`\n   */\n  noInline(): this;\n\n  /**\n   * Serializes the reference to a JSON object.\n   * The serialization format is compatible with the IPLD-style encoded references.\n   * When a reference has a saved target (i.e. the target or object holding the reference is not in the database),\n   * the target is included in the serialized object.\n   *\n   * Examples:\n   * `{ \"/\": \"dxn:...\" }`\n   * `{ \"/\": \"dxn:...\", \"target\": { ... } }`\n   */\n  encode(): EncodedReference;\n\n  [RefTypeId]: {\n    _T: T;\n  };\n}\n\nexport declare namespace Ref {\n  /**\n   * Target of the reference.\n   */\n  export type Target<R> = R extends Ref<infer U> ? U : never;\n}\n\nRef.isRef = (obj: any): obj is Ref<any> => {\n  return obj && typeof obj === 'object' && RefTypeId in obj;\n};\n\nRef.hasObjectId = (id: ObjectId) => (ref: Ref<any>) => ref.dxn.isLocalObjectId() && ref.dxn.parts[1] === id;\n\nRef.isRefSchema = (schema: Schema.Schema<any, any>): schema is Ref$<any> => {\n  return Ref.isRefSchemaAST(schema.ast);\n};\n\nRef.isRefSchemaAST = (ast: SchemaAST.AST): boolean => {\n  return SchemaAST.getAnnotation(ast, ReferenceAnnotationId).pipe(Option.isSome);\n};\n\nRef.make = <T extends BaseObject>(obj: T): Ref<T> => {\n  if (typeof obj !== 'object' || obj === null) {\n    throw new TypeError('Expected: ECHO object.');\n  }\n\n  // TODO(dmaretskyi): Extract to `getObjectDXN` function.\n  const id = obj.id;\n  invariant(ObjectId.isValid(id), 'Invalid object ID');\n  const dxn = Reference.localObjectReference(id).toDXN();\n  return new RefImpl(dxn, obj);\n};\n\nRef.fromDXN = (dxn: DXN): Ref<any> => {\n  return new RefImpl(dxn);\n};\n\n/**\n * `reference` field on the schema object.\n */\nexport type JsonSchemaReferenceInfo = {\n  schema: { $ref: string };\n  schemaVersion?: string;\n};\n\n/**\n * @internal\n */\n// TODO(burdon): Move to json schema and make private?\nexport const createEchoReferenceSchema = (\n  echoId: string | undefined,\n  typename: string | undefined,\n  version: string | undefined,\n  schemaName?: string,\n): Schema.SchemaClass<Ref<any>, EncodedReference> => {\n  if (!echoId && !typename) {\n    throw new TypeError('Either echoId or typename must be provided.');\n  }\n\n  const referenceInfo: JsonSchemaReferenceInfo = {\n    schema: {\n      // TODO(dmaretskyi): Include version?\n      $ref: echoId ?? DXN.fromTypename(typename!).toString(),\n    },\n    schemaVersion: version,\n  };\n\n  // TODO(dmaretskyi): Add name and description.\n  const refSchema = Schema.declare<Ref<any>, EncodedReference, []>(\n    [],\n    {\n      encode: () => {\n        return (value) => {\n          return Effect.succeed({\n            '/': (value as Ref<any>).dxn.toString(),\n          });\n        };\n      },\n      decode: () => {\n        return (value) => {\n          // TODO(dmaretskyi): This branch seems to be taken by Schema.is\n          if (Ref.isRef(value)) {\n            return Effect.succeed(value);\n          }\n\n          if (typeof value !== 'object' || value == null || typeof (value as any)['/'] !== 'string') {\n            return Effect.fail(new ParseResult.Unexpected(value, 'reference'));\n          }\n\n          return Effect.succeed(Ref.fromDXN(DXN.parse((value as any)['/'])));\n        };\n      },\n    },\n    {\n      jsonSchema: {\n        $id: JSON_SCHEMA_ECHO_REF_ID,\n        reference: referenceInfo,\n      },\n      [ReferenceAnnotationId]: {\n        typename: typename ?? '',\n        version,\n      },\n    },\n  );\n\n  return refSchema;\n};\n\nconst getSchemaExpectedName = (ast: SchemaAST.Annotated): string | undefined => {\n  return SchemaAST.getIdentifierAnnotation(ast).pipe(\n    Option.orElse(() => SchemaAST.getTitleAnnotation(ast)),\n    Option.orElse(() => SchemaAST.getDescriptionAnnotation(ast)),\n    Option.getOrElse(() => undefined),\n  );\n};\n\nexport interface RefResolver {\n  /**\n   * Resolve ref synchronously from the objects in the working set.\n   *\n   * @param dxn\n   * @param load If true the resolver should attempt to load the object from disk.\n   * @param onLoad Callback to call when the object is loaded.\n   */\n  resolveSync(dxn: DXN, load: boolean, onLoad?: () => void): BaseObject | undefined;\n\n  /**\n   * Resolver ref asynchronously.\n   */\n  resolve(dxn: DXN): Promise<BaseObject | undefined>;\n\n  // TODO(dmaretskyi): Combine with `resolve`.\n  resolveSchema(dxn: DXN): Promise<Schema.Schema.AnyNoContext | undefined>;\n}\n\nexport class RefImpl<T> implements Ref<T> {\n  #dxn: DXN;\n  #resolver?: RefResolver = undefined;\n  #signal = compositeRuntime.createSignal();\n\n  /**\n   * Target is set when the reference is created from a specific object.\n   * In this case, the target might not be in the database.\n   */\n  #target: T | undefined = undefined;\n\n  /**\n   * Callback to issue a reactive notification when object is resolved.\n   */\n  #resolverCallback = () => {\n    this.#signal.notifyWrite();\n  };\n\n  constructor(dxn: DXN, target?: T) {\n    this.#dxn = dxn;\n    this.#target = target;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  get dxn(): DXN {\n    return this.#dxn;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  get target(): T | undefined {\n    this.#signal.notifyRead();\n    if (this.#target) {\n      return this.#target;\n    }\n\n    invariant(this.#resolver, 'Resolver is not set');\n    return this.#resolver.resolveSync(this.#dxn, true, this.#resolverCallback) as T | undefined;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async load(): Promise<T> {\n    invariant(this.#resolver, 'Resolver is not set');\n    const obj = await this.#resolver.resolve(this.#dxn);\n    if (obj == null) {\n      throw new Error('Object not found');\n    }\n    return obj as T;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async tryLoad(): Promise<T | undefined> {\n    invariant(this.#resolver, 'Resolver is not set');\n    return (await this.#resolver.resolve(this.#dxn)) as T | undefined;\n  }\n\n  /**\n   * Do not inline the target object in the reference.\n   * Makes .target unavailable unless the reference is connected to a database context.\n   */\n  noInline(): this {\n    this.#target = undefined;\n    return this;\n  }\n\n  encode(): EncodedReference {\n    return {\n      '/': this.#dxn.toString(),\n      ...(this.#target ? { target: this.#target } : {}),\n    };\n  }\n\n  /**\n   * Serializes the reference to a JSON object.\n   * The serialization format is compatible with the IPLD-style encoded references.\n   * When a reference has a saved target (i.e. the target or object holding the reference is not in the database),\n   * the target is included in the serialized object.\n   */\n  toJSON(): EncodedReference {\n    return this.encode();\n  }\n\n  toString(): string {\n    if (this.#target) {\n      return `Ref(${this.#target.toString()})`;\n    }\n\n    return `Ref(${this.#dxn.toString()})`;\n  }\n\n  [RefTypeId] = refVariance;\n\n  /**\n   * Internal method to set the resolver.\n   * @internal\n   */\n  _setResolver(resolver: RefResolver): void {\n    this.#resolver = resolver;\n  }\n\n  /**\n   * Internal method to get the saved target.\n   * Not the same as `target` which is resolved from the resolver.\n   * @internal\n   */\n  _getSavedTarget(): T | undefined {\n    return this.#target;\n  }\n}\n\n/**\n * Internal API for setting the reference resolver.\n */\nexport const setRefResolver = (ref: Ref<any>, resolver: RefResolver) => {\n  invariant(ref instanceof RefImpl, 'Ref is not an instance of RefImpl');\n  ref._setResolver(resolver);\n};\n\n/**\n * Internal API for getting the saved target on a reference.\n */\nexport const getRefSavedTarget = (ref: Ref<any>): BaseObject | undefined => {\n  invariant(ref instanceof RefImpl, 'Ref is not an instance of RefImpl');\n  return ref._getSavedTarget();\n};\n\n// Used to validate reference target type.\nconst refVariance: Ref<any>[typeof RefTypeId] = {\n  _T: null as any,\n};\n\nexport const refFromEncodedReference = (encodedReference: EncodedReference, resolver?: RefResolver): Ref<any> => {\n  const dxn = DXN.parse(encodedReference['/']);\n  const ref = new RefImpl(dxn);\n\n  // TODO(dmaretskyi): Handle inline target in the encoded reference.\n\n  if (resolver) {\n    setRefResolver(ref, resolver);\n  }\n  return ref;\n};\n\nexport class StaticRefResolver implements RefResolver {\n  public objects = new Map<ObjectId, BaseObject>();\n  public schemas = new Map<DXN.String, Schema.Schema.AnyNoContext>();\n\n  addObject(obj: BaseObject): this {\n    this.objects.set(obj.id, obj);\n    return this;\n  }\n\n  addSchema(schema: Schema.Schema.AnyNoContext): this {\n    const dxn = getSchemaDXN(schema);\n    invariant(dxn, 'Schema has no DXN');\n    this.schemas.set(dxn.toString(), schema);\n    return this;\n  }\n\n  resolveSync(dxn: DXN, _load: boolean, _onLoad?: () => void): BaseObject | undefined {\n    const id = dxn?.asEchoDXN()?.echoId;\n    if (id == null) {\n      return undefined;\n    }\n\n    return this.objects.get(id);\n  }\n\n  async resolve(dxn: DXN): Promise<BaseObject | undefined> {\n    const id = dxn?.asEchoDXN()?.echoId;\n    if (id == null) {\n      return undefined;\n    }\n\n    return this.objects.get(id);\n  }\n\n  async resolveSchema(dxn: DXN): Promise<Schema.Schema.AnyNoContext | undefined> {\n    return this.schemas.get(dxn.toString());\n  }\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { type ObjectId } from '@dxos/keys';\nimport { isNonNullable } from '@dxos/util';\n\nimport { Ref } from './ref';\nimport type { AnyEchoObject } from '../types';\n\n/**\n * Helper functions for working with arrays of refs.\n */\nexport const RefArray = Object.freeze({\n  /**\n   * @returns all resolved targets.\n   */\n  targets: <T extends AnyEchoObject>(refs: Ref<T>[]): T[] => {\n    return refs.map((ref) => ref.target).filter(isNonNullable);\n  },\n\n  /**\n   * Load all referenced objects.\n   */\n  loadAll: <T extends AnyEchoObject>(refs: Ref<T>[]): Promise<T[]> => {\n    return Promise.all(refs.map((ref) => ref.load()));\n  },\n\n  /**\n   * Removes the ref with the given id.\n   */\n  removeById: (refs: Ref<AnyEchoObject>[], id: ObjectId) => {\n    const index = refs.findIndex(Ref.hasObjectId(id));\n    if (index >= 0) {\n      refs.splice(index, 1);\n    }\n  },\n});\n", "//\n// Copyright 2024 DXOS.org\n//\n\n// TODO(burdon): Document.\nexport const defineHiddenProperty = (object: any, key: string | symbol, value: any) => {\n  Object.defineProperty(object, key, {\n    enumerable: false,\n    configurable: true,\n    value,\n  });\n};\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { Schema } from 'effect';\n\nimport { raise } from '@dxos/debug';\nimport { isEncodedReference, type EncodedReference } from '@dxos/echo-protocol';\nimport { assertArgument, invariant } from '@dxos/invariant';\nimport { DXN, ObjectId } from '@dxos/keys';\nimport { assumeType, deepMapValues, visitValues } from '@dxos/util';\n\nimport { setSchema } from './accessors';\nimport { ObjectMetaSchema } from './meta';\nimport {\n  ATTR_DELETED,\n  ATTR_META,\n  ATTR_RELATION_SOURCE,\n  ATTR_RELATION_TARGET,\n  ATTR_SELF_DXN,\n  ATTR_TYPE,\n  EntityKindId,\n  MetaId,\n  RelationSourceDXNId,\n  RelationTargetDXNId,\n  RelationSourceId,\n  RelationTargetId,\n  TypeId,\n  type ObjectJSON,\n  assertObjectModelShape,\n} from './model';\nimport { getType, setTypename } from './typename';\nimport { EntityKind } from '../ast';\nimport { Ref, refFromEncodedReference, setRefResolver, type RefResolver } from '../ref';\nimport { type AnyEchoObject } from '../types';\nimport { defineHiddenProperty } from '../utils';\n\ntype DeepReplaceRef<T> =\n  T extends Ref<any> ? EncodedReference : T extends object ? { [K in keyof T]: DeepReplaceRef<T[K]> } : T;\n\ntype SerializedObject<T extends { id: string }> = { [K in keyof T]: DeepReplaceRef<T[K]> } & ObjectJSON;\n\n/**\n * Converts object to it's JSON representation.\n */\nexport const objectToJSON = <T extends AnyEchoObject>(obj: T): SerializedObject<T> => {\n  const typename = getType(obj)?.toString();\n  invariant(typename && typeof typename === 'string');\n  return typedJsonSerializer.call(obj);\n};\n\n/**\n * Creates an object from it's json representation.\n * Performs schema validation.\n * References and schema will be resolvable if the `refResolver` is provided.\n *\n * The function need to be async to support resolving the schema as well as the relation endpoints.\n */\nexport const objectFromJSON = async (\n  jsonData: unknown,\n  { refResolver }: { refResolver?: RefResolver } = {},\n): Promise<AnyEchoObject> => {\n  assumeType<ObjectJSON>(jsonData);\n  assertArgument(typeof jsonData === 'object' && jsonData !== null, 'expect object');\n  assertArgument(typeof jsonData[ATTR_TYPE] === 'string', 'expected object to have a type');\n  assertArgument(typeof jsonData.id === 'string', 'expected object to have an id');\n\n  const type = DXN.parse(jsonData[ATTR_TYPE]);\n  const schema = await refResolver?.resolveSchema(type);\n  invariant(schema === undefined || Schema.isSchema(schema));\n\n  let obj: any;\n  if (schema != null) {\n    obj = await schema.pipe(Schema.decodeUnknownPromise)(jsonData);\n    if (refResolver) {\n      setRefResolverOnData(obj, refResolver);\n    }\n  } else {\n    obj = decodeGeneric(jsonData, { refResolver });\n  }\n\n  invariant(ObjectId.isValid(obj.id), 'Invalid object id');\n\n  setTypename(obj, type);\n  if (schema) {\n    setSchema(obj, schema);\n  }\n\n  const isRelation =\n    typeof jsonData[ATTR_RELATION_SOURCE] === 'string' || typeof jsonData[ATTR_RELATION_TARGET] === 'string';\n  if (isRelation) {\n    const sourceDxn: DXN = DXN.parse(jsonData[ATTR_RELATION_SOURCE] ?? raise(new TypeError('Missing relation source')));\n    const targetDxn: DXN = DXN.parse(jsonData[ATTR_RELATION_TARGET] ?? raise(new TypeError('Missing relation target')));\n\n    // TODO(dmaretskyi): Async!\n    const source = (await refResolver?.resolve(sourceDxn)) as AnyEchoObject | undefined;\n    const target = (await refResolver?.resolve(targetDxn)) as AnyEchoObject | undefined;\n\n    defineHiddenProperty(obj, EntityKindId, EntityKind.Relation);\n    defineHiddenProperty(obj, RelationSourceDXNId, sourceDxn);\n    defineHiddenProperty(obj, RelationTargetDXNId, targetDxn);\n    defineHiddenProperty(obj, RelationSourceId, source);\n    defineHiddenProperty(obj, RelationTargetId, target);\n  } else {\n    defineHiddenProperty(obj, EntityKindId, EntityKind.Object);\n  }\n\n  if (typeof jsonData[ATTR_META] === 'object') {\n    const meta = await ObjectMetaSchema.pipe(Schema.decodeUnknownPromise)(jsonData[ATTR_META]);\n\n    // Defensive programming.\n    invariant(Array.isArray(meta.keys));\n\n    defineHiddenProperty(obj, MetaId, meta);\n  }\n\n  assertObjectModelShape(obj);\n  invariant((obj as any)[ATTR_TYPE] === undefined, 'Invalid object model');\n  invariant((obj as any)[ATTR_SELF_DXN] === undefined, 'Invalid object model');\n  invariant((obj as any)[ATTR_DELETED] === undefined, 'Invalid object model');\n  invariant((obj as any)[ATTR_RELATION_SOURCE] === undefined, 'Invalid object model');\n  invariant((obj as any)[ATTR_RELATION_TARGET] === undefined, 'Invalid object model');\n  invariant((obj as any)[ATTR_META] === undefined, 'Invalid object model');\n  return obj;\n};\n\nconst decodeGeneric = (jsonData: unknown, options: { refResolver?: RefResolver }) => {\n  const {\n    [ATTR_TYPE]: _type,\n    [ATTR_META]: _meta,\n    [ATTR_DELETED]: _deleted,\n    [ATTR_RELATION_SOURCE]: _relationSource,\n    [ATTR_RELATION_TARGET]: _relationTarget,\n    [ATTR_SELF_DXN]: _selfDxn,\n    ...props\n  } = jsonData as any;\n\n  return deepMapValues(props, (value, recurse) => {\n    if (isEncodedReference(value)) {\n      return refFromEncodedReference(value, options.refResolver);\n    }\n    return recurse(value);\n  });\n};\n\nconst setRefResolverOnData = (obj: AnyEchoObject, refResolver: RefResolver) => {\n  const go = (value: unknown) => {\n    if (Ref.isRef(value)) {\n      setRefResolver(value, refResolver);\n    } else {\n      visitValues(value, go);\n    }\n  };\n\n  go(obj);\n};\n\n/**\n * @internal\n */\nexport const attachTypedJsonSerializer = (obj: any) => {\n  const descriptor = Object.getOwnPropertyDescriptor(obj, 'toJSON');\n  if (descriptor) {\n    return;\n  }\n\n  Object.defineProperty(obj, 'toJSON', {\n    value: typedJsonSerializer,\n    writable: false,\n    enumerable: false,\n    configurable: false,\n  });\n};\n\n// NOTE: KEEP as function.\nconst typedJsonSerializer = function (this: any) {\n  const { id, [TypeId]: typename, [MetaId]: meta, ...rest } = this;\n  const result: any = {\n    id,\n    [ATTR_TYPE]: typename.toString(),\n  };\n\n  if (this[RelationSourceDXNId]) {\n    const sourceDXN = this[RelationSourceDXNId];\n    invariant(sourceDXN instanceof DXN);\n    result[ATTR_RELATION_SOURCE] = sourceDXN.toString();\n  }\n  if (this[RelationTargetDXNId]) {\n    const targetDXN = this[RelationTargetDXNId];\n    invariant(targetDXN instanceof DXN);\n    result[ATTR_RELATION_TARGET] = targetDXN.toString();\n  }\n\n  if (meta) {\n    result[ATTR_META] = serializeData(meta);\n  }\n\n  Object.assign(result, serializeData(rest));\n  return result;\n};\n\nconst serializeData = (data: unknown) => {\n  return deepMapValues(data, (value, recurse) => {\n    if (Ref.isRef(value)) {\n      // TODO(dmaretskyi): Should this be configurable?\n      return value.noInline().encode();\n    }\n    return recurse(value);\n  });\n};\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { type Schema } from 'effect';\n\nimport { raise } from '@dxos/debug';\nimport { assertArgument, failedInvariant } from '@dxos/invariant';\nimport { ObjectId } from '@dxos/keys';\n\nimport { getObjectDXN, setSchema } from './accessors';\nimport { attachedTypedObjectInspector } from './inspect';\nimport { attachTypedJsonSerializer } from './json-serializer';\nimport {\n  assertObjectModelShape,\n  EntityKindId,\n  MetaId,\n  RelationSourceDXNId,\n  RelationSourceId,\n  RelationTargetDXNId,\n  RelationTargetId,\n} from './model';\nimport { setTypename } from './typename';\nimport { EntityKind, getSchemaDXN, getTypeAnnotation } from '../ast';\nimport { defineHiddenProperty } from '../utils';\n\n// Make `id` optional.\ntype CreateData<T> = T extends { id: string } ? Omit<T, 'id' | typeof EntityKindId> & { id?: string } : T;\n\n/**\n * Creates a new object instance from a schema and data, without signal reactivity.\n * This static version creates plain JavaScript objects that are not reactive/observable.\n * For reactive objects that automatically update UI when changed, use the regular live() function.\n *\n * @param schema - The Effect schema that defines the object's structure and type, piped into EchoObject\n * @param data - The data to initialize the object with. The id and @type fields are handled automatically.\n * @returns A new non-reactive object instance conforming to the schema\n * @throws {Error} If the schema is not an object schema\n * @throws {TypeError} If data contains an @type field\n *\n * @example\n * ```ts\n * const Contact = Schema.Struct({\n *   name: Schema.String,\n *   email: Schema.String,\n * }).pipe(Type.Obj({\n *   typename: 'example.com/type/Contact',\n *   version: '0.1.0',\n * }))\n *\n * // Creates a non-reactive contact object\n * const contact = create(Contact, {\n *   name: \"John\",\n *   email: \"john@example.com\",\n * })\n * ```\n */\n// TODO(burdon): Rename make.\n// TODO(burdon): Handle defaults (see Schema.make).\n// TODO(dmaretskyi): Use `Obj.make` and `Relation.make` from '@dxos/echo' instead.\nexport const create = <S extends Schema.Schema.AnyNoContext>(\n  schema: S,\n  data: CreateData<Schema.Schema.Type<S>>,\n): CreateData<Schema.Schema.Type<S>> & { id: string } => {\n  const annotation = getTypeAnnotation(schema);\n  if (!annotation) {\n    throw new Error('Schema is not an object schema');\n  }\n  assertArgument(!('@type' in data), '@type is not allowed');\n  assertArgument(!(RelationSourceDXNId in data), 'Relation source DXN is not allowed in the constructor');\n  assertArgument(!(RelationTargetDXNId in data), 'Relation target DXN is not allowed in the constructor');\n  assertArgument(\n    RelationSourceId in data === RelationTargetId in data,\n    'Relation source and target must be provided together',\n  );\n\n  const obj = { ...data, id: data.id ?? ObjectId.random() };\n  const kind = RelationSourceId in data ? EntityKind.Relation : EntityKind.Object;\n  defineHiddenProperty(obj, EntityKindId, kind);\n  setTypename(obj, getSchemaDXN(schema) ?? failedInvariant('Missing schema DXN'));\n  setSchema(obj, schema);\n  attachTypedJsonSerializer(obj);\n  attachedTypedObjectInspector(obj);\n  defineHiddenProperty(obj, MetaId, { keys: [] });\n  if (kind === EntityKind.Relation) {\n    const sourceDXN = getObjectDXN(data[RelationSourceId]) ?? raise(new Error('Unresolved relation source'));\n    const targetDXN = getObjectDXN(data[RelationTargetId]) ?? raise(new Error('Unresolved relation target'));\n    defineHiddenProperty(obj, RelationSourceDXNId, sourceDXN);\n    defineHiddenProperty(obj, RelationTargetDXNId, targetDXN);\n  }\n\n  assertObjectModelShape(obj);\n  return obj;\n};\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport type { inspect as inspectFn, InspectOptionsStylized } from 'node:util';\n\nimport { inspectCustom, type CustomInspectFunction } from '@dxos/debug';\n\nimport { ATTR_META, ATTR_TYPE, MetaId } from './model';\nimport { getType } from './typename';\nimport { type BaseEchoObject } from '../types';\n\n/*\n * @internal\n */\nexport const attachedTypedObjectInspector = (obj: any) => {\n  const descriptor = Object.getOwnPropertyDescriptor(obj, inspectCustom);\n  if (descriptor) {\n    return;\n  }\n\n  Object.defineProperty(obj, inspectCustom, {\n    value: typedObjectInspectFunction,\n    writable: false,\n    enumerable: false,\n    configurable: true,\n  });\n};\n\n// NOTE: KEEP as function.\nconst typedObjectInspectFunction: CustomInspectFunction<BaseEchoObject> = function (\n  this: BaseEchoObject,\n  depth: number,\n  options: InspectOptionsStylized,\n  inspect: typeof inspectFn,\n) {\n  const { id, ...props } = this;\n  return inspect(\n    {\n      id,\n      [ATTR_TYPE]: getType(this),\n      ...props,\n      [ATTR_META]: (this as any)[MetaId], // TODO(dmaretskyi): Couldn't use getMeta since that throw's if the object has no meta.\n    },\n    options,\n  );\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { Schema, SchemaAST, type Types } from 'effect';\n\nimport { raise } from '@dxos/debug';\nimport { invariant } from '@dxos/invariant';\nimport { DXN } from '@dxos/keys';\n\nimport { type RelationSourceTargetRefs } from './relation';\nimport {\n  getEntityKind,\n  getSchemaTypename,\n  getTypeIdentifierAnnotation,\n  EntityKind,\n  type TypeAnnotation,\n  TypeAnnotationId,\n  type TypeMeta,\n} from '../ast';\nimport { type HasId, type ToMutable } from '../types';\n\n/**\n * Pipeable function to add ECHO object annotations to a schema.\n */\n// TODO(burdon): Rename EchoType.\nexport const EchoObject: {\n  // TODO(burdon): Tighten Self type to Schema.TypeLiteral or Schema.Struct to facilitate definition of `make` method.\n  // (meta: TypeMeta): <Self extends Schema.Struct<Fields>, Fields extends Schema.Struct.Fields>(self: Self) => EchoObjectSchema<Self, Fields>;\n  (meta: TypeMeta): <Self extends Schema.Schema.Any>(self: Self) => EchoTypeSchema<Self>;\n} = ({ typename, version }) => {\n  return <Self extends Schema.Schema.Any>(self: Self): EchoTypeSchema<Self> => {\n    invariant(typeof TypeAnnotationId === 'symbol', 'Sanity.');\n    invariant(SchemaAST.isTypeLiteral(self.ast), 'Schema must be a TypeLiteral.');\n\n    // TODO(dmaretskyi): Does `Schema.mutable` work for deep mutability here?\n    // TODO(dmaretskyi): Do not do mutable here.\n    const schemaWithId = Schema.extend(Schema.mutable(self), Schema.Struct({ id: Schema.String }));\n    const ast = SchemaAST.annotations(schemaWithId.ast, {\n      // TODO(dmaretskyi): `extend` kills the annotations.\n      ...self.ast.annotations,\n      [TypeAnnotationId]: { kind: EntityKind.Object, typename, version } satisfies TypeAnnotation,\n      // TODO(dmaretskyi): TypeIdentifierAnnotationId?\n    });\n\n    return makeEchoObjectSchema<Self>(/* self.fields, */ ast, typename, version);\n  };\n};\n\nexport type EchoRelationOptions<\n  TSource extends Schema.Schema.AnyNoContext,\n  TTarget extends Schema.Schema.AnyNoContext,\n> = {\n  typename: string;\n  version: string;\n  source: TSource;\n  target: TTarget;\n};\n\nconst getDXNForRelationSchemaRef = (schema: Schema.Schema.Any): string => {\n  const identifier = getTypeIdentifierAnnotation(schema);\n  if (identifier) {\n    return identifier;\n  }\n\n  const typename = getSchemaTypename(schema);\n  if (!typename) {\n    throw new Error('Schema must have a typename');\n  }\n  return DXN.fromTypename(typename).toString();\n};\n\n// TODO(dmaretskyi): Rename?\nexport const EchoRelation = <Source extends Schema.Schema.AnyNoContext, Target extends Schema.Schema.AnyNoContext>(\n  options: EchoRelationOptions<Source, Target>,\n) => {\n  const sourceDXN = getDXNForRelationSchemaRef(options.source);\n  const targetDXN = getDXNForRelationSchemaRef(options.target);\n  if (getEntityKind(options.source) !== EntityKind.Object) {\n    raise(new Error('Source schema must be an echo object schema.'));\n  }\n  if (getEntityKind(options.target) !== EntityKind.Object) {\n    raise(new Error('Target schema must be an echo object schema.'));\n  }\n\n  return <Self extends Schema.Schema.Any>(\n    self: Self,\n  ): EchoTypeSchema<Self, RelationSourceTargetRefs<Schema.Schema.Type<Source>, Schema.Schema.Type<Target>>> => {\n    invariant(SchemaAST.isTypeLiteral(self.ast), 'Schema must be a TypeLiteral.');\n\n    // TODO(dmaretskyi): Does `Schema.mutable` work for deep mutability here?\n    // TODO(dmaretskyi): Do not do mutable here.\n    const schemaWithId = Schema.extend(Schema.mutable(self), Schema.Struct({ id: Schema.String }));\n    const ast = SchemaAST.annotations(schemaWithId.ast, {\n      // TODO(dmaretskyi): `extend` kills the annotations.\n      ...self.ast.annotations,\n      [TypeAnnotationId]: {\n        kind: EntityKind.Relation,\n        typename: options.typename,\n        version: options.version,\n        sourceSchema: sourceDXN,\n        targetSchema: targetDXN,\n      } satisfies TypeAnnotation,\n      // TODO(dmaretskyi): TypeIdentifierAnnotationId?\n    });\n\n    return makeEchoObjectSchema<Self>(/* self.fields, */ ast, options.typename, options.version);\n  };\n};\n\n// type RequiredKeys<T> = { [K in keyof T]-?: {} extends Pick<T, K> ? never : K }[keyof T];\ntype EchoTypeSchemaProps<T, ExtraFields = {}> = Types.Simplify<HasId & ToMutable<T> & ExtraFields>;\n\n// type MakeOptions =\n//   | boolean\n//   | {\n//       readonly disableValidation?: boolean;\n//     };\n\n// NOTE: Utils copied from Effect `Schema.ts`.\n// const _ownKeys = (o: object): Array<PropertyKey> =>\n//   (Object.keys(o) as Array<PropertyKey>).concat(Object.getOwnPropertySymbols(o));\n\n// const _lazilyMergeDefaults = (\n//   fields: Schema.Struct.Fields,\n//   out: Record<PropertyKey, unknown>,\n// ): { [x: string | symbol]: unknown } => {\n//   const ownKeys = _ownKeys(fields);\n//   for (const key of ownKeys) {\n//     const field = fields[key];\n//     if (out[key] === undefined && Schema.isPropertySignature(field)) {\n//       const ast = field.ast;\n//       const defaultValue = ast._tag === 'PropertySignatureDeclaration' ? ast.defaultValue : ast.to.defaultValue;\n//       if (defaultValue !== undefined) {\n//         out[key] = defaultValue();\n//       }\n//     }\n//   }\n//   return out;\n// };\n\n// const _getDisableValidationMakeOption = (options: MakeOptions | undefined): boolean =>\n//   Predicate.isBoolean(options) ? options : options?.disableValidation ?? false;\n\nexport interface EchoTypeSchema<Self extends Schema.Schema.Any, ExtraFields = {}>\n  extends TypeMeta,\n    Schema.AnnotableClass<\n      EchoTypeSchema<Self, ExtraFields>,\n      EchoTypeSchemaProps<Schema.Schema.Type<Self>, ExtraFields>,\n      EchoTypeSchemaProps<Schema.Schema.Encoded<Self>, ExtraFields>,\n      Schema.Schema.Context<Self>\n    > {\n  // make(\n  //   props: RequiredKeys<Schema.TypeLiteral.Constructor<Fields, []>> extends never\n  //     ? void | Simplify<Schema.TypeLiteral.Constructor<Fields, []>>\n  //     : Simplify<Schema.TypeLiteral.Constructor<Fields, []>>,\n  //   options?: MakeOptions,\n  // ): Simplify<Schema.TypeLiteral.Type<Fields, []>>;\n\n  instanceOf(value: unknown): boolean;\n}\n\nconst makeEchoObjectSchema = <Self extends Schema.Schema.Any>(\n  // fields: Fields,\n  ast: SchemaAST.AST,\n  typename: string,\n  version: string,\n): EchoTypeSchema<Self> => {\n  return class EchoObjectSchemaClass extends Schema.make<\n    EchoTypeSchemaProps<Schema.Schema.Type<Self>>,\n    EchoTypeSchemaProps<Schema.Schema.Encoded<Self>>,\n    Schema.Schema.Context<Self>\n  >(ast) {\n    static readonly typename = typename;\n    static readonly version = version;\n\n    static override annotations(\n      annotations: Schema.Annotations.GenericSchema<EchoTypeSchemaProps<Schema.Schema.Type<Self>>>,\n    ): EchoTypeSchema<Self> {\n      const schema = Schema.make<EchoTypeSchemaProps<Schema.Schema.Type<Self>>>(ast).annotations(annotations);\n      return makeEchoObjectSchema<Self>(/* fields, */ schema.ast, typename, version);\n    }\n\n    // static make(\n    //   props: RequiredKeys<Schema.TypeLiteral.Constructor<Fields, []>> extends never\n    //     ? void | Simplify<Schema.TypeLiteral.Constructor<Fields, []>>\n    //     : Simplify<Schema.TypeLiteral.Constructor<Fields, []>>,\n    //   options?: MakeOptions,\n    // ): Simplify<Schema.TypeLiteral.Type<Fields, []>> {\n    //   const propsWithDefaults: any = _lazilyMergeDefaults(fields, { ...(props as any) });\n    //   return _getDisableValidationMakeOption(options)\n    //     ? propsWithDefaults\n    //     : ParseResult.validateSync(this)(propsWithDefaults);\n    // }\n\n    static instanceOf(value: unknown): boolean {\n      return Schema.is(this)(value);\n    }\n  };\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { Schema } from 'effect';\n\nimport { EchoObject } from './entity';\n\nexport const EXPANDO_TYPENAME = 'dxos.org/type/Expando';\n\nconst ExpandoSchema = Schema.Struct({}, { key: Schema.String, value: Schema.Any }).pipe(\n  EchoObject({ typename: EXPANDO_TYPENAME, version: '0.1.0' }),\n);\n\n/**\n * Expando object is an object with an arbitrary set of properties.\n */\n// TODO(dmaretskyi): Can we consider expando a top-type, i.e. have a ref to expando potentially be a valid ref to any object?\nexport interface Expando extends Schema.Schema.Type<typeof ExpandoSchema> {}\n\nexport const Expando: Schema.Schema<Expando> = ExpandoSchema;\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { DXN, ObjectId, QueueSubspaceTags, SpaceId } from '@dxos/keys';\n\n// TODO(burdon): Move to @dxos/keys once ObjectId is moved there.\n/**\n * @deprecated Use `db.queues.create()`\n */\nexport const createQueueDXN = (spaceId = SpaceId.random(), queueId = ObjectId.random()) =>\n  new DXN(DXN.kind.QUEUE, [QueueSubspaceTags.DATA, spaceId, queueId]);\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { Schema } from 'effect';\n\nimport { invariant } from '@dxos/invariant';\n\nimport { makeTypedEntityClass, type TypedObjectFields, type TypedObjectOptions } from './common';\nimport { type TypeAnnotation, EntityKind, TypeAnnotationId, type TypeMeta, Typename, Version } from '../ast';\nimport { type HasId } from '../types';\n\n/**\n * Definition for an object type that can be stored in an ECHO database.\n * Implements effect schema to define object properties.\n * Has a typename and version.\n *\n * In contrast to {@link EchoSchema} this definition is not recorded in the database.\n */\nexport interface TypedObject<A = any, I = any> extends TypeMeta, Schema.Schema<A, I> {}\n\n/**\n * Typed object that could be used as a prototype in class definitions.\n * This is an internal API type.\n * Use {@link TypedObject} for the common use-cases.\n */\nexport interface TypedObjectPrototype<A = any, I = any> extends TypedObject<A, I> {\n  /** Type constructor. */\n  new (): HasId & A;\n}\n\nexport type TypedObjectProps = TypeMeta & {\n  // TODO(dmaretskyi): Remove after all legacy types has been removed.\n  disableValidation?: boolean;\n};\n\n/**\n * Base class factory for typed objects.\n * @deprecated Use pipe(Type.Obj) instead.\n */\nexport const TypedObject = ({ typename: _typename, version: _version, disableValidation }: TypedObjectProps) => {\n  const typename = Typename.make(_typename, { disableValidation });\n  const version = Version.make(_version, { disableValidation });\n\n  /**\n   * Return class definition factory.\n   */\n  return <SchemaFields extends Schema.Struct.Fields, Options extends TypedObjectOptions>(\n    fields: SchemaFields,\n    options?: Options,\n  ): TypedObjectPrototype<TypedObjectFields<SchemaFields, Options>, Schema.Struct.Encoded<SchemaFields>> => {\n    // Create schema from fields.\n    const schema: Schema.Schema.All = options?.record\n      ? Schema.Struct(fields, { key: Schema.String, value: Schema.Any })\n      : Schema.Struct(fields);\n\n    // Set ECHO object id property.\n    const typeSchema = Schema.extend(\n      Schema.mutable(options?.partial ? Schema.partial(schema) : schema),\n      Schema.Struct({ id: Schema.String }),\n    );\n\n    // Set ECHO annotations.\n    invariant(typeof EntityKind.Object === 'string');\n    const annotatedSchema = typeSchema.annotations({\n      [TypeAnnotationId]: { kind: EntityKind.Object, typename, version } satisfies TypeAnnotation,\n    });\n\n    /**\n     * Return class definition.\n     * NOTE: Actual reactive ECHO objects must be created via the `live(Type)` function.\n     */\n    // TODO(burdon): This is missing fields required by TypedObject (e.g., Type, Encoded, Context)?\n    return class TypedObject extends makeTypedEntityClass(typename, version, annotatedSchema as any) {} as any;\n  };\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { Schema } from 'effect';\n\nimport { invariant } from '@dxos/invariant';\n\nimport { makeTypedEntityClass, type TypedObjectFields, type TypedObjectOptions } from './common';\nimport { type RelationSourceTargetRefs } from './relation';\nimport { EntityKind, TypeAnnotationId, Typename, Version, type TypeAnnotation, type TypeMeta } from '../ast';\nimport { type HasId } from '../types';\n\n/**\n * Definition for an object type that can be stored in an ECHO database.\n * Implements effect schema to define object properties.\n * Has a typename and version.\n *\n * In contrast to {@link EchoSchema} this definition is not recorded in the database.\n */\nexport interface TypedRelation<A = any, I = any> extends TypeMeta, Schema.Schema<A, I> {}\n\n/**\n * Typed object that could be used as a prototype in class definitions.\n * This is an internal API type.\n * Use {@link TypedRelation} for the common use-cases.\n */\nexport interface TypedRelationPrototype<A = any, I = any> extends TypedRelation<A, I> {\n  /** Type constructor. */\n  new (): HasId & A;\n}\n\nexport type TypedRelationProps = TypeMeta & {\n  // TODO(dmaretskyi): Remove after all legacy types has been removed.\n  disableValidation?: boolean;\n};\n\n/**\n * Base class factory for typed objects.\n * @deprecated Use {@link EchoRelation} instead.\n */\nexport const TypedRelation = ({ typename: _typename, version: _version, disableValidation }: TypedRelationProps) => {\n  const typename = Typename.make(_typename, { disableValidation });\n  const version = Version.make(_version, { disableValidation });\n\n  /**\n   * Return class definition factory.\n   */\n  return <SchemaFields extends Schema.Struct.Fields, Options extends TypedObjectOptions>(\n    fields: SchemaFields,\n    options?: Options,\n  ): TypedRelationPrototype<\n    TypedObjectFields<SchemaFields, Options> & RelationSourceTargetRefs,\n    Schema.Struct.Encoded<SchemaFields>\n  > => {\n    // Create schema from fields.\n    const schema: Schema.Schema.All = options?.record\n      ? Schema.Struct(fields, { key: Schema.String, value: Schema.Any })\n      : Schema.Struct(fields);\n\n    // Set ECHO object id property.\n    const typeSchema = Schema.extend(\n      Schema.mutable(options?.partial ? Schema.partial(schema) : schema),\n      Schema.Struct({ id: Schema.String }),\n    );\n\n    // Set ECHO annotations.\n    invariant(typeof EntityKind.Relation === 'string');\n    const annotatedSchema = typeSchema.annotations({\n      [TypeAnnotationId]: { kind: EntityKind.Relation, typename, version } satisfies TypeAnnotation,\n    });\n\n    /**\n     * Return class definition.\n     * NOTE: Actual reactive ECHO objects must be created via the `live(Type)` function.\n     */\n    // TODO(burdon): This is missing fields required by TypedRelation (e.g., Type, Encoded, Context)?\n    return class TypedRelation extends makeTypedEntityClass(typename, version, annotatedSchema as any) {} as any;\n  };\n};\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { DeletedId } from './model';\nimport type { BaseObject } from '../types';\n\n/**\n * @returns `true` if the object has been marked as deleted.\n */\nexport const isDeleted = (obj: BaseObject): boolean => {\n  if ((obj as any)[DeletedId] === undefined) {\n    throw new Error('Object does not support deletion marker');\n  }\n  return (obj as any)[DeletedId] ?? false;\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { SchemaAST, Schema } from 'effect';\n\nimport { invariant } from '@dxos/invariant';\n\nimport { SchemaId } from './model';\n\n// TODO(burdon): Reconcile with @dxos/effect visit().\n\nexport class SchemaValidator {\n  /**\n   * Recursively check that schema specifies constructions we can handle.\n   * Validates there are no ambiguous discriminated union types.\n   */\n  public static validateSchema(schema: Schema.Schema.AnyNoContext): void {\n    const visitAll = (nodes: SchemaAST.AST[]) => nodes.forEach((node) => this.validateSchema(Schema.make(node)));\n    if (SchemaAST.isUnion(schema.ast)) {\n      const typeAstList = schema.ast.types.filter((type) => SchemaAST.isTypeLiteral(type)) as SchemaAST.TypeLiteral[];\n      // Check we can handle a discriminated union.\n      if (typeAstList.length > 1) {\n        getTypeDiscriminators(typeAstList);\n      }\n      visitAll(typeAstList);\n    } else if (SchemaAST.isTupleType(schema.ast)) {\n      const positionalTypes = schema.ast.elements.map((t) => t.type);\n      const allTypes = positionalTypes.concat(schema.ast.rest.map((t) => t.type));\n      visitAll(allTypes);\n    } else if (SchemaAST.isTypeLiteral(schema.ast)) {\n      visitAll(SchemaAST.getPropertySignatures(schema.ast).map((p) => p.type));\n    }\n  }\n\n  public static hasTypeAnnotation(\n    rootObjectSchema: Schema.Schema.AnyNoContext,\n    property: string,\n    annotation: symbol,\n  ): boolean {\n    try {\n      let type = this.getPropertySchema(rootObjectSchema, [property]);\n      if (SchemaAST.isTupleType(type.ast)) {\n        type = this.getPropertySchema(rootObjectSchema, [property, '0']);\n      }\n\n      return type.ast.annotations[annotation] != null;\n    } catch (err) {\n      return false;\n    }\n  }\n\n  public static getPropertySchema(\n    rootObjectSchema: Schema.Schema.AnyNoContext,\n    propertyPath: KeyPath,\n    getProperty: (path: KeyPath) => any = () => null,\n  ): Schema.Schema.AnyNoContext {\n    let schema: Schema.Schema.AnyNoContext = rootObjectSchema;\n    for (let i = 0; i < propertyPath.length; i++) {\n      const propertyName = propertyPath[i];\n      const tupleAst = unwrapArray(schema.ast);\n      if (tupleAst != null) {\n        schema = getArrayElementSchema(tupleAst, propertyName);\n      } else {\n        const propertyType = getPropertyType(schema.ast, propertyName.toString(), (propertyName) =>\n          getProperty([...propertyPath.slice(0, i), propertyName]),\n        );\n        if (propertyType == null) {\n          throw new TypeError(`unknown property: ${String(propertyName)} on object. Path: ${propertyPath}`);\n        }\n\n        schema = Schema.make(propertyType).annotations(propertyType.annotations);\n      }\n    }\n\n    return schema;\n  }\n\n  public static getTargetPropertySchema(target: any, prop: string | symbol): Schema.Schema.AnyNoContext {\n    const schema: Schema.Schema.AnyNoContext | undefined = (target as any)[SchemaId];\n    invariant(schema, 'target has no schema');\n    const arrayAst = unwrapArray(schema.ast);\n    if (arrayAst != null) {\n      return getArrayElementSchema(arrayAst, prop);\n    }\n\n    const propertyType = getPropertyType(schema.ast, prop.toString(), (prop) => target[prop]);\n    if (propertyType == null) {\n      return Schema.Any; // TODO(burdon): HACK.\n    }\n\n    invariant(propertyType, `invalid property: ${prop.toString()}`);\n    return Schema.make(propertyType);\n  }\n}\n\n/**\n * Tuple AST is used both for:\n * fixed-length tuples ([string, number]) in which case AST will be { elements: [Schema.String, Schema.Number] }\n * variable-length arrays (Array<string | number>) in which case AST will be { rest: [Schema.Union(Schema.String, Schema.Number)] }\n */\nconst getArrayElementSchema = (\n  tupleAst: SchemaAST.TupleType,\n  property: string | symbol | number,\n): Schema.Schema.AnyNoContext => {\n  const elementIndex = typeof property === 'string' ? parseInt(property, 10) : Number.NaN;\n  if (Number.isNaN(elementIndex)) {\n    invariant(property === 'length', `invalid array property: ${String(property)}`);\n    return Schema.Number;\n  }\n  if (elementIndex < tupleAst.elements.length) {\n    const elementType = tupleAst.elements[elementIndex].type;\n    return Schema.make(elementType).annotations(elementType.annotations);\n  }\n\n  const restType = tupleAst.rest;\n  return Schema.make(restType[0].type).annotations(restType[0].annotations);\n};\n\nconst flattenUnion = (typeAst: SchemaAST.AST): SchemaAST.AST[] =>\n  SchemaAST.isUnion(typeAst) ? typeAst.types.flatMap(flattenUnion) : [typeAst];\n\nconst getProperties = (\n  typeAst: SchemaAST.AST,\n  getTargetPropertyFn: (propertyName: string) => any,\n): SchemaAST.PropertySignature[] => {\n  const astCandidates = flattenUnion(typeAst);\n  const typeAstList = astCandidates.filter((type) => SchemaAST.isTypeLiteral(type)) as SchemaAST.TypeLiteral[];\n  if (typeAstList.length === 0) {\n    return [];\n  }\n  if (typeAstList.length === 1) {\n    return SchemaAST.getPropertySignatures(typeAstList[0]);\n  }\n\n  const typeDiscriminators = getTypeDiscriminators(typeAstList);\n  const targetPropertyValue = getTargetPropertyFn(String(typeDiscriminators[0].name));\n  const typeIndex = typeDiscriminators.findIndex((p) => targetPropertyValue === (p.type as SchemaAST.Literal).literal);\n  invariant(typeIndex !== -1, 'discriminator field not set on target');\n  return SchemaAST.getPropertySignatures(typeAstList[typeIndex]);\n};\n\nconst getPropertyType = (\n  ast: SchemaAST.AST,\n  propertyName: string,\n  getTargetPropertyFn: (propertyName: string) => any,\n): SchemaAST.AST | null => {\n  const anyOrObject = unwrapAst(\n    ast,\n    (candidate) => SchemaAST.isAnyKeyword(candidate) || SchemaAST.isObjectKeyword(candidate),\n  );\n  if (anyOrObject != null) {\n    return ast;\n  }\n\n  const typeOrDiscriminatedUnion = unwrapAst(ast, (t) => {\n    return SchemaAST.isTypeLiteral(t) || (SchemaAST.isUnion(t) && t.types.some((t) => SchemaAST.isTypeLiteral(t)));\n  });\n  if (typeOrDiscriminatedUnion == null) {\n    return null;\n  }\n\n  const targetProperty = getProperties(typeOrDiscriminatedUnion, getTargetPropertyFn).find(\n    (p) => p.name === propertyName,\n  );\n  if (targetProperty != null) {\n    return unwrapAst(targetProperty.type);\n  }\n\n  const indexSignatureType = unwrapAst(ast, SchemaAST.isTypeLiteral);\n  if (\n    indexSignatureType &&\n    SchemaAST.isTypeLiteral(indexSignatureType) &&\n    indexSignatureType.indexSignatures.length > 0\n  ) {\n    return unwrapAst(indexSignatureType.indexSignatures[0].type);\n  }\n\n  return null;\n};\n\nconst getTypeDiscriminators = (typeAstList: SchemaAST.TypeLiteral[]): SchemaAST.PropertySignature[] => {\n  const discriminatorPropCandidates = typeAstList\n    .flatMap(SchemaAST.getPropertySignatures)\n    .filter((p) => SchemaAST.isLiteral(p.type));\n  const propertyName = discriminatorPropCandidates[0].name;\n  const isValidDiscriminator = discriminatorPropCandidates.every((p) => p.name === propertyName && !p.isOptional);\n  const everyTypeHasDiscriminator = discriminatorPropCandidates.length === typeAstList.length;\n  const isDiscriminatedUnion = isValidDiscriminator && everyTypeHasDiscriminator;\n  invariant(isDiscriminatedUnion, 'type ambiguity: every type in a union must have a single unique-literal field');\n  return discriminatorPropCandidates;\n};\n\n/**\n * Used to check that rootAst is for a type matching the provided predicate.\n * That's not always straightforward because types of optionality and recursive types.\n * const Task = Schema.Struct({\n *   ...,\n *   previous?: Schema.optional(Schema.suspend(() => Task)),\n * });\n * Here the AST for `previous` field is going to be Union(Suspend(Type), Undefined).\n * SchemaAST.isTypeLiteral(field) will return false, but unwrapAst(field, (ast) => SchemaAST.isTypeLiteral(ast))\n * will return true.\n */\nconst unwrapAst = (rootAst: SchemaAST.AST, predicate?: (ast: SchemaAST.AST) => boolean): SchemaAST.AST | null => {\n  let ast: SchemaAST.AST | undefined = rootAst;\n  while (ast != null) {\n    if (predicate?.(ast)) {\n      return ast;\n    }\n\n    if (SchemaAST.isUnion(ast)) {\n      const next: any = ast.types.find((t) => (predicate != null && predicate(t)) || SchemaAST.isSuspend(t));\n      if (next != null) {\n        ast = next;\n        continue;\n      }\n    }\n\n    if (SchemaAST.isSuspend(ast)) {\n      ast = ast.f();\n    } else {\n      return predicate == null ? ast : null;\n    }\n  }\n\n  return null;\n};\n\nconst unwrapArray = (ast: SchemaAST.AST) => unwrapAst(ast, SchemaAST.isTupleType) as SchemaAST.TupleType | null;\n\nexport const checkIdNotPresentOnSchema = (schema: Schema.Schema<any, any, any>) => {\n  invariant(SchemaAST.isTypeLiteral(schema.ast));\n  const idProperty = SchemaAST.getPropertySignatures(schema.ast).find((prop) => prop.name === 'id');\n  if (idProperty != null) {\n    throw new Error('\"id\" property name is reserved');\n  }\n};\n\ntype KeyPath = readonly (string | number)[];\n"],
  "mappings": "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",
  "names": ["import_effect", "import_invariant", "import_keys", "import_util", "import_echo_protocol", "import_debug", "createAnnotationHelper", "id", "get", "schema", "SchemaAST", "getAnnotation", "set", "value", "annotations", "EntityKind", "EntityKindSchema", "Schema", "Enums", "TypeIdentifierAnnotationId", "Symbol", "for", "getTypeIdentifierAnnotation", "flow", "Option", "getOrElse", "undefined", "ast", "TypeAnnotationId", "Typename", "String", "pipe", "pattern", "Version", "TypeAnnotation", "Struct", "kind", "typename", "version", "sourceSchema", "optional", "DXN", "targetSchema", "getTypeAnnotation", "assertArgument", "getEntityKind", "getSchemaTypename", "getSchemaVersion", "PropertyMetaAnnotationId", "PropertyMeta", "name", "self", "existingMeta", "getPropertyMetaAnnotation", "prop", "type", "map", "meta", "ReferenceAnnotationId", "getReferenceAnnotation", "SchemaMetaSymbol", "LabelAnnotationId", "LabelAnnotation", "FieldLookupAnnotationId", "GeneratorAnnotationId", "GeneratorAnnotation", "getSchemaDXN", "isSchema", "parse", "objectAnnotation", "fromTypenameAndVersion", "FIELD_PATH_ANNOTATION", "FieldPath", "path", "EntityKindId", "SelfDXNId", "ATTR_SELF_DXN", "TypeId", "ATTR_TYPE", "SchemaId", "DeletedId", "ATTR_DELETED", "MetaId", "ATTR_META", "RelationSourceDXNId", "ATTR_RELATION_SOURCE", "RelationTargetDXNId", "ATTR_RELATION_TARGET", "RelationSourceId", "RelationTargetId", "assertObjectModelShape", "obj", "invariant", "assumeType", "ObjectId", "isValid", "Object", "Relation", "getObjectDXN", "object", "TypeError", "fromLocalObjectId", "getSchema", "setSchema", "defineProperty", "writable", "enumerable", "configurable", "getLabelForObject", "getLabel", "annotation", "Array", "isArray", "accessor", "getField", "toString", "getTypename", "getType", "asTypeDXN", "setTypename", "makeTypedEntityClass", "baseSchema", "_a", "schemaVariance", "bind", "hasInstance", "Error", "_A", "_", "_I", "_R", "ObjectMetaSchema", "keys", "mutable", "ForeignKey", "foreignKey", "source", "foreignKeyEquals", "a", "b", "getObjectMeta", "getMeta", "metadata", "compareForeignKeys", "intersection", "length", "JSON_SCHEMA_ECHO_REF_ID", "getSchemaReference", "property", "$id", "reference", "$ref", "createSchemaReference", "fromTypename", "RefTypeId", "Ref", "createEchoReferenceSchema", "getSchemaExpectedName", "isRef", "hasObjectId", "ref", "dxn", "isLocalObjectId", "parts", "isRefSchema", "isRefSchemaAST", "isSome", "make", "Reference", "localObjectReference", "toDXN", "RefImpl", "fromDXN", "echoId", "schemaName", "referenceInfo", "schemaVersion", "refSchema", "declare", "encode", "Effect", "succeed", "decode", "fail", "ParseResult", "Unexpected", "jsonSchema", "getIdentifierAnnotation", "orElse", "getTitleAnnotation", "getDescriptionAnnotation", "target", "compositeRuntime", "createSignal", "notifyWrite", "refVariance", "notifyRead", "resolveSync", "load", "resolve", "tryLoad", "noInline", "toJSON", "_setResolver", "resolver", "_getSavedTarget", "setRefResolver", "getRefSavedTarget", "_T", "refFromEncodedReference", "encodedReference", "StaticRefResolver", "objects", "Map", "schemas", "addObject", "addSchema", "_load", "_onLoad", "asEchoDXN", "resolveSchema", "RefArray", "freeze", "targets", "refs", "filter", "isNonNullable", "loadAll", "Promise", "all", "removeById", "index", "findIndex", "splice", "defineHiddenProperty", "key", "objectToJSON", "typedJsonSerializer", "call", "objectFromJSON", "jsonData", "refResolver", "decodeUnknownPromise", "setRefResolverOnData", "decodeGeneric", "isRelation", "sourceDxn", "raise", "targetDxn", "options", "_type", "_meta", "_deleted", "_relationSource", "_relationTarget", "_selfDxn", "props", "deepMapValues", "recurse", "isEncodedReference", "go", "visitValues", "attachTypedJsonSerializer", "descriptor", "getOwnPropertyDescriptor", "rest", "result", "sourceDXN", "targetDXN", "serializeData", "assign", "data", "attachedTypedObjectInspector", "inspectCustom", "typedObjectInspectFunction", "depth", "inspect", "create", "random", "failedInvariant", "EchoObject", "isTypeLiteral", "schemaWithId", "extend", "makeEchoObjectSchema", "getDXNForRelationSchemaRef", "identifier", "EchoRelation", "EchoObjectSchemaClass", "instanceOf", "is", "EXPANDO_TYPENAME", "ExpandoSchema", "Any", "Expando", "createQueueDXN", "spaceId", "SpaceId", "queueId", "QUEUE", "QueueSubspaceTags", "DATA", "TypedObject", "_typename", "_version", "disableValidation", "fields", "record", "typeSchema", "partial", "annotatedSchema", "TypedRelation", "isDeleted", "SchemaValidator", "validateSchema", "visitAll", "nodes", "forEach", "node", "isUnion", "typeAstList", "types", "getTypeDiscriminators", "isTupleType", "positionalTypes", "elements", "t", "allTypes", "concat", "getPropertySignatures", "p", "hasTypeAnnotation", "rootObjectSchema", "getPropertySchema", "err", "propertyPath", "getProperty", "i", "propertyName", "tupleAst", "unwrapArray", "getArrayElementSchema", "propertyType", "getPropertyType", "slice", "getTargetPropertySchema", "arrayAst", "elementIndex", "parseInt", "Number", "NaN", "isNaN", "elementType", "restType", "flattenUnion", "typeAst", "flatMap", "getProperties", "getTargetPropertyFn", "astCandidates", "typeDiscriminators", "targetPropertyValue", "typeIndex", "literal", "anyOrObject", "unwrapAst", "candidate", "isAnyKeyword", "isObjectKeyword", "typeOrDiscriminatedUnion", "some", "targetProperty", "find", "indexSignatureType", "indexSignatures", "discriminatorPropCandidates", "isLiteral", "isValidDiscriminator", "every", "isOptional", "everyTypeHasDiscriminator", "isDiscriminatedUnion", "rootAst", "predicate", "next", "isSuspend", "f", "checkIdNotPresentOnSchema", "idProperty"]
}
