"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var testing_exports = {};
__export(testing_exports, {
  Testing: () => Testing,
  prepareAstForCompare: () => prepareAstForCompare,
  updateCounter: () => updateCounter
});
module.exports = __toCommonJS(testing_exports);
var import_chunk_BRS5374V = require("../chunk-BRS5374V.cjs");
var import_effect = require("effect");
var import_signals_core = require("@preact/signals-core");
var import_echo_signals = require("@dxos/echo-signals");
var import_util = require("@dxos/util");
(function(Testing2) {
  const Circle = import_effect.Schema.Struct({
    type: import_effect.Schema.Literal("circle"),
    radius: import_effect.Schema.Number
  });
  const Square = import_effect.Schema.Struct({
    type: import_effect.Schema.Literal("square"),
    side: import_effect.Schema.Number
  });
  const Shape = import_effect.Schema.Union(Circle, Square);
  const TestNestedSchema = import_effect.Schema.mutable(import_effect.Schema.Struct({
    field: import_effect.Schema.String
  }));
  Testing2.TestNestedType = TestNestedSchema.pipe((0, import_chunk_BRS5374V.EchoObject)({
    typename: "example.com/type/TestNested",
    version: "0.1.0"
  }));
  class EmptySchemaType extends (0, import_chunk_BRS5374V.TypedObject)({
    typename: "example.com/type/Empty",
    version: "0.1.0"
  })({}) {
  }
  Testing2.EmptySchemaType = EmptySchemaType;
  const fields = {
    string: import_effect.Schema.String,
    number: import_effect.Schema.Number,
    nullableShapeArray: import_effect.Schema.mutable(import_effect.Schema.Array(import_effect.Schema.Union(Shape, import_effect.Schema.Null))),
    boolean: import_effect.Schema.Boolean,
    null: import_effect.Schema.Null,
    undefined: import_effect.Schema.Undefined,
    stringArray: import_effect.Schema.mutable(import_effect.Schema.Array(import_effect.Schema.String)),
    twoDimNumberArray: import_effect.Schema.mutable(import_effect.Schema.Array(import_effect.Schema.mutable(import_effect.Schema.Array(import_effect.Schema.Number)))),
    object: TestNestedSchema,
    objectArray: import_effect.Schema.mutable(import_effect.Schema.Array(TestNestedSchema)),
    nested: import_effect.Schema.optional((0, import_chunk_BRS5374V.Ref)(Testing2.TestNestedType)),
    other: import_effect.Schema.Any
  };
  Testing2.TestSchema = import_effect.Schema.mutable(import_effect.Schema.partial(import_effect.Schema.Struct(fields)));
  class TestSchemaType extends (0, import_chunk_BRS5374V.TypedObject)({
    typename: "example.com/type/Test",
    version: "0.1.0"
  })(fields, {
    partial: true
  }) {
  }
  Testing2.TestSchemaType = TestSchemaType;
  Testing2.TestType = Testing2.TestSchema.pipe((0, import_chunk_BRS5374V.EchoObject)({
    typename: "example.com/type/Test",
    version: "0.1.0"
  }));
  class TestClass {
    constructor() {
      this.field = "value";
    }
    toJSON() {
      return {
        field: this.field
      };
    }
  }
  Testing2.TestClass = TestClass;
  Testing2.TestSchemaWithClass = import_effect.Schema.mutable(import_effect.Schema.extend(Testing2.TestSchema, import_effect.Schema.mutable(import_effect.Schema.Struct({
    classInstance: import_effect.Schema.optional(import_effect.Schema.instanceOf(TestClass))
  }))));
  class Contact extends (0, import_chunk_BRS5374V.TypedObject)({
    typename: "example.com/type/Contact",
    version: "0.1.0"
  })({
    name: import_effect.Schema.String,
    username: import_effect.Schema.String,
    email: import_effect.Schema.String,
    tasks: import_effect.Schema.suspend(() => import_effect.Schema.mutable(import_effect.Schema.Array((0, import_chunk_BRS5374V.Ref)(Task)))),
    address: import_effect.Schema.Struct({
      city: import_effect.Schema.optional(import_effect.Schema.String),
      state: import_effect.Schema.optional(import_effect.Schema.String),
      zip: import_effect.Schema.optional(import_effect.Schema.String),
      coordinates: import_effect.Schema.Struct({
        lat: import_effect.Schema.optional(import_effect.Schema.Number),
        lng: import_effect.Schema.optional(import_effect.Schema.Number)
      })
    })
  }, {
    partial: true
  }) {
  }
  Testing2.Contact = Contact;
  class Task extends (0, import_chunk_BRS5374V.TypedObject)({
    typename: "example.com/type/Task",
    version: "0.1.0"
  })({
    title: import_effect.Schema.optional(import_effect.Schema.String),
    completed: import_effect.Schema.optional(import_effect.Schema.Boolean),
    assignee: import_effect.Schema.optional((0, import_chunk_BRS5374V.Ref)(Contact)),
    previous: import_effect.Schema.optional(import_effect.Schema.suspend(() => (0, import_chunk_BRS5374V.Ref)(Task))),
    subTasks: import_effect.Schema.optional(import_effect.Schema.mutable(import_effect.Schema.Array(import_effect.Schema.suspend(() => (0, import_chunk_BRS5374V.Ref)(Task))))),
    description: import_effect.Schema.optional(import_effect.Schema.String)
  }, {
    partial: true
  }) {
  }
  Testing2.Task = Task;
  (function(RecordType) {
    RecordType[RecordType["UNDEFINED"] = 0] = "UNDEFINED";
    RecordType[RecordType["PERSONAL"] = 1] = "PERSONAL";
    RecordType[RecordType["WORK"] = 2] = "WORK";
  })(Testing2.RecordType || (Testing2.RecordType = {}));
  class Container extends (0, import_chunk_BRS5374V.TypedObject)({
    typename: "example.com/type/Container",
    version: "0.1.0"
  })({
    objects: import_effect.Schema.mutable(import_effect.Schema.Array((0, import_chunk_BRS5374V.Ref)(import_chunk_BRS5374V.Expando))),
    records: import_effect.Schema.mutable(import_effect.Schema.Array(import_effect.Schema.partial(import_effect.Schema.Struct({
      title: import_effect.Schema.String,
      description: import_effect.Schema.String,
      contacts: import_effect.Schema.mutable(import_effect.Schema.Array((0, import_chunk_BRS5374V.Ref)(Contact))),
      type: import_effect.Schema.Enums(Testing2.RecordType)
    }))))
  }, {
    partial: true
  }) {
  }
  Testing2.Container = Container;
  Testing2.HasManager = import_effect.Schema.Struct({
    since: import_effect.Schema.optional(import_effect.Schema.String)
  }).pipe((0, import_chunk_BRS5374V.EchoRelation)({
    typename: "example.com/type/HasManager",
    version: "0.1.0",
    source: Contact,
    target: Contact
  }));
})(Testing || (Testing = {}));
var Testing;
(0, import_echo_signals.registerSignalsRuntime)();
var updateCounter = (touch) => {
  let updateCount = -1;
  const unsubscribe = (0, import_signals_core.effect)(() => {
    touch();
    updateCount++;
  });
  return {
    // https://github.com/tc39/proposal-explicit-resource-management
    [Symbol.dispose]: unsubscribe,
    get count() {
      return updateCount;
    }
  };
};
var prepareAstForCompare = (obj) => (0, import_util.deepMapValues)(obj, (value, recurse, key) => {
  if (typeof value === "function") {
    return null;
  }
  if (value instanceof RegExp) {
    return value;
  }
  if (typeof value === "object") {
    const clone = {
      ...value
    };
    for (const sym of Object.getOwnPropertySymbols(clone)) {
      clone[sym.toString()] = clone[sym];
      delete clone[sym];
    }
    return recurse(clone);
  }
  return recurse(value);
});
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Testing,
  prepareAstForCompare,
  updateCounter
});
//# sourceMappingURL=index.cjs.map
