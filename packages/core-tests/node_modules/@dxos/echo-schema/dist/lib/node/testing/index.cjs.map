{
  "version": 3,
  "sources": ["../../../../src/testing/types.ts", "../../../../src/testing/utils.ts"],
  "sourcesContent": ["//\n// Copyright 2024 DXOS.org\n//\n\nimport { Schema } from 'effect';\n\nimport { EchoObject, EchoRelation, Expando, TypedObject } from '../object';\nimport { Ref, type Ref$ } from '../ref';\n\n// TODO(burdon): These are non-canonical test types, so we really shouldn't export and use in other classes (compare with @dxos/sdk/testing).\nexport namespace Testing {\n  //\n  // Primitives\n  //\n\n  const Circle = Schema.Struct({ type: Schema.Literal('circle'), radius: Schema.Number });\n  const Square = Schema.Struct({ type: Schema.Literal('square'), side: Schema.Number });\n  const Shape = Schema.Union(Circle, Square);\n\n  //\n  // Simple types\n  //\n\n  const TestNestedSchema = Schema.mutable(Schema.Struct({ field: Schema.String }));\n  export type TestNestedSchema = Schema.Schema.Type<typeof TestNestedSchema>;\n  export const TestNestedType = TestNestedSchema.pipe(\n    EchoObject({ typename: 'example.com/type/TestNested', version: '0.1.0' }),\n  );\n\n  //\n  // Complex types\n  // TODO(burdon): Change to Type.Obj.\n  //\n\n  export class EmptySchemaType extends TypedObject({\n    typename: 'example.com/type/Empty',\n    version: '0.1.0',\n  })({}) {}\n\n  const fields = {\n    string: Schema.String,\n    number: Schema.Number,\n    nullableShapeArray: Schema.mutable(Schema.Array(Schema.Union(Shape, Schema.Null))),\n    boolean: Schema.Boolean,\n    null: Schema.Null,\n    undefined: Schema.Undefined,\n    stringArray: Schema.mutable(Schema.Array(Schema.String)),\n    twoDimNumberArray: Schema.mutable(Schema.Array(Schema.mutable(Schema.Array(Schema.Number)))),\n    object: TestNestedSchema,\n    objectArray: Schema.mutable(Schema.Array(TestNestedSchema)),\n    nested: Schema.optional(Ref(TestNestedType)),\n    other: Schema.Any,\n  };\n\n  export const TestSchema = Schema.mutable(Schema.partial(Schema.Struct(fields)));\n  export type TestSchema = Schema.Schema.Type<typeof TestSchema>;\n\n  export class TestSchemaType extends TypedObject({\n    typename: 'example.com/type/Test',\n    version: '0.1.0',\n  })(fields, { partial: true }) {} // TODO(burdon): Partial?\n\n  // TODO(burdon): Why do we use need this rather then TestSchemaType?\n  export const TestType = TestSchema.pipe(\n    EchoObject({\n      typename: 'example.com/type/Test',\n      version: '0.1.0',\n    }),\n  );\n\n  export class TestClass {\n    field = 'value';\n    toJSON() {\n      return { field: this.field };\n    }\n  }\n\n  // TODO(dmaretskyi): Another top-level Schema.mutable call as a workaround for the regression in the last minor.\n  export const TestSchemaWithClass = Schema.mutable(\n    Schema.extend(\n      TestSchema,\n      Schema.mutable(\n        Schema.Struct({\n          classInstance: Schema.optional(Schema.instanceOf(TestClass)),\n        }),\n      ),\n    ),\n  );\n\n  export type TestSchemaWithClass = Schema.Schema.Type<typeof TestSchemaWithClass>;\n\n  export class Contact extends TypedObject({\n    typename: 'example.com/type/Contact',\n    version: '0.1.0',\n  })(\n    {\n      name: Schema.String,\n      username: Schema.String,\n      email: Schema.String,\n      tasks: Schema.suspend((): Schema.mutable<Schema.Array$<Ref$<Task>>> => Schema.mutable(Schema.Array(Ref(Task)))),\n      address: Schema.Struct({\n        city: Schema.optional(Schema.String),\n        state: Schema.optional(Schema.String),\n        zip: Schema.optional(Schema.String),\n        coordinates: Schema.Struct({\n          lat: Schema.optional(Schema.Number),\n          lng: Schema.optional(Schema.Number),\n        }),\n      }),\n    },\n    { partial: true },\n  ) {}\n\n  export class Task extends TypedObject({\n    typename: 'example.com/type/Task',\n    version: '0.1.0',\n  })(\n    {\n      title: Schema.optional(Schema.String),\n      completed: Schema.optional(Schema.Boolean),\n      assignee: Schema.optional(Ref(Contact)),\n      previous: Schema.optional(Schema.suspend((): Ref$<Task> => Ref(Task))),\n      subTasks: Schema.optional(Schema.mutable(Schema.Array(Schema.suspend((): Ref$<Task> => Ref(Task))))),\n      description: Schema.optional(Schema.String),\n    },\n    { partial: true },\n  ) {}\n\n  // TOOD(burdon): Ref$ breaks if using new syntax (since ID is not declared).\n\n  // export const Task = Schema.Struct({\n  //   title: Schema.String,\n  //   completed: Schema.Boolean,\n  //   assignee: Schema.optional(Ref(Schema.suspend((): Ref$<Contact> => Ref(Contact)))),\n  //   previous: Schema.optional(Ref(Schema.suspend((): Ref$<Task> => Ref(Task)))),\n  //   subTasks: Schema.optional(Schema.Array(Ref(Schema.suspend((): Ref$<Task> => Ref(Task))))),\n  //   description: Schema.optional(Schema.String),\n  // }).pipe(\n  //   EchoObject({\n  //     typename: 'example.com/type/Task',\n  //     version: '0.1.0',\n  //   }),\n  // );\n\n  // export type Task = Schema.Schema.Type<typeof Task>;\n\n  // export const Contact = Schema.Struct({\n  //   name: Schema.String,\n  //   username: Schema.String,\n  //   email: Schema.String,\n  //   // TOOD(burdon): Should model via relations?\n  //   // tasks: Schema.mutable(Schema.Array(Ref(Task))),\n  //   address: Schema.Struct({\n  //     city: Schema.optional(Schema.String),\n  //     state: Schema.optional(Schema.String),\n  //     zip: Schema.optional(Schema.String),\n  //     coordinates: Schema.Struct({\n  //       lat: Schema.optional(Schema.Number),\n  //       lng: Schema.optional(Schema.Number),\n  //     }),\n  //   }),\n  // }).pipe(\n  //   EchoObject({\n  //     typename: 'example.com/type/Contact',\n  //     version: '0.1.0',\n  //   }),\n  // );\n\n  // export type Contact = Schema.Schema.Type<typeof Contact>;\n\n  export enum RecordType {\n    UNDEFINED = 0,\n    PERSONAL = 1,\n    WORK = 2,\n  }\n\n  export class Container extends TypedObject({\n    typename: 'example.com/type/Container',\n    version: '0.1.0',\n  })(\n    {\n      objects: Schema.mutable(Schema.Array(Ref(Expando))),\n      records: Schema.mutable(\n        Schema.Array(\n          Schema.partial(\n            Schema.Struct({\n              title: Schema.String,\n              description: Schema.String,\n              contacts: Schema.mutable(Schema.Array(Ref(Contact))),\n              type: Schema.Enums(RecordType),\n            }),\n          ),\n        ),\n      ),\n    },\n    { partial: true },\n  ) {}\n\n  export const HasManager = Schema.Struct({\n    since: Schema.optional(Schema.String),\n  }).pipe(\n    EchoRelation({\n      typename: 'example.com/type/HasManager',\n      version: '0.1.0',\n      source: Contact,\n      target: Contact,\n    }),\n  );\n  export interface HasManager extends Schema.Schema.Type<typeof HasManager> {}\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { effect } from '@preact/signals-core';\nimport { type SchemaAST } from 'effect';\n\nimport { registerSignalsRuntime } from '@dxos/echo-signals';\nimport { deepMapValues } from '@dxos/util';\n\nregisterSignalsRuntime();\n\n// TODO(burdon): Move to util.\nexport const updateCounter = (touch: () => void) => {\n  let updateCount = -1;\n  const unsubscribe = effect(() => {\n    touch();\n    updateCount++;\n  });\n\n  return {\n    // https://github.com/tc39/proposal-explicit-resource-management\n    [Symbol.dispose]: unsubscribe,\n    get count() {\n      return updateCount;\n    },\n  };\n};\n\n/**\n * Converts AST to a format that can be compared with test matchers.\n */\nexport const prepareAstForCompare = (obj: SchemaAST.AST): any =>\n  deepMapValues(obj, (value: any, recurse, key) => {\n    if (typeof value === 'function') {\n      return null;\n    }\n\n    if (value instanceof RegExp) {\n      return value;\n    }\n\n    // Convert symbols to strings.\n    if (typeof value === 'object') {\n      const clone = { ...value };\n      for (const sym of Object.getOwnPropertySymbols(clone as any)) {\n        clone[sym.toString()] = clone[sym];\n        delete clone[sym];\n      }\n      return recurse(clone);\n    }\n\n    return recurse(value);\n  });\n"],
  "mappings": "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",
  "names": ["Testing", "Circle", "Schema", "Struct", "type", "Literal", "radius", "Number", "Square", "side", "Shape", "Union", "TestNestedSchema", "mutable", "field", "String", "TestNestedType", "pipe", "EchoObject", "typename", "version", "EmptySchemaType", "TypedObject", "fields", "string", "number", "nullableShapeArray", "Array", "Null", "boolean", "Boolean", "null", "undefined", "Undefined", "stringArray", "twoDimNumberArray", "object", "objectArray", "nested", "optional", "Ref", "other", "Any", "TestSchema", "partial", "TestSchemaType", "TestType", "TestClass", "toJSON", "TestSchemaWithClass", "extend", "classInstance", "instanceOf", "Contact", "name", "username", "email", "tasks", "suspend", "Task", "address", "city", "state", "zip", "coordinates", "lat", "lng", "title", "completed", "assignee", "previous", "subTasks", "description", "RecordType", "Container", "objects", "Expando", "records", "contacts", "Enums", "HasManager", "since", "EchoRelation", "source", "target", "registerSignalsRuntime", "updateCounter", "touch", "updateCount", "unsubscribe", "effect", "Symbol", "dispose", "count", "prepareAstForCompare", "obj", "deepMapValues", "value", "recurse", "key", "RegExp", "clone", "sym", "Object", "getOwnPropertySymbols", "toString"]
}
