{
  "version": 3,
  "sources": ["../../../src/document-structure.ts", "../../../src/reference.ts", "../../../src/space-doc-version.ts", "../../../src/space-id.ts", "../../../src/foreign-key.ts", "../../../src/query/ast.ts"],
  "sourcesContent": ["//\n// Copyright 2024 DXOS.org\n//\n\nimport { invariant } from '@dxos/invariant';\nimport type { DXN, ObjectId } from '@dxos/keys';\nimport { visitValues } from '@dxos/util';\n\nimport { type RawString } from './automerge';\nimport type { ForeignKey } from './foreign-key';\nimport { isEncodedReference, type EncodedReference } from './reference';\nimport { type SpaceDocVersion } from './space-doc-version';\n\nexport type SpaceState = {\n  // Url of the root automerge document.\n  rootUrl?: string;\n};\n\n/**\n * Array indexes get converted to strings.\n */\nexport type ObjectProp = string;\nexport type ObjectPropPath = ObjectProp[];\n\n/**\n * Link to all documents that hold objects in the space.\n */\nexport interface DatabaseDirectory {\n  version?: SpaceDocVersion;\n\n  access?: {\n    spaceKey: string;\n  };\n  /**\n   * Objects inlined in the current document.\n   */\n  objects?: {\n    [id: string]: ObjectStructure;\n  };\n  /**\n   * Object id points to an automerge doc url where the object is embedded.\n   */\n  links?: {\n    [echoId: string]: string | RawString;\n  };\n\n  /**\n   * @deprecated\n   * For backward compatibility.\n   */\n  experimental_spaceKey?: string;\n}\n\nexport const DatabaseDirectory = Object.freeze({\n  /**\n   * @returns Space key in hex of the space that owns the document. In hex format. Without 0x prefix.\n   */\n  getSpaceKey: (doc: DatabaseDirectory): string | null => {\n    // experimental_spaceKey is set on old documents, new ones are created with doc.access.spaceKey\n    const rawSpaceKey = doc.access?.spaceKey ?? doc.experimental_spaceKey;\n    if (rawSpaceKey == null) {\n      return null;\n    }\n\n    const rawKey = String(rawSpaceKey);\n    invariant(!rawKey.startsWith('0x'), 'Space key must not start with 0x');\n    return rawKey;\n  },\n\n  getInlineObject: (doc: DatabaseDirectory, id: ObjectId): ObjectStructure | undefined => {\n    return doc.objects?.[id];\n  },\n\n  getLink: (doc: DatabaseDirectory, id: ObjectId): string | undefined => {\n    return doc.links?.[id]?.toString();\n  },\n\n  make: ({\n    spaceKey,\n    objects,\n    links,\n  }: {\n    spaceKey: string;\n    objects?: Record<string, ObjectStructure>;\n    links?: Record<string, RawString>;\n  }): DatabaseDirectory => ({\n    access: {\n      spaceKey,\n    },\n    objects: objects ?? {},\n    links: links ?? {},\n  }),\n});\n\n/**\n * Representation of an ECHO object in an AM document.\n */\nexport type ObjectStructure = {\n  // TODO(dmaretskyi): Missing in some cases.\n  system?: ObjectSystem;\n\n  meta: ObjectMeta;\n  /**\n   * User-defined data.\n   * Adheres to schema in `system.type`\n   */\n  data: Record<string, any>;\n};\n\n// Helper methods to interact with the {@link ObjectStructure}.\nexport const ObjectStructure = Object.freeze({\n  /**\n   * @throws On invalid object structure.\n   */\n  getTypeReference: (object: ObjectStructure): EncodedReference | undefined => {\n    return object.system?.type;\n  },\n\n  /**\n   * @throws On invalid object structure.\n   */\n  getEntityKind: (object: ObjectStructure): 'object' | 'relation' => {\n    const kind = object.system?.kind ?? 'object';\n    invariant(kind === 'object' || kind === 'relation', 'Invalid kind');\n    return kind;\n  },\n\n  isDeleted: (object: ObjectStructure): boolean => {\n    return object.system?.deleted ?? false;\n  },\n\n  getRelationSource: (object: ObjectStructure): EncodedReference | undefined => {\n    return object.system?.source;\n  },\n\n  getRelationTarget: (object: ObjectStructure): EncodedReference | undefined => {\n    return object.system?.target;\n  },\n\n  /**\n   * @returns All references in the data section of the object.\n   */\n  getAllOutgoingReferences: (object: ObjectStructure): { path: ObjectPropPath; reference: EncodedReference }[] => {\n    const references: { path: ObjectPropPath; reference: EncodedReference }[] = [];\n    const visit = (path: ObjectPropPath, value: unknown) => {\n      if (isEncodedReference(value)) {\n        references.push({ path, reference: value });\n      } else {\n        visitValues(value, (value, key) => visit([...path, String(key)], value));\n      }\n    };\n    visitValues(object.data, (value, key) => visit([String(key)], value));\n    return references;\n  },\n\n  makeObject: ({\n    type,\n    data,\n    keys,\n  }: {\n    type: DXN.String;\n    deleted?: boolean;\n    keys?: ForeignKey[];\n    data?: unknown;\n  }): ObjectStructure => {\n    return {\n      system: {\n        kind: 'object',\n        type: { '/': type },\n      },\n      meta: {\n        keys: keys ?? [],\n      },\n      data: data ?? {},\n    };\n  },\n\n  makeRelation: ({\n    type,\n    source,\n    target,\n    deleted,\n    keys,\n    data,\n  }: {\n    type: DXN.String;\n    source: EncodedReference;\n    target: EncodedReference;\n    deleted?: boolean;\n    keys?: ForeignKey[];\n    data?: unknown;\n  }): ObjectStructure => {\n    return {\n      system: {\n        kind: 'relation',\n        type: { '/': type },\n        source,\n        target,\n        deleted: deleted ?? false,\n      },\n      meta: {\n        keys: keys ?? [],\n      },\n      data: data ?? {},\n    };\n  },\n});\n\n/**\n * Echo object metadata.\n */\nexport type ObjectMeta = {\n  /**\n   * Foreign keys.\n   */\n  keys: ForeignKey[];\n};\n\n/**\n * Automerge object system properties.\n * (Is automerge specific.)\n */\nexport type ObjectSystem = {\n  /**\n   * Entity kind.\n   */\n  kind?: 'object' | 'relation';\n\n  /**\n   * Object reference ('protobuf' protocol) type.\n   */\n  type?: EncodedReference;\n\n  /**\n   * Deletion marker.\n   */\n  deleted?: boolean;\n\n  /**\n   * Only for relations.\n   */\n  source?: EncodedReference;\n\n  /**\n   * Only for relations.w\n   */\n  target?: EncodedReference;\n};\n\n/**\n * Id property name.\n */\nexport const PROPERTY_ID = 'id';\n\n/**\n * Data namespace.\n * The key on {@link ObjectStructure} that contains the user-defined data.\n */\nexport const DATA_NAMESPACE = 'data';\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { DXN, LOCAL_SPACE_TAG, type PublicKey } from '@dxos/keys';\nimport { type ObjectId } from '@dxos/protocols';\nimport { type Reference as ReferenceProto } from '@dxos/protocols/proto/dxos/echo/model/document';\n\n/**\n * Runtime representation of an reference in ECHO.\n * Implemented as a DXN, but we might extend it to other URIs in the future.\n */\nexport class Reference {\n  /**\n   * Protocol references to runtime registered types.\n   * @deprecated\n   */\n  static TYPE_PROTOCOL = 'protobuf';\n\n  static fromDXN(dxn: DXN): Reference {\n    switch (dxn.kind) {\n      case DXN.kind.TYPE:\n        return new Reference(dxn.parts[0], Reference.TYPE_PROTOCOL, 'dxos.org', dxn);\n      case DXN.kind.ECHO:\n        if (dxn.parts[0] === LOCAL_SPACE_TAG) {\n          return new Reference(dxn.parts[1], undefined, undefined, dxn);\n        } else {\n          return new Reference(dxn.parts[1], undefined, dxn.parts[0], dxn);\n        }\n      default:\n        return new Reference(dxn.parts[0], undefined, dxn.parts[0], dxn);\n    }\n  }\n\n  static fromValue(value: ReferenceProto): Reference {\n    return new Reference(value.objectId, value.protocol, value.host);\n  }\n\n  /**\n   * Reference an object in the local space.\n   */\n  static localObjectReference(objectId: ObjectId): Reference {\n    return new Reference(objectId);\n  }\n\n  /**\n   * @deprecated\n   */\n  // TODO(dmaretskyi): Remove.\n  static fromLegacyTypename(type: string): Reference {\n    return new Reference(type, Reference.TYPE_PROTOCOL, 'dxos.org');\n  }\n\n  /**\n   * @deprecated\n   */\n  // TODO(dmaretskyi): Remove\n  static fromObjectIdAndSpaceKey(objectId: ObjectId, spaceKey: PublicKey): Reference {\n    // TODO(dmaretskyi): FIX ME! This should be a space ID not a space key.\n    return new Reference(objectId, undefined, spaceKey.toHex());\n  }\n\n  // prettier-ignore\n  private constructor(\n    // TODO(dmaretskyi): Remove and just leave DXN.\n    private readonly _objectId: ObjectId,\n    private readonly _protocol?: string,\n    private readonly _host?: string,\n    private readonly _dxn?: DXN,\n  ) {}\n\n  get dxn(): DXN | undefined {\n    return this._dxn;\n  }\n\n  /**\n   * @deprecated\n   */\n  // TODO(dmaretskyi): Remove.\n  get objectId(): ObjectId {\n    return this._objectId;\n  }\n\n  /**\n   * @deprecated\n   */\n  // TODO(dmaretskyi): Remove.\n  get protocol(): string | undefined {\n    return this._protocol;\n  }\n\n  /**\n   * @deprecated\n   */\n  // TODO(dmaretskyi): Remove.\n  get host(): string | undefined {\n    return this._host;\n  }\n\n  encode(): ReferenceProto {\n    return { objectId: this.objectId, host: this.host, protocol: this.protocol };\n  }\n\n  // TODO(dmaretskyi): Remove in favor of `reference.dxn`.\n  toDXN(): DXN {\n    if (this._dxn) {\n      return this._dxn;\n    }\n\n    if (this.protocol === Reference.TYPE_PROTOCOL) {\n      return new DXN(DXN.kind.TYPE, [this.objectId]);\n    } else {\n      if (this.host) {\n        // Host is assumed to be the space key.\n        // The DXN should actually have the space ID.\n        // TODO(dmaretskyi): Migrate to space id.\n        return new DXN(DXN.kind.ECHO, [this.host, this.objectId]);\n      } else {\n        return new DXN(DXN.kind.ECHO, [LOCAL_SPACE_TAG, this.objectId]);\n      }\n    }\n  }\n}\n\nexport const REFERENCE_TYPE_TAG = 'dxos.echo.model.document.Reference';\n\n/**\n * Reference as it is stored in Automerge document.\n */\nexport type EncodedReference = {\n  '/': string;\n};\n\nexport const encodeReference = (reference: Reference): EncodedReference => ({\n  '/': reference.toDXN().toString(),\n});\n\nexport const decodeReference = (value: any) => {\n  if (typeof value !== 'object' || value === null || typeof value['/'] !== 'string') {\n    throw new Error('Invalid reference');\n  }\n  const dxnString = value['/'];\n\n  if (\n    dxnString.length % 2 === 0 &&\n    dxnString.slice(0, dxnString.length / 2) === dxnString.slice(dxnString.length / 2) &&\n    dxnString.includes('dxn:echo')\n  ) {\n    throw new Error('Automerge bug detected!');\n  }\n\n  return Reference.fromDXN(DXN.parse(dxnString));\n};\n\nexport const isEncodedReference = (value: any): value is EncodedReference =>\n  typeof value === 'object' && value !== null && Object.keys(value).length === 1 && typeof value['/'] === 'string';\n", "//\n// Copyright 2024 DXOS.org\n//\n\n/**\n * Denotes the data version of the space automerge document as well as the leaf documents for each individual ECHO object.\n */\nexport type SpaceDocVersion = number & { __type: 'SpaceDocVersion' };\n\nexport const SpaceDocVersion = Object.freeze({\n  /**\n   * For the documents created before the versioning was introduced.\n   */\n  LEGACY: 0 as SpaceDocVersion,\n\n  /**\n   * Current version.\n   */\n  CURRENT: 1 as SpaceDocVersion,\n});\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { subtleCrypto } from '@dxos/crypto';\nimport { PublicKey, SpaceId } from '@dxos/keys';\nimport { ComplexMap } from '@dxos/util';\n\nconst SPACE_IDS_CACHE = new ComplexMap<PublicKey, SpaceId>(PublicKey.hash);\n\n/**\n * Space keys are generated by creating a keypair, and then taking the first 20 bytes of the SHA-256 hash of the public key and encoding them to multibase RFC4648 base-32 format (prefixed with B, see Multibase Table).\n * Inspired by how ethereum addresses are derived.\n */\nexport const createIdFromSpaceKey = async (spaceKey: PublicKey): Promise<SpaceId> => {\n  const cachedValue = SPACE_IDS_CACHE.get(spaceKey);\n  if (cachedValue !== undefined) {\n    return cachedValue;\n  }\n\n  const digest = await subtleCrypto.digest('SHA-256', spaceKey.asUint8Array());\n\n  const bytes = new Uint8Array(digest).slice(0, SpaceId.byteLength);\n  const spaceId = SpaceId.encode(bytes);\n  SPACE_IDS_CACHE.set(spaceKey, spaceId);\n  return spaceId;\n};\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { Schema, SchemaAST } from 'effect';\n\nconst ForeignKey_ = Schema.Struct({\n  /**\n   * Name of the foreign database/system.\n   * E.g., `github.com`.\n   */\n  source: Schema.String,\n\n  /**\n   * Id within the foreign database.\n   */\n  // TODO(wittjosiah): This annotation is currently used to ensure id field shows up in forms.\n  // TODO(dmaretskyi): `false` is not a valid value for the annotation.\n  id: Schema.String.annotations({ [SchemaAST.IdentifierAnnotationId]: false }),\n});\n\nexport type ForeignKey = Schema.Schema.Type<typeof ForeignKey_>;\n\n/**\n * Reference to an object in a foreign database.\n */\nexport const ForeignKey: Schema.Schema<ForeignKey> = ForeignKey_;\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { Schema } from 'effect';\n\nimport { DXN, ObjectId } from '@dxos/keys';\n\nimport { ForeignKey } from '../foreign-key';\n\nconst TypenameSpecifier = Schema.Union(DXN.Schema, Schema.Null).annotations({\n  description: 'DXN or null. Null means any type will match',\n});\n\n// NOTE: This pattern with 3 definitions per schema is need to make the types opaque, and circular references in AST to not cause compiler errors.\n\n/**\n * Filter by object type and properties.\n *\n * Clauses are combined using logical AND.\n */\n// TODO(burdon): Filter object vs. relation.\nconst FilterObject_ = Schema.Struct({\n  type: Schema.Literal('object'),\n\n  typename: TypenameSpecifier,\n\n  id: Schema.optional(Schema.Array(ObjectId)),\n\n  /**\n   * Filter by property.\n   * Must not include object ID.\n   */\n  props: Schema.Record({\n    key: Schema.String.annotations({ description: 'Property name' }),\n    value: Schema.suspend(() => Filter),\n  }),\n\n  /**\n   * Objects that have any of the given foreign keys.\n   */\n  foreignKeys: Schema.optional(Schema.Array(ForeignKey)),\n\n  // NOTE: Make sure to update `FilterStep.isNoop` if you change this.\n});\nexport interface FilterObject extends Schema.Schema.Type<typeof FilterObject_> {}\nexport const FilterObject: Schema.Schema<FilterObject> = FilterObject_;\n\nconst FilterCompare_ = Schema.Struct({\n  type: Schema.Literal('compare'),\n  operator: Schema.Literal('eq', 'neq', 'gt', 'gte', 'lt', 'lte'),\n  value: Schema.Unknown,\n});\nexport interface FilterCompare extends Schema.Schema.Type<typeof FilterCompare_> {}\nexport const FilterCompare: Schema.Schema<FilterCompare> = FilterCompare_;\n\nconst FilterIn_ = Schema.Struct({\n  type: Schema.Literal('in'),\n  values: Schema.Array(Schema.Any),\n});\nexport interface FilterIn extends Schema.Schema.Type<typeof FilterIn_> {}\nexport const FilterIn: Schema.Schema<FilterIn> = FilterIn_;\n\nconst FilterRange_ = Schema.Struct({\n  type: Schema.Literal('range'),\n  from: Schema.Any,\n  to: Schema.Any,\n});\nexport interface FilterRange extends Schema.Schema.Type<typeof FilterRange_> {}\nexport const FilterRange: Schema.Schema<FilterRange> = FilterRange_;\n\nconst FilterTextSearch_ = Schema.Struct({\n  type: Schema.Literal('text-search'),\n  text: Schema.String,\n  searchKind: Schema.optional(Schema.Literal('full-text', 'vector')),\n});\nexport interface FilterTextSearch extends Schema.Schema.Type<typeof FilterTextSearch_> {}\nexport const FilterTextSearch: Schema.Schema<FilterTextSearch> = FilterTextSearch_;\n\nconst FilterNot_ = Schema.Struct({\n  type: Schema.Literal('not'),\n  filter: Schema.suspend(() => Filter),\n});\nexport interface FilterNot extends Schema.Schema.Type<typeof FilterNot_> {}\nexport const FilterNot: Schema.Schema<FilterNot> = FilterNot_;\n\nconst FilterAnd_ = Schema.Struct({\n  type: Schema.Literal('and'),\n  filters: Schema.Array(Schema.suspend(() => Filter)),\n});\nexport interface FilterAnd extends Schema.Schema.Type<typeof FilterAnd_> {}\nexport const FilterAnd: Schema.Schema<FilterAnd> = FilterAnd_;\n\nconst FilterOr_ = Schema.Struct({\n  type: Schema.Literal('or'),\n  filters: Schema.Array(Schema.suspend(() => Filter)),\n});\nexport interface FilterOr extends Schema.Schema.Type<typeof FilterOr_> {}\nexport const FilterOr: Schema.Schema<FilterOr> = FilterOr_;\n\nexport const Filter = Schema.Union(\n  FilterObject,\n  FilterTextSearch,\n  FilterCompare,\n  FilterIn,\n  FilterRange,\n  FilterNot,\n  FilterAnd,\n  FilterOr,\n);\nexport type Filter = Schema.Schema.Type<typeof Filter>;\n\n/**\n * Query objects by type, id, and/or predicates.\n */\nconst QuerySelectClause_ = Schema.Struct({\n  type: Schema.Literal('select'),\n  filter: Schema.suspend(() => Filter),\n});\nexport interface QuerySelectClause extends Schema.Schema.Type<typeof QuerySelectClause_> {}\nexport const QuerySelectClause: Schema.Schema<QuerySelectClause> = QuerySelectClause_;\n\n/**\n * Filter objects from selection.\n */\nconst QueryFilterClause_ = Schema.Struct({\n  type: Schema.Literal('filter'),\n  selection: Schema.suspend(() => Query),\n  filter: Schema.suspend(() => Filter),\n});\nexport interface QueryFilterClause extends Schema.Schema.Type<typeof QueryFilterClause_> {}\nexport const QueryFilterClause: Schema.Schema<QueryFilterClause> = QueryFilterClause_;\n\n/**\n * Traverse references from an anchor object.\n */\nconst QueryReferenceTraversalClause_ = Schema.Struct({\n  type: Schema.Literal('reference-traversal'),\n  anchor: Schema.suspend(() => Query),\n  property: Schema.String, // TODO(dmaretskyi): Change to EscapedPropPath.\n});\nexport interface QueryReferenceTraversalClause extends Schema.Schema.Type<typeof QueryReferenceTraversalClause_> {}\nexport const QueryReferenceTraversalClause: Schema.Schema<QueryReferenceTraversalClause> =\n  QueryReferenceTraversalClause_;\n\n/**\n * Traverse incoming references to an anchor object.\n */\nconst QueryIncomingReferencesClause_ = Schema.Struct({\n  type: Schema.Literal('incoming-references'),\n  anchor: Schema.suspend(() => Query),\n  property: Schema.String,\n  typename: TypenameSpecifier,\n});\nexport interface QueryIncomingReferencesClause extends Schema.Schema.Type<typeof QueryIncomingReferencesClause_> {}\nexport const QueryIncomingReferencesClause: Schema.Schema<QueryIncomingReferencesClause> =\n  QueryIncomingReferencesClause_;\n\n/**\n * Traverse relations connecting to an anchor object.\n */\nconst QueryRelationClause_ = Schema.Struct({\n  type: Schema.Literal('relation'),\n  anchor: Schema.suspend(() => Query),\n  /**\n   * outgoing: anchor is the source of the relation.\n   * incoming: anchor is the target of the relation.\n   * both: anchor is either the source or target of the relation.\n   */\n  direction: Schema.Literal('outgoing', 'incoming', 'both'),\n  filter: Schema.optional(Schema.suspend(() => Filter)),\n});\nexport interface QueryRelationClause extends Schema.Schema.Type<typeof QueryRelationClause_> {}\nexport const QueryRelationClause: Schema.Schema<QueryRelationClause> = QueryRelationClause_;\n\n/**\n * Traverse into the source or target of a relation.\n */\nconst QueryRelationTraversalClause_ = Schema.Struct({\n  type: Schema.Literal('relation-traversal'),\n  anchor: Schema.suspend(() => Query),\n  direction: Schema.Literal('source', 'target', 'both'),\n});\nexport interface QueryRelationTraversalClause extends Schema.Schema.Type<typeof QueryRelationTraversalClause_> {}\nexport const QueryRelationTraversalClause: Schema.Schema<QueryRelationTraversalClause> = QueryRelationTraversalClause_;\n\n/**\n * Union of multiple queries.\n */\nconst QueryUnionClause_ = Schema.Struct({\n  type: Schema.Literal('union'),\n  queries: Schema.Array(Schema.suspend(() => Query)),\n});\nexport interface QueryUnionClause extends Schema.Schema.Type<typeof QueryUnionClause_> {}\nexport const QueryUnionClause: Schema.Schema<QueryUnionClause> = QueryUnionClause_;\n\n/**\n * Set difference of two queries.\n */\nconst QuerySetDifferenceClause_ = Schema.Struct({\n  type: Schema.Literal('set-difference'),\n  source: Schema.suspend(() => Query),\n  exclude: Schema.suspend(() => Query),\n});\nexport interface QuerySetDifferenceClause extends Schema.Schema.Type<typeof QuerySetDifferenceClause_> {}\nexport const QuerySetDifferenceClause: Schema.Schema<QuerySetDifferenceClause> = QuerySetDifferenceClause_;\n\n/**\n * Add options to a query.\n */\nconst QueryOptionsClause_ = Schema.Struct({\n  type: Schema.Literal('options'),\n  query: Schema.suspend(() => Query),\n  options: Schema.suspend(() => QueryOptions),\n});\nexport interface QueryOptionsClause extends Schema.Schema.Type<typeof QueryOptionsClause_> {}\nexport const QueryOptionsClause: Schema.Schema<QueryOptionsClause> = QueryOptionsClause_;\n\nconst Query_ = Schema.Union(\n  QuerySelectClause,\n  QueryFilterClause,\n  QueryReferenceTraversalClause,\n  QueryIncomingReferencesClause,\n  QueryRelationClause,\n  QueryRelationTraversalClause,\n  QueryUnionClause,\n  QuerySetDifferenceClause,\n  QueryOptionsClause,\n);\n\nexport type Query = Schema.Schema.Type<typeof Query_>;\nexport const Query: Schema.Schema<Query> = Query_;\n\nexport const QueryOptions = Schema.Struct({\n  spaceIds: Schema.optional(Schema.Array(Schema.String)),\n  deleted: Schema.optional(Schema.Literal('include', 'exclude', 'only')),\n});\nexport interface QueryOptions extends Schema.Schema.Type<typeof QueryOptions> {}\n\nexport const visit = (query: Query, visitor: (node: Query) => void) => {\n  switch (query.type) {\n    case 'filter':\n      visit(query.selection, visitor);\n      break;\n    case 'reference-traversal':\n      visit(query.anchor, visitor);\n      break;\n    case 'incoming-references':\n      visit(query.anchor, visitor);\n      break;\n    case 'relation':\n      visit(query.anchor, visitor);\n      break;\n    case 'options':\n      visit(query.query, visitor);\n      break;\n    case 'relation-traversal':\n      visit(query.anchor, visitor);\n      break;\n    case 'union':\n      query.queries.forEach((q) => visit(q, visitor));\n      break;\n    case 'set-difference':\n      visit(query.source, visitor);\n      visit(query.exclude, visitor);\n      break;\n  }\n};\n"],
  "mappings": "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",
  "names": ["import_keys", "import_util", "import_effect", "Reference", "TYPE_PROTOCOL", "fromDXN", "dxn", "kind", "DXN", "TYPE", "parts", "ECHO", "LOCAL_SPACE_TAG", "undefined", "fromValue", "value", "objectId", "protocol", "host", "localObjectReference", "fromLegacyTypename", "type", "fromObjectIdAndSpaceKey", "spaceKey", "toHex", "_objectId", "_protocol", "_host", "_dxn", "encode", "toDXN", "REFERENCE_TYPE_TAG", "encodeReference", "reference", "toString", "decodeReference", "Error", "dxnString", "length", "slice", "includes", "parse", "isEncodedReference", "Object", "keys", "DatabaseDirectory", "freeze", "getSpaceKey", "doc", "rawSpaceKey", "access", "experimental_spaceKey", "rawKey", "String", "invariant", "startsWith", "getInlineObject", "id", "objects", "getLink", "links", "make", "ObjectStructure", "getTypeReference", "object", "system", "getEntityKind", "isDeleted", "deleted", "getRelationSource", "source", "getRelationTarget", "target", "getAllOutgoingReferences", "references", "visit", "path", "push", "visitValues", "key", "data", "makeObject", "meta", "makeRelation", "PROPERTY_ID", "DATA_NAMESPACE", "SpaceDocVersion", "LEGACY", "CURRENT", "SPACE_IDS_CACHE", "ComplexMap", "PublicKey", "hash", "createIdFromSpaceKey", "cachedValue", "get", "digest", "subtleCrypto", "asUint8Array", "bytes", "Uint8Array", "SpaceId", "byteLength", "spaceId", "set", "ForeignKey_", "Schema", "Struct", "annotations", "SchemaAST", "IdentifierAnnotationId", "ForeignKey", "TypenameSpecifier", "Union", "Null", "description", "FilterObject_", "Literal", "typename", "optional", "Array", "ObjectId", "props", "Record", "suspend", "Filter", "foreignKeys", "FilterObject", "FilterCompare_", "operator", "Unknown", "FilterCompare", "FilterIn_", "values", "Any", "FilterIn", "FilterRange_", "from", "to", "FilterRange", "FilterTextSearch_", "text", "searchKind", "FilterTextSearch", "FilterNot_", "filter", "FilterNot", "FilterAnd_", "filters", "FilterAnd", "FilterOr_", "FilterOr", "QuerySelectClause_", "QuerySelectClause", "QueryFilterClause_", "selection", "Query", "QueryFilterClause", "QueryReferenceTraversalClause_", "anchor", "property", "QueryReferenceTraversalClause", "QueryIncomingReferencesClause_", "QueryIncomingReferencesClause", "QueryRelationClause_", "direction", "QueryRelationClause", "QueryRelationTraversalClause_", "QueryRelationTraversalClause", "QueryUnionClause_", "queries", "QueryUnionClause", "QuerySetDifferenceClause_", "exclude", "QuerySetDifferenceClause", "QueryOptionsClause_", "query", "options", "QueryOptions", "QueryOptionsClause", "Query_", "spaceIds", "visitor", "forEach", "q"]
}
