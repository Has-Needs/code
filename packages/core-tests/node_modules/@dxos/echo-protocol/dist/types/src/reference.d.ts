import { DXN, type PublicKey } from '@dxos/keys';
import { type ObjectId } from '@dxos/protocols';
import { type Reference as ReferenceProto } from '@dxos/protocols/proto/dxos/echo/model/document';
/**
 * Runtime representation of an reference in ECHO.
 * Implemented as a DXN, but we might extend it to other URIs in the future.
 */
export declare class Reference {
    private readonly _objectId;
    private readonly _protocol?;
    private readonly _host?;
    private readonly _dxn?;
    /**
     * Protocol references to runtime registered types.
     * @deprecated
     */
    static TYPE_PROTOCOL: string;
    static fromDXN(dxn: DXN): Reference;
    static fromValue(value: ReferenceProto): Reference;
    /**
     * Reference an object in the local space.
     */
    static localObjectReference(objectId: ObjectId): Reference;
    /**
     * @deprecated
     */
    static fromLegacyTypename(type: string): Reference;
    /**
     * @deprecated
     */
    static fromObjectIdAndSpaceKey(objectId: ObjectId, spaceKey: PublicKey): Reference;
    private constructor();
    get dxn(): DXN | undefined;
    /**
     * @deprecated
     */
    get objectId(): ObjectId;
    /**
     * @deprecated
     */
    get protocol(): string | undefined;
    /**
     * @deprecated
     */
    get host(): string | undefined;
    encode(): ReferenceProto;
    toDXN(): DXN;
}
export declare const REFERENCE_TYPE_TAG = "dxos.echo.model.document.Reference";
/**
 * Reference as it is stored in Automerge document.
 */
export type EncodedReference = {
    '/': string;
};
export declare const encodeReference: (reference: Reference) => EncodedReference;
export declare const decodeReference: (value: any) => Reference;
export declare const isEncodedReference: (value: any) => value is EncodedReference;
//# sourceMappingURL=reference.d.ts.map