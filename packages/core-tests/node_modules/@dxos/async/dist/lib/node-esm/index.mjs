import { createRequire } from 'node:module';const require = createRequire(import.meta.url);

// packages/common/async/src/callback.ts
var createPromiseFromCallback = (run) => new Promise((resolve, reject) => {
  run((error, value) => {
    if (error) {
      reject(error);
    } else {
      resolve(value);
    }
  });
});

// packages/common/async/src/chain.ts
var asyncChain = (chain) => async (elements) => {
  let result = await elements;
  for (const part of chain) {
    result = await Promise.all(result.map(async (element) => await part(element)));
  }
  return result;
};

// packages/common/async/src/cleanup.ts
import { ComplexMap } from "@dxos/util";
var combine = (...cleanupFns) => {
  return () => {
    cleanupFns.flat().forEach((cleanupFn) => cleanupFn());
  };
};
var timeout = (cb, ms = 0) => {
  const t = setTimeout(cb, ms);
  return () => clearTimeout(t);
};
var interval = (cb, ms) => {
  const t = setInterval(cb, ms);
  return () => clearInterval(t);
};
function addEventListener(target, type, listener, options) {
  target.addEventListener(type, listener, options);
  return () => target.removeEventListener(type, listener, options);
}
var SubscriptionList = class {
  constructor() {
    this._cleanups = [];
  }
  add(cb) {
    this._cleanups.push(cb);
    return this;
  }
  clear() {
    this._cleanups.forEach((cb) => cb());
    this._cleanups.length = 0;
  }
};
var SubscriptionSet = class {
  constructor(keyProjection) {
    this._cleanupMap = new ComplexMap(keyProjection);
  }
  set(key, cb) {
    this._cleanupMap.set(key, cb);
    return this;
  }
  clear() {
    this._cleanupMap.forEach((cb) => cb());
    this._cleanupMap.clear();
  }
};

// packages/common/async/src/debounce.ts
var debounce = (cb, wait = 100) => {
  let t;
  return (...args) => {
    clearTimeout(t);
    t = setTimeout(() => cb(...args), wait);
  };
};

// packages/common/async/src/errors.ts
var toError = (err) => err === void 0 || typeof err === "string" ? new Error(err) : err;
var TimeoutError = class extends Error {
  constructor(timeout2, label) {
    super(timeout2 ? `Timeout [${timeout2.toLocaleString()}ms]${label === void 0 ? "" : `: ${label}`}` : "Timeout");
  }
};
var observableError = (observable, err) => {
  if (err instanceof TimeoutError) {
    observable.callback.onTimeout?.(err);
  } else {
    observable.callback.onError(toError(err));
  }
};

// packages/common/async/src/timeout.ts
import { ContextDisposedError } from "@dxos/context";
var sleep = (ms) => {
  return new Promise((resolve) => {
    const finish = Date.now() + ms;
    const sleeper = () => {
      const delta = finish - Date.now();
      if (delta > 0) {
        setTimeout(sleeper, delta);
      } else {
        resolve();
      }
    };
    sleeper();
  });
};
var asyncReturn = () => sleep(0);
var asyncTimeout = async (promise, timeout2, err) => {
  let timeoutId;
  const throwable = err === void 0 || typeof err === "string" ? new TimeoutError(timeout2, err) : err;
  const timeoutPromise = new Promise((resolve, reject) => {
    timeoutId = setTimeout(() => {
      reject(throwable);
    }, timeout2);
    unrefTimeout(timeoutId);
  });
  const conditionTimeout = typeof promise === "function" ? createPromiseFromCallback(promise) : promise;
  return await Promise.race([
    conditionTimeout,
    timeoutPromise
  ]).finally(() => {
    clearTimeout(timeoutId);
  });
};
var unrefTimeout = (timeoutId) => {
  if (typeof timeoutId === "object" && "unref" in timeoutId) {
    timeoutId.unref();
  }
};
var sleepWithContext = (ctx, ms) => {
  const error = new ContextDisposedError();
  return new Promise((resolve, reject) => {
    if (ctx.disposed) {
      reject(error);
      return;
    }
    const timeout2 = setTimeout(() => {
      clearDispose();
      resolve();
    }, ms);
    const clearDispose = ctx.onDispose(() => {
      clearTimeout(timeout2);
      reject(error);
    });
  });
};

// packages/common/async/src/event-emitter.ts
var onEvent = (eventEmitter, eventName, callback) => {
  eventEmitter.on(eventName, callback);
  return () => eventEmitter.off(eventName, callback);
};
var addListener = (eventEmitter, eventName, callback) => {
  const off = onEvent(eventEmitter, eventName, callback);
  return {
    remove: () => off()
  };
};
var waitForEvent = (eventEmitter, eventName, test, timeout2, error) => {
  let off;
  const promise = new Promise((resolve) => {
    off = onEvent(eventEmitter, eventName, (...args) => {
      if (!test || test(...args)) {
        resolve(...args);
      }
    });
  });
  return timeout2 ? asyncTimeout(promise, timeout2, error ?? new Error()).finally(off) : promise.finally(off);
};

// packages/common/async/src/events.ts
import { Context } from "@dxos/context";
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/common/async/src/events.ts";
var DO_NOT_ERROR_ON_ASYNC_CALLBACK = true;
var Event = class _Event {
  constructor() {
    this._listeners = /* @__PURE__ */ new Set();
    this._effects = /* @__PURE__ */ new Set();
  }
  /**
  * Wrap objects that have on/off style event emitters.
  */
  static wrap(emitter, eventName) {
    const event = new _Event();
    event.addEffect(() => {
      const onEvent2 = (data) => event.emit(data);
      emitter.on(eventName, onEvent2);
      return () => emitter.off(eventName, onEvent2);
    });
    return event;
  }
  /**
  * Emit an event.
  * In most cases should only be called by the class or entity containing the event.
  * All listeners are called in order of subscription with persistent ones first.
  * Listeners are called synchronously in the same stack.
  * A thrown exception in the listener will stop the event from being emitted to the rest of the listeners.
  *
  * @param data param that will be passed to all listeners.
  */
  emit(data) {
    for (const listener of this._listeners) {
      listener.trigger(data);
      if (listener.once) {
        this._listeners.delete(listener);
      }
    }
  }
  /**
  * Emit an event and wait for async listeners to complete.
  * In most cases should only be called by the class or entity containing the event.
  * All listeners are called in order of subscription with persistent ones first.
  * Listeners are called sequentially.
  *
  * @param data param that will be passed to all listeners.
  */
  async emitAsync(data) {
    for (const listener of this._listeners) {
      await listener.triggerAsync(data);
      if (listener.once) {
        this._listeners.delete(listener);
      }
    }
  }
  on(_ctx, _callback, options) {
    const [ctx, callback] = _ctx instanceof Context ? [
      _ctx,
      _callback
    ] : [
      new Context(void 0, {
        F: __dxlog_file,
        L: 132
      }),
      _ctx
    ];
    const weak = !!options?.weak;
    const once = !!options?.once;
    const listener = new EventListener(this, callback, ctx, once, weak);
    this._addListener(listener);
    return () => {
      this._removeListener(listener);
    };
  }
  /**
  * Unsubscribe this callback from new events. Includes persistent and once-listeners.
  * NOTE: It is recommended to use `Event.on`'s return value instead.
  * If the callback is not subscribed this is no-op.
  *
  * @param callback
  */
  off(callback) {
    for (const listener of this._listeners) {
      if (listener.derefCallback() === callback) {
        this._removeListener(listener);
      }
    }
  }
  once(_ctx, _callback) {
    const [ctx, callback] = _ctx instanceof Context ? [
      _ctx,
      _callback
    ] : [
      new Context(void 0, {
        F: __dxlog_file,
        L: 169
      }),
      _ctx
    ];
    const listener = new EventListener(this, callback, ctx, true, false);
    this._addListener(listener);
    return () => {
      this._removeListener(listener);
    };
  }
  /**
  * An async iterator that iterates over events.
  * This iterator runs indefinitely.
  */
  async *[Symbol.asyncIterator]() {
    while (true) {
      yield await new Promise((resolve) => {
        this.once(resolve);
      });
    }
  }
  /**
  * Returns a promise that resolves with the first event emitted that matches the provided predicate.
  *
  * @param predicate
  */
  waitFor(predicate) {
    return new Promise((resolve) => {
      const unsubscribe = this.on((data) => {
        if (predicate(data)) {
          unsubscribe();
          resolve(data);
        }
      });
    });
  }
  /**
  * Returns a promise that resolves once a specific number of events was emitted since this method was called.
  *
  * @param expectedCount
  */
  waitForCount(expectedCount) {
    let count = 0;
    return this.waitFor(() => ++count === expectedCount);
  }
  /**
  * Similar to waitFor, but the promise resolves immediately if the condition is already true.
  */
  // TODO(burdon): Should pass event property to predicate.
  async waitForCondition(predicate) {
    if (!predicate()) {
      await this.waitFor(predicate);
    }
  }
  /**
  * Returns the number of persistent listeners.
  */
  listenerCount() {
    return this._listeners.size;
  }
  /**
  * Add a side effect that will be activated once the event has at least one subscriber.
  * The provided callback can return a function that will be used to clean up after the last subscriber unsubscribes from the event.
  * The API is similar to `useEffect` from React.
  *
  * ## Example:
  * ```typescript
  * event.addEffect(() => {
  *   // do stuff
  *   return () => {
  *     // clean-up
  *   };
  * });
  * ```
  *
  * @returns Callback that will remove this effect once called.
  */
  addEffect(effect) {
    const handle = {
      effect,
      cleanup: void 0
    };
    if (this.listenerCount() > 0) {
      handle.cleanup = handle.effect();
    }
    this._effects.add(handle);
    return () => {
      handle.cleanup?.();
      this._effects.delete(handle);
    };
  }
  /**
  * Triggers an event with at least `timeout` milliseconds between each event.
  * If the event is triggered more often, the event is delayed until the timeout is reached.
  * If event is emitted for the first time or event wasn't fired for `timeout` milliseconds,
  * the event is emitted after `timeout / 8` ms.
  */
  // TODO(burdon): Factor out generic function.
  debounce(timeout2 = 0) {
    let firing;
    let lastFired;
    const debouncedEvent = new _Event();
    debouncedEvent.addEffect(() => {
      const unsubscribe = this.on(() => {
        if (!firing) {
          const fireIn = !lastFired || Date.now() - lastFired > timeout2 ? timeout2 / 8 : timeout2;
          firing = setTimeout(() => {
            lastFired = Date.now();
            firing = void 0;
            debouncedEvent.emit();
          }, fireIn);
        }
      });
      return () => {
        unsubscribe();
        clearTimeout(firing);
      };
    });
    return debouncedEvent;
  }
  /**
  * Turn any variant of `Event<T>` into an `Event<void>` discarding the callback parameter.
  */
  discardParameter() {
    return this;
  }
  /**
  * Pipe the events into another event.
  * @param event
  */
  pipeInto(event) {
    return this.on((data) => event.emit(data));
  }
  /**
  * Overridden to not return implementation details.
  */
  toJSON() {
    return {
      listenerCount: this.listenerCount()
    };
  }
  _addListener(listener) {
    this._listeners.add(listener);
    if (this.listenerCount() === 1) {
      this._runEffects();
    }
  }
  /**
  * @internal
  */
  _removeListener(listener) {
    this._listeners.delete(listener);
    listener.remove();
    if (this.listenerCount() === 0) {
      this._cleanupEffects();
    }
  }
  _runEffects() {
    for (const handle of this._effects) {
      handle.cleanup = handle.effect();
    }
  }
  _cleanupEffects() {
    for (const handle of this._effects) {
      handle.cleanup?.();
      handle.cleanup = void 0;
    }
  }
};
var EventListener = class {
  constructor(event, listener, ctx, once, weak) {
    this.ctx = ctx;
    this.once = once;
    this.weak = weak;
    this._clearDispose = void 0;
    this._clearDispose = ctx.onDispose(() => {
      event._removeListener(this);
    });
    if (weak) {
      this.callback = new WeakRef(listener);
      weakListeners().registry?.register(listener, {
        event: new WeakRef(event),
        listener: this
      }, this);
    } else {
      this.callback = listener;
    }
  }
  derefCallback() {
    return this.weak ? this.callback.deref() : this.callback;
  }
  trigger(data) {
    let result;
    try {
      const callback = this.derefCallback();
      result = callback?.(data);
    } catch (err) {
      this.ctx.raise(err);
    }
    if (!DO_NOT_ERROR_ON_ASYNC_CALLBACK) {
      if (result instanceof Promise) {
        throw new TypeError("Event has async callbacks, use emitAsync instead");
      }
    }
  }
  async triggerAsync(data) {
    try {
      const callback = this.derefCallback();
      await callback?.(data);
    } catch (err) {
      this.ctx.raise(err);
    }
  }
  remove() {
    this._clearDispose?.();
    weakListeners().registry?.unregister(this);
  }
};
var weakListenersState = null;
var FINALIZATION_REGISTRY_SUPPORTED = !!globalThis.FinalizationRegistry;
var weakListeners = () => {
  if (!FINALIZATION_REGISTRY_SUPPORTED) {
    return {
      registry: void 0
    };
  }
  weakListenersState ??= new FinalizationRegistry(({ event, listener }) => {
    event.deref()?._removeListener(listener);
  });
  return {
    registry: weakListenersState
  };
};

// packages/common/async/src/latch.ts
import { invariant } from "@dxos/invariant";
var __dxlog_file2 = "/home/runner/work/dxos/dxos/packages/common/async/src/latch.ts";
var latch = ({ count = 1, timeout: timeout2 } = {}) => {
  invariant(count >= 0, void 0, {
    F: __dxlog_file2,
    L: 19,
    S: void 0,
    A: [
      "count >= 0",
      ""
    ]
  });
  let t;
  let doResolve;
  let doReject;
  const promise = new Promise((resolve, reject) => {
    doResolve = (value) => {
      clearTimeout(t);
      resolve(value);
    };
    doReject = (err) => {
      clearTimeout(t);
      reject(err);
    };
  });
  if (count === 0) {
    setTimeout(() => {
      doResolve(0);
    });
  } else {
    if (timeout2) {
      t = setTimeout(() => {
        doReject(new Error(`Timed out after ${timeout2.toLocaleString()}ms`));
      }, timeout2);
    }
  }
  let i = 0;
  return [
    async () => await promise,
    () => {
      if (++i === count) {
        doResolve(i);
      }
      return i;
    },
    (err) => doReject(err)
  ];
};

// packages/common/async/src/mutex.ts
import "@dxos/util";
import { warnAfterTimeout } from "@dxos/debug";
var Mutex = class {
  constructor() {
    this._queue = Promise.resolve();
    this._queueLength = 0;
    this._tag = null;
  }
  get tag() {
    return this._tag;
  }
  isLocked() {
    return this._queueLength > 0;
  }
  /**
  * Acquires the lock.
  * Caller is responsible for releasing the lock using the returned callback.
  * NOTE: Using `executeSynchronized` is preferred over using `acquire` directly.
  * @returns Release callback
  */
  async acquire(tag) {
    const prev = this._queue;
    let guard;
    this._queueLength++;
    this._queue = new Promise((resolve) => {
      guard = new MutexGuard(() => {
        this._queueLength--;
        this._tag = null;
        resolve();
      });
    });
    await prev;
    if (tag !== void 0) {
      this._tag = tag;
    }
    return guard;
  }
  /**
  * Waits for all previous executions to complete and then executes a given function.
  * Only a single function can be executed at a time.
  * Function are executed in the same order as `executeSynchronized` is called.
  * WARNING: Calling `executeSynchronized` inside of `executeSynchronized` on the same lock instance is a deadlock.
  */
  async executeSynchronized(fun) {
    const guard = await this.acquire();
    try {
      return await fun();
    } finally {
      guard.release();
    }
  }
};
var MutexGuard = class {
  constructor(_release) {
    this._release = _release;
  }
  /**
  * Releases the lock.
  */
  release() {
    this._release();
  }
  [Symbol.dispose]() {
    this.release();
  }
};
var classMutexSymbol = Symbol("class-mutex");
var FORCE_DISABLE_WARNING = false;
var enableWarning = !FORCE_DISABLE_WARNING && globalThis.mochaExecutor;
var synchronized = (target, propertyName, descriptor) => {
  const method = descriptor.value;
  descriptor.value = async function synchronizedMethod(...args) {
    const mutex = this[classMutexSymbol] ??= new Mutex();
    const tag = `${target.constructor.name}.${propertyName}`;
    let guard;
    if (!enableWarning) {
      guard = await mutex.acquire(tag);
    } else {
      guard = await warnAfterTimeout(1e4, `lock on ${tag} (taken by ${mutex.tag})`, () => mutex.acquire(tag));
    }
    try {
      return await method.apply(this, args);
    } finally {
      guard.release();
    }
  };
  Object.defineProperty(descriptor.value, "name", {
    value: propertyName + "$synchronized"
  });
};

// packages/common/async/src/observable.ts
import Observable from "zen-observable";
import PushStream from "zen-push";

// packages/common/async/src/trigger.ts
var trigger = (timeout2) => {
  let callback;
  const promise = new Promise((resolve, reject) => {
    if (timeout2) {
      setTimeout(() => reject(new Error(`Timed out after ${timeout2.toLocaleString()}ms`)), timeout2);
    }
    callback = resolve;
  });
  const provider = () => promise;
  const resolver = (value) => callback(value);
  return [
    provider,
    resolver
  ];
};
var TriggerState = /* @__PURE__ */ function(TriggerState2) {
  TriggerState2["WAITING"] = "WAITING";
  TriggerState2["RESOLVED"] = "RESOLVED";
  TriggerState2["REJECTED"] = "REJECTED";
  return TriggerState2;
}({});
var Trigger = class {
  constructor(_options = {
    autoReset: false
  }) {
    this._options = _options;
    this._state = "WAITING";
    this.reset();
  }
  get state() {
    return this._state;
  }
  /**
  * Wait until wake is called, with optional timeout.
  */
  async wait({ timeout: timeout2 } = {}) {
    if (timeout2) {
      return asyncTimeout(this._promise, timeout2, new TimeoutError(timeout2));
    } else {
      return this._promise;
    }
  }
  /**
  * Wake blocked callers (if any).
  * NOOP if the trigger is already resolved.
  */
  wake(value) {
    if (this._state !== "WAITING") {
      return this;
    }
    this._state = "RESOLVED";
    this._resolve(value);
    if (this._options.autoReset) {
      return this.reset();
    }
    return this;
  }
  /**
  * Reset promise (new waiters will wait).
  */
  reset() {
    this._state = "WAITING";
    this._promise = new Promise((resolve, reject) => {
      this._resolve = resolve;
      this._reject = reject;
    });
    this._promise.catch(() => {
    });
    return this;
  }
  /**
  * Throw error to blocked callers (if any).
  * NOOP if the trigger is already resolved.
  */
  throw(error) {
    if (this._state !== "WAITING") {
      return this;
    }
    this._state = "REJECTED";
    this._reject(error);
    if (this._options.autoReset) {
      return this.reset();
    }
    return this;
  }
};

// packages/common/async/src/observable.ts
var MulticastObservable = class _MulticastObservable extends Observable {
  constructor(subscriber, _value) {
    super((observer) => this._subscribe(observer)), this._value = _value, this._observers = /* @__PURE__ */ new Set(), this._completed = new Trigger(), this._handlers = {
      next: (value) => {
        this._value = value;
        this._observers.forEach((observer) => observer.next?.(value));
      },
      error: (err) => {
        this._observers.forEach((observer) => observer.error?.(err));
      },
      complete: () => {
        this._completed.wake();
        this._observers.forEach((observer) => observer.complete?.());
      }
    };
    this._observable = typeof subscriber === "function" ? new Observable(subscriber) : subscriber;
    this._observable.subscribe(this._handlers);
  }
  static from(value, initialValue) {
    if ("emit" in value) {
      return new _MulticastObservable((observer) => {
        value.on((data) => {
          observer.next(data);
        });
      }, initialValue);
    }
    const observable = Observable.from(value);
    return new _MulticastObservable(observable, initialValue);
  }
  static of(...items) {
    return new _MulticastObservable(Observable.of(...items.slice(1)), items[0]);
  }
  /**
  * @returns Stable reference to an observable that always returns `undefined`.
  */
  static empty() {
    return EMPTY_OBSERVABLE;
  }
  /**
  * Get the current value of the observable.
  */
  get() {
    if (this._value === void 0) {
      throw new Error("MulticastObservable is not initialized.");
    }
    return this._value;
  }
  /**
  * Wait for the observable to complete.
  *
  * @returns Promise that resolves to the value of the observable at the time of completion.
  */
  async wait({ timeout: timeout2 } = {}) {
    await this._completed.wait({
      timeout: timeout2
    });
    return this.get();
  }
  forEach(callback) {
    return this._observable.forEach(callback);
  }
  map(callback) {
    return new _MulticastObservable(this._observable.map(callback), this._value && callback(this._value));
  }
  filter(callback) {
    return new _MulticastObservable(this._observable.filter(callback), this._value && callback(this._value) ? this._value : void 0);
  }
  reduce(callback, initialValue) {
    return new _MulticastObservable(initialValue ? this._observable.reduce(callback, initialValue) : this._observable.reduce(callback), initialValue ?? this._value);
  }
  flatMap(callback) {
    return new _MulticastObservable(this._observable.flatMap(callback), this._value && callback(this._value).get());
  }
  concat(...observables) {
    return new _MulticastObservable(this._observable.concat(...observables), this._value);
  }
  /**
  * Concatenates multicast observables without losing the current value.
  * @param reducer reduces the values of any multicast observables being concatenated into a single value
  * @param observables observables to concatenate
  * @returns concatenated observable
  */
  losslessConcat(reducer, ...observables) {
    const multicast = observables.filter((observable) => observable instanceof _MulticastObservable);
    const value = reducer(this._value, multicast.map((observable) => observable.get()));
    return new _MulticastObservable(this._observable.concat(...observables), value);
  }
  _subscribe(observer) {
    if (!this._observers.has(observer)) {
      this._observers.add(observer);
    }
    if (this._value !== void 0) {
      observer.next?.(this._value);
    }
    return () => {
      this._observers.delete(observer);
    };
  }
};
var EMPTY_OBSERVABLE = MulticastObservable.of(null);

// packages/common/async/src/observable-value.ts
import { createSetDispatch } from "@dxos/util";
var ObservableProvider = class {
  constructor() {
    this._handlers = /* @__PURE__ */ new Set();
    this._proxy = createSetDispatch({
      handlers: this._handlers
    });
  }
  /**
  * Proxy used to dispatch callbacks to each subscription.
  */
  get callback() {
    return this._proxy;
  }
  get value() {
    return this._value;
  }
  setValue(value) {
    this._value = value;
  }
  subscribe(handler) {
    this._handlers.add(handler);
    return () => {
      this._handlers.delete(handler);
    };
  }
};
var CancellableObservableProvider = class extends ObservableProvider {
  constructor(_handleCancel) {
    super(), this._handleCancel = _handleCancel, this._cancelled = false;
  }
  get cancelled() {
    return this._cancelled;
  }
  async cancel() {
    if (this._cancelled) {
      return;
    }
    this._cancelled = true;
    await this._handleCancel?.();
    this.callback.onCancelled?.();
  }
};

// packages/common/async/src/persistent-lifecycle.ts
import { LifecycleState, Resource, cancelWithContext } from "@dxos/context";
import { warnAfterTimeout as warnAfterTimeout2 } from "@dxos/debug";
import { log as log2 } from "@dxos/log";

// packages/common/async/src/task-scheduling.ts
import { ContextDisposedError as ContextDisposedError2 } from "@dxos/context";
import { StackTrace as StackTrace2 } from "@dxos/debug";

// packages/common/async/src/track-leaks.ts
import { StackTrace } from "@dxos/debug";
import { log } from "@dxos/log";
var __dxlog_file3 = "/home/runner/work/dxos/dxos/packages/common/async/src/track-leaks.ts";
var enabled = typeof process !== "undefined" && !!process.env.DX_TRACK_LEAKS;
var openResources = /* @__PURE__ */ new Set();
var handleSymbol = Symbol("checkLeaksHandle");
var trackResource = (resourceProvider) => {
  if (!enabled) {
    return () => {
    };
  }
  const resource = resourceProvider();
  openResources.add(resource);
  return () => {
    openResources.delete(resource);
  };
};
var trackLeaks = (open, close) => (target) => {
  if (!enabled) {
    return;
  }
  const openMethod = target.prototype[open];
  const closeMethod = target.prototype[close];
  if (!openMethod || !closeMethod) {
    throw new Error(`Cannot find ${open} or ${close} method in ${target.name}`);
  }
  {
    target.prototype[open] = async function(...args) {
      this[handleSymbol] = trackResource(() => ({
        name: target.name,
        openStack: new StackTrace()
      }));
      return openMethod.apply(this, args);
    };
    Object.defineProperty(target.prototype[open], "name", {
      value: open + "$checkLeaks"
    });
  }
  {
    target.prototype[close] = async function(...args) {
      this[handleSymbol]?.();
      return closeMethod.apply(this, args);
    };
    Object.defineProperty(target.prototype[close], "name", {
      value: close + "$checkLeaks"
    });
  }
};
var dumpLeaks = () => {
  if (!enabled) {
    return;
  }
  log.info(`Leaked resources ${openResources.size}:`, void 0, {
    F: __dxlog_file3,
    L: 82,
    S: void 0,
    C: (f, a) => f(...a)
  });
  for (const resource of openResources) {
    log.info(`- ${resource.name} at`, void 0, {
      F: __dxlog_file3,
      L: 84,
      S: void 0,
      C: (f, a) => f(...a)
    });
    log.info(resource.openStack.getStack(1), void 0, {
      F: __dxlog_file3,
      L: 85,
      S: void 0,
      C: (f, a) => f(...a)
    });
    log.info("\n", void 0, {
      F: __dxlog_file3,
      L: 86,
      S: void 0,
      C: (f, a) => f(...a)
    });
  }
};
if (enabled) {
  global.dxDumpLeaks = dumpLeaks;
}

// packages/common/async/src/task-scheduling.ts
var DeferredTask = class {
  constructor(_ctx, _callback) {
    this._ctx = _ctx;
    this._callback = _callback;
    this._scheduled = false;
    this._currentTask = null;
    this._nextTask = new Trigger();
  }
  get scheduled() {
    return this._scheduled;
  }
  /**
  * Schedule the task to run asynchronously.
  */
  schedule() {
    if (this._scheduled) {
      return;
    }
    scheduleTask(this._ctx, async () => {
      await this._currentTask;
      this._scheduled = false;
      const completionTrigger = this._nextTask;
      this._nextTask = new Trigger();
      this._currentTask = runInContextAsync(this._ctx, () => this._callback()).then(() => {
        completionTrigger.wake();
      });
    });
    this._scheduled = true;
  }
  /**
  * Schedule the task to run and wait for it to finish.
  */
  async runBlocking() {
    if (this._ctx.disposed) {
      throw new ContextDisposedError2();
    }
    this.schedule();
    await this._nextTask.wait();
  }
  /**
  * Waits for the current task to finish if it is running.
  * Does not schedule a new task.
  */
  async join() {
    await this._currentTask;
  }
};
var runInContext = (ctx, fn) => {
  try {
    fn();
  } catch (err) {
    ctx.raise(err);
  }
};
var runInContextAsync = async (ctx, fn) => {
  try {
    await fn();
  } catch (err) {
    ctx.raise(err);
  }
};
var scheduleMicroTask = (ctx, fn) => {
  queueMicrotask(async () => {
    if (ctx.disposed) {
      return;
    }
    await runInContextAsync(ctx, fn);
  });
};
var scheduleTask = (ctx, fn, afterMs) => {
  const clearTracking = trackResource(() => ({
    name: `task (${fn.name || "anonymous"})`,
    openStack: new StackTrace2()
  }));
  const timeout2 = setTimeout(async () => {
    clearDispose();
    await runInContextAsync(ctx, fn);
    clearTracking();
  }, afterMs);
  const clearDispose = ctx.onDispose(() => {
    clearTracking();
    clearTimeout(timeout2);
  });
};
var scheduleTaskInterval = (ctx, task, interval2) => {
  const clearTracking = trackResource(() => ({
    name: `repeating task (${task.name || "anonymous"})`,
    openStack: new StackTrace2()
  }));
  let timeoutId;
  const run = async () => {
    await runInContextAsync(ctx, task);
    if (ctx.disposed) {
      return;
    }
    timeoutId = setTimeout(run, interval2);
  };
  timeoutId = setTimeout(run, interval2);
  ctx.onDispose(() => {
    clearTracking();
    clearTimeout(timeoutId);
  });
};
var scheduleExponentialBackoffTaskInterval = (ctx, task, initialInterval) => {
  const clearTracking = trackResource(() => ({
    name: `repeating task (${task.name || "anonymous"})`,
    openStack: new StackTrace2()
  }));
  let timeoutId;
  let interval2 = initialInterval;
  const repeat = async () => {
    await runInContextAsync(ctx, task);
    if (ctx.disposed) {
      return;
    }
    interval2 *= 2;
    timeoutId = setTimeout(repeat, interval2);
  };
  timeoutId = setTimeout(repeat, interval2);
  ctx.onDispose(() => {
    clearTracking();
    clearTimeout(timeoutId);
  });
};

// packages/common/async/src/persistent-lifecycle.ts
function _ts_decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file4 = "/home/runner/work/dxos/dxos/packages/common/async/src/persistent-lifecycle.ts";
var INIT_RESTART_DELAY = 100;
var DEFAULT_MAX_RESTART_DELAY = 5e3;
var PersistentLifecycle = class extends Resource {
  constructor({ start, stop, onRestart, maxRestartDelay = DEFAULT_MAX_RESTART_DELAY }) {
    super();
    this._currentState = void 0;
    this._restartTask = void 0;
    this._restartAfter = 0;
    this._start = start;
    this._stop = stop;
    this._onRestart = onRestart;
    this._maxRestartDelay = maxRestartDelay;
  }
  get state() {
    return this._currentState;
  }
  async _open() {
    this._restartTask = new DeferredTask(this._ctx, async () => {
      try {
        await this._restart();
      } catch (err) {
        log2.warn("Restart failed", {
          err
        }, {
          F: __dxlog_file4,
          L: 72,
          S: this,
          C: (f, a) => f(...a)
        });
        this._restartTask?.schedule();
      }
    });
    this._currentState = await this._start().catch((err) => {
      log2.warn("Start failed", {
        err
      }, {
        F: __dxlog_file4,
        L: 78,
        S: this,
        C: (f, a) => f(...a)
      });
      this._restartTask?.schedule();
      return void 0;
    });
  }
  async _close() {
    await this._restartTask?.join();
    await this._stopCurrentState();
    this._restartTask = void 0;
  }
  async _restart() {
    log2(`restarting in ${this._restartAfter}ms`, {
      state: this._lifecycleState
    }, {
      F: __dxlog_file4,
      L: 91,
      S: this,
      C: (f, a) => f(...a)
    });
    await this._stopCurrentState();
    if (this._lifecycleState !== LifecycleState.OPEN) {
      return;
    }
    await cancelWithContext(this._ctx, sleep(this._restartAfter));
    this._restartAfter = Math.min(Math.max(this._restartAfter * 2, INIT_RESTART_DELAY), this._maxRestartDelay);
    await warnAfterTimeout2(5e3, "Connection establishment takes too long", async () => {
      this._currentState = await this._start();
    });
    this._restartAfter = 0;
    await this._onRestart?.();
  }
  async _stopCurrentState() {
    if (this._currentState) {
      try {
        await this._stop(this._currentState);
      } catch (err) {
        log2.catch(err, void 0, {
          F: __dxlog_file4,
          L: 113,
          S: this,
          C: (f, a) => f(...a)
        });
      }
      this._currentState = void 0;
    }
  }
  /**
  * Scheduling restart should be done from outside.
  */
  async scheduleRestart() {
    if (this._lifecycleState !== LifecycleState.OPEN) {
      return;
    }
    this._restartTask.schedule();
  }
};
_ts_decorate([
  synchronized
], PersistentLifecycle.prototype, "_open", null);
_ts_decorate([
  synchronized
], PersistentLifecycle.prototype, "scheduleRestart", null);

// packages/common/async/src/push-iterable.ts
import { invariant as invariant2 } from "@dxos/invariant";
var __dxlog_file5 = "/home/runner/work/dxos/dxos/packages/common/async/src/push-iterable.ts";
var makePushIterable = () => {
  const buf = [];
  const trigger2 = new Trigger({
    autoReset: true
  });
  return {
    [Symbol.asyncIterator]() {
      return {
        next: async () => {
          while (buf.length === 0) {
            await trigger2.wait();
          }
          const item = buf.shift();
          invariant2(item, void 0, {
            F: __dxlog_file5,
            L: 42,
            S: this,
            A: [
              "item",
              ""
            ]
          });
          switch (item.kind) {
            case "next":
              return {
                value: item.value,
                done: false
              };
            case "return":
              return {
                value: item.value,
                done: true
              };
            case "throw":
              throw item.value;
          }
        }
      };
    },
    next: (value) => {
      buf.push({
        kind: "next",
        value
      });
      trigger2.wake();
    },
    return: (value) => {
      buf.push({
        kind: "return",
        value
      });
      trigger2.wake();
    },
    throw: (value) => {
      buf.push({
        kind: "throw",
        value
      });
      trigger2.wake();
    }
  };
};

// packages/common/async/src/sink.ts
var sink = (emitter, event, count = 1) => {
  const [getPromise, resolve] = trigger();
  let counter = 0;
  const listener = () => {
    if (++counter === count) {
      emitter.off(event, listener);
      resolve();
    }
  };
  emitter.on(event, listener);
  return getPromise();
};

// packages/common/async/src/stream-to-array.ts
var streamToArray = (stream) => {
  let deferred;
  if (!stream.readable) {
    deferred = Promise.resolve([]);
  } else {
    deferred = new Promise((resolve, reject) => {
      if (!stream.readable) {
        return resolve([]);
      }
      let arr = [];
      const onData = (doc) => {
        arr?.push(doc);
      };
      const onEnd = (err) => {
        if (err) {
          reject(err);
        } else {
          resolve(arr);
        }
        cleanup();
      };
      const onClose = () => {
        resolve(arr);
        cleanup();
      };
      const cleanup = () => {
        arr = [];
        stream.removeListener("data", onData);
        stream.removeListener("end", onEnd);
        stream.removeListener("error", onEnd);
        stream.removeListener("close", onClose);
      };
      stream.on("data", onData);
      stream.on("end", onEnd);
      stream.on("error", onEnd);
      stream.on("close", onClose);
    });
  }
  return deferred;
};

// packages/common/async/src/test-stream.ts
import { Duplex } from "node:stream";
var TestStream = class extends Duplex {
  constructor() {
    super(...arguments);
    this._received = Buffer.alloc(0);
    this._onWrite = new Event();
  }
  static async assertConnectivity(stream1, stream2, { timeout: timeout2 = 200 } = {}) {
    stream1.push("ping");
    stream2.push("pong");
    await Promise.all([
      stream2.assertReceivedAsync("ping", {
        timeout: timeout2
      }),
      stream1.assertReceivedAsync("pong", {
        timeout: timeout2
      })
    ]);
  }
  _write(chunk, encoding, callback) {
    this._received = Buffer.concat([
      this._received,
      chunk
    ]);
    this._onWrite.emit();
    callback();
  }
  _read(size) {
  }
  assertReceivedAsync(data, { timeout: timeout2 = 200 } = {}) {
    const dataBuffer = Buffer.isBuffer(data) ? data : Buffer.from(data);
    return asyncTimeout(this._onWrite.waitForCondition(() => this._received.equals(dataBuffer)), timeout2);
  }
};

// packages/common/async/src/testing.ts
var waitForCondition = ({ condition, timeout: timeout2 = 0, interval: interval2 = 10, error, breakOnError = false }) => {
  const stopTime = timeout2 ? Date.now() + timeout2 : 0;
  const trigger2 = new Trigger();
  const waiter = async () => {
    while (!stopTime || Date.now() < stopTime) {
      try {
        const value = await condition();
        if (value) {
          trigger2.wake(value);
          break;
        }
      } catch (err) {
        if (breakOnError === true) {
          trigger2.throw(err);
        }
      }
      await sleep(interval2);
    }
  };
  setTimeout(waiter, 0);
  return trigger2.wait({
    timeout: timeout2
  });
};

// packages/common/async/src/timer.ts
var Timer = class {
  constructor(_callback) {
    this._callback = _callback;
    this._state = new Event();
    this._count = 0;
  }
  get state() {
    return this._state;
  }
  get running() {
    return !!this._timer;
  }
  start(options, cb) {
    if (isNaN(options.count) || isNaN(options.interval)) {
      throw new Error(`Invalid options: ${JSON.stringify(options)}`);
    }
    if (this.running) {
      this.stop();
    }
    const stop = () => {
      this.stop();
      cb?.();
    };
    const run = () => {
      if (this._count >= (options.count ?? 0)) {
        stop();
      } else {
        const interval2 = (options.interval ?? 0) + Math.random() * (options.jitter ?? 0);
        this._timer = setTimeout(async () => {
          await this._callback(this._count++);
          run();
        }, interval2);
      }
    };
    this._state.emit(true);
    this._count = 0;
    setTimeout(run);
    return this;
  }
  stop() {
    clearInterval(this._timer);
    this._timer = void 0;
    this._state.emit(false);
    return this;
  }
};

// packages/common/async/src/until.ts
var until = (cb, timeout2) => {
  return new Promise((resolve, reject) => {
    const t = timeout2 && setTimeout(() => {
      reject(new Error(`Timeout after ${t}ms`));
    }, timeout2);
    setTimeout(async () => {
      try {
        await cb((value) => {
          t && clearTimeout(t);
          resolve(value);
        }, (error) => {
          t && clearTimeout(t);
          reject(error);
        });
      } catch (err) {
        reject(err);
      }
    });
  });
};
var untilPromise = (cb) => cb();
var untilError = (cb) => {
  return new Promise((resolve, reject) => {
    setTimeout(async () => {
      try {
        await cb();
        reject(new Error("No error was thrown."));
      } catch (err) {
        resolve(err);
      }
    });
  });
};

// packages/common/async/src/update-scheduler.ts
var TIME_PERIOD = 1e3;
var UpdateScheduler = class {
  constructor(_ctx, _callback, _params = {}) {
    this._ctx = _ctx;
    this._callback = _callback;
    this._params = _params;
    this._promise = null;
    this._scheduled = false;
    this._lastUpdateTime = -TIME_PERIOD;
    _ctx.onDispose(async () => {
      await this._promise;
    });
  }
  trigger() {
    if (this._scheduled) {
      return;
    }
    scheduleMicroTask(this._ctx, async () => {
      await this._promise;
      if (this._params.maxFrequency) {
        const now = performance.now();
        const delay = this._lastUpdateTime + TIME_PERIOD / this._params.maxFrequency - now;
        if (delay > 0) {
          await new Promise((resolve) => {
            const timeoutId = setTimeout(() => {
              clearContext();
              resolve();
            }, delay);
            const clearContext = this._ctx.onDispose(() => {
              clearTimeout(timeoutId);
              resolve();
            });
          });
        }
      }
      if (this._ctx.disposed) {
        return;
      }
      this._lastUpdateTime = performance.now();
      this._scheduled = false;
      this._promise = this._callback().then(() => {
        this._promise = null;
      }, (error) => {
        this._promise = null;
        this._ctx.raise(error);
      });
    });
    this._scheduled = true;
  }
  forceTrigger() {
    scheduleMicroTask(this._ctx, async () => {
      this._callback().catch((err) => this._ctx.raise(err));
    });
  }
  /**
  * Waits for the current task to finish if it is running.
  * Does not schedule a new task.
  */
  async join() {
    await this._promise;
  }
  /**
  * Force schedule the task to run and wait for it to finish.
  */
  async runBlocking() {
    await this._promise;
    this._promise = this._callback();
    await this._promise;
  }
};
export {
  CancellableObservableProvider,
  DeferredTask,
  Event,
  MulticastObservable,
  Mutex,
  MutexGuard,
  Observable,
  ObservableProvider,
  PersistentLifecycle,
  PushStream,
  SubscriptionList,
  SubscriptionSet,
  TestStream,
  TimeoutError,
  Timer,
  Trigger,
  TriggerState,
  UpdateScheduler,
  addEventListener,
  addListener,
  asyncChain,
  asyncReturn,
  asyncTimeout,
  combine,
  createPromiseFromCallback,
  debounce,
  dumpLeaks,
  interval,
  latch,
  makePushIterable,
  observableError,
  onEvent,
  runInContext,
  runInContextAsync,
  scheduleExponentialBackoffTaskInterval,
  scheduleMicroTask,
  scheduleTask,
  scheduleTaskInterval,
  sink,
  sleep,
  sleepWithContext,
  streamToArray,
  synchronized,
  timeout,
  toError,
  trackLeaks,
  trackResource,
  trigger,
  unrefTimeout,
  until,
  untilError,
  untilPromise,
  waitForCondition,
  waitForEvent
};
//# sourceMappingURL=index.mjs.map
