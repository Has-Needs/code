{
  "version": 3,
  "sources": ["../../../src/callback.ts", "../../../src/chain.ts", "../../../src/cleanup.ts", "../../../src/debounce.ts", "../../../src/errors.ts", "../../../src/timeout.ts", "../../../src/event-emitter.ts", "../../../src/events.ts", "../../../src/latch.ts", "../../../src/mutex.ts", "../../../src/observable.ts", "../../../src/trigger.ts", "../../../src/observable-value.ts", "../../../src/persistent-lifecycle.ts", "../../../src/task-scheduling.ts", "../../../src/track-leaks.ts", "../../../src/push-iterable.ts", "../../../src/sink.ts", "../../../src/stream-to-array.ts", "../../../src/test-stream.ts", "../../../src/testing.ts", "../../../src/timer.ts", "../../../src/until.ts", "../../../src/update-scheduler.ts"],
  "sourcesContent": ["//\n// Copyright 2020 DXOS.org\n//\n\n/**\n * Helper to convert a callback based API into a promise based API.\n */\nexport const createPromiseFromCallback = <T = void>(\n  run: (cb: (error?: Error, value?: T) => void) => void,\n): Promise<T> =>\n  new Promise((resolve, reject) => {\n    run((error, value) => {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(value!);\n      }\n    });\n  });\n", "//\n// Copyright 2022 DXOS.org\n//\n\ntype Transform = (...args: any) => Promise<any>;\n\n/**\n * Async reducer iteratively applies functions to the given array of elements.\n */\nexport const asyncChain =\n  <T>(chain: Transform[]) =>\n  async (elements: Promise<T[]>) => {\n    let result = await elements;\n    for (const part of chain) {\n      result = await Promise.all(result.map(async (element) => await part(element)));\n    }\n\n    return result;\n  };\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { ComplexMap, type PrimitiveProjection } from '@dxos/util';\n\nexport type CleanupFn = () => void;\n\n/**\n * Combine multiple cleanup functions into a single cleanup function.\n * Can be used in effect hooks in conjunction with `addEventListener`.\n */\nexport const combine = (...cleanupFns: (CleanupFn | CleanupFn[])[]): CleanupFn => {\n  return () => {\n    cleanupFns.flat().forEach((cleanupFn) => cleanupFn());\n  };\n};\n\nexport const timeout = (cb: Function, ms = 0): CleanupFn => {\n  const t = setTimeout(cb, ms);\n  return () => clearTimeout(t);\n};\n\nexport const interval = (cb: Function, ms: number): CleanupFn => {\n  const t = setInterval(cb, ms);\n  return () => clearInterval(t);\n};\n\ntype EventMap<T> = T extends Window\n  ? WindowEventMap\n  : T extends Document\n    ? DocumentEventMap\n    : T extends HTMLElement\n      ? HTMLElementEventMap\n      : Record<string, Event>;\n\n/**\n * Add the event listener and return a cleanup function.\n * Can be used in effect hooks in conjunction with `combine`.\n */\nexport function addEventListener<T extends EventTarget, K extends keyof EventMap<T>>(\n  target: T,\n  type: K,\n  listener: (this: T, ev: EventMap<T>[K]) => any,\n  options?: boolean | AddEventListenerOptions,\n): CleanupFn {\n  target.addEventListener(type as string, listener as EventListener, options);\n  return () => target.removeEventListener(type as string, listener as EventListener, options);\n}\n\nexport class SubscriptionList {\n  private readonly _cleanups: CleanupFn[] = [];\n\n  add(cb: CleanupFn): this {\n    this._cleanups.push(cb);\n    return this;\n  }\n\n  clear(): void {\n    this._cleanups.forEach((cb) => cb());\n    this._cleanups.length = 0;\n  }\n}\n\nexport class SubscriptionSet<T = any> {\n  private readonly _cleanupMap: ComplexMap<T, CleanupFn>;\n\n  constructor(keyProjection: PrimitiveProjection<T>) {\n    this._cleanupMap = new ComplexMap<T, CleanupFn>(keyProjection);\n  }\n\n  set(key: T, cb: CleanupFn): this {\n    this._cleanupMap.set(key, cb);\n    return this;\n  }\n\n  clear(): void {\n    this._cleanupMap.forEach((cb) => cb());\n    this._cleanupMap.clear();\n  }\n}\n", "//\n// Copyright 2023 DXOS.org\n//\n\n/**\n * Debounce callback.\n */\nexport const debounce = (cb: (...args: any[]) => void, wait = 100): ((...args: any[]) => void) => {\n  let t: ReturnType<typeof setTimeout>;\n  return (...args: any[]) => {\n    clearTimeout(t);\n    t = setTimeout(() => cb(...args), wait);\n  };\n};\n", "//\n// Copyright 2020 DXOS.org\n//\n\nimport { type ObservableProvider } from './observable-value';\n\n// TODO(burdon): Move to debug.\n//  Use: https://nodejs.org/api/errors.html\nexport const toError = (err: any) => (err === undefined || typeof err === 'string' ? new Error(err) : err);\n\nexport class TimeoutError extends Error {\n  constructor(timeout?: number, label?: string) {\n    super(timeout ? `Timeout [${timeout.toLocaleString()}ms]${label === undefined ? '' : `: ${label}`}` : 'Timeout');\n  }\n}\n\nexport interface AsyncEvents<T = any> {\n  onSuccess?(result: T): void;\n  onTimeout?(err: TimeoutError): void;\n  onError(err: any): void;\n}\n\nexport const observableError = (observable: ObservableProvider<AsyncEvents>, err: any) => {\n  if (err instanceof TimeoutError) {\n    observable.callback.onTimeout?.(err);\n  } else {\n    observable.callback.onError(toError(err));\n  }\n};\n", "//\n// Copyright 2020 DXOS.org\n//\n\nimport { type Context, ContextDisposedError } from '@dxos/context';\n\nimport { createPromiseFromCallback } from './callback';\nimport { TimeoutError } from './errors';\n\n/**\n * Times out after delay.\n */\nexport const sleep = (ms: number) => {\n  return new Promise<void>((resolve) => {\n    const finish = Date.now() + ms;\n\n    // `setTimeout` does not guarantee execution at >= the scheduled time and may execute slightly early.\n    const sleeper = () => {\n      const delta = finish - Date.now();\n      if (delta > 0) {\n        setTimeout(sleeper, delta);\n      } else {\n        resolve();\n      }\n    };\n\n    sleeper();\n  });\n};\n\n/**\n * Can be used in long-running tasks to let other callbacks be invoked.\n */\nexport const asyncReturn = () => sleep(0);\n\n/**\n * Wait for promise or throw error.\n */\nexport const asyncTimeout = async <T>(\n  // TODO(dmaretskyi): This callback API is unintuitive and leads to bugs.\n  promise: Promise<T> | (() => Promise<T>),\n  timeout: number,\n  err?: Error | string,\n): Promise<T> => {\n  let timeoutId: NodeJS.Timeout;\n  const throwable = err === undefined || typeof err === 'string' ? new TimeoutError(timeout, err) : err;\n  const timeoutPromise = new Promise<T>((resolve, reject) => {\n    timeoutId = setTimeout(() => {\n      reject(throwable);\n    }, timeout);\n\n    unrefTimeout(timeoutId);\n  });\n\n  const conditionTimeout = typeof promise === 'function' ? createPromiseFromCallback<T>(promise) : promise;\n  return await Promise.race([conditionTimeout, timeoutPromise]).finally(() => {\n    clearTimeout(timeoutId);\n  });\n};\n\n/**\n * In Node.JS, `unref` prevents the timeout from blocking the process from exiting. Not available in browsers.\n * https://nodejs.org/api/timers.html#timeoutunref\n */\nexport const unrefTimeout = (timeoutId: NodeJS.Timeout) => {\n  if (typeof timeoutId === 'object' && 'unref' in timeoutId) {\n    timeoutId.unref();\n  }\n};\n\nexport const sleepWithContext = (ctx: Context, ms: number) => {\n  const error = new ContextDisposedError();\n  return new Promise<void>((resolve, reject) => {\n    if (ctx.disposed) {\n      reject(error);\n      return;\n    }\n\n    const timeout = setTimeout(() => {\n      clearDispose();\n      resolve();\n    }, ms);\n\n    const clearDispose = ctx.onDispose(() => {\n      clearTimeout(timeout);\n      reject(error);\n    });\n  });\n};\n", "//\n// Copyright 2020 DXOS.org\n//\n\nimport { type EventEmitter } from 'node:events';\n\nimport { asyncTimeout } from './timeout';\n\n/**\n * Adds the listener and returns a function to remove it.\n * Promotes removing listeners when cleaning up objects (to prevent leaks).\n */\nexport const onEvent = (eventEmitter: EventEmitter, eventName: string, callback: (args: any) => void) => {\n  eventEmitter.on(eventName, callback);\n  return () => eventEmitter.off(eventName, callback);\n};\n\n/**\n * @deprecated\n */\nexport const addListener = (eventEmitter: EventEmitter, eventName: string, callback: () => void) => {\n  const off = onEvent(eventEmitter, eventName, callback);\n  return {\n    remove: () => off(),\n  };\n};\n\n/**\n * Waits for an event with an optional test condition.\n */\nexport const waitForEvent = (\n  eventEmitter: EventEmitter,\n  eventName: string,\n  test?: (args: any) => boolean,\n  timeout?: number,\n  error?: Error | string,\n): Promise<any> => {\n  let off;\n\n  const promise = new Promise((resolve) => {\n    off = onEvent(eventEmitter, eventName, (...args) => {\n      if (!test || test(...args)) {\n        resolve(...args);\n      }\n    });\n  });\n\n  return timeout ? asyncTimeout(promise, timeout, error ?? new Error()).finally(off) : promise.finally(off);\n};\n", "//\n// Copyright 2020 DXOS.org\n//\n\nimport { Context } from '@dxos/context';\nimport { type MaybePromise } from '@dxos/util';\n\nimport { type CleanupFn } from './cleanup';\n\nexport type Effect = () => CleanupFn | undefined;\n\n/**\n * Effect that's been added to a specific Event.\n */\ninterface MaterializedEffect {\n  effect: Effect;\n  cleanup: CleanupFn | undefined;\n}\n\ninterface EventEmitterLike {\n  on(event: string, cb: (data?: any) => void): void;\n  off(event: string, cb: (data?: any) => void): void;\n}\n\nexport type ListenerOptions = {\n  weak?: boolean;\n  once?: boolean;\n};\n\ntype EventCallback<T> = (data: T) => MaybePromise<void>;\n\n// TODO(dmaretskyi): Remove this once the code is cleaned up.\nconst DO_NOT_ERROR_ON_ASYNC_CALLBACK = true;\n\n/**\n * An EventEmitter variant that does not do event multiplexing and represents a single event.\n *\n * ## Typical usage:\n * ```javascript\n * class Model {\n *   public readonly update = new Event<UpdateData>();\n *   private readonly privateEvent = new Event<void>();\n *\n *   onUpdate(data: UpdateData) {\n *     ...\n *     this.update.emit(data);\n *   }\n * }\n *\n * model.update.on(data => {\n *   ...\n * });\n * ```\n *\n * ## Advantages over traditional EventEmitter:\n * 1. User describes explicitly what events a class has as they are defined as class fields.\n * 2. User can explicitly define event visibility (public, protected, private).\n * 3. Having events as class fields allows the compiler to check for correct event usage.\n * 4. User can type the data that event will be emitting.\n * 5. Uses composition instead of inheritance.\n * 6. Removes the cases where event names intersect when used in cases with inheritance.\n * 7. Remove the need to namespace events when developing a class with events that will be used as a base-class.\n */\n// TODO(burdon): Rename EventSink? (Event is a built-in type).\nexport class Event<T = void> implements ReadOnlyEvent<T> {\n  /**\n   * Wrap objects that have on/off style event emitters.\n   */\n  static wrap<T>(emitter: EventEmitterLike, eventName: string): Event<T> {\n    const event = new Event<T>();\n\n    event.addEffect(() => {\n      const onEvent = (data: any) => event.emit(data);\n      emitter.on(eventName, onEvent);\n      return () => emitter.off(eventName, onEvent);\n    });\n\n    return event;\n  }\n\n  private readonly _listeners = new Set<EventListener<T>>();\n  private readonly _effects = new Set<MaterializedEffect>();\n\n  /**\n   * Emit an event.\n   * In most cases should only be called by the class or entity containing the event.\n   * All listeners are called in order of subscription with persistent ones first.\n   * Listeners are called synchronously in the same stack.\n   * A thrown exception in the listener will stop the event from being emitted to the rest of the listeners.\n   *\n   * @param data param that will be passed to all listeners.\n   */\n  emit(data: T): void {\n    for (const listener of this._listeners) {\n      listener.trigger(data);\n\n      if (listener.once) {\n        this._listeners.delete(listener);\n      }\n    }\n  }\n\n  /**\n   * Emit an event and wait for async listeners to complete.\n   * In most cases should only be called by the class or entity containing the event.\n   * All listeners are called in order of subscription with persistent ones first.\n   * Listeners are called sequentially.\n   *\n   * @param data param that will be passed to all listeners.\n   */\n  async emitAsync(data: T): Promise<void> {\n    for (const listener of this._listeners) {\n      await listener.triggerAsync(data);\n\n      if (listener.once) {\n        this._listeners.delete(listener);\n      }\n    }\n  }\n\n  /**\n   * Register an event listener.\n   * If provided callback was already registered as once-listener, it is made permanent.\n   *\n   * @param callback\n   * @param options.weak If true, the callback will be weakly referenced and will be garbage collected if no other references to it exist.\n   * @returns function that unsubscribes this event listener\n   */\n  on(callback: EventCallback<T>): CleanupFn;\n  on(ctx: Context, callback: EventCallback<T>, options?: ListenerOptions): CleanupFn;\n  on(_ctx: any, _callback?: EventCallback<T>, options?: ListenerOptions): CleanupFn {\n    const [ctx, callback] = _ctx instanceof Context ? [_ctx, _callback] : [new Context(), _ctx];\n    const weak = !!options?.weak;\n    const once = !!options?.once;\n\n    const listener = new EventListener(this, callback, ctx, once, weak);\n\n    this._addListener(listener);\n\n    return () => {\n      this._removeListener(listener);\n    };\n  }\n\n  /**\n   * Unsubscribe this callback from new events. Includes persistent and once-listeners.\n   * NOTE: It is recommended to use `Event.on`'s return value instead.\n   * If the callback is not subscribed this is no-op.\n   *\n   * @param callback\n   */\n  off(callback: (data: T) => void): void {\n    for (const listener of this._listeners) {\n      if (listener.derefCallback() === callback) {\n        this._removeListener(listener);\n      }\n    }\n  }\n\n  /**\n   * Register a callback to be called only once when the next event is emitted.\n   * If this callback is already registered as permanent listener, this is no-op.\n   *\n   * @param callback\n   */\n  once(callback: (data: T) => void): CleanupFn;\n  once(ctx: Context, callback: (data: T) => void): CleanupFn;\n  once(_ctx: any, _callback?: (data: T) => void): CleanupFn {\n    const [ctx, callback] = _ctx instanceof Context ? [_ctx, _callback] : [new Context(), _ctx];\n\n    const listener = new EventListener(this, callback, ctx, true, false);\n\n    this._addListener(listener);\n\n    return () => {\n      this._removeListener(listener);\n    };\n  }\n\n  /**\n   * An async iterator that iterates over events.\n   * This iterator runs indefinitely.\n   */\n  async *[Symbol.asyncIterator](): AsyncIterator<T> {\n    while (true) {\n      yield await new Promise((resolve) => {\n        this.once(resolve);\n      });\n    }\n  }\n\n  /**\n   * Returns a promise that resolves with the first event emitted that matches the provided predicate.\n   *\n   * @param predicate\n   */\n  waitFor(predicate: (data: T) => boolean): Promise<T> {\n    return new Promise((resolve) => {\n      const unsubscribe = this.on((data) => {\n        if (predicate(data)) {\n          unsubscribe();\n          resolve(data);\n        }\n      });\n    });\n  }\n\n  /**\n   * Returns a promise that resolves once a specific number of events was emitted since this method was called.\n   *\n   * @param expectedCount\n   */\n  waitForCount(expectedCount: number): Promise<T> {\n    let count = 0;\n    return this.waitFor(() => ++count === expectedCount);\n  }\n\n  /**\n   * Similar to waitFor, but the promise resolves immediately if the condition is already true.\n   */\n  // TODO(burdon): Should pass event property to predicate.\n  async waitForCondition(predicate: () => boolean): Promise<void> {\n    if (!predicate()) {\n      await this.waitFor(predicate);\n    }\n  }\n\n  /**\n   * Returns the number of persistent listeners.\n   */\n  listenerCount(): number {\n    return this._listeners.size;\n  }\n\n  /**\n   * Add a side effect that will be activated once the event has at least one subscriber.\n   * The provided callback can return a function that will be used to clean up after the last subscriber unsubscribes from the event.\n   * The API is similar to `useEffect` from React.\n   *\n   * ## Example:\n   * ```typescript\n   * event.addEffect(() => {\n   *   // do stuff\n   *   return () => {\n   *     // clean-up\n   *   };\n   * });\n   * ```\n   *\n   * @returns Callback that will remove this effect once called.\n   */\n  addEffect(effect: Effect): CleanupFn {\n    const handle: MaterializedEffect = { effect, cleanup: undefined };\n\n    if (this.listenerCount() > 0) {\n      handle.cleanup = handle.effect();\n    }\n\n    this._effects.add(handle);\n    return () => {\n      // eslint-disable-next-line no-unused-expressions\n      handle.cleanup?.();\n      this._effects.delete(handle);\n    };\n  }\n\n  /**\n   * Triggers an event with at least `timeout` milliseconds between each event.\n   * If the event is triggered more often, the event is delayed until the timeout is reached.\n   * If event is emitted for the first time or event wasn't fired for `timeout` milliseconds,\n   * the event is emitted after `timeout / 8` ms.\n   */\n  // TODO(burdon): Factor out generic function.\n  debounce(timeout = 0): Event<void> {\n    let firing: NodeJS.Timeout | undefined;\n    let lastFired: number | undefined;\n\n    const debouncedEvent = new Event<void>();\n    debouncedEvent.addEffect(() => {\n      const unsubscribe = this.on(() => {\n        if (!firing) {\n          const fireIn = !lastFired || Date.now() - lastFired > timeout ? timeout / 8 : timeout;\n          firing = setTimeout(() => {\n            lastFired = Date.now();\n            firing = undefined;\n            debouncedEvent.emit();\n          }, fireIn);\n        }\n      });\n\n      return () => {\n        unsubscribe();\n        clearTimeout(firing);\n      };\n    });\n\n    return debouncedEvent;\n  }\n\n  /**\n   * Turn any variant of `Event<T>` into an `Event<void>` discarding the callback parameter.\n   */\n  discardParameter(): Event<void> {\n    return this as any;\n  }\n\n  /**\n   * Pipe the events into another event.\n   * @param event\n   */\n  pipeInto(event: Event<T>): CleanupFn {\n    return this.on((data) => event.emit(data));\n  }\n\n  /**\n   * Overridden to not return implementation details.\n   */\n  toJSON(): { listenerCount: number } {\n    return {\n      listenerCount: this.listenerCount(),\n    };\n  }\n\n  private _addListener(listener: EventListener<T>): void {\n    this._listeners.add(listener);\n\n    if (this.listenerCount() === 1) {\n      this._runEffects();\n    }\n  }\n\n  /**\n   * @internal\n   */\n  _removeListener(listener: EventListener<T>): void {\n    this._listeners.delete(listener);\n    listener.remove();\n\n    if (this.listenerCount() === 0) {\n      this._cleanupEffects();\n    }\n  }\n\n  private _runEffects(): void {\n    for (const handle of this._effects) {\n      handle.cleanup = handle.effect();\n    }\n  }\n\n  private _cleanupEffects(): void {\n    for (const handle of this._effects) {\n      // eslint-disable-next-line no-unused-expressions\n      handle.cleanup?.();\n      handle.cleanup = undefined;\n    }\n  }\n}\n\n/**\n * A version of Event class which only has subscribe methods.\n * Useful in cases where you want to explicitly prohibit calling `emit` method.\n */\nexport interface ReadOnlyEvent<T = void> {\n  /**\n   * Register an event listener.\n   * If provided callback was already registered as once-listener, it is made permanent.\n   *\n   * @param callback\n   * @param options.weak If true, the callback will be weakly referenced and will be garbage collected if no other references to it exist.\n   * @returns function that unsubscribes this event listener\n   */\n  on(callback: (data: T) => void): CleanupFn;\n  on(ctx: Context, callback: (data: T) => void, options?: ListenerOptions): CleanupFn;\n\n  /**\n   * Unsubscribes this callback from new events. Includes persistent and once-listeners.\n   * NOTE: It is recommended to us `Event.on`'s return value.\n   * If the callback is not subscribed this is no-op.\n   *\n   * @param callback\n   */\n  off(callback: (data: T) => void): void;\n\n  /**\n   * Register a callback to be called only once when the next event is emitted.\n   * If this callback is already registered as permanent listener, this is no-op.\n   *\n   * @param callback\n   */\n  once(callback: (data: T) => void): CleanupFn;\n\n  /**\n   * An async iterator that iterates over events.\n   * This iterator runs indefinitely.\n   */\n  [Symbol.asyncIterator](): AsyncIterator<T>;\n\n  /**\n   * Returns a promise that resolves with the first event emitted that matches the provided predicate.\n   *\n   * @param predicate\n   */\n  waitFor(predicate: (data: T) => boolean): Promise<T>;\n\n  /**\n   * Returns a promise that resolves once a specific number of events was emitted since this method was called.\n   *\n   * @param expectedCount\n   */\n  waitForCount(expectedCount: number): Promise<T>;\n\n  /**\n   * Turn any variant of `Event<T>` into an `Event<void>` discarding the callback parameter.\n   */\n  discardParameter(): Event<void>;\n\n  /**\n   * Triggers an event with at least `timeout` milliseconds between each event.\n   * If the event is triggered more often, the event is delayed until the timeout is reached.\n   * If event is emitted for the first time or event wasn't fired for `timeout` milliseconds,\n   * the event is emitted after `timeout / 8` ms.\n   */\n  debounce(timeout?: number): Event<void>;\n}\n\nclass EventListener<T> {\n  public readonly callback: EventCallback<T> | WeakRef<EventCallback<T>>;\n\n  private readonly _clearDispose?: () => void = undefined;\n\n  constructor(\n    event: Event<T>,\n    listener: EventCallback<T>,\n    public readonly ctx: Context,\n    public readonly once: boolean,\n    public readonly weak: boolean,\n  ) {\n    this._clearDispose = ctx.onDispose(() => {\n      event._removeListener(this);\n    });\n\n    if (weak) {\n      this.callback = new WeakRef(listener);\n      weakListeners().registry?.register(\n        listener,\n        {\n          event: new WeakRef(event),\n          listener: this,\n        },\n        this,\n      );\n    } else {\n      this.callback = listener;\n    }\n  }\n\n  derefCallback(): EventCallback<T> | undefined {\n    return this.weak ? (this.callback as WeakRef<EventCallback<T>>).deref() : (this.callback as EventCallback<T>);\n  }\n\n  trigger(data: T): void {\n    let result!: MaybePromise<void>;\n    try {\n      const callback = this.derefCallback();\n      result = callback?.(data);\n    } catch (err: any) {\n      this.ctx.raise(err);\n    }\n\n    if (!DO_NOT_ERROR_ON_ASYNC_CALLBACK) {\n      if (result instanceof Promise) {\n        throw new TypeError('Event has async callbacks, use emitAsync instead');\n      }\n    }\n  }\n\n  async triggerAsync(data: T): Promise<void> {\n    try {\n      const callback = this.derefCallback();\n      await callback?.(data);\n    } catch (err: any) {\n      this.ctx.raise(err);\n    }\n  }\n\n  remove(): void {\n    this._clearDispose?.();\n    weakListeners().registry?.unregister(this);\n  }\n}\n\ntype HeldValue = {\n  event: WeakRef<Event<any>>;\n  listener: EventListener<any>;\n};\n\nlet weakListenersState: FinalizationRegistry<HeldValue> | null = null;\n\ntype WeakListeners = {\n  registry: FinalizationRegistry<HeldValue> | undefined;\n};\n\nconst FINALIZATION_REGISTRY_SUPPORTED = !!globalThis.FinalizationRegistry;\n\nconst weakListeners = (): WeakListeners => {\n  if (!FINALIZATION_REGISTRY_SUPPORTED) {\n    return { registry: undefined };\n  }\n  weakListenersState ??= new FinalizationRegistry(({ event, listener }) => {\n    event.deref()?._removeListener(listener);\n  });\n  return { registry: weakListenersState };\n};\n", "//\n// Copyright 2020 DXOS.org\n//\n\nimport { invariant } from '@dxos/invariant';\n\ntype LatchProps = {\n  count?: number;\n  timeout?: number;\n};\n\ntype LatchResult = [() => Promise<number>, () => number, (err: Error) => void];\n\n/**\n * Returns a callback and a promise that's resolved when the callback is called n times.\n */\n// TODO(burdon): Reconcile with until/trigger.\nexport const latch = ({ count = 1, timeout }: LatchProps = {}): LatchResult => {\n  invariant(count >= 0);\n\n  let t: ReturnType<typeof setTimeout>;\n  let doResolve: (value: number) => void;\n  let doReject: (err: Error) => void;\n  const promise = new Promise<number>((resolve, reject) => {\n    doResolve = (value) => {\n      clearTimeout(t);\n      resolve(value);\n    };\n\n    doReject = (err) => {\n      clearTimeout(t);\n      reject(err);\n    };\n  });\n\n  if (count === 0) {\n    setTimeout(() => {\n      doResolve(0);\n    });\n  } else {\n    if (timeout) {\n      t = setTimeout(() => {\n        doReject(new Error(`Timed out after ${timeout.toLocaleString()}ms`));\n      }, timeout);\n    }\n  }\n\n  let i = 0;\n  return [\n    async () => await promise,\n    () => {\n      if (++i === count) {\n        doResolve(i);\n      }\n\n      return i;\n    },\n    (err: Error) => doReject(err),\n  ];\n};\n", "//\n// Copyright 2020 DXOS.org\n//\n\n// Import explicit resource management polyfill.\nimport '@dxos/util';\nimport { warnAfterTimeout } from '@dxos/debug';\n\n/**\n * A locking mechanism to ensure that a given section of the code is executed by only one single \"thread\" at a time.\n *\n * Functions are chained in a structure similar to a linked list.\n * `_lastPromise` always contains the function that will finish executing last.\n *\n * Initially it is set to `Promise.resolve()` -- a promise that resolves immediately.\n * Enqueuing is done by attaching provided function to the `_lastPromise` via a `.then()` call\n * then updating the `_lastPromise` variable.\n *\n * It is important that enqueuing is done atomically:\n * there are no `await`s in `executeSynchronized` and it's not async while still returning a promise.\n *\n * Java docs reference on synchronized sections:\n * https://docs.oracle.com/javase/tutorial/essential/concurrency/locksync.html\n */\nexport class Mutex {\n  private _queue = Promise.resolve();\n  private _queueLength = 0;\n\n  private _tag: string | null = null;\n\n  get tag() {\n    return this._tag;\n  }\n\n  isLocked(): boolean {\n    return this._queueLength > 0;\n  }\n\n  /**\n   * Acquires the lock.\n   * Caller is responsible for releasing the lock using the returned callback.\n   * NOTE: Using `executeSynchronized` is preferred over using `acquire` directly.\n   * @returns Release callback\n   */\n  async acquire(tag?: string): Promise<MutexGuard> {\n    const prev = this._queue;\n\n    // Immediately update the promise before invoking any async actions so that next invocation waits for our task to complete.\n    let guard!: MutexGuard;\n    this._queueLength++;\n    this._queue = new Promise((resolve) => {\n      guard = new MutexGuard(() => {\n        this._queueLength--;\n        this._tag = null;\n        resolve();\n      });\n    });\n\n    await prev;\n\n    if (tag !== undefined) {\n      this._tag = tag;\n    }\n    return guard;\n  }\n\n  /**\n   * Waits for all previous executions to complete and then executes a given function.\n   * Only a single function can be executed at a time.\n   * Function are executed in the same order as `executeSynchronized` is called.\n   * WARNING: Calling `executeSynchronized` inside of `executeSynchronized` on the same lock instance is a deadlock.\n   */\n  async executeSynchronized<T>(fun: () => Promise<T>): Promise<T> {\n    const guard = await this.acquire();\n\n    try {\n      return await fun();\n    } finally {\n      guard.release();\n    }\n  }\n}\n\nexport class MutexGuard {\n  constructor(private readonly _release: () => void) {}\n\n  /**\n   * Releases the lock.\n   */\n  release(): void {\n    this._release();\n  }\n\n  [Symbol.dispose](): void {\n    this.release();\n  }\n}\n\nconst classMutexSymbol = Symbol('class-mutex');\n\ninterface LockableClass {\n  [classMutexSymbol]?: Mutex;\n}\n\nconst FORCE_DISABLE_WARNING = false;\n\n// Enabled only in tests by default.\nconst enableWarning = !FORCE_DISABLE_WARNING && (globalThis as any).mochaExecutor;\n\n/**\n * Same as `synchronized` in Java.\n * Uses a lock global to the current class instance.\n * This way every synchronized method on the same instance will share a single lock.\n */\nexport const synchronized = (\n  target: any,\n  propertyName: string,\n  descriptor: TypedPropertyDescriptor<(...args: any) => Promise<any>>,\n) => {\n  const method = descriptor.value!;\n  descriptor.value = async function synchronizedMethod(this: any & LockableClass, ...args: any) {\n    const mutex: Mutex = (this[classMutexSymbol] ??= new Mutex());\n\n    const tag = `${target.constructor.name}.${propertyName}`;\n\n    // Disable warning in prod to avoid performance penalty.\n    let guard;\n    if (!enableWarning) {\n      guard = await mutex.acquire(tag);\n    } else {\n      guard = await warnAfterTimeout(10_000, `lock on ${tag} (taken by ${mutex.tag})`, () => mutex.acquire(tag));\n    }\n\n    try {\n      return await method.apply(this, args);\n    } finally {\n      guard.release();\n    }\n  };\n  Object.defineProperty(descriptor.value, 'name', { value: propertyName + '$synchronized' });\n};\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport Observable from 'zen-observable';\nimport type { ObservableLike, Observer, Subscriber } from 'zen-observable/esm';\nimport PushStream from 'zen-push';\n\nimport { type Event } from './events';\nimport { Trigger } from './trigger';\n\nexport { Observable, PushStream, type Subscriber };\n\n// Inspired by:\n// https://github.com/zenparsing/zen-push/blob/39949f1/index.js#L93\n// https://github.com/apollographql/apollo-client/blob/a0eb4d6/src/utilities/observables/Concast.ts\n\n/**\n * Observable which supports multiple subscribers and stores the current value.\n *\n * The current value is emitted to new subscribers on subscription.\n */\nexport class MulticastObservable<T> extends Observable<T> {\n  private readonly _observers = new Set<Observer<T>>();\n  private readonly _observable: Observable<T>;\n  private readonly _completed = new Trigger();\n\n  constructor(\n    subscriber: Observable<T> | Subscriber<T>,\n    protected _value?: T,\n  ) {\n    super((observer) => this._subscribe(observer));\n\n    this._observable = typeof subscriber === 'function' ? new Observable(subscriber) : subscriber;\n    // Automatically subscribe to source observable.\n    // Ensures that the current value is always up to date.\n    // TODO(wittjosiah): Does this subscription need to be cleaned up? Where should that happen?\n    this._observable.subscribe(this._handlers);\n  }\n\n  static override from<T>(\n    value: Observable<T> | ObservableLike<T> | ArrayLike<T> | Event<T>,\n    initialValue?: T,\n  ): MulticastObservable<T> {\n    if ('emit' in value) {\n      return new MulticastObservable((observer) => {\n        // TODO(wittjosiah): Do error/complete matter for events?\n        value.on((data) => {\n          observer.next(data);\n        });\n      }, initialValue);\n    }\n\n    const observable = Observable.from(value);\n    return new MulticastObservable(observable, initialValue);\n  }\n\n  static override of<T>(...items: T[]): MulticastObservable<T> {\n    return new MulticastObservable(Observable.of(...items.slice(1)), items[0]);\n  }\n\n  /**\n   * @returns Stable reference to an observable that always returns `undefined`.\n   */\n  static empty(): MulticastObservable<null> {\n    return EMPTY_OBSERVABLE;\n  }\n\n  /**\n   * Get the current value of the observable.\n   */\n  get(): T {\n    // TODO(wittjosiah): Is there a better way to handle this?\n    //   `this._value` is not guaranteed to be set for compatibility with `Observable` base class.\n    //   `get()` should always return `T` to avoid having to sprinkle conditional logic.\n    if (this._value === undefined) {\n      throw new Error('MulticastObservable is not initialized.');\n    }\n\n    return this._value;\n  }\n\n  /**\n   * Wait for the observable to complete.\n   *\n   * @returns Promise that resolves to the value of the observable at the time of completion.\n   */\n  async wait({ timeout }: { timeout?: number } = {}): Promise<T> {\n    await this._completed.wait({ timeout });\n    return this.get();\n  }\n\n  override forEach(callback: (value: T) => void): Promise<void> {\n    return this._observable.forEach(callback);\n  }\n\n  override map<R>(callback: (value: T) => R): MulticastObservable<R> {\n    return new MulticastObservable(this._observable.map(callback), this._value && callback(this._value));\n  }\n\n  override filter(callback: (value: T) => boolean): MulticastObservable<T> {\n    return new MulticastObservable(\n      this._observable.filter(callback),\n      this._value && callback(this._value) ? this._value : undefined,\n    );\n  }\n\n  override reduce<R = T>(callback: (previousValue: R, currentValue: T) => R, initialValue?: R): MulticastObservable<R> {\n    return new MulticastObservable(\n      initialValue ? this._observable.reduce(callback, initialValue) : this._observable.reduce(callback),\n      initialValue ?? (this._value as R),\n    );\n  }\n\n  override flatMap<R>(callback: (value: T) => MulticastObservable<R>): MulticastObservable<R> {\n    return new MulticastObservable(this._observable.flatMap(callback), this._value && callback(this._value).get());\n  }\n\n  override concat<R>(...observables: Array<Observable<R>>): MulticastObservable<R> {\n    return new MulticastObservable(this._observable.concat(...observables), this._value as R);\n  }\n\n  /**\n   * Concatenates multicast observables without losing the current value.\n   * @param reducer reduces the values of any multicast observables being concatenated into a single value\n   * @param observables observables to concatenate\n   * @returns concatenated observable\n   */\n  losslessConcat<R>(\n    reducer: (currentValue: R, newValues: R[]) => R,\n    ...observables: Array<Observable<R>>\n  ): MulticastObservable<R> {\n    const multicast = observables.filter(\n      (observable): observable is MulticastObservable<R> => observable instanceof MulticastObservable,\n    );\n    const value = reducer(\n      this._value as R,\n      multicast.map((observable) => observable.get()),\n    );\n    return new MulticastObservable(this._observable.concat(...observables), value);\n  }\n\n  private _subscribe(observer: Observer<T>): () => void {\n    if (!this._observers.has(observer)) {\n      this._observers.add(observer);\n    }\n\n    if (this._value !== undefined) {\n      observer.next?.(this._value);\n    }\n\n    return () => {\n      this._observers.delete(observer);\n    };\n  }\n\n  private _handlers: Observer<T> = {\n    next: (value) => {\n      this._value = value;\n      this._observers.forEach((observer) => observer.next?.(value));\n    },\n    error: (err) => {\n      this._observers.forEach((observer) => observer.error?.(err));\n    },\n    complete: () => {\n      this._completed.wake();\n      this._observers.forEach((observer) => observer.complete?.());\n    },\n  };\n}\n\nconst EMPTY_OBSERVABLE = MulticastObservable.of(null);\n", "//\n// Copyright 2020 DXOS.org\n//\n\nimport { TimeoutError } from './errors';\nimport { asyncTimeout } from './timeout';\n\n/**\n * Returns a tuple containing a Promise that will be resolved when the resolver function is called.\n * @deprecated Use `Trigger` instead.\n */\nexport const trigger = <T = void>(timeout?: number): [() => Promise<T>, (arg: T) => void] => {\n  // eslint-disable-line @stayradiated/prefer-arrow-functions/prefer-arrow-functions\n  let callback: (arg: T) => void;\n\n  const promise = new Promise<T>((resolve, reject) => {\n    if (timeout) {\n      setTimeout(() => reject(new Error(`Timed out after ${timeout.toLocaleString()}ms`)), timeout);\n    }\n\n    callback = resolve;\n  });\n\n  const provider = () => promise;\n  const resolver = (value: T) => callback(value);\n\n  return [provider, resolver];\n};\n\nexport type TriggerOptions = {\n  autoReset: boolean;\n};\n\nexport enum TriggerState {\n  WAITING = 'WAITING',\n  RESOLVED = 'RESOLVED',\n  REJECTED = 'REJECTED',\n}\n\n/**\n * Enables blocked listeners to be awakened with optional timeouts.\n *\n * Has two states:\n * - WAITING: promise is in pending state and will be resolved once `wake()` is called.\n * - RESOLVED: promise is already resolved, and all calls to `wait()` resolve immediately.\n * - REJECTED: promise is rejected, and all calls to `wait()` return rejected promise.\n *\n * Trigger starts in WAITING state initially.\n * Use `reset()` to switch resolved trigger back to WAITING state.\n */\nexport class Trigger<T = void> {\n  private _promise!: Promise<T>;\n  private _resolve!: (value: T | PromiseLike<T>) => void;\n  private _reject!: (error: Error) => void;\n  private _state: TriggerState = TriggerState.WAITING;\n\n  constructor(private _options: TriggerOptions = { autoReset: false }) {\n    this.reset();\n  }\n\n  get state() {\n    return this._state;\n  }\n\n  /**\n   * Wait until wake is called, with optional timeout.\n   */\n  async wait({ timeout }: { timeout?: number } = {}): Promise<T> {\n    if (timeout) {\n      return asyncTimeout(this._promise, timeout, new TimeoutError(timeout));\n    } else {\n      return this._promise;\n    }\n  }\n\n  /**\n   * Wake blocked callers (if any).\n   * NOOP if the trigger is already resolved.\n   */\n  wake(value: T): this {\n    if (this._state !== TriggerState.WAITING) {\n      return this;\n    }\n    this._state = TriggerState.RESOLVED;\n    this._resolve(value);\n    if (this._options.autoReset) {\n      return this.reset();\n    }\n\n    return this;\n  }\n\n  /**\n   * Reset promise (new waiters will wait).\n   */\n  reset(): this {\n    this._state = TriggerState.WAITING;\n    this._promise = new Promise<T>((resolve, reject) => {\n      this._resolve = resolve;\n      this._reject = reject;\n    });\n\n    this._promise.catch(() => {}); // Prevent unhandled promise rejections.\n    return this;\n  }\n\n  /**\n   * Throw error to blocked callers (if any).\n   * NOOP if the trigger is already resolved.\n   */\n  throw(error: Error): this {\n    if (this._state !== TriggerState.WAITING) {\n      return this;\n    }\n    this._state = TriggerState.REJECTED;\n    this._reject(error);\n    if (this._options.autoReset) {\n      return this.reset();\n    }\n\n    return this;\n  }\n}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { createSetDispatch } from '@dxos/util';\n\nimport { type CleanupFn } from './cleanup';\n\n/**\n * Return type for processes that support cancellable subscriptions.\n * The handler object implements the observable events.\n * @deprecated\n */\nexport interface ObservableValue<Events, Value = unknown> {\n  value?: Value;\n  setValue(value: Value): void;\n  subscribe(handler: Events): CleanupFn;\n}\n\n/**\n * Provider that manages a set of subscriptions.\n * @deprecated\n */\n// TODO(burdon): Support multiple subscribers.\n//  https://betterprogramming.pub/compare-leading-javascript-functional-reactive-stream-libraries-544163c1ded6\n//  https://github.com/apollographql/apollo-client/tree/main/src/utilities/observables\n//  https://github.com/mostjs/core\nexport class ObservableProvider<Events extends {}, Value = unknown> implements ObservableValue<Events, Value> {\n  protected readonly _handlers = new Set<Events>();\n  private readonly _proxy = createSetDispatch<Events>({\n    handlers: this._handlers,\n  });\n\n  private _value?: Value;\n\n  /**\n   * Proxy used to dispatch callbacks to each subscription.\n   */\n  get callback(): Events {\n    return this._proxy;\n  }\n\n  get value() {\n    return this._value;\n  }\n\n  setValue(value: Value): void {\n    this._value = value;\n  }\n\n  subscribe(handler: Events): CleanupFn {\n    this._handlers.add(handler);\n    return () => {\n      this._handlers.delete(handler);\n    };\n  }\n}\n\n/**\n * @deprecated\n */\nexport interface CancellableObservableEvents {\n  onCancelled?(): void;\n}\n\n/**\n * @deprecated\n */\nexport interface CancellableObservable<Events extends CancellableObservableEvents, Value = unknown>\n  extends ObservableValue<Events, Value> {\n  cancel(): Promise<void>;\n}\n\n/**\n * Implements subscriptions with ability to be cancelled.\n * @deprecated\n */\nexport class CancellableObservableProvider<\n  Events extends CancellableObservableEvents,\n> extends ObservableProvider<Events> {\n  private _cancelled = false;\n\n  constructor(private readonly _handleCancel?: () => Promise<void>) {\n    super();\n  }\n\n  get cancelled() {\n    return this._cancelled;\n  }\n\n  async cancel(): Promise<void> {\n    if (this._cancelled) {\n      return;\n    }\n\n    this._cancelled = true;\n    await this._handleCancel?.();\n    this.callback.onCancelled?.();\n  }\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { LifecycleState, Resource, cancelWithContext } from '@dxos/context';\nimport { warnAfterTimeout } from '@dxos/debug';\nimport { log } from '@dxos/log';\n\nimport { synchronized } from './mutex';\nimport { DeferredTask } from './task-scheduling';\nimport { sleep } from './timeout';\n\nconst INIT_RESTART_DELAY = 100;\nconst DEFAULT_MAX_RESTART_DELAY = 5000;\n\nexport type PersistentLifecycleParams<T> = {\n  /**\n   * Create connection.\n   * If promise resolves successfully, connection is considered established.\n   */\n  start: () => Promise<T | undefined>;\n\n  /**\n   * Reset connection to initial state.\n   */\n  stop: (state: T) => Promise<void>;\n\n  /**\n   * Called after successful start.\n   */\n  onRestart?: () => Promise<void>;\n\n  /**\n   * Maximum delay between restartion attempts.\n   * Default: 5000ms\n   */\n  maxRestartDelay?: number;\n};\n\n/**\n * Handles restarts (e.g. persists connection).\n * Restarts are scheduled with exponential backoff.\n */\nexport class PersistentLifecycle<T> extends Resource {\n  private readonly _start: () => Promise<T | undefined>;\n  private readonly _stop: (state: T) => Promise<void>;\n  private readonly _onRestart?: () => Promise<void>;\n  private readonly _maxRestartDelay: number;\n\n  private _currentState: T | undefined = undefined;\n  private _restartTask?: DeferredTask = undefined;\n  private _restartAfter = 0;\n\n  constructor({ start, stop, onRestart, maxRestartDelay = DEFAULT_MAX_RESTART_DELAY }: PersistentLifecycleParams<T>) {\n    super();\n    this._start = start;\n    this._stop = stop;\n    this._onRestart = onRestart;\n    this._maxRestartDelay = maxRestartDelay;\n  }\n\n  get state() {\n    return this._currentState;\n  }\n\n  @synchronized\n  protected override async _open(): Promise<void> {\n    this._restartTask = new DeferredTask(this._ctx, async () => {\n      try {\n        await this._restart();\n      } catch (err) {\n        log.warn('Restart failed', { err });\n        this._restartTask?.schedule();\n      }\n    });\n\n    this._currentState = await this._start().catch((err) => {\n      log.warn('Start failed', { err });\n      this._restartTask?.schedule();\n      return undefined;\n    });\n  }\n\n  protected override async _close(): Promise<void> {\n    await this._restartTask?.join();\n    await this._stopCurrentState();\n    this._restartTask = undefined;\n  }\n\n  private async _restart(): Promise<void> {\n    log(`restarting in ${this._restartAfter}ms`, { state: this._lifecycleState });\n    await this._stopCurrentState();\n    if (this._lifecycleState !== LifecycleState.OPEN) {\n      return;\n    }\n    await cancelWithContext(this._ctx!, sleep(this._restartAfter));\n    this._restartAfter = Math.min(Math.max(this._restartAfter * 2, INIT_RESTART_DELAY), this._maxRestartDelay);\n\n    // May fail if the connection is not established.\n    await warnAfterTimeout(5_000, 'Connection establishment takes too long', async () => {\n      this._currentState = await this._start();\n    });\n\n    this._restartAfter = 0;\n    await this._onRestart?.();\n  }\n\n  private async _stopCurrentState(): Promise<void> {\n    if (this._currentState) {\n      try {\n        await this._stop(this._currentState);\n      } catch (err) {\n        log.catch(err);\n      }\n      this._currentState = undefined;\n    }\n  }\n\n  /**\n   * Scheduling restart should be done from outside.\n   */\n  @synchronized\n  async scheduleRestart(): Promise<void> {\n    if (this._lifecycleState !== LifecycleState.OPEN) {\n      return;\n    }\n    this._restartTask!.schedule();\n  }\n}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { ContextDisposedError, type Context } from '@dxos/context';\nimport { StackTrace } from '@dxos/debug';\nimport { type MaybePromise } from '@dxos/util';\n\nimport { trackResource } from './track-leaks';\nimport { Trigger } from './trigger';\n\n/**\n * A task that can be scheduled to run in the next event loop iteration.\n * Could be triggered multiple times, but only runs once.\n * If a new task is triggered while a previous one is running, the next run would occur immediately after the current run has finished.\n */\n// TODO(dmaretskyi): Consider calling `join` on context dispose.\n// TODO(burdon): Add throttling support.\nexport class DeferredTask {\n  private _scheduled = false;\n  private _currentTask: Promise<void> | null = null; // Can't be rejected.\n  private _nextTask = new Trigger();\n\n  constructor(\n    private readonly _ctx: Context,\n    private readonly _callback: () => Promise<void>,\n  ) {}\n\n  get scheduled() {\n    return this._scheduled;\n  }\n\n  /**\n   * Schedule the task to run asynchronously.\n   */\n  schedule(): void {\n    if (this._scheduled) {\n      return; // Already scheduled.\n    }\n\n    scheduleTask(this._ctx, async () => {\n      // The previous task might still be running, so we need to wait for it to finish.\n      await this._currentTask; // Can't be rejected.\n\n      // Reset the flag. New tasks can now be scheduled. They would wait for the callback to finish.\n      this._scheduled = false;\n      const completionTrigger = this._nextTask;\n      this._nextTask = new Trigger(); // Re-create the trigger as opposed to resetting it since there might be listeners waiting for it.\n\n      // Store the promise so that new tasks could wait for this one to finish.\n      this._currentTask = runInContextAsync(this._ctx, () => this._callback()).then(() => {\n        completionTrigger.wake();\n      });\n    });\n\n    this._scheduled = true;\n  }\n\n  /**\n   * Schedule the task to run and wait for it to finish.\n   */\n  async runBlocking(): Promise<void> {\n    if (this._ctx.disposed) {\n      throw new ContextDisposedError();\n    }\n\n    this.schedule();\n    await this._nextTask.wait();\n  }\n\n  /**\n   * Waits for the current task to finish if it is running.\n   * Does not schedule a new task.\n   */\n  async join(): Promise<void> {\n    await this._currentTask;\n  }\n}\n\nexport const runInContext = (ctx: Context, fn: () => void) => {\n  try {\n    fn();\n  } catch (err: any) {\n    ctx.raise(err);\n  }\n};\n\nexport const runInContextAsync = async (ctx: Context, fn: () => MaybePromise<void>) => {\n  try {\n    await fn();\n  } catch (err: any) {\n    ctx.raise(err);\n  }\n};\n\nexport const scheduleMicroTask = (ctx: Context, fn: () => MaybePromise<void>) => {\n  queueMicrotask(async () => {\n    if (ctx.disposed) {\n      return;\n    }\n    await runInContextAsync(ctx, fn);\n  });\n};\n\nexport const scheduleTask = (ctx: Context, fn: () => MaybePromise<void>, afterMs?: number) => {\n  const clearTracking = trackResource(() => ({\n    name: `task (${fn.name || 'anonymous'})`,\n    openStack: new StackTrace(),\n  }));\n\n  const timeout = setTimeout(async () => {\n    clearDispose();\n    await runInContextAsync(ctx, fn);\n    clearTracking();\n  }, afterMs);\n\n  const clearDispose = ctx.onDispose(() => {\n    clearTracking();\n    clearTimeout(timeout);\n  });\n};\n\n/**\n * Run the task in the next event loop iteration, and then repeat in `interval` ms after the previous iteration completes.\n */\nexport const scheduleTaskInterval = (ctx: Context, task: () => Promise<void>, interval: number) => {\n  const clearTracking = trackResource(() => ({\n    name: `repeating task (${task.name || 'anonymous'})`,\n    openStack: new StackTrace(),\n  }));\n\n  let timeoutId: NodeJS.Timeout;\n\n  const run = async () => {\n    await runInContextAsync(ctx, task);\n    if (ctx.disposed) {\n      return;\n    }\n    timeoutId = setTimeout(run, interval);\n  };\n\n  timeoutId = setTimeout(run, interval);\n  ctx.onDispose(() => {\n    clearTracking();\n    clearTimeout(timeoutId);\n  });\n};\n\nexport const scheduleExponentialBackoffTaskInterval = (\n  ctx: Context,\n  task: () => Promise<void>,\n  initialInterval: number,\n) => {\n  const clearTracking = trackResource(() => ({\n    name: `repeating task (${task.name || 'anonymous'})`,\n    openStack: new StackTrace(),\n  }));\n\n  let timeoutId: NodeJS.Timeout;\n\n  let interval = initialInterval;\n  const repeat = async () => {\n    await runInContextAsync(ctx, task);\n    if (ctx.disposed) {\n      return;\n    }\n    interval *= 2;\n    timeoutId = setTimeout(repeat, interval);\n  };\n\n  timeoutId = setTimeout(repeat, interval);\n  ctx.onDispose(() => {\n    clearTracking();\n    clearTimeout(timeoutId);\n  });\n};\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { StackTrace } from '@dxos/debug';\nimport { log } from '@dxos/log';\n\nconst enabled = typeof process !== 'undefined' && !!process.env.DX_TRACK_LEAKS;\n\ntype OpenResource = {\n  name: string;\n  openStack: StackTrace;\n};\n\nconst openResources = new Set<OpenResource>();\n\nconst handleSymbol = Symbol('checkLeaksHandle');\n\nexport const trackResource = (resourceProvider: () => OpenResource): (() => void) => {\n  if (!enabled) {\n    return () => {};\n  }\n  const resource = resourceProvider();\n\n  openResources.add(resource);\n\n  return () => {\n    openResources.delete(resource);\n  };\n};\n\n/**\n * Makes sure that the resource is at the end of the test.\n *\n * Example:\n *\n * ```typescript\n * @trackLeaks('open', 'close')\n * class Resource {}\n * ```\n */\nexport const trackLeaks =\n  (open: string, close: string): ClassDecorator =>\n  (target: any) => {\n    if (!enabled) {\n      return;\n    }\n\n    const openMethod = target.prototype[open];\n    const closeMethod = target.prototype[close];\n    if (!openMethod || !closeMethod) {\n      throw new Error(`Cannot find ${open} or ${close} method in ${target.name}`);\n    }\n\n    {\n      target.prototype[open] = async function (this: any, ...args: any) {\n        this[handleSymbol] = trackResource(() => ({\n          name: target.name,\n          openStack: new StackTrace(),\n        }));\n\n        return openMethod.apply(this, args);\n      };\n      Object.defineProperty(target.prototype[open], 'name', { value: open + '$checkLeaks' });\n    }\n\n    {\n      target.prototype[close] = async function (this: any, ...args: any) {\n        this[handleSymbol]?.();\n\n        return closeMethod.apply(this, args);\n      };\n      Object.defineProperty(target.prototype[close], 'name', { value: close + '$checkLeaks' });\n    }\n  };\n\nexport const dumpLeaks = () => {\n  if (!enabled) {\n    return;\n  }\n\n  log.info(`Leaked resources ${openResources.size}:`);\n  for (const resource of openResources) {\n    log.info(`- ${resource.name} at`);\n    log.info(resource.openStack.getStack(1));\n    log.info('\\n');\n  }\n};\n\nif (enabled) {\n  (global as any).dxDumpLeaks = dumpLeaks;\n}\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { invariant } from '@dxos/invariant';\n\nimport { Trigger } from './trigger';\n\ninterface PushAsyncIterable<T, TReturn = any> extends AsyncIterable<T, TReturn> {\n  /**\n   * Push a value into the iterable.\n   */\n  next(value: T): void;\n\n  /**\n   * Return a value from the iterable.\n   */\n  return(value?: TReturn): void;\n\n  /**\n   * Throw an error from the iterable.\n   */\n  throw(value?: any): void;\n}\n\n/**\n * Creates an async iterable where the data is pushed by calling methods on the iterable.\n */\nexport const makePushIterable = <T, TReturn = any>(): PushAsyncIterable<T, TReturn> => {\n  const buf: ({ kind: 'next'; value: T } | { kind: 'return'; value: TReturn } | { kind: 'throw'; value?: any })[] = [];\n  const trigger = new Trigger({ autoReset: true });\n\n  return {\n    [Symbol.asyncIterator]() {\n      return {\n        next: async (): Promise<IteratorResult<T, TReturn>> => {\n          while (buf.length === 0) {\n            await trigger.wait();\n          }\n\n          const item = buf.shift();\n          invariant(item);\n\n          switch (item.kind) {\n            case 'next':\n              return { value: item.value, done: false };\n            case 'return':\n              return { value: item.value, done: true };\n            case 'throw':\n              throw item.value;\n          }\n        },\n      };\n    },\n    next: (value: T) => {\n      buf.push({ kind: 'next', value });\n      trigger.wake();\n    },\n    return: (value: TReturn) => {\n      buf.push({ kind: 'return', value });\n      trigger.wake();\n    },\n    throw: (value?: any) => {\n      buf.push({ kind: 'throw', value });\n      trigger.wake();\n    },\n  };\n};\n", "//\n// Copyright 2020 DXOS.org\n//\n\nimport { type EventEmitter } from 'node:events';\n\nimport { trigger } from './trigger';\n\n/**\n * Waits for the specified number of events from the given emitter.\n */\nexport const sink = (emitter: EventEmitter, event: string, count = 1): Promise<void> => {\n  const [getPromise, resolve] = trigger();\n\n  let counter = 0;\n  const listener = () => {\n    if (++counter === count) {\n      emitter.off(event, listener);\n      resolve();\n    }\n  };\n\n  emitter.on(event, listener);\n\n  return getPromise();\n};\n", "//\n// Copyright 2022 DXOS.org\n//\n\n/**\n * Concatenate a readable stream's data into a single array.\n *\n * From https://github.com/stream-utils/stream-to-array, but does not depend on\n * any-promise which does not work in web workers due to using window in its\n * browser shim.\n */\nexport const streamToArray = (stream: NodeJS.ReadableStream): Promise<any[]> => {\n  let deferred: Promise<any[]>;\n\n  if (!stream.readable) {\n    deferred = Promise.resolve([]);\n  } else {\n    deferred = new Promise((resolve, reject) => {\n      // stream is already ended\n      if (!stream.readable) {\n        return resolve([]);\n      }\n\n      let arr: any[] = [];\n\n      const onData = (doc: any) => {\n        arr?.push(doc);\n      };\n\n      const onEnd = (err: any) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(arr);\n        }\n        cleanup();\n      };\n\n      const onClose = () => {\n        resolve(arr);\n        cleanup();\n      };\n\n      const cleanup = () => {\n        arr = [];\n        stream.removeListener('data', onData);\n        stream.removeListener('end', onEnd);\n        stream.removeListener('error', onEnd);\n        stream.removeListener('close', onClose);\n      };\n\n      stream.on('data', onData);\n      stream.on('end', onEnd);\n      stream.on('error', onEnd);\n      stream.on('close', onClose);\n    });\n  }\n\n  return deferred;\n};\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { Duplex } from 'node:stream';\n\nimport { Event } from './events';\nimport { asyncTimeout } from './timeout';\n\n/**\n * Duplex stream for testing.\n * If this stream is piped into another stream, use `push` to send data, and `assertReceivedAsync` to assert the received data.\n */\nexport class TestStream extends Duplex {\n  static async assertConnectivity(\n    stream1: TestStream,\n    stream2: TestStream,\n    { timeout = 200 }: { timeout?: number } = {},\n  ): Promise<void> {\n    stream1.push('ping');\n    stream2.push('pong');\n\n    await Promise.all([\n      stream2.assertReceivedAsync('ping', { timeout }),\n      stream1.assertReceivedAsync('pong', { timeout }),\n    ]);\n  }\n\n  private _received = Buffer.alloc(0);\n  private _onWrite = new Event();\n\n  override _write(chunk: any, encoding: BufferEncoding, callback: (error?: Error | null) => void): void {\n    this._received = Buffer.concat([this._received, chunk]);\n    this._onWrite.emit();\n    callback();\n  }\n\n  override _read(size: number): void {\n    // noop\n  }\n\n  assertReceivedAsync(data: Buffer | string, { timeout = 200 }: { timeout?: number } = {}): Promise<void> {\n    const dataBuffer = Buffer.isBuffer(data) ? data : Buffer.from(data);\n    return asyncTimeout(\n      this._onWrite.waitForCondition(() => this._received.equals(dataBuffer)),\n      timeout,\n    );\n  }\n}\n", "//\n// Copyright 2020 DXOS.org\n//\n\nimport { sleep } from './timeout';\nimport { Trigger } from './trigger';\n\n/**\n * NOTE: THIS SHOULD ONLY BE USED IN TESTS.\n *\n * Returns a Promise which resolves when `condFn` returns truthy.\n * The value returned by `condFn` is used to resolve the Promise.\n * @param condition Function to call.\n * @param [timeout] How long to wait, in milliseconds (0 = no timeout).\n * @param [interval=10] How frequently to check, in milliseconds.\n */\nexport const waitForCondition = <FunctionType extends (...args: any) => any>({\n  condition,\n  timeout = 0,\n  interval = 10,\n  error,\n  breakOnError = false,\n}: {\n  condition: FunctionType;\n  timeout?: number;\n  interval?: number;\n  error?: Error;\n  breakOnError?: boolean;\n}) => {\n  const stopTime = timeout ? Date.now() + timeout : 0;\n  const trigger = new Trigger<ReturnType<FunctionType>>();\n  const waiter = async () => {\n    // eslint-disable-next-line no-unmodified-loop-condition\n    while (!stopTime || Date.now() < stopTime) {\n      try {\n        // eslint-disable-next-line no-await-in-loop\n        const value = await condition();\n        if (value) {\n          trigger.wake(value);\n          break;\n        }\n      } catch (err: any) {\n        if (breakOnError === true) {\n          trigger.throw(err);\n        }\n      }\n\n      // eslint-disable-next-line no-await-in-loop\n      await sleep(interval);\n    }\n  };\n\n  setTimeout(waiter, 0);\n\n  return trigger.wait({ timeout });\n};\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { Event, type ReadOnlyEvent } from './events';\n\nexport type TimerOptions = { count: number; interval: number; jitter?: number };\n\nexport type TimerCallback = (i: number) => Promise<boolean | void>;\n\n/**\n * Manages callback invocations at a interval with a possible jitter.\n * Note: The interval excludes the running time of the callback.\n */\nexport class Timer {\n  private readonly _state = new Event<boolean>();\n  private _timer?: NodeJS.Timeout;\n  private _count = 0;\n\n  constructor(private readonly _callback: TimerCallback) {}\n\n  get state(): ReadOnlyEvent<boolean> {\n    return this._state;\n  }\n\n  get running() {\n    return !!this._timer;\n  }\n\n  start(options: TimerOptions, cb?: () => void): this {\n    if (isNaN(options.count) || isNaN(options.interval)) {\n      throw new Error(`Invalid options: ${JSON.stringify(options)}`);\n    }\n\n    if (this.running) {\n      this.stop();\n    }\n\n    const stop = () => {\n      this.stop();\n      cb?.();\n    };\n\n    const run = () => {\n      if (this._count >= (options.count ?? 0)) {\n        stop();\n      } else {\n        const interval = (options.interval ?? 0) + Math.random() * (options.jitter ?? 0);\n        this._timer = setTimeout(async () => {\n          await this._callback(this._count++);\n          run();\n        }, interval);\n      }\n    };\n\n    this._state.emit(true);\n    this._count = 0;\n\n    // Start asynchronously (give caller chance to register event listener).\n    setTimeout(run);\n    return this;\n  }\n\n  stop(): this {\n    clearInterval(this._timer);\n    this._timer = undefined;\n    this._state.emit(false);\n    return this;\n  }\n}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nexport type UntilCallback<T> = (resolve: (value: T) => void, reject: (error: Error) => void) => Promise<T> | void;\n\n/**\n * Awaits promise.\n */\n// TODO(burdon): Reconcile with latch/trigger.\nexport const until = <T = void>(cb: UntilCallback<T>, timeout?: number): Promise<T> => {\n  return new Promise((resolve, reject) => {\n    const t =\n      timeout &&\n      setTimeout(() => {\n        reject(new Error(`Timeout after ${t}ms`));\n      }, timeout);\n\n    setTimeout(async () => {\n      try {\n        await cb(\n          (value: T) => {\n            t && clearTimeout(t);\n            resolve(value);\n          },\n          (error: Error) => {\n            t && clearTimeout(t);\n            reject(error);\n          },\n        );\n      } catch (err) {\n        reject(err);\n      }\n    });\n  });\n};\n\n/**\n * Wait until promise resolves.\n */\n// TODO(burdon): Reconcile promises (with timeouts).\nexport const untilPromise = <T = void>(cb: () => Promise<T>) => cb();\n\n/**\n * Wait until error is thrown.\n */\nexport const untilError = (cb: () => Promise<any>) => {\n  return new Promise((resolve, reject) => {\n    setTimeout(async () => {\n      try {\n        await cb();\n        reject(new Error('No error was thrown.'));\n      } catch (err) {\n        resolve(err);\n      }\n    });\n  });\n};\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { type Context } from '@dxos/context';\n\nimport { scheduleMicroTask } from './task-scheduling';\n\nexport type UpdateSchedulerOptions = {\n  /**\n   * Maximum frequency of updates. If not specified, updates will be scheduled on every change.\n   */\n  maxFrequency?: number;\n};\n\n/**\n * Time period for update counting.\n */\nconst TIME_PERIOD = 1000;\n\nexport class UpdateScheduler {\n  /**\n   * Promise that resolves when the callback is done.\n   * Never rejects.\n   */\n  private _promise: Promise<any> | null = null;\n  private _scheduled = false;\n\n  private _lastUpdateTime = -TIME_PERIOD;\n\n  constructor(\n    private readonly _ctx: Context,\n    private readonly _callback: () => Promise<void>,\n    private readonly _params: UpdateSchedulerOptions = {},\n  ) {\n    _ctx.onDispose(async () => {\n      await this._promise; // Context waits for callback to finish.\n    });\n  }\n\n  trigger(): void {\n    if (this._scheduled) {\n      return;\n    }\n\n    scheduleMicroTask(this._ctx, async () => {\n      // The previous task might still be running, so we need to wait for it to finish.\n      await this._promise; // Can't be rejected.\n\n      // Check if the callback was called recently.\n      if (this._params.maxFrequency) {\n        const now = performance.now();\n        const delay = this._lastUpdateTime + TIME_PERIOD / this._params.maxFrequency - now;\n        if (delay > 0) {\n          await new Promise<void>((resolve) => {\n            const timeoutId = setTimeout(() => {\n              clearContext();\n              resolve();\n            }, delay);\n\n            const clearContext = this._ctx.onDispose(() => {\n              clearTimeout(timeoutId);\n              resolve();\n            });\n          });\n        }\n      }\n\n      if (this._ctx.disposed) {\n        return;\n      }\n\n      this._lastUpdateTime = performance.now();\n\n      // Reset the flag. New tasks can now be scheduled. They would wait for the callback to finish.\n      this._scheduled = false;\n      this._promise = this._callback().then(\n        () => {\n          this._promise = null;\n        },\n        (error) => {\n          this._promise = null;\n          this._ctx.raise(error);\n        },\n      );\n    });\n\n    this._scheduled = true;\n  }\n\n  forceTrigger(): void {\n    scheduleMicroTask(this._ctx, async () => {\n      this._callback().catch((err) => this._ctx.raise(err));\n    });\n  }\n\n  /**\n   * Waits for the current task to finish if it is running.\n   * Does not schedule a new task.\n   */\n  async join(): Promise<void> {\n    await this._promise;\n  }\n\n  /**\n   * Force schedule the task to run and wait for it to finish.\n   */\n  async runBlocking(): Promise<void> {\n    // The previous task might still be running, so we need to wait for it to finish.\n    await this._promise; // Can't be rejected.\n    this._promise = this._callback();\n    await this._promise;\n  }\n}\n"],
  "mappings": "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",
  "names": ["import_context", "import_util", "import_debug", "import_log", "import_invariant", "createPromiseFromCallback", "run", "Promise", "resolve", "reject", "error", "value", "asyncChain", "chain", "elements", "result", "part", "all", "map", "element", "combine", "cleanupFns", "flat", "forEach", "cleanupFn", "timeout", "cb", "ms", "t", "setTimeout", "clearTimeout", "interval", "setInterval", "clearInterval", "addEventListener", "target", "type", "listener", "options", "removeEventListener", "SubscriptionList", "_cleanups", "add", "push", "clear", "length", "SubscriptionSet", "keyProjection", "_cleanupMap", "ComplexMap", "set", "key", "debounce", "wait", "args", "toError", "err", "undefined", "Error", "TimeoutError", "label", "toLocaleString", "observableError", "observable", "callback", "onTimeout", "onError", "sleep", "finish", "Date", "now", "sleeper", "delta", "asyncReturn", "asyncTimeout", "promise", "timeoutId", "throwable", "timeoutPromise", "unrefTimeout", "conditionTimeout", "race", "finally", "unref", "sleepWithContext", "ctx", "ContextDisposedError", "disposed", "clearDispose", "onDispose", "onEvent", "eventEmitter", "eventName", "on", "off", "addListener", "remove", "waitForEvent", "test", "DO_NOT_ERROR_ON_ASYNC_CALLBACK", "Event", "_listeners", "Set", "_effects", "wrap", "emitter", "event", "addEffect", "data", "emit", "trigger", "once", "delete", "emitAsync", "triggerAsync", "_ctx", "_callback", "Context", "weak", "EventListener", "_addListener", "_removeListener", "derefCallback", "Symbol", "asyncIterator", "waitFor", "predicate", "unsubscribe", "waitForCount", "expectedCount", "count", "waitForCondition", "listenerCount", "size", "effect", "handle", "cleanup", "firing", "lastFired", "debouncedEvent", "fireIn", "discardParameter", "pipeInto", "toJSON", "_runEffects", "_cleanupEffects", "_clearDispose", "WeakRef", "weakListeners", "registry", "register", "deref", "raise", "TypeError", "unregister", "weakListenersState", "FINALIZATION_REGISTRY_SUPPORTED", "globalThis", "FinalizationRegistry", "latch", "invariant", "doResolve", "doReject", "i", "Mutex", "_queue", "_queueLength", "_tag", "tag", "isLocked", "acquire", "prev", "guard", "MutexGuard", "executeSynchronized", "fun", "release", "_release", "dispose", "classMutexSymbol", "FORCE_DISABLE_WARNING", "enableWarning", "mochaExecutor", "synchronized", "propertyName", "descriptor", "method", "synchronizedMethod", "mutex", "name", "warnAfterTimeout", "apply", "Object", "defineProperty", "provider", "resolver", "TriggerState", "Trigger", "_options", "autoReset", "_state", "reset", "state", "_promise", "wake", "_resolve", "_reject", "catch", "throw", "MulticastObservable", "Observable", "subscriber", "_value", "observer", "_subscribe", "_observers", "_completed", "_handlers", "next", "complete", "_observable", "subscribe", "from", "initialValue", "of", "items", "slice", "empty", "EMPTY_OBSERVABLE", "get", "filter", "reduce", "flatMap", "concat", "observables", "losslessConcat", "reducer", "multicast", "has", "ObservableProvider", "_proxy", "createSetDispatch", "handlers", "setValue", "handler", "CancellableObservableProvider", "_handleCancel", "_cancelled", "cancelled", "cancel", "onCancelled", "enabled", "process", "env", "DX_TRACK_LEAKS", "openResources", "handleSymbol", "trackResource", "resourceProvider", "resource", "trackLeaks", "open", "close", "openMethod", "prototype", "closeMethod", "openStack", "StackTrace", "dumpLeaks", "log", "info", "getStack", "global", "dxDumpLeaks", "DeferredTask", "_scheduled", "_currentTask", "_nextTask", "scheduled", "schedule", "scheduleTask", "completionTrigger", "runInContextAsync", "then", "runBlocking", "join", "runInContext", "fn", "scheduleMicroTask", "queueMicrotask", "afterMs", "clearTracking", "scheduleTaskInterval", "task", "scheduleExponentialBackoffTaskInterval", "initialInterval", "repeat", "INIT_RESTART_DELAY", "DEFAULT_MAX_RESTART_DELAY", "PersistentLifecycle", "Resource", "start", "stop", "onRestart", "maxRestartDelay", "_currentState", "_restartTask", "_restartAfter", "_start", "_stop", "_onRestart", "_maxRestartDelay", "_open", "_restart", "warn", "_close", "_stopCurrentState", "_lifecycleState", "LifecycleState", "OPEN", "cancelWithContext", "Math", "min", "max", "scheduleRestart", "makePushIterable", "buf", "item", "shift", "kind", "done", "return", "sink", "getPromise", "counter", "streamToArray", "stream", "deferred", "readable", "arr", "onData", "doc", "onEnd", "onClose", "removeListener", "TestStream", "Duplex", "_received", "Buffer", "alloc", "_onWrite", "assertConnectivity", "stream1", "stream2", "assertReceivedAsync", "_write", "chunk", "encoding", "_read", "dataBuffer", "isBuffer", "equals", "condition", "breakOnError", "stopTime", "waiter", "Timer", "_count", "running", "_timer", "isNaN", "JSON", "stringify", "random", "jitter", "until", "untilPromise", "untilError", "TIME_PERIOD", "UpdateScheduler", "_params", "_lastUpdateTime", "maxFrequency", "performance", "delay", "clearContext", "forceTrigger"]
}
