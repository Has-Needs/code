import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv1";
import type { Any, EmptySchema, Timestamp } from "@bufbuild/protobuf/wkt";
import type { JsonObject, Message as Message$1 } from "@bufbuild/protobuf";
/**
 * Describes the file dxos/mesh/signal.proto.
 */
export declare const file_dxos_mesh_signal: GenFile;
/**
 * / @deprecated
 *
 * @generated from message dxos.mesh.signal.JoinRequest
 */
export type JoinRequest = Message$1<"dxos.mesh.signal.JoinRequest"> & {
    /**
     * @generated from field: bytes swarm = 1;
     */
    swarm: Uint8Array;
    /**
     * @generated from field: bytes peer = 2;
     */
    peer: Uint8Array;
    /**
     * @generated from field: optional google.protobuf.Struct metadata = 3;
     */
    metadata?: JsonObject;
};
/**
 * Describes the message dxos.mesh.signal.JoinRequest.
 * Use `create(JoinRequestSchema)` to create a new message.
 */
export declare const JoinRequestSchema: GenMessage<JoinRequest>;
/**
 * / @deprecated
 *
 * @generated from message dxos.mesh.signal.Message
 */
export type Message = Message$1<"dxos.mesh.signal.Message"> & {
    /**
     * TODO(egor): Rename to `sender`.
     *
     * @generated from field: bytes author = 1;
     */
    author: Uint8Array;
    /**
     * @generated from field: bytes recipient = 2;
     */
    recipient: Uint8Array;
    /**
     * @generated from field: google.protobuf.Any payload = 3;
     */
    payload?: Any;
    /**
     * @generated from field: optional google.protobuf.Struct metadata = 4;
     */
    metadata?: JsonObject;
};
/**
 * Describes the message dxos.mesh.signal.Message.
 * Use `create(MessageSchema)` to create a new message.
 */
export declare const MessageSchema: GenMessage<Message>;
/**
 * / @deprecated
 *
 * @generated from message dxos.mesh.signal.ReceptionRequest
 */
export type ReceptionRequest = Message$1<"dxos.mesh.signal.ReceptionRequest"> & {
    /**
     * @generated from field: bytes peer = 1;
     */
    peer: Uint8Array;
};
/**
 * Describes the message dxos.mesh.signal.ReceptionRequest.
 * Use `create(ReceptionRequestSchema)` to create a new message.
 */
export declare const ReceptionRequestSchema: GenMessage<ReceptionRequest>;
/**
 * / Goes on Pub/Sub swarm topic and as a Join stream in RPC.
 * / @deprecated
 *
 * @generated from message dxos.mesh.signal.SwarmEvent
 */
export type SwarmEvent = Message$1<"dxos.mesh.signal.SwarmEvent"> & {
    /**
     * @generated from oneof dxos.mesh.signal.SwarmEvent.event
     */
    event: {
        /**
         * / The peer was announced as available on the swarm.
         *
         * @generated from field: dxos.mesh.signal.SwarmEvent.PeerAvailable peer_available = 1;
         */
        value: SwarmEvent_PeerAvailable;
        case: "peerAvailable";
    } | {
        /**
         * / The peer left, or their announcement timed out.
         *
         * @generated from field: dxos.mesh.signal.SwarmEvent.PeerLeft peer_left = 2;
         */
        value: SwarmEvent_PeerLeft;
        case: "peerLeft";
    } | {
        case: undefined;
        value?: undefined;
    };
};
/**
 * Describes the message dxos.mesh.signal.SwarmEvent.
 * Use `create(SwarmEventSchema)` to create a new message.
 */
export declare const SwarmEventSchema: GenMessage<SwarmEvent>;
/**
 * Announce peer available on swarm.
 *
 * @generated from message dxos.mesh.signal.SwarmEvent.PeerAvailable
 */
export type SwarmEvent_PeerAvailable = Message$1<"dxos.mesh.signal.SwarmEvent.PeerAvailable"> & {
    /**
     * @generated from field: bytes peer = 1;
     */
    peer: Uint8Array;
    /**
     * @generated from field: google.protobuf.Timestamp since = 2;
     */
    since?: Timestamp;
    /**
     * When, if at all (handle the default value as not), this availability would expires were it not re-announced, like
     * periodically in Pub/Sub with some margin such that Pub/Sub network partitions lead to offline statuses.
     *
     * @generated from field: optional google.protobuf.Timestamp until = 3;
     */
    until?: Timestamp;
    /**
     * / Only relevant in Pub/Sub. Optional, the host topic to eagerly send PeerAvailable messages back to.
     *
     * @generated from field: optional bytes announce_back_to_host = 4;
     */
    announceBackToHost?: Uint8Array;
};
/**
 * Describes the message dxos.mesh.signal.SwarmEvent.PeerAvailable.
 * Use `create(SwarmEvent_PeerAvailableSchema)` to create a new message.
 */
export declare const SwarmEvent_PeerAvailableSchema: GenMessage<SwarmEvent_PeerAvailable>;
/**
 * @generated from message dxos.mesh.signal.SwarmEvent.PeerLeft
 */
export type SwarmEvent_PeerLeft = Message$1<"dxos.mesh.signal.SwarmEvent.PeerLeft"> & {
    /**
     * @generated from field: bytes peer = 1;
     */
    peer: Uint8Array;
};
/**
 * Describes the message dxos.mesh.signal.SwarmEvent.PeerLeft.
 * Use `create(SwarmEvent_PeerLeftSchema)` to create a new message.
 */
export declare const SwarmEvent_PeerLeftSchema: GenMessage<SwarmEvent_PeerLeft>;
/**
 * / Goes on a Pub/Sub host topic.
 * / @deprecated
 *
 * @generated from message dxos.mesh.signal.HostEvent
 */
export type HostEvent = Message$1<"dxos.mesh.signal.HostEvent"> & {
    /**
     * @generated from oneof dxos.mesh.signal.HostEvent.event
     */
    event: {
        /**
         * @generated from field: dxos.mesh.signal.HostEvent.AnnounceBack announce_back = 1;
         */
        value: HostEvent_AnnounceBack;
        case: "announceBack";
    } | {
        case: undefined;
        value?: undefined;
    };
};
/**
 * Describes the message dxos.mesh.signal.HostEvent.
 * Use `create(HostEventSchema)` to create a new message.
 */
export declare const HostEventSchema: GenMessage<HostEvent>;
/**
 * @generated from message dxos.mesh.signal.HostEvent.AnnounceBack
 */
export type HostEvent_AnnounceBack = Message$1<"dxos.mesh.signal.HostEvent.AnnounceBack"> & {
    /**
     * @generated from field: bytes swarm = 1;
     */
    swarm: Uint8Array;
    /**
     * @generated from field: dxos.mesh.signal.SwarmEvent.PeerAvailable peer_available = 2;
     */
    peerAvailable?: SwarmEvent_PeerAvailable;
};
/**
 * Describes the message dxos.mesh.signal.HostEvent.AnnounceBack.
 * Use `create(HostEvent_AnnounceBackSchema)` to create a new message.
 */
export declare const HostEvent_AnnounceBackSchema: GenMessage<HostEvent_AnnounceBack>;
/**
 * / Goes on Pub/Sub peer topic.
 * / @deprecated
 *
 * @generated from message dxos.mesh.signal.PeerEvent
 */
export type PeerEvent = Message$1<"dxos.mesh.signal.PeerEvent"> & {
    /**
     * @generated from oneof dxos.mesh.signal.PeerEvent.event
     */
    event: {
        /**
         * @generated from field: dxos.mesh.signal.Message message = 1;
         */
        value: Message;
        case: "message";
    } | {
        case: undefined;
        value?: undefined;
    };
};
/**
 * Describes the message dxos.mesh.signal.PeerEvent.
 * Use `create(PeerEventSchema)` to create a new message.
 */
export declare const PeerEventSchema: GenMessage<PeerEvent>;
/**
 * / @deprecated
 *
 * @generated from enum dxos.mesh.signal.SignalState
 */
export declare enum SignalState {
    /**
     * / Connection is being established.
     *
     * @generated from enum value: CONNECTING = 0;
     */
    CONNECTING = 0,
    /**
     * / Connection is being re-established.
     *
     * @generated from enum value: RECONNECTING = 1;
     */
    RECONNECTING = 1,
    /**
     * / Connected.
     *
     * @generated from enum value: CONNECTED = 2;
     */
    CONNECTED = 2,
    /**
     * / Server terminated the connection. Socket will be reconnected.
     *
     * @generated from enum value: DISCONNECTED = 3;
     */
    DISCONNECTED = 3,
    /**
     * / Server terminated the connection with an ERROR. Socket will be reconnected.
     *
     * @generated from enum value: ERROR = 4;
     */
    ERROR = 4,
    /**
     * / Socket was closed.
     *
     * @generated from enum value: CLOSED = 5;
     */
    CLOSED = 5
}
/**
 * Describes the enum dxos.mesh.signal.SignalState.
 */
export declare const SignalStateSchema: GenEnum<SignalState>;
/**
 * TOOD(burdon): Rename.
 * / @deprecated
 *
 * @generated from service dxos.mesh.signal.Signal
 */
export declare const Signal: GenService<{
    /**
     * @generated from rpc dxos.mesh.signal.Signal.Join
     */
    join: {
        methodKind: "server_streaming";
        input: typeof JoinRequestSchema;
        output: typeof SwarmEventSchema;
    };
    /**
     * @generated from rpc dxos.mesh.signal.Signal.ReceiveMessages
     */
    receiveMessages: {
        methodKind: "server_streaming";
        input: typeof ReceptionRequestSchema;
        output: typeof MessageSchema;
    };
    /**
     * @generated from rpc dxos.mesh.signal.Signal.SendMessage
     */
    sendMessage: {
        methodKind: "unary";
        input: typeof MessageSchema;
        output: typeof EmptySchema;
    };
}>;
//# sourceMappingURL=signal_pb.d.ts.map