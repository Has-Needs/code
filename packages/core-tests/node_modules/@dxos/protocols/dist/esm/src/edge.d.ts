import { Schema } from 'effect';
import { SpaceId } from '@dxos/keys';
export declare enum EdgeService {
    AUTOMERGE_REPLICATOR = "automerge-replicator",
    FEED_REPLICATOR = "feed-replicator",
    SWARM = "swarm",
    SIGNAL = "signal"
}
export type EdgeHttpSuccess<T> = {
    success: true;
    data: T;
};
export type EdgeErrorData = {
    type: string;
} & Record<string, any>;
export type EdgeHttpFailure = {
    success: false;
    /**
     * An explanation of why the call failed. Used mostly for logging and monitoring.
     */
    reason: string;
    /**
     * Information that can be used to retry the request such that it will succeed, for example:
     * 1. { type: 'auth_required', challenge: string }
     *    Requires retrying the request with challenge signature included.
     * 2. { type: 'user_confirmation_required', dialog: { title: string, message: string, confirmation_payload: string } }
     *    Requires showing a confirmation dialog to a user and retrying the request with confirmation_payload included
     *    if the user confirms.
     * When errorData is returned simply retrying the request won't have any effect.
     * EdgeHttpClient should parse well-known errorData into Error types and throw.
     */
    errorData?: EdgeErrorData;
};
export type EdgeHttpResponse<T> = EdgeHttpSuccess<T> | EdgeHttpFailure;
export type GetNotarizationResponseBody = {
    awaitingNotarization: {
        credentials: string[];
    };
};
export type ExecuteWorkflowResponseBody = {
    success: boolean;
    reason?: string;
    output?: any;
};
export type PostNotarizationRequestBody = {
    credentials: string[];
};
export type JoinSpaceRequest = {
    invitationId: string;
    identityKey: string;
    /**
     * Base64 encoded signed challenge.
     * Used to verify the IdentityKey in case of `invitation.authMethod === Invitation.AuthMethod.KNOWN_PUBLIC_KEY`
     */
    signature?: string;
};
export type JoinSpaceResponseBody = {
    spaceMemberCredential: string;
    spaceGenesisFeedKey: string;
};
export type RecoverIdentitySignature = string | {
    signature: string;
    clientDataJson: string;
    authenticatorData: string;
};
export type RecoverIdentityRequest = {
    deviceKey: string;
    controlFeedKey: string;
    lookupKey?: string;
    signature?: RecoverIdentitySignature;
    token?: string;
};
export type RecoverIdentityResponseBody = {
    identityKey: string;
    haloSpaceKey: string;
    genesisFeedKey: string;
    deviceAuthCredential: string;
};
export type CreateAgentRequestBody = {
    identityKey: string;
    haloSpaceId: SpaceId;
    haloSpaceKey: string;
};
export type CreateAgentResponseBody = {
    deviceKey: string;
    feedKey: string;
};
export type GetAgentStatusResponseBody = {
    agent: {
        deviceKey?: string;
        status: EdgeAgentStatus;
    };
};
export type UploadFunctionRequest = {
    name?: string;
    script: string;
    version: string;
    ownerPublicKey: string;
};
export type UploadFunctionResponseBody = {
    functionId: string;
    version: string;
    meta: {
        description?: string;
        /**
         * JSON Schema for the input of the function.
         */
        inputSchema?: object;
        /**
         * JSON Schema for the output of the function.
         */
        outputSchema?: object;
    };
};
export type CreateSpaceRequest = {
    agentKey: string;
};
export type CreateSpaceResponseBody = {
    spaceKey: string;
    spaceId: string;
    automergeRoot: string;
};
export declare enum EdgeAgentStatus {
    ACTIVE = "active",
    INACTIVE = "inactive",
    NOT_FOUND = "not_found"
}
export type EdgeAuthChallenge = {
    type: 'auth_challenge';
    challenge: string;
};
export declare enum OAuthProvider {
    GOOGLE = "google",
    BLUESKY = "bluesky"
}
export declare const InitiateOAuthFlowRequestSchema: Schema.Struct<{
    provider: Schema.Enums<typeof OAuthProvider>;
    spaceId: Schema.refine<string & {
        __SpaceId: true;
    }, Schema.Schema<string, string, never>>;
    accessTokenId: typeof Schema.String;
    scopes: Schema.mutable<Schema.Array$<typeof Schema.String>>;
    noRefresh: Schema.optional<typeof Schema.Boolean>;
    loginHint: Schema.optional<typeof Schema.String>;
}>;
export type InitiateOAuthFlowRequest = Schema.Schema.Type<typeof InitiateOAuthFlowRequestSchema>;
export type InitiateOAuthFlowResponse = {
    authUrl: string;
};
export type OAuthFlowResult = {
    success: true;
    accessToken: string;
    accessTokenId: string;
} | {
    success: false;
    reason: string;
};
export declare enum EdgeWebsocketProtocol {
    V0 = "edge-ws-v0",
    /**
     * Enables message framing and muxing by service-id.
     */
    V1 = "edge-ws-v1"
}
//# sourceMappingURL=edge.d.ts.map