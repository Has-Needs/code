{
  "version": 3,
  "sources": ["../../../../src/testing/change-metadata.ts", "../../../../src/testing/test-agent-builder.ts", "../../../../src/testing/test-feed-builder.ts", "../../../../src/testing/test-network-adapter.ts", "../../../../src/testing/test-replicator.ts", "../../../../src/testing/test-schema.ts", "../../../../src/testing/test-data.ts"],
  "sourcesContent": ["//\n// Copyright 2023 DXOS.org\n//\n\nimport { log } from '@dxos/log';\nimport { schema } from '@dxos/protocols/proto';\nimport type { Storage } from '@dxos/random-access-storage';\n\nimport { MetadataStore } from '../metadata';\n\nconst EchoMetadata = schema.getCodecForType('dxos.echo.metadata.EchoMetadata');\n\n/**\n * This function will change the storage version in the metadata.\n * This will break your storage and make it unusable.\n * Use this only for testing purposes.\n */\nexport const changeStorageVersionInMetadata = async (storage: Storage, version: number) => {\n  log('Changing storage version in metadata. USE ONLY FOR TESTING.');\n  const metadata = new MetadataStore(storage.createDirectory('metadata'));\n  await metadata.load();\n  const echoMetadata = metadata.metadata;\n  echoMetadata.version = version;\n  const file = metadata._directory.getOrCreateFile('EchoMetadata');\n  await metadata._writeFile(file, EchoMetadata, echoMetadata);\n  await metadata._directory.flush();\n};\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { Context } from '@dxos/context';\nimport { CredentialGenerator } from '@dxos/credentials';\nimport { type FeedStore } from '@dxos/feed-store';\nimport { type Keyring } from '@dxos/keyring';\nimport { PublicKey } from '@dxos/keys';\nimport { MemorySignalManager, MemorySignalManagerContext, WebsocketSignalManager } from '@dxos/messaging';\nimport { MemoryTransportFactory, SwarmNetworkManager, createRtcTransportFactory } from '@dxos/network-manager';\nimport { type FeedMessage } from '@dxos/protocols/proto/dxos/echo/feed';\nimport { type SpaceMetadata } from '@dxos/protocols/proto/dxos/echo/metadata';\nimport { AdmittedFeed } from '@dxos/protocols/proto/dxos/halo/credentials';\nimport { StorageType, createStorage, type Storage } from '@dxos/random-access-storage';\nimport { Gossip, Presence } from '@dxos/teleport-extension-gossip';\nimport { BlobStore } from '@dxos/teleport-extension-object-sync';\nimport { ComplexMap } from '@dxos/util';\n\nimport { TestFeedBuilder } from './test-feed-builder';\nimport { MetadataStore } from '../metadata';\nimport { MOCK_AUTH_PROVIDER, MOCK_AUTH_VERIFIER, SpaceManager, SpaceProtocol, type Space } from '../space';\n\nexport type NetworkManagerProvider = () => SwarmNetworkManager;\n\nexport const MemoryNetworkManagerProvider =\n  (signalContext: MemorySignalManagerContext): NetworkManagerProvider =>\n  () =>\n    new SwarmNetworkManager({\n      signalManager: new MemorySignalManager(signalContext),\n      transportFactory: MemoryTransportFactory,\n    });\n\nexport const WebsocketNetworkManagerProvider =\n  (signalUrl: string): NetworkManagerProvider =>\n  () =>\n    new SwarmNetworkManager({\n      signalManager: new WebsocketSignalManager([{ server: signalUrl }]),\n      transportFactory: createRtcTransportFactory(),\n    });\n\nexport type TestAgentBuilderOptions = {\n  storage?: Storage;\n  networkManagerProvider?: NetworkManagerProvider;\n};\n\n/**\n * Factory for test agents.\n */\nexport class TestAgentBuilder {\n  private readonly _agents = new ComplexMap<PublicKey, TestAgent>(PublicKey.hash);\n  private readonly _storage: Storage;\n  private readonly _networkManagerProvider: NetworkManagerProvider;\n\n  constructor({ storage, networkManagerProvider }: TestAgentBuilderOptions = {}) {\n    this._storage = storage ?? createStorage({ type: StorageType.RAM });\n    this._networkManagerProvider =\n      networkManagerProvider ?? MemoryNetworkManagerProvider(new MemorySignalManagerContext());\n  }\n\n  async close() {\n    return Promise.all(this.agents.map((agent) => agent.close()));\n  }\n\n  get agents() {\n    return Array.from(this._agents.values());\n  }\n\n  getAgent(deviceKey: PublicKey): TestAgent | undefined {\n    return this._agents.get(deviceKey);\n  }\n\n  async createPeer(): Promise<TestAgent> {\n    // prettier-ignore\n    const feedBuilder = new TestFeedBuilder()\n      .setStorage(this._storage, `agent-${this._agents.size}`);\n\n    const identityKey = await feedBuilder.keyring.createKey();\n    const deviceKey = await feedBuilder.keyring.createKey();\n\n    const agent = new TestAgent(this._networkManagerProvider, feedBuilder, identityKey, deviceKey);\n    this._agents.set(deviceKey, agent);\n    return agent;\n  }\n}\n\n/**\n * Test agent that enables the creation and replication of multiple spaces.\n */\nexport class TestAgent {\n  private readonly _spaces = new ComplexMap<PublicKey, Space>(PublicKey.hash);\n\n  public readonly storage: Storage;\n  public readonly keyring: Keyring;\n  public readonly feedStore: FeedStore<FeedMessage>;\n\n  private _metadataStore?: MetadataStore;\n  get metadataStore() {\n    return (this._metadataStore ??= new MetadataStore(this.storage.createDirectory('metadata')));\n  }\n\n  private _blobStore?: BlobStore;\n  get blobStore() {\n    return (this._blobStore ??= new BlobStore(this.storage.createDirectory('blobs')));\n  }\n\n  constructor(\n    private readonly _networkManagerProvider: NetworkManagerProvider,\n    private readonly _feedBuilder: TestFeedBuilder,\n    public readonly identityKey: PublicKey,\n    public readonly deviceKey: PublicKey,\n  ) {\n    this.storage = this._feedBuilder.storage;\n    this.keyring = this._feedBuilder.keyring;\n    this.feedStore = this._feedBuilder.createFeedStore();\n  }\n\n  async close() {\n    return Promise.all([...this.spaces.map((space) => space.close())]);\n  }\n\n  get spaces() {\n    return Array.from(this._spaces.values());\n  }\n\n  getSpace(spaceKey: PublicKey): Space | undefined {\n    return this._spaces.get(spaceKey);\n  }\n\n  private _networkManager?: SwarmNetworkManager;\n  get networkManager() {\n    if (this._networkManager) {\n      return this._networkManager;\n    }\n\n    this._networkManager = this._networkManagerProvider();\n    this._networkManager.setPeerInfo({ peerKey: this.deviceKey.toHex(), identityKey: this.identityKey.toHex() });\n\n    return this._networkManager;\n  }\n\n  private _spaceManager?: SpaceManager;\n  get spaceManager() {\n    return (this._spaceManager ??= new SpaceManager({\n      feedStore: this.feedStore,\n      networkManager: this.networkManager,\n      metadataStore: this.metadataStore,\n      blobStore: this.blobStore,\n    }));\n  }\n\n  async createSpace(\n    identityKey: PublicKey = this.identityKey,\n    spaceKey?: PublicKey,\n    genesisKey?: PublicKey,\n    dataKey?: PublicKey,\n    saveMetadata = false,\n  ): Promise<Space> {\n    if (!spaceKey) {\n      saveMetadata = true;\n      spaceKey = await this.keyring.createKey();\n    }\n    if (!genesisKey) {\n      genesisKey = await this.keyring.createKey();\n    }\n\n    const controlFeed = await this.feedStore.openFeed(genesisKey, { writable: true });\n    const dataFeed = await this.feedStore.openFeed(dataKey ?? (await this.keyring.createKey()), {\n      writable: true,\n      sparse: true,\n    });\n\n    const metadata: SpaceMetadata = {\n      key: spaceKey,\n      genesisFeedKey: genesisKey,\n      controlFeedKey: controlFeed.key,\n      dataFeedKey: dataFeed.key,\n    };\n    if (saveMetadata) {\n      await this.metadataStore.addSpace(metadata);\n    }\n\n    await this.spaceManager.open();\n    const space = await this.spaceManager.constructSpace({\n      metadata,\n      swarmIdentity: {\n        identityKey: this.identityKey,\n        peerKey: this.deviceKey,\n        credentialProvider: MOCK_AUTH_PROVIDER,\n        credentialAuthenticator: MOCK_AUTH_VERIFIER,\n      },\n      memberKey: identityKey,\n      onAuthorizedConnection: (session) => {\n        session.addExtension(\n          'dxos.mesh.teleport.gossip',\n          this.createGossip().createExtension({ remotePeerId: session.remotePeerId }),\n        );\n      },\n      onDelegatedInvitationStatusChange: async () => {},\n      onMemberRolesChanged: async () => {},\n    });\n    await space.setControlFeed(controlFeed);\n    await space.setDataFeed(dataFeed);\n\n    await space.open(new Context());\n\n    this._spaces.set(spaceKey, space);\n    return space;\n  }\n\n  createSpaceProtocol(topic: PublicKey, gossip?: Gossip): SpaceProtocol {\n    return new SpaceProtocol({\n      topic,\n      swarmIdentity: {\n        identityKey: this.identityKey,\n        peerKey: this.deviceKey,\n        credentialProvider: MOCK_AUTH_PROVIDER,\n        credentialAuthenticator: MOCK_AUTH_VERIFIER,\n      },\n      networkManager: this.networkManager,\n      blobStore: this.blobStore,\n      onSessionAuth: (session) => {\n        session.addExtension(\n          'dxos.mesh.teleport.gossip',\n          (gossip ?? this.createGossip()).createExtension({ remotePeerId: session.remotePeerId }),\n        );\n      },\n    });\n  }\n\n  createGossip(): Gossip {\n    return new Gossip({\n      localPeerId: this.deviceKey,\n    });\n  }\n\n  createPresence(gossip?: Gossip): Presence {\n    return new Presence({\n      announceInterval: 30,\n      offlineTimeout: 200,\n      identityKey: this.identityKey,\n      gossip: gossip ?? this.createGossip(),\n    });\n  }\n\n  async spaceGenesis(space: Space): Promise<void> {\n    const generator = new CredentialGenerator(this.keyring, this.identityKey, this.deviceKey);\n    const credentials = [\n      ...(await generator.createSpaceGenesis(space.key, space.controlFeedKey!)),\n      await generator.createFeedAdmission(space.key, space.dataFeedKey!, AdmittedFeed.Designation.DATA),\n      await generator.createEpochCredential(space.key),\n    ];\n\n    for (const credential of credentials) {\n      await space.controlPipeline.writer.write({\n        credential: { credential },\n      });\n    }\n  }\n}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { TestBuilder } from '@dxos/feed-store/testing';\nimport type { FeedMessage } from '@dxos/protocols/proto/dxos/echo/feed';\n\nimport { valueEncoding } from '../common';\n\n/**\n * Builder with default encoder and generator.\n */\nexport class TestFeedBuilder extends TestBuilder<FeedMessage> {\n  constructor() {\n    super({\n      valueEncoding,\n    });\n  }\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { type Message, NetworkAdapter, type PeerId } from '@automerge/automerge-repo';\n\nimport { Trigger, sleep } from '@dxos/async';\nimport { invariant } from '@dxos/invariant';\nimport { log } from '@dxos/log';\n\nexport type TestConnectionStateProvider = () => 'on' | 'off';\n\nexport class TestAdapter extends NetworkAdapter {\n  static createPair(connectionStateProvider: TestConnectionStateProvider = () => 'on'): TestAdapter[] {\n    const adapter1: TestAdapter = new TestAdapter({\n      send: (message: Message) => connectionStateProvider() === 'on' && sleep(10).then(() => adapter2.receive(message)),\n    });\n    const adapter2: TestAdapter = new TestAdapter({\n      send: (message: Message) => connectionStateProvider() === 'on' && sleep(10).then(() => adapter1.receive(message)),\n    });\n\n    return [adapter1, adapter2];\n  }\n\n  public onConnect = new Trigger();\n\n  constructor(private readonly _params: { send: (message: Message) => void }) {\n    super();\n  }\n\n  override isReady(): boolean {\n    return true;\n  }\n\n  override whenReady(): Promise<void> {\n    return Promise.resolve();\n  }\n\n  override connect(peerId: PeerId): void {\n    this.peerId = peerId;\n    this.onConnect.wake();\n  }\n\n  peerCandidate(peerId: PeerId): void {\n    invariant(peerId, 'PeerId is required');\n    this.emit('peer-candidate', { peerId, peerMetadata: {} });\n  }\n\n  peerDisconnected(peerId: PeerId): void {\n    invariant(peerId, 'PeerId is required');\n    this.emit('peer-disconnected', { peerId });\n  }\n\n  override send(message: Message): void {\n    log('send', { from: message.senderId, to: message.targetId, type: message.type });\n    this._params.send(message);\n  }\n\n  override disconnect(): void {\n    this.peerId = undefined;\n  }\n\n  receive(message: Message): void {\n    invariant(this.peerId, 'Peer id is not set');\n    this.emit('message', message);\n  }\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { sleep, synchronized } from '@dxos/async';\nimport { type Context, LifecycleState, Resource } from '@dxos/context';\nimport { invariant } from '@dxos/invariant';\nimport { log } from '@dxos/log';\nimport type { AutomergeProtocolMessage } from '@dxos/protocols';\nimport { AutomergeReplicator, type AutomergeReplicatorFactory } from '@dxos/teleport-extension-automerge-replicator';\n\nimport type {\n  EchoReplicator,\n  EchoReplicatorContext,\n  ReplicatorConnection,\n  ShouldAdvertiseParams,\n  ShouldSyncCollectionParams,\n} from '../automerge';\n\nexport type TestReplicatorNetworkOptions = {\n  latency?: number;\n};\n\nexport class TestReplicationNetwork extends Resource {\n  private readonly _replicators = new Set<TestReplicator>();\n  private readonly _latency?: number = undefined;\n\n  constructor(options: TestReplicatorNetworkOptions = {}) {\n    super();\n    this._latency = options.latency;\n  }\n\n  protected override async _close(ctx: Context): Promise<void> {\n    for (const replicator of this._replicators) {\n      for (const connection of replicator.connections) {\n        void connection.writable.abort();\n        void connection.readable.cancel();\n      }\n    }\n  }\n\n  async createReplicator(): Promise<TestReplicator> {\n    const replicator = new TestReplicator({\n      onConnect: async () => {\n        invariant(this._lifecycleState === LifecycleState.OPEN);\n        await this._connectReplicator(replicator);\n      },\n      onDisconnect: async () => {\n        invariant(this._lifecycleState === LifecycleState.OPEN);\n        await this._disconnectReplicator(replicator);\n      },\n    });\n    this._replicators.add(replicator);\n    return replicator;\n  }\n\n  @synchronized\n  private async _connectReplicator(replicator: TestReplicator): Promise<void> {\n    for (const otherReplicator of this._replicators.values()) {\n      if (otherReplicator === replicator || !otherReplicator.connected) {\n        continue;\n      }\n      log('create connection', { from: replicator.context!.peerId, to: otherReplicator.context!.peerId });\n      const [connection1, connection2] = this._createConnectionPair(\n        replicator.context!.peerId,\n        otherReplicator.context!.peerId,\n      );\n      await replicator.context!.onConnectionOpen(connection1);\n      await otherReplicator.context!.onConnectionOpen(connection2);\n    }\n  }\n\n  private async _disconnectReplicator(replicator: TestReplicator): Promise<void> {\n    for (const connection of replicator.connections) {\n      await replicator.context!.onConnectionClosed(connection);\n      await connection.otherSide!.owningReplicator!.removeConnection(connection.otherSide!);\n    }\n  }\n\n  private _createConnectionPair(peer1: string, peer2: string): [TestReplicatorConnection, TestReplicatorConnection] {\n    const LOG = false;\n\n    const forward = new TransformStream({\n      transform: async (message, controller) => {\n        if (LOG) {\n          log('replicate', { from: peer1, to: peer2, message });\n        }\n\n        if (this._latency !== undefined) {\n          await sleep(this._latency);\n        }\n\n        controller.enqueue(message);\n      },\n    });\n    const backwards = new TransformStream({\n      transform: async (message, controller) => {\n        if (LOG) {\n          log('replicate', { from: peer2, to: peer1, message });\n        }\n\n        if (this._latency !== undefined) {\n          await sleep(this._latency);\n        }\n\n        controller.enqueue(message);\n      },\n    });\n\n    const connection1 = new TestReplicatorConnection(peer2, backwards.readable, forward.writable);\n    const connection2 = new TestReplicatorConnection(peer1, forward.readable, backwards.writable);\n    connection1.otherSide = connection2;\n    connection2.otherSide = connection1;\n    return [connection1, connection2];\n  }\n}\n\ntype TestReplicatorParams = {\n  onConnect: () => Promise<void>;\n  onDisconnect: () => Promise<void>;\n};\n\nexport class TestReplicator implements EchoReplicator {\n  constructor(private readonly _params: TestReplicatorParams) {}\n\n  public connected = false;\n  public context: EchoReplicatorContext | undefined = undefined;\n  public connections = new Set<TestReplicatorConnection>();\n\n  async connect(context: EchoReplicatorContext): Promise<void> {\n    log('connect', { peerId: context.peerId });\n    this.context = context;\n    this.connected = true;\n    await this._params.onConnect();\n  }\n\n  async disconnect(): Promise<void> {\n    log('disconnect', { peerId: this.context!.peerId });\n    this.connected = false;\n    await this._params.onDisconnect();\n  }\n\n  async addConnection(connection: TestReplicatorConnection): Promise<void> {\n    connection.owningReplicator = this;\n    this.connections.add(connection);\n    this.context!.onConnectionOpen(connection);\n  }\n\n  async removeConnection(connection: TestReplicatorConnection): Promise<void> {\n    connection.owningReplicator = undefined;\n    this.context!.onConnectionClosed(connection);\n    this.connections.delete(connection);\n  }\n}\n\nexport class TestReplicatorConnection implements ReplicatorConnection {\n  public otherSide: TestReplicatorConnection | undefined = undefined;\n  public owningReplicator: TestReplicator | undefined = undefined;\n\n  constructor(\n    public readonly peerId: string,\n    public readonly readable: ReadableStream<AutomergeProtocolMessage>,\n    public readonly writable: WritableStream<AutomergeProtocolMessage>,\n  ) {}\n\n  async shouldAdvertise(params: ShouldAdvertiseParams): Promise<boolean> {\n    return true;\n  }\n\n  shouldSyncCollection(params: ShouldSyncCollectionParams): boolean {\n    return true;\n  }\n}\n\nexport const testAutomergeReplicatorFactory: AutomergeReplicatorFactory = (params) => {\n  return new AutomergeReplicator(\n    {\n      ...params[0],\n      sendSyncRetryPolicy: {\n        retryBackoff: 20,\n        retriesBeforeBackoff: 2,\n        maxRetries: 3,\n      },\n    },\n    params[1],\n  );\n};\n\nexport const brokenAutomergeReplicatorFactory: AutomergeReplicatorFactory = (params) => {\n  params[1]!.onSyncMessage = () => {\n    throw new Error();\n  };\n  return testAutomergeReplicatorFactory(params);\n};\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { Schema } from 'effect';\n\nimport { Type } from '@dxos/echo';\n\n//\n// Example schema\n//\n\n// TODO(dmaretskyi): Need common set of test types.\nexport const Person = Schema.Struct({\n  name: Schema.String,\n  email: Schema.optional(Schema.String),\n  age: Schema.optional(Schema.Number),\n}).pipe(\n  Type.Obj({\n    typename: 'dxos.org/type/Person',\n    version: '0.1.0',\n  }),\n);\nexport interface Person extends Schema.Schema.Type<typeof Person> {}\n\nexport const Organization = Schema.Struct({\n  name: Schema.String,\n}).pipe(\n  Type.Obj({\n    typename: 'dxos.org/type/Organization',\n    version: '0.1.0',\n  }),\n);\nexport interface Organization extends Schema.Schema.Type<typeof Organization> {}\n\nexport const WorksFor = Schema.Struct({\n  since: Schema.String,\n}).pipe(\n  Type.Relation({\n    typename: 'dxos.org/type/WorksFor',\n    version: '0.1.0',\n    source: Person,\n    target: Organization,\n  }),\n);\nexport interface WorksFor extends Schema.Schema.Type<typeof WorksFor> {}\n\nexport const Task = Schema.Struct({\n  title: Schema.String,\n  createdAt: Schema.String,\n  assignee: Type.Ref(Person),\n}).pipe(Type.Obj({ typename: 'dxos.org/type/Task', version: '0.1.0' }));\nexport interface Task extends Schema.Schema.Type<typeof Task> {}\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { DatabaseDirectory, ObjectStructure } from '@dxos/echo-protocol';\nimport { getSchemaDXN } from '@dxos/echo-schema';\nimport { DXN, ObjectId, PublicKey } from '@dxos/keys';\n\nimport * as TestSchema from './test-schema';\n\nconst spaceKey = PublicKey.random();\n\nexport const PEOPLE = {\n  fred: DatabaseDirectory.make({\n    spaceKey: spaceKey.toHex(),\n    objects: {\n      [ObjectId.random()]: ObjectStructure.makeObject({\n        type: getSchemaDXN(TestSchema.Person)!.toString(),\n        data: {\n          name: 'Fred',\n        },\n      }),\n    },\n  }),\n  alice: DatabaseDirectory.make({\n    spaceKey: spaceKey.toHex(),\n    objects: {\n      [ObjectId.random()]: ObjectStructure.makeObject({\n        type: getSchemaDXN(TestSchema.Person)!.toString(),\n        data: {\n          name: 'Alice',\n        },\n      }),\n    },\n  }),\n};\n\nexport const ORGS = {\n  cyberdyne: DatabaseDirectory.make({\n    spaceKey: spaceKey.toHex(),\n    objects: {\n      [ObjectId.random()]: ObjectStructure.makeObject({\n        type: getSchemaDXN(TestSchema.Organization)!.toString(),\n        data: {\n          name: 'Cyberdyne Systems',\n          founded: '1984',\n        },\n      }),\n    },\n  }),\n  aperture: DatabaseDirectory.make({\n    spaceKey: spaceKey.toHex(),\n    objects: {\n      [ObjectId.random()]: ObjectStructure.makeObject({\n        type: getSchemaDXN(TestSchema.Organization)!.toString(),\n        data: {\n          name: 'Aperture Science',\n          founded: '1953',\n        },\n      }),\n    },\n  }),\n};\n\nexport const WORKS_FOR = {\n  fredWorksForCyberdyne: DatabaseDirectory.make({\n    spaceKey: spaceKey.toHex(),\n    objects: {\n      [ObjectId.random()]: ObjectStructure.makeRelation({\n        type: getSchemaDXN(TestSchema.WorksFor)!.toString(),\n        source: { '/': DXN.fromLocalObjectId(Object.keys(PEOPLE.fred.objects!)[0]).toString() },\n        target: { '/': DXN.fromLocalObjectId(Object.keys(ORGS.cyberdyne.objects!)[0]).toString() },\n        data: {\n          since: '2020',\n          position: 'Engineer',\n        },\n      }),\n    },\n  }),\n  aliceWorksForAperture: DatabaseDirectory.make({\n    spaceKey: spaceKey.toHex(),\n    objects: {\n      [ObjectId.random()]: ObjectStructure.makeRelation({\n        type: getSchemaDXN(TestSchema.WorksFor)!.toString(),\n        source: { '/': DXN.fromLocalObjectId(Object.keys(PEOPLE.alice.objects!)[0]).toString() },\n        target: { '/': DXN.fromLocalObjectId(Object.keys(ORGS.aperture.objects!)[0]).toString() },\n        data: {\n          since: '2018',\n          position: 'Research Scientist',\n        },\n      }),\n    },\n  }),\n};\n\nexport const TASKS = {\n  task1: DatabaseDirectory.make({\n    spaceKey: spaceKey.toHex(),\n    objects: {\n      [ObjectId.random()]: ObjectStructure.makeObject({\n        type: getSchemaDXN(TestSchema.Task)!.toString(),\n        data: {\n          title: 'Complete project documentation',\n          description: 'Write comprehensive documentation for the new system',\n          status: 'in-progress',\n          dueDate: '2023-12-31',\n          assignee: { '/': DXN.fromLocalObjectId(Object.keys(PEOPLE.fred.objects!)[0]).toString() },\n        },\n      }),\n    },\n  }),\n  task2: DatabaseDirectory.make({\n    spaceKey: spaceKey.toHex(),\n    objects: {\n      [ObjectId.random()]: ObjectStructure.makeObject({\n        type: getSchemaDXN(TestSchema.Task)!.toString(),\n        data: {\n          title: 'Run experiments',\n          description: 'Conduct series of experiments on the portal device',\n          status: 'pending',\n          dueDate: '2023-11-15',\n          assignee: { '/': DXN.fromLocalObjectId(Object.keys(PEOPLE.alice.objects!)[0]).toString() },\n        },\n      }),\n    },\n  }),\n};\n"],
  "mappings": "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",
  "names": ["import_credentials", "import_log", "import_async", "import_context", "import_invariant", "import_keys", "EchoMetadata", "schema", "getCodecForType", "changeStorageVersionInMetadata", "storage", "version", "log", "metadata", "MetadataStore", "createDirectory", "load", "echoMetadata", "file", "_directory", "getOrCreateFile", "_writeFile", "flush", "TestFeedBuilder", "TestBuilder", "valueEncoding", "MemoryNetworkManagerProvider", "signalContext", "SwarmNetworkManager", "signalManager", "MemorySignalManager", "transportFactory", "MemoryTransportFactory", "WebsocketNetworkManagerProvider", "signalUrl", "WebsocketSignalManager", "server", "createRtcTransportFactory", "TestAgentBuilder", "networkManagerProvider", "_agents", "ComplexMap", "PublicKey", "hash", "_storage", "createStorage", "type", "StorageType", "RAM", "_networkManagerProvider", "MemorySignalManagerContext", "close", "Promise", "all", "agents", "map", "agent", "Array", "from", "values", "getAgent", "deviceKey", "get", "createPeer", "feedBuilder", "setStorage", "size", "identityKey", "keyring", "createKey", "TestAgent", "set", "metadataStore", "_metadataStore", "blobStore", "_blobStore", "BlobStore", "_feedBuilder", "_spaces", "feedStore", "createFeedStore", "spaces", "space", "getSpace", "spaceKey", "networkManager", "_networkManager", "setPeerInfo", "peerKey", "toHex", "spaceManager", "_spaceManager", "SpaceManager", "createSpace", "genesisKey", "dataKey", "saveMetadata", "controlFeed", "openFeed", "writable", "dataFeed", "sparse", "key", "genesisFeedKey", "controlFeedKey", "dataFeedKey", "addSpace", "open", "constructSpace", "swarmIdentity", "credentialProvider", "MOCK_AUTH_PROVIDER", "credentialAuthenticator", "MOCK_AUTH_VERIFIER", "memberKey", "onAuthorizedConnection", "session", "addExtension", "createGossip", "createExtension", "remotePeerId", "onDelegatedInvitationStatusChange", "onMemberRolesChanged", "setControlFeed", "setDataFeed", "Context", "createSpaceProtocol", "topic", "gossip", "SpaceProtocol", "onSessionAuth", "Gossip", "localPeerId", "createPresence", "Presence", "announceInterval", "offlineTimeout", "spaceGenesis", "generator", "CredentialGenerator", "credentials", "createSpaceGenesis", "createFeedAdmission", "AdmittedFeed", "Designation", "DATA", "createEpochCredential", "credential", "controlPipeline", "writer", "write", "TestAdapter", "NetworkAdapter", "createPair", "connectionStateProvider", "adapter1", "send", "message", "sleep", "then", "adapter2", "receive", "_params", "onConnect", "Trigger", "isReady", "whenReady", "resolve", "connect", "peerId", "wake", "peerCandidate", "invariant", "emit", "peerMetadata", "peerDisconnected", "senderId", "to", "targetId", "disconnect", "undefined", "TestReplicationNetwork", "Resource", "options", "_replicators", "Set", "_latency", "latency", "_close", "ctx", "replicator", "connection", "connections", "abort", "readable", "cancel", "createReplicator", "TestReplicator", "_lifecycleState", "LifecycleState", "OPEN", "_connectReplicator", "onDisconnect", "_disconnectReplicator", "add", "otherReplicator", "connected", "context", "connection1", "connection2", "_createConnectionPair", "onConnectionOpen", "onConnectionClosed", "otherSide", "owningReplicator", "removeConnection", "peer1", "peer2", "LOG", "forward", "TransformStream", "transform", "controller", "enqueue", "backwards", "TestReplicatorConnection", "addConnection", "delete", "shouldAdvertise", "params", "shouldSyncCollection", "testAutomergeReplicatorFactory", "AutomergeReplicator", "sendSyncRetryPolicy", "retryBackoff", "retriesBeforeBackoff", "maxRetries", "brokenAutomergeReplicatorFactory", "onSyncMessage", "Error", "Person", "Schema", "Struct", "name", "String", "email", "optional", "age", "Number", "pipe", "Type", "Obj", "typename", "Organization", "WorksFor", "since", "Relation", "source", "target", "Task", "title", "createdAt", "assignee", "Ref", "random", "PEOPLE", "fred", "DatabaseDirectory", "make", "objects", "ObjectId", "ObjectStructure", "makeObject", "getSchemaDXN", "toString", "data", "alice", "ORGS", "cyberdyne", "founded", "aperture", "WORKS_FOR", "fredWorksForCyberdyne", "makeRelation", "DXN", "fromLocalObjectId", "Object", "keys", "position", "aliceWorksForAperture", "TASKS", "task1", "description", "status", "dueDate", "task2"]
}
