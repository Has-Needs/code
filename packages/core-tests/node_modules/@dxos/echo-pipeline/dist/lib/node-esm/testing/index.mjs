import { createRequire } from 'node:module';const require = createRequire(import.meta.url);
import {
  MOCK_AUTH_PROVIDER,
  MOCK_AUTH_VERIFIER,
  MetadataStore,
  SpaceManager,
  SpaceProtocol,
  valueEncoding
} from "../chunk-5BHLPT24.mjs";
import {
  __export
} from "../chunk-HSLMI22Q.mjs";

// packages/core/echo/echo-pipeline/src/testing/change-metadata.ts
import { log } from "@dxos/log";
import { schema } from "@dxos/protocols/proto";
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/core/echo/echo-pipeline/src/testing/change-metadata.ts";
var EchoMetadata = schema.getCodecForType("dxos.echo.metadata.EchoMetadata");
var changeStorageVersionInMetadata = async (storage, version) => {
  log("Changing storage version in metadata. USE ONLY FOR TESTING.", void 0, {
    F: __dxlog_file,
    L: 19,
    S: void 0,
    C: (f, a) => f(...a)
  });
  const metadata = new MetadataStore(storage.createDirectory("metadata"));
  await metadata.load();
  const echoMetadata = metadata.metadata;
  echoMetadata.version = version;
  const file = metadata._directory.getOrCreateFile("EchoMetadata");
  await metadata._writeFile(file, EchoMetadata, echoMetadata);
  await metadata._directory.flush();
};

// packages/core/echo/echo-pipeline/src/testing/test-agent-builder.ts
import { Context } from "@dxos/context";
import { CredentialGenerator } from "@dxos/credentials";
import { PublicKey } from "@dxos/keys";
import { MemorySignalManager, MemorySignalManagerContext, WebsocketSignalManager } from "@dxos/messaging";
import { MemoryTransportFactory, SwarmNetworkManager, createRtcTransportFactory } from "@dxos/network-manager";
import { AdmittedFeed } from "@dxos/protocols/proto/dxos/halo/credentials";
import { StorageType, createStorage } from "@dxos/random-access-storage";
import { Gossip, Presence } from "@dxos/teleport-extension-gossip";
import { BlobStore } from "@dxos/teleport-extension-object-sync";
import { ComplexMap } from "@dxos/util";

// packages/core/echo/echo-pipeline/src/testing/test-feed-builder.ts
import { TestBuilder } from "@dxos/feed-store/testing";
var TestFeedBuilder = class extends TestBuilder {
  constructor() {
    super({
      valueEncoding
    });
  }
};

// packages/core/echo/echo-pipeline/src/testing/test-agent-builder.ts
var __dxlog_file2 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-pipeline/src/testing/test-agent-builder.ts";
var MemoryNetworkManagerProvider = (signalContext) => () => new SwarmNetworkManager({
  signalManager: new MemorySignalManager(signalContext),
  transportFactory: MemoryTransportFactory
});
var WebsocketNetworkManagerProvider = (signalUrl) => () => new SwarmNetworkManager({
  signalManager: new WebsocketSignalManager([
    {
      server: signalUrl
    }
  ]),
  transportFactory: createRtcTransportFactory()
});
var TestAgentBuilder = class {
  constructor({ storage, networkManagerProvider } = {}) {
    this._agents = new ComplexMap(PublicKey.hash);
    this._storage = storage ?? createStorage({
      type: StorageType.RAM
    });
    this._networkManagerProvider = networkManagerProvider ?? MemoryNetworkManagerProvider(new MemorySignalManagerContext());
  }
  async close() {
    return Promise.all(this.agents.map((agent) => agent.close()));
  }
  get agents() {
    return Array.from(this._agents.values());
  }
  getAgent(deviceKey) {
    return this._agents.get(deviceKey);
  }
  async createPeer() {
    const feedBuilder = new TestFeedBuilder().setStorage(this._storage, `agent-${this._agents.size}`);
    const identityKey = await feedBuilder.keyring.createKey();
    const deviceKey = await feedBuilder.keyring.createKey();
    const agent = new TestAgent(this._networkManagerProvider, feedBuilder, identityKey, deviceKey);
    this._agents.set(deviceKey, agent);
    return agent;
  }
};
var TestAgent = class {
  get metadataStore() {
    return this._metadataStore ??= new MetadataStore(this.storage.createDirectory("metadata"));
  }
  get blobStore() {
    return this._blobStore ??= new BlobStore(this.storage.createDirectory("blobs"));
  }
  constructor(_networkManagerProvider, _feedBuilder, identityKey, deviceKey) {
    this._networkManagerProvider = _networkManagerProvider;
    this._feedBuilder = _feedBuilder;
    this.identityKey = identityKey;
    this.deviceKey = deviceKey;
    this._spaces = new ComplexMap(PublicKey.hash);
    this.storage = this._feedBuilder.storage;
    this.keyring = this._feedBuilder.keyring;
    this.feedStore = this._feedBuilder.createFeedStore();
  }
  async close() {
    return Promise.all([
      ...this.spaces.map((space) => space.close())
    ]);
  }
  get spaces() {
    return Array.from(this._spaces.values());
  }
  getSpace(spaceKey2) {
    return this._spaces.get(spaceKey2);
  }
  get networkManager() {
    if (this._networkManager) {
      return this._networkManager;
    }
    this._networkManager = this._networkManagerProvider();
    this._networkManager.setPeerInfo({
      peerKey: this.deviceKey.toHex(),
      identityKey: this.identityKey.toHex()
    });
    return this._networkManager;
  }
  get spaceManager() {
    return this._spaceManager ??= new SpaceManager({
      feedStore: this.feedStore,
      networkManager: this.networkManager,
      metadataStore: this.metadataStore,
      blobStore: this.blobStore
    });
  }
  async createSpace(identityKey = this.identityKey, spaceKey2, genesisKey, dataKey, saveMetadata = false) {
    if (!spaceKey2) {
      saveMetadata = true;
      spaceKey2 = await this.keyring.createKey();
    }
    if (!genesisKey) {
      genesisKey = await this.keyring.createKey();
    }
    const controlFeed = await this.feedStore.openFeed(genesisKey, {
      writable: true
    });
    const dataFeed = await this.feedStore.openFeed(dataKey ?? await this.keyring.createKey(), {
      writable: true,
      sparse: true
    });
    const metadata = {
      key: spaceKey2,
      genesisFeedKey: genesisKey,
      controlFeedKey: controlFeed.key,
      dataFeedKey: dataFeed.key
    };
    if (saveMetadata) {
      await this.metadataStore.addSpace(metadata);
    }
    await this.spaceManager.open();
    const space = await this.spaceManager.constructSpace({
      metadata,
      swarmIdentity: {
        identityKey: this.identityKey,
        peerKey: this.deviceKey,
        credentialProvider: MOCK_AUTH_PROVIDER,
        credentialAuthenticator: MOCK_AUTH_VERIFIER
      },
      memberKey: identityKey,
      onAuthorizedConnection: (session) => {
        session.addExtension("dxos.mesh.teleport.gossip", this.createGossip().createExtension({
          remotePeerId: session.remotePeerId
        }));
      },
      onDelegatedInvitationStatusChange: async () => {
      },
      onMemberRolesChanged: async () => {
      }
    });
    await space.setControlFeed(controlFeed);
    await space.setDataFeed(dataFeed);
    await space.open(new Context(void 0, {
      F: __dxlog_file2,
      L: 205
    }));
    this._spaces.set(spaceKey2, space);
    return space;
  }
  createSpaceProtocol(topic, gossip) {
    return new SpaceProtocol({
      topic,
      swarmIdentity: {
        identityKey: this.identityKey,
        peerKey: this.deviceKey,
        credentialProvider: MOCK_AUTH_PROVIDER,
        credentialAuthenticator: MOCK_AUTH_VERIFIER
      },
      networkManager: this.networkManager,
      blobStore: this.blobStore,
      onSessionAuth: (session) => {
        session.addExtension("dxos.mesh.teleport.gossip", (gossip ?? this.createGossip()).createExtension({
          remotePeerId: session.remotePeerId
        }));
      }
    });
  }
  createGossip() {
    return new Gossip({
      localPeerId: this.deviceKey
    });
  }
  createPresence(gossip) {
    return new Presence({
      announceInterval: 30,
      offlineTimeout: 200,
      identityKey: this.identityKey,
      gossip: gossip ?? this.createGossip()
    });
  }
  async spaceGenesis(space) {
    const generator = new CredentialGenerator(this.keyring, this.identityKey, this.deviceKey);
    const credentials = [
      ...await generator.createSpaceGenesis(space.key, space.controlFeedKey),
      await generator.createFeedAdmission(space.key, space.dataFeedKey, AdmittedFeed.Designation.DATA),
      await generator.createEpochCredential(space.key)
    ];
    for (const credential of credentials) {
      await space.controlPipeline.writer.write({
        credential: {
          credential
        }
      });
    }
  }
};

// packages/core/echo/echo-pipeline/src/testing/test-network-adapter.ts
import { NetworkAdapter } from "@automerge/automerge-repo";
import { Trigger, sleep } from "@dxos/async";
import { invariant } from "@dxos/invariant";
import { log as log2 } from "@dxos/log";
var __dxlog_file3 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-pipeline/src/testing/test-network-adapter.ts";
var TestAdapter = class _TestAdapter extends NetworkAdapter {
  static createPair(connectionStateProvider = () => "on") {
    const adapter1 = new _TestAdapter({
      send: (message) => connectionStateProvider() === "on" && sleep(10).then(() => adapter2.receive(message))
    });
    const adapter2 = new _TestAdapter({
      send: (message) => connectionStateProvider() === "on" && sleep(10).then(() => adapter1.receive(message))
    });
    return [
      adapter1,
      adapter2
    ];
  }
  constructor(_params) {
    super(), this._params = _params, this.onConnect = new Trigger();
  }
  isReady() {
    return true;
  }
  whenReady() {
    return Promise.resolve();
  }
  connect(peerId) {
    this.peerId = peerId;
    this.onConnect.wake();
  }
  peerCandidate(peerId) {
    invariant(peerId, "PeerId is required", {
      F: __dxlog_file3,
      L: 45,
      S: this,
      A: [
        "peerId",
        "'PeerId is required'"
      ]
    });
    this.emit("peer-candidate", {
      peerId,
      peerMetadata: {}
    });
  }
  peerDisconnected(peerId) {
    invariant(peerId, "PeerId is required", {
      F: __dxlog_file3,
      L: 50,
      S: this,
      A: [
        "peerId",
        "'PeerId is required'"
      ]
    });
    this.emit("peer-disconnected", {
      peerId
    });
  }
  send(message) {
    log2("send", {
      from: message.senderId,
      to: message.targetId,
      type: message.type
    }, {
      F: __dxlog_file3,
      L: 55,
      S: this,
      C: (f, a) => f(...a)
    });
    this._params.send(message);
  }
  disconnect() {
    this.peerId = void 0;
  }
  receive(message) {
    invariant(this.peerId, "Peer id is not set", {
      F: __dxlog_file3,
      L: 64,
      S: this,
      A: [
        "this.peerId",
        "'Peer id is not set'"
      ]
    });
    this.emit("message", message);
  }
};

// packages/core/echo/echo-pipeline/src/testing/test-replicator.ts
import { sleep as sleep2, synchronized } from "@dxos/async";
import { LifecycleState, Resource } from "@dxos/context";
import { invariant as invariant2 } from "@dxos/invariant";
import { log as log3 } from "@dxos/log";
import { AutomergeReplicator } from "@dxos/teleport-extension-automerge-replicator";
function _ts_decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file4 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-pipeline/src/testing/test-replicator.ts";
var TestReplicationNetwork = class extends Resource {
  constructor(options = {}) {
    super();
    this._replicators = /* @__PURE__ */ new Set();
    this._latency = void 0;
    this._latency = options.latency;
  }
  async _close(ctx) {
    for (const replicator of this._replicators) {
      for (const connection of replicator.connections) {
        void connection.writable.abort();
        void connection.readable.cancel();
      }
    }
  }
  async createReplicator() {
    const replicator = new TestReplicator({
      onConnect: async () => {
        invariant2(this._lifecycleState === LifecycleState.OPEN, void 0, {
          F: __dxlog_file4,
          L: 45,
          S: this,
          A: [
            "this._lifecycleState === LifecycleState.OPEN",
            ""
          ]
        });
        await this._connectReplicator(replicator);
      },
      onDisconnect: async () => {
        invariant2(this._lifecycleState === LifecycleState.OPEN, void 0, {
          F: __dxlog_file4,
          L: 49,
          S: this,
          A: [
            "this._lifecycleState === LifecycleState.OPEN",
            ""
          ]
        });
        await this._disconnectReplicator(replicator);
      }
    });
    this._replicators.add(replicator);
    return replicator;
  }
  async _connectReplicator(replicator) {
    for (const otherReplicator of this._replicators.values()) {
      if (otherReplicator === replicator || !otherReplicator.connected) {
        continue;
      }
      log3("create connection", {
        from: replicator.context.peerId,
        to: otherReplicator.context.peerId
      }, {
        F: __dxlog_file4,
        L: 63,
        S: this,
        C: (f, a) => f(...a)
      });
      const [connection1, connection2] = this._createConnectionPair(replicator.context.peerId, otherReplicator.context.peerId);
      await replicator.context.onConnectionOpen(connection1);
      await otherReplicator.context.onConnectionOpen(connection2);
    }
  }
  async _disconnectReplicator(replicator) {
    for (const connection of replicator.connections) {
      await replicator.context.onConnectionClosed(connection);
      await connection.otherSide.owningReplicator.removeConnection(connection.otherSide);
    }
  }
  _createConnectionPair(peer1, peer2) {
    const LOG = false;
    const forward = new TransformStream({
      transform: async (message, controller) => {
        if (LOG) {
          log3("replicate", {
            from: peer1,
            to: peer2,
            message
          }, {
            F: __dxlog_file4,
            L: 86,
            S: this,
            C: (f, a) => f(...a)
          });
        }
        if (this._latency !== void 0) {
          await sleep2(this._latency);
        }
        controller.enqueue(message);
      }
    });
    const backwards = new TransformStream({
      transform: async (message, controller) => {
        if (LOG) {
          log3("replicate", {
            from: peer2,
            to: peer1,
            message
          }, {
            F: __dxlog_file4,
            L: 99,
            S: this,
            C: (f, a) => f(...a)
          });
        }
        if (this._latency !== void 0) {
          await sleep2(this._latency);
        }
        controller.enqueue(message);
      }
    });
    const connection1 = new TestReplicatorConnection(peer2, backwards.readable, forward.writable);
    const connection2 = new TestReplicatorConnection(peer1, forward.readable, backwards.writable);
    connection1.otherSide = connection2;
    connection2.otherSide = connection1;
    return [
      connection1,
      connection2
    ];
  }
};
_ts_decorate([
  synchronized
], TestReplicationNetwork.prototype, "_connectReplicator", null);
var TestReplicator = class {
  constructor(_params) {
    this._params = _params;
    this.connected = false;
    this.context = void 0;
    this.connections = /* @__PURE__ */ new Set();
  }
  async connect(context) {
    log3("connect", {
      peerId: context.peerId
    }, {
      F: __dxlog_file4,
      L: 131,
      S: this,
      C: (f, a) => f(...a)
    });
    this.context = context;
    this.connected = true;
    await this._params.onConnect();
  }
  async disconnect() {
    log3("disconnect", {
      peerId: this.context.peerId
    }, {
      F: __dxlog_file4,
      L: 138,
      S: this,
      C: (f, a) => f(...a)
    });
    this.connected = false;
    await this._params.onDisconnect();
  }
  async addConnection(connection) {
    connection.owningReplicator = this;
    this.connections.add(connection);
    this.context.onConnectionOpen(connection);
  }
  async removeConnection(connection) {
    connection.owningReplicator = void 0;
    this.context.onConnectionClosed(connection);
    this.connections.delete(connection);
  }
};
var TestReplicatorConnection = class {
  constructor(peerId, readable, writable) {
    this.peerId = peerId;
    this.readable = readable;
    this.writable = writable;
    this.otherSide = void 0;
    this.owningReplicator = void 0;
  }
  async shouldAdvertise(params) {
    return true;
  }
  shouldSyncCollection(params) {
    return true;
  }
};
var testAutomergeReplicatorFactory = (params) => {
  return new AutomergeReplicator({
    ...params[0],
    sendSyncRetryPolicy: {
      retryBackoff: 20,
      retriesBeforeBackoff: 2,
      maxRetries: 3
    }
  }, params[1]);
};
var brokenAutomergeReplicatorFactory = (params) => {
  params[1].onSyncMessage = () => {
    throw new Error();
  };
  return testAutomergeReplicatorFactory(params);
};

// packages/core/echo/echo-pipeline/src/testing/test-schema.ts
var test_schema_exports = {};
__export(test_schema_exports, {
  Organization: () => Organization,
  Person: () => Person,
  Task: () => Task,
  WorksFor: () => WorksFor
});
import { Schema } from "effect";
import { Type } from "@dxos/echo";
var Person = Schema.Struct({
  name: Schema.String,
  email: Schema.optional(Schema.String),
  age: Schema.optional(Schema.Number)
}).pipe(Type.Obj({
  typename: "dxos.org/type/Person",
  version: "0.1.0"
}));
var Organization = Schema.Struct({
  name: Schema.String
}).pipe(Type.Obj({
  typename: "dxos.org/type/Organization",
  version: "0.1.0"
}));
var WorksFor = Schema.Struct({
  since: Schema.String
}).pipe(Type.Relation({
  typename: "dxos.org/type/WorksFor",
  version: "0.1.0",
  source: Person,
  target: Organization
}));
var Task = Schema.Struct({
  title: Schema.String,
  createdAt: Schema.String,
  assignee: Type.Ref(Person)
}).pipe(Type.Obj({
  typename: "dxos.org/type/Task",
  version: "0.1.0"
}));

// packages/core/echo/echo-pipeline/src/testing/test-data.ts
var test_data_exports = {};
__export(test_data_exports, {
  ORGS: () => ORGS,
  PEOPLE: () => PEOPLE,
  TASKS: () => TASKS,
  WORKS_FOR: () => WORKS_FOR
});
import { DatabaseDirectory, ObjectStructure } from "@dxos/echo-protocol";
import { getSchemaDXN } from "@dxos/echo-schema";
import { DXN, ObjectId, PublicKey as PublicKey2 } from "@dxos/keys";
var spaceKey = PublicKey2.random();
var PEOPLE = {
  fred: DatabaseDirectory.make({
    spaceKey: spaceKey.toHex(),
    objects: {
      [ObjectId.random()]: ObjectStructure.makeObject({
        type: getSchemaDXN(Person).toString(),
        data: {
          name: "Fred"
        }
      })
    }
  }),
  alice: DatabaseDirectory.make({
    spaceKey: spaceKey.toHex(),
    objects: {
      [ObjectId.random()]: ObjectStructure.makeObject({
        type: getSchemaDXN(Person).toString(),
        data: {
          name: "Alice"
        }
      })
    }
  })
};
var ORGS = {
  cyberdyne: DatabaseDirectory.make({
    spaceKey: spaceKey.toHex(),
    objects: {
      [ObjectId.random()]: ObjectStructure.makeObject({
        type: getSchemaDXN(Organization).toString(),
        data: {
          name: "Cyberdyne Systems",
          founded: "1984"
        }
      })
    }
  }),
  aperture: DatabaseDirectory.make({
    spaceKey: spaceKey.toHex(),
    objects: {
      [ObjectId.random()]: ObjectStructure.makeObject({
        type: getSchemaDXN(Organization).toString(),
        data: {
          name: "Aperture Science",
          founded: "1953"
        }
      })
    }
  })
};
var WORKS_FOR = {
  fredWorksForCyberdyne: DatabaseDirectory.make({
    spaceKey: spaceKey.toHex(),
    objects: {
      [ObjectId.random()]: ObjectStructure.makeRelation({
        type: getSchemaDXN(WorksFor).toString(),
        source: {
          "/": DXN.fromLocalObjectId(Object.keys(PEOPLE.fred.objects)[0]).toString()
        },
        target: {
          "/": DXN.fromLocalObjectId(Object.keys(ORGS.cyberdyne.objects)[0]).toString()
        },
        data: {
          since: "2020",
          position: "Engineer"
        }
      })
    }
  }),
  aliceWorksForAperture: DatabaseDirectory.make({
    spaceKey: spaceKey.toHex(),
    objects: {
      [ObjectId.random()]: ObjectStructure.makeRelation({
        type: getSchemaDXN(WorksFor).toString(),
        source: {
          "/": DXN.fromLocalObjectId(Object.keys(PEOPLE.alice.objects)[0]).toString()
        },
        target: {
          "/": DXN.fromLocalObjectId(Object.keys(ORGS.aperture.objects)[0]).toString()
        },
        data: {
          since: "2018",
          position: "Research Scientist"
        }
      })
    }
  })
};
var TASKS = {
  task1: DatabaseDirectory.make({
    spaceKey: spaceKey.toHex(),
    objects: {
      [ObjectId.random()]: ObjectStructure.makeObject({
        type: getSchemaDXN(Task).toString(),
        data: {
          title: "Complete project documentation",
          description: "Write comprehensive documentation for the new system",
          status: "in-progress",
          dueDate: "2023-12-31",
          assignee: {
            "/": DXN.fromLocalObjectId(Object.keys(PEOPLE.fred.objects)[0]).toString()
          }
        }
      })
    }
  }),
  task2: DatabaseDirectory.make({
    spaceKey: spaceKey.toHex(),
    objects: {
      [ObjectId.random()]: ObjectStructure.makeObject({
        type: getSchemaDXN(Task).toString(),
        data: {
          title: "Run experiments",
          description: "Conduct series of experiments on the portal device",
          status: "pending",
          dueDate: "2023-11-15",
          assignee: {
            "/": DXN.fromLocalObjectId(Object.keys(PEOPLE.alice.objects)[0]).toString()
          }
        }
      })
    }
  })
};
export {
  MemoryNetworkManagerProvider,
  TestAdapter,
  TestAgent,
  TestAgentBuilder,
  test_data_exports as TestData,
  TestFeedBuilder,
  TestReplicationNetwork,
  TestReplicator,
  TestReplicatorConnection,
  test_schema_exports as TestSchema,
  WebsocketNetworkManagerProvider,
  brokenAutomergeReplicatorFactory,
  changeStorageVersionInMetadata,
  testAutomergeReplicatorFactory
};
//# sourceMappingURL=index.mjs.map
