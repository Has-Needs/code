{
  "version": 3,
  "sources": ["../../../../src/testing/change-metadata.ts", "../../../../src/testing/test-agent-builder.ts", "../../../../src/testing/test-feed-builder.ts", "../../../../src/testing/test-network-adapter.ts", "../../../../src/testing/test-replicator.ts", "../../../../src/testing/test-schema.ts", "../../../../src/testing/test-data.ts"],
  "sourcesContent": ["//\n// Copyright 2023 DXOS.org\n//\n\nimport { log } from '@dxos/log';\nimport { schema } from '@dxos/protocols/proto';\nimport type { Storage } from '@dxos/random-access-storage';\n\nimport { MetadataStore } from '../metadata';\n\nconst EchoMetadata = schema.getCodecForType('dxos.echo.metadata.EchoMetadata');\n\n/**\n * This function will change the storage version in the metadata.\n * This will break your storage and make it unusable.\n * Use this only for testing purposes.\n */\nexport const changeStorageVersionInMetadata = async (storage: Storage, version: number) => {\n  log('Changing storage version in metadata. USE ONLY FOR TESTING.');\n  const metadata = new MetadataStore(storage.createDirectory('metadata'));\n  await metadata.load();\n  const echoMetadata = metadata.metadata;\n  echoMetadata.version = version;\n  const file = metadata._directory.getOrCreateFile('EchoMetadata');\n  await metadata._writeFile(file, EchoMetadata, echoMetadata);\n  await metadata._directory.flush();\n};\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { Context } from '@dxos/context';\nimport { CredentialGenerator } from '@dxos/credentials';\nimport { type FeedStore } from '@dxos/feed-store';\nimport { type Keyring } from '@dxos/keyring';\nimport { PublicKey } from '@dxos/keys';\nimport { MemorySignalManager, MemorySignalManagerContext, WebsocketSignalManager } from '@dxos/messaging';\nimport { MemoryTransportFactory, SwarmNetworkManager, createRtcTransportFactory } from '@dxos/network-manager';\nimport { type FeedMessage } from '@dxos/protocols/proto/dxos/echo/feed';\nimport { type SpaceMetadata } from '@dxos/protocols/proto/dxos/echo/metadata';\nimport { AdmittedFeed } from '@dxos/protocols/proto/dxos/halo/credentials';\nimport { StorageType, createStorage, type Storage } from '@dxos/random-access-storage';\nimport { Gossip, Presence } from '@dxos/teleport-extension-gossip';\nimport { BlobStore } from '@dxos/teleport-extension-object-sync';\nimport { ComplexMap } from '@dxos/util';\n\nimport { TestFeedBuilder } from './test-feed-builder';\nimport { MetadataStore } from '../metadata';\nimport { MOCK_AUTH_PROVIDER, MOCK_AUTH_VERIFIER, SpaceManager, SpaceProtocol, type Space } from '../space';\n\nexport type NetworkManagerProvider = () => SwarmNetworkManager;\n\nexport const MemoryNetworkManagerProvider =\n  (signalContext: MemorySignalManagerContext): NetworkManagerProvider =>\n  () =>\n    new SwarmNetworkManager({\n      signalManager: new MemorySignalManager(signalContext),\n      transportFactory: MemoryTransportFactory,\n    });\n\nexport const WebsocketNetworkManagerProvider =\n  (signalUrl: string): NetworkManagerProvider =>\n  () =>\n    new SwarmNetworkManager({\n      signalManager: new WebsocketSignalManager([{ server: signalUrl }]),\n      transportFactory: createRtcTransportFactory(),\n    });\n\nexport type TestAgentBuilderOptions = {\n  storage?: Storage;\n  networkManagerProvider?: NetworkManagerProvider;\n};\n\n/**\n * Factory for test agents.\n */\nexport class TestAgentBuilder {\n  private readonly _agents = new ComplexMap<PublicKey, TestAgent>(PublicKey.hash);\n  private readonly _storage: Storage;\n  private readonly _networkManagerProvider: NetworkManagerProvider;\n\n  constructor({ storage, networkManagerProvider }: TestAgentBuilderOptions = {}) {\n    this._storage = storage ?? createStorage({ type: StorageType.RAM });\n    this._networkManagerProvider =\n      networkManagerProvider ?? MemoryNetworkManagerProvider(new MemorySignalManagerContext());\n  }\n\n  async close() {\n    return Promise.all(this.agents.map((agent) => agent.close()));\n  }\n\n  get agents() {\n    return Array.from(this._agents.values());\n  }\n\n  getAgent(deviceKey: PublicKey): TestAgent | undefined {\n    return this._agents.get(deviceKey);\n  }\n\n  async createPeer(): Promise<TestAgent> {\n    // prettier-ignore\n    const feedBuilder = new TestFeedBuilder()\n      .setStorage(this._storage, `agent-${this._agents.size}`);\n\n    const identityKey = await feedBuilder.keyring.createKey();\n    const deviceKey = await feedBuilder.keyring.createKey();\n\n    const agent = new TestAgent(this._networkManagerProvider, feedBuilder, identityKey, deviceKey);\n    this._agents.set(deviceKey, agent);\n    return agent;\n  }\n}\n\n/**\n * Test agent that enables the creation and replication of multiple spaces.\n */\nexport class TestAgent {\n  private readonly _spaces = new ComplexMap<PublicKey, Space>(PublicKey.hash);\n\n  public readonly storage: Storage;\n  public readonly keyring: Keyring;\n  public readonly feedStore: FeedStore<FeedMessage>;\n\n  private _metadataStore?: MetadataStore;\n  get metadataStore() {\n    return (this._metadataStore ??= new MetadataStore(this.storage.createDirectory('metadata')));\n  }\n\n  private _blobStore?: BlobStore;\n  get blobStore() {\n    return (this._blobStore ??= new BlobStore(this.storage.createDirectory('blobs')));\n  }\n\n  constructor(\n    private readonly _networkManagerProvider: NetworkManagerProvider,\n    private readonly _feedBuilder: TestFeedBuilder,\n    public readonly identityKey: PublicKey,\n    public readonly deviceKey: PublicKey,\n  ) {\n    this.storage = this._feedBuilder.storage;\n    this.keyring = this._feedBuilder.keyring;\n    this.feedStore = this._feedBuilder.createFeedStore();\n  }\n\n  async close() {\n    return Promise.all([...this.spaces.map((space) => space.close())]);\n  }\n\n  get spaces() {\n    return Array.from(this._spaces.values());\n  }\n\n  getSpace(spaceKey: PublicKey): Space | undefined {\n    return this._spaces.get(spaceKey);\n  }\n\n  private _networkManager?: SwarmNetworkManager;\n  get networkManager() {\n    if (this._networkManager) {\n      return this._networkManager;\n    }\n\n    this._networkManager = this._networkManagerProvider();\n    this._networkManager.setPeerInfo({ peerKey: this.deviceKey.toHex(), identityKey: this.identityKey.toHex() });\n\n    return this._networkManager;\n  }\n\n  private _spaceManager?: SpaceManager;\n  get spaceManager() {\n    return (this._spaceManager ??= new SpaceManager({\n      feedStore: this.feedStore,\n      networkManager: this.networkManager,\n      metadataStore: this.metadataStore,\n      blobStore: this.blobStore,\n    }));\n  }\n\n  async createSpace(\n    identityKey: PublicKey = this.identityKey,\n    spaceKey?: PublicKey,\n    genesisKey?: PublicKey,\n    dataKey?: PublicKey,\n    saveMetadata = false,\n  ): Promise<Space> {\n    if (!spaceKey) {\n      saveMetadata = true;\n      spaceKey = await this.keyring.createKey();\n    }\n    if (!genesisKey) {\n      genesisKey = await this.keyring.createKey();\n    }\n\n    const controlFeed = await this.feedStore.openFeed(genesisKey, { writable: true });\n    const dataFeed = await this.feedStore.openFeed(dataKey ?? (await this.keyring.createKey()), {\n      writable: true,\n      sparse: true,\n    });\n\n    const metadata: SpaceMetadata = {\n      key: spaceKey,\n      genesisFeedKey: genesisKey,\n      controlFeedKey: controlFeed.key,\n      dataFeedKey: dataFeed.key,\n    };\n    if (saveMetadata) {\n      await this.metadataStore.addSpace(metadata);\n    }\n\n    await this.spaceManager.open();\n    const space = await this.spaceManager.constructSpace({\n      metadata,\n      swarmIdentity: {\n        identityKey: this.identityKey,\n        peerKey: this.deviceKey,\n        credentialProvider: MOCK_AUTH_PROVIDER,\n        credentialAuthenticator: MOCK_AUTH_VERIFIER,\n      },\n      memberKey: identityKey,\n      onAuthorizedConnection: (session) => {\n        session.addExtension(\n          'dxos.mesh.teleport.gossip',\n          this.createGossip().createExtension({ remotePeerId: session.remotePeerId }),\n        );\n      },\n      onDelegatedInvitationStatusChange: async () => {},\n      onMemberRolesChanged: async () => {},\n    });\n    await space.setControlFeed(controlFeed);\n    await space.setDataFeed(dataFeed);\n\n    await space.open(new Context());\n\n    this._spaces.set(spaceKey, space);\n    return space;\n  }\n\n  createSpaceProtocol(topic: PublicKey, gossip?: Gossip): SpaceProtocol {\n    return new SpaceProtocol({\n      topic,\n      swarmIdentity: {\n        identityKey: this.identityKey,\n        peerKey: this.deviceKey,\n        credentialProvider: MOCK_AUTH_PROVIDER,\n        credentialAuthenticator: MOCK_AUTH_VERIFIER,\n      },\n      networkManager: this.networkManager,\n      blobStore: this.blobStore,\n      onSessionAuth: (session) => {\n        session.addExtension(\n          'dxos.mesh.teleport.gossip',\n          (gossip ?? this.createGossip()).createExtension({ remotePeerId: session.remotePeerId }),\n        );\n      },\n    });\n  }\n\n  createGossip(): Gossip {\n    return new Gossip({\n      localPeerId: this.deviceKey,\n    });\n  }\n\n  createPresence(gossip?: Gossip): Presence {\n    return new Presence({\n      announceInterval: 30,\n      offlineTimeout: 200,\n      identityKey: this.identityKey,\n      gossip: gossip ?? this.createGossip(),\n    });\n  }\n\n  async spaceGenesis(space: Space): Promise<void> {\n    const generator = new CredentialGenerator(this.keyring, this.identityKey, this.deviceKey);\n    const credentials = [\n      ...(await generator.createSpaceGenesis(space.key, space.controlFeedKey!)),\n      await generator.createFeedAdmission(space.key, space.dataFeedKey!, AdmittedFeed.Designation.DATA),\n      await generator.createEpochCredential(space.key),\n    ];\n\n    for (const credential of credentials) {\n      await space.controlPipeline.writer.write({\n        credential: { credential },\n      });\n    }\n  }\n}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { TestBuilder } from '@dxos/feed-store/testing';\nimport type { FeedMessage } from '@dxos/protocols/proto/dxos/echo/feed';\n\nimport { valueEncoding } from '../common';\n\n/**\n * Builder with default encoder and generator.\n */\nexport class TestFeedBuilder extends TestBuilder<FeedMessage> {\n  constructor() {\n    super({\n      valueEncoding,\n    });\n  }\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { type Message, NetworkAdapter, type PeerId } from '@automerge/automerge-repo';\n\nimport { Trigger, sleep } from '@dxos/async';\nimport { invariant } from '@dxos/invariant';\nimport { log } from '@dxos/log';\n\nexport type TestConnectionStateProvider = () => 'on' | 'off';\n\nexport class TestAdapter extends NetworkAdapter {\n  static createPair(connectionStateProvider: TestConnectionStateProvider = () => 'on'): TestAdapter[] {\n    const adapter1: TestAdapter = new TestAdapter({\n      send: (message: Message) => connectionStateProvider() === 'on' && sleep(10).then(() => adapter2.receive(message)),\n    });\n    const adapter2: TestAdapter = new TestAdapter({\n      send: (message: Message) => connectionStateProvider() === 'on' && sleep(10).then(() => adapter1.receive(message)),\n    });\n\n    return [adapter1, adapter2];\n  }\n\n  public onConnect = new Trigger();\n\n  constructor(private readonly _params: { send: (message: Message) => void }) {\n    super();\n  }\n\n  override isReady(): boolean {\n    return true;\n  }\n\n  override whenReady(): Promise<void> {\n    return Promise.resolve();\n  }\n\n  override connect(peerId: PeerId): void {\n    this.peerId = peerId;\n    this.onConnect.wake();\n  }\n\n  peerCandidate(peerId: PeerId): void {\n    invariant(peerId, 'PeerId is required');\n    this.emit('peer-candidate', { peerId, peerMetadata: {} });\n  }\n\n  peerDisconnected(peerId: PeerId): void {\n    invariant(peerId, 'PeerId is required');\n    this.emit('peer-disconnected', { peerId });\n  }\n\n  override send(message: Message): void {\n    log('send', { from: message.senderId, to: message.targetId, type: message.type });\n    this._params.send(message);\n  }\n\n  override disconnect(): void {\n    this.peerId = undefined;\n  }\n\n  receive(message: Message): void {\n    invariant(this.peerId, 'Peer id is not set');\n    this.emit('message', message);\n  }\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { sleep, synchronized } from '@dxos/async';\nimport { type Context, LifecycleState, Resource } from '@dxos/context';\nimport { invariant } from '@dxos/invariant';\nimport { log } from '@dxos/log';\nimport type { AutomergeProtocolMessage } from '@dxos/protocols';\nimport { AutomergeReplicator, type AutomergeReplicatorFactory } from '@dxos/teleport-extension-automerge-replicator';\n\nimport type {\n  EchoReplicator,\n  EchoReplicatorContext,\n  ReplicatorConnection,\n  ShouldAdvertiseParams,\n  ShouldSyncCollectionParams,\n} from '../automerge';\n\nexport type TestReplicatorNetworkOptions = {\n  latency?: number;\n};\n\nexport class TestReplicationNetwork extends Resource {\n  private readonly _replicators = new Set<TestReplicator>();\n  private readonly _latency?: number = undefined;\n\n  constructor(options: TestReplicatorNetworkOptions = {}) {\n    super();\n    this._latency = options.latency;\n  }\n\n  protected override async _close(ctx: Context): Promise<void> {\n    for (const replicator of this._replicators) {\n      for (const connection of replicator.connections) {\n        void connection.writable.abort();\n        void connection.readable.cancel();\n      }\n    }\n  }\n\n  async createReplicator(): Promise<TestReplicator> {\n    const replicator = new TestReplicator({\n      onConnect: async () => {\n        invariant(this._lifecycleState === LifecycleState.OPEN);\n        await this._connectReplicator(replicator);\n      },\n      onDisconnect: async () => {\n        invariant(this._lifecycleState === LifecycleState.OPEN);\n        await this._disconnectReplicator(replicator);\n      },\n    });\n    this._replicators.add(replicator);\n    return replicator;\n  }\n\n  @synchronized\n  private async _connectReplicator(replicator: TestReplicator): Promise<void> {\n    for (const otherReplicator of this._replicators.values()) {\n      if (otherReplicator === replicator || !otherReplicator.connected) {\n        continue;\n      }\n      log('create connection', { from: replicator.context!.peerId, to: otherReplicator.context!.peerId });\n      const [connection1, connection2] = this._createConnectionPair(\n        replicator.context!.peerId,\n        otherReplicator.context!.peerId,\n      );\n      await replicator.context!.onConnectionOpen(connection1);\n      await otherReplicator.context!.onConnectionOpen(connection2);\n    }\n  }\n\n  private async _disconnectReplicator(replicator: TestReplicator): Promise<void> {\n    for (const connection of replicator.connections) {\n      await replicator.context!.onConnectionClosed(connection);\n      await connection.otherSide!.owningReplicator!.removeConnection(connection.otherSide!);\n    }\n  }\n\n  private _createConnectionPair(peer1: string, peer2: string): [TestReplicatorConnection, TestReplicatorConnection] {\n    const LOG = false;\n\n    const forward = new TransformStream({\n      transform: async (message, controller) => {\n        if (LOG) {\n          log('replicate', { from: peer1, to: peer2, message });\n        }\n\n        if (this._latency !== undefined) {\n          await sleep(this._latency);\n        }\n\n        controller.enqueue(message);\n      },\n    });\n    const backwards = new TransformStream({\n      transform: async (message, controller) => {\n        if (LOG) {\n          log('replicate', { from: peer2, to: peer1, message });\n        }\n\n        if (this._latency !== undefined) {\n          await sleep(this._latency);\n        }\n\n        controller.enqueue(message);\n      },\n    });\n\n    const connection1 = new TestReplicatorConnection(peer2, backwards.readable, forward.writable);\n    const connection2 = new TestReplicatorConnection(peer1, forward.readable, backwards.writable);\n    connection1.otherSide = connection2;\n    connection2.otherSide = connection1;\n    return [connection1, connection2];\n  }\n}\n\ntype TestReplicatorParams = {\n  onConnect: () => Promise<void>;\n  onDisconnect: () => Promise<void>;\n};\n\nexport class TestReplicator implements EchoReplicator {\n  constructor(private readonly _params: TestReplicatorParams) {}\n\n  public connected = false;\n  public context: EchoReplicatorContext | undefined = undefined;\n  public connections = new Set<TestReplicatorConnection>();\n\n  async connect(context: EchoReplicatorContext): Promise<void> {\n    log('connect', { peerId: context.peerId });\n    this.context = context;\n    this.connected = true;\n    await this._params.onConnect();\n  }\n\n  async disconnect(): Promise<void> {\n    log('disconnect', { peerId: this.context!.peerId });\n    this.connected = false;\n    await this._params.onDisconnect();\n  }\n\n  async addConnection(connection: TestReplicatorConnection): Promise<void> {\n    connection.owningReplicator = this;\n    this.connections.add(connection);\n    this.context!.onConnectionOpen(connection);\n  }\n\n  async removeConnection(connection: TestReplicatorConnection): Promise<void> {\n    connection.owningReplicator = undefined;\n    this.context!.onConnectionClosed(connection);\n    this.connections.delete(connection);\n  }\n}\n\nexport class TestReplicatorConnection implements ReplicatorConnection {\n  public otherSide: TestReplicatorConnection | undefined = undefined;\n  public owningReplicator: TestReplicator | undefined = undefined;\n\n  constructor(\n    public readonly peerId: string,\n    public readonly readable: ReadableStream<AutomergeProtocolMessage>,\n    public readonly writable: WritableStream<AutomergeProtocolMessage>,\n  ) {}\n\n  async shouldAdvertise(params: ShouldAdvertiseParams): Promise<boolean> {\n    return true;\n  }\n\n  shouldSyncCollection(params: ShouldSyncCollectionParams): boolean {\n    return true;\n  }\n}\n\nexport const testAutomergeReplicatorFactory: AutomergeReplicatorFactory = (params) => {\n  return new AutomergeReplicator(\n    {\n      ...params[0],\n      sendSyncRetryPolicy: {\n        retryBackoff: 20,\n        retriesBeforeBackoff: 2,\n        maxRetries: 3,\n      },\n    },\n    params[1],\n  );\n};\n\nexport const brokenAutomergeReplicatorFactory: AutomergeReplicatorFactory = (params) => {\n  params[1]!.onSyncMessage = () => {\n    throw new Error();\n  };\n  return testAutomergeReplicatorFactory(params);\n};\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { Schema } from 'effect';\n\nimport { Type } from '@dxos/echo';\n\n//\n// Example schema\n//\n\n// TODO(dmaretskyi): Need common set of test types.\nexport const Person = Schema.Struct({\n  name: Schema.String,\n  email: Schema.optional(Schema.String),\n  age: Schema.optional(Schema.Number),\n}).pipe(\n  Type.Obj({\n    typename: 'dxos.org/type/Person',\n    version: '0.1.0',\n  }),\n);\nexport interface Person extends Schema.Schema.Type<typeof Person> {}\n\nexport const Organization = Schema.Struct({\n  name: Schema.String,\n}).pipe(\n  Type.Obj({\n    typename: 'dxos.org/type/Organization',\n    version: '0.1.0',\n  }),\n);\nexport interface Organization extends Schema.Schema.Type<typeof Organization> {}\n\nexport const WorksFor = Schema.Struct({\n  since: Schema.String,\n}).pipe(\n  Type.Relation({\n    typename: 'dxos.org/type/WorksFor',\n    version: '0.1.0',\n    source: Person,\n    target: Organization,\n  }),\n);\nexport interface WorksFor extends Schema.Schema.Type<typeof WorksFor> {}\n\nexport const Task = Schema.Struct({\n  title: Schema.String,\n  createdAt: Schema.String,\n  assignee: Type.Ref(Person),\n}).pipe(Type.Obj({ typename: 'dxos.org/type/Task', version: '0.1.0' }));\nexport interface Task extends Schema.Schema.Type<typeof Task> {}\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { DatabaseDirectory, ObjectStructure } from '@dxos/echo-protocol';\nimport { getSchemaDXN } from '@dxos/echo-schema';\nimport { DXN, ObjectId, PublicKey } from '@dxos/keys';\n\nimport * as TestSchema from './test-schema';\n\nconst spaceKey = PublicKey.random();\n\nexport const PEOPLE = {\n  fred: DatabaseDirectory.make({\n    spaceKey: spaceKey.toHex(),\n    objects: {\n      [ObjectId.random()]: ObjectStructure.makeObject({\n        type: getSchemaDXN(TestSchema.Person)!.toString(),\n        data: {\n          name: 'Fred',\n        },\n      }),\n    },\n  }),\n  alice: DatabaseDirectory.make({\n    spaceKey: spaceKey.toHex(),\n    objects: {\n      [ObjectId.random()]: ObjectStructure.makeObject({\n        type: getSchemaDXN(TestSchema.Person)!.toString(),\n        data: {\n          name: 'Alice',\n        },\n      }),\n    },\n  }),\n};\n\nexport const ORGS = {\n  cyberdyne: DatabaseDirectory.make({\n    spaceKey: spaceKey.toHex(),\n    objects: {\n      [ObjectId.random()]: ObjectStructure.makeObject({\n        type: getSchemaDXN(TestSchema.Organization)!.toString(),\n        data: {\n          name: 'Cyberdyne Systems',\n          founded: '1984',\n        },\n      }),\n    },\n  }),\n  aperture: DatabaseDirectory.make({\n    spaceKey: spaceKey.toHex(),\n    objects: {\n      [ObjectId.random()]: ObjectStructure.makeObject({\n        type: getSchemaDXN(TestSchema.Organization)!.toString(),\n        data: {\n          name: 'Aperture Science',\n          founded: '1953',\n        },\n      }),\n    },\n  }),\n};\n\nexport const WORKS_FOR = {\n  fredWorksForCyberdyne: DatabaseDirectory.make({\n    spaceKey: spaceKey.toHex(),\n    objects: {\n      [ObjectId.random()]: ObjectStructure.makeRelation({\n        type: getSchemaDXN(TestSchema.WorksFor)!.toString(),\n        source: { '/': DXN.fromLocalObjectId(Object.keys(PEOPLE.fred.objects!)[0]).toString() },\n        target: { '/': DXN.fromLocalObjectId(Object.keys(ORGS.cyberdyne.objects!)[0]).toString() },\n        data: {\n          since: '2020',\n          position: 'Engineer',\n        },\n      }),\n    },\n  }),\n  aliceWorksForAperture: DatabaseDirectory.make({\n    spaceKey: spaceKey.toHex(),\n    objects: {\n      [ObjectId.random()]: ObjectStructure.makeRelation({\n        type: getSchemaDXN(TestSchema.WorksFor)!.toString(),\n        source: { '/': DXN.fromLocalObjectId(Object.keys(PEOPLE.alice.objects!)[0]).toString() },\n        target: { '/': DXN.fromLocalObjectId(Object.keys(ORGS.aperture.objects!)[0]).toString() },\n        data: {\n          since: '2018',\n          position: 'Research Scientist',\n        },\n      }),\n    },\n  }),\n};\n\nexport const TASKS = {\n  task1: DatabaseDirectory.make({\n    spaceKey: spaceKey.toHex(),\n    objects: {\n      [ObjectId.random()]: ObjectStructure.makeObject({\n        type: getSchemaDXN(TestSchema.Task)!.toString(),\n        data: {\n          title: 'Complete project documentation',\n          description: 'Write comprehensive documentation for the new system',\n          status: 'in-progress',\n          dueDate: '2023-12-31',\n          assignee: { '/': DXN.fromLocalObjectId(Object.keys(PEOPLE.fred.objects!)[0]).toString() },\n        },\n      }),\n    },\n  }),\n  task2: DatabaseDirectory.make({\n    spaceKey: spaceKey.toHex(),\n    objects: {\n      [ObjectId.random()]: ObjectStructure.makeObject({\n        type: getSchemaDXN(TestSchema.Task)!.toString(),\n        data: {\n          title: 'Run experiments',\n          description: 'Conduct series of experiments on the portal device',\n          status: 'pending',\n          dueDate: '2023-11-15',\n          assignee: { '/': DXN.fromLocalObjectId(Object.keys(PEOPLE.alice.objects!)[0]).toString() },\n        },\n      }),\n    },\n  }),\n};\n"],
  "mappings": "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",
  "names": ["log", "schema", "EchoMetadata", "schema", "getCodecForType", "changeStorageVersionInMetadata", "storage", "version", "log", "metadata", "MetadataStore", "createDirectory", "load", "echoMetadata", "file", "_directory", "getOrCreateFile", "_writeFile", "flush", "Context", "CredentialGenerator", "PublicKey", "MemorySignalManager", "MemorySignalManagerContext", "WebsocketSignalManager", "MemoryTransportFactory", "SwarmNetworkManager", "createRtcTransportFactory", "AdmittedFeed", "StorageType", "createStorage", "Gossip", "Presence", "BlobStore", "ComplexMap", "TestBuilder", "TestFeedBuilder", "TestBuilder", "valueEncoding", "MemoryNetworkManagerProvider", "signalContext", "SwarmNetworkManager", "signalManager", "MemorySignalManager", "transportFactory", "MemoryTransportFactory", "WebsocketNetworkManagerProvider", "signalUrl", "WebsocketSignalManager", "server", "createRtcTransportFactory", "TestAgentBuilder", "storage", "networkManagerProvider", "_agents", "ComplexMap", "PublicKey", "hash", "_storage", "createStorage", "type", "StorageType", "RAM", "_networkManagerProvider", "MemorySignalManagerContext", "close", "Promise", "all", "agents", "map", "agent", "Array", "from", "values", "getAgent", "deviceKey", "get", "createPeer", "feedBuilder", "TestFeedBuilder", "setStorage", "size", "identityKey", "keyring", "createKey", "TestAgent", "set", "metadataStore", "_metadataStore", "MetadataStore", "createDirectory", "blobStore", "_blobStore", "BlobStore", "_feedBuilder", "_spaces", "feedStore", "createFeedStore", "spaces", "space", "getSpace", "spaceKey", "networkManager", "_networkManager", "setPeerInfo", "peerKey", "toHex", "spaceManager", "_spaceManager", "SpaceManager", "createSpace", "genesisKey", "dataKey", "saveMetadata", "controlFeed", "openFeed", "writable", "dataFeed", "sparse", "metadata", "key", "genesisFeedKey", "controlFeedKey", "dataFeedKey", "addSpace", "open", "constructSpace", "swarmIdentity", "credentialProvider", "MOCK_AUTH_PROVIDER", "credentialAuthenticator", "MOCK_AUTH_VERIFIER", "memberKey", "onAuthorizedConnection", "session", "addExtension", "createGossip", "createExtension", "remotePeerId", "onDelegatedInvitationStatusChange", "onMemberRolesChanged", "setControlFeed", "setDataFeed", "Context", "createSpaceProtocol", "topic", "gossip", "SpaceProtocol", "onSessionAuth", "Gossip", "localPeerId", "createPresence", "Presence", "announceInterval", "offlineTimeout", "spaceGenesis", "generator", "CredentialGenerator", "credentials", "createSpaceGenesis", "createFeedAdmission", "AdmittedFeed", "Designation", "DATA", "createEpochCredential", "credential", "controlPipeline", "writer", "write", "NetworkAdapter", "Trigger", "sleep", "invariant", "log", "TestAdapter", "createPair", "connectionStateProvider", "adapter1", "send", "message", "then", "adapter2", "receive", "_params", "onConnect", "isReady", "whenReady", "Promise", "resolve", "connect", "peerId", "wake", "peerCandidate", "emit", "peerMetadata", "peerDisconnected", "from", "senderId", "to", "targetId", "type", "disconnect", "undefined", "sleep", "synchronized", "LifecycleState", "Resource", "invariant", "log", "AutomergeReplicator", "TestReplicationNetwork", "options", "_replicators", "Set", "_latency", "undefined", "latency", "_close", "ctx", "replicator", "connection", "connections", "writable", "abort", "readable", "cancel", "createReplicator", "TestReplicator", "onConnect", "_lifecycleState", "OPEN", "_connectReplicator", "onDisconnect", "_disconnectReplicator", "add", "otherReplicator", "values", "connected", "from", "context", "peerId", "to", "connection1", "connection2", "_createConnectionPair", "onConnectionOpen", "onConnectionClosed", "otherSide", "owningReplicator", "removeConnection", "peer1", "peer2", "LOG", "forward", "TransformStream", "transform", "message", "controller", "enqueue", "backwards", "TestReplicatorConnection", "_params", "connect", "disconnect", "addConnection", "delete", "shouldAdvertise", "params", "shouldSyncCollection", "testAutomergeReplicatorFactory", "sendSyncRetryPolicy", "retryBackoff", "retriesBeforeBackoff", "maxRetries", "brokenAutomergeReplicatorFactory", "onSyncMessage", "Error", "Schema", "Type", "Person", "Schema", "Struct", "name", "String", "email", "optional", "age", "Number", "pipe", "Type", "Obj", "typename", "version", "Organization", "WorksFor", "since", "Relation", "source", "target", "Task", "title", "createdAt", "assignee", "Ref", "DatabaseDirectory", "ObjectStructure", "getSchemaDXN", "DXN", "ObjectId", "PublicKey", "spaceKey", "PublicKey", "random", "PEOPLE", "fred", "DatabaseDirectory", "make", "toHex", "objects", "ObjectId", "ObjectStructure", "makeObject", "type", "getSchemaDXN", "Person", "toString", "data", "name", "alice", "ORGS", "cyberdyne", "Organization", "founded", "aperture", "WORKS_FOR", "fredWorksForCyberdyne", "makeRelation", "WorksFor", "source", "DXN", "fromLocalObjectId", "Object", "keys", "target", "since", "position", "aliceWorksForAperture", "TASKS", "task1", "Task", "title", "description", "status", "dueDate", "assignee", "task2"]
}
