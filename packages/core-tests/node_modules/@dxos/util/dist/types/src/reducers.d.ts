export type Accessor<T, V> = string | ((value: T) => V);
export declare const accessBy: <T, V>(value: T, accessor: Accessor<T, V>) => any;
export declare const median: (values: number[]) => number;
export type NumericalValues = {
    min?: number;
    max?: number;
    mean?: number;
    median?: number;
    total: number;
    count: number;
};
/**
 * Returns an array of unique values.
 */
export declare const numericalValues: <T>(values: T[], accessor: Accessor<T, number>) => NumericalValues;
/**
 * Returns an array of unique values.
 */
export declare const reduceSet: <T, V>(values: T[], accessor: Accessor<T, V>) => Set<V>;
/**
 * Returns an object containing values grouped by the given key accessor.
 */
export declare const reduceGroupBy: <T, K>(values: T[], accessor: Accessor<T, K>) => Map<K, T[]>;
/**
 * Generic composable reducer interface.
 */
export interface Reducer<T, S> {
    /**
     * Get initial state.
     */
    initialState(): S;
    /**
     * Apply event to state.
     */
    reduce(state: S, event: T): S;
}
/**
 * Applies the reducer to the array of values.
 */
export declare const reduceSeries: <T, S>(reducer: Reducer<T, S>, events: T[]) => S;
/**
 * Reducer to group values.
 */
export declare const createGroupReducer: <T, S>(groupBy: (value: T) => string, sub: Reducer<T, S>) => Reducer<T, Record<string, S>>;
export type TimeRecord = {
    timestamp: Date | number | string;
};
export type TimeBucket = {
    start: number;
    period: number;
    count: number;
};
export declare const getDate: (value: Date | number | string) => Date;
/**
 * Reducer to group by time period.
 */
export declare const createBucketReducer: <T extends TimeRecord>(period: number) => Reducer<T, TimeBucket[]>;
//# sourceMappingURL=reducers.d.ts.map