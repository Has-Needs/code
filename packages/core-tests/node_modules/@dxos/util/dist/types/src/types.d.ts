export type AsyncCallback<T> = (param: T) => Promise<void>;
export type Provider<T, V = void> = (arg: V) => T;
export type MaybeProvider<T, V = void> = T | ((arg: V) => T);
export type MaybePromise<T> = T | Promise<T>;
export type GuardedType<T> = T extends (value: any) => value is infer R ? R : never;
export type DeepReadonly<T> = {
    readonly [P in keyof T]: T[P] extends Record<string, any> ? DeepReadonly<T[P]> : T[P] extends Array<infer U> ? ReadonlyArray<DeepReadonly<U>> : T[P];
};
export type DeepWriteable<T> = {
    -readonly [K in keyof T]: T[K] extends object ? DeepWriteable<T[K]> : T[K];
};
/**
 * Simplifies type (copied from effect).
 */
export type Simplify<A> = {
    [K in keyof A]: A[K];
} extends infer B ? B : never;
/**
 * Replace types of specified keys.
 */
export type Specialize<T, U> = Simplify<Omit<T, keyof U> & U>;
/**
 * Make specified keys optional.
 */
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;
/**
 * All types that evaluate to false when cast to a boolean.
 */
export type Falsy = false | 0 | '' | null | undefined;
/**
 * Use with filter chaining instead of filter(Boolean) to preserve type.
 * NOTE: To filter by type:
 * items.filter((item: any): item is RangeSet<Decoration> => item instanceof RangeSet)
 */
export declare const isNotFalsy: <T>(value: T) => value is Exclude<T, Falsy>;
export declare const isNonNullable: <T>(value: T | null | undefined) => value is T;
export declare const doAsync: (fn: () => Promise<void>) => Promise<void>;
/**
 * Get value from a provider.
 */
export declare const getProviderValue: <T, V = void>(provider: MaybeProvider<T, V>, arg?: V) => T;
/**
 * Get value from a provider, which may be async.
 */
export declare const getAsyncProviderValue: <T, V = void>(provider: MaybeProvider<MaybePromise<T>, V>, arg?: V) => MaybePromise<T>;
/**
 * Remove keys with undefined values.
 */
export declare const stripUndefined: <T extends {
    [index: string]: any;
}>(obj: T) => T;
/**
 * Return new object with sorted keys.
 */
export declare const sortKeys: <T extends object>(obj: T) => T;
/**
 * Swap position of element within array.
 */
export declare const arrayMove: <T>(array: T[], from: number, to: number) => Array<T>;
//# sourceMappingURL=types.d.ts.map