import "@dxos/node-std/globals";

// packages/common/util/src/array-to-hex.ts
var byteToHex = [];
for (let n = 0; n <= 255; ++n) {
  const hexOctet = n.toString(16).padStart(2, "0");
  byteToHex.push(hexOctet);
}
var arrayToHex = (buf) => {
  const buff = new Uint8Array(buf);
  const hexOctets = [];
  for (let i = 0; i < buff.length; ++i) {
    hexOctets.push(byteToHex[buff[i]]);
  }
  return hexOctets.join("");
};

// packages/common/util/src/array.ts
var diff = (previous, next, comparator) => {
  const remaining = [
    ...previous
  ];
  const result = {
    added: [],
    updated: [],
    removed: remaining
  };
  for (const object of next) {
    const index = remaining.findIndex((item) => comparator(item, object));
    if (index === -1) {
      result.added.push(object);
    } else {
      result.updated.push(object);
      remaining.splice(index, 1);
    }
  }
  return result;
};
var intersection = (a, b, comparator) => a.filter((a2) => b.find((b2) => comparator(a2, b2)) !== void 0);
var distinctBy = (array, selector) => {
  const seenKeys = /* @__PURE__ */ new Set();
  return array.filter((item) => {
    const key = selector(item);
    if (seenKeys.has(key)) {
      return false;
    }
    seenKeys.add(key);
    return true;
  });
};
var removeBy = (array, test) => {
  const removed = [];
  for (let i = array.length - 1; i >= 0; i--) {
    if (test(array[i], i)) {
      removed.push(...array.splice(i, 1));
    }
  }
  return removed;
};
var partition = (array, guard) => {
  return array.reduce(([accepted, rejected], item, index, array2) => guard(item, index, array2) ? [
    [
      ...accepted,
      item
    ],
    rejected
  ] : [
    accepted,
    [
      ...rejected,
      item
    ]
  ], [
    [],
    []
  ]);
};
var intersectBy = (arrays, selector) => {
  if (arrays.length === 0) {
    return [];
  }
  if (arrays.length === 1) {
    return [
      ...arrays[0]
    ];
  }
  const [first, ...rest] = arrays;
  const lookups = rest.map((array) => {
    const map = /* @__PURE__ */ new Map();
    for (const item of array) {
      map.set(selector(item), item);
    }
    return map;
  });
  return first.filter((item) => {
    const key = selector(item);
    return lookups.every((lookup) => lookup.has(key));
  });
};

// packages/common/util/src/binder.ts
import util from "@dxos/node-std/util";
var createBinder = (obj) => ({
  fn: (fn) => fn.bind(obj),
  async: (fn) => util.promisify(fn.bind(obj))
});

// packages/common/util/src/bitfield.ts
import { invariant } from "@dxos/invariant";
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/common/util/src/bitfield.ts";
var BitField = class _BitField {
  static get(data, idx) {
    const bit = data[idx >> 3] >> 7 - idx % 8 & 1;
    return !!bit;
  }
  static set(data, idx, value) {
    if (value) {
      data[idx >> 3] = data[idx >> 3] | 1 << 7 - idx % 8;
    } else {
      data[idx >> 3] = data[idx >> 3] & ~(1 << 7 - idx % 8);
    }
  }
  /**
  * [start; end)
  */
  static count(data, begin, end) {
    let count = 0;
    for (let i = begin; i < end; i++) {
      const bit = data[i >> 3] >> 7 - i % 8 & 1;
      count += bit;
    }
    return count;
  }
  static invert(data) {
    const result = new Uint8Array(data.length);
    for (let i = 0; i < data.length; i++) {
      result[i] = ~data[i];
    }
    return result;
  }
  static and(first, second) {
    invariant(first.length === second.length, "Bitfields must be of the same length", {
      F: __dxlog_file,
      L: 52,
      S: this,
      A: [
        "first.length === second.length",
        "'Bitfields must be of the same length'"
      ]
    });
    const result = new Uint8Array(first.length);
    for (let i = 0; i < first.length; i++) {
      result[i] = first[i] & second[i];
    }
    return result;
  }
  static findIndexes(data, opts = {}) {
    const { start = 0, end = data.length * 8, value = true } = opts;
    const result = [];
    for (let i = start; i < end; i++) {
      if (_BitField.get(data, i) === value) {
        result.push(i);
      }
    }
    return result;
  }
  static ones(count) {
    const res = new Uint8Array(Math.ceil(Math.ceil(count) / 8)).fill(255);
    const bitInLastByte = Math.ceil(count % 8);
    res[res.length - 1] = 255 << 8 - bitInLastByte;
    return res;
  }
  static zeros(count) {
    return new Uint8Array(Math.ceil(Math.ceil(count) / 8)).fill(0);
  }
};

// packages/common/util/src/callback-collection.ts
var CallbackCollection = class {
  #callbacks = [];
  append(callback) {
    this.#callbacks.push(callback);
  }
  prepend(callback) {
    this.#callbacks.unshift(callback);
  }
  remove(callback) {
    this.#callbacks = this.#callbacks.filter((c) => c !== callback);
  }
  callParallel(...args) {
    return Promise.all(this.#callbacks.map((callback) => callback(...args)));
  }
  async callSerial(...args) {
    const results = [];
    for (const callback of this.#callbacks) {
      results.push(await callback(...args));
    }
    return results;
  }
};

// packages/common/util/src/callback.ts
import { invariant as invariant2 } from "@dxos/invariant";
var __dxlog_file2 = "/home/runner/work/dxos/dxos/packages/common/util/src/callback.ts";
var Callback = class {
  call(...args) {
    invariant2(this._callback, "Callback not set", {
      F: __dxlog_file2,
      L: 20,
      S: this,
      A: [
        "this._callback",
        "'Callback not set'"
      ]
    });
    return this._callback(...args);
  }
  callIfSet(...args) {
    return this._callback?.(...args);
  }
  set(callback) {
    invariant2(!this._callback, "Callback already set", {
      F: __dxlog_file2,
      L: 29,
      S: this,
      A: [
        "!this._callback",
        "'Callback already set'"
      ]
    });
    this._callback = callback;
  }
  isSet() {
    return !!this._callback;
  }
};
var createSetDispatch = ({ handlers }) => {
  return new Proxy({
    handlers
  }, {
    get: (target, prop) => {
      return (...args) => {
        handlers.forEach((handler) => {
          const method = handler[prop];
          if (method) {
            method.apply(handler, args);
          }
        });
      };
    }
  });
};

// packages/common/util/src/case.ts
var LOW_DASH = "_".codePointAt(0);
var HI_DASH = "-".codePointAt(0);
var SMALL_A = "a".codePointAt(0);
var CAPITAL_A = "A".codePointAt(0);
var SMALL_Z = "z".codePointAt(0);
var CAPITAL_Z = "Z".codePointAt(0);
var isLower = (char) => char >= SMALL_A && char <= SMALL_Z;
var isUpper = (char) => char >= CAPITAL_A && char <= CAPITAL_Z;
var toLower = (char) => char + 32;
var changeCase = (str, delim) => {
  const firstChar = str.charCodeAt(0);
  if (!isLower(firstChar)) {
    return str;
  }
  const length = str.length;
  let changed = false;
  const out = [];
  for (let i = 0; i < length; ++i) {
    const c = str.charCodeAt(i);
    if (isUpper(c)) {
      out.push(delim);
      out.push(toLower(c));
      changed = true;
    } else {
      out.push(c);
    }
  }
  return changed ? String.fromCharCode.apply(void 0, out) : str;
};
var decamelize = (str) => changeCase(str, LOW_DASH);
var hyphenize = (str) => changeCase(str, HI_DASH);

// packages/common/util/src/chunk-array.ts
var chunkArray = (array, size) => {
  const result = [];
  for (let i = 0; i < array.length; i += size) {
    result.push(array.slice(i, i + size));
  }
  return result;
};

// packages/common/util/src/circular-buffer.ts
import { invariant as invariant3 } from "@dxos/invariant";
var __dxlog_file3 = "/home/runner/work/dxos/dxos/packages/common/util/src/circular-buffer.ts";
var CircularBuffer = class {
  constructor(size) {
    this._nextIndex = 0;
    this._elementCount = 0;
    invariant3(size >= 1, void 0, {
      F: __dxlog_file3,
      L: 13,
      S: this,
      A: [
        "size >= 1",
        ""
      ]
    });
    this._buffer = new Array(size);
  }
  push(element) {
    const evicted = this._elementCount === this._buffer.length ? this._buffer[this._nextIndex] : void 0;
    this._buffer[this._nextIndex] = element;
    this._nextIndex = (this._nextIndex + 1) % this._buffer.length;
    this._elementCount = Math.min(this._buffer.length, this._elementCount + 1);
    return evicted;
  }
  get elementCount() {
    return this._elementCount;
  }
  getLast() {
    if (this._elementCount === 0) {
      return void 0;
    }
    if (this._nextIndex === 0) {
      return this._buffer[this._buffer.length - 1];
    }
    return this._buffer[this._nextIndex - 1];
  }
  [Symbol.iterator]() {
    return this.values();
  }
  *values() {
    if (this._elementCount === 0) {
      return;
    }
    if (this._elementCount < this._buffer.length) {
      for (let i = 0; i < this._elementCount; i++) {
        yield this._buffer[i];
      }
      return;
    }
    for (let i = this._nextIndex; i < this._buffer.length; i++) {
      yield this._buffer[i];
    }
    for (let i = 0; i < this._nextIndex; i++) {
      yield this._buffer[i];
    }
  }
};

// packages/common/util/src/clear-undefined.ts
var clearUndefined = (obj) => {
  for (const key of [
    ...Object.getOwnPropertyNames(obj),
    ...Object.getOwnPropertySymbols(obj)
  ]) {
    if (obj[key] === void 0) {
      delete obj[key];
    }
  }
  return obj;
};

// packages/common/util/src/complex.ts
import { inspect } from "@dxos/node-std/util";
import { inspectObject, raise } from "@dxos/debug";
var MAX_SERIALIZATION_LENGTH = 10;
var ComplexSet = class {
  // prettier-ignore
  constructor(_projection, values) {
    this._projection = _projection;
    this._values = /* @__PURE__ */ new Map();
    if (values) {
      for (const value of values) {
        this.add(value);
      }
    }
  }
  toString() {
    return inspectObject(this);
  }
  toJSON() {
    return this._values.size > MAX_SERIALIZATION_LENGTH ? {
      size: this._values.size
    } : Array.from(this._values.values());
  }
  [inspect.custom]() {
    return inspectObject(this);
  }
  add(value) {
    this._values.set(this._projection(value), value);
    return this;
  }
  clear() {
    this._values.clear();
  }
  delete(value) {
    return this._values.delete(this._projection(value));
  }
  forEach(callbackfn, thisArg) {
    if (thisArg) {
      callbackfn = callbackfn.bind(thisArg);
    }
    this._values.forEach((value) => callbackfn(value, value, this));
  }
  has(value) {
    return this._values.has(this._projection(value));
  }
  get size() {
    return this._values.size;
  }
  [Symbol.iterator]() {
    return this._values.values();
  }
  *entries() {
    for (const value of this._values.values()) {
      yield [
        value,
        value
      ];
    }
  }
  keys() {
    return this[Symbol.iterator]();
  }
  values() {
    return this[Symbol.iterator]();
  }
  get [Symbol.toStringTag]() {
    return "ComplexSet";
  }
  union(other) {
    throw new Error("Method not implemented.");
  }
  intersection(other) {
    throw new Error("Method not implemented.");
  }
  difference(other) {
    throw new Error("Method not implemented.");
  }
  symmetricDifference(other) {
    throw new Error("Method not implemented.");
  }
  isSubsetOf(other) {
    throw new Error("Method not implemented.");
  }
  isSupersetOf(other) {
    throw new Error("Method not implemented.");
  }
  isDisjointFrom(other) {
    throw new Error("Method not implemented.");
  }
};
var makeSet = (projection) => {
  return class BoundComplexSet extends ComplexSet {
    constructor(values) {
      super(projection, values);
    }
  };
};
var ComplexMap = class _ComplexMap {
  // prettier-ignore
  constructor(_keyProjection, entries2) {
    this._keyProjection = _keyProjection;
    this._keys = /* @__PURE__ */ new Map();
    this._values = /* @__PURE__ */ new Map();
    if (entries2) {
      for (const [key, value] of entries2) {
        this.set(key, value);
      }
    }
  }
  toString() {
    return inspectObject(this);
  }
  toJSON() {
    return this._values.size > MAX_SERIALIZATION_LENGTH ? {
      size: this._values.size
    } : Array.from(this._values.values());
  }
  [inspect.custom]() {
    return inspectObject(this);
  }
  clear() {
    this._keys.clear();
    this._values.clear();
  }
  delete(key) {
    const keyDeleted = this._keys.delete(this._keyProjection(key));
    const valueDeleted = this._values.delete(this._keyProjection(key));
    return keyDeleted || valueDeleted;
  }
  forEach(callbackfn, thisArg) {
    if (thisArg) {
      callbackfn = callbackfn.bind(thisArg);
    }
    this._keys.forEach((key, primitive) => callbackfn(this._values.get(primitive) ?? raise(new Error("Map corrupted.")), key, this));
  }
  get(key) {
    return this._values.get(this._keyProjection(key));
  }
  has(key) {
    return this._keys.has(this._keyProjection(key));
  }
  set(key, value) {
    const primitive = this._keyProjection(key);
    this._keys.set(primitive, key);
    this._values.set(primitive, value);
    return this;
  }
  get size() {
    return this._keys.size;
  }
  *[Symbol.iterator]() {
    for (const [primitive, key] of this._keys) {
      const value = this._values.get(primitive) ?? raise(new Error("Map corrupted."));
      yield [
        key,
        value
      ];
    }
  }
  entries() {
    return this[Symbol.iterator]();
  }
  keys() {
    return this._keys.values();
  }
  values() {
    return this._values.values();
  }
  mapValues(mapper) {
    return new _ComplexMap(this._keyProjection, [
      ...this.entries()
    ].map(([key, value]) => [
      key,
      mapper(value, key)
    ]));
  }
  get [Symbol.toStringTag]() {
    return "ComplexMap";
  }
};
var makeMap = (keyProjection) => class BoundComplexMap extends ComplexMap {
  constructor(entries2) {
    super(keyProjection, entries2);
  }
};

// packages/common/util/src/deep.ts
import get from "lodash.get";
import set from "lodash.set";
import { invariant as invariant4 } from "@dxos/invariant";
var __dxlog_file4 = "/home/runner/work/dxos/dxos/packages/common/util/src/deep.ts";
var setDeep = (obj, path, value) => {
  invariant4(path.length > 0, void 0, {
    F: __dxlog_file4,
    L: 18,
    S: void 0,
    A: [
      "path.length > 0",
      ""
    ]
  });
  let parent = obj;
  for (const key of path.slice(0, -1)) {
    if (parent[key] === void 0) {
      const isArrayIndex = !isNaN(Number(key));
      parent[key] = isArrayIndex ? [] : {};
    }
    parent = parent[key];
  }
  parent[path.at(-1)] = value;
  return obj;
};
var getDeep = (obj, path) => {
  let parent = obj;
  for (const key of path) {
    parent = parent?.[key];
  }
  return parent;
};

// packages/common/util/src/defer-function.ts
var deferFunction = (fnProvider) => (...args) => fnProvider()(...args);

// packages/common/util/src/explicit-resource-management-polyfill.ts
Symbol.dispose ??= Symbol("Symbol.dispose");
Symbol.asyncDispose ??= Symbol("Symbol.asyncDispose");

// packages/common/util/src/defer.ts
var defer = (fn) => new DeferGuard(fn);
var DeferGuard = class {
  /**
  * @internal
  */
  constructor(_fn) {
    this._fn = _fn;
  }
  [Symbol.dispose]() {
    const result = this._fn();
    if (result instanceof Promise) {
      throw new Error("Async functions in defer are not supported. Use deferAsync instead.");
    }
  }
};
var deferAsync = (fn) => new DeferAsyncGuard(fn);
var DeferAsyncGuard = class {
  /**
  * @internal
  */
  constructor(_fn) {
    this._fn = _fn;
  }
  async [Symbol.asyncDispose]() {
    await this._fn();
  }
};

// packages/common/util/src/entry.ts
var entry = (map, key) => new MapEntry(map, key);
var MapEntry = class {
  /**
  * @internal
  */
  // prettier-ignore
  constructor(_map, _key) {
    this._map = _map;
    this._key = _key;
  }
  get key() {
    return this._key;
  }
  get value() {
    return this._map.get(this._key);
  }
  orInsert(value) {
    if (!this._map.has(this._key)) {
      this._map.set(this._key, value);
    }
    return this;
  }
  deep(key) {
    return entry(this.value, key);
  }
};

// packages/common/util/src/first-two-chars.ts
var renderableCharRegex = /^(?![\p{Control}\p{Mark}\p{Separator}\p{Surrogate}\p{Unassigned}\p{P}])[\p{L}\p{N}\p{S}\p{Emoji}]$/u;
var getFirstTwoRenderableChars = (label) => {
  const characters = Array.from(label);
  const result = [
    "",
    ""
  ];
  let foundFirst = false;
  for (let i = 0; i < characters.length; i++) {
    const char = characters[i];
    if (renderableCharRegex.test(char)) {
      if (!foundFirst) {
        result[0] = char;
        foundFirst = true;
      } else {
        const textBetween = characters.slice(result[0].length, i).join("");
        if (/[^\p{L}\p{N}_]/u.test(textBetween)) {
          result[1] = char;
          break;
        }
      }
    }
  }
  return result;
};

// packages/common/util/src/for-each-async.ts
var forEachAsync = (items, fn) => Promise.all(items.map(fn));

// packages/common/util/src/human-hash.ts
import { PublicKey } from "@dxos/keys";
var DEFAULT_WORDLIST = [
  "ack",
  "alabama",
  "alanine",
  "alaska",
  "alpha",
  "angel",
  "apart",
  "april",
  "arizona",
  "arkansas",
  "artist",
  "asparagus",
  "aspen",
  "august",
  "autumn",
  "avocado",
  "bacon",
  "bakerloo",
  "batman",
  "beer",
  "berlin",
  "beryllium",
  "black",
  "blossom",
  "blue",
  "bluebird",
  "bravo",
  "bulldog",
  "burger",
  "butter",
  "california",
  "carbon",
  "cardinal",
  "carolina",
  "carpet",
  "cat",
  "ceiling",
  "charlie",
  "chicken",
  "coffee",
  "cola",
  "cold",
  "colorado",
  "comet",
  "connecticut",
  "crazy",
  "cup",
  "dakota",
  "december",
  "delaware",
  "delta",
  "diet",
  "don",
  "double",
  "early",
  "earth",
  "east",
  "echo",
  "edward",
  "eight",
  "eighteen",
  "eleven",
  "emma",
  "enemy",
  "equal",
  "failed",
  "fanta",
  "fifteen",
  "fillet",
  "finch",
  "fish",
  "five",
  "fix",
  "floor",
  "florida",
  "football",
  "four",
  "fourteen",
  "foxtrot",
  "freddie",
  "friend",
  "fruit",
  "gee",
  "georgia",
  "glucose",
  "golf",
  "green",
  "grey",
  "hamper",
  "happy",
  "harry",
  "hawaii",
  "helium",
  "high",
  "hot",
  "hotel",
  "hydrogen",
  "idaho",
  "illinois",
  "india",
  "indigo",
  "ink",
  "iowa",
  "island",
  "item",
  "jersey",
  "jig",
  "johnny",
  "juliet",
  "july",
  "jupiter",
  "kansas",
  "kentucky",
  "kilo",
  "king",
  "kitten",
  "lactose",
  "lake",
  "lamp",
  "lemon",
  "leopard",
  "lima",
  "lion",
  "lithium",
  "london",
  "louisiana",
  "low",
  "magazine",
  "magnesium",
  "maine",
  "mango",
  "march",
  "mars",
  "maryland",
  "massachusetts",
  "may",
  "mexico",
  "michigan",
  "mike",
  "minnesota",
  "mirror",
  "mississippi",
  "missouri",
  "mobile",
  "mockingbird",
  "monkey",
  "montana",
  "moon",
  "mountain",
  "muppet",
  "music",
  "nebraska",
  "neptune",
  "network",
  "nevada",
  "nine",
  "nineteen",
  "nitrogen",
  "north",
  "november",
  "nuts",
  "october",
  "ohio",
  "oklahoma",
  "one",
  "orange",
  "oranges",
  "oregon",
  "oscar",
  "oven",
  "oxygen",
  "papa",
  "paris",
  "pasta",
  "pennsylvania",
  "pip",
  "pizza",
  "pluto",
  "potato",
  "princess",
  "purple",
  "quebec",
  "queen",
  "quiet",
  "red",
  "river",
  "robert",
  "robin",
  "romeo",
  "rugby",
  "sad",
  "salami",
  "saturn",
  "september",
  "seven",
  "seventeen",
  "shade",
  "sierra",
  "single",
  "sink",
  "six",
  "sixteen",
  "skylark",
  "snake",
  "social",
  "sodium",
  "solar",
  "south",
  "spaghetti",
  "speaker",
  "spring",
  "stairway",
  "steak",
  "stream",
  "summer",
  "sweet",
  "table",
  "tango",
  "ten",
  "tennessee",
  "tennis",
  "texas",
  "thirteen",
  "three",
  "timing",
  "triple",
  "twelve",
  "twenty",
  "two",
  "uncle",
  "undress",
  "uniform",
  "uranus",
  "utah",
  "vegan",
  "venus",
  "vermont",
  "victor",
  "video",
  "violet",
  "virginia",
  "washington",
  "west",
  "whiskey",
  "white",
  "william",
  "winner",
  "winter",
  "wisconsin",
  "wolfram",
  "wyoming",
  "xray",
  "yankee",
  "yellow",
  "zebra",
  "zulu"
];
var HumanHasher = class {
  /**
  * Transforms hex digests to human-readable strings.
  *
  * The format of these strings will look something like:
  * `victor-bacon-zulu-lima`. The output is obtained by compressing the input
  * digest to a fixed number of bytes, then mapping those bytes to one of 256
  * words. A default wordlist is provided, but you can override this if you
  * prefer.
  * As long as you use the same wordlist, the output will be consistent (i.e.
  * the same digest will always render the same representation).
  *
  * @param wordlist A list of exactly 256 words to choose from
  */
  constructor(wordlist = DEFAULT_WORDLIST) {
    this.wordlist = wordlist;
    if (wordlist.length !== 256) {
      throw new Error("Wordlist must have exactly 256 items");
    }
    this.wordlist = wordlist;
  }
  /**
  * Humanize a given hexadecimal digest.
  *
  * Change the number of words output by specifying `words`. Change the
  * word separator with `separator`.
  *
  * @param hexdigest A string of hexadecimal characters to humanize
  * @param words How many words to output (more = safer)
  * @param separator The string used to seperate the words
  */
  humanize(hexdigest, words = 4, separator = "-") {
    const pairs = hexdigest.match(/(..?)/g);
    if (!pairs) {
      throw new Error("");
    }
    const bytes = pairs.map((x) => parseInt(x, 16));
    const compressed = this._compress(bytes, words);
    return compressed.map((x) => this.wordlist[x]).join(separator);
  }
  /**
  * Compress a list of byte values to a fixed target length.
  *
  * @param bytes A list of bytes (numbers from 0-254)
  * @param target The number of bytes to return / compress to
  */
  _compress(bytes, target) {
    const length = bytes.length;
    if (target > length) {
      throw new Error("Fewer input bytes than requested output");
    }
    const segSize = length / target >> 0;
    const segments = [];
    for (let i = 0; i < segSize * target; i += segSize) {
      segments.push(bytes.slice(i, i + segSize));
    }
    segments[segments.length - 1] = segments[segments.length - 1].concat(bytes.slice(target * segSize));
    const checksums = segments.map((x) => x.reduce((acc, curr) => acc ^ curr));
    return checksums;
  }
};
var hasher = new HumanHasher();
var humanize = (value) => {
  if (value instanceof Buffer || value instanceof Uint8Array || value instanceof ArrayBuffer) {
    value = PublicKey.stringify(value);
  } else if (value instanceof PublicKey) {
    value = value.toHex();
  }
  return hasher.humanize(value);
};

// packages/common/util/src/map.ts
var defaultMap = (map, key, def) => {
  let value = map.get(key);
  if (value === void 0) {
    value = typeof def === "function" ? def() : def;
    map.set(key, value);
  }
  return value;
};

// packages/common/util/src/instance-id.ts
var symbol = Symbol.for("dxos.instance-contexts");
var instanceContexts = globalThis[symbol] ??= /* @__PURE__ */ new WeakMap();
var getPrototypeSpecificInstanceId = (instance) => {
  const prototype = Object.getPrototypeOf(instance);
  const instanceCtx = defaultMap(instanceContexts, prototype, () => ({
    nextId: 0,
    instanceIds: /* @__PURE__ */ new WeakMap()
  }));
  let id = instanceCtx.instanceIds.get(instance);
  if (id === void 0) {
    id = instanceCtx.nextId++;
    instanceCtx.instanceIds.set(instance, id);
  }
  return id;
};
var getDebugName = (instance) => {
  if (instance == null) {
    return "null";
  }
  const prototype = Object.getPrototypeOf(instance);
  return `${prototype.constructor?.name ?? "Object"}#${getPrototypeSpecificInstanceId(instance)}`;
};

// packages/common/util/src/interval.ts
var exponentialBackoffInterval = (cb, initialInterval) => {
  let interval = initialInterval;
  const repeat = () => {
    cb();
    interval *= 2;
    timeoutId = setTimeout(repeat, interval);
  };
  let timeoutId = setTimeout(repeat, interval);
  return () => clearTimeout(timeoutId);
};

// packages/common/util/src/join-tables.ts
var joinTables = (leftColumn, rightColumn, left, right) => {
  const map = /* @__PURE__ */ new Map();
  const used = /* @__PURE__ */ new Set();
  for (const row of right) {
    map.set(row[rightColumn], row);
  }
  const result = [];
  for (const row of left) {
    const right2 = map.get(row[leftColumn]);
    used.add(right2);
    result.push(Object.assign(right2 ?? {}, row));
  }
  for (const row of right) {
    if (!used.has(row)) {
      result.push(row);
    }
  }
  return result;
};

// packages/common/util/src/json.ts
import { inspect as inspect2 } from "@dxos/node-std/util";
import { PublicKey as PublicKey2 } from "@dxos/keys";

// packages/common/util/src/uint8array.ts
var arraysEqual = (a, b) => {
  if (a.length !== b.length) {
    return false;
  }
  for (let i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
};
var arrayToBuffer = (array) => {
  return Buffer.from(array.buffer, array.byteOffset, array.byteLength);
};
var bufferToArray = (buffer) => {
  return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
};
var stringToArray = (string) => bufferToArray(Buffer.from(string, "hex"));
var arrayToString = (array) => arrayToBuffer(array).toString("hex");

// packages/common/util/src/json.ts
var MAX_DEPTH = 5;
var LOG_MAX_DEPTH = 7;
function jsonReplacer(key, value) {
  if (value !== null && typeof value === "object" && typeof value[inspect2.custom] === "function") {
    return value[inspect2.custom]();
  }
  if (value !== null && typeof value === "object" && value.type === "Buffer" && Array.isArray(value.data)) {
    if (value.data.length === 32) {
      const key2 = Buffer.from(value.data);
      return `[${humanize(key2)}]:[${PublicKey2.stringify(key2)}]`;
    } else {
      return Buffer.from(value.data).toString("hex");
    }
  }
  return value;
}
var jsonify = (value, depth = 0, visitedObjects = /* @__PURE__ */ new WeakSet()) => {
  if (depth > MAX_DEPTH) {
    return null;
  } else if (typeof value === "function") {
    return null;
  } else if (typeof value === "object" && value !== null) {
    if (visitedObjects.has(value)) {
      return null;
    }
    visitedObjects.add(value);
    try {
      if (value instanceof Uint8Array) {
        return arrayToBuffer(value).toString("hex");
      } else if (Array.isArray(value)) {
        return value.map((x) => jsonify(x, depth + 1, visitedObjects));
      } else if (typeof value.toJSON === "function") {
        return value.toJSON();
      } else {
        const res = {};
        for (const key of Object.keys(value)) {
          res[key] = jsonify(value[key], depth + 1, visitedObjects);
        }
        return res;
      }
    } finally {
      visitedObjects.delete(value);
    }
  } else {
    return value;
  }
};
var jsonlogify = (value, depth = 0, visitedObjects = /* @__PURE__ */ new WeakSet()) => {
  if (depth > LOG_MAX_DEPTH) {
    return null;
  } else if (typeof value === "function") {
    return null;
  } else if (typeof value === "object" && value !== null) {
    if (visitedObjects.has(value)) {
      return null;
    }
    visitedObjects.add(value);
    try {
      if (value instanceof Uint8Array) {
        return arrayToBuffer(value).toString("hex");
      } else if (Array.isArray(value)) {
        return value.map((x) => jsonlogify(x, depth + 1, visitedObjects));
      } else if (typeof value.toJSONL === "function") {
        return value.toJSONL();
      } else if (typeof value.toJSON === "function") {
        return value.toJSON();
      } else {
        const res = {};
        for (const key of Object.keys(value)) {
          res[key] = jsonlogify(value[key], depth + 1, visitedObjects);
        }
        return res;
      }
    } finally {
      visitedObjects.delete(value);
    }
  } else {
    return value;
  }
};
var jsonKeyReplacer = (options = {}) => (key, value) => {
  if (typeof value === "string") {
    const key2 = PublicKey2.fromHex(value);
    if (key2.toHex() === value) {
      return options.humanize ? humanize(key2) : options.truncate ? key2.truncate() : key2.toHex();
    }
  }
  return value;
};

// packages/common/util/src/map-values.ts
var mapValues = (obj, fn) => {
  const result = {};
  Object.keys(obj).forEach((key) => {
    result[key] = fn(obj[key], key);
  });
  return result;
};
var deepMapValues = (value, fn) => {
  return new DeepMapper(fn).map(value);
};
var DeepMapper = class {
  constructor(_fn) {
    this._fn = _fn;
    this._cyclic = /* @__PURE__ */ new Map();
    this._recurse = (value) => {
      if (this._cyclic.has(value)) {
        return this._cyclic.get(value);
      }
      if (Array.isArray(value)) {
        const res = new Array(value.length);
        this._cyclic.set(value, res);
        for (let i = 0; i < value.length; i++) {
          res[i] = this._map(value[i], i);
        }
        return res;
      } else if (value !== null && typeof value === "object") {
        const res = {};
        this._cyclic.set(value, res);
        for (const key in value) {
          res[key] = this._map(value[key], key);
        }
        return res;
      } else {
        return value;
      }
    };
  }
  map(value) {
    return this._map(value, void 0);
  }
  _map(value, key) {
    if (this._cyclic.has(value)) {
      return this._cyclic.get(value);
    }
    return this._fn(value, this._recurse, key);
  }
};
var deepMapValuesAsync = (value, fn) => {
  return new DeepMapperAsync(fn).map(value);
};
var DeepMapperAsync = class {
  constructor(_fn) {
    this._fn = _fn;
    this._cyclic = /* @__PURE__ */ new Map();
    this._recurse = async (value) => {
      if (this._cyclic.has(value)) {
        return this._cyclic.get(value);
      }
      if (Array.isArray(value)) {
        const res = new Array(value.length);
        this._cyclic.set(value, res);
        for (let i = 0; i < value.length; i++) {
          res[i] = await this._map(value[i], i);
        }
        return res;
      } else if (value !== null && typeof value === "object") {
        const res = {};
        this._cyclic.set(value, res);
        for (const key in value) {
          res[key] = await this._map(value[key], key);
        }
        return res;
      } else {
        return value;
      }
    };
  }
  map(value) {
    return this._map(value, void 0);
  }
  _map(value, key) {
    if (this._cyclic.has(value)) {
      return this._cyclic.get(value);
    }
    return this._fn(value, this._recurse, key);
  }
};
var visitValues = (object, visitor) => {
  if (Array.isArray(object)) {
    object.forEach((item, index) => visitor(item, index));
  } else if (typeof object === "object" && object !== null) {
    for (const [key, value] of Object.entries(object)) {
      visitor(value, key);
    }
  }
};

// packages/common/util/src/object.ts
var keys = (obj) => Object.keys(obj);
var entries = (obj) => Object.entries(obj);

// packages/common/util/src/order-keys.ts
var orderKeys = (obj, order) => {
  const ordered = {};
  for (const key of order) {
    if (key in obj) {
      ordered[key] = obj[key];
    }
  }
  for (const key in obj) {
    if (!(key in ordered)) {
      ordered[key] = obj[key];
    }
  }
  return ordered;
};

// packages/common/util/src/order.ts
var inferObjectOrder = (objectMap, order = []) => {
  const orderedObjects = order.reduce((acc, id) => {
    if (id in objectMap) {
      acc.objects.push(objectMap[id]);
      acc.ids.add(id);
    }
    return acc;
  }, {
    objects: [],
    ids: /* @__PURE__ */ new Set()
  });
  const { objects } = Object.keys(objectMap).reduce((acc, id) => {
    if (!acc.ids.has(id)) {
      acc.objects.push(objectMap[id]);
    }
    return acc;
  }, orderedObjects);
  return objects;
};
var inferRecordOrder = (objectMap, order = []) => {
  return Object.assign(order.filter((id) => id in objectMap).reduce((acc, id) => {
    acc[id] = null;
    return acc;
  }, {}), objectMap);
};

// packages/common/util/src/pick.ts
var pick = (obj, keys2) => {
  return keys2.reduce((result, key) => {
    if (obj && key in obj) {
      result[key] = obj[key];
    }
    return result;
  }, {});
};
var pickBy = (obj, predicate) => {
  const result = {};
  for (const key in obj) {
    if (predicate(obj[key])) {
      result[key] = obj[key];
    }
  }
  return result;
};
var omit = (obj, keys2) => {
  const result = {
    ...obj
  };
  keys2.forEach((key) => {
    delete result[key];
  });
  return result;
};

// packages/common/util/src/platform.ts
var isNode = () => typeof process !== "undefined" && process.versions != null && process.versions.node != null;
var mobileAndTabletCheck = () => {
  let check = false;
  ((a) => {
    if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4))) {
      check = true;
    }
  })(navigator.userAgent || navigator.vendor || window.opera);
  return check;
};
var iosCheck = () => {
  return [
    "iPad Simulator",
    "iPhone Simulator",
    "iPod Simulator",
    "iPad",
    "iPhone",
    "iPod"
  ].includes(navigator.platform) || // iPad on iOS 13 detection
  navigator.userAgent.includes("Mac") && "ontouchend" in document;
};
var safariCheck = () => typeof navigator !== "undefined" && /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
var getHostPlatform = () => {
  if (!("navigator" in window)) {
    return "unknown";
  }
  const platform = (navigator.userAgentData?.platform || navigator.platform)?.toLowerCase();
  if (platform.startsWith("win")) {
    return "windows";
  } else if (platform.startsWith("mac")) {
    return "macos";
  } else if (platform.startsWith("ipad") || platform.startsWith("iphone") || platform.startsWith("ipod")) {
    return "ios";
  } else if (platform.startsWith("linux")) {
    return "linux";
  } else {
    return "unknown";
  }
};

// packages/common/util/src/position.ts
var byPosition = ({ position: a = "static" }, { position: b = "static" }) => {
  if (a === b) {
    return 0;
  } else if (a === "hoist" || b === "fallback") {
    return -1;
  } else if (b === "hoist" || a === "fallback") {
    return 1;
  } else {
    return 0;
  }
};

// packages/common/util/src/random.ts
var randomInt = (max, min = 0) => {
  min = Math.ceil(min);
  max = Math.floor(max);
  return Math.floor(Math.random() * (max - min + 1)) + min;
};

// packages/common/util/src/range.ts
var range = (n = 0, mapper) => {
  const range2 = Array.from(Array(n).keys());
  return mapper == null ? range2 : range2.map(mapper);
};
var rangeFromTo = (from, to, mapper) => {
  return mapper == null ? range(to - from, (i) => i + from) : range(to - from, (i) => mapper(i + from));
};
var clamp = (value, min, max) => {
  return Math.min(Math.max(value, min), max);
};

// packages/common/util/src/reducers.ts
var accessBy = (value, accessor) => typeof accessor === "function" ? accessor(value) : value[accessor];
var median = (values) => {
  const mid = Math.floor(values.length / 2);
  if (values.length % 2 === 1) {
    return values[mid];
  } else {
    return (values[mid - 1] + values[mid]) / 2;
  }
};
var numericalValues = (values, accessor) => {
  const result = {
    total: 0,
    count: 0
  };
  const sorted = values.map((value) => {
    const v = accessBy(value, accessor);
    if (v === void 0 || isNaN(v)) {
      return void 0;
    }
    result.total += v;
    if (result.min === void 0 || v < result.min) {
      result.min = v;
    }
    if (result.max === void 0 || v > result.max) {
      result.max = v;
    }
    return v;
  }).filter((value) => value !== void 0).sort((a, b) => a - b);
  if (sorted.length) {
    Object.assign(result, {
      count: sorted.length,
      mean: result.total / sorted.length,
      median: median(sorted)
    });
  }
  return result;
};
var reduceSet = (values, accessor) => {
  return values.reduce((values2, value) => {
    const v = accessBy(value, accessor);
    values2.add(v);
    return values2;
  }, /* @__PURE__ */ new Set());
};
var reduceGroupBy = (values, accessor) => {
  return values.reduce((values2, value) => {
    const key = accessBy(value, accessor);
    defaultMap(values2, key, []).push(value);
    return values2;
  }, /* @__PURE__ */ new Map());
};
var reduceSeries = (reducer, events) => {
  const state = reducer.initialState();
  for (const event of events) {
    reducer.reduce(state, event);
  }
  return state;
};
var createGroupReducer = (groupBy, sub) => ({
  initialState: () => ({}),
  reduce: (state, event) => {
    const key = groupBy(event);
    state[key] = sub.reduce(state[key] ?? sub.initialState(), event);
    return state;
  }
});
var getDate = (value) => value instanceof Date ? value : new Date(value);
var createBucketReducer = (period) => ({
  initialState: () => [],
  reduce: (series, event) => {
    const timestamp = getDate(event.timestamp);
    let bucket = series[series.length - 1];
    if (!bucket || bucket.start + period < timestamp.getTime()) {
      bucket = {
        start: timestamp.getTime(),
        period,
        count: 0
      };
      series.push(bucket);
    }
    bucket.count++;
    return series;
  }
});

// packages/common/util/src/remove-undefined-keys.ts
var removeUndefinedProperties = (object) => {
  for (const prop of [
    ...Object.getOwnPropertyNames(object),
    ...Object.getOwnPropertySymbols(object)
  ]) {
    if (object[prop] === void 0) {
      delete object[prop];
    }
  }
  return object;
};
var removeProperties = (root, condition) => {
  if (!root || typeof root !== "object") {
    return root;
  }
  if (Array.isArray(root)) {
    return root.map((item) => removeProperties(item, condition));
  }
  const result = {
    ...root
  };
  if (typeof condition === "function") {
    for (const [key, value] of Object.entries(result)) {
      if (condition(key, value)) {
        delete result[key];
      }
    }
  } else {
    for (const key of condition) {
      delete result[key];
    }
  }
  for (const [key, value] of Object.entries(result)) {
    if (typeof value === "object") {
      result[key] = removeProperties(value, condition);
    }
  }
  return result;
};

// packages/common/util/src/safe-await.ts
var safeAwaitAll = async (source, taskFactory, onError) => {
  const failedItems = [];
  await Promise.all([
    ...source
  ].map(async (item, idx) => {
    try {
      await taskFactory(item);
    } catch (err) {
      if (onError) {
        onError(err, item, idx);
      }
      failedItems.push(item);
    }
  }));
  return failedItems;
};

// packages/common/util/src/safe-instanceof.ts
var instanceTag = Symbol("instanceTag");
var safeInstanceof = (tag) => (target) => {
  target.prototype[instanceTag] = tag;
  Object.defineProperty(target.prototype, Symbol.hasInstance, {
    value: (instance) => instance?.[instanceTag] === tag
  });
  Object.defineProperty(target, Symbol.hasInstance, {
    value: (instance) => instance?.[instanceTag] === tag
  });
};

// packages/common/util/src/safe-parse.ts
var safeParseInt = (value, defaultValue) => {
  try {
    const n = parseInt(value ?? "");
    return isNaN(n) ? defaultValue : n;
  } catch (err) {
    return defaultValue;
  }
};
var safeParseFloat = (str, defaultValue) => {
  try {
    return parseFloat(str);
  } catch {
    return defaultValue ?? 0;
  }
};
var safeParseJson = (data, defaultValue) => {
  if (data && data.length > 0) {
    try {
      return JSON.parse(data);
    } catch (err) {
    }
  }
  return defaultValue;
};

// packages/common/util/src/sliding-window-summary.ts
import { invariant as invariant5 } from "@dxos/invariant";
var __dxlog_file5 = "/home/runner/work/dxos/dxos/packages/common/util/src/sliding-window-summary.ts";
var SlidingWindowSummary = class {
  constructor(options) {
    this._sum = 0;
    this._buffer = new CircularBuffer(options.dataPoints);
    if (options.precision != null) {
      invariant5(options.precision >= 0, void 0, {
        F: __dxlog_file5,
        L: 26,
        S: this,
        A: [
          "options.precision >= 0",
          ""
        ]
      });
      this._precision = Math.pow(10, options.precision);
    }
  }
  record(value) {
    const evicted = this._buffer.push(value);
    this._sum += value - (evicted ?? 0);
  }
  average() {
    return this._buffer.elementCount === 0 ? 0 : this._withPrecision(this._sum / this._buffer.elementCount);
  }
  computeWindowSummary() {
    const mean = this.average();
    const sortedElements = [
      ...this._buffer
    ].sort();
    const median2 = this._withPrecision(sortedElements.length % 2 === 0 ? (sortedElements[sortedElements.length / 2] + sortedElements[sortedElements.length / 2 - 1]) / 2 : sortedElements[sortedElements.length / 2]);
    const p90 = this._withPrecision(sortedElements[Math.round(sortedElements.length * 0.9)]);
    const variance = sortedElements.reduce((acc, v) => acc + Math.pow(v - mean, 2)) / sortedElements.length;
    const stdDev = this._withPrecision(Math.sqrt(variance));
    const histogram = sortedElements.reduce((acc, v) => {
      acc[v] += 1;
      return acc;
    }, {});
    return {
      mean,
      median: median2,
      p90,
      stdDev,
      histogram
    };
  }
  _withPrecision(value) {
    if (this._precision == null) {
      return value;
    }
    return Math.round(value * this._precision) / this._precision;
  }
};

// packages/common/util/src/sort.ts
var compareScalar = (inc = true) => (a, b) => (inc ? 1 : -1) * (a < b ? -1 : a > b ? 1 : 0);
var compareString = (inc = true, caseInsensitive = true) => (a, b) => {
  if (caseInsensitive) {
    a = a?.toLowerCase();
    b = b?.toLowerCase();
  }
  return (inc ? 1 : -1) * (a < b ? -1 : a > b ? 1 : 0);
};
var compareObject = (prop, sorter, inc = true) => (a, b) => (inc ? 1 : -1) * sorter(a[prop], b[prop]);
var compareMulti = (sorters) => (a, b) => {
  const sort = (i = 0) => {
    const s = sorters[i](a, b);
    if (s === 0 && i < sorters.length - 1) {
      return sort(i + 1);
    } else {
      return s;
    }
  };
  return sort();
};

// packages/common/util/src/string.ts
var capitalize = (str) => {
  if (str.length === 0) {
    return "";
  }
  return str.charAt(0).toUpperCase() + str.slice(1);
};

// packages/common/util/src/sum.ts
var sum = (values) => values.reduce((a, b) => a + b, 0);

// packages/common/util/src/throw-unhandled-error.ts
var throwUnhandledError = (error) => {
  queueMicrotask(() => {
    throw error;
  });
};

// packages/common/util/src/to-fallback.ts
var idEmoji = [
  // When changing this set, please check the result in a console or e.g. RunKit (https://runkit.com/thure/642214441dd6ae000855a8de)
  // Emoji sometimes use a combination of code points, and some code points aren't visible on their own, so by adding or deleting you may unintentionally create non-visible items.
  // This set was chosen from the characters in Unicode Emoji v15.0 based on the following criteria:
  // – not people or isolated anthropomorphic faces
  // – not flags
  // – more concrete than abstract
  // – less culturally specific
  // – less easily confused with another emoji in the set
  // – requires less special knowledge to identify
  // – less likely to evoke negative feelings (no meat, no drugs, no weapons, etc)
  // – less common as a signifier in UX
  // NOTE that this is intentionally an array of strings because of the way emoji graphemes work.
  "\u{1F47B}",
  "\u{1F479}",
  "\u{1F47D}",
  "\u{1F916}",
  "\u{1F383}",
  "\u{1F9BE}",
  "\u{1F9BF}",
  "\u{1F9B7}",
  "\u{1F463}",
  "\u{1F441}\uFE0F",
  "\u{1F9F6}",
  "\u{1F451}",
  "\u{1F412}",
  "\u{1F986}",
  "\u{1F989}",
  "\u{1F434}",
  "\u{1F984}",
  "\u{1F41D}",
  "\u{1F98B}",
  "\u{1F41E}",
  "\u{1FAB2}",
  "\u{1F422}",
  "\u{1F98E}",
  "\u{1F995}",
  "\u{1F991}",
  "\u{1F980}",
  "\u{1F420}",
  "\u{1F42C}",
  "\u{1F40B}",
  "\u{1F9AD}",
  "\u{1F405}",
  "\u{1F406}",
  "\u{1F993}",
  "\u{1F98D}",
  "\u{1F9A7}",
  "\u{1F418}",
  "\u{1F42B}",
  "\u{1F992}",
  "\u{1F998}",
  "\u{1F9AC}",
  "\u{1F416}",
  "\u{1F40F}",
  "\u{1F98C}",
  "\u{1F415}",
  "\u{1F408}",
  "\u{1F413}",
  "\u{1F99A}",
  "\u{1F99C}",
  "\u{1F9A2}",
  "\u{1F9A9}",
  "\u{1F9A6}",
  "\u{1F401}",
  "\u{1F43F}\uFE0F",
  "\u{1F335}",
  "\u{1F332}",
  "\u{1F333}",
  "\u{1FAB5}",
  "\u{1F331}",
  "\u{1F341}",
  "\u{1FABA}",
  "\u{1F344}",
  "\u{1F41A}",
  "\u{1FAB8}",
  "\u{1FAA8}",
  "\u{1F33E}",
  "\u{1F337}",
  "\u{1F33B}",
  "\u2600\uFE0F",
  "\u{1F319}",
  "\u{1FA90}",
  "\u2B50\uFE0F",
  "\u26A1\uFE0F",
  "\u2604\uFE0F",
  "\u{1F525}",
  "\u{1F308}",
  "\u2601\uFE0F",
  "\u{1F4A7}",
  "\u26F1\uFE0F",
  "\u{1F30A}",
  "\u{1F34E}",
  "\u{1F34B}",
  "\u{1F349}",
  "\u{1F347}",
  "\u{1FAD0}",
  "\u{1F348}",
  "\u{1F352}",
  "\u{1F351}",
  "\u{1F96D}",
  "\u{1F34D}",
  "\u{1F965}",
  "\u{1F95D}",
  "\u{1F951}",
  "\u{1F336}\uFE0F",
  "\u{1F33D}",
  "\u{1F955}",
  "\u{1F36C}",
  "\u{1F95C}",
  "\u{1FAD6}",
  "\u2615\uFE0F",
  "\u{1F375}",
  "\u{1F9CA}",
  "\u{1F9C2}",
  "\u{1F3D4}\uFE0F",
  "\u2693\uFE0F",
  "\u{1F6DF}",
  "\u{1F3DD}\uFE0F",
  "\u{1F6F6}",
  "\u{1F680}",
  "\u{1F6F0}\uFE0F",
  "\u26F2\uFE0F",
  "\u{1F3F0}",
  "\u{1F6B2}",
  "\u26FA\uFE0F",
  "\u{1F399}\uFE0F",
  "\u{1F9F2}",
  "\u2699\uFE0F",
  "\u{1F529}",
  "\u{1F52E}",
  "\u{1F52D}",
  "\u{1F52C}",
  "\u{1F9EC}",
  "\u{1F321}\uFE0F",
  "\u{1F9FA}",
  "\u{1F6CE}\uFE0F",
  "\u{1F511}",
  "\u{1FA91}",
  "\u{1F9F8}",
  "\u{1F388}",
  "\u{1F380}",
  "\u{1F38A}",
  "\u267B\uFE0F",
  "\u{1F3B5}"
];
var idHue = [
  "red",
  // 'orange' as const, /* More shades in these palettes are considered “ugly” */
  "amber",
  // 'yellow' as const, /* More shades in these palettes are considered “ugly” */
  "lime",
  "green",
  "emerald",
  "teal",
  "cyan",
  // 'sky' as const, /* Omitted since it is quite similar to the primary accent palette */
  // 'blue' as const, /* Omitted since it is quite similar to the primary accent palette */
  // 'indigo' as const, /* Omitted since it is quite similar to the primary accent palette */
  "violet",
  "purple",
  "fuchsia",
  "pink",
  "rose"
];
var keyToEmoji = (key) => keyToFallback(key).emoji;
var hexToEmoji = (hex) => hexToFallback(hex).emoji;
var toEmoji = (hash) => toFallback(hash).emoji;
var keyToHue = (key) => keyToFallback(key).hue;
var hexToHue = (hex) => hexToFallback(hex).hue;
var toHue = (hash) => toFallback(hash).hue;
var keyToFallback = (key) => hexToFallback(key.toHex());
var hexToFallback = (hex) => toFallback(parseInt(hex, 16));
var toFallback = (hash) => {
  const totalCombinations = idEmoji.length * idHue.length;
  const combinationIndex = hash % totalCombinations;
  const emojiIndex = Math.floor(combinationIndex / idHue.length);
  const hueIndex = combinationIndex % idHue.length;
  return {
    emoji: idEmoji[emojiIndex],
    hue: idHue[hueIndex]
  };
};

// packages/common/util/src/tracer.ts
var Tracer = class {
  constructor() {
    this._events = /* @__PURE__ */ new Map();
    this._recording = false;
  }
  // TODO(burdon): Start/stop methods for recording data? By id?
  //  Alternatively, enable subscriptions to track/compute series.
  // TODO(burdon): Hierarchical traces?
  get recording() {
    return this._recording;
  }
  keys() {
    return Array.from(this._events.keys());
  }
  get(id, filter) {
    const events = this._events.get(id);
    if (filter) {
      return events?.filter((event) => Object.entries(filter).every(([key, value]) => event?.value[key] === value));
    }
    return events;
  }
  clear() {
    this._events.clear();
  }
  start() {
    this._recording = true;
    return this;
  }
  stop() {
    this._recording = false;
    return this;
  }
  emit(id, value) {
    this._post(this._createEvent(id, value));
  }
  mark(id, value) {
    const event = this._createEvent(id, value);
    const start = performance.now();
    return {
      start,
      end: () => {
        event.duration = performance.now() - start;
        this._post(event);
      }
    };
  }
  _createEvent(id, value) {
    const event = {
      id,
      timestamp: Date.now()
    };
    if (value !== void 0) {
      event.value = value;
    }
    return event;
  }
  _post(event) {
    if (this._recording) {
      defaultMap(this._events, event.id, []).push(event);
    }
  }
};
var tracer = new Tracer();

// packages/common/util/src/tree.ts
import { truncateKey } from "@dxos/debug";
var stringifyTree = (node, ancestors = [], rows = []) => {
  if (node.children?.length) {
    node.children.forEach((child, i) => {
      stringifyTree(child, [
        ...ancestors,
        [
          node,
          i
        ]
      ], rows);
    });
  } else {
    const keyLen = 8;
    const name = (node2) => truncateKey(node2.id, keyLen);
    const parts = [];
    ancestors.forEach(([node2, i], j) => {
      const first = ancestors.slice(j).every(([_, i2]) => i2 === 0);
      parts.push(j === 0 ? first ? "\u251C" : " " : "");
      parts.push(first ? `\u2500(${name(node2)})\u2500` : "".padEnd(keyLen + 4));
      if (node2.children) {
        if (first) {
          parts.push(node2.children.length > 1 ? "\u252C" : "\u2500");
        } else {
          const childFirst = ancestors.slice(j + 1).every(([_, i2]) => i2 === 0);
          if (node2.children.length - 1 === i) {
            parts.push(childFirst ? "\u2570" : " ");
          } else {
            parts.push(childFirst ? "\u251C" : "\u2502");
          }
        }
      }
    });
    parts.push(`\u2500(${name(node)})`);
    rows.push(parts.join(""));
  }
  return rows;
};

// packages/common/util/src/types.ts
var isNotFalsy = (value) => !!value;
var isNonNullable = (value) => value != null;
var doAsync = async (fn) => fn();
var getProviderValue = (provider, arg) => {
  return typeof provider === "function" ? provider(arg) : provider;
};
var getAsyncProviderValue = (provider, arg) => {
  return getProviderValue(provider, arg);
};
var stripUndefined = (obj) => {
  if (typeof obj === "object") {
    Object.keys(obj).forEach((key) => {
      const value = obj[key];
      if (value === void 0) {
        delete obj[key];
      } else if (value !== null && typeof value === "object") {
        stripUndefined(value);
      }
    });
  }
  return obj;
};
var sortKeys = (obj) => Object.keys(obj).sort().reduce((sorted, key) => {
  sorted[key] = obj[key];
  return sorted;
}, {});
var arrayMove = (array, from, to) => {
  array.splice(to < 0 ? array.length + to : to, 0, array.splice(from, 1)[0]);
  return array;
};

// packages/common/util/src/weak.ts
var WeakDictionary = class {
  constructor(entries2) {
    this._internal = /* @__PURE__ */ new Map();
    this._finalization = new FinalizationRegistry((cleanUpCallback) => {
      cleanUpCallback();
    });
    this._internal = new Map(entries2?.map(([key, value]) => [
      key,
      new WeakRef(value)
    ]));
    entries2?.forEach(([key, value]) => this._register(key, value));
  }
  *entries() {
    for (const [key, value] of this._internal) {
      yield [
        key,
        value.deref()
      ];
    }
  }
  keys() {
    return this._internal.keys();
  }
  *values() {
    for (const value of this._internal.values()) {
      const deref = value.deref();
      if (!deref) {
        continue;
      }
      yield deref;
    }
  }
  *[Symbol.iterator]() {
    for (const [key, value] of this._internal) {
      yield [
        key,
        value.deref()
      ];
    }
  }
  get [Symbol.toStringTag]() {
    return "WeakDictionary";
  }
  get size() {
    return this._internal.size;
  }
  get(key) {
    return this._internal.get(key)?.deref();
  }
  set(key, value) {
    this._internal.set(key, new WeakRef(value));
    this._register(key, value);
    return this;
  }
  has(key) {
    return this._internal.has(key) && this._internal.get(key).deref() !== void 0;
  }
  delete(key) {
    const value = this._internal.get(key)?.deref();
    if (value) {
      this._unregister(value);
    }
    return this._internal.delete(key);
  }
  clear() {
    this._internal.forEach((value) => {
      const v = value.deref();
      if (v) {
        this._unregister(v);
      }
    });
    this._internal.clear();
  }
  forEach(callbackfn, thisArg) {
    if (thisArg) {
      callbackfn = callbackfn.bind(thisArg);
    }
    this._internal.forEach((value, key) => {
      const v = value.deref();
      if (v) {
        callbackfn(v, key, this);
      }
    });
  }
  _register(key, value) {
    this._finalization.register(value, () => {
      this._internal.delete(key);
    }, value);
  }
  _unregister(value) {
    this._finalization.unregister(value);
  }
};

// packages/common/util/src/assume.ts
function assumeType(value) {
}
export {
  BitField,
  Callback,
  CallbackCollection,
  CircularBuffer,
  ComplexMap,
  ComplexSet,
  HumanHasher,
  MapEntry,
  SlidingWindowSummary,
  Tracer,
  WeakDictionary,
  accessBy,
  arrayMove,
  arrayToBuffer,
  arrayToHex,
  arrayToString,
  arraysEqual,
  assumeType,
  bufferToArray,
  byPosition,
  capitalize,
  chunkArray,
  clamp,
  clearUndefined,
  compareMulti,
  compareObject,
  compareScalar,
  compareString,
  createBinder,
  createBucketReducer,
  createGroupReducer,
  createSetDispatch,
  decamelize,
  deepMapValues,
  deepMapValuesAsync,
  defaultMap,
  defer,
  deferAsync,
  deferFunction,
  diff,
  distinctBy,
  doAsync,
  entries,
  entry,
  exponentialBackoffInterval,
  forEachAsync,
  get,
  getAsyncProviderValue,
  getDate,
  getDebugName,
  getDeep,
  getFirstTwoRenderableChars,
  getHostPlatform,
  getPrototypeSpecificInstanceId,
  getProviderValue,
  hexToEmoji,
  hexToFallback,
  hexToHue,
  humanize,
  hyphenize,
  idEmoji,
  idHue,
  inferObjectOrder,
  inferRecordOrder,
  intersectBy,
  intersection,
  iosCheck,
  isNode,
  isNonNullable,
  isNotFalsy,
  joinTables,
  jsonKeyReplacer,
  jsonReplacer,
  jsonify,
  jsonlogify,
  keyToEmoji,
  keyToFallback,
  keyToHue,
  keys,
  makeMap,
  makeSet,
  mapValues,
  median,
  mobileAndTabletCheck,
  numericalValues,
  omit,
  orderKeys,
  partition,
  pick,
  pickBy,
  randomInt,
  range,
  rangeFromTo,
  reduceGroupBy,
  reduceSeries,
  reduceSet,
  removeBy,
  removeProperties,
  removeUndefinedProperties,
  safariCheck,
  safeAwaitAll,
  safeInstanceof,
  safeParseFloat,
  safeParseInt,
  safeParseJson,
  set,
  setDeep,
  sortKeys,
  stringToArray,
  stringifyTree,
  stripUndefined,
  sum,
  throwUnhandledError,
  toEmoji,
  toFallback,
  toHue,
  tracer,
  visitValues
};
//# sourceMappingURL=index.mjs.map
