import { createRequire } from 'node:module';const require = createRequire(import.meta.url);
import {
  FeedFactory,
  FeedStore,
  FeedWrapper
} from "./chunk-AO5I2BX3.mjs";

// packages/common/feed-store/src/feed-iterator.ts
import safeRace from "race-as-promised";
import { Trigger as Trigger2 } from "@dxos/async";
import { invariant as invariant2 } from "@dxos/invariant";
import { log as log2 } from "@dxos/log";

// packages/common/feed-store/src/feed-queue.ts
import { inspect } from "node:util";
import { Writable } from "streamx";
import { Event, latch, Trigger } from "@dxos/async";
import { inspectObject } from "@dxos/debug";
import { invariant } from "@dxos/invariant";
import { log } from "@dxos/log";
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/common/feed-store/src/feed-queue.ts";
var defaultReadStreamOptions = {
  live: true,
  batch: 1024
};
var FeedQueue = class {
  // prettier-ignore
  constructor(_feed, _options = {}) {
    this._feed = _feed;
    this._options = _options;
    this.updated = new Event();
    this._messageTrigger = new Trigger({
      autoReset: true
    });
    this._feedConsumer = void 0;
    this._currentBlock = void 0;
    this._index = -1;
  }
  [inspect.custom]() {
    return inspectObject(this);
  }
  toJSON() {
    return {
      feedKey: this._feed.key,
      index: this.index,
      length: this.length,
      open: this.isOpen
    };
  }
  get feed() {
    return this._feed;
  }
  get isOpen() {
    return Boolean(this._feedConsumer);
  }
  get length() {
    return this._feed.properties.length;
  }
  /**
  * Index (seq) of the NEXT block to be read, or -1 if not open.
  */
  get index() {
    return this._index;
  }
  /**
  * Opens (or reopens) the queue.
  * @param options.start Starting index. First mutation to be read would have `seq == options.start`.
  */
  async open(options = {}) {
    if (this.isOpen) {
      return;
    }
    this._index = options.start ?? 0;
    log("opening", {
      feedKey: this._feed.key
    }, {
      F: __dxlog_file,
      L: 92,
      S: this,
      C: (f, a) => f(...a)
    });
    const opts = Object.assign({}, defaultReadStreamOptions, options);
    const feedStream = this._feed.createReadableStream(opts);
    this._feedConsumer = new Writable({
      write: (data, next) => {
        this._next = () => {
          this._next = void 0;
          this._currentBlock = void 0;
          this._index++;
          next();
        };
        this._currentBlock = {
          feedKey: this._feed.key,
          seq: this._index,
          data
        };
        this._messageTrigger.wake(this._currentBlock);
        this.updated.emit(this);
      }
    });
    const onClose = () => {
      this.feed.core.off("close", onClose);
      this._feedConsumer?.off("close", onClose);
      this._feedConsumer?.off("error", onError);
      this._destroyConsumer();
    };
    const onError = (err) => {
      if (!err) {
        return;
      }
      if (err.message === "Writable stream closed prematurely" || err.message === "Feed is closed") {
        return;
      }
      log.catch(err, {
        feedKey: this._feed.key
      }, {
        F: __dxlog_file,
        L: 135,
        S: this,
        C: (f, a) => f(...a)
      });
    };
    this._feed.core.once("close", onClose);
    this._feedConsumer.on("error", onError);
    this._feedConsumer.once("close", onClose);
    feedStream.pipe(this._feedConsumer, (err) => {
      if (err) {
        onError(err);
      }
      this._destroyConsumer();
    });
    log("opened", void 0, {
      F: __dxlog_file,
      L: 153,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  /**
  * Closes the queue.
  */
  async close() {
    if (this.isOpen) {
      invariant(this._feedConsumer, void 0, {
        F: __dxlog_file,
        L: 161,
        S: this,
        A: [
          "this._feedConsumer",
          ""
        ]
      });
      invariant(!this._feed.properties.closed, void 0, {
        F: __dxlog_file,
        L: 162,
        S: this,
        A: [
          "!this._feed.properties.closed",
          ""
        ]
      });
      log("closing", {
        feedKey: this._feed.key
      }, {
        F: __dxlog_file,
        L: 164,
        S: this,
        C: (f, a) => f(...a)
      });
      const [closed, setClosed] = latch();
      this._feedConsumer.once("close", setClosed);
      this._feedConsumer.destroy();
      this._next?.();
      await closed();
      log("closed", void 0, {
        F: __dxlog_file,
        L: 170,
        S: this,
        C: (f, a) => f(...a)
      });
    }
  }
  /**
  * Get the block at the head of the queue without removing it.
  */
  peek() {
    return this._currentBlock;
  }
  /**
  * Pop block at the head of the queue.
  */
  async pop() {
    if (!this.isOpen) {
      throw new Error(`Queue closed: ${this.feed.key.truncate()}`);
    }
    let block = this.peek();
    if (!block) {
      block = await this._messageTrigger.wait();
    }
    if (block) {
      this._next?.();
    }
    return block;
  }
  _destroyConsumer() {
    if (this._feedConsumer) {
      log("queue closed", {
        feedKey: this._feed.key
      }, {
        F: __dxlog_file,
        L: 203,
        S: this,
        C: (f, a) => f(...a)
      });
      this._feedConsumer = void 0;
      this._next = void 0;
      this._currentBlock = void 0;
      this._index = -1;
    }
  }
};

// packages/common/feed-store/src/feed-iterator.ts
var __dxlog_file2 = "/home/runner/work/dxos/dxos/packages/common/feed-store/src/feed-iterator.ts";
var AbstractFeedIterator = class {
  constructor() {
    this._stopTrigger = new Trigger2();
    this._open = false;
    this._running = false;
  }
  toJSON() {
    return {
      open: this.isOpen,
      running: this.isRunning
    };
  }
  get isOpen() {
    return this._open;
  }
  get isRunning() {
    return this._running;
  }
  async open() {
    if (!this._open) {
      log2("opening...", void 0, {
        F: __dxlog_file2,
        L: 41,
        S: this,
        C: (f, a) => f(...a)
      });
      await this._onOpen();
      this._open = true;
      await this.start();
      log2("opened", void 0, {
        F: __dxlog_file2,
        L: 46,
        S: this,
        C: (f, a) => f(...a)
      });
    }
  }
  async close() {
    if (this._open) {
      log2("closing...", void 0, {
        F: __dxlog_file2,
        L: 52,
        S: this,
        C: (f, a) => f(...a)
      });
      await this.stop();
      await this._onClose();
      this._open = false;
      log2("closed", void 0, {
        F: __dxlog_file2,
        L: 57,
        S: this,
        C: (f, a) => f(...a)
      });
    }
  }
  async start() {
    invariant2(this._open, void 0, {
      F: __dxlog_file2,
      L: 62,
      S: this,
      A: [
        "this._open",
        ""
      ]
    });
    if (!this._running) {
      this._running = true;
    }
  }
  async stop() {
    invariant2(this._open, void 0, {
      F: __dxlog_file2,
      L: 69,
      S: this,
      A: [
        "this._open",
        ""
      ]
    });
    if (this._running) {
      this._running = false;
      this._stopTrigger.wake();
    }
  }
  //
  // AsyncIterable
  //
  [Symbol.asyncIterator]() {
    return this._generator();
  }
  async *_generator() {
    log2("started", void 0, {
      F: __dxlog_file2,
      L: 85,
      S: this,
      C: (f, a) => f(...a)
    });
    while (this._running) {
      const block = await safeRace([
        this._stopTrigger.wait(),
        this._nextBlock()
      ]);
      if (block === void 0) {
        break;
      }
      yield block;
    }
    log2("stopped", void 0, {
      F: __dxlog_file2,
      L: 97,
      S: this,
      C: (f, a) => f(...a)
    });
  }
};
var FeedIterator = class extends AbstractFeedIterator {
  constructor(_feed) {
    super(), this._feed = _feed;
    this._queue = new FeedQueue(this._feed);
  }
  async _onOpen() {
    await this._queue.open();
  }
  async _onClose() {
    await this._queue.close();
  }
  async _nextBlock() {
    return this._queue.pop();
  }
};

// packages/common/feed-store/src/feed-set-iterator.ts
import { inspect as inspect2 } from "node:util";
import { Event as Event2, SubscriptionList, Trigger as Trigger3 } from "@dxos/async";
import { inspectObject as inspectObject2 } from "@dxos/debug";
import { invariant as invariant3 } from "@dxos/invariant";
import { PublicKey } from "@dxos/keys";
import { log as log3 } from "@dxos/log";
import { ComplexMap, isNonNullable } from "@dxos/util";
var __dxlog_file3 = "/home/runner/work/dxos/dxos/packages/common/feed-store/src/feed-set-iterator.ts";
var defaultFeedSetIteratorOptions = {
  stallTimeout: 1e3
};
var FeedSetIterator = class extends AbstractFeedIterator {
  constructor(_selector, options = defaultFeedSetIteratorOptions) {
    super(), this._selector = _selector, this.options = options, this._feedQueues = new ComplexMap(PublicKey.hash), this._trigger = new Trigger3({
      autoReset: true
    }), this._subscriptions = new SubscriptionList(), this.stalled = new Event2();
    invariant3(_selector, void 0, {
      F: __dxlog_file3,
      L: 55,
      S: this,
      A: [
        "_selector",
        ""
      ]
    });
    invariant3(options, void 0, {
      F: __dxlog_file3,
      L: 56,
      S: this,
      A: [
        "options",
        ""
      ]
    });
  }
  [inspect2.custom]() {
    return inspectObject2(this);
  }
  toJSON() {
    return {
      open: this.isOpen,
      running: this.isRunning,
      indexes: this.indexes
    };
  }
  get size() {
    return this._feedQueues.size;
  }
  get feeds() {
    return Array.from(this._feedQueues.values()).map((feedQueue) => feedQueue.feed);
  }
  get indexes() {
    return Array.from(this._feedQueues.values()).map((feedQueue) => ({
      feedKey: feedQueue.feed.key,
      index: feedQueue.index
    }));
  }
  reiterateBlock(block) {
    this._trigger.wake();
  }
  async addFeed(feed) {
    invariant3(!this._feedQueues.has(feed.key), `Feed already added: ${feed.key}`, {
      F: __dxlog_file3,
      L: 91,
      S: this,
      A: [
        "!this._feedQueues.has(feed.key)",
        "`Feed already added: ${feed.key}`"
      ]
    });
    invariant3(feed.properties.opened, void 0, {
      F: __dxlog_file3,
      L: 92,
      S: this,
      A: [
        "feed.properties.opened",
        ""
      ]
    });
    log3("feed added", {
      feedKey: feed.key
    }, {
      F: __dxlog_file3,
      L: 93,
      S: this,
      C: (f, a) => f(...a)
    });
    const queue = new FeedQueue(feed);
    this._feedQueues.set(feed.key, queue);
    this._subscriptions.add(queue.updated.on(() => {
      this._trigger.wake();
    }));
    await queue.open({
      start: this.options.start?.find((index) => index.feedKey.equals(feed.key))?.index
    });
    this._trigger.wake();
  }
  hasFeed(feedKey) {
    return this._feedQueues.has(feedKey);
  }
  async _onOpen() {
    for (const queue of this._feedQueues.values()) {
      await queue.open();
    }
  }
  async _onClose() {
    this._subscriptions.clear();
    await Promise.all(Array.from(this._feedQueues.values()).map((queue) => queue.close()));
    this._trigger.wake();
  }
  /**
  * Gets the next block from the selected queue.
  */
  async _nextBlock() {
    let t;
    while (this._running) {
      const queues = Array.from(this._feedQueues.values());
      const blocks = queues.map((queue) => queue.peek()).filter(isNonNullable);
      if (blocks.length) {
        const idx = this._selector(blocks);
        log3("selected", {
          idx,
          blocks
        }, {
          F: __dxlog_file3,
          L: 143,
          S: this,
          C: (f, a) => f(...a)
        });
        if (idx === void 0) {
          if (t === void 0) {
            t = setTimeout(() => {
              this.stalled.emit(this);
              this._trigger.wake();
            }, this.options.stallTimeout);
          }
        } else {
          if (t !== void 0) {
            clearTimeout(t);
            t = void 0;
          }
          if (idx >= blocks.length) {
            throw new Error(`Index out of bounds: ${idx} of ${blocks.length}`);
          }
          const queue = this._feedQueues.get(blocks[idx].feedKey);
          log3("popping", queue.toJSON(), {
            F: __dxlog_file3,
            L: 163,
            S: this,
            C: (f, a) => f(...a)
          });
          try {
            const message = await queue.pop();
            invariant3(message === blocks[idx], void 0, {
              F: __dxlog_file3,
              L: 166,
              S: this,
              A: [
                "message === blocks[idx]",
                ""
              ]
            });
            return message;
          } catch (err) {
            log3.warn("queue closed", {
              feedKey: queue.feed.key
            }, {
              F: __dxlog_file3,
              L: 170,
              S: this,
              C: (f, a) => f(...a)
            });
          }
        }
      }
      await this._trigger.wait();
    }
  }
};

// packages/common/feed-store/src/feed-writer.ts
var createFeedWriter = (cb) => ({
  write: async (data) => {
    return cb(data);
  }
});
var writeMessages = async (writer, messages) => {
  const receipts = [];
  for (const message of messages) {
    receipts.push(await writer.write(message));
  }
  return receipts;
};
export {
  AbstractFeedIterator,
  FeedFactory,
  FeedIterator,
  FeedQueue,
  FeedSetIterator,
  FeedStore,
  FeedWrapper,
  createFeedWriter,
  defaultFeedSetIteratorOptions,
  defaultReadStreamOptions,
  writeMessages
};
//# sourceMappingURL=index.mjs.map
