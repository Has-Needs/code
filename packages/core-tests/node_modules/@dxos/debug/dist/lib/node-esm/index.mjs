import { createRequire } from 'node:module';const require = createRequire(import.meta.url);

// packages/common/debug/src/assert.ts
var checkType = (value) => value;

// packages/common/debug/src/error-handler.ts
import { EventEmitter } from "node:events";
var ErrorHandler = class extends EventEmitter {
  constructor() {
    super();
    this._listener = (event) => {
      const cause = event.error || event.reason || event;
      const message = cause.stack || cause.message || cause.toString();
      this.emit("error", message);
    };
    window.addEventListener("error", this._listener);
    window.addEventListener("unhandledrejection", this._listener);
  }
  reset() {
    window.removeEventListener("error", this._listener);
    window.removeEventListener("unhandledrejection", this._listener);
  }
};

// packages/common/debug/src/error-stream.ts
var ErrorStream = class {
  constructor() {
    this._unhandledErrors = 0;
  }
  assertNoUnhandledErrors() {
    if (this._unhandledErrors > 0) {
      throw new Error(`Assertion failed: expected no unhandled errors to be thrown, but ${this._unhandledErrors} were thrown.`);
    }
  }
  raise(error) {
    if (this._handler) {
      this._handler(error);
    } else {
      this._unhandledError(error);
    }
  }
  handle(handler) {
    this._handler = handler;
  }
  pipeTo(receiver) {
    this.handle((error) => receiver.raise(error));
  }
  _unhandledError(error) {
    this._unhandledErrors++;
    setTimeout(() => {
      throw error;
    });
  }
};

// packages/common/debug/src/fail.ts
var failUndefined = () => {
  throw new Error("Required value was null or undefined.");
};

// packages/common/debug/src/inspect.ts
import { inspect } from "node:util";
var inspectObject = (obj) => {
  const name = Object.getPrototypeOf(obj).constructor.name;
  return obj.toJSON ? `${name}(${inspect(obj.toJSON())})` : String(obj);
};

// packages/common/debug/src/log-method.ts
function logMethod(target, propertyName, descriptor) {
  const method = descriptor.value;
  descriptor.value = function(...args) {
    console.log(`Called ${target.constructor.name}.${propertyName} ${args}`);
    try {
      const result = method.apply(this, args);
      if (typeof result.catch === "function") {
        result.catch((err) => {
          console.log(`Rejected ${target.constructor.name}.${propertyName}`, err);
        });
      }
      return result;
    } catch (err) {
      console.log(`Thrown ${target.constructor.name}.${propertyName}`, err);
      throw err;
    }
  };
}

// packages/common/debug/src/raise.ts
var raise = (error) => {
  throw error;
};

// packages/common/debug/src/snoop.ts
var SnoopLevel = /* @__PURE__ */ function(SnoopLevel2) {
  SnoopLevel2[SnoopLevel2["DEFAULT"] = 0] = "DEFAULT";
  SnoopLevel2[SnoopLevel2["VERBOSE"] = 1] = "VERBOSE";
  SnoopLevel2[SnoopLevel2["BOLD"] = 2] = "BOLD";
  return SnoopLevel2;
}({});
var Snoop = class _Snoop {
  static stackFunction(err) {
    const stack = err.stack.split("\n");
    const match = stack[2].match(/.+\((.+)\).*/);
    if (match) {
      const [file, line] = match[1].split(":");
      return `[${file.substring(file.lastIndexOf("/") + 1)}:${line}]`;
    }
  }
  constructor(_context) {
    this._context = _context;
  }
  get verbose() {
    return 1;
  }
  get bold() {
    return 2;
  }
  format(prefix, name, args, level) {
    const pre = prefix.repeat(level === 2 ? 8 : 2);
    const label = this._context ? `${this._context}.${name}` : name;
    const line = `${pre} ${label}${args}`;
    return level === 2 ? [
      pre,
      line,
      pre
    ].join("\n") : line;
  }
  in(label, level, ...args) {
    return this.format("<", label, level === 0 ? "" : `(${String(...args)})`, level);
  }
  out(label, level, result) {
    return this.format(">", label, level === 0 ? "" : ` = ${String(result)}`, level);
  }
  sync(f, label, level = 1) {
    label = label ?? _Snoop.stackFunction(new Error());
    return (...args) => {
      console.log(this.in(label ?? "", level, ...args));
      const r = f(...args);
      console.log(this.out(label ?? "", level, r));
      return r;
    };
  }
  async(f, label, level = 1) {
    label = label ?? _Snoop.stackFunction(new Error());
    return async (...args) => {
      console.log(this.in(label ?? "", level, ...args));
      const r = await f(...args);
      console.log(this.out(label ?? "", level, r));
      return r;
    };
  }
};
var snoop = new Snoop();

// packages/common/debug/src/stack-trace.ts
var StackTrace = class {
  constructor() {
    this._stack = new Error();
  }
  /**
  * Get stack formatted as string.
  * @param skipFrames Number of frames to skip. By default, the first frame would be the invocation of the StackTrace constructor.
  * @returns
  */
  getStack(skipFrames = 0) {
    const stack = this._stack.stack.split("\n");
    return stack.slice(skipFrames + 2).join("\n");
  }
  getStackArray(skipFrames = 0) {
    const stack = this._stack.stack.split("\n");
    return stack.slice(skipFrames + 2);
  }
};

// packages/common/debug/src/strings.ts
var truncate = (str = "", length = 8, pad = false) => {
  if (str.length >= length - 1) {
    return str.substring(0, length - 1) + "\u2026";
  } else {
    return pad ? str.padEnd(length, typeof pad === "boolean" ? " " : pad[0]) : str;
  }
};
var truncateKey = (key, length = 8) => {
  const str = String(key);
  if (str.length <= length) {
    return str;
  }
  return str.slice(0, length);
};

// packages/common/debug/src/throw.ts
var expectToThrow = async (test, errType = Error) => {
  let thrown;
  try {
    await test();
  } catch (err) {
    thrown = err;
  }
  if (thrown === void 0 || !(thrown instanceof errType)) {
    throw new Error(`Expected function to throw instance of ${errType.prototype.name}`);
  }
};

// packages/common/debug/src/timeout-warning.ts
var warnAfterTimeout = async (timeout, context, body) => {
  const stack = new StackTrace();
  const timeoutId = setTimeout(() => {
    console.warn(`Action \`${context}\` is taking more then ${timeout.toLocaleString()}ms to complete. This might be a bug.
${stack.getStack()}`);
  }, timeout);
  try {
    return await body();
  } finally {
    clearTimeout(timeoutId);
  }
};
function timed(timeout) {
  return (target, propertyName, descriptor) => {
    const method = descriptor.value;
    descriptor.value = function(...args) {
      return warnAfterTimeout(timeout, `${target.constructor.name}.${propertyName}`, () => method.apply(this, args));
    };
  };
}

// packages/common/debug/src/todo.ts
var todo = (message) => {
  throw new Error(message ?? "Not implemented.");
};

// packages/common/debug/src/devtools-formatter.ts
var devtoolsFormatter = Symbol.for("devtoolsFormatter");
var register = () => {
  if (typeof window !== "undefined") {
    (window.devtoolsFormatters ??= []).push({
      header: (value, config) => {
        const formatter = value[devtoolsFormatter];
        if (formatter === void 0) {
          return null;
        }
        if (typeof formatter !== "object" || formatter === null || typeof formatter.header !== "function") {
          throw new Error(`Invalid devtools formatter for ${value.constructor.name}`);
        }
        return formatter.header(config);
      },
      hasBody: (value, config) => {
        const formatter = value[devtoolsFormatter];
        if (!formatter || !formatter.hasBody) {
          return false;
        }
        return formatter.hasBody(config);
      },
      body: (value, config) => {
        const formatter = value[devtoolsFormatter];
        if (!formatter || !formatter.body) {
          return null;
        }
        return formatter.body(config);
      }
    });
  }
};
register();

// packages/common/debug/src/equality.ts
var equalsSymbol = Symbol.for("dxos.common.equals");
var isEquatable = (value) => {
  return typeof value === "object" && value !== null && typeof value[equalsSymbol] === "function";
};
var isEqual = (value, other) => {
  return value[equalsSymbol](other);
};
var loadashEqualityFn = (value, other) => {
  if (!isEquatable(value)) {
    return void 0;
  }
  return isEqual(value, other);
};

// packages/common/debug/src/exposed-modules.ts
var exposeModule = (name, module) => {
  EXPOSED_MODULES[name] = module;
};
var importModule = (name) => {
  if (EXPOSED_MODULES[name]) {
    return EXPOSED_MODULES[name];
  } else {
    throw new Error(`Module ${name} is not exposed.`);
  }
};
var EXPOSED_MODULES = {};

// packages/common/debug/src/inspect-custom.ts
var inspectCustom = Symbol.for("nodejs.util.inspect.custom");
export {
  ErrorHandler,
  ErrorStream,
  Snoop,
  SnoopLevel,
  StackTrace,
  checkType,
  devtoolsFormatter,
  equalsSymbol,
  expectToThrow,
  exposeModule,
  failUndefined,
  importModule,
  inspectCustom,
  inspectObject,
  isEqual,
  isEquatable,
  loadashEqualityFn,
  logMethod,
  raise,
  snoop,
  timed,
  todo,
  truncate,
  truncateKey,
  warnAfterTimeout
};
//# sourceMappingURL=index.mjs.map
