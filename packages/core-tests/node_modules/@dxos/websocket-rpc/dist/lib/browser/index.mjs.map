{
  "version": 3,
  "sources": ["../../../src/client.ts", "../../../src/token-auth.ts", "../../../src/server.ts"],
  "sourcesContent": ["//\n// Copyright 2022 DXOS.org\n//\n\nimport WebSocket from 'isomorphic-ws';\n\nimport { Event, Trigger } from '@dxos/async';\nimport { log, logInfo } from '@dxos/log';\nimport { createProtoRpcPeer, type ProtoRpcPeer, type ProtoRpcPeerOptions } from '@dxos/rpc';\n\nimport { WebSocketWithTokenAuth } from './token-auth';\n\nexport type WebsocketRpcClientParams<C, S> = {\n  url: string;\n  authenticationToken?: string;\n} & Pick<ProtoRpcPeerOptions<C, S>, 'requested' | 'exposed' | 'handlers' | 'noHandshake'>;\n\nexport class WebsocketRpcClient<C, S> {\n  private _socket?: WebSocket;\n  private _rpc?: ProtoRpcPeer<C>;\n  private readonly _connectTrigger = new Trigger();\n\n  readonly connected = new Event();\n  readonly disconnected = new Event();\n  readonly error = new Event<Error>();\n\n  constructor(private readonly _params: WebsocketRpcClientParams<C, S>) {\n    this._rpc = createProtoRpcPeer({\n      requested: this._params.requested,\n      exposed: this._params.exposed,\n      handlers: this._params.handlers,\n      noHandshake: this._params.noHandshake,\n      port: {\n        send: (msg) => {\n          this._socket!.send(msg);\n        },\n        subscribe: (cb) => {\n          this._socket!.onmessage = async (msg: WebSocket.MessageEvent) => {\n            if (typeof Blob !== 'undefined' && msg.data instanceof Blob) {\n              cb(Buffer.from(await msg.data.arrayBuffer()));\n            } else {\n              cb(msg.data as any);\n            }\n          };\n        },\n      },\n    });\n  }\n\n  @logInfo\n  get url() {\n    return this._params.url;\n  }\n\n  async open(): Promise<void> {\n    if (this._params.authenticationToken) {\n      this._socket = new WebSocketWithTokenAuth(this._params.url, this._params.authenticationToken);\n    } else {\n      this._socket = new WebSocket(this._params.url);\n    }\n    this._socket.onopen = async () => {\n      log('Socket open');\n      try {\n        await this._rpc!.open();\n        log(`RPC open ${this._params.url}`);\n        this.connected.emit();\n        this._connectTrigger.wake();\n      } catch (err: any) {\n        this.error.emit(err);\n      }\n    };\n\n    this._socket.onclose = async () => {\n      log(`Disconnected ${this._params.url}`);\n      this.disconnected.emit();\n      await this.close();\n    };\n\n    this._socket.onerror = (event: WebSocket.ErrorEvent) => {\n      // Browsers do not include the error message in the event object, so we cannot discern 401 errors from other errors.\n      log.error(event.message ?? 'Socket error', { url: this._params.url });\n      const error = event.error ?? new Error(event.message);\n      this.error.emit(error);\n      this._connectTrigger.throw(error);\n    };\n\n    await this._connectTrigger.wait();\n  }\n\n  async close(): Promise<void> {\n    try {\n      await this._rpc?.close();\n    } catch (err) {\n      log.catch(err);\n    }\n    this._socket?.close();\n  }\n\n  get rpc() {\n    return this._rpc!.rpc;\n  }\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\n// Implement WS header-based auth similar to https://github.com/kubernetes/kubernetes/commit/714f97d7baf4975ad3aa47735a868a81a984d1f0\n// https://stackoverflow.com/questions/4361173/http-headers-in-websockets-client-api/77060459#77060459\n\nimport { type IncomingMessage } from 'http';\nimport WebSocket from 'isomorphic-ws';\nimport { type Socket } from 'node:net';\n\nimport { log } from '@dxos/log';\n\nconst PROTOCOL_TOKEN_PREFIX = 'base64url.bearer.authorization.dxos.org';\n\n// TODO: implement middleware which removes the token from the request\n\nexport const authenticateRequestWithTokenAuth = (\n  request: IncomingMessage,\n  socket: Socket,\n  upgradeHead: Buffer,\n  token: string,\n  cb: (request: IncomingMessage, socket: Socket, upgradeHead: Buffer) => void,\n) => {\n  const protocolHeader = request.headers['sec-websocket-protocol'];\n\n  if (!protocolHeader) {\n    log('upgrade unauthorized, header missing', { header: request.headers['sec-websocket-protocol'] });\n    socket.write('HTTP/1.1 401 Unauthorized\\r\\n\\r\\n');\n    socket.destroy();\n    return;\n  }\n\n  const tokenHeader = protocolHeader.replace(new RegExp(`^${PROTOCOL_TOKEN_PREFIX}.`), '');\n\n  // padding characters are not allowed as a websocket protocol.\n  const encodedToken = Buffer.from(token).toString('base64').replace(/=*$/, '');\n\n  if (tokenHeader !== encodedToken) {\n    log('upgrade unauthorized', { token, foo: encodedToken });\n    socket.write('HTTP/1.1 401 Unauthorized\\r\\n\\r\\n');\n    socket.destroy();\n    return;\n  }\n\n  cb(request, socket, upgradeHead);\n};\n\nexport class WebSocketWithTokenAuth extends WebSocket {\n  constructor(url: string, token: string) {\n    const encodedToken = Buffer.from(token).toString('base64').replace(/=*$/, '');\n\n    const wsProtocols = [`base64url.bearer.authorization.dxos.org.${encodedToken}`];\n    super(url, wsProtocols);\n    log('encodedToken', {\n      encodedToken,\n    });\n  }\n}\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { type IncomingMessage } from 'http';\nimport WebSocket from 'isomorphic-ws';\nimport { type Socket } from 'node:net';\n\nimport { log } from '@dxos/log';\nimport { createProtoRpcPeer, type ProtoRpcPeer, type ProtoRpcPeerOptions } from '@dxos/rpc';\n\nexport type ConnectionInfo = {\n  request: IncomingMessage;\n};\n\nexport type ConnectionHandler<C, S> = {\n  onOpen?: (rpc: ProtoRpcPeer<C>) => Promise<void>;\n  onClose?: (rpc: ProtoRpcPeer<C>) => Promise<void>;\n} & Pick<ProtoRpcPeerOptions<C, S>, 'requested' | 'exposed' | 'handlers'>;\n\nexport type WebsocketRpcServerParams<C, S> = {\n  onConnection: (info: ConnectionInfo) => Promise<ConnectionHandler<C, S>>;\n} & WebSocket.ServerOptions;\n\nexport class WebsocketRpcServer<C, S> {\n  private _server?: WebSocket.Server;\n\n  constructor(private readonly _params: WebsocketRpcServerParams<C, S>) {}\n  handleUpgrade(request: IncomingMessage, socket: Socket, head: Buffer): void {\n    this._server?.handleUpgrade(request, socket, head, (ws) => {\n      this._server?.emit('connection', ws, request);\n    });\n  }\n\n  async open(): Promise<void> {\n    this._server = new WebSocket.Server({\n      ...this._params,\n    });\n    this._server.on('connection', async (socket, request) => {\n      log('connection', { url: request.url, headers: request.headers });\n      const info: ConnectionInfo = {\n        request,\n      };\n      const { onOpen, onClose, ...options } = await this._params.onConnection(info);\n      const rpc = createProtoRpcPeer<C, S>({\n        ...options,\n        port: {\n          send: (msg) => {\n            socket.send(msg);\n          },\n          subscribe: (cb) => {\n            socket.onmessage = async (msg: WebSocket.MessageEvent) => {\n              if (typeof Blob !== 'undefined' && msg.data instanceof Blob) {\n                cb(Buffer.from(await msg.data.arrayBuffer()));\n              } else {\n                cb(msg.data as any);\n              }\n            };\n          },\n        },\n      });\n\n      await rpc.open();\n      await onOpen?.(rpc);\n      socket.onclose = async () => {\n        await onClose?.(rpc);\n        await rpc.close();\n      };\n    });\n  }\n\n  async close(): Promise<void> {\n    this._server?.close();\n  }\n}\n"],
  "mappings": "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",
  "names": ["WebSocket", "Event", "Trigger", "log", "logInfo", "createProtoRpcPeer", "WebSocket", "log", "PROTOCOL_TOKEN_PREFIX", "authenticateRequestWithTokenAuth", "request", "socket", "upgradeHead", "token", "cb", "protocolHeader", "headers", "header", "write", "destroy", "tokenHeader", "replace", "RegExp", "encodedToken", "Buffer", "from", "toString", "foo", "WebSocketWithTokenAuth", "url", "wsProtocols", "WebsocketRpcClient", "_params", "_connectTrigger", "Trigger", "connected", "Event", "disconnected", "error", "_rpc", "createProtoRpcPeer", "requested", "exposed", "handlers", "noHandshake", "port", "send", "msg", "_socket", "subscribe", "cb", "onmessage", "Blob", "data", "Buffer", "from", "arrayBuffer", "url", "open", "authenticationToken", "WebSocketWithTokenAuth", "WebSocket", "onopen", "log", "emit", "wake", "err", "onclose", "close", "onerror", "event", "message", "Error", "throw", "wait", "catch", "rpc", "WebSocket", "log", "createProtoRpcPeer", "WebsocketRpcServer", "_params", "handleUpgrade", "request", "socket", "head", "_server", "ws", "emit", "open", "Server", "on", "url", "headers", "info", "onOpen", "onClose", "options", "onConnection", "rpc", "port", "send", "msg", "subscribe", "cb", "onmessage", "Blob", "data", "Buffer", "from", "arrayBuffer", "onclose", "close"]
}
