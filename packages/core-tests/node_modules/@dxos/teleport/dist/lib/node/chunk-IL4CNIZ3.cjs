"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var chunk_IL4CNIZ3_exports = {};
__export(chunk_IL4CNIZ3_exports, {
  Framer: () => Framer,
  Muxer: () => Muxer,
  Teleport: () => Teleport,
  TestBuilder: () => TestBuilder,
  TestConnection: () => TestConnection,
  TestExtension: () => TestExtension,
  TestExtensionWithStreams: () => TestExtensionWithStreams,
  TestPeer: () => TestPeer,
  decodeFrame: () => decodeFrame,
  encodeFrame: () => encodeFrame
});
module.exports = __toCommonJS(chunk_IL4CNIZ3_exports);
var import_node_stream = require("node:stream");
var import_async = require("@dxos/async");
var import_invariant = require("@dxos/invariant");
var import_keys = require("@dxos/keys");
var import_log = require("@dxos/log");
var import_async2 = require("@dxos/async");
var import_context = require("@dxos/context");
var import_debug = require("@dxos/debug");
var import_invariant2 = require("@dxos/invariant");
var import_keys2 = require("@dxos/keys");
var import_log2 = require("@dxos/log");
var import_protocols = require("@dxos/protocols");
var import_async3 = require("@dxos/async");
var import_context2 = require("@dxos/context");
var import_log3 = require("@dxos/log");
var import_protocols2 = require("@dxos/protocols");
var import_proto = require("@dxos/protocols/proto");
var import_rpc = require("@dxos/rpc");
var import_util = require("@dxos/util");
var import_node_stream2 = require("node:stream");
var import_async4 = require("@dxos/async");
var import_invariant3 = require("@dxos/invariant");
var import_log4 = require("@dxos/log");
var import_node_stream3 = require("node:stream");
var import_async5 = require("@dxos/async");
var import_context3 = require("@dxos/context");
var import_debug2 = require("@dxos/debug");
var import_invariant4 = require("@dxos/invariant");
var import_log5 = require("@dxos/log");
var import_protocols3 = require("@dxos/protocols");
var import_proto2 = require("@dxos/protocols/proto");
var import_async6 = require("@dxos/async");
var import_invariant5 = require("@dxos/invariant");
var import_log6 = require("@dxos/log");
var import_async7 = require("@dxos/async");
var import_invariant6 = require("@dxos/invariant");
var import_log7 = require("@dxos/log");
var import_proto3 = require("@dxos/protocols/proto");
var import_rpc2 = require("@dxos/rpc");
var import_node_crypto = require("node:crypto");
var import_async8 = require("@dxos/async");
var import_invariant7 = require("@dxos/invariant");
var import_log8 = require("@dxos/log");
var import_proto4 = require("@dxos/protocols/proto");
var import_rpc3 = require("@dxos/rpc");
var __create = Object.create;
var __defProp2 = Object.defineProperty;
var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames2 = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps2 = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames2(from))
      if (!__hasOwnProp2.call(to, key) && key !== except)
        __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps2(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var require_encode = __commonJS({
  "node_modules/.pnpm/varint@6.0.0/node_modules/varint/encode.js"(exports2, module2) {
    module2.exports = encode;
    var MSB = 128;
    var REST = 127;
    var MSBALL = ~REST;
    var INT = Math.pow(2, 31);
    function encode(num, out, offset) {
      if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
        encode.bytes = 0;
        throw new RangeError("Could not encode varint");
      }
      out = out || [];
      offset = offset || 0;
      var oldOffset = offset;
      while (num >= INT) {
        out[offset++] = num & 255 | MSB;
        num /= 128;
      }
      while (num & MSBALL) {
        out[offset++] = num & 255 | MSB;
        num >>>= 7;
      }
      out[offset] = num | 0;
      encode.bytes = offset - oldOffset + 1;
      return out;
    }
  }
});
var require_decode = __commonJS({
  "node_modules/.pnpm/varint@6.0.0/node_modules/varint/decode.js"(exports2, module2) {
    module2.exports = read;
    var MSB = 128;
    var REST = 127;
    function read(buf, offset) {
      var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
      do {
        if (counter >= l || shift > 49) {
          read.bytes = 0;
          throw new RangeError("Could not decode varint");
        }
        b = buf[counter++];
        res += shift < 28 ? (b & REST) << shift : (b & REST) * Math.pow(2, shift);
        shift += 7;
      } while (b >= MSB);
      read.bytes = counter - offset;
      return res;
    }
  }
});
var require_length = __commonJS({
  "node_modules/.pnpm/varint@6.0.0/node_modules/varint/length.js"(exports2, module2) {
    var N1 = Math.pow(2, 7);
    var N2 = Math.pow(2, 14);
    var N3 = Math.pow(2, 21);
    var N4 = Math.pow(2, 28);
    var N5 = Math.pow(2, 35);
    var N6 = Math.pow(2, 42);
    var N7 = Math.pow(2, 49);
    var N8 = Math.pow(2, 56);
    var N9 = Math.pow(2, 63);
    module2.exports = function(value) {
      return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
    };
  }
});
var require_varint = __commonJS({
  "node_modules/.pnpm/varint@6.0.0/node_modules/varint/index.js"(exports2, module2) {
    module2.exports = {
      encode: require_encode(),
      decode: require_decode(),
      encodingLength: require_length()
    };
  }
});
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/core/mesh/teleport/src/control-extension.ts";
var HEARTBEAT_RTT_WARN_THRESH = 1e4;
var DEBUG_PRINT_HEARTBEAT = false;
var ControlExtension = class {
  constructor(opts, localPeerId, remotePeerId) {
    this.opts = opts;
    this.localPeerId = localPeerId;
    this.remotePeerId = remotePeerId;
    this._ctx = new import_context2.Context({
      onError: (err) => {
        this._extensionContext.close(err);
      }
    }, {
      F: __dxlog_file,
      L: 31
    });
    this.onExtensionRegistered = new import_util.Callback();
  }
  async registerExtension(name) {
    await this._rpc.rpc.Control.registerExtension({
      name
    });
  }
  async onOpen(extensionContext) {
    this._extensionContext = extensionContext;
    this._rpc = (0, import_rpc.createProtoRpcPeer)({
      requested: {
        Control: import_proto.schema.getService("dxos.mesh.teleport.control.ControlService")
      },
      exposed: {
        Control: import_proto.schema.getService("dxos.mesh.teleport.control.ControlService")
      },
      handlers: {
        Control: {
          registerExtension: async (request) => {
            this.onExtensionRegistered.call(request.name);
          },
          heartbeat: async (request) => {
            if (DEBUG_PRINT_HEARTBEAT) {
              (0, import_log3.log)("received heartbeat request", {
                ts: request.requestTimestamp,
                localPeerId: this.localPeerId.truncate(),
                remotePeerId: this.remotePeerId.truncate()
              }, {
                F: __dxlog_file,
                L: 69,
                S: this,
                C: (f, a) => f(...a)
              });
            }
            return {
              requestTimestamp: request.requestTimestamp
            };
          }
        }
      },
      port: await extensionContext.createPort("rpc", {
        contentType: 'application/x-protobuf; messageType="dxos.rpc.Message"'
      }),
      timeout: this.opts.heartbeatTimeout
    });
    await this._rpc.open();
    (0, import_async3.scheduleTaskInterval)(this._ctx, async () => {
      const reqTS = /* @__PURE__ */ new Date();
      try {
        const resp = await (0, import_async3.asyncTimeout)(this._rpc.rpc.Control.heartbeat({
          requestTimestamp: reqTS
        }), this.opts.heartbeatTimeout);
        const now = Date.now();
        if (resp.requestTimestamp instanceof Date) {
          if (now - resp.requestTimestamp.getTime() > (HEARTBEAT_RTT_WARN_THRESH < this.opts.heartbeatTimeout ? HEARTBEAT_RTT_WARN_THRESH : this.opts.heartbeatTimeout / 2)) {
            import_log3.log.warn(`heartbeat RTT for Teleport > ${HEARTBEAT_RTT_WARN_THRESH / 1e3}s`, {
              rtt: now - resp.requestTimestamp.getTime(),
              localPeerId: this.localPeerId.truncate(),
              remotePeerId: this.remotePeerId.truncate()
            }, {
              F: __dxlog_file,
              L: 107,
              S: this,
              C: (f, a) => f(...a)
            });
          } else {
            if (DEBUG_PRINT_HEARTBEAT) {
              (0, import_log3.log)("heartbeat RTT", {
                rtt: now - resp.requestTimestamp.getTime(),
                localPeerId: this.localPeerId.truncate(),
                remotePeerId: this.remotePeerId.truncate()
              }, {
                F: __dxlog_file,
                L: 114,
                S: this,
                C: (f, a) => f(...a)
              });
            }
          }
        }
      } catch (err) {
        const now = Date.now();
        if (err instanceof import_protocols2.RpcClosedError) {
          (0, import_log3.log)("ignoring RpcClosedError in heartbeat", void 0, {
            F: __dxlog_file,
            L: 126,
            S: this,
            C: (f, a) => f(...a)
          });
          this._extensionContext.close(err);
          return;
        }
        if (err instanceof import_async3.TimeoutError) {
          (0, import_log3.log)("timeout waiting for heartbeat response", {
            err,
            delay: now - reqTS.getTime()
          }, {
            F: __dxlog_file,
            L: 131,
            S: this,
            C: (f, a) => f(...a)
          });
          this.opts.onTimeout(err);
        } else {
          import_log3.log.info("other error waiting for heartbeat response", {
            err,
            delay: now - reqTS.getTime()
          }, {
            F: __dxlog_file,
            L: 134,
            S: this,
            C: (f, a) => f(...a)
          });
          this.opts.onTimeout(err);
        }
      }
    }, this.opts.heartbeatInterval);
  }
  async onClose(err) {
    await this._ctx.dispose();
    await this._rpc.close();
  }
  async onAbort(err) {
    await this._ctx.dispose();
    await this._rpc.abort();
  }
};
var __dxlog_file2 = "/home/runner/work/dxos/dxos/packages/core/mesh/teleport/src/muxing/framer.ts";
var FRAME_LENGTH_SIZE = 2;
var Framer = class {
  constructor() {
    this._messageCb = void 0;
    this._subscribeCb = void 0;
    this._buffer = void 0;
    this._sendCallbacks = [];
    this._bytesSent = 0;
    this._bytesReceived = 0;
    this._writable = true;
    this.drain = new import_async4.Event();
    this._stream = new import_node_stream2.Duplex({
      objectMode: false,
      read: () => {
        this._processResponseQueue();
      },
      write: (chunk, encoding, callback) => {
        (0, import_invariant3.invariant)(!this._subscribeCb, "Internal Framer bug. Concurrent writes detected.", {
          F: __dxlog_file2,
          L: 40,
          S: this,
          A: [
            "!this._subscribeCb",
            "'Internal Framer bug. Concurrent writes detected.'"
          ]
        });
        this._bytesReceived += chunk.length;
        if (this._buffer && this._buffer.length > 0) {
          this._buffer = Buffer.concat([
            this._buffer,
            chunk
          ]);
        } else {
          this._buffer = chunk;
        }
        if (this._messageCb) {
          this._popFrames();
          callback();
        } else {
          this._subscribeCb = () => {
            this._popFrames();
            this._subscribeCb = void 0;
            callback();
          };
        }
      }
    });
    this.port = {
      send: (message) => {
        return new Promise((resolve) => {
          const frame = encodeFrame(message);
          this._bytesSent += frame.length;
          this._writable = this._stream.push(frame);
          if (!this._writable) {
            this._sendCallbacks.push(resolve);
          } else {
            resolve();
          }
        });
      },
      subscribe: (callback) => {
        (0, import_invariant3.invariant)(!this._messageCb, "Rpc port already has a message listener.", {
          F: __dxlog_file2,
          L: 79,
          S: this,
          A: [
            "!this._messageCb",
            "'Rpc port already has a message listener.'"
          ]
        });
        this._messageCb = callback;
        this._subscribeCb?.();
        return () => {
          this._messageCb = void 0;
        };
      }
    };
  }
  get stream() {
    return this._stream;
  }
  get bytesSent() {
    return this._bytesSent;
  }
  get bytesReceived() {
    return this._bytesReceived;
  }
  get writable() {
    return this._writable;
  }
  _processResponseQueue() {
    const responseQueue = this._sendCallbacks;
    this._sendCallbacks = [];
    this._writable = true;
    this.drain.emit();
    responseQueue.forEach((cb) => cb());
  }
  /**
  * Attempts to pop frames from the buffer and call the message callback.
  */
  _popFrames() {
    let offset = 0;
    while (offset < this._buffer.length) {
      const frame = decodeFrame(this._buffer, offset);
      if (!frame) {
        break;
      }
      offset += frame.bytesConsumed;
      this._messageCb(frame.payload);
    }
    if (offset < this._buffer.length) {
      this._buffer = this._buffer.subarray(offset);
    } else {
      this._buffer = void 0;
    }
  }
  destroy() {
    if (this._stream.readableLength > 0) {
      (0, import_log4.log)("framer destroyed while there are still read bytes in the buffer.", void 0, {
        F: __dxlog_file2,
        L: 140,
        S: this,
        C: (f, a) => f(...a)
      });
    }
    if (this._stream.writableLength > 0) {
      import_log4.log.warn("framer destroyed while there are still write bytes in the buffer.", void 0, {
        F: __dxlog_file2,
        L: 143,
        S: this,
        C: (f, a) => f(...a)
      });
    }
    this._stream.destroy();
  }
};
var decodeFrame = (buffer, offset) => {
  if (buffer.length < offset + FRAME_LENGTH_SIZE) {
    return void 0;
  }
  const frameLength = buffer.readUInt16BE(offset);
  const bytesConsumed = FRAME_LENGTH_SIZE + frameLength;
  if (buffer.length < offset + bytesConsumed) {
    return void 0;
  }
  const payload = buffer.subarray(offset + FRAME_LENGTH_SIZE, offset + bytesConsumed);
  return {
    payload,
    bytesConsumed
  };
};
var encodeFrame = (payload) => {
  const frame = Buffer.allocUnsafe(FRAME_LENGTH_SIZE + payload.length);
  frame.writeUInt16BE(payload.length, 0);
  frame.set(payload, FRAME_LENGTH_SIZE);
  return frame;
};
var import_varint = __toESM(require_varint(), 1);
var __dxlog_file3 = "/home/runner/work/dxos/dxos/packages/core/mesh/teleport/src/muxing/balancer.ts";
var MAX_CHUNK_SIZE = 8192;
var Balancer = class {
  constructor(_sysChannelId) {
    this._sysChannelId = _sysChannelId;
    this._lastCallerIndex = 0;
    this._channels = [];
    this._framer = new Framer();
    this._sendBuffers = /* @__PURE__ */ new Map();
    this._receiveBuffers = /* @__PURE__ */ new Map();
    this._sending = false;
    this.incomingData = new import_async6.Event();
    this.stream = this._framer.stream;
    this._channels.push(_sysChannelId);
    this._framer.port.subscribe(this._processIncomingMessage.bind(this));
  }
  get bytesSent() {
    return this._framer.bytesSent;
  }
  get bytesReceived() {
    return this._framer.bytesReceived;
  }
  get buffersCount() {
    return this._sendBuffers.size;
  }
  addChannel(channel) {
    this._channels.push(channel);
  }
  pushData(data, trigger, channelId) {
    this._enqueueChunk(data, trigger, channelId);
    this._sendChunks().catch((err) => import_log6.log.catch(err, void 0, {
      F: __dxlog_file3,
      L: 75,
      S: this,
      C: (f, a) => f(...a)
    }));
  }
  destroy() {
    if (this._sendBuffers.size !== 0) {
      import_log6.log.info("destroying balancer with pending calls", void 0, {
        F: __dxlog_file3,
        L: 80,
        S: this,
        C: (f, a) => f(...a)
      });
    }
    this._sendBuffers.clear();
    this._framer.destroy();
  }
  _processIncomingMessage(msg) {
    const { channelId, dataLength, chunk } = decodeChunk(msg, (channelId2) => !this._receiveBuffers.has(channelId2));
    if (!this._receiveBuffers.has(channelId)) {
      if (chunk.length < dataLength) {
        this._receiveBuffers.set(channelId, {
          buffer: Buffer.from(chunk),
          msgLength: dataLength
        });
      } else {
        this.incomingData.emit(chunk);
      }
    } else {
      const channelBuffer = this._receiveBuffers.get(channelId);
      channelBuffer.buffer = Buffer.concat([
        channelBuffer.buffer,
        chunk
      ]);
      if (channelBuffer.buffer.length < channelBuffer.msgLength) {
        return;
      }
      const msg2 = channelBuffer.buffer;
      this._receiveBuffers.delete(channelId);
      this.incomingData.emit(msg2);
    }
  }
  _getNextCallerId() {
    if (this._sendBuffers.has(this._sysChannelId)) {
      return this._sysChannelId;
    }
    const index = this._lastCallerIndex;
    this._lastCallerIndex = (this._lastCallerIndex + 1) % this._channels.length;
    return this._channels[index];
  }
  _enqueueChunk(data, trigger, channelId) {
    if (!this._channels.includes(channelId)) {
      throw new Error(`Unknown channel ${channelId}`);
    }
    if (!this._sendBuffers.has(channelId)) {
      this._sendBuffers.set(channelId, []);
    }
    const sendBuffer = this._sendBuffers.get(channelId);
    const chunks = [];
    for (let idx = 0; idx < data.length; idx += MAX_CHUNK_SIZE) {
      chunks.push(data.subarray(idx, idx + MAX_CHUNK_SIZE));
    }
    chunks.forEach((chunk, index) => {
      const msg = encodeChunk({
        chunk,
        channelId,
        dataLength: index === 0 ? data.length : void 0
      });
      sendBuffer.push({
        msg,
        trigger: index === chunks.length - 1 ? trigger : void 0
      });
    });
  }
  // get the next chunk or null if there are no chunks remaining
  _getNextChunk() {
    let chunk;
    while (this._sendBuffers.size > 0) {
      const channelId = this._getNextCallerId();
      const sendBuffer = this._sendBuffers.get(channelId);
      if (!sendBuffer) {
        continue;
      }
      chunk = sendBuffer.shift();
      if (!chunk) {
        continue;
      }
      if (sendBuffer.length === 0) {
        this._sendBuffers.delete(channelId);
      }
      return chunk;
    }
    return null;
  }
  async _sendChunks() {
    if (this._sending) {
      return;
    }
    this._sending = true;
    let chunk;
    chunk = this._getNextChunk();
    while (chunk) {
      if (!this._framer.writable) {
        (0, import_log6.log)("PAUSE for drain", void 0, {
          F: __dxlog_file3,
          L: 179,
          S: this,
          C: (f, a) => f(...a)
        });
        await this._framer.drain.waitForCount(1);
        (0, import_log6.log)("RESUME for drain", void 0, {
          F: __dxlog_file3,
          L: 181,
          S: this,
          C: (f, a) => f(...a)
        });
      }
      try {
        await this._framer.port.send(chunk.msg);
        chunk.trigger?.wake();
      } catch (err) {
        (0, import_log6.log)("Error sending chunk", {
          err
        }, {
          F: __dxlog_file3,
          L: 187,
          S: this,
          C: (f, a) => f(...a)
        });
        chunk.trigger?.throw(err);
      }
      chunk = this._getNextChunk();
    }
    (0, import_invariant5.invariant)(this._sendBuffers.size === 0, "sendBuffers not empty", {
      F: __dxlog_file3,
      L: 192,
      S: this,
      A: [
        "this._sendBuffers.size === 0",
        "'sendBuffers not empty'"
      ]
    });
    this._sending = false;
  }
};
var encodeChunk = ({ channelId, dataLength, chunk }) => {
  const channelTagLength = import_varint.default.encodingLength(channelId);
  const dataLengthLength = dataLength ? import_varint.default.encodingLength(dataLength) : 0;
  const message = Buffer.allocUnsafe(channelTagLength + dataLengthLength + chunk.length);
  import_varint.default.encode(channelId, message);
  if (dataLength) {
    import_varint.default.encode(dataLength, message, channelTagLength);
  }
  message.set(chunk, channelTagLength + dataLengthLength);
  return message;
};
var decodeChunk = (data, withLength) => {
  const channelId = import_varint.default.decode(data);
  let dataLength;
  let offset = import_varint.default.decode.bytes;
  if (withLength(channelId)) {
    dataLength = import_varint.default.decode(data, offset);
    offset += import_varint.default.decode.bytes;
  }
  const chunk = data.subarray(offset);
  return {
    channelId,
    dataLength,
    chunk
  };
};
function _ts_decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file4 = "/home/runner/work/dxos/dxos/packages/core/mesh/teleport/src/muxing/muxer.ts";
var Command = import_proto2.schema.getCodecForType("dxos.mesh.muxer.Command");
var DEFAULT_SEND_COMMAND_TIMEOUT = 6e4;
var DESTROY_COMMAND_SEND_TIMEOUT = 5e3;
var STATS_INTERVAL = 1e3;
var MAX_SAFE_FRAME_SIZE = 1e6;
var SYSTEM_CHANNEL_ID = 0;
var GRACEFUL_CLOSE_TIMEOUT = 3e3;
var Muxer = class {
  constructor() {
    this._balancer = new Balancer(SYSTEM_CHANNEL_ID);
    this._channelsByLocalId = /* @__PURE__ */ new Map();
    this._channelsByTag = /* @__PURE__ */ new Map();
    this._ctx = new import_context3.Context(void 0, {
      F: __dxlog_file4,
      L: 108
    });
    this._nextId = 1;
    this._closing = false;
    this._destroying = false;
    this._disposed = false;
    this._lastStats = void 0;
    this._lastChannelStats = /* @__PURE__ */ new Map();
    this.afterClosed = new import_async5.Event();
    this.statsUpdated = new import_async5.Event();
    this.stream = this._balancer.stream;
    this._balancer.incomingData.on(async (msg) => {
      await this._handleCommand(Command.decode(msg));
    });
  }
  setSessionId(sessionId) {
    this._sessionId = sessionId;
  }
  get sessionIdString() {
    return this._sessionId ? this._sessionId.truncate() : "none";
  }
  /**
  * Creates a duplex Node.js-style stream.
  * The remote peer is expected to call `createStream` with the same tag.
  * The stream is immediately readable and writable.
  * NOTE: The data will be buffered until the stream is opened remotely with the same tag (may cause a memory leak).
  */
  async createStream(tag, opts = {}) {
    const channel = this._getOrCreateStream({
      tag,
      contentType: opts.contentType
    });
    (0, import_invariant4.invariant)(!channel.push, `Channel already open: ${tag}`, {
      F: __dxlog_file4,
      L: 152,
      S: this,
      A: [
        "!channel.push",
        "`Channel already open: ${tag}`"
      ]
    });
    const stream = new import_node_stream3.Duplex({
      write: (data, encoding, callback) => {
        this._sendData(channel, data).then(() => callback()).catch(callback);
      },
      read: () => {
      }
    });
    channel.push = (data) => {
      channel.stats.bytesReceived += data.length;
      stream.push(data);
    };
    channel.destroy = (err) => {
      if (err) {
        if (stream.listeners("error").length > 0) {
          stream.destroy(err);
        } else {
          stream.destroy();
        }
      } else {
        stream.destroy();
      }
    };
    try {
      await this._sendCommand({
        openChannel: {
          id: channel.id,
          tag: channel.tag,
          contentType: channel.contentType
        }
      }, SYSTEM_CHANNEL_ID);
    } catch (err) {
      this._destroyChannel(channel, err);
      throw err;
    }
    return stream;
  }
  /**
  * Creates an RPC port.
  * The remote peer is expected to call `createPort` with the same tag.
  * The port is immediately usable.
  * NOTE: The data will be buffered until the stream is opened remotely with the same tag (may cause a memory leak).
  */
  async createPort(tag, opts = {}) {
    const channel = this._getOrCreateStream({
      tag,
      contentType: opts.contentType
    });
    (0, import_invariant4.invariant)(!channel.push, `Channel already open: ${tag}`, {
      F: __dxlog_file4,
      L: 212,
      S: this,
      A: [
        "!channel.push",
        "`Channel already open: ${tag}`"
      ]
    });
    let inboundBuffer = [];
    let callback;
    channel.push = (data) => {
      channel.stats.bytesReceived += data.length;
      if (callback) {
        callback(data);
      } else {
        inboundBuffer.push(data);
      }
    };
    const port = {
      send: async (data, timeout) => {
        await this._sendData(channel, data, timeout);
      },
      subscribe: (cb) => {
        (0, import_invariant4.invariant)(!callback, "Only one subscriber is allowed", {
          F: __dxlog_file4,
          L: 234,
          S: this,
          A: [
            "!callback",
            "'Only one subscriber is allowed'"
          ]
        });
        callback = cb;
        for (const data of inboundBuffer) {
          cb(data);
        }
        inboundBuffer = [];
      }
    };
    try {
      await this._sendCommand({
        openChannel: {
          id: channel.id,
          tag: channel.tag,
          contentType: channel.contentType
        }
      }, SYSTEM_CHANNEL_ID);
    } catch (err) {
      this._destroyChannel(channel, err);
      throw err;
    }
    return port;
  }
  // initiate graceful close
  async close(err) {
    if (this._destroying) {
      (0, import_log5.log)("already destroying, ignoring graceful close request", void 0, {
        F: __dxlog_file4,
        L: 267,
        S: this,
        C: (f, a) => f(...a)
      });
      return;
    }
    if (this._closing) {
      (0, import_log5.log)("already closing, ignoring graceful close request", void 0, {
        F: __dxlog_file4,
        L: 271,
        S: this,
        C: (f, a) => f(...a)
      });
      return;
    }
    this._closing = true;
    await this._sendCommand({
      close: {
        error: err?.message
      }
    }, SYSTEM_CHANNEL_ID, DESTROY_COMMAND_SEND_TIMEOUT).catch(async (err2) => {
      (0, import_log5.log)("error sending close command", {
        err: err2
      }, {
        F: __dxlog_file4,
        L: 286,
        S: this,
        C: (f, a) => f(...a)
      });
      await this._dispose(err2);
    });
    await (0, import_async5.asyncTimeout)(this._dispose(err), GRACEFUL_CLOSE_TIMEOUT, new import_protocols3.TimeoutError("gracefully closing muxer"));
  }
  // force close without confirmation
  async destroy(err) {
    if (this._destroying) {
      (0, import_log5.log)("already destroying, ignoring destroy request", void 0, {
        F: __dxlog_file4,
        L: 299,
        S: this,
        C: (f, a) => f(...a)
      });
      return;
    }
    this._destroying = true;
    void this._ctx.dispose();
    if (this._closing) {
      (0, import_log5.log)("destroy cancelling graceful close", void 0, {
        F: __dxlog_file4,
        L: 305,
        S: this,
        C: (f, a) => f(...a)
      });
      this._closing = false;
    } else {
      await this._sendCommand({
        close: {
          error: err?.message
        }
      }, SYSTEM_CHANNEL_ID).catch(async (err2) => {
        (0, import_log5.log)("error sending courtesy close command", {
          err: err2
        }, {
          F: __dxlog_file4,
          L: 318,
          S: this,
          C: (f, a) => f(...a)
        });
      });
    }
    this._dispose(err).catch((err2) => {
      (0, import_log5.log)("error disposing after destroy", {
        err: err2
      }, {
        F: __dxlog_file4,
        L: 323,
        S: this,
        C: (f, a) => f(...a)
      });
    });
  }
  // complete the termination, graceful or otherwise
  async _dispose(err) {
    if (this._disposed) {
      (0, import_log5.log)("already destroyed, ignoring dispose request", void 0, {
        F: __dxlog_file4,
        L: 331,
        S: this,
        C: (f, a) => f(...a)
      });
      return;
    }
    void this._ctx.dispose();
    await this._balancer.destroy();
    for (const channel of this._channelsByTag.values()) {
      channel.destroy?.(err);
    }
    this._disposed = true;
    await this._emitStats();
    this.afterClosed.emit(err);
    this._channelsByLocalId.clear();
    this._channelsByTag.clear();
  }
  async _handleCommand(cmd) {
    if (this._disposed) {
      import_log5.log.warn("Received command after disposed", {
        cmd
      }, {
        F: __dxlog_file4,
        L: 354,
        S: this,
        C: (f, a) => f(...a)
      });
      return;
    }
    if (cmd.close) {
      if (!this._closing) {
        (0, import_log5.log)("received peer close, initiating my own graceful close", void 0, {
          F: __dxlog_file4,
          L: 360,
          S: this,
          C: (f, a) => f(...a)
        });
        await this.close(new Error("received peer close"));
      } else {
        (0, import_log5.log)("received close from peer, already closing", void 0, {
          F: __dxlog_file4,
          L: 363,
          S: this,
          C: (f, a) => f(...a)
        });
      }
      return;
    }
    if (cmd.openChannel) {
      const channel = this._getOrCreateStream({
        tag: cmd.openChannel.tag,
        contentType: cmd.openChannel.contentType
      });
      channel.remoteId = cmd.openChannel.id;
      for (const data of channel.buffer) {
        await this._sendCommand({
          data: {
            channelId: channel.remoteId,
            data
          }
        }, channel.id);
      }
      channel.buffer = [];
    } else if (cmd.data) {
      const stream = this._channelsByLocalId.get(cmd.data.channelId) ?? (0, import_debug2.failUndefined)();
      if (!stream.push) {
        import_log5.log.warn("Received data for channel before it was opened", {
          tag: stream.tag
        }, {
          F: __dxlog_file4,
          L: 392,
          S: this,
          C: (f, a) => f(...a)
        });
        return;
      }
      stream.push(cmd.data.data);
    }
  }
  async _sendCommand(cmd, channelId = -1, timeout = DEFAULT_SEND_COMMAND_TIMEOUT) {
    if (this._disposed) {
      return;
    }
    try {
      const trigger = new import_async5.Trigger();
      this._balancer.pushData(Command.encode(cmd), trigger, channelId);
      await trigger.wait({
        timeout
      });
    } catch (err) {
      await this.destroy(err);
    }
  }
  _getOrCreateStream(params) {
    if (this._channelsByTag.size === 0) {
      (0, import_async5.scheduleTaskInterval)(this._ctx, async () => this._emitStats(), STATS_INTERVAL);
    }
    let channel = this._channelsByTag.get(params.tag);
    if (!channel) {
      channel = {
        id: this._nextId++,
        remoteId: null,
        tag: params.tag,
        contentType: params.contentType,
        buffer: [],
        push: null,
        destroy: null,
        stats: {
          bytesSent: 0,
          bytesReceived: 0
        }
      };
      this._channelsByTag.set(channel.tag, channel);
      this._channelsByLocalId.set(channel.id, channel);
      this._balancer.addChannel(channel.id);
    }
    return channel;
  }
  async _sendData(channel, data, timeout) {
    if (data.length > MAX_SAFE_FRAME_SIZE) {
      import_log5.log.warn("frame size exceeds maximum safe value", {
        size: data.length,
        threshold: MAX_SAFE_FRAME_SIZE
      }, {
        F: __dxlog_file4,
        L: 442,
        S: this,
        C: (f, a) => f(...a)
      });
    }
    channel.stats.bytesSent += data.length;
    if (channel.remoteId === null) {
      channel.buffer.push(data);
      return;
    }
    await this._sendCommand({
      data: {
        channelId: channel.remoteId,
        data
      }
    }, channel.id, timeout);
  }
  _destroyChannel(channel, err) {
    if (err) {
      import_log5.log.warn("destroying channel with error", {
        err
      }, {
        F: __dxlog_file4,
        L: 465,
        S: this,
        C: (f, a) => f(...a)
      });
    }
    if (channel.destroy) {
      channel.destroy(err);
    }
    this._channelsByLocalId.delete(channel.id);
    this._channelsByTag.delete(channel.tag);
  }
  async _emitStats() {
    if (this._disposed || this._destroying) {
      if (!this._lastStats) {
        return;
      }
      const lastStats = this._lastStats;
      this._lastStats = void 0;
      lastStats.readBufferSize = 0;
      lastStats.writeBufferSize = 0;
      for (const c of lastStats.channels) {
        c.writeBufferSize = 0;
      }
      this.statsUpdated.emit(lastStats);
      this._lastChannelStats.clear();
      return;
    }
    const bytesSent = this._balancer.bytesSent;
    const bytesReceived = this._balancer.bytesReceived;
    const now = Date.now();
    const interval = this._lastStats ? (now - this._lastStats.timestamp) / 1e3 : 0;
    const calculateThroughput = (current, last) => last ? {
      bytesSentRate: interval ? (current.bytesSent - last.bytesSent) / interval : void 0,
      bytesReceivedRate: interval ? (current.bytesReceived - last.bytesReceived) / interval : void 0
    } : {};
    this._lastStats = {
      timestamp: now,
      channels: Array.from(this._channelsByTag.values()).map((channel) => {
        const stats = {
          id: channel.id,
          tag: channel.tag,
          contentType: channel.contentType,
          writeBufferSize: channel.buffer.length,
          bytesSent: channel.stats.bytesSent,
          bytesReceived: channel.stats.bytesReceived,
          ...calculateThroughput(channel.stats, this._lastChannelStats.get(channel.id))
        };
        this._lastChannelStats.set(channel.id, stats);
        return stats;
      }),
      bytesSent,
      bytesReceived,
      ...calculateThroughput({
        bytesSent,
        bytesReceived
      }, this._lastStats),
      readBufferSize: this._balancer.stream.readableLength,
      writeBufferSize: this._balancer.stream.writableLength
    };
    this.statsUpdated.emit(this._lastStats);
  }
};
_ts_decorate([
  import_log5.logInfo
], Muxer.prototype, "sessionIdString", null);
function _ts_decorate2(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file5 = "/home/runner/work/dxos/dxos/packages/core/mesh/teleport/src/teleport.ts";
var CONTROL_HEARTBEAT_INTERVAL = 1e4;
var CONTROL_HEARTBEAT_TIMEOUT = 6e4;
var Teleport = class {
  constructor({ initiator, localPeerId, remotePeerId, ...rest }) {
    this._ctx = new import_context.Context({
      onError: (err) => {
        import_log2.log.info("error in teleport context", {
          err
        }, {
          F: __dxlog_file5,
          L: 40,
          S: this,
          C: (f, a) => f(...a)
        });
        void this.destroy(err).catch(() => {
          import_log2.log.error("Error during destroy", err, {
            F: __dxlog_file5,
            L: 42,
            S: this,
            C: (f, a) => f(...a)
          });
        });
      }
    }, {
      F: __dxlog_file5,
      L: 38
    });
    this._muxer = new Muxer();
    this._extensions = /* @__PURE__ */ new Map();
    this._remoteExtensions = /* @__PURE__ */ new Set();
    this._open = false;
    this._destroying = false;
    this._aborting = false;
    (0, import_invariant2.invariant)(typeof initiator === "boolean", void 0, {
      F: __dxlog_file5,
      L: 63,
      S: this,
      A: [
        "typeof initiator === 'boolean'",
        ""
      ]
    });
    (0, import_invariant2.invariant)(import_keys2.PublicKey.isPublicKey(localPeerId), void 0, {
      F: __dxlog_file5,
      L: 64,
      S: this,
      A: [
        "PublicKey.isPublicKey(localPeerId)",
        ""
      ]
    });
    (0, import_invariant2.invariant)(import_keys2.PublicKey.isPublicKey(remotePeerId), void 0, {
      F: __dxlog_file5,
      L: 65,
      S: this,
      A: [
        "PublicKey.isPublicKey(remotePeerId)",
        ""
      ]
    });
    this.initiator = initiator;
    this.localPeerId = localPeerId;
    this.remotePeerId = remotePeerId;
    this._control = new ControlExtension({
      heartbeatInterval: rest.controlHeartbeatInterval ?? CONTROL_HEARTBEAT_INTERVAL,
      heartbeatTimeout: rest.controlHeartbeatTimeout ?? CONTROL_HEARTBEAT_TIMEOUT,
      onTimeout: () => {
        if (this._destroying || this._aborting) {
          return;
        }
        import_log2.log.info("abort teleport due to onTimeout in ControlExtension", void 0, {
          F: __dxlog_file5,
          L: 78,
          S: this,
          C: (f, a) => f(...a)
        });
        this.abort(new import_protocols.TimeoutError("control extension")).catch((err) => import_log2.log.catch(err, void 0, {
          F: __dxlog_file5,
          L: 79,
          S: this,
          C: (f, a) => f(...a)
        }));
      }
    }, this.localPeerId, this.remotePeerId);
    this._control.onExtensionRegistered.set(async (name) => {
      (0, import_log2.log)("remote extension", {
        name
      }, {
        F: __dxlog_file5,
        L: 87,
        S: this,
        C: (f, a) => f(...a)
      });
      (0, import_invariant2.invariant)(!this._remoteExtensions.has(name), "Remote extension already exists", {
        F: __dxlog_file5,
        L: 88,
        S: this,
        A: [
          "!this._remoteExtensions.has(name)",
          "'Remote extension already exists'"
        ]
      });
      this._remoteExtensions.add(name);
      if (this._extensions.has(name)) {
        try {
          await this._openExtension(name);
        } catch (err) {
          await this.destroy(err);
        }
      }
    });
    {
      this._muxer.stream.on("close", async () => {
        if (this._destroying || this._aborting) {
          (0, import_log2.log)("destroy teleport due to muxer stream close, skipping due to already destroying/aborting", void 0, {
            F: __dxlog_file5,
            L: 104,
            S: this,
            C: (f, a) => f(...a)
          });
          return;
        }
        await this.destroy();
      });
      this._muxer.stream.on("error", async (err) => {
        await this.destroy(err);
      });
    }
    this._muxer.statsUpdated.on((stats) => {
      import_log2.log.trace("dxos.mesh.teleport.stats", {
        localPeerId,
        remotePeerId,
        bytesSent: stats.bytesSent,
        bytesSentRate: stats.bytesSentRate,
        bytesReceived: stats.bytesReceived,
        bytesReceivedRate: stats.bytesReceivedRate,
        channels: stats.channels
      }, {
        F: __dxlog_file5,
        L: 117,
        S: this,
        C: (f, a) => f(...a)
      });
    });
  }
  get isOpen() {
    return this._open;
  }
  get sessionIdString() {
    return this._sessionId ? this._sessionId.truncate() : "none";
  }
  get stream() {
    return this._muxer.stream;
  }
  get stats() {
    return this._muxer.statsUpdated;
  }
  /**
  * Blocks until the handshake is complete.
  */
  async open(sessionId = import_keys2.PublicKey.random()) {
    this._sessionId = sessionId;
    (0, import_log2.log)("open", void 0, {
      F: __dxlog_file5,
      L: 151,
      S: this,
      C: (f, a) => f(...a)
    });
    this._setExtension("dxos.mesh.teleport.control", this._control);
    await this._openExtension("dxos.mesh.teleport.control");
    this._open = true;
    this._muxer.setSessionId(sessionId);
  }
  async close(err) {
    await this.destroy(err);
  }
  async abort(err) {
    if (this._aborting || this._destroying) {
      return;
    }
    this._aborting = true;
    this._open = false;
    if (this._ctx.disposed) {
      return;
    }
    await this._ctx.dispose();
    for (const extension of this._extensions.values()) {
      try {
        await extension.onAbort(err);
      } catch (err2) {
        import_log2.log.catch(err2, void 0, {
          F: __dxlog_file5,
          L: 181,
          S: this,
          C: (f, a) => f(...a)
        });
      }
    }
    await this._muxer.destroy(err);
  }
  async destroy(err) {
    if (this._destroying || this._aborting) {
      return;
    }
    (0, import_log2.log)("destroying teleport...", {
      extensionsCount: this._extensions.size
    }, {
      F: __dxlog_file5,
      L: 194,
      S: this,
      C: (f, a) => f(...a)
    });
    this._destroying = true;
    this._open = false;
    if (this._ctx.disposed) {
      return;
    }
    await this._ctx.dispose();
    for (const extension of this._extensions.values()) {
      try {
        (0, import_log2.log)("destroying extension", {
          name: extension.constructor.name
        }, {
          F: __dxlog_file5,
          L: 206,
          S: this,
          C: (f, a) => f(...a)
        });
        await extension.onClose(err);
        (0, import_log2.log)("destroyed extension", {
          name: extension.constructor.name
        }, {
          F: __dxlog_file5,
          L: 208,
          S: this,
          C: (f, a) => f(...a)
        });
      } catch (err2) {
        import_log2.log.catch(err2, void 0, {
          F: __dxlog_file5,
          L: 210,
          S: this,
          C: (f, a) => f(...a)
        });
      }
    }
    await this._muxer.close();
    (0, import_log2.log)("teleport destroyed", void 0, {
      F: __dxlog_file5,
      L: 215,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  addExtension(name, extension) {
    if (!this._open) {
      throw new Error("Not open");
    }
    (0, import_log2.log)("addExtension", {
      name
    }, {
      F: __dxlog_file5,
      L: 223,
      S: this,
      C: (f, a) => f(...a)
    });
    this._setExtension(name, extension);
    (0, import_async2.scheduleTask)(this._ctx, async () => {
      try {
        await this._control.registerExtension(name);
      } catch (err) {
        if (err instanceof import_protocols.RpcClosedError) {
          return;
        }
        throw err;
      }
    });
    if (this._remoteExtensions.has(name)) {
      (0, import_async2.scheduleTask)(this._ctx, async () => {
        await this._openExtension(name);
      });
    }
  }
  _setExtension(extensionName, extension) {
    (0, import_invariant2.invariant)(!extensionName.includes("/"), "Invalid extension name", {
      F: __dxlog_file5,
      L: 247,
      S: this,
      A: [
        "!extensionName.includes('/')",
        "'Invalid extension name'"
      ]
    });
    (0, import_invariant2.invariant)(!this._extensions.has(extensionName), "Extension already exists", {
      F: __dxlog_file5,
      L: 248,
      S: this,
      A: [
        "!this._extensions.has(extensionName)",
        "'Extension already exists'"
      ]
    });
    this._extensions.set(extensionName, extension);
  }
  async _openExtension(extensionName) {
    (0, import_log2.log)("open extension", {
      extensionName
    }, {
      F: __dxlog_file5,
      L: 253,
      S: this,
      C: (f, a) => f(...a)
    });
    const extension = this._extensions.get(extensionName) ?? (0, import_debug.failUndefined)();
    const context = {
      initiator: this.initiator,
      localPeerId: this.localPeerId,
      remotePeerId: this.remotePeerId,
      createPort: async (channelName, opts) => {
        (0, import_invariant2.invariant)(!channelName.includes("/"), "Invalid channel name", {
          F: __dxlog_file5,
          L: 261,
          S: this,
          A: [
            "!channelName.includes('/')",
            "'Invalid channel name'"
          ]
        });
        return this._muxer.createPort(`${extensionName}/${channelName}`, opts);
      },
      createStream: async (channelName, opts) => {
        (0, import_invariant2.invariant)(!channelName.includes("/"), "Invalid channel name", {
          F: __dxlog_file5,
          L: 265,
          S: this,
          A: [
            "!channelName.includes('/')",
            "'Invalid channel name'"
          ]
        });
        return this._muxer.createStream(`${extensionName}/${channelName}`, opts);
      },
      close: (err) => {
        void (0, import_async2.runInContextAsync)(this._ctx, async () => {
          await this.close(err);
        });
      }
    };
    await extension.onOpen(context);
    (0, import_log2.log)("extension opened", {
      extensionName
    }, {
      F: __dxlog_file5,
      L: 276,
      S: this,
      C: (f, a) => f(...a)
    });
  }
};
_ts_decorate2([
  import_log2.logInfo
], Teleport.prototype, "sessionIdString", null);
_ts_decorate2([
  import_async2.synchronized
], Teleport.prototype, "abort", null);
_ts_decorate2([
  import_async2.synchronized
], Teleport.prototype, "destroy", null);
var __dxlog_file6 = "/home/runner/work/dxos/dxos/packages/core/mesh/teleport/src/testing/test-builder.ts";
var TestBuilder = class {
  constructor() {
    this._peers = /* @__PURE__ */ new Set();
  }
  createPeer(opts) {
    const peer = opts.factory();
    this._peers.add(peer);
    return peer;
  }
  *createPeers(opts) {
    while (true) {
      yield this.createPeer(opts);
    }
  }
  async destroy() {
    await Promise.all(Array.from(this._peers).map((agent) => agent.destroy()));
  }
  async connect(peer1, peer2) {
    (0, import_invariant.invariant)(peer1 !== peer2, void 0, {
      F: __dxlog_file6,
      L: 38,
      S: this,
      A: [
        "peer1 !== peer2",
        ""
      ]
    });
    (0, import_invariant.invariant)(this._peers.has(peer1), void 0, {
      F: __dxlog_file6,
      L: 39,
      S: this,
      A: [
        "this._peers.has(peer1)",
        ""
      ]
    });
    (0, import_invariant.invariant)(this._peers.has(peer1), void 0, {
      F: __dxlog_file6,
      L: 40,
      S: this,
      A: [
        "this._peers.has(peer1)",
        ""
      ]
    });
    const connection1 = peer1.createConnection({
      initiator: true,
      remotePeerId: peer2.peerId
    });
    const connection2 = peer2.createConnection({
      initiator: false,
      remotePeerId: peer1.peerId
    });
    pipeStreams(connection1.teleport.stream, connection2.teleport.stream);
    await Promise.all([
      peer1.openConnection(connection1),
      peer2.openConnection(connection2)
    ]);
    return [
      connection1,
      connection2
    ];
  }
  async disconnect(peer1, peer2) {
    (0, import_invariant.invariant)(peer1 !== peer2, void 0, {
      F: __dxlog_file6,
      L: 52,
      S: this,
      A: [
        "peer1 !== peer2",
        ""
      ]
    });
    (0, import_invariant.invariant)(this._peers.has(peer1), void 0, {
      F: __dxlog_file6,
      L: 53,
      S: this,
      A: [
        "this._peers.has(peer1)",
        ""
      ]
    });
    (0, import_invariant.invariant)(this._peers.has(peer1), void 0, {
      F: __dxlog_file6,
      L: 54,
      S: this,
      A: [
        "this._peers.has(peer1)",
        ""
      ]
    });
    const connection1 = Array.from(peer1.connections).find((connection) => connection.remotePeerId.equals(peer2.peerId));
    const connection2 = Array.from(peer2.connections).find((connection) => connection.remotePeerId.equals(peer1.peerId));
    (0, import_invariant.invariant)(connection1, void 0, {
      F: __dxlog_file6,
      L: 63,
      S: this,
      A: [
        "connection1",
        ""
      ]
    });
    (0, import_invariant.invariant)(connection2, void 0, {
      F: __dxlog_file6,
      L: 64,
      S: this,
      A: [
        "connection2",
        ""
      ]
    });
    await Promise.all([
      peer1.closeConnection(connection1),
      peer2.closeConnection(connection2)
    ]);
  }
};
var TestPeer = class {
  constructor(peerId = import_keys.PublicKey.random()) {
    this.peerId = peerId;
    this.connections = /* @__PURE__ */ new Set();
  }
  async onOpen(connection) {
  }
  async onClose(connection) {
  }
  createConnection({ initiator, remotePeerId }) {
    const connection = new TestConnection(this.peerId, remotePeerId, initiator);
    this.connections.add(connection);
    return connection;
  }
  async openConnection(connection) {
    (0, import_invariant.invariant)(this.connections.has(connection), void 0, {
      F: __dxlog_file6,
      L: 85,
      S: this,
      A: [
        "this.connections.has(connection)",
        ""
      ]
    });
    await connection.teleport.open(import_keys.PublicKey.random());
    await this.onOpen(connection);
  }
  async closeConnection(connection) {
    (0, import_invariant.invariant)(this.connections.has(connection), void 0, {
      F: __dxlog_file6,
      L: 91,
      S: this,
      A: [
        "this.connections.has(connection)",
        ""
      ]
    });
    await this.onClose(connection);
    await connection.teleport.close();
    this.connections.delete(connection);
  }
  async destroy() {
    for (const teleport of this.connections) {
      await this.closeConnection(teleport);
    }
  }
};
var pipeStreams = (stream1, stream2) => {
  (0, import_node_stream.pipeline)(stream1, stream2, (err) => {
    if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
      import_log.log.catch(err, void 0, {
        F: __dxlog_file6,
        L: 107,
        S: void 0,
        C: (f, a) => f(...a)
      });
    }
  });
  (0, import_node_stream.pipeline)(stream2, stream1, (err) => {
    if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
      import_log.log.catch(err, void 0, {
        F: __dxlog_file6,
        L: 112,
        S: void 0,
        C: (f, a) => f(...a)
      });
    }
  });
};
var TestConnection = class {
  constructor(localPeerId, remotePeerId, initiator) {
    this.localPeerId = localPeerId;
    this.remotePeerId = remotePeerId;
    this.initiator = initiator;
    this.teleport = new Teleport({
      initiator,
      localPeerId,
      remotePeerId
    });
  }
  whenOpen(open) {
    return (0, import_async.waitForCondition)({
      condition: () => this.teleport.isOpen === open
    });
  }
};
var __dxlog_file7 = "/home/runner/work/dxos/dxos/packages/core/mesh/teleport/src/testing/test-extension.ts";
var TestExtension = class {
  constructor(callbacks = {}) {
    this.callbacks = callbacks;
    this.open = new import_async7.Trigger();
    this.closed = new import_async7.Trigger();
    this.aborted = new import_async7.Trigger();
  }
  get remotePeerId() {
    return this.extensionContext?.remotePeerId;
  }
  async onOpen(context) {
    (0, import_log7.log)("onOpen", {
      localPeerId: context.localPeerId,
      remotePeerId: context.remotePeerId
    }, {
      F: __dxlog_file7,
      L: 34,
      S: this,
      C: (f, a) => f(...a)
    });
    this.extensionContext = context;
    this._rpc = (0, import_rpc2.createProtoRpcPeer)({
      port: await context.createPort("rpc", {
        contentType: 'application/x-protobuf; messageType="dxos.rpc.Message"'
      }),
      requested: {
        TestService: import_proto3.schema.getService("example.testing.rpc.TestService")
      },
      exposed: {
        TestService: import_proto3.schema.getService("example.testing.rpc.TestService")
      },
      handlers: {
        TestService: {
          voidCall: async (request) => {
          },
          testCall: async (request) => {
            return {
              data: request.data
            };
          }
        }
      },
      timeout: 2e3
    });
    await this._rpc.open();
    await this.callbacks.onOpen?.();
    this.open.wake();
  }
  async onClose(err) {
    (0, import_log7.log)("onClose", {
      err
    }, {
      F: __dxlog_file7,
      L: 68,
      S: this,
      C: (f, a) => f(...a)
    });
    await this.callbacks.onClose?.();
    this.closed.wake();
    await this._rpc?.close();
  }
  async onAbort(err) {
    (0, import_log7.log)("onAbort", {
      err
    }, {
      F: __dxlog_file7,
      L: 75,
      S: this,
      C: (f, a) => f(...a)
    });
    await this.callbacks.onAbort?.();
    this.aborted.wake();
    await this._rpc?.abort();
  }
  async test(message = "test") {
    await this.open.wait({
      timeout: 2e3
    });
    const res = await (0, import_async7.asyncTimeout)(this._rpc.rpc.TestService.testCall({
      data: message
    }), 1500);
    (0, import_invariant6.invariant)(res.data === message, void 0, {
      F: __dxlog_file7,
      L: 84,
      S: this,
      A: [
        "res.data === message",
        ""
      ]
    });
  }
  /**
  * Force-close the connection.
  */
  async closeConnection(err) {
    this.extensionContext?.close(err);
  }
};
var __dxlog_file8 = "/home/runner/work/dxos/dxos/packages/core/mesh/teleport/src/testing/test-extension-with-streams.ts";
var TestExtensionWithStreams = class {
  constructor(callbacks = {}) {
    this.callbacks = callbacks;
    this.open = new import_async8.Trigger();
    this.closed = new import_async8.Trigger();
    this.aborted = new import_async8.Trigger();
    this._streams = /* @__PURE__ */ new Map();
  }
  get remotePeerId() {
    return this.extensionContext?.remotePeerId;
  }
  async _openStream(streamTag, interval = 5, chunkSize = 2048) {
    (0, import_invariant7.invariant)(!this._streams.has(streamTag), `Stream already exists: ${streamTag}`, {
      F: __dxlog_file8,
      L: 39,
      S: this,
      A: [
        "!this._streams.has(streamTag)",
        "`Stream already exists: ${streamTag}`"
      ]
    });
    const networkStream = await this.extensionContext.createStream(streamTag, {
      contentType: "application/x-test-stream"
    });
    const streamEntry = {
      networkStream,
      bytesSent: 0,
      bytesReceived: 0,
      sendErrors: 0,
      receiveErrors: 0,
      startTimestamp: Date.now()
    };
    const pushChunk = () => {
      streamEntry.timer = setTimeout(() => {
        const chunk = (0, import_node_crypto.randomBytes)(chunkSize);
        if (!networkStream.write(chunk, "binary", (err) => {
          if (!err) {
            streamEntry.bytesSent += chunk.length;
          } else {
            streamEntry.sendErrors += 1;
          }
        })) {
          networkStream.once("drain", pushChunk);
        } else {
          process.nextTick(pushChunk);
        }
      }, interval);
    };
    pushChunk();
    this._streams.set(streamTag, streamEntry);
    networkStream.on("data", (data) => {
      streamEntry.bytesReceived += data.length;
    });
    networkStream.on("error", (err) => {
      streamEntry.receiveErrors += 1;
    });
    networkStream.on("close", () => {
      networkStream.removeAllListeners();
    });
    streamEntry.reportingTimer = setInterval(() => {
      const { bytesSent, bytesReceived, sendErrors, receiveErrors } = streamEntry;
      import_log8.log.trace("dxos.test.stream-stats", {
        streamTag,
        bytesSent,
        bytesReceived,
        sendErrors,
        receiveErrors,
        from: this.extensionContext?.localPeerId,
        to: this.extensionContext?.remotePeerId
      }, {
        F: __dxlog_file8,
        L: 93,
        S: this,
        C: (f, a) => f(...a)
      });
    }, 100);
  }
  _closeStream(streamTag) {
    (0, import_invariant7.invariant)(this._streams.has(streamTag), `Stream does not exist: ${streamTag}`, {
      F: __dxlog_file8,
      L: 106,
      S: this,
      A: [
        "this._streams.has(streamTag)",
        "`Stream does not exist: ${streamTag}`"
      ]
    });
    const stream = this._streams.get(streamTag);
    clearTimeout(stream.timer);
    clearTimeout(stream.reportingTimer);
    const { bytesSent, bytesReceived, sendErrors, receiveErrors, startTimestamp } = stream;
    stream.networkStream.destroy();
    this._streams.delete(streamTag);
    return {
      bytesSent,
      bytesReceived,
      sendErrors,
      receiveErrors,
      runningTime: Date.now() - (startTimestamp ?? 0)
    };
  }
  async onOpen(context) {
    (0, import_log8.log)("onOpen", {
      localPeerId: context.localPeerId,
      remotePeerId: context.remotePeerId
    }, {
      F: __dxlog_file8,
      L: 128,
      S: this,
      C: (f, a) => f(...a)
    });
    this.extensionContext = context;
    this._rpc = (0, import_rpc3.createProtoRpcPeer)({
      port: await context.createPort("rpc", {
        contentType: 'application/x-protobuf; messageType="dxos.rpc.Message"'
      }),
      requested: {
        TestServiceWithStreams: import_proto4.schema.getService("example.testing.rpc.TestServiceWithStreams")
      },
      exposed: {
        TestServiceWithStreams: import_proto4.schema.getService("example.testing.rpc.TestServiceWithStreams")
      },
      handlers: {
        TestServiceWithStreams: {
          requestTestStream: async (request) => {
            const { data: streamTag, streamLoadInterval, streamLoadChunkSize } = request;
            await this._openStream(streamTag, streamLoadInterval, streamLoadChunkSize);
            return {
              data: streamTag
            };
          },
          closeTestStream: async (request) => {
            const streamTag = request.data;
            const { bytesSent, bytesReceived, sendErrors, receiveErrors, runningTime } = this._closeStream(streamTag);
            return {
              data: streamTag,
              bytesSent,
              bytesReceived,
              sendErrors,
              receiveErrors,
              runningTime
            };
          }
        }
      },
      timeout: 2e3
    });
    await this._rpc.open();
    await this.callbacks.onOpen?.();
    this.open.wake();
  }
  async onClose(err) {
    (0, import_log8.log)("onClose", {
      err
    }, {
      F: __dxlog_file8,
      L: 179,
      S: this,
      C: (f, a) => f(...a)
    });
    await this.callbacks.onClose?.();
    this.closed.wake();
    for (const [streamTag, stream] of Object.entries(this._streams)) {
      (0, import_log8.log)("closing stream", {
        streamTag
      }, {
        F: __dxlog_file8,
        L: 183,
        S: this,
        C: (f, a) => f(...a)
      });
      clearTimeout(stream.interval);
      stream.networkStream.destroy();
    }
    await this._rpc?.close();
  }
  async onAbort(err) {
    (0, import_log8.log)("onAbort", {
      err
    }, {
      F: __dxlog_file8,
      L: 191,
      S: this,
      C: (f, a) => f(...a)
    });
    await this.callbacks.onAbort?.();
    this.aborted.wake();
    await this._rpc?.abort();
  }
  async addNewStream(streamLoadInterval, streamLoadChunkSize, streamTag) {
    await this.open.wait({
      timeout: 1500
    });
    if (!streamTag) {
      streamTag = `stream-${(0, import_node_crypto.randomBytes)(4).toString("hex")}`;
    }
    const { data } = await this._rpc.rpc.TestServiceWithStreams.requestTestStream({
      data: streamTag,
      streamLoadInterval,
      streamLoadChunkSize
    });
    (0, import_invariant7.invariant)(data === streamTag, void 0, {
      F: __dxlog_file8,
      L: 207,
      S: this,
      A: [
        "data === streamTag",
        ""
      ]
    });
    await this._openStream(streamTag, streamLoadInterval, streamLoadChunkSize);
    return streamTag;
  }
  async closeStream(streamTag) {
    await this.open.wait({
      timeout: 1500
    });
    const { data, bytesSent, bytesReceived, sendErrors, receiveErrors, runningTime } = await this._rpc.rpc.TestServiceWithStreams.closeTestStream({
      data: streamTag
    });
    (0, import_invariant7.invariant)(data === streamTag, void 0, {
      F: __dxlog_file8,
      L: 220,
      S: this,
      A: [
        "data === streamTag",
        ""
      ]
    });
    const local = this._closeStream(streamTag);
    return {
      streamTag,
      stats: {
        local,
        remote: {
          bytesSent,
          bytesReceived,
          sendErrors,
          receiveErrors,
          runningTime
        }
      }
    };
  }
  /**
  * Force-close the connection.
  */
  async closeConnection(err) {
    this.extensionContext?.close(err);
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Framer,
  Muxer,
  Teleport,
  TestBuilder,
  TestConnection,
  TestExtension,
  TestExtensionWithStreams,
  TestPeer,
  decodeFrame,
  encodeFrame
});
//# sourceMappingURL=chunk-IL4CNIZ3.cjs.map
