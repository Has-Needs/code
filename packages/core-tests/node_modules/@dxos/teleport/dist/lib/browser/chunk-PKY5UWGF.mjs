import "@dxos/node-std/globals";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/.pnpm/varint@6.0.0/node_modules/varint/encode.js
var require_encode = __commonJS({
  "node_modules/.pnpm/varint@6.0.0/node_modules/varint/encode.js"(exports, module) {
    module.exports = encode;
    var MSB = 128;
    var REST = 127;
    var MSBALL = ~REST;
    var INT = Math.pow(2, 31);
    function encode(num, out, offset) {
      if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
        encode.bytes = 0;
        throw new RangeError("Could not encode varint");
      }
      out = out || [];
      offset = offset || 0;
      var oldOffset = offset;
      while (num >= INT) {
        out[offset++] = num & 255 | MSB;
        num /= 128;
      }
      while (num & MSBALL) {
        out[offset++] = num & 255 | MSB;
        num >>>= 7;
      }
      out[offset] = num | 0;
      encode.bytes = offset - oldOffset + 1;
      return out;
    }
  }
});

// node_modules/.pnpm/varint@6.0.0/node_modules/varint/decode.js
var require_decode = __commonJS({
  "node_modules/.pnpm/varint@6.0.0/node_modules/varint/decode.js"(exports, module) {
    module.exports = read;
    var MSB = 128;
    var REST = 127;
    function read(buf, offset) {
      var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
      do {
        if (counter >= l || shift > 49) {
          read.bytes = 0;
          throw new RangeError("Could not decode varint");
        }
        b = buf[counter++];
        res += shift < 28 ? (b & REST) << shift : (b & REST) * Math.pow(2, shift);
        shift += 7;
      } while (b >= MSB);
      read.bytes = counter - offset;
      return res;
    }
  }
});

// node_modules/.pnpm/varint@6.0.0/node_modules/varint/length.js
var require_length = __commonJS({
  "node_modules/.pnpm/varint@6.0.0/node_modules/varint/length.js"(exports, module) {
    var N1 = Math.pow(2, 7);
    var N2 = Math.pow(2, 14);
    var N3 = Math.pow(2, 21);
    var N4 = Math.pow(2, 28);
    var N5 = Math.pow(2, 35);
    var N6 = Math.pow(2, 42);
    var N7 = Math.pow(2, 49);
    var N8 = Math.pow(2, 56);
    var N9 = Math.pow(2, 63);
    module.exports = function(value) {
      return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
    };
  }
});

// node_modules/.pnpm/varint@6.0.0/node_modules/varint/index.js
var require_varint = __commonJS({
  "node_modules/.pnpm/varint@6.0.0/node_modules/varint/index.js"(exports, module) {
    module.exports = {
      encode: require_encode(),
      decode: require_decode(),
      encodingLength: require_length()
    };
  }
});

// packages/core/mesh/teleport/src/testing/test-builder.ts
import { pipeline } from "@dxos/node-std/stream";
import { waitForCondition } from "@dxos/async";
import { invariant as invariant5 } from "@dxos/invariant";
import { PublicKey as PublicKey2 } from "@dxos/keys";
import { log as log6 } from "@dxos/log";

// packages/core/mesh/teleport/src/teleport.ts
import { runInContextAsync, synchronized, scheduleTask } from "@dxos/async";
import { Context as Context3 } from "@dxos/context";
import { failUndefined as failUndefined2 } from "@dxos/debug";
import { invariant as invariant4 } from "@dxos/invariant";
import { PublicKey } from "@dxos/keys";
import { log as log5, logInfo as logInfo2 } from "@dxos/log";
import { RpcClosedError as RpcClosedError2, TimeoutError as TimeoutError2 } from "@dxos/protocols";

// packages/core/mesh/teleport/src/control-extension.ts
import { asyncTimeout, scheduleTaskInterval, TimeoutError as AsyncTimeoutError } from "@dxos/async";
import { Context } from "@dxos/context";
import { log } from "@dxos/log";
import { RpcClosedError } from "@dxos/protocols";
import { schema } from "@dxos/protocols/proto";
import { createProtoRpcPeer } from "@dxos/rpc";
import { Callback } from "@dxos/util";
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/core/mesh/teleport/src/control-extension.ts";
var HEARTBEAT_RTT_WARN_THRESH = 1e4;
var DEBUG_PRINT_HEARTBEAT = false;
var ControlExtension = class {
  constructor(opts, localPeerId, remotePeerId) {
    this.opts = opts;
    this.localPeerId = localPeerId;
    this.remotePeerId = remotePeerId;
    this._ctx = new Context({
      onError: (err) => {
        this._extensionContext.close(err);
      }
    }, {
      F: __dxlog_file,
      L: 31
    });
    this.onExtensionRegistered = new Callback();
  }
  async registerExtension(name) {
    await this._rpc.rpc.Control.registerExtension({
      name
    });
  }
  async onOpen(extensionContext) {
    this._extensionContext = extensionContext;
    this._rpc = createProtoRpcPeer({
      requested: {
        Control: schema.getService("dxos.mesh.teleport.control.ControlService")
      },
      exposed: {
        Control: schema.getService("dxos.mesh.teleport.control.ControlService")
      },
      handlers: {
        Control: {
          registerExtension: async (request) => {
            this.onExtensionRegistered.call(request.name);
          },
          heartbeat: async (request) => {
            if (DEBUG_PRINT_HEARTBEAT) {
              log("received heartbeat request", {
                ts: request.requestTimestamp,
                localPeerId: this.localPeerId.truncate(),
                remotePeerId: this.remotePeerId.truncate()
              }, {
                F: __dxlog_file,
                L: 69,
                S: this,
                C: (f, a) => f(...a)
              });
            }
            return {
              requestTimestamp: request.requestTimestamp
            };
          }
        }
      },
      port: await extensionContext.createPort("rpc", {
        contentType: 'application/x-protobuf; messageType="dxos.rpc.Message"'
      }),
      timeout: this.opts.heartbeatTimeout
    });
    await this._rpc.open();
    scheduleTaskInterval(this._ctx, async () => {
      const reqTS = /* @__PURE__ */ new Date();
      try {
        const resp = await asyncTimeout(this._rpc.rpc.Control.heartbeat({
          requestTimestamp: reqTS
        }), this.opts.heartbeatTimeout);
        const now = Date.now();
        if (resp.requestTimestamp instanceof Date) {
          if (now - resp.requestTimestamp.getTime() > (HEARTBEAT_RTT_WARN_THRESH < this.opts.heartbeatTimeout ? HEARTBEAT_RTT_WARN_THRESH : this.opts.heartbeatTimeout / 2)) {
            log.warn(`heartbeat RTT for Teleport > ${HEARTBEAT_RTT_WARN_THRESH / 1e3}s`, {
              rtt: now - resp.requestTimestamp.getTime(),
              localPeerId: this.localPeerId.truncate(),
              remotePeerId: this.remotePeerId.truncate()
            }, {
              F: __dxlog_file,
              L: 107,
              S: this,
              C: (f, a) => f(...a)
            });
          } else {
            if (DEBUG_PRINT_HEARTBEAT) {
              log("heartbeat RTT", {
                rtt: now - resp.requestTimestamp.getTime(),
                localPeerId: this.localPeerId.truncate(),
                remotePeerId: this.remotePeerId.truncate()
              }, {
                F: __dxlog_file,
                L: 114,
                S: this,
                C: (f, a) => f(...a)
              });
            }
          }
        }
      } catch (err) {
        const now = Date.now();
        if (err instanceof RpcClosedError) {
          log("ignoring RpcClosedError in heartbeat", void 0, {
            F: __dxlog_file,
            L: 126,
            S: this,
            C: (f, a) => f(...a)
          });
          this._extensionContext.close(err);
          return;
        }
        if (err instanceof AsyncTimeoutError) {
          log("timeout waiting for heartbeat response", {
            err,
            delay: now - reqTS.getTime()
          }, {
            F: __dxlog_file,
            L: 131,
            S: this,
            C: (f, a) => f(...a)
          });
          this.opts.onTimeout(err);
        } else {
          log.info("other error waiting for heartbeat response", {
            err,
            delay: now - reqTS.getTime()
          }, {
            F: __dxlog_file,
            L: 134,
            S: this,
            C: (f, a) => f(...a)
          });
          this.opts.onTimeout(err);
        }
      }
    }, this.opts.heartbeatInterval);
  }
  async onClose(err) {
    await this._ctx.dispose();
    await this._rpc.close();
  }
  async onAbort(err) {
    await this._ctx.dispose();
    await this._rpc.abort();
  }
};

// packages/core/mesh/teleport/src/muxing/framer.ts
import { Duplex } from "@dxos/node-std/stream";
import { Event } from "@dxos/async";
import { invariant } from "@dxos/invariant";
import { log as log2 } from "@dxos/log";
var __dxlog_file2 = "/home/runner/work/dxos/dxos/packages/core/mesh/teleport/src/muxing/framer.ts";
var FRAME_LENGTH_SIZE = 2;
var Framer = class {
  constructor() {
    // private readonly _tagBuffer = Buffer.alloc(4)
    this._messageCb = void 0;
    this._subscribeCb = void 0;
    this._buffer = void 0;
    this._sendCallbacks = [];
    this._bytesSent = 0;
    this._bytesReceived = 0;
    this._writable = true;
    this.drain = new Event();
    // TODO(egorgripasov): Consider using a Transform stream if it provides better backpressure handling.
    this._stream = new Duplex({
      objectMode: false,
      read: () => {
        this._processResponseQueue();
      },
      write: (chunk, encoding, callback) => {
        invariant(!this._subscribeCb, "Internal Framer bug. Concurrent writes detected.", {
          F: __dxlog_file2,
          L: 40,
          S: this,
          A: [
            "!this._subscribeCb",
            "'Internal Framer bug. Concurrent writes detected.'"
          ]
        });
        this._bytesReceived += chunk.length;
        if (this._buffer && this._buffer.length > 0) {
          this._buffer = Buffer.concat([
            this._buffer,
            chunk
          ]);
        } else {
          this._buffer = chunk;
        }
        if (this._messageCb) {
          this._popFrames();
          callback();
        } else {
          this._subscribeCb = () => {
            this._popFrames();
            this._subscribeCb = void 0;
            callback();
          };
        }
      }
    });
    this.port = {
      send: (message) => {
        return new Promise((resolve) => {
          const frame = encodeFrame(message);
          this._bytesSent += frame.length;
          this._writable = this._stream.push(frame);
          if (!this._writable) {
            this._sendCallbacks.push(resolve);
          } else {
            resolve();
          }
        });
      },
      subscribe: (callback) => {
        invariant(!this._messageCb, "Rpc port already has a message listener.", {
          F: __dxlog_file2,
          L: 79,
          S: this,
          A: [
            "!this._messageCb",
            "'Rpc port already has a message listener.'"
          ]
        });
        this._messageCb = callback;
        this._subscribeCb?.();
        return () => {
          this._messageCb = void 0;
        };
      }
    };
  }
  get stream() {
    return this._stream;
  }
  get bytesSent() {
    return this._bytesSent;
  }
  get bytesReceived() {
    return this._bytesReceived;
  }
  get writable() {
    return this._writable;
  }
  _processResponseQueue() {
    const responseQueue = this._sendCallbacks;
    this._sendCallbacks = [];
    this._writable = true;
    this.drain.emit();
    responseQueue.forEach((cb) => cb());
  }
  /**
  * Attempts to pop frames from the buffer and call the message callback.
  */
  _popFrames() {
    let offset = 0;
    while (offset < this._buffer.length) {
      const frame = decodeFrame(this._buffer, offset);
      if (!frame) {
        break;
      }
      offset += frame.bytesConsumed;
      this._messageCb(frame.payload);
    }
    if (offset < this._buffer.length) {
      this._buffer = this._buffer.subarray(offset);
    } else {
      this._buffer = void 0;
    }
  }
  destroy() {
    if (this._stream.readableLength > 0) {
      log2("framer destroyed while there are still read bytes in the buffer.", void 0, {
        F: __dxlog_file2,
        L: 140,
        S: this,
        C: (f, a) => f(...a)
      });
    }
    if (this._stream.writableLength > 0) {
      log2.warn("framer destroyed while there are still write bytes in the buffer.", void 0, {
        F: __dxlog_file2,
        L: 143,
        S: this,
        C: (f, a) => f(...a)
      });
    }
    this._stream.destroy();
  }
};
var decodeFrame = (buffer, offset) => {
  if (buffer.length < offset + FRAME_LENGTH_SIZE) {
    return void 0;
  }
  const frameLength = buffer.readUInt16BE(offset);
  const bytesConsumed = FRAME_LENGTH_SIZE + frameLength;
  if (buffer.length < offset + bytesConsumed) {
    return void 0;
  }
  const payload = buffer.subarray(offset + FRAME_LENGTH_SIZE, offset + bytesConsumed);
  return {
    payload,
    bytesConsumed
  };
};
var encodeFrame = (payload) => {
  const frame = Buffer.allocUnsafe(FRAME_LENGTH_SIZE + payload.length);
  frame.writeUInt16BE(payload.length, 0);
  frame.set(payload, FRAME_LENGTH_SIZE);
  return frame;
};

// packages/core/mesh/teleport/src/muxing/muxer.ts
import { Duplex as Duplex2 } from "@dxos/node-std/stream";
import { scheduleTaskInterval as scheduleTaskInterval2, Event as Event3, Trigger, asyncTimeout as asyncTimeout2 } from "@dxos/async";
import { Context as Context2 } from "@dxos/context";
import { failUndefined } from "@dxos/debug";
import { invariant as invariant3 } from "@dxos/invariant";
import { log as log4, logInfo } from "@dxos/log";
import { TimeoutError } from "@dxos/protocols";
import { schema as schema2 } from "@dxos/protocols/proto";

// packages/core/mesh/teleport/src/muxing/balancer.ts
var import_varint = __toESM(require_varint(), 1);
import { Event as Event2 } from "@dxos/async";
import { invariant as invariant2 } from "@dxos/invariant";
import { log as log3 } from "@dxos/log";
var __dxlog_file3 = "/home/runner/work/dxos/dxos/packages/core/mesh/teleport/src/muxing/balancer.ts";
var MAX_CHUNK_SIZE = 8192;
var Balancer = class {
  constructor(_sysChannelId) {
    this._sysChannelId = _sysChannelId;
    this._lastCallerIndex = 0;
    this._channels = [];
    this._framer = new Framer();
    this._sendBuffers = /* @__PURE__ */ new Map();
    this._receiveBuffers = /* @__PURE__ */ new Map();
    this._sending = false;
    this.incomingData = new Event2();
    this.stream = this._framer.stream;
    this._channels.push(_sysChannelId);
    this._framer.port.subscribe(this._processIncomingMessage.bind(this));
  }
  get bytesSent() {
    return this._framer.bytesSent;
  }
  get bytesReceived() {
    return this._framer.bytesReceived;
  }
  get buffersCount() {
    return this._sendBuffers.size;
  }
  addChannel(channel) {
    this._channels.push(channel);
  }
  pushData(data, trigger, channelId) {
    this._enqueueChunk(data, trigger, channelId);
    this._sendChunks().catch((err) => log3.catch(err, void 0, {
      F: __dxlog_file3,
      L: 75,
      S: this,
      C: (f, a) => f(...a)
    }));
  }
  destroy() {
    if (this._sendBuffers.size !== 0) {
      log3.info("destroying balancer with pending calls", void 0, {
        F: __dxlog_file3,
        L: 80,
        S: this,
        C: (f, a) => f(...a)
      });
    }
    this._sendBuffers.clear();
    this._framer.destroy();
  }
  _processIncomingMessage(msg) {
    const { channelId, dataLength, chunk } = decodeChunk(msg, (channelId2) => !this._receiveBuffers.has(channelId2));
    if (!this._receiveBuffers.has(channelId)) {
      if (chunk.length < dataLength) {
        this._receiveBuffers.set(channelId, {
          buffer: Buffer.from(chunk),
          msgLength: dataLength
        });
      } else {
        this.incomingData.emit(chunk);
      }
    } else {
      const channelBuffer = this._receiveBuffers.get(channelId);
      channelBuffer.buffer = Buffer.concat([
        channelBuffer.buffer,
        chunk
      ]);
      if (channelBuffer.buffer.length < channelBuffer.msgLength) {
        return;
      }
      const msg2 = channelBuffer.buffer;
      this._receiveBuffers.delete(channelId);
      this.incomingData.emit(msg2);
    }
  }
  _getNextCallerId() {
    if (this._sendBuffers.has(this._sysChannelId)) {
      return this._sysChannelId;
    }
    const index = this._lastCallerIndex;
    this._lastCallerIndex = (this._lastCallerIndex + 1) % this._channels.length;
    return this._channels[index];
  }
  _enqueueChunk(data, trigger, channelId) {
    if (!this._channels.includes(channelId)) {
      throw new Error(`Unknown channel ${channelId}`);
    }
    if (!this._sendBuffers.has(channelId)) {
      this._sendBuffers.set(channelId, []);
    }
    const sendBuffer = this._sendBuffers.get(channelId);
    const chunks = [];
    for (let idx = 0; idx < data.length; idx += MAX_CHUNK_SIZE) {
      chunks.push(data.subarray(idx, idx + MAX_CHUNK_SIZE));
    }
    chunks.forEach((chunk, index) => {
      const msg = encodeChunk({
        chunk,
        channelId,
        dataLength: index === 0 ? data.length : void 0
      });
      sendBuffer.push({
        msg,
        trigger: index === chunks.length - 1 ? trigger : void 0
      });
    });
  }
  // get the next chunk or null if there are no chunks remaining
  _getNextChunk() {
    let chunk;
    while (this._sendBuffers.size > 0) {
      const channelId = this._getNextCallerId();
      const sendBuffer = this._sendBuffers.get(channelId);
      if (!sendBuffer) {
        continue;
      }
      chunk = sendBuffer.shift();
      if (!chunk) {
        continue;
      }
      if (sendBuffer.length === 0) {
        this._sendBuffers.delete(channelId);
      }
      return chunk;
    }
    return null;
  }
  async _sendChunks() {
    if (this._sending) {
      return;
    }
    this._sending = true;
    let chunk;
    chunk = this._getNextChunk();
    while (chunk) {
      if (!this._framer.writable) {
        log3("PAUSE for drain", void 0, {
          F: __dxlog_file3,
          L: 179,
          S: this,
          C: (f, a) => f(...a)
        });
        await this._framer.drain.waitForCount(1);
        log3("RESUME for drain", void 0, {
          F: __dxlog_file3,
          L: 181,
          S: this,
          C: (f, a) => f(...a)
        });
      }
      try {
        await this._framer.port.send(chunk.msg);
        chunk.trigger?.wake();
      } catch (err) {
        log3("Error sending chunk", {
          err
        }, {
          F: __dxlog_file3,
          L: 187,
          S: this,
          C: (f, a) => f(...a)
        });
        chunk.trigger?.throw(err);
      }
      chunk = this._getNextChunk();
    }
    invariant2(this._sendBuffers.size === 0, "sendBuffers not empty", {
      F: __dxlog_file3,
      L: 192,
      S: this,
      A: [
        "this._sendBuffers.size === 0",
        "'sendBuffers not empty'"
      ]
    });
    this._sending = false;
  }
};
var encodeChunk = ({ channelId, dataLength, chunk }) => {
  const channelTagLength = import_varint.default.encodingLength(channelId);
  const dataLengthLength = dataLength ? import_varint.default.encodingLength(dataLength) : 0;
  const message = Buffer.allocUnsafe(channelTagLength + dataLengthLength + chunk.length);
  import_varint.default.encode(channelId, message);
  if (dataLength) {
    import_varint.default.encode(dataLength, message, channelTagLength);
  }
  message.set(chunk, channelTagLength + dataLengthLength);
  return message;
};
var decodeChunk = (data, withLength) => {
  const channelId = import_varint.default.decode(data);
  let dataLength;
  let offset = import_varint.default.decode.bytes;
  if (withLength(channelId)) {
    dataLength = import_varint.default.decode(data, offset);
    offset += import_varint.default.decode.bytes;
  }
  const chunk = data.subarray(offset);
  return {
    channelId,
    dataLength,
    chunk
  };
};

// packages/core/mesh/teleport/src/muxing/muxer.ts
function _ts_decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file4 = "/home/runner/work/dxos/dxos/packages/core/mesh/teleport/src/muxing/muxer.ts";
var Command = schema2.getCodecForType("dxos.mesh.muxer.Command");
var DEFAULT_SEND_COMMAND_TIMEOUT = 6e4;
var DESTROY_COMMAND_SEND_TIMEOUT = 5e3;
var STATS_INTERVAL = 1e3;
var MAX_SAFE_FRAME_SIZE = 1e6;
var SYSTEM_CHANNEL_ID = 0;
var GRACEFUL_CLOSE_TIMEOUT = 3e3;
var Muxer = class {
  constructor() {
    this._balancer = new Balancer(SYSTEM_CHANNEL_ID);
    this._channelsByLocalId = /* @__PURE__ */ new Map();
    this._channelsByTag = /* @__PURE__ */ new Map();
    this._ctx = new Context2(void 0, {
      F: __dxlog_file4,
      L: 108
    });
    this._nextId = 1;
    this._closing = false;
    this._destroying = false;
    this._disposed = false;
    this._lastStats = void 0;
    this._lastChannelStats = /* @__PURE__ */ new Map();
    this.afterClosed = new Event3();
    this.statsUpdated = new Event3();
    this.stream = this._balancer.stream;
    this._balancer.incomingData.on(async (msg) => {
      await this._handleCommand(Command.decode(msg));
    });
  }
  setSessionId(sessionId) {
    this._sessionId = sessionId;
  }
  get sessionIdString() {
    return this._sessionId ? this._sessionId.truncate() : "none";
  }
  /**
  * Creates a duplex Node.js-style stream.
  * The remote peer is expected to call `createStream` with the same tag.
  * The stream is immediately readable and writable.
  * NOTE: The data will be buffered until the stream is opened remotely with the same tag (may cause a memory leak).
  */
  async createStream(tag, opts = {}) {
    const channel = this._getOrCreateStream({
      tag,
      contentType: opts.contentType
    });
    invariant3(!channel.push, `Channel already open: ${tag}`, {
      F: __dxlog_file4,
      L: 152,
      S: this,
      A: [
        "!channel.push",
        "`Channel already open: ${tag}`"
      ]
    });
    const stream = new Duplex2({
      write: (data, encoding, callback) => {
        this._sendData(channel, data).then(() => callback()).catch(callback);
      },
      read: () => {
      }
    });
    channel.push = (data) => {
      channel.stats.bytesReceived += data.length;
      stream.push(data);
    };
    channel.destroy = (err) => {
      if (err) {
        if (stream.listeners("error").length > 0) {
          stream.destroy(err);
        } else {
          stream.destroy();
        }
      } else {
        stream.destroy();
      }
    };
    try {
      await this._sendCommand({
        openChannel: {
          id: channel.id,
          tag: channel.tag,
          contentType: channel.contentType
        }
      }, SYSTEM_CHANNEL_ID);
    } catch (err) {
      this._destroyChannel(channel, err);
      throw err;
    }
    return stream;
  }
  /**
  * Creates an RPC port.
  * The remote peer is expected to call `createPort` with the same tag.
  * The port is immediately usable.
  * NOTE: The data will be buffered until the stream is opened remotely with the same tag (may cause a memory leak).
  */
  async createPort(tag, opts = {}) {
    const channel = this._getOrCreateStream({
      tag,
      contentType: opts.contentType
    });
    invariant3(!channel.push, `Channel already open: ${tag}`, {
      F: __dxlog_file4,
      L: 212,
      S: this,
      A: [
        "!channel.push",
        "`Channel already open: ${tag}`"
      ]
    });
    let inboundBuffer = [];
    let callback;
    channel.push = (data) => {
      channel.stats.bytesReceived += data.length;
      if (callback) {
        callback(data);
      } else {
        inboundBuffer.push(data);
      }
    };
    const port = {
      send: async (data, timeout) => {
        await this._sendData(channel, data, timeout);
      },
      subscribe: (cb) => {
        invariant3(!callback, "Only one subscriber is allowed", {
          F: __dxlog_file4,
          L: 234,
          S: this,
          A: [
            "!callback",
            "'Only one subscriber is allowed'"
          ]
        });
        callback = cb;
        for (const data of inboundBuffer) {
          cb(data);
        }
        inboundBuffer = [];
      }
    };
    try {
      await this._sendCommand({
        openChannel: {
          id: channel.id,
          tag: channel.tag,
          contentType: channel.contentType
        }
      }, SYSTEM_CHANNEL_ID);
    } catch (err) {
      this._destroyChannel(channel, err);
      throw err;
    }
    return port;
  }
  // initiate graceful close
  async close(err) {
    if (this._destroying) {
      log4("already destroying, ignoring graceful close request", void 0, {
        F: __dxlog_file4,
        L: 267,
        S: this,
        C: (f, a) => f(...a)
      });
      return;
    }
    if (this._closing) {
      log4("already closing, ignoring graceful close request", void 0, {
        F: __dxlog_file4,
        L: 271,
        S: this,
        C: (f, a) => f(...a)
      });
      return;
    }
    this._closing = true;
    await this._sendCommand({
      close: {
        error: err?.message
      }
    }, SYSTEM_CHANNEL_ID, DESTROY_COMMAND_SEND_TIMEOUT).catch(async (err2) => {
      log4("error sending close command", {
        err: err2
      }, {
        F: __dxlog_file4,
        L: 286,
        S: this,
        C: (f, a) => f(...a)
      });
      await this._dispose(err2);
    });
    await asyncTimeout2(this._dispose(err), GRACEFUL_CLOSE_TIMEOUT, new TimeoutError("gracefully closing muxer"));
  }
  // force close without confirmation
  async destroy(err) {
    if (this._destroying) {
      log4("already destroying, ignoring destroy request", void 0, {
        F: __dxlog_file4,
        L: 299,
        S: this,
        C: (f, a) => f(...a)
      });
      return;
    }
    this._destroying = true;
    void this._ctx.dispose();
    if (this._closing) {
      log4("destroy cancelling graceful close", void 0, {
        F: __dxlog_file4,
        L: 305,
        S: this,
        C: (f, a) => f(...a)
      });
      this._closing = false;
    } else {
      await this._sendCommand({
        close: {
          error: err?.message
        }
      }, SYSTEM_CHANNEL_ID).catch(async (err2) => {
        log4("error sending courtesy close command", {
          err: err2
        }, {
          F: __dxlog_file4,
          L: 318,
          S: this,
          C: (f, a) => f(...a)
        });
      });
    }
    this._dispose(err).catch((err2) => {
      log4("error disposing after destroy", {
        err: err2
      }, {
        F: __dxlog_file4,
        L: 323,
        S: this,
        C: (f, a) => f(...a)
      });
    });
  }
  // complete the termination, graceful or otherwise
  async _dispose(err) {
    if (this._disposed) {
      log4("already destroyed, ignoring dispose request", void 0, {
        F: __dxlog_file4,
        L: 331,
        S: this,
        C: (f, a) => f(...a)
      });
      return;
    }
    void this._ctx.dispose();
    await this._balancer.destroy();
    for (const channel of this._channelsByTag.values()) {
      channel.destroy?.(err);
    }
    this._disposed = true;
    await this._emitStats();
    this.afterClosed.emit(err);
    this._channelsByLocalId.clear();
    this._channelsByTag.clear();
  }
  async _handleCommand(cmd) {
    if (this._disposed) {
      log4.warn("Received command after disposed", {
        cmd
      }, {
        F: __dxlog_file4,
        L: 354,
        S: this,
        C: (f, a) => f(...a)
      });
      return;
    }
    if (cmd.close) {
      if (!this._closing) {
        log4("received peer close, initiating my own graceful close", void 0, {
          F: __dxlog_file4,
          L: 360,
          S: this,
          C: (f, a) => f(...a)
        });
        await this.close(new Error("received peer close"));
      } else {
        log4("received close from peer, already closing", void 0, {
          F: __dxlog_file4,
          L: 363,
          S: this,
          C: (f, a) => f(...a)
        });
      }
      return;
    }
    if (cmd.openChannel) {
      const channel = this._getOrCreateStream({
        tag: cmd.openChannel.tag,
        contentType: cmd.openChannel.contentType
      });
      channel.remoteId = cmd.openChannel.id;
      for (const data of channel.buffer) {
        await this._sendCommand({
          data: {
            channelId: channel.remoteId,
            data
          }
        }, channel.id);
      }
      channel.buffer = [];
    } else if (cmd.data) {
      const stream = this._channelsByLocalId.get(cmd.data.channelId) ?? failUndefined();
      if (!stream.push) {
        log4.warn("Received data for channel before it was opened", {
          tag: stream.tag
        }, {
          F: __dxlog_file4,
          L: 392,
          S: this,
          C: (f, a) => f(...a)
        });
        return;
      }
      stream.push(cmd.data.data);
    }
  }
  async _sendCommand(cmd, channelId = -1, timeout = DEFAULT_SEND_COMMAND_TIMEOUT) {
    if (this._disposed) {
      return;
    }
    try {
      const trigger = new Trigger();
      this._balancer.pushData(Command.encode(cmd), trigger, channelId);
      await trigger.wait({
        timeout
      });
    } catch (err) {
      await this.destroy(err);
    }
  }
  _getOrCreateStream(params) {
    if (this._channelsByTag.size === 0) {
      scheduleTaskInterval2(this._ctx, async () => this._emitStats(), STATS_INTERVAL);
    }
    let channel = this._channelsByTag.get(params.tag);
    if (!channel) {
      channel = {
        id: this._nextId++,
        remoteId: null,
        tag: params.tag,
        contentType: params.contentType,
        buffer: [],
        push: null,
        destroy: null,
        stats: {
          bytesSent: 0,
          bytesReceived: 0
        }
      };
      this._channelsByTag.set(channel.tag, channel);
      this._channelsByLocalId.set(channel.id, channel);
      this._balancer.addChannel(channel.id);
    }
    return channel;
  }
  async _sendData(channel, data, timeout) {
    if (data.length > MAX_SAFE_FRAME_SIZE) {
      log4.warn("frame size exceeds maximum safe value", {
        size: data.length,
        threshold: MAX_SAFE_FRAME_SIZE
      }, {
        F: __dxlog_file4,
        L: 442,
        S: this,
        C: (f, a) => f(...a)
      });
    }
    channel.stats.bytesSent += data.length;
    if (channel.remoteId === null) {
      channel.buffer.push(data);
      return;
    }
    await this._sendCommand({
      data: {
        channelId: channel.remoteId,
        data
      }
    }, channel.id, timeout);
  }
  _destroyChannel(channel, err) {
    if (err) {
      log4.warn("destroying channel with error", {
        err
      }, {
        F: __dxlog_file4,
        L: 465,
        S: this,
        C: (f, a) => f(...a)
      });
    }
    if (channel.destroy) {
      channel.destroy(err);
    }
    this._channelsByLocalId.delete(channel.id);
    this._channelsByTag.delete(channel.tag);
  }
  async _emitStats() {
    if (this._disposed || this._destroying) {
      if (!this._lastStats) {
        return;
      }
      const lastStats = this._lastStats;
      this._lastStats = void 0;
      lastStats.readBufferSize = 0;
      lastStats.writeBufferSize = 0;
      for (const c of lastStats.channels) {
        c.writeBufferSize = 0;
      }
      this.statsUpdated.emit(lastStats);
      this._lastChannelStats.clear();
      return;
    }
    const bytesSent = this._balancer.bytesSent;
    const bytesReceived = this._balancer.bytesReceived;
    const now = Date.now();
    const interval = this._lastStats ? (now - this._lastStats.timestamp) / 1e3 : 0;
    const calculateThroughput = (current, last) => last ? {
      bytesSentRate: interval ? (current.bytesSent - last.bytesSent) / interval : void 0,
      bytesReceivedRate: interval ? (current.bytesReceived - last.bytesReceived) / interval : void 0
    } : {};
    this._lastStats = {
      timestamp: now,
      channels: Array.from(this._channelsByTag.values()).map((channel) => {
        const stats = {
          id: channel.id,
          tag: channel.tag,
          contentType: channel.contentType,
          writeBufferSize: channel.buffer.length,
          bytesSent: channel.stats.bytesSent,
          bytesReceived: channel.stats.bytesReceived,
          ...calculateThroughput(channel.stats, this._lastChannelStats.get(channel.id))
        };
        this._lastChannelStats.set(channel.id, stats);
        return stats;
      }),
      bytesSent,
      bytesReceived,
      ...calculateThroughput({
        bytesSent,
        bytesReceived
      }, this._lastStats),
      readBufferSize: this._balancer.stream.readableLength,
      writeBufferSize: this._balancer.stream.writableLength
    };
    this.statsUpdated.emit(this._lastStats);
  }
};
_ts_decorate([
  logInfo
], Muxer.prototype, "sessionIdString", null);

// packages/core/mesh/teleport/src/teleport.ts
function _ts_decorate2(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file5 = "/home/runner/work/dxos/dxos/packages/core/mesh/teleport/src/teleport.ts";
var CONTROL_HEARTBEAT_INTERVAL = 1e4;
var CONTROL_HEARTBEAT_TIMEOUT = 6e4;
var Teleport = class {
  constructor({ initiator, localPeerId, remotePeerId, ...rest }) {
    this._ctx = new Context3({
      onError: (err) => {
        log5.info("error in teleport context", {
          err
        }, {
          F: __dxlog_file5,
          L: 40,
          S: this,
          C: (f, a) => f(...a)
        });
        void this.destroy(err).catch(() => {
          log5.error("Error during destroy", err, {
            F: __dxlog_file5,
            L: 42,
            S: this,
            C: (f, a) => f(...a)
          });
        });
      }
    }, {
      F: __dxlog_file5,
      L: 38
    });
    this._muxer = new Muxer();
    this._extensions = /* @__PURE__ */ new Map();
    this._remoteExtensions = /* @__PURE__ */ new Set();
    this._open = false;
    this._destroying = false;
    this._aborting = false;
    invariant4(typeof initiator === "boolean", void 0, {
      F: __dxlog_file5,
      L: 63,
      S: this,
      A: [
        "typeof initiator === 'boolean'",
        ""
      ]
    });
    invariant4(PublicKey.isPublicKey(localPeerId), void 0, {
      F: __dxlog_file5,
      L: 64,
      S: this,
      A: [
        "PublicKey.isPublicKey(localPeerId)",
        ""
      ]
    });
    invariant4(PublicKey.isPublicKey(remotePeerId), void 0, {
      F: __dxlog_file5,
      L: 65,
      S: this,
      A: [
        "PublicKey.isPublicKey(remotePeerId)",
        ""
      ]
    });
    this.initiator = initiator;
    this.localPeerId = localPeerId;
    this.remotePeerId = remotePeerId;
    this._control = new ControlExtension({
      heartbeatInterval: rest.controlHeartbeatInterval ?? CONTROL_HEARTBEAT_INTERVAL,
      heartbeatTimeout: rest.controlHeartbeatTimeout ?? CONTROL_HEARTBEAT_TIMEOUT,
      onTimeout: () => {
        if (this._destroying || this._aborting) {
          return;
        }
        log5.info("abort teleport due to onTimeout in ControlExtension", void 0, {
          F: __dxlog_file5,
          L: 78,
          S: this,
          C: (f, a) => f(...a)
        });
        this.abort(new TimeoutError2("control extension")).catch((err) => log5.catch(err, void 0, {
          F: __dxlog_file5,
          L: 79,
          S: this,
          C: (f, a) => f(...a)
        }));
      }
    }, this.localPeerId, this.remotePeerId);
    this._control.onExtensionRegistered.set(async (name) => {
      log5("remote extension", {
        name
      }, {
        F: __dxlog_file5,
        L: 87,
        S: this,
        C: (f, a) => f(...a)
      });
      invariant4(!this._remoteExtensions.has(name), "Remote extension already exists", {
        F: __dxlog_file5,
        L: 88,
        S: this,
        A: [
          "!this._remoteExtensions.has(name)",
          "'Remote extension already exists'"
        ]
      });
      this._remoteExtensions.add(name);
      if (this._extensions.has(name)) {
        try {
          await this._openExtension(name);
        } catch (err) {
          await this.destroy(err);
        }
      }
    });
    {
      this._muxer.stream.on("close", async () => {
        if (this._destroying || this._aborting) {
          log5("destroy teleport due to muxer stream close, skipping due to already destroying/aborting", void 0, {
            F: __dxlog_file5,
            L: 104,
            S: this,
            C: (f, a) => f(...a)
          });
          return;
        }
        await this.destroy();
      });
      this._muxer.stream.on("error", async (err) => {
        await this.destroy(err);
      });
    }
    this._muxer.statsUpdated.on((stats) => {
      log5.trace("dxos.mesh.teleport.stats", {
        localPeerId,
        remotePeerId,
        bytesSent: stats.bytesSent,
        bytesSentRate: stats.bytesSentRate,
        bytesReceived: stats.bytesReceived,
        bytesReceivedRate: stats.bytesReceivedRate,
        channels: stats.channels
      }, {
        F: __dxlog_file5,
        L: 117,
        S: this,
        C: (f, a) => f(...a)
      });
    });
  }
  get isOpen() {
    return this._open;
  }
  get sessionIdString() {
    return this._sessionId ? this._sessionId.truncate() : "none";
  }
  get stream() {
    return this._muxer.stream;
  }
  get stats() {
    return this._muxer.statsUpdated;
  }
  /**
  * Blocks until the handshake is complete.
  */
  async open(sessionId = PublicKey.random()) {
    this._sessionId = sessionId;
    log5("open", void 0, {
      F: __dxlog_file5,
      L: 151,
      S: this,
      C: (f, a) => f(...a)
    });
    this._setExtension("dxos.mesh.teleport.control", this._control);
    await this._openExtension("dxos.mesh.teleport.control");
    this._open = true;
    this._muxer.setSessionId(sessionId);
  }
  async close(err) {
    await this.destroy(err);
  }
  async abort(err) {
    if (this._aborting || this._destroying) {
      return;
    }
    this._aborting = true;
    this._open = false;
    if (this._ctx.disposed) {
      return;
    }
    await this._ctx.dispose();
    for (const extension of this._extensions.values()) {
      try {
        await extension.onAbort(err);
      } catch (err2) {
        log5.catch(err2, void 0, {
          F: __dxlog_file5,
          L: 181,
          S: this,
          C: (f, a) => f(...a)
        });
      }
    }
    await this._muxer.destroy(err);
  }
  async destroy(err) {
    if (this._destroying || this._aborting) {
      return;
    }
    log5("destroying teleport...", {
      extensionsCount: this._extensions.size
    }, {
      F: __dxlog_file5,
      L: 194,
      S: this,
      C: (f, a) => f(...a)
    });
    this._destroying = true;
    this._open = false;
    if (this._ctx.disposed) {
      return;
    }
    await this._ctx.dispose();
    for (const extension of this._extensions.values()) {
      try {
        log5("destroying extension", {
          name: extension.constructor.name
        }, {
          F: __dxlog_file5,
          L: 206,
          S: this,
          C: (f, a) => f(...a)
        });
        await extension.onClose(err);
        log5("destroyed extension", {
          name: extension.constructor.name
        }, {
          F: __dxlog_file5,
          L: 208,
          S: this,
          C: (f, a) => f(...a)
        });
      } catch (err2) {
        log5.catch(err2, void 0, {
          F: __dxlog_file5,
          L: 210,
          S: this,
          C: (f, a) => f(...a)
        });
      }
    }
    await this._muxer.close();
    log5("teleport destroyed", void 0, {
      F: __dxlog_file5,
      L: 215,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  addExtension(name, extension) {
    if (!this._open) {
      throw new Error("Not open");
    }
    log5("addExtension", {
      name
    }, {
      F: __dxlog_file5,
      L: 223,
      S: this,
      C: (f, a) => f(...a)
    });
    this._setExtension(name, extension);
    scheduleTask(this._ctx, async () => {
      try {
        await this._control.registerExtension(name);
      } catch (err) {
        if (err instanceof RpcClosedError2) {
          return;
        }
        throw err;
      }
    });
    if (this._remoteExtensions.has(name)) {
      scheduleTask(this._ctx, async () => {
        await this._openExtension(name);
      });
    }
  }
  _setExtension(extensionName, extension) {
    invariant4(!extensionName.includes("/"), "Invalid extension name", {
      F: __dxlog_file5,
      L: 247,
      S: this,
      A: [
        "!extensionName.includes('/')",
        "'Invalid extension name'"
      ]
    });
    invariant4(!this._extensions.has(extensionName), "Extension already exists", {
      F: __dxlog_file5,
      L: 248,
      S: this,
      A: [
        "!this._extensions.has(extensionName)",
        "'Extension already exists'"
      ]
    });
    this._extensions.set(extensionName, extension);
  }
  async _openExtension(extensionName) {
    log5("open extension", {
      extensionName
    }, {
      F: __dxlog_file5,
      L: 253,
      S: this,
      C: (f, a) => f(...a)
    });
    const extension = this._extensions.get(extensionName) ?? failUndefined2();
    const context = {
      initiator: this.initiator,
      localPeerId: this.localPeerId,
      remotePeerId: this.remotePeerId,
      createPort: async (channelName, opts) => {
        invariant4(!channelName.includes("/"), "Invalid channel name", {
          F: __dxlog_file5,
          L: 261,
          S: this,
          A: [
            "!channelName.includes('/')",
            "'Invalid channel name'"
          ]
        });
        return this._muxer.createPort(`${extensionName}/${channelName}`, opts);
      },
      createStream: async (channelName, opts) => {
        invariant4(!channelName.includes("/"), "Invalid channel name", {
          F: __dxlog_file5,
          L: 265,
          S: this,
          A: [
            "!channelName.includes('/')",
            "'Invalid channel name'"
          ]
        });
        return this._muxer.createStream(`${extensionName}/${channelName}`, opts);
      },
      close: (err) => {
        void runInContextAsync(this._ctx, async () => {
          await this.close(err);
        });
      }
    };
    await extension.onOpen(context);
    log5("extension opened", {
      extensionName
    }, {
      F: __dxlog_file5,
      L: 276,
      S: this,
      C: (f, a) => f(...a)
    });
  }
};
_ts_decorate2([
  logInfo2
], Teleport.prototype, "sessionIdString", null);
_ts_decorate2([
  synchronized
], Teleport.prototype, "abort", null);
_ts_decorate2([
  synchronized
], Teleport.prototype, "destroy", null);

// packages/core/mesh/teleport/src/testing/test-builder.ts
var __dxlog_file6 = "/home/runner/work/dxos/dxos/packages/core/mesh/teleport/src/testing/test-builder.ts";
var TestBuilder = class {
  constructor() {
    this._peers = /* @__PURE__ */ new Set();
  }
  createPeer(opts) {
    const peer = opts.factory();
    this._peers.add(peer);
    return peer;
  }
  *createPeers(opts) {
    while (true) {
      yield this.createPeer(opts);
    }
  }
  async destroy() {
    await Promise.all(Array.from(this._peers).map((agent) => agent.destroy()));
  }
  async connect(peer1, peer2) {
    invariant5(peer1 !== peer2, void 0, {
      F: __dxlog_file6,
      L: 38,
      S: this,
      A: [
        "peer1 !== peer2",
        ""
      ]
    });
    invariant5(this._peers.has(peer1), void 0, {
      F: __dxlog_file6,
      L: 39,
      S: this,
      A: [
        "this._peers.has(peer1)",
        ""
      ]
    });
    invariant5(this._peers.has(peer1), void 0, {
      F: __dxlog_file6,
      L: 40,
      S: this,
      A: [
        "this._peers.has(peer1)",
        ""
      ]
    });
    const connection1 = peer1.createConnection({
      initiator: true,
      remotePeerId: peer2.peerId
    });
    const connection2 = peer2.createConnection({
      initiator: false,
      remotePeerId: peer1.peerId
    });
    pipeStreams(connection1.teleport.stream, connection2.teleport.stream);
    await Promise.all([
      peer1.openConnection(connection1),
      peer2.openConnection(connection2)
    ]);
    return [
      connection1,
      connection2
    ];
  }
  async disconnect(peer1, peer2) {
    invariant5(peer1 !== peer2, void 0, {
      F: __dxlog_file6,
      L: 52,
      S: this,
      A: [
        "peer1 !== peer2",
        ""
      ]
    });
    invariant5(this._peers.has(peer1), void 0, {
      F: __dxlog_file6,
      L: 53,
      S: this,
      A: [
        "this._peers.has(peer1)",
        ""
      ]
    });
    invariant5(this._peers.has(peer1), void 0, {
      F: __dxlog_file6,
      L: 54,
      S: this,
      A: [
        "this._peers.has(peer1)",
        ""
      ]
    });
    const connection1 = Array.from(peer1.connections).find((connection) => connection.remotePeerId.equals(peer2.peerId));
    const connection2 = Array.from(peer2.connections).find((connection) => connection.remotePeerId.equals(peer1.peerId));
    invariant5(connection1, void 0, {
      F: __dxlog_file6,
      L: 63,
      S: this,
      A: [
        "connection1",
        ""
      ]
    });
    invariant5(connection2, void 0, {
      F: __dxlog_file6,
      L: 64,
      S: this,
      A: [
        "connection2",
        ""
      ]
    });
    await Promise.all([
      peer1.closeConnection(connection1),
      peer2.closeConnection(connection2)
    ]);
  }
};
var TestPeer = class {
  constructor(peerId = PublicKey2.random()) {
    this.peerId = peerId;
    this.connections = /* @__PURE__ */ new Set();
  }
  async onOpen(connection) {
  }
  async onClose(connection) {
  }
  createConnection({ initiator, remotePeerId }) {
    const connection = new TestConnection(this.peerId, remotePeerId, initiator);
    this.connections.add(connection);
    return connection;
  }
  async openConnection(connection) {
    invariant5(this.connections.has(connection), void 0, {
      F: __dxlog_file6,
      L: 85,
      S: this,
      A: [
        "this.connections.has(connection)",
        ""
      ]
    });
    await connection.teleport.open(PublicKey2.random());
    await this.onOpen(connection);
  }
  async closeConnection(connection) {
    invariant5(this.connections.has(connection), void 0, {
      F: __dxlog_file6,
      L: 91,
      S: this,
      A: [
        "this.connections.has(connection)",
        ""
      ]
    });
    await this.onClose(connection);
    await connection.teleport.close();
    this.connections.delete(connection);
  }
  async destroy() {
    for (const teleport of this.connections) {
      await this.closeConnection(teleport);
    }
  }
};
var pipeStreams = (stream1, stream2) => {
  pipeline(stream1, stream2, (err) => {
    if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
      log6.catch(err, void 0, {
        F: __dxlog_file6,
        L: 107,
        S: void 0,
        C: (f, a) => f(...a)
      });
    }
  });
  pipeline(stream2, stream1, (err) => {
    if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
      log6.catch(err, void 0, {
        F: __dxlog_file6,
        L: 112,
        S: void 0,
        C: (f, a) => f(...a)
      });
    }
  });
};
var TestConnection = class {
  constructor(localPeerId, remotePeerId, initiator) {
    this.localPeerId = localPeerId;
    this.remotePeerId = remotePeerId;
    this.initiator = initiator;
    this.teleport = new Teleport({
      initiator,
      localPeerId,
      remotePeerId
    });
  }
  whenOpen(open) {
    return waitForCondition({
      condition: () => this.teleport.isOpen === open
    });
  }
};

// packages/core/mesh/teleport/src/testing/test-extension.ts
import { asyncTimeout as asyncTimeout3, Trigger as Trigger2 } from "@dxos/async";
import { invariant as invariant6 } from "@dxos/invariant";
import { log as log7 } from "@dxos/log";
import { schema as schema3 } from "@dxos/protocols/proto";
import { createProtoRpcPeer as createProtoRpcPeer2 } from "@dxos/rpc";
var __dxlog_file7 = "/home/runner/work/dxos/dxos/packages/core/mesh/teleport/src/testing/test-extension.ts";
var TestExtension = class {
  constructor(callbacks = {}) {
    this.callbacks = callbacks;
    this.open = new Trigger2();
    this.closed = new Trigger2();
    this.aborted = new Trigger2();
  }
  get remotePeerId() {
    return this.extensionContext?.remotePeerId;
  }
  async onOpen(context) {
    log7("onOpen", {
      localPeerId: context.localPeerId,
      remotePeerId: context.remotePeerId
    }, {
      F: __dxlog_file7,
      L: 34,
      S: this,
      C: (f, a) => f(...a)
    });
    this.extensionContext = context;
    this._rpc = createProtoRpcPeer2({
      port: await context.createPort("rpc", {
        contentType: 'application/x-protobuf; messageType="dxos.rpc.Message"'
      }),
      requested: {
        TestService: schema3.getService("example.testing.rpc.TestService")
      },
      exposed: {
        TestService: schema3.getService("example.testing.rpc.TestService")
      },
      handlers: {
        TestService: {
          voidCall: async (request) => {
          },
          testCall: async (request) => {
            return {
              data: request.data
            };
          }
        }
      },
      timeout: 2e3
    });
    await this._rpc.open();
    await this.callbacks.onOpen?.();
    this.open.wake();
  }
  async onClose(err) {
    log7("onClose", {
      err
    }, {
      F: __dxlog_file7,
      L: 68,
      S: this,
      C: (f, a) => f(...a)
    });
    await this.callbacks.onClose?.();
    this.closed.wake();
    await this._rpc?.close();
  }
  async onAbort(err) {
    log7("onAbort", {
      err
    }, {
      F: __dxlog_file7,
      L: 75,
      S: this,
      C: (f, a) => f(...a)
    });
    await this.callbacks.onAbort?.();
    this.aborted.wake();
    await this._rpc?.abort();
  }
  async test(message = "test") {
    await this.open.wait({
      timeout: 2e3
    });
    const res = await asyncTimeout3(this._rpc.rpc.TestService.testCall({
      data: message
    }), 1500);
    invariant6(res.data === message, void 0, {
      F: __dxlog_file7,
      L: 84,
      S: this,
      A: [
        "res.data === message",
        ""
      ]
    });
  }
  /**
  * Force-close the connection.
  */
  async closeConnection(err) {
    this.extensionContext?.close(err);
  }
};

// packages/core/mesh/teleport/src/testing/test-extension-with-streams.ts
import { randomBytes } from "@dxos/node-std/crypto";
import { Trigger as Trigger3 } from "@dxos/async";
import { invariant as invariant7 } from "@dxos/invariant";
import { log as log8 } from "@dxos/log";
import { schema as schema4 } from "@dxos/protocols/proto";
import { createProtoRpcPeer as createProtoRpcPeer3 } from "@dxos/rpc";
var __dxlog_file8 = "/home/runner/work/dxos/dxos/packages/core/mesh/teleport/src/testing/test-extension-with-streams.ts";
var TestExtensionWithStreams = class {
  constructor(callbacks = {}) {
    this.callbacks = callbacks;
    this.open = new Trigger3();
    this.closed = new Trigger3();
    this.aborted = new Trigger3();
    this._streams = /* @__PURE__ */ new Map();
  }
  get remotePeerId() {
    return this.extensionContext?.remotePeerId;
  }
  async _openStream(streamTag, interval = 5, chunkSize = 2048) {
    invariant7(!this._streams.has(streamTag), `Stream already exists: ${streamTag}`, {
      F: __dxlog_file8,
      L: 39,
      S: this,
      A: [
        "!this._streams.has(streamTag)",
        "`Stream already exists: ${streamTag}`"
      ]
    });
    const networkStream = await this.extensionContext.createStream(streamTag, {
      contentType: "application/x-test-stream"
    });
    const streamEntry = {
      networkStream,
      bytesSent: 0,
      bytesReceived: 0,
      sendErrors: 0,
      receiveErrors: 0,
      startTimestamp: Date.now()
    };
    const pushChunk = () => {
      streamEntry.timer = setTimeout(() => {
        const chunk = randomBytes(chunkSize);
        if (!networkStream.write(chunk, "binary", (err) => {
          if (!err) {
            streamEntry.bytesSent += chunk.length;
          } else {
            streamEntry.sendErrors += 1;
          }
        })) {
          networkStream.once("drain", pushChunk);
        } else {
          process.nextTick(pushChunk);
        }
      }, interval);
    };
    pushChunk();
    this._streams.set(streamTag, streamEntry);
    networkStream.on("data", (data) => {
      streamEntry.bytesReceived += data.length;
    });
    networkStream.on("error", (err) => {
      streamEntry.receiveErrors += 1;
    });
    networkStream.on("close", () => {
      networkStream.removeAllListeners();
    });
    streamEntry.reportingTimer = setInterval(() => {
      const { bytesSent, bytesReceived, sendErrors, receiveErrors } = streamEntry;
      log8.trace("dxos.test.stream-stats", {
        streamTag,
        bytesSent,
        bytesReceived,
        sendErrors,
        receiveErrors,
        from: this.extensionContext?.localPeerId,
        to: this.extensionContext?.remotePeerId
      }, {
        F: __dxlog_file8,
        L: 93,
        S: this,
        C: (f, a) => f(...a)
      });
    }, 100);
  }
  _closeStream(streamTag) {
    invariant7(this._streams.has(streamTag), `Stream does not exist: ${streamTag}`, {
      F: __dxlog_file8,
      L: 106,
      S: this,
      A: [
        "this._streams.has(streamTag)",
        "`Stream does not exist: ${streamTag}`"
      ]
    });
    const stream = this._streams.get(streamTag);
    clearTimeout(stream.timer);
    clearTimeout(stream.reportingTimer);
    const { bytesSent, bytesReceived, sendErrors, receiveErrors, startTimestamp } = stream;
    stream.networkStream.destroy();
    this._streams.delete(streamTag);
    return {
      bytesSent,
      bytesReceived,
      sendErrors,
      receiveErrors,
      runningTime: Date.now() - (startTimestamp ?? 0)
    };
  }
  async onOpen(context) {
    log8("onOpen", {
      localPeerId: context.localPeerId,
      remotePeerId: context.remotePeerId
    }, {
      F: __dxlog_file8,
      L: 128,
      S: this,
      C: (f, a) => f(...a)
    });
    this.extensionContext = context;
    this._rpc = createProtoRpcPeer3({
      port: await context.createPort("rpc", {
        contentType: 'application/x-protobuf; messageType="dxos.rpc.Message"'
      }),
      requested: {
        TestServiceWithStreams: schema4.getService("example.testing.rpc.TestServiceWithStreams")
      },
      exposed: {
        TestServiceWithStreams: schema4.getService("example.testing.rpc.TestServiceWithStreams")
      },
      handlers: {
        TestServiceWithStreams: {
          requestTestStream: async (request) => {
            const { data: streamTag, streamLoadInterval, streamLoadChunkSize } = request;
            await this._openStream(streamTag, streamLoadInterval, streamLoadChunkSize);
            return {
              data: streamTag
            };
          },
          closeTestStream: async (request) => {
            const streamTag = request.data;
            const { bytesSent, bytesReceived, sendErrors, receiveErrors, runningTime } = this._closeStream(streamTag);
            return {
              data: streamTag,
              bytesSent,
              bytesReceived,
              sendErrors,
              receiveErrors,
              runningTime
            };
          }
        }
      },
      timeout: 2e3
    });
    await this._rpc.open();
    await this.callbacks.onOpen?.();
    this.open.wake();
  }
  async onClose(err) {
    log8("onClose", {
      err
    }, {
      F: __dxlog_file8,
      L: 179,
      S: this,
      C: (f, a) => f(...a)
    });
    await this.callbacks.onClose?.();
    this.closed.wake();
    for (const [streamTag, stream] of Object.entries(this._streams)) {
      log8("closing stream", {
        streamTag
      }, {
        F: __dxlog_file8,
        L: 183,
        S: this,
        C: (f, a) => f(...a)
      });
      clearTimeout(stream.interval);
      stream.networkStream.destroy();
    }
    await this._rpc?.close();
  }
  async onAbort(err) {
    log8("onAbort", {
      err
    }, {
      F: __dxlog_file8,
      L: 191,
      S: this,
      C: (f, a) => f(...a)
    });
    await this.callbacks.onAbort?.();
    this.aborted.wake();
    await this._rpc?.abort();
  }
  async addNewStream(streamLoadInterval, streamLoadChunkSize, streamTag) {
    await this.open.wait({
      timeout: 1500
    });
    if (!streamTag) {
      streamTag = `stream-${randomBytes(4).toString("hex")}`;
    }
    const { data } = await this._rpc.rpc.TestServiceWithStreams.requestTestStream({
      data: streamTag,
      streamLoadInterval,
      streamLoadChunkSize
    });
    invariant7(data === streamTag, void 0, {
      F: __dxlog_file8,
      L: 207,
      S: this,
      A: [
        "data === streamTag",
        ""
      ]
    });
    await this._openStream(streamTag, streamLoadInterval, streamLoadChunkSize);
    return streamTag;
  }
  async closeStream(streamTag) {
    await this.open.wait({
      timeout: 1500
    });
    const { data, bytesSent, bytesReceived, sendErrors, receiveErrors, runningTime } = await this._rpc.rpc.TestServiceWithStreams.closeTestStream({
      data: streamTag
    });
    invariant7(data === streamTag, void 0, {
      F: __dxlog_file8,
      L: 220,
      S: this,
      A: [
        "data === streamTag",
        ""
      ]
    });
    const local = this._closeStream(streamTag);
    return {
      streamTag,
      stats: {
        local,
        remote: {
          bytesSent,
          bytesReceived,
          sendErrors,
          receiveErrors,
          runningTime
        }
      }
    };
  }
  /**
  * Force-close the connection.
  */
  async closeConnection(err) {
    this.extensionContext?.close(err);
  }
};

export {
  Framer,
  decodeFrame,
  encodeFrame,
  Muxer,
  Teleport,
  TestBuilder,
  TestPeer,
  TestConnection,
  TestExtension,
  TestExtensionWithStreams
};
//# sourceMappingURL=chunk-PKY5UWGF.mjs.map
