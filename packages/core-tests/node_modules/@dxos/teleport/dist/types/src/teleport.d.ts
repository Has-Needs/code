import { type Duplex } from 'node:stream';
import { type Event } from '@dxos/async';
import { PublicKey } from '@dxos/keys';
import { type CreateChannelOpts, type MuxerStats, type RpcPort } from './muxing';
export type TeleportParams = {
    initiator: boolean;
    localPeerId: PublicKey;
    remotePeerId: PublicKey;
    controlHeartbeatInterval?: number;
    controlHeartbeatTimeout?: number;
};
/**
 * TODO(burdon): Comment: what is this?
 */
export declare class Teleport {
    readonly initiator: boolean;
    readonly localPeerId: PublicKey;
    readonly remotePeerId: PublicKey;
    _sessionId?: PublicKey;
    private readonly _ctx;
    private readonly _muxer;
    private readonly _control;
    private readonly _extensions;
    private readonly _remoteExtensions;
    private _open;
    private _destroying;
    private _aborting;
    get isOpen(): boolean;
    constructor({ initiator, localPeerId, remotePeerId, ...rest }: TeleportParams);
    get sessionIdString(): string;
    get stream(): Duplex;
    get stats(): Event<MuxerStats>;
    /**
     * Blocks until the handshake is complete.
     */
    open(sessionId?: PublicKey): Promise<void>;
    close(err?: Error): Promise<void>;
    abort(err?: Error): Promise<void>;
    destroy(err?: Error): Promise<void>;
    addExtension(name: string, extension: TeleportExtension): void;
    private _setExtension;
    private _openExtension;
}
export type ExtensionContext = {
    /**
     * One of the peers will be designated an initiator.
     */
    initiator: boolean;
    localPeerId: PublicKey;
    remotePeerId: PublicKey;
    createStream(tag: string, opts?: CreateChannelOpts): Promise<Duplex>;
    createPort(tag: string, opts?: CreateChannelOpts): Promise<RpcPort>;
    close(err?: Error): void;
};
export interface TeleportExtension {
    onOpen(context: ExtensionContext): Promise<void>;
    onClose(err?: Error): Promise<void>;
    onAbort(err?: Error): Promise<void>;
}
//# sourceMappingURL=teleport.d.ts.map