import "@dxos/node-std/globals";
import import$random_access_storage from 'random-access-storage';
import import$inherits from 'inherits';
import import$next_tick from 'next-tick';
import import$once from 'once';
import import$buffer_from from 'buffer-from';
import import$buffer_alloc from 'buffer-alloc';
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/.pnpm/random-access-idb@1.2.2_patch_hash=mqfhtwnltd5kq5s4kb4gk7k2k4/node_modules/random-access-idb/lib/blocks.js
var require_blocks = __commonJS({
  "node_modules/.pnpm/random-access-idb@1.2.2_patch_hash=mqfhtwnltd5kq5s4kb4gk7k2k4/node_modules/random-access-idb/lib/blocks.js"(exports, module) {
    module.exports = function(size, start, end) {
      var result = [];
      for (var n = Math.floor(start / size) * size; n < end; n += size) {
        result.push({
          block: Math.floor(n / size),
          start: Math.max(n, start) % size,
          end: Math.min(n + size, end) % size || size
        });
      }
      return result;
    };
  }
});

// node_modules/.pnpm/random-access-idb@1.2.2_patch_hash=mqfhtwnltd5kq5s4kb4gk7k2k4/node_modules/random-access-idb/index.js
var require_random_access_idb = __commonJS({
  "node_modules/.pnpm/random-access-idb@1.2.2_patch_hash=mqfhtwnltd5kq5s4kb4gk7k2k4/node_modules/random-access-idb/index.js"(exports, module) {
    var RandomAccess = import$random_access_storage;
    var inherits = import$inherits;
    var nextTick = import$next_tick;
    var once = import$once;
    var blocks = require_blocks();
    var bufferFrom = import$buffer_from;
    var bufferAlloc = import$buffer_alloc;
    var DELIM2 = "\0";
    var win = typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {};
    module.exports = function(dbname, xopts) {
      if (!xopts) xopts = {};
      var idb2 = xopts.idb || (typeof win !== "undefined" ? win.indexedDB || win.mozIndexedDB || win.webkitIndexedDB || win.msIndexedDB : null);
      if (!idb2) throw new Error("indexedDB not present and not given");
      var db = null, dbqueue = [];
      if (typeof idb2.open === "function") {
        var req = idb2.open(dbname);
        req.addEventListener("upgradeneeded", function() {
          db = req.result;
          db.createObjectStore("data");
        });
        req.addEventListener("success", function() {
          db = req.result;
          dbqueue.forEach(function(cb) {
            cb(db);
          });
          dbqueue = null;
        });
      } else {
        db = idb2;
      }
      function getdb(cb) {
        if (db) nextTick(function() {
          cb(db);
        });
        else dbqueue.push(cb);
      }
      return {
        create: function(name, opts) {
          if (typeof name === "object") {
            opts = name;
            name = opts.name;
          }
          if (!opts) opts = {};
          opts.name = name;
          return new Store(Object.assign({ db: getdb }, xopts, opts));
        },
        getdb
      };
    };
    function Store(opts) {
      if (!(this instanceof Store)) return new Store(opts);
      RandomAccess.call(this);
      if (!opts) opts = {};
      if (typeof opts === "string") opts = { name: opts };
      this.size = opts.size || 4096;
      this.name = opts.name;
      this.length = opts.length || 0;
      this._getdb = opts.db;
    }
    inherits(Store, RandomAccess);
    Store.prototype._blocks = function(i, j) {
      return blocks(this.size, i, j);
    };
    Store.prototype._read = function(req) {
      var self2 = this;
      var buffers = [];
      self2._store("readonly", function(err, store) {
        if ((self2.length || 0) < req.offset + req.size) {
          return req.callback(new Error("Could not satisfy length"));
        }
        if (err) return req.callback(err);
        var offsets = self2._blocks(req.offset, req.offset + req.size);
        var pending = offsets.length + 1;
        var firstBlock = offsets.length > 0 ? offsets[0].block : 0;
        var j = 0;
        for (var i = 0; i < offsets.length; i++) (function(o) {
          var key = self2.name + DELIM2 + o.block;
          backify(store.get(key), function(err2, ev) {
            if (err2) return req.callback(err2);
            buffers[o.block - firstBlock] = ev.target.result ? bufferFrom(ev.target.result.subarray(o.start, o.end)) : bufferAlloc(o.end - o.start);
            if (--pending === 0) req.callback(null, Buffer.concat(buffers));
          });
        })(offsets[i]);
        if (--pending === 0) req.callback(null, Buffer.concat(buffers));
      });
    };
    Store.prototype._write = function(req) {
      var self2 = this;
      self2._store("readwrite", function(err, store) {
        if (err) return req.callback(err);
        var offsets = self2._blocks(req.offset, req.offset + req.data.length);
        var pending = 1;
        var buffers = {};
        for (var i = 0; i < offsets.length; i++) (function(o, i2) {
          if (o.end - o.start === self2.size) return;
          pending++;
          var key = self2.name + DELIM2 + o.block;
          backify(store.get(key), function(err2, ev) {
            if (err2) return req.callback(err2);
            buffers[i2] = bufferFrom(ev.target.result || bufferAlloc(self2.size));
            if (--pending === 0) write(store, offsets, buffers);
          });
        })(offsets[i], i);
        if (--pending === 0) write(store, offsets, buffers);
      });
      function write(store, offsets, buffers) {
        var block;
        for (var i = 0, j = 0; i < offsets.length; i++) {
          var o = offsets[i];
          var len = o.end - o.start;
          if (len === self2.size) {
            block = bufferFrom(req.data.slice(j, j + len));
          } else {
            block = buffers[i];
            req.data.copy(block, o.start, j, j + len);
          }
          store.put(block, self2.name + DELIM2 + o.block);
          j += len;
        }
        var length = Math.max(self2.length || 0, req.offset + req.data.length);
        store.put(length, self2.name + DELIM2 + "length");
        store.transaction.addEventListener("complete", function() {
          self2.length = length;
          req.callback(null);
        });
        store.transaction.addEventListener("error", function(err) {
          req.callback(err);
        });
      }
    };
    Store.prototype._store = function(mode, cb) {
      cb = once(cb);
      var self2 = this;
      self2._getdb(function(db) {
        var tx = db.transaction(["data"], mode);
        var store = tx.objectStore("data");
        tx.addEventListener("error", cb);
        cb(null, store);
      });
    };
    Store.prototype._open = function(req) {
      var self2 = this;
      this._getdb(function(db) {
        self2._store("readonly", function(err, store) {
          backify(store.get(self2.name + DELIM2 + "length"), function(err2, ev) {
            self2.length = ev.target.result || 0;
            req.callback(null);
          });
        });
      });
    };
    Store.prototype._close = function(req) {
      this._getdb(function(db) {
        req.callback();
      });
    };
    Store.prototype._stat = function(req) {
      var self2 = this;
      nextTick(function() {
        req.callback(null, { size: self2.length });
      });
    };
    function backify(r, cb) {
      r.addEventListener("success", function(ev) {
        cb(null, ev);
      });
      r.addEventListener("error", cb);
    }
  }
});

// packages/common/random-access-storage/src/common/abstract-storage.ts
import { join as join2 } from "@dxos/node-std/path";
import { inspect } from "@dxos/node-std/util";
import { inspectObject } from "@dxos/debug";
import { log as log2 } from "@dxos/log";

// packages/common/random-access-storage/src/common/utils.ts
import { join } from "@dxos/node-std/path";
var stringDiff = (first, second) => first.split(second).join("");
var getFullPath = (root, path) => join(root, stringDiff(path, root));

// packages/common/random-access-storage/src/common/directory.ts
var Directory = class _Directory {
  constructor({ type, path, list, getOrCreateFile, remove, onFlush }) {
    this.type = type;
    this.path = path;
    this._list = list;
    this._getOrCreateFile = getOrCreateFile;
    this._remove = remove;
    this._onFlush = onFlush;
  }
  toString() {
    return `Directory(${JSON.stringify({
      type: this.type,
      path: this.path
    })})`;
  }
  /**
  * Create a new sub-directory.
  */
  createDirectory(path) {
    return new _Directory({
      type: this.type,
      path: getFullPath(this.path, path),
      list: this._list,
      getOrCreateFile: this._getOrCreateFile,
      remove: this._remove
    });
  }
  /**
  * Get all files in the current directory.
  */
  list() {
    return this._list(this.path);
  }
  /**
  * Get or create a new file.
  */
  getOrCreateFile(filename, opts) {
    return this._getOrCreateFile(this.path, filename, opts);
  }
  async flush() {
    await this._onFlush?.();
  }
  /**
  * Close and delete all files in the directory and all its sub-directories.
  */
  async delete() {
    await this._remove();
  }
};

// packages/common/random-access-storage/src/common/file.ts
import pify from "pify";
import { log } from "@dxos/log";
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/common/random-access-storage/src/common/file.ts";
var MAX_STORAGE_OPERATION_TIME = 50;
var pifyFields = (object, type, fields) => {
  for (const field of fields) {
    if (!object[field]) {
    } else {
      const fn = pify(object[field].bind(object));
      object[field] = async (...args) => {
        const before = performance.now();
        const res = await fn(...args);
        const elapsed = performance.now() - before;
        if (elapsed > MAX_STORAGE_OPERATION_TIME) {
          log("Slow storage operation", {
            type,
            operation: field,
            elapsed
          }, {
            F: __dxlog_file,
            L: 62,
            S: void 0,
            C: (f, a) => f(...a)
          });
        }
        return res;
      };
    }
  }
  return object;
};
var wrapFile = (native, type) => {
  const file = pifyFields(native, type, [
    "write",
    "read",
    "del",
    "stat",
    "close",
    "destroy",
    "truncate"
  ]);
  return Object.assign(file, {
    type,
    native
  });
};

// packages/common/random-access-storage/src/common/abstract-storage.ts
var __dxlog_file2 = "/home/runner/work/dxos/dxos/packages/common/random-access-storage/src/common/abstract-storage.ts";
var AbstractStorage = class {
  // TODO(burdon): Make required.
  constructor(path) {
    this.path = path;
    this._files = /* @__PURE__ */ new Map();
  }
  [inspect.custom]() {
    return inspectObject(this);
  }
  toJSON() {
    return {
      type: this.type,
      path: this.path
    };
  }
  get size() {
    return this._files.size;
  }
  // TODO(burdon): Make required.
  createDirectory(sub = "") {
    return new Directory({
      type: this.type,
      path: getFullPath(this.path, sub),
      list: this._list.bind(this),
      getOrCreateFile: (...args) => this.getOrCreateFile(...args),
      remove: () => this._remove(sub)
    });
  }
  /**
  * Delete all files.
  */
  async reset() {
    try {
      log2.info("Erasing all data...", void 0, {
        F: __dxlog_file2,
        L: 60,
        S: this,
        C: (f, a) => f(...a)
      });
      await this._closeFilesInPath("");
      await this._remove("");
      await this._destroy();
      log2("Erased...", void 0, {
        F: __dxlog_file2,
        L: 64,
        S: this,
        C: (f, a) => f(...a)
      });
    } catch (err) {
      log2.catch(err, void 0, {
        F: __dxlog_file2,
        L: 66,
        S: this,
        C: (f, a) => f(...a)
      });
    }
  }
  async _list(path) {
    return Array.from((await this._getFiles(path)).keys()).map((filename) => {
      let name = filename.replace(path, "");
      if (name.startsWith("/")) {
        name = name.substring(1);
      }
      return name;
    });
  }
  getOrCreateFile(path, filename, opts) {
    const fullPath = join2(path, filename);
    let native;
    let file = this._getFileIfExists(fullPath);
    if (file) {
      if (!file.closed) {
        return file;
      }
      native = this._openFile(file.native);
    }
    if (!native) {
      native = this._createFile(path, filename, opts);
    }
    file = wrapFile(native, this.type);
    this._files.set(fullPath, file);
    return file;
  }
  _destroy() {
    return void 0;
  }
  /**
  * Attempt to reopen file.
  */
  _openFile(file) {
    return void 0;
  }
  _getFileIfExists(filename) {
    if (this._files.has(filename)) {
      const file = this._files.get(filename);
      if (file && !file.destroyed) {
        return file;
      }
    }
  }
  async _getFiles(path) {
    const fullPath = getFullPath(this.path, path);
    return new Map([
      ...this._files.entries()
    ].filter(([path2, file]) => path2.includes(fullPath) && file.destroyed !== true));
  }
  async _closeFilesInPath(path) {
    await Promise.all(Array.from((await this._getFiles(path)).values()).map((file) => file.close().catch((err) => log2.catch(err, void 0, {
      F: __dxlog_file2,
      L: 134,
      S: this,
      C: (f, a) => f(...a)
    }))));
  }
  async close() {
    await this._closeFilesInPath("");
  }
  // TODO(burdon): Delete directory (not just listed files).
  async _remove(path) {
    await Promise.all(Array.from(await this._getFiles(path)).map(([path2, file]) => {
      return file.destroy().then(() => this._files.delete(path2)).catch((err) => log2.error(err.message, void 0, {
        F: __dxlog_file2,
        L: 149,
        S: this,
        C: (f, a) => f(...a)
      }));
    }));
  }
};

// packages/common/random-access-storage/src/common/memory-storage.ts
import ram from "random-access-memory";
import { arrayToBuffer } from "@dxos/util";

// packages/common/random-access-storage/src/common/storage.ts
var StorageType = /* @__PURE__ */ function(StorageType2) {
  StorageType2["RAM"] = "ram";
  StorageType2["IDB"] = "idb";
  StorageType2["CHROME"] = "chrome";
  StorageType2["FIREFOX"] = "firefox";
  StorageType2["NODE"] = "node";
  StorageType2["WEBFS"] = "webfs";
  return StorageType2;
}({});

// packages/common/random-access-storage/src/common/memory-storage.ts
var MemoryStorage = class extends AbstractStorage {
  constructor() {
    super(...arguments);
    this.type = StorageType.RAM;
  }
  _createFile(path, filename) {
    return this._patchFile(ram());
  }
  _openFile(file) {
    const newFile = file.clone();
    newFile.closed = false;
    return this._patchFile(newFile);
  }
  _patchFile(file) {
    const trueRead = file.read.bind(file);
    file.read = (offset, size, cb) => trueRead(offset, size, (err, data) => {
      if (err) {
        return cb(err);
      } else {
        return cb(err, arrayToBuffer(data));
      }
    });
    return file;
  }
  async getDiskInfo() {
    let used = 0;
    for (const file of this._files.values()) {
      const size = file.length;
      used += Number.isNaN(size) ? 0 : size;
    }
    return {
      used
    };
  }
};

// packages/common/random-access-storage/src/browser/idb-storage.ts
var import_random_access_idb = __toESM(require_random_access_idb(), 1);
import { invariant } from "@dxos/invariant";
var __dxlog_file3 = "/home/runner/work/dxos/dxos/packages/common/random-access-storage/src/browser/idb-storage.ts";
var DELIM = "\0";
var IDbStorage = class extends AbstractStorage {
  constructor(path) {
    super(path);
    this.type = StorageType.IDB;
    this._store = "data";
    this._initialized = false;
    this._fileStorage = this._createFileStorage(path);
  }
  _createFileStorage(path) {
    const database = (0, import_random_access_idb.default)(path);
    let res;
    this._db = new Promise((resolve) => {
      res = resolve;
    });
    database.getdb(res);
    return database.create;
  }
  async close() {
    await this._closeFilesInPath("");
  }
  async reset() {
    await this._closeFilesInPath("");
    await this._remove("");
  }
  async _destroy() {
    throw new Error("Unreachable");
  }
  _createFile(path, filename) {
    const file = this._fileStorage(getFullPath(path, filename));
    file.destroy = (cb) => {
      void this._db.then((db) => {
        const lowerBound = getFullPath(path, filename);
        const upperBound = `${lowerBound}\uFFFF`;
        const range = IDBKeyRange.bound(lowerBound, upperBound);
        const transaction = db.transaction(this._store, "readwrite");
        const objectStore = transaction.objectStore(this._store);
        objectStore.delete(range);
        transaction.oncomplete = () => {
          file.destroyed = true;
          file.unlinked = true;
          file.closed = true;
          cb(null);
        };
        transaction.onerror = () => cb(transaction.error);
      });
    };
    file.deletable = true;
    return file;
  }
  async _loadFiles(path) {
    const db = await this._db;
    invariant(db, "Database is not initialized.", {
      F: __dxlog_file3,
      L: 85,
      S: this,
      A: [
        "db",
        "'Database is not initialized.'"
      ]
    });
    const lowerBound = path;
    const upperBound = `${path}\uFFFF`;
    const range = IDBKeyRange.bound(lowerBound, upperBound);
    const transaction = db.transaction(this._store);
    const objectStore = transaction.objectStore(this._store);
    const request = objectStore.openCursor(range);
    return new Promise((resolve, reject) => {
      transaction.onerror = () => {
        reject(request.error);
      };
      request.onsuccess = (event) => {
        const cursor = event.target.result;
        if (cursor) {
          const filename = String(cursor.key).split(DELIM)[0];
          if (filename && !this._files.has(getFullPath(this.path, filename))) {
            const file = this._createFile(path, filename);
            this._files.set(getFullPath(this.path, filename), wrapFile(file, this.type));
          }
          cursor.continue();
        } else {
          resolve();
        }
      };
    });
  }
  async _getFiles(path) {
    if (!this._initialized) {
      await this._loadFiles(this.path);
      this._initialized = true;
    }
    return super._getFiles(path);
  }
};

// packages/common/random-access-storage/src/browser/web-fs.ts
import { EventEmitter } from "@dxos/node-std/events";
import { callbackify } from "@dxos/node-std/util";
import { synchronized } from "@dxos/async";
import { invariant as invariant2 } from "@dxos/invariant";
import { log as log3 } from "@dxos/log";
import { TimeSeriesCounter, trace } from "@dxos/tracing";
function _ts_decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file4 = "/home/runner/work/dxos/dxos/packages/common/random-access-storage/src/browser/web-fs.ts";
var WebFS = class {
  constructor(path) {
    this.path = path;
    this._files = /* @__PURE__ */ new Map();
    this.type = StorageType.WEBFS;
  }
  get size() {
    return this._files.size;
  }
  _getFiles(path) {
    const fullName = this._getFullFilename(this.path, path);
    return new Map([
      ...this._files.entries()
    ].filter(([path2, file]) => {
      return path2.includes(fullName) && !file.destroyed;
    }));
  }
  async _list(path) {
    const fullName = this._getFullFilename(path);
    const root = await this._initialize();
    const entries = [];
    for await (const entry of root.keys()) {
      if (entry.startsWith(fullName + "_") && !entry.endsWith(".crswap")) {
        entries.push(entry.slice(fullName.length + 1));
      }
    }
    return entries;
  }
  async _initialize() {
    if (this._root) {
      return this._root;
    }
    this._root = await navigator.storage.getDirectory();
    invariant2(this._root, "Root is undefined", {
      F: __dxlog_file4,
      L: 73,
      S: this,
      A: [
        "this._root",
        "'Root is undefined'"
      ]
    });
    return this._root;
  }
  createDirectory(sub = "") {
    return new Directory({
      type: this.type,
      path: getFullPath(this.path, sub),
      list: (path) => this._list(path),
      getOrCreateFile: (...args) => this.getOrCreateFile(...args),
      remove: () => this._delete(sub),
      onFlush: async () => {
        await Promise.all(Array.from(this._getFiles(sub)).map(([_, file]) => file.flush()));
      }
    });
  }
  getOrCreateFile(path, filename, opts) {
    const fullName = this._getFullFilename(path, filename);
    const existingFile = this._files.get(fullName);
    if (existingFile) {
      return existingFile;
    }
    const file = this._createFile(fullName);
    this._files.set(fullName, file);
    return file;
  }
  _createFile(fullName) {
    return new WebFile({
      fileName: fullName,
      file: this._initialize().then((root) => root.getFileHandle(fullName, {
        create: true
      })),
      destroy: async () => {
        this._files.delete(fullName);
        const root = await this._initialize();
        return root.removeEntry(fullName);
      }
    });
  }
  async _delete(path) {
    await Promise.all(Array.from(this._getFiles(path)).map(async ([path2, file]) => {
      await file.destroy().catch((err) => log3.warn(err, void 0, {
        F: __dxlog_file4,
        L: 116,
        S: this,
        C: (f, a) => f(...a)
      }));
      this._files.delete(path2);
    }));
  }
  async reset() {
    await this._initialize();
    for await (const filename of await this._root.keys()) {
      await this._root.removeEntry(filename, {
        recursive: true
      }).catch((err) => log3.warn("failed to remove an entry", {
        filename,
        err
      }, {
        F: __dxlog_file4,
        L: 126,
        S: this,
        C: (f, a) => f(...a)
      }));
      this._files.delete(filename);
    }
    this._root = void 0;
  }
  async close() {
    await Promise.all(Array.from(this._files.values()).map((file) => {
      return file.close().catch((e) => log3.warn("failed to close a file", {
        file: file.fileName,
        e
      }, {
        F: __dxlog_file4,
        L: 136,
        S: this,
        C: (f, a) => f(...a)
      }));
    }));
  }
  _getFullFilename(path, filename) {
    if (filename) {
      return getFullPath(path, filename).replace(/\//g, "_");
    } else {
      return path.replace(/\//g, "_");
    }
  }
  async getDiskInfo() {
    let used = 0;
    const recurse = async (handle) => {
      const promises = [];
      for await (const entry of handle.values()) {
        promises.push((async () => {
          switch (entry.kind) {
            case "file":
              used += await entry.getFile().then((f) => f.size);
              break;
            case "directory":
              await recurse(entry);
              break;
          }
        })());
      }
      await Promise.all(promises);
    };
    await recurse(this._root);
    return {
      used
    };
  }
};
_ts_decorate([
  synchronized
], WebFS.prototype, "_initialize", null);
var WebFile = class extends EventEmitter {
  constructor({ fileName, file, destroy }) {
    super();
    /**
    * Current view of the file contents.
    */
    this._buffer = null;
    this._loadBufferPromise = null;
    this._flushScheduled = false;
    this._flushPromise = Promise.resolve();
    /**
    * Used to discard unnecessary scheduled flushes.
    * If _flushNow() is called with a lower sequence number it should early exit.
    */
    this._flushSequence = 0;
    //
    // Metrics
    //
    this._flushes = new TimeSeriesCounter();
    this._operations = new TimeSeriesCounter();
    this._reads = new TimeSeriesCounter();
    this._readBytes = new TimeSeriesCounter();
    this._writes = new TimeSeriesCounter();
    this._writeBytes = new TimeSeriesCounter();
    this.type = StorageType.WEBFS;
    //
    // random-access-storage library compatibility
    //
    // TODO(dmaretskyi): Are those all needed?
    this.opened = true;
    this.suspended = false;
    this.closed = false;
    this.unlinked = false;
    this.writing = false;
    this.readable = true;
    this.writable = true;
    this.deletable = true;
    this.truncatable = true;
    this.statable = true;
    this.destroyed = false;
    this.directory = "";
    // TODO(dmaretskyi): is this used?
    this.filename = "";
    this.native = {
      write: callbackify(this.write.bind(this)),
      read: callbackify(this.read.bind(this)),
      del: callbackify(this.del.bind(this)),
      stat: callbackify(this.stat.bind(this)),
      destroy: callbackify(this.destroy.bind(this)),
      truncate: callbackify(this.truncate?.bind(this))
    };
    this.fileName = fileName;
    this._fileHandle = file;
    this._destroy = destroy;
    void this._loadBufferGuarded();
  }
  get _bufferSize() {
    return this._buffer?.length;
  }
  async _loadBuffer() {
    const fileHandle = await this._fileHandle;
    const file = await fileHandle.getFile();
    this._buffer = new Uint8Array(await file.arrayBuffer());
  }
  async _loadBufferGuarded() {
    await (this._loadBufferPromise ??= this._loadBuffer());
  }
  // Do not call directly, use _flushLater or _flushNow.
  async _flushCache(sequence) {
    if (this.destroyed || sequence < this._flushSequence) {
      return;
    }
    this._flushSequence = sequence + 1;
    this._flushes.inc();
    await this._loadBufferGuarded();
    invariant2(this._buffer, void 0, {
      F: __dxlog_file4,
      L: 300,
      S: this,
      A: [
        "this._buffer",
        ""
      ]
    });
    const fileHandle = await this._fileHandle;
    const writable = await fileHandle.createWritable({
      keepExistingData: true
    });
    await writable.write({
      type: "write",
      data: this._buffer,
      position: 0
    });
    await writable.close();
  }
  _flushLater() {
    if (this._flushScheduled) {
      return;
    }
    const sequence = this._flushSequence;
    setTimeout(async () => {
      await this._flushPromise;
      this._flushScheduled = false;
      this._flushPromise = this._flushCache(sequence).catch((err) => log3.warn(err, void 0, {
        F: __dxlog_file4,
        L: 318,
        S: this,
        C: (f, a) => f(...a)
      }));
    });
    this._flushScheduled = true;
  }
  async _flushNow() {
    await this._flushPromise;
    this._flushPromise = this._flushCache(this._flushSequence).catch((err) => log3.warn(err, void 0, {
      F: __dxlog_file4,
      L: 326,
      S: this,
      C: (f, a) => f(...a)
    }));
    await this._flushPromise;
  }
  async read(offset, size) {
    this.assertNotDestroyed("Read");
    this._operations.inc();
    this._reads.inc();
    this._readBytes.inc(size);
    if (!this._buffer) {
      await this._loadBufferGuarded();
      invariant2(this._buffer, void 0, {
        F: __dxlog_file4,
        L: 339,
        S: this,
        A: [
          "this._buffer",
          ""
        ]
      });
    }
    if (offset + size > this._buffer.length) {
      throw new Error("Read out of bounds");
    }
    return Buffer.from(this._buffer.slice(offset, offset + size));
  }
  async write(offset, data) {
    this.assertNotDestroyed("Write");
    this._operations.inc();
    this._writes.inc();
    this._writeBytes.inc(data.length);
    if (!this._buffer) {
      await this._loadBufferGuarded();
      invariant2(this._buffer, void 0, {
        F: __dxlog_file4,
        L: 359,
        S: this,
        A: [
          "this._buffer",
          ""
        ]
      });
    }
    if (offset + data.length <= this._buffer.length) {
      this._buffer.set(data, offset);
    } else {
      const newCache = new Uint8Array(offset + data.length);
      newCache.set(this._buffer);
      newCache.set(data, offset);
      this._buffer = newCache;
    }
    this._flushLater();
  }
  async del(offset, size) {
    this.assertNotDestroyed("Del");
    this._operations.inc();
    if (offset < 0 || size <= 0) {
      return;
    }
    if (!this._buffer) {
      await this._loadBufferGuarded();
      invariant2(this._buffer, void 0, {
        F: __dxlog_file4,
        L: 386,
        S: this,
        A: [
          "this._buffer",
          ""
        ]
      });
    }
    let leftoverSize = 0;
    if (offset + size < this._buffer.length) {
      leftoverSize = this._buffer.length - (offset + size);
      this._buffer.set(this._buffer.slice(offset + size, offset + size + leftoverSize), offset);
    }
    this._buffer = this._buffer.slice(0, offset + leftoverSize);
    this._flushLater();
  }
  async stat() {
    this.assertNotDestroyed("Truncate");
    this._operations.inc();
    if (!this._buffer) {
      await this._loadBufferGuarded();
      invariant2(this._buffer, void 0, {
        F: __dxlog_file4,
        L: 408,
        S: this,
        A: [
          "this._buffer",
          ""
        ]
      });
    }
    return {
      size: this._buffer.length
    };
  }
  async truncate(offset) {
    this.assertNotDestroyed("Truncate");
    this._operations.inc();
    if (!this._buffer) {
      await this._loadBufferGuarded();
      invariant2(this._buffer, void 0, {
        F: __dxlog_file4,
        L: 423,
        S: this,
        A: [
          "this._buffer",
          ""
        ]
      });
    }
    this._buffer = this._buffer.slice(0, offset);
    this._flushLater();
  }
  async flush() {
    this.assertNotDestroyed("Flush");
    await this._flushNow();
  }
  /**
  * It's best to avoid using this method as it doesn't really close a file.
  * We could update the _opened flag and add a guard like for destroyed, but this would break
  * the FileSystemFileHandle sharing required for browser tests to run, where writes are
  * not immediately visible if using different file handles.
  */
  async close() {
    await this._flushNow();
  }
  async destroy() {
    if (!this.destroyed) {
      await this._flushNow();
      this.destroyed = true;
      return await this._destroy();
    }
  }
  assertNotDestroyed(operation) {
    if (this.destroyed) {
      throw new Error(`${operation} on a destroyed or closed file`);
    }
  }
};
_ts_decorate([
  trace.info()
], WebFile.prototype, "fileName", void 0);
_ts_decorate([
  trace.metricsCounter()
], WebFile.prototype, "_flushes", void 0);
_ts_decorate([
  trace.metricsCounter()
], WebFile.prototype, "_operations", void 0);
_ts_decorate([
  trace.metricsCounter()
], WebFile.prototype, "_reads", void 0);
_ts_decorate([
  trace.metricsCounter()
], WebFile.prototype, "_readBytes", void 0);
_ts_decorate([
  trace.metricsCounter()
], WebFile.prototype, "_writes", void 0);
_ts_decorate([
  trace.metricsCounter()
], WebFile.prototype, "_writeBytes", void 0);
_ts_decorate([
  trace.info()
], WebFile.prototype, "_bufferSize", null);
_ts_decorate([
  synchronized
], WebFile.prototype, "destroy", null);

// packages/common/random-access-storage/src/browser/storage.ts
var createStorage = ({ type, root = "" } = {}) => {
  if (type === void 0) {
    return new IDbStorage(root);
  }
  switch (type) {
    case StorageType.RAM: {
      return new MemoryStorage(root);
    }
    case StorageType.IDB:
    case StorageType.CHROME:
    case StorageType.FIREFOX: {
      return new IDbStorage(root);
    }
    case StorageType.WEBFS: {
      return new WebFS(root);
    }
    default: {
      throw new Error(`Invalid type: ${type}`);
    }
  }
};
export {
  AbstractStorage,
  Directory,
  MemoryStorage,
  StorageType,
  createStorage,
  getFullPath,
  stringDiff,
  wrapFile
};
//# sourceMappingURL=index.mjs.map
