import { createRequire } from 'node:module';const require = createRequire(import.meta.url);

// packages/core/mesh/teleport-extension-gossip/src/gossip.ts
import { scheduleTask, Event, scheduleTaskInterval } from "@dxos/async";
import { Context } from "@dxos/context";
import { PublicKey } from "@dxos/keys";
import { log as log2 } from "@dxos/log";
import { RpcClosedError, TimeoutError } from "@dxos/protocols";
import { ComplexMap, ComplexSet } from "@dxos/util";

// packages/core/mesh/teleport-extension-gossip/src/gossip-extension.ts
import { Trigger } from "@dxos/async";
import { invariant } from "@dxos/invariant";
import { log } from "@dxos/log";
import { schema } from "@dxos/protocols/proto";
import { createProtoRpcPeer } from "@dxos/rpc";
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/core/mesh/teleport-extension-gossip/src/gossip-extension.ts";
var GossipExtension = class {
  constructor(_callbacks = {}) {
    this._callbacks = _callbacks;
    this._opened = new Trigger();
    this._closed = false;
  }
  async onOpen(context) {
    log("onOpen", {
      localPeerId: context.localPeerId,
      remotePeerId: context.remotePeerId
    }, {
      F: __dxlog_file,
      L: 37,
      S: this,
      C: (f, a) => f(...a)
    });
    this._rpc = createProtoRpcPeer({
      requested: {
        GossipService: schema.getService("dxos.mesh.teleport.gossip.GossipService")
      },
      exposed: {
        GossipService: schema.getService("dxos.mesh.teleport.gossip.GossipService")
      },
      handlers: {
        GossipService: {
          announce: async (message) => {
            log("received announce", {
              localPeerId: context.localPeerId,
              remotePeerId: context.remotePeerId,
              message
            }, {
              F: __dxlog_file,
              L: 49,
              S: this,
              C: (f, a) => f(...a)
            });
            await this._callbacks.onAnnounce?.(message);
          }
        }
      },
      port: await context.createPort("rpc", {
        contentType: 'application/x-protobuf; messageType="dxos.rpc.Message"'
      })
    });
    await this._rpc.open();
    this._opened.wake();
  }
  async onClose(err) {
    log("close", {
      err
    }, {
      F: __dxlog_file,
      L: 63,
      S: this,
      C: (f, a) => f(...a)
    });
    await this._rpc?.close();
    await this._callbacks.onClose?.(err);
    this._closed = true;
  }
  async onAbort(err) {
    log("abort", {
      err
    }, {
      F: __dxlog_file,
      L: 70,
      S: this,
      C: (f, a) => f(...a)
    });
    try {
      await this._rpc?.abort();
    } catch (err2) {
      log.catch(err2, void 0, {
        F: __dxlog_file,
        L: 74,
        S: this,
        C: (f, a) => f(...a)
      });
    } finally {
      await this._callbacks.onClose?.(err);
    }
    this._closed = true;
  }
  async sendAnnounce(message) {
    if (this._closed) {
      return;
    }
    await this._opened.wait();
    invariant(this._rpc, "RPC not initialized", {
      F: __dxlog_file,
      L: 86,
      S: this,
      A: [
        "this._rpc",
        "'RPC not initialized'"
      ]
    });
    await this._rpc.rpc.GossipService.announce(message);
  }
};

// packages/core/mesh/teleport-extension-gossip/src/gossip.ts
var __dxlog_file2 = "/home/runner/work/dxos/dxos/packages/core/mesh/teleport-extension-gossip/src/gossip.ts";
var RECEIVED_MESSAGES_GC_INTERVAL = 12e4;
var MAX_CTX_TASKS = 50;
var Gossip = class {
  constructor(_params) {
    this._params = _params;
    this._ctx = new Context({
      onError: (err) => {
        log2.catch(err, void 0, {
          F: __dxlog_file2,
          L: 32,
          S: this,
          C: (f, a) => f(...a)
        });
      }
    }, {
      F: __dxlog_file2,
      L: 30
    });
    this._listeners = /* @__PURE__ */ new Map();
    this._receivedMessages = new ComplexSet(PublicKey.hash);
    this._toClear = new ComplexSet(PublicKey.hash);
    this._connections = new ComplexMap(PublicKey.hash);
    this.connectionClosed = new Event();
  }
  get localPeerId() {
    return this._params.localPeerId;
  }
  async open() {
    scheduleTaskInterval(this._ctx, async () => {
      this._performGc();
    }, RECEIVED_MESSAGES_GC_INTERVAL);
  }
  async close() {
    await this._ctx.dispose();
  }
  getConnections() {
    return Array.from(this._connections.keys());
  }
  createExtension({ remotePeerId }) {
    const extension = new GossipExtension({
      onAnnounce: async (message) => {
        if (this._receivedMessages.has(message.messageId)) {
          return;
        }
        this._receivedMessages.add(message.messageId);
        this._callListeners(message);
        if (this._ctx.disposeCallbacksLength > MAX_CTX_TASKS) {
          log2(`skipping propagating gossip message due to exessive tasks (${MAX_CTX_TASKS})`, void 0, {
            F: __dxlog_file2,
            L: 84,
            S: this,
            C: (f, a) => f(...a)
          });
          return;
        }
        scheduleTask(this._ctx, async () => {
          await this._propagateAnnounce(message);
        });
      },
      onClose: async (err) => {
        if (this._connections.has(remotePeerId)) {
          this._connections.delete(remotePeerId);
        }
        this.connectionClosed.emit(remotePeerId);
      }
    });
    this._connections.set(remotePeerId, extension);
    return extension;
  }
  postMessage(channel, payload) {
    for (const extension of this._connections.values()) {
      this._sendAnnounceWithTimeoutTracking(extension, {
        peerId: this._params.localPeerId,
        messageId: PublicKey.random(),
        channelId: channel,
        timestamp: /* @__PURE__ */ new Date(),
        payload
      }).catch(async (err) => {
        if (err instanceof RpcClosedError) {
          log2("sendAnnounce failed because of RpcClosedError", {
            err
          }, {
            F: __dxlog_file2,
            L: 113,
            S: this,
            C: (f, a) => f(...a)
          });
        } else if (err instanceof TimeoutError || err.constructor.name === "TimeoutError" || err.message.startsWith("Timeout")) {
          log2("sendAnnounce failed because of TimeoutError", {
            err
          }, {
            F: __dxlog_file2,
            L: 119,
            S: this,
            C: (f, a) => f(...a)
          });
        } else {
          log2.catch(err, void 0, {
            F: __dxlog_file2,
            L: 121,
            S: this,
            C: (f, a) => f(...a)
          });
        }
      });
    }
  }
  listen(channel, callback) {
    if (!this._listeners.has(channel)) {
      this._listeners.set(channel, /* @__PURE__ */ new Set());
    }
    this._listeners.get(channel).add(callback);
    return {
      unsubscribe: () => {
        this._listeners.get(channel).delete(callback);
      }
    };
  }
  _callListeners(message) {
    if (this._listeners.has(message.channelId)) {
      this._listeners.get(message.channelId).forEach((callback) => {
        callback(message);
      });
    }
  }
  _propagateAnnounce(message) {
    return Promise.all([
      ...this._connections.entries()
    ].map(async ([remotePeerId, extension]) => {
      if (this._params.localPeerId.equals(message.peerId) || remotePeerId.equals(message.peerId)) {
        return;
      }
      return this._sendAnnounceWithTimeoutTracking(extension, message).catch((err) => log2(err, void 0, {
        F: __dxlog_file2,
        L: 154,
        S: this,
        C: (f, a) => f(...a)
      }));
    }));
  }
  _performGc() {
    const start = performance.now();
    for (const key of this._toClear.keys()) {
      this._receivedMessages.delete(key);
    }
    this._toClear.clear();
    for (const key of this._receivedMessages.keys()) {
      this._toClear.add(key);
    }
    const elapsed = performance.now() - start;
    if (elapsed > 100) {
      log2.warn("GC took too long", {
        elapsed
      }, {
        F: __dxlog_file2,
        L: 172,
        S: this,
        C: (f, a) => f(...a)
      });
    }
  }
  _sendAnnounceWithTimeoutTracking(extension, message) {
    return extension.sendAnnounce(message).catch((err) => {
    });
  }
};

// packages/core/mesh/teleport-extension-gossip/src/presence.ts
import { Event as Event2, scheduleTaskInterval as scheduleTaskInterval2 } from "@dxos/async";
import { Resource } from "@dxos/context";
import { invariant as invariant2 } from "@dxos/invariant";
import { PublicKey as PublicKey2 } from "@dxos/keys";
import { log as log3 } from "@dxos/log";
import { ComplexMap as ComplexMap2 } from "@dxos/util";
var __dxlog_file3 = "/home/runner/work/dxos/dxos/packages/core/mesh/teleport-extension-gossip/src/presence.ts";
var PRESENCE_CHANNEL_ID = "dxos.mesh.presence.Presence";
var Presence = class extends Resource {
  // remotePeerId -> PresenceExtension
  constructor(_params) {
    super(), this._params = _params, this.updated = new Event2(), this.newPeer = new Event2(), this._peerStates = new ComplexMap2(PublicKey2.hash), this._peersByIdentityKey = new ComplexMap2(PublicKey2.hash), this._isOnline = (message) => {
      return message.timestamp.getTime() > Date.now() - this._params.offlineTimeout;
    };
    invariant2(this._params.announceInterval < this._params.offlineTimeout, "Announce interval should be less than offline timeout.", {
      F: __dxlog_file3,
      L: 55,
      S: this,
      A: [
        "this._params.announceInterval < this._params.offlineTimeout",
        "'Announce interval should be less than offline timeout.'"
      ]
    });
    this._params.gossip.listen(PRESENCE_CHANNEL_ID, (message) => {
      this._receiveAnnounces(message);
    });
  }
  async _open() {
    scheduleTaskInterval2(this._ctx, async () => {
      const peerState = {
        "@type": "dxos.mesh.presence.PeerState",
        identityKey: this._params.identityKey,
        connections: this._params.gossip.getConnections()
      };
      this._params.gossip.postMessage(PRESENCE_CHANNEL_ID, peerState);
    }, this._params.announceInterval);
    scheduleTaskInterval2(this._ctx, async () => {
      this.updated.emit();
    }, this._params.offlineTimeout);
    this._params.gossip.connectionClosed.on(this._ctx, (peerId) => {
      const peerState = this._peerStates.get(peerId);
      if (peerState != null) {
        this._peerStates.delete(peerId);
        this._removePeerFromIdentityKeyIndex(peerState);
        this.updated.emit();
      }
    });
  }
  async _catch(err) {
    log3.catch(err, void 0, {
      F: __dxlog_file3,
      L: 101,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  getPeers() {
    return Array.from(this._peerStates.values()).map((message) => message.payload);
  }
  getPeersByIdentityKey(key) {
    return (this._peersByIdentityKey.get(key) ?? []).filter(this._isOnline).map((m) => m.payload);
  }
  getPeersOnline() {
    return Array.from(this._peerStates.values()).filter(this._isOnline).map((message) => message.payload);
  }
  getLocalState() {
    return {
      identityKey: this._params.identityKey,
      connections: this._params.gossip.getConnections(),
      peerId: this._params.gossip.localPeerId
    };
  }
  _receiveAnnounces(message) {
    invariant2(message.channelId === PRESENCE_CHANNEL_ID, `Invalid channel ID: ${message.channelId}`, {
      F: __dxlog_file3,
      L: 131,
      S: this,
      A: [
        "message.channelId === PRESENCE_CHANNEL_ID",
        "`Invalid channel ID: ${message.channelId}`"
      ]
    });
    const oldPeerState = this._peerStates.get(message.peerId);
    if (!oldPeerState || oldPeerState.timestamp.getTime() < message.timestamp.getTime()) {
      message.payload.peerId = message.peerId;
      this._peerStates.set(message.peerId, message);
      this._updatePeerInIdentityKeyIndex(message);
      this.updated.emit();
    }
  }
  _removePeerFromIdentityKeyIndex(peerState) {
    const identityPeerList = this._peersByIdentityKey.get(peerState.payload.identityKey) ?? [];
    const peerIdIndex = identityPeerList.findIndex((id) => id.peerId?.equals(peerState.peerId));
    if (peerIdIndex >= 0) {
      identityPeerList.splice(peerIdIndex, 1);
    }
  }
  _updatePeerInIdentityKeyIndex(newState) {
    const identityKey = newState.payload.identityKey;
    const identityKeyPeers = this._peersByIdentityKey.get(identityKey) ?? [];
    const existingIndex = identityKeyPeers.findIndex((p) => p.peerId && newState.peerId?.equals(p.peerId));
    if (existingIndex >= 0) {
      const oldState = identityKeyPeers.splice(existingIndex, 1, newState)[0];
      if (!this._isOnline(oldState)) {
        this.newPeer.emit(newState.payload);
      }
    } else {
      this._peersByIdentityKey.set(identityKey, identityKeyPeers);
      identityKeyPeers.push(newState);
      this.newPeer.emit(newState.payload);
    }
  }
};
export {
  Gossip,
  GossipExtension,
  Presence
};
//# sourceMappingURL=index.mjs.map
