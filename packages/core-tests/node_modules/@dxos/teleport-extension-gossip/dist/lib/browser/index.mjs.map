{
  "version": 3,
  "sources": ["../../../src/gossip.ts", "../../../src/gossip-extension.ts", "../../../src/presence.ts"],
  "sourcesContent": ["//\n// Copyright 2023 DXOS.org\n//\n\nimport { scheduleTask, Event, scheduleTaskInterval } from '@dxos/async';\nimport { Context } from '@dxos/context';\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { RpcClosedError, TimeoutError } from '@dxos/protocols';\nimport { type GossipMessage } from '@dxos/protocols/proto/dxos/mesh/teleport/gossip';\nimport { ComplexMap, ComplexSet } from '@dxos/util';\n\nimport { GossipExtension } from './gossip-extension';\n\nexport type GossipParams = {\n  localPeerId: PublicKey;\n};\n\nconst RECEIVED_MESSAGES_GC_INTERVAL = 120_000;\n\nconst MAX_CTX_TASKS = 50;\n\n/**\n * Gossip extensions manager.\n * Keeps track of all peers that are connected to the local peer.\n * Routes received announces to all connected peers.\n * Exposes API send announce to everybody and subscribe to .\n */\nexport class Gossip {\n  private readonly _ctx = new Context({\n    onError: (err) => {\n      log.catch(err);\n    },\n  });\n\n  private readonly _listeners = new Map<string, Set<(message: GossipMessage) => void>>();\n\n  private readonly _receivedMessages = new ComplexSet<PublicKey>(PublicKey.hash);\n\n  /**\n   * Keys scheduled to be cleared from _receivedMessages on the next iteration.\n   */\n  private readonly _toClear = new ComplexSet<PublicKey>(PublicKey.hash);\n\n  // remotePeerId -> PresenceExtension\n  private readonly _connections = new ComplexMap<PublicKey, GossipExtension>(PublicKey.hash);\n\n  public readonly connectionClosed = new Event<PublicKey>();\n\n  constructor(private readonly _params: GossipParams) {}\n\n  get localPeerId() {\n    return this._params.localPeerId;\n  }\n\n  async open(): Promise<void> {\n    // Clear the map periodically.\n    scheduleTaskInterval(\n      this._ctx,\n      async () => {\n        this._performGc();\n      },\n      RECEIVED_MESSAGES_GC_INTERVAL,\n    );\n  }\n\n  async close(): Promise<void> {\n    await this._ctx.dispose();\n  }\n\n  getConnections() {\n    return Array.from(this._connections.keys());\n  }\n\n  createExtension({ remotePeerId }: { remotePeerId: PublicKey }): GossipExtension {\n    const extension = new GossipExtension({\n      onAnnounce: async (message) => {\n        if (this._receivedMessages.has(message.messageId)) {\n          return;\n        }\n        this._receivedMessages.add(message.messageId);\n        this._callListeners(message);\n        if (this._ctx.disposeCallbacksLength > MAX_CTX_TASKS) {\n          log(`skipping propagating gossip message due to exessive tasks (${MAX_CTX_TASKS})`);\n          return;\n        }\n        scheduleTask(this._ctx, async () => {\n          await this._propagateAnnounce(message);\n        });\n      },\n      onClose: async (err) => {\n        if (this._connections.has(remotePeerId)) {\n          this._connections.delete(remotePeerId);\n        }\n        this.connectionClosed.emit(remotePeerId);\n      },\n    });\n    this._connections.set(remotePeerId, extension);\n\n    return extension;\n  }\n\n  postMessage(channel: string, payload: any): void {\n    for (const extension of this._connections.values()) {\n      this._sendAnnounceWithTimeoutTracking(extension, {\n        peerId: this._params.localPeerId,\n        messageId: PublicKey.random(),\n        channelId: channel,\n        timestamp: new Date(),\n        payload,\n      }).catch(async (err) => {\n        if (err instanceof RpcClosedError) {\n          log('sendAnnounce failed because of RpcClosedError', { err });\n        } else if (\n          err instanceof TimeoutError ||\n          err.constructor.name === 'TimeoutError' ||\n          err.message.startsWith('Timeout')\n        ) {\n          log('sendAnnounce failed because of TimeoutError', { err });\n        } else {\n          log.catch(err);\n        }\n      });\n    }\n  }\n\n  listen(channel: string, callback: (message: GossipMessage) => void): { unsubscribe: () => void } {\n    if (!this._listeners.has(channel)) {\n      this._listeners.set(channel, new Set());\n    }\n    this._listeners.get(channel)!.add(callback);\n\n    return {\n      unsubscribe: () => {\n        this._listeners.get(channel)!.delete(callback);\n      },\n    };\n  }\n\n  private _callListeners(message: GossipMessage): void {\n    if (this._listeners.has(message.channelId)) {\n      this._listeners.get(message.channelId)!.forEach((callback) => {\n        callback(message);\n      });\n    }\n  }\n\n  private _propagateAnnounce(message: GossipMessage): Promise<void[]> {\n    return Promise.all(\n      [...this._connections.entries()].map(async ([remotePeerId, extension]) => {\n        if (this._params.localPeerId.equals(message.peerId) || remotePeerId.equals(message.peerId)) {\n          return;\n        }\n        return this._sendAnnounceWithTimeoutTracking(extension, message).catch((err) => log(err));\n      }),\n    );\n  }\n\n  private _performGc(): void {\n    const start = performance.now();\n\n    for (const key of this._toClear.keys()) {\n      this._receivedMessages.delete(key);\n    }\n    this._toClear.clear();\n    for (const key of this._receivedMessages.keys()) {\n      this._toClear.add(key);\n    }\n\n    const elapsed = performance.now() - start;\n    if (elapsed > 100) {\n      log.warn('GC took too long', { elapsed });\n    }\n  }\n\n  private _sendAnnounceWithTimeoutTracking(extension: GossipExtension, message: GossipMessage): Promise<void> {\n    return extension.sendAnnounce(message).catch((err) => {\n      // Noop?\n    });\n  }\n}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { Trigger } from '@dxos/async';\nimport { invariant } from '@dxos/invariant';\nimport { log } from '@dxos/log';\nimport { schema } from '@dxos/protocols/proto';\nimport { type GossipMessage, type GossipService } from '@dxos/protocols/proto/dxos/mesh/teleport/gossip';\nimport { createProtoRpcPeer, type ProtoRpcPeer } from '@dxos/rpc';\nimport { type ExtensionContext, type TeleportExtension } from '@dxos/teleport';\n\nexport type GossipCallbacks = {\n  /**\n   * Callback to be called when a new announce is received.\n   */\n  onAnnounce?: (message: GossipMessage) => Promise<void>;\n\n  /**\n   * Callback to be called when the extension is closed.\n   */\n  onClose?: (err?: Error) => Promise<void>;\n};\n\n/**\n * Sends announces between two peers for a single teleport session.\n */\nexport class GossipExtension implements TeleportExtension {\n  private readonly _opened = new Trigger();\n  private _closed = false;\n\n  private _rpc?: ProtoRpcPeer<ServiceBundle>;\n\n  constructor(private readonly _callbacks: GossipCallbacks = {}) {}\n\n  async onOpen(context: ExtensionContext): Promise<void> {\n    log('onOpen', { localPeerId: context.localPeerId, remotePeerId: context.remotePeerId });\n\n    this._rpc = createProtoRpcPeer<ServiceBundle, ServiceBundle>({\n      requested: {\n        GossipService: schema.getService('dxos.mesh.teleport.gossip.GossipService'),\n      },\n      exposed: {\n        GossipService: schema.getService('dxos.mesh.teleport.gossip.GossipService'),\n      },\n      handlers: {\n        GossipService: {\n          announce: async (message: GossipMessage) => {\n            log('received announce', { localPeerId: context.localPeerId, remotePeerId: context.remotePeerId, message });\n            await this._callbacks.onAnnounce?.(message);\n          },\n        },\n      },\n      port: await context.createPort('rpc', {\n        contentType: 'application/x-protobuf; messageType=\"dxos.rpc.Message\"',\n      }),\n    });\n    await this._rpc.open();\n    this._opened.wake();\n  }\n\n  async onClose(err?: Error): Promise<void> {\n    log('close', { err });\n    await this._rpc?.close();\n    await this._callbacks.onClose?.(err);\n    this._closed = true;\n  }\n\n  async onAbort(err?: Error): Promise<void> {\n    log('abort', { err });\n    try {\n      await this._rpc?.abort();\n    } catch (err) {\n      log.catch(err);\n    } finally {\n      await this._callbacks.onClose?.(err);\n    }\n    this._closed = true;\n  }\n\n  async sendAnnounce(message: GossipMessage): Promise<void> {\n    if (this._closed) {\n      return;\n    }\n    await this._opened.wait();\n    invariant(this._rpc, 'RPC not initialized');\n    await this._rpc.rpc.GossipService.announce(message);\n  }\n}\n\ntype ServiceBundle = {\n  GossipService: GossipService;\n};\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { Event, scheduleTaskInterval } from '@dxos/async';\nimport { type WithTypeUrl } from '@dxos/codec-protobuf';\nimport { Resource } from '@dxos/context';\nimport { invariant } from '@dxos/invariant';\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { type PeerState } from '@dxos/protocols/proto/dxos/mesh/presence';\nimport { type GossipMessage } from '@dxos/protocols/proto/dxos/mesh/teleport/gossip';\nimport { ComplexMap } from '@dxos/util';\n\nimport { type Gossip } from './gossip';\n\nexport type PresenceParams = {\n  /**\n   * Interval between presence announces.\n   */\n  announceInterval: number;\n  /**\n   * Timeout after which a peer is considered offline.\n   * Should be greater than announceInterval.\n   */\n  offlineTimeout: number;\n\n  /**\n   * Identity key of the local peer.\n   */\n  identityKey: PublicKey; // TODO(mykola): Remove once IdentityKey can be obtained from DeviceKey.\n\n  gossip: Gossip;\n};\n\nconst PRESENCE_CHANNEL_ID = 'dxos.mesh.presence.Presence';\n\n/**\n * Presence manager.\n * Keeps track of all peers that are connected to the local peer.\n * Routes received presence announces to all connected peers.\n * Exposes API to get the list of peers that are online.\n */\nexport class Presence extends Resource {\n  public readonly updated = new Event<void>();\n  public readonly newPeer = new Event<PeerState>();\n\n  private readonly _peerStates = new ComplexMap<PublicKey, GossipMessage>(PublicKey.hash);\n  private readonly _peersByIdentityKey = new ComplexMap<PublicKey, GossipMessage[]>(PublicKey.hash);\n\n  // remotePeerId -> PresenceExtension\n\n  constructor(private readonly _params: PresenceParams) {\n    super();\n    invariant(\n      this._params.announceInterval < this._params.offlineTimeout,\n      'Announce interval should be less than offline timeout.',\n    );\n\n    this._params.gossip.listen(PRESENCE_CHANNEL_ID, (message) => {\n      this._receiveAnnounces(message);\n    });\n  }\n\n  protected override async _open(): Promise<void> {\n    // Send announce to all connected peers.\n    scheduleTaskInterval(\n      this._ctx,\n      async () => {\n        const peerState: WithTypeUrl<PeerState> = {\n          '@type': 'dxos.mesh.presence.PeerState',\n          identityKey: this._params.identityKey,\n          connections: this._params.gossip.getConnections(),\n        };\n        this._params.gossip.postMessage(PRESENCE_CHANNEL_ID, peerState);\n      },\n      this._params.announceInterval,\n    );\n\n    // Emit updated event in case some peers went offline.\n    scheduleTaskInterval(\n      this._ctx,\n      async () => {\n        this.updated.emit();\n      },\n      this._params.offlineTimeout,\n    );\n\n    // Remove peer state when connection is closed.\n    this._params.gossip.connectionClosed.on(this._ctx, (peerId) => {\n      const peerState = this._peerStates.get(peerId);\n      if (peerState != null) {\n        this._peerStates.delete(peerId);\n        this._removePeerFromIdentityKeyIndex(peerState);\n        this.updated.emit();\n      }\n    });\n  }\n\n  protected override async _catch(err: Error): Promise<void> {\n    log.catch(err);\n  }\n\n  getPeers(): PeerState[] {\n    return Array.from(this._peerStates.values()).map((message) => message.payload);\n  }\n\n  getPeersByIdentityKey(key: PublicKey): PeerState[] {\n    return (this._peersByIdentityKey.get(key) ?? []).filter(this._isOnline).map((m) => m.payload);\n  }\n\n  getPeersOnline(): PeerState[] {\n    return Array.from(this._peerStates.values())\n      .filter(this._isOnline)\n      .map((message) => message.payload);\n  }\n\n  private _isOnline = (message: GossipMessage): boolean => {\n    return message.timestamp.getTime() > Date.now() - this._params.offlineTimeout;\n  };\n\n  getLocalState(): PeerState {\n    return {\n      identityKey: this._params.identityKey,\n      connections: this._params.gossip.getConnections(),\n      peerId: this._params.gossip.localPeerId,\n    };\n  }\n\n  private _receiveAnnounces(message: GossipMessage): void {\n    invariant(message.channelId === PRESENCE_CHANNEL_ID, `Invalid channel ID: ${message.channelId}`);\n    const oldPeerState = this._peerStates.get(message.peerId);\n    if (!oldPeerState || oldPeerState.timestamp.getTime() < message.timestamp.getTime()) {\n      // Assign peer id to payload.\n      (message.payload as PeerState).peerId = message.peerId;\n\n      this._peerStates.set(message.peerId, message);\n      this._updatePeerInIdentityKeyIndex(message);\n      this.updated.emit();\n    }\n  }\n\n  private _removePeerFromIdentityKeyIndex(peerState: GossipMessage): void {\n    const identityPeerList = this._peersByIdentityKey.get((peerState.payload as PeerState).identityKey) ?? [];\n    const peerIdIndex = identityPeerList.findIndex((id) => id.peerId?.equals(peerState.peerId));\n    if (peerIdIndex >= 0) {\n      identityPeerList.splice(peerIdIndex, 1);\n    }\n  }\n\n  private _updatePeerInIdentityKeyIndex(newState: GossipMessage): void {\n    const identityKey = (newState.payload as PeerState).identityKey;\n    const identityKeyPeers = this._peersByIdentityKey.get(identityKey) ?? [];\n    const existingIndex = identityKeyPeers.findIndex((p) => p.peerId && newState.peerId?.equals(p.peerId));\n    if (existingIndex >= 0) {\n      const oldState = identityKeyPeers.splice(existingIndex, 1, newState)[0];\n      if (!this._isOnline(oldState)) {\n        this.newPeer.emit(newState.payload);\n      }\n    } else {\n      this._peersByIdentityKey.set(identityKey, identityKeyPeers);\n      identityKeyPeers.push(newState);\n      this.newPeer.emit(newState.payload);\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": ["scheduleTask", "Event", "scheduleTaskInterval", "Context", "PublicKey", "log", "RpcClosedError", "TimeoutError", "ComplexMap", "ComplexSet", "Trigger", "invariant", "log", "schema", "createProtoRpcPeer", "GossipExtension", "_callbacks", "_opened", "_closed", "onOpen", "context", "localPeerId", "remotePeerId", "_rpc", "requested", "GossipService", "getService", "exposed", "handlers", "announce", "message", "onAnnounce", "port", "createPort", "contentType", "open", "wake", "onClose", "err", "close", "onAbort", "abort", "catch", "sendAnnounce", "wait", "rpc", "RECEIVED_MESSAGES_GC_INTERVAL", "MAX_CTX_TASKS", "Gossip", "_params", "_ctx", "Context", "onError", "err", "log", "catch", "_listeners", "Map", "_receivedMessages", "ComplexSet", "PublicKey", "hash", "_toClear", "_connections", "ComplexMap", "connectionClosed", "Event", "localPeerId", "open", "scheduleTaskInterval", "_performGc", "close", "dispose", "getConnections", "Array", "from", "keys", "createExtension", "remotePeerId", "extension", "GossipExtension", "onAnnounce", "message", "has", "messageId", "add", "_callListeners", "disposeCallbacksLength", "scheduleTask", "_propagateAnnounce", "onClose", "delete", "emit", "set", "postMessage", "channel", "payload", "values", "_sendAnnounceWithTimeoutTracking", "peerId", "random", "channelId", "timestamp", "Date", "RpcClosedError", "TimeoutError", "name", "startsWith", "listen", "callback", "Set", "get", "unsubscribe", "forEach", "Promise", "all", "entries", "map", "equals", "start", "performance", "now", "key", "clear", "elapsed", "warn", "sendAnnounce", "Event", "scheduleTaskInterval", "Resource", "invariant", "PublicKey", "log", "ComplexMap", "PRESENCE_CHANNEL_ID", "Presence", "_params", "updated", "newPeer", "_peerStates", "hash", "_peersByIdentityKey", "_isOnline", "message", "timestamp", "getTime", "Date", "now", "offlineTimeout", "announceInterval", "gossip", "listen", "_receiveAnnounces", "_open", "_ctx", "peerState", "identityKey", "connections", "getConnections", "postMessage", "emit", "connectionClosed", "on", "peerId", "get", "delete", "_removePeerFromIdentityKeyIndex", "_catch", "err", "catch", "getPeers", "Array", "from", "values", "map", "payload", "getPeersByIdentityKey", "key", "filter", "m", "getPeersOnline", "getLocalState", "localPeerId", "channelId", "oldPeerState", "set", "_updatePeerInIdentityKeyIndex", "identityPeerList", "peerIdIndex", "findIndex", "id", "equals", "splice", "newState", "identityKeyPeers", "existingIndex", "p", "oldState", "push"]
}
