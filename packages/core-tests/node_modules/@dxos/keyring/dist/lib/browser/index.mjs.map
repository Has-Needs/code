{
  "version": 3,
  "sources": ["../../../src/keyring.ts", "../../../src/testing.ts"],
  "sourcesContent": ["//\n// Copyright 2022 DXOS.org\n//\n\nimport { Event, synchronized } from '@dxos/async';\nimport { type ProtoCodec } from '@dxos/codec-protobuf';\nimport { subtleCrypto, type Signer } from '@dxos/crypto';\nimport { todo } from '@dxos/debug';\nimport { invariant } from '@dxos/invariant';\nimport { PublicKey } from '@dxos/keys';\nimport { schema } from '@dxos/protocols/proto';\nimport { type KeyRecord } from '@dxos/protocols/proto/dxos/halo/keyring';\nimport { createStorage, type Directory, StorageType } from '@dxos/random-access-storage';\nimport { ComplexMap, arrayToBuffer } from '@dxos/util';\n\nconst KeyRecord: ProtoCodec<KeyRecord> = schema.getCodecForType('dxos.halo.keyring.KeyRecord');\n\n/**\n * Manages keys.\n */\nexport class Keyring implements Signer {\n  private readonly _keyCache = new ComplexMap<PublicKey, CryptoKeyPair>(PublicKey.hash);\n  readonly keysUpdate = new Event();\n\n  constructor(\n    private readonly _storage: Directory = createStorage({\n      type: StorageType.RAM,\n    }).createDirectory('keyring'),\n  ) {\n    invariant(subtleCrypto, 'SubtleCrypto not available in this environment.');\n  }\n\n  async sign(key: PublicKey, message: Uint8Array): Promise<Uint8Array> {\n    const keyPair = await this._getKey(key);\n\n    return new Uint8Array(\n      await subtleCrypto.sign(\n        {\n          name: 'ECDSA',\n          hash: 'SHA-256',\n        },\n        keyPair.privateKey,\n        message,\n      ),\n    );\n  }\n\n  async createKey(): Promise<PublicKey> {\n    const keyPair = await subtleCrypto.generateKey(\n      {\n        name: 'ECDSA',\n        namedCurve: 'P-256',\n      },\n      true,\n      ['sign', 'verify'],\n    );\n\n    await this._setKey(keyPair);\n\n    return keyPairToPublicKey(keyPair);\n  }\n\n  @synchronized\n  private async _getKey(key: PublicKey): Promise<CryptoKeyPair> {\n    if (!this._keyCache.has(key)) {\n      const file = this._storage.getOrCreateFile(key.toHex());\n      const { size } = await file.stat();\n      if (size === 0) {\n        throw new Error(`Key not found: ${key.toHex()}`);\n      }\n\n      const recordBytes = await file.read(0, size);\n      await file.close();\n\n      const record = KeyRecord.decode(recordBytes);\n      const publicKey = PublicKey.from(record.publicKey);\n      invariant(key.equals(publicKey), 'Corrupted keyring: Key mismatch');\n      invariant(record.privateKey, 'Corrupted keyring: Missing private key');\n      const keyPair: CryptoKeyPair = {\n        publicKey: await subtleCrypto.importKey(\n          'raw',\n          record.publicKey,\n          {\n            name: 'ECDSA',\n            namedCurve: 'P-256',\n          },\n          true,\n          ['verify'],\n        ),\n        privateKey: await subtleCrypto.importKey(\n          'pkcs8',\n          record.privateKey,\n          {\n            name: 'ECDSA',\n            namedCurve: 'P-256',\n          },\n          true,\n          ['sign'],\n        ),\n      };\n\n      this._keyCache.set(publicKey, keyPair);\n    }\n\n    return this._keyCache.get(key)!; // TODO(burdon): Fail if null?\n  }\n\n  @synchronized\n  private async _setKey(keyPair: CryptoKeyPair): Promise<void> {\n    const publicKey = await keyPairToPublicKey(keyPair);\n    this._keyCache.set(publicKey, keyPair);\n\n    const record: KeyRecord = {\n      publicKey: publicKey.asUint8Array(),\n      privateKey: new Uint8Array(await subtleCrypto.exportKey('pkcs8', keyPair.privateKey)),\n    };\n\n    const file = this._storage.getOrCreateFile(publicKey.toHex());\n    await file.write(0, arrayToBuffer(KeyRecord.encode(record)));\n    await file.close();\n    await file.flush?.();\n    this.keysUpdate.emit();\n  }\n\n  // TODO(burdon): ???\n  deleteKey(key: PublicKey): Promise<void> {\n    return todo('We need a method to delete a file.');\n  }\n\n  async list(): Promise<KeyRecord[]> {\n    const keys: KeyRecord[] = [];\n    for (const path of await this._storage.list()) {\n      const fileName = path.split('/').pop(); // get last portion of the path\n      invariant(fileName, 'Invalid file name');\n      keys.push({ publicKey: PublicKey.fromHex(fileName).asUint8Array() });\n    }\n    return keys;\n  }\n\n  async importKeyPair(keyPair: CryptoKeyPair): Promise<PublicKey> {\n    await this._setKey(keyPair);\n    return keyPairToPublicKey(keyPair);\n  }\n}\n\nconst keyPairToPublicKey = async (keyPair: CryptoKeyPair): Promise<PublicKey> => {\n  return PublicKey.from(new Uint8Array(await subtleCrypto.exportKey('raw', keyPair.publicKey)));\n};\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { subtleCrypto } from '@dxos/crypto';\n\nexport type TestKeyPair = {\n  privateKey: JsonWebKey;\n  publicKey: JsonWebKey;\n  publicKeyHex: string;\n};\n\n/**\n * Generate a key pair which for testing purposes.\n * @returns {Promise<TestKeyPair>}\n */\nexport const generateJWKKeyPair = async (): Promise<TestKeyPair> => {\n  const keyPair = await subtleCrypto.generateKey(\n    {\n      name: 'ECDSA',\n      namedCurve: 'P-256',\n    },\n    true,\n    ['sign', 'verify'],\n  );\n\n  const privateKeyExported = await subtleCrypto.exportKey('jwk', keyPair.privateKey);\n  const publicKeyExported = await subtleCrypto.exportKey('jwk', keyPair.publicKey);\n\n  // Convert the public key to hex format\n  const publicKeyBuffer = new Uint8Array(await subtleCrypto.exportKey('raw', keyPair.publicKey));\n  const publicKeyHex = Array.from(publicKeyBuffer)\n    .map((byte) => byte.toString(16).padStart(2, '0'))\n    .join('');\n\n  return {\n    privateKey: privateKeyExported,\n    publicKey: publicKeyExported,\n    publicKeyHex,\n  };\n};\n\n/**\n * Parse a key pair from JWK format.\n */\nexport const parseJWKKeyPair = async (privateKey: JsonWebKey, publicKey: JsonWebKey): Promise<CryptoKeyPair> => {\n  return {\n    privateKey: await subtleCrypto.importKey('jwk', privateKey, { name: 'ECDSA', namedCurve: 'P-256' }, true, ['sign']),\n    publicKey: await subtleCrypto.importKey('jwk', publicKey, { name: 'ECDSA', namedCurve: 'P-256' }, true, ['verify']),\n  };\n};\n"],
  "mappings": "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",
  "names": ["Event", "synchronized", "subtleCrypto", "todo", "invariant", "PublicKey", "schema", "createStorage", "StorageType", "ComplexMap", "arrayToBuffer", "KeyRecord", "getCodecForType", "Keyring", "_storage", "type", "RAM", "createDirectory", "_keyCache", "hash", "keysUpdate", "sign", "key", "message", "keyPair", "_getKey", "Uint8Array", "name", "privateKey", "createKey", "generateKey", "namedCurve", "_setKey", "keyPairToPublicKey", "has", "file", "getOrCreateFile", "toHex", "size", "stat", "Error", "recordBytes", "read", "close", "record", "decode", "publicKey", "from", "equals", "importKey", "set", "get", "asUint8Array", "exportKey", "write", "encode", "flush", "emit", "deleteKey", "list", "keys", "path", "fileName", "split", "pop", "push", "fromHex", "importKeyPair", "subtleCrypto", "generateJWKKeyPair", "keyPair", "subtleCrypto", "generateKey", "name", "namedCurve", "privateKeyExported", "exportKey", "privateKey", "publicKeyExported", "publicKey", "publicKeyBuffer", "Uint8Array", "publicKeyHex", "Array", "from", "map", "byte", "toString", "padStart", "join", "parseJWKKeyPair", "importKey"]
}
