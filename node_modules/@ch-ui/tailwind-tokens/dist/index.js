// packages/tailwind-tokens/src/index.ts
import {
  facetSemanticValues,
  resolveNaming,
  resolveDefinition,
  seriesValues,
  variableNameFromValue,
  nameFromValue
} from "@ch-ui/tokens";
var defaultAdapterConfig = {};
var renderPhysicalMappings = (config, {
  conditions,
  series,
  namespace,
  definitions: layerDefinitions = {}
}, semanticValues, ...ancestorDefinitions) => Object.entries(conditions).reduce(
  (acc, [conditionId, _statements]) => Object.entries(series).reduce(
    (acc2, [seriesId, { [conditionId]: series2 }]) => {
      const resolvedSeries = resolveDefinition(
        series2,
        "series",
        () => true,
        layerDefinitions,
        ...ancestorDefinitions
      );
      const resolvedNaming = resolveNaming(resolvedSeries.naming);
      const tokenization = config.tokenization ?? "keep-series";
      const separator = config.seriesValueSeparator ?? "-";
      if (tokenization === "recursive") {
        acc2[seriesId] = Array.from(
          seriesValues(resolvedSeries, semanticValues?.[seriesId]).keys()
        ).reduce((acc3, value) => {
          acc3[`${nameFromValue(value, resolvedNaming)}`] = `var(${variableNameFromValue(
            value,
            resolvedNaming,
            seriesId,
            namespace
          )})`;
          return acc3;
        }, {});
      } else {
        acc2 = {
          ...acc2,
          ...Array.from(
            seriesValues(series2, semanticValues?.[seriesId]).keys()
          ).reduce((acc3, value) => {
            const tokenName = tokenization === "keep-series" ? `${seriesId}${separator}${nameFromValue(
              value,
              resolvedNaming
            )}` : nameFromValue(value, resolvedNaming);
            acc3[tokenName] = `var(${variableNameFromValue(
              value,
              resolvedNaming,
              seriesId,
              namespace
            )})`;
            return acc3;
          }, {})
        };
      }
      return acc2;
    },
    acc
  ),
  {}
);
var renderSemanticMappings = (config, semantic) => {
  if (!semantic) {
    return {};
  } else {
    const { conditions, sememes, namespace } = semantic;
    return Object.entries(conditions).reduce(
      (acc, [conditionId, statements]) => Object.keys(sememes).reduce((acc2, sememeName) => {
        acc2[sememeName] = `var(--${namespace}${sememeName})`;
        return acc2;
      }, acc),
      {}
    );
  }
};
var renderAliasMappings = (config, alias) => {
  if (!alias) {
    return {};
  } else {
    const { namespace, aliases } = alias;
    return Object.entries(aliases).reduce(
      (acc, [sememeName, sememeAliases]) => {
        return Object.entries(sememeAliases).reduce(
          (acc2, [conditionId, aliasNames]) => {
            return aliasNames.reduce((acc3, aliasName) => {
              acc3[aliasName] = `var(--${namespace}${aliasName})`;
              return acc3;
            }, acc2);
          },
          acc
        );
      },
      {}
    );
  }
};
var renderTailwindFacet = (config, { physical, semantic, alias, definitions: facetDefinitions = {} }) => {
  const semanticValues = facetSemanticValues(semantic);
  return {
    ...renderPhysicalMappings(
      config,
      physical,
      semanticValues,
      facetDefinitions
    ),
    ...renderSemanticMappings(config, semantic),
    ...renderAliasMappings(config, alias)
  };
};
var src_default = (tokensConfig, adapterConfig = defaultAdapterConfig) => Object.entries(adapterConfig).reduce(
  (acc, entry) => {
    const [twKey, config] = entry;
    if (config.facet in tokensConfig) {
      const twFacet = renderTailwindFacet(config, tokensConfig[config.facet]);
      if (config.disposition === "extend") {
        acc.extend ??= {};
        acc.extend[twKey] = twFacet;
      } else {
        acc[twKey] = twFacet;
      }
    }
    return acc;
  },
  {}
);
export {
  src_default as default
};
//# sourceMappingURL=index.js.map
