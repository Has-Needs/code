"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// packages/tailwind-tokens/src/index.ts
var src_exports = {};
__export(src_exports, {
  default: () => src_default
});
module.exports = __toCommonJS(src_exports);
var import_tokens = require("@ch-ui/tokens");
var defaultAdapterConfig = {};
var renderPhysicalMappings = (config, {
  conditions,
  series,
  namespace,
  definitions: layerDefinitions = {}
}, semanticValues, ...ancestorDefinitions) => Object.entries(conditions).reduce(
  (acc, [conditionId, _statements]) => Object.entries(series).reduce(
    (acc2, [seriesId, { [conditionId]: series2 }]) => {
      const resolvedSeries = (0, import_tokens.resolveDefinition)(
        series2,
        "series",
        () => true,
        layerDefinitions,
        ...ancestorDefinitions
      );
      const resolvedNaming = (0, import_tokens.resolveNaming)(resolvedSeries.naming);
      const tokenization = config.tokenization ?? "keep-series";
      const separator = config.seriesValueSeparator ?? "-";
      if (tokenization === "recursive") {
        acc2[seriesId] = Array.from(
          (0, import_tokens.seriesValues)(resolvedSeries, semanticValues?.[seriesId]).keys()
        ).reduce((acc3, value) => {
          acc3[`${(0, import_tokens.nameFromValue)(value, resolvedNaming)}`] = `var(${(0, import_tokens.variableNameFromValue)(
            value,
            resolvedNaming,
            seriesId,
            namespace
          )})`;
          return acc3;
        }, {});
      } else {
        acc2 = {
          ...acc2,
          ...Array.from(
            (0, import_tokens.seriesValues)(series2, semanticValues?.[seriesId]).keys()
          ).reduce((acc3, value) => {
            const tokenName = tokenization === "keep-series" ? `${seriesId}${separator}${(0, import_tokens.nameFromValue)(
              value,
              resolvedNaming
            )}` : (0, import_tokens.nameFromValue)(value, resolvedNaming);
            acc3[tokenName] = `var(${(0, import_tokens.variableNameFromValue)(
              value,
              resolvedNaming,
              seriesId,
              namespace
            )})`;
            return acc3;
          }, {})
        };
      }
      return acc2;
    },
    acc
  ),
  {}
);
var renderSemanticMappings = (config, semantic) => {
  if (!semantic) {
    return {};
  } else {
    const { conditions, sememes, namespace } = semantic;
    return Object.entries(conditions).reduce(
      (acc, [conditionId, statements]) => Object.keys(sememes).reduce((acc2, sememeName) => {
        acc2[sememeName] = `var(--${namespace}${sememeName})`;
        return acc2;
      }, acc),
      {}
    );
  }
};
var renderAliasMappings = (config, alias) => {
  if (!alias) {
    return {};
  } else {
    const { namespace, aliases } = alias;
    return Object.entries(aliases).reduce(
      (acc, [sememeName, sememeAliases]) => {
        return Object.entries(sememeAliases).reduce(
          (acc2, [conditionId, aliasNames]) => {
            return aliasNames.reduce((acc3, aliasName) => {
              acc3[aliasName] = `var(--${namespace}${aliasName})`;
              return acc3;
            }, acc2);
          },
          acc
        );
      },
      {}
    );
  }
};
var renderTailwindFacet = (config, { physical, semantic, alias, definitions: facetDefinitions = {} }) => {
  const semanticValues = (0, import_tokens.facetSemanticValues)(semantic);
  return {
    ...renderPhysicalMappings(
      config,
      physical,
      semanticValues,
      facetDefinitions
    ),
    ...renderSemanticMappings(config, semantic),
    ...renderAliasMappings(config, alias)
  };
};
var src_default = (tokensConfig, adapterConfig = defaultAdapterConfig) => Object.entries(adapterConfig).reduce(
  (acc, entry) => {
    const [twKey, config] = entry;
    if (config.facet in tokensConfig) {
      const twFacet = renderTailwindFacet(config, tokensConfig[config.facet]);
      if (config.disposition === "extend") {
        acc.extend ??= {};
        acc.extend[twKey] = twFacet;
      } else {
        acc[twKey] = twFacet;
      }
    }
    return acc;
  },
  {}
);
//# sourceMappingURL=index.cjs.map
