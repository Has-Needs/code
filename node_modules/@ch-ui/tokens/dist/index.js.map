{
  "version": 3,
  "sources": ["../src/index.ts", "../src/physical-layer/helical-arc.ts", "../src/util/render-condition.ts", "../src/util/series-values.ts", "../src/util/resolve-definitions.ts", "../src/physical-layer/render-physical-layer.ts", "../src/physical-layer/audit-physical-layer.ts", "../src/physical-layer/exponential.ts", "../src/physical-layer/linenar.ts", "../src/semantic-layer.ts", "../src/alias-layer.ts", "../src/facet.ts", "../src/token-set.ts"],
  "sourcesContent": ["// Required notice: Copyright (c) 2024, Will Shown <ch-ui@willshown.com>\n\nimport { PluginCreator, parse, AtRule } from 'postcss';\nimport { TokenSet, renderTokenSet } from './token-set';\n\nexport type PluginOptions = {\n  config: (params: AtRule['params']) => Promise<TokenSet> | TokenSet;\n};\n\nconst creator: PluginCreator<PluginOptions> = (opts?: PluginOptions) => {\n  return {\n    postcssPlugin: '@ch-ui/tokens',\n    AtRule: {\n      async tokens(rule) {\n        const config = (await opts?.config(rule.params)) ?? {};\n        rule.replaceWith(\n          parse(renderTokenSet(config), {\n            from: rule.source?.input.file ?? 'unknown',\n          }),\n        );\n      },\n    },\n  };\n};\n\ncreator.postcss = true;\n\nexport * from './facet';\nexport * from './physical-layer';\nexport * from './semantic-layer';\nexport * from './types';\nexport * from './token-set';\nexport * from './util';\n\nexport default creator;\n", "// Required notice: Copyright (c) 2024, Will Shown <ch-ui@willshown.com>\nimport {\n  type HelicalArcConfig,\n  type Gamut,\n  helicalArcFromConfig,\n  constellationFromHelicalArc,\n  oklabVectorToValue,\n  getOklabVectorsFromLuminosities,\n  parseAlphaLuminosity,\n} from '@ch-ui/colors';\nimport {\n  AuditOptions,\n  HelicalArcSeries,\n  PhysicalLayer,\n  SemanticValues,\n  AuditTokens,\n  RenderTokensParams,\n  RenderTokens,\n  ResolvedHelicalArcSeries,\n  Definitions,\n} from '../types';\nimport {\n  variableNameFromValue,\n  physicalValueFromValueRelation,\n  resolveAccompanyingSeries,\n} from '../util';\nimport { renderPhysicalLayer } from './render-physical-layer';\nimport { auditPhysicalLayer } from './audit-physical-layer';\n\nexport type ColorsPhysicalLayer = PhysicalLayer<Gamut, HelicalArcSeries>;\n\nconst helicalArcSeriesCheck = (\n  resolvedSeries: any,\n): resolvedSeries is ResolvedHelicalArcSeries => {\n  return (\n    Array.isArray(resolvedSeries.keyPoint) &&\n    Number.isFinite(resolvedSeries.lowerCp) &&\n    Number.isFinite(resolvedSeries.upperCp) &&\n    Number.isFinite(resolvedSeries.torsion)\n  );\n};\n\nconst helicalArcNamedVectors = (\n  {\n    series,\n    seriesId,\n    namespace,\n    values = [],\n    resolvedNaming,\n  }: Omit<RenderTokensParams<ResolvedHelicalArcSeries>, 'conditionId'>,\n  ...definitions: Definitions[]\n) =>\n  getOklabVectorsFromLuminosities(\n    values.map((value) => {\n      const [l] = parseAlphaLuminosity(value);\n      const resolvedPhysicalValueRelation = resolveAccompanyingSeries(\n        series.physicalValueRelation,\n        ...definitions,\n      );\n      return physicalValueFromValueRelation(l, resolvedPhysicalValueRelation);\n    }),\n    constellationFromPalette(series),\n  ).map((oklabVector, index) => {\n    return {\n      value: values[index],\n      variableName: variableNameFromValue(\n        values[index],\n        resolvedNaming,\n        seriesId,\n        namespace,\n      ),\n      oklabVector,\n    };\n  });\n\nexport const renderHelicalArcTokens: RenderTokens<ResolvedHelicalArcSeries> = (\n  params,\n  ...definitions\n) =>\n  helicalArcNamedVectors(params, ...definitions).map(\n    ({ oklabVector, value, variableName }) => {\n      const [_, alpha] = parseAlphaLuminosity(value);\n      return `${variableName}: ${oklabVectorToValue(\n        oklabVector,\n        params.conditionId as Gamut,\n        alpha,\n      )};`;\n    },\n  );\n\nexport const renderPhysicalColorLayer = (\n  layer: ColorsPhysicalLayer,\n  semanticValues?: SemanticValues,\n  ...definitions: Definitions[]\n): string =>\n  renderPhysicalLayer<\n    ColorsPhysicalLayer,\n    HelicalArcSeries,\n    ResolvedHelicalArcSeries\n  >(\n    layer,\n    renderHelicalArcTokens,\n    helicalArcSeriesCheck,\n    semanticValues,\n    ...definitions,\n  );\n\nexport const auditHelicalArcTokens: AuditTokens<ResolvedHelicalArcSeries> = (\n  { values, ...params },\n  ...definitions: Definitions[]\n) =>\n  helicalArcNamedVectors(\n    {\n      ...params,\n      values: Array.from(values.keys()),\n    },\n    ...definitions,\n  ).map(({ value, variableName }) => ({\n    variableName,\n    value,\n    seriesId: params.seriesId,\n    ...values.get(value)!,\n  }));\n\nexport const auditPhysicalColorLayer = (\n  layer: ColorsPhysicalLayer,\n  auditOptions: AuditOptions,\n  semanticValues?: SemanticValues,\n  ...definitions: Definitions[]\n) =>\n  auditPhysicalLayer<ColorsPhysicalLayer, ResolvedHelicalArcSeries>(\n    layer,\n    auditOptions,\n    auditHelicalArcTokens,\n    semanticValues,\n    ...definitions,\n  );\n\nexport const constellationFromPalette = (\n  helicalArcConfig: HelicalArcConfig,\n  curveDepth: number = 32,\n) =>\n  constellationFromHelicalArc(\n    helicalArcFromConfig(helicalArcConfig),\n    curveDepth,\n  );\n\nexport { parseAlphaLuminosity };\n", "// Required notice: Copyright (c) 2024, Will Shown <ch-ui@willshown.com>\n\nconst indent = (text: string, level: number) =>\n  [...Array(level)].reduce((acc, _) => `  ${acc}`, text);\n\nexport const renderCondition = (\n  block: string,\n  level: number = 0,\n  statements?: string[],\n): string => {\n  if (statements && statements.length > 0) {\n    const [statement, ...nextStatements] = statements;\n    return `${indent(`${statement} {`, level)}\\n${renderCondition(\n      block,\n      level + 1,\n      nextStatements,\n    )}\\n${indent('}', level)}`;\n  } else {\n    return level > 0 ? block.replace(/^(.+)/gm, indent('$1', level)) : block;\n  }\n};\n", "// Required notice: Copyright (c) 2024, Will Shown <ch-ui@willshown.com>\n\nimport {\n  ResolvedNaming,\n  SememeAnnotation,\n  SemanticLayer,\n  SemanticValues,\n  Series,\n  FacetAnnotatedValues,\n  SemanticAnnotatedValues,\n  ResolvedAccompanyingSeries,\n} from '../types';\n\n/**\n * Produces all unique values of a series\n */\nexport const seriesValues = <V = number>(\n  { values = [], naming }: Series<V>,\n  semanticValues?: SemanticAnnotatedValues<V>,\n): FacetAnnotatedValues<V> => {\n  const seriesAnnotatedValues = Array.from(\n    new Set([\n      ...values,\n      ...(naming && typeof naming !== 'string' ? Object.values(naming) : []),\n      ...(semanticValues ? Array.from(semanticValues.keys()) : []),\n    ]),\n  )\n    .sort()\n    .reduce((acc: FacetAnnotatedValues<V>, value) => {\n      acc.set(value, { physical: [], semantic: [] });\n      return acc;\n    }, new Map());\n  values.forEach((directValue) => {\n    seriesAnnotatedValues.get(directValue)?.physical.push('values');\n  });\n  if (naming && typeof naming !== 'string') {\n    Object.values(naming).forEach((nameValue) => {\n      seriesAnnotatedValues.get(nameValue)?.physical.push('naming');\n    });\n  }\n  if (semanticValues) {\n    semanticValues.forEach((annotations, value) => {\n      seriesAnnotatedValues.get(value)?.semantic.push(...annotations);\n    });\n  }\n  return seriesAnnotatedValues;\n};\n\nexport const facetSemanticValues = <\n  K extends string = string,\n  S extends string = string,\n  V = number,\n>(\n  semanticLayer?: SemanticLayer<K, S, V>,\n): SemanticValues<S, V> => {\n  return semanticLayer\n    ? Object.entries(semanticLayer.sememes).reduce(\n        (acc, [sememeName, sememe]) => {\n          Object.entries(sememe).forEach(([conditionId, sememe]) => {\n            const [seriesId, value] = sememe as [S, V];\n            const annotation = {\n              sememeName,\n              conditionId,\n            } satisfies SememeAnnotation;\n            if (!acc[seriesId]) {\n              acc[seriesId] = new Map<V, SememeAnnotation[]>();\n            }\n            if (acc[seriesId].has(value)) {\n              acc[seriesId].get(value)!.push(annotation);\n            } else {\n              acc[seriesId].set(value, [annotation]);\n            }\n          });\n          return acc;\n        },\n        {} as SemanticValues<S, V>,\n      )\n    : ({} as SemanticValues<S, V>);\n};\n\nconst defaultRelation: ResolvedAccompanyingSeries = {\n  initial: 0,\n  slope: 1,\n  method: 'floor',\n};\n\nexport const physicalValueFromValueRelation = (\n  value: number,\n  { initial, slope }: ResolvedAccompanyingSeries = defaultRelation,\n) => (value - initial) / slope;\n\nexport const resolveNaming = (\n  naming: Series['naming'] = 'toString',\n): ResolvedNaming =>\n  typeof naming === 'string'\n    ? 'toString'\n    : Object.entries(naming).reduce((acc, [name, value]) => {\n        acc.set(value, name);\n        return acc;\n      }, new Map());\n\nexport const escapeValue = (value: string) =>\n  value.replace('/', '\\\\/').replace('.', '\\\\.');\n\nexport const nameFromValue = (\n  value: number | string,\n  resolvedNaming: ResolvedNaming,\n): string => {\n  if (\n    typeof resolvedNaming === 'string'\n      ? resolvedNaming === 'toString'\n      : !resolvedNaming.has(value)\n  ) {\n    return escapeValue(`${value}`);\n  } else {\n    return (resolvedNaming as Exclude<ResolvedNaming, 'toString'>).get(value)!;\n  }\n};\n\nexport const variableNameFromValue = (\n  value: number | string,\n  resolvedNaming: ResolvedNaming,\n  seriesId: string,\n  namespace: string = '',\n): string =>\n  `--${namespace}${seriesId}-${nameFromValue(value, resolvedNaming)}`;\n", "// Required notice: Copyright (c) 2025, Will Shown <ch-ui@willshown.com>\n\nimport {\n  AccompanyingSeries,\n  Definitions,\n  InvariantCheck,\n  ResolvedAccompanyingSeries,\n  Series,\n} from '../types';\nimport invariant from 'invariant';\n\nconst resolveDefinitionImpl = <Definition extends { extends?: string } = any>(\n  target: Definition,\n  typeKey: string,\n  ...definitions: Definitions[]\n): Definition => {\n  if (!target.extends) {\n    return target;\n  } else {\n    const source =\n      definitions.find(\n        ({ [typeKey]: typeDefinitions = {} }) =>\n          target.extends! in typeDefinitions,\n      )?.[typeKey]?.[target.extends] ?? {};\n    return {\n      ...resolveDefinitionImpl(source, typeKey, ...definitions),\n      ...target,\n    };\n  }\n};\n\nexport const resolveDefinition = <\n  Definition extends { extends?: string } = any,\n  ResolvedDefinition extends Definition = any,\n>(\n  target: Definition,\n  typeKey: string,\n  invariantCheck: InvariantCheck,\n  ...definitions: Definitions[]\n): ResolvedDefinition => {\n  const resolvedDefinition = resolveDefinitionImpl(\n    target,\n    typeKey,\n    ...definitions,\n  );\n  invariant(\n    invariantCheck(resolvedDefinition),\n    `Definition ${target.extends} could not be resolved.`,\n  );\n  return resolvedDefinition as ResolvedDefinition;\n};\n\nexport const resolveAccompanyingSeries = (\n  target: AccompanyingSeries,\n  ...definitions: Definitions[]\n): ResolvedAccompanyingSeries => {\n  return resolveDefinition<AccompanyingSeries, ResolvedAccompanyingSeries>(\n    target,\n    'accompanyingSeries',\n    ({ initial, slope, method }) =>\n      Number.isFinite(initial) &&\n      Number.isFinite(slope) &&\n      typeof method === 'string',\n    ...definitions,\n  );\n};\n", "// Required notice: Copyright (c) 2024, Will Shown <ch-ui@willshown.com>\n\nimport {\n  Definitions,\n  InvariantCheck,\n  PhysicalLayer,\n  RenderTokens,\n  SemanticValues,\n  Series,\n} from '../types';\nimport {\n  renderCondition,\n  resolveNaming,\n  seriesValues,\n  resolveDefinition,\n} from '../util';\n\nexport const renderPhysicalLayer = <\n  L extends PhysicalLayer<string, Series<any>>,\n  S extends Series<any>,\n  ResolvedSeries extends S = S,\n>(\n  { conditions, series, namespace = '', definitions: layerDefinitions = {} }: L,\n  renderTokens: RenderTokens<ResolvedSeries>,\n  invariantCheck: InvariantCheck,\n  semanticValues?: SemanticValues,\n  ...ancestorDefinitions: Definitions[]\n) => {\n  return `${Object.entries(conditions)\n    .map(([conditionId, statements]) =>\n      renderCondition(\n        Object.entries(series)\n          .filter(([_, series]) => series[conditionId])\n          .map(([seriesId, { [conditionId]: series }]) => {\n            const resolvedSeries = resolveDefinition<S, ResolvedSeries>(\n              series as S,\n              'series',\n              invariantCheck,\n              layerDefinitions,\n              ...ancestorDefinitions,\n            );\n            const resolvedNaming = resolveNaming(resolvedSeries.naming);\n            const values = Array.from(\n              seriesValues(resolvedSeries, semanticValues?.[seriesId]).keys(),\n            );\n            return renderTokens(\n              {\n                seriesId,\n                conditionId,\n                series: resolvedSeries,\n                namespace,\n                resolvedNaming,\n                values,\n              },\n              layerDefinitions,\n              ...ancestorDefinitions,\n            ).join('\\n');\n          })\n          .join('\\n\\n'),\n        0,\n        statements,\n      ),\n    )\n    .join('\\n\\n')}`;\n};\n", "// Required notice: Copyright (c) 2025, Will Shown <ch-ui@willshown.com>\n\nimport {\n  AuditOptions,\n  AuditTokens,\n  Definitions,\n  PhysicalLayer,\n  SemanticValues,\n  Series,\n  TokenAudit,\n} from '../types';\nimport { resolveDefinition, resolveNaming, seriesValues } from '../util';\n\nexport const auditPhysicalLayer = <\n  L extends PhysicalLayer<string, Series<any>>,\n  S extends Series<any>,\n>(\n  { series, namespace = '', definitions: layerDefinitions = {} }: L,\n  { condition }: AuditOptions,\n  auditTokens: AuditTokens<S>,\n  semanticValues?: SemanticValues,\n  ...ancestorDefinitions: Definitions[]\n): Record<string, TokenAudit[]> => {\n  return Object.fromEntries(\n    Object.entries(series).map(([seriesId, { [condition]: series }]) => {\n      const resolvedSeries = resolveDefinition<S, S>(\n        series as S,\n        'series',\n        () => true,\n        layerDefinitions,\n        ...ancestorDefinitions,\n      );\n      const resolvedNaming = resolveNaming(resolvedSeries.naming);\n      const values = seriesValues(resolvedSeries, semanticValues?.[seriesId]);\n      return [\n        seriesId,\n        auditTokens(\n          {\n            seriesId,\n            series: resolvedSeries,\n            namespace,\n            resolvedNaming,\n            values,\n          },\n          layerDefinitions,\n          ...ancestorDefinitions,\n        ),\n      ];\n    }),\n  );\n};\n", "// Required notice: Copyright (c) 2024, Will Shown <ch-ui@willshown.com>\n\nimport {\n  AuditOptions,\n  ExponentialSeries,\n  PhysicalLayer,\n  RenderTokensParams,\n  SemanticValues,\n  AuditTokens,\n  RenderTokens,\n  ResolvedExponentialSeries,\n  Definitions,\n} from '../types';\nimport { renderPhysicalLayer } from './render-physical-layer';\nimport { variableNameFromValue, resolveAccompanyingSeries } from '../util';\nimport { auditPhysicalLayer } from './audit-physical-layer';\nimport invariant from 'invariant';\n\nexport type ExponentialPhysicalLayer<S extends string = string> =\n  //\n  PhysicalLayer<S, ExponentialSeries>;\n\nconst exponentialSeriesCheck = (\n  resolvedSeries: any,\n): resolvedSeries is ExponentialSeries => {\n  return (\n    Number.isFinite(resolvedSeries.initial) &&\n    Number.isFinite(resolvedSeries.base)\n  );\n};\n\nconst exponentialNamedResolvedValues = (\n  {\n    series,\n    seriesId,\n    namespace,\n    values = [],\n    resolvedNaming,\n  }: Omit<RenderTokensParams<ResolvedExponentialSeries>, 'conditionId'>,\n  ...definitions: Definitions[]\n) => {\n  const { initial, base, snapTo } = series;\n  invariant(\n    initial && base,\n    `Series ${seriesId} values could not be resolved.`,\n  );\n  return values\n    .map((value) => {\n      const preSnappedValue = initial * Math.pow(base, value);\n      if (snapTo) {\n        const { initial, slope, method } = resolveAccompanyingSeries(\n          snapTo,\n          ...definitions,\n        );\n        return (\n          initial + slope * Math[method]((preSnappedValue - initial) / slope)\n        );\n      } else {\n        return preSnappedValue;\n      }\n    })\n    .map((resolvedValue, index) => {\n      return {\n        value: values[index],\n        variableName: variableNameFromValue(\n          values[index],\n          resolvedNaming,\n          seriesId,\n          namespace,\n        ),\n        resolvedValue,\n      };\n    });\n};\n\nexport const renderExponentialTokens: RenderTokens<\n  ResolvedExponentialSeries\n> = (params, ...definitions) =>\n  exponentialNamedResolvedValues(params, ...definitions).map(\n    ({ resolvedValue, variableName }) => {\n      return `${variableName}: ${resolvedValue.toFixed(3)}${\n        params.series.unit\n      };`;\n    },\n  );\n\nexport const renderExponentialLayer = (\n  layer: ExponentialPhysicalLayer,\n  semanticValues?: SemanticValues,\n  ...definitions: Definitions[]\n): string =>\n  renderPhysicalLayer<\n    ExponentialPhysicalLayer,\n    ExponentialSeries,\n    ResolvedExponentialSeries\n  >(\n    layer,\n    renderExponentialTokens,\n    exponentialSeriesCheck,\n    semanticValues,\n    ...definitions,\n  );\n\nexport const auditExponentialTokens: AuditTokens<ResolvedExponentialSeries> = (\n  { values, ...params },\n  ...definitions: Definitions[]\n) =>\n  exponentialNamedResolvedValues(\n    {\n      ...params,\n      values: Array.from(values.keys()),\n    },\n    ...definitions,\n  ).map(({ value, variableName }) => ({\n    variableName,\n    value,\n    seriesId: params.seriesId,\n    ...values.get(value)!,\n  }));\n\nexport const auditExponentialLayer = (\n  layer: ExponentialPhysicalLayer,\n  auditOptions: AuditOptions,\n  semanticValues?: SemanticValues,\n  ...definitions: Definitions[]\n) =>\n  auditPhysicalLayer<ExponentialPhysicalLayer, ResolvedExponentialSeries>(\n    layer,\n    auditOptions,\n    auditExponentialTokens,\n    semanticValues,\n    ...definitions,\n  );\n", "// Required notice: Copyright (c) 2024, Will Shown <ch-ui@willshown.com>\n\nimport {\n  AuditOptions,\n  LinearSeries,\n  PhysicalLayer,\n  RenderTokensParams,\n  SemanticValues,\n  RenderTokens,\n  AuditTokens,\n  ResolvedLinearSeries,\n  Definitions,\n} from '../types';\nimport { renderPhysicalLayer } from './render-physical-layer';\nimport { variableNameFromValue } from '../util';\nimport { auditPhysicalLayer } from './audit-physical-layer';\n\nexport type LinearPhysicalLayer<S extends string = string> =\n  //\n  PhysicalLayer<S, LinearSeries>;\n\nconst checkLinearSeries = (\n  resolvedSeries: any,\n): resolvedSeries is LinearSeries => {\n  return (\n    Number.isFinite(resolvedSeries.initial) &&\n    Number.isFinite(resolvedSeries.slope)\n  );\n};\n\nconst linearNamedResolvedValues = (\n  {\n    series,\n    seriesId,\n    namespace,\n    values = [],\n    resolvedNaming,\n  }: Omit<RenderTokensParams<ResolvedLinearSeries>, 'conditionId'>,\n  ...definitions: Definitions[]\n) => {\n  const { initial, slope } = series;\n  return values\n    .map((value) => initial + slope * value)\n    .map((resolvedValue, index) => {\n      return {\n        value: values[index],\n        variableName: variableNameFromValue(\n          values[index],\n          resolvedNaming,\n          seriesId,\n          namespace,\n        ),\n        resolvedValue,\n      };\n    });\n};\n\nexport const renderLinearTokens: RenderTokens<ResolvedLinearSeries> = (\n  params,\n  ...definitions\n) =>\n  linearNamedResolvedValues(params, ...definitions).map(\n    ({ variableName, resolvedValue }) => {\n      return `${variableName}: ${resolvedValue.toFixed(3)}${\n        params.series.unit\n      };`;\n    },\n  );\n\nexport const renderLinearLayer = (\n  layer: LinearPhysicalLayer,\n  semanticValues?: SemanticValues,\n  ...definitions: Definitions[]\n): string =>\n  renderPhysicalLayer<LinearPhysicalLayer, LinearSeries, ResolvedLinearSeries>(\n    layer,\n    renderLinearTokens,\n    checkLinearSeries,\n    semanticValues,\n    ...definitions,\n  );\n\nexport const auditLinearTokens: AuditTokens<ResolvedLinearSeries> = (\n  { values, ...params },\n  ...definitions: Definitions[]\n) =>\n  linearNamedResolvedValues(\n    {\n      ...params,\n      values: Array.from(values.keys()),\n    },\n    ...definitions,\n  ).map(({ value, variableName }) => ({\n    variableName,\n    value,\n    seriesId: params.seriesId,\n    ...values.get(value)!,\n  }));\n\nexport const auditLinearLayer = (\n  layer: LinearPhysicalLayer,\n  auditOptions: AuditOptions,\n  semanticValues?: SemanticValues,\n  ...definitions: Definitions[]\n) =>\n  auditPhysicalLayer<LinearPhysicalLayer, ResolvedLinearSeries>(\n    layer,\n    auditOptions,\n    auditLinearTokens,\n    semanticValues,\n    ...definitions,\n  );\n", "// Required notice: Copyright (c) 2024, Will Shown <ch-ui@willshown.com>\n\nimport { SemanticLayer, Statements } from './types';\nimport { escapeValue, renderCondition } from './util';\n\nexport const renderSemanticLayer = <\n  K extends string = string,\n  P extends string = string,\n  V = number,\n  Q extends string = string,\n>({\n  conditions,\n  sememes,\n  namespace = '',\n  physicalNamespace = namespace,\n}: SemanticLayer<K, P, V, Q>): string => {\n  return Object.entries(conditions)\n    .map(([conditionId, statements]) =>\n      renderCondition(\n        (\n          Object.entries(sememes) as [\n            keyof typeof sememes,\n            (typeof sememes)[Q],\n          ][]\n        )\n          .filter(([, sememe]) => sememe[conditionId as K])\n          .map(([sememeName, sememe]) => {\n            const [seriesName, value] = sememe[conditionId as K]!;\n            return `--${namespace}${sememeName}: var(--${physicalNamespace}${seriesName}-${escapeValue(\n              `${value}`,\n            )});`;\n          })\n          .join('\\n'),\n        0,\n        statements as Statements,\n      ),\n    )\n    .join('\\n\\n');\n};\n", "// Required notice: Copyright (c) 2025, Will Shown <ch-ui@willshown.com>\n\nimport { AliasLayer, Statements } from './types';\nimport { renderCondition } from './util';\n\nexport const renderAliasLayer = <\n  K extends string = string,\n  Q extends string = string,\n>({\n  conditions,\n  aliases,\n  namespace = '',\n  semanticNamespace = namespace,\n}: AliasLayer<K, Q>): string => {\n  return Object.entries(conditions)\n    .map(([conditionId, statements]) =>\n      renderCondition(\n        (Object.entries(aliases) as [Q, Record<K, string[]>][])\n          .filter(([_, sememeAliases]) => sememeAliases[conditionId as K])\n          .map(([sememeName, sememeAliases]) => {\n            return sememeAliases[conditionId as K]!.map(\n              (aliasName) =>\n                `--${namespace}${aliasName}: var(--${semanticNamespace}${sememeName});`,\n            ).join('\\n');\n          })\n          .join('\\n'),\n        0,\n        statements as Statements,\n      ),\n    )\n    .join('\\n\\n');\n};\n", "// Required notice: Copyright (c) 2024, Will Shown <ch-ui@willshown.com>\n\nimport {\n  ColorsPhysicalLayer,\n  ExponentialPhysicalLayer,\n  LinearPhysicalLayer,\n  renderExponentialLayer,\n  renderLinearLayer,\n  renderPhysicalColorLayer,\n  auditPhysicalColorLayer,\n  auditExponentialLayer,\n  auditLinearLayer,\n} from './physical-layer';\nimport {\n  AliasLayer,\n  AuditOptions,\n  Definitions,\n  PhysicalLayer,\n  SemanticLayer,\n  SemanticValues,\n  Series,\n  ValueOfSeries,\n} from './types';\nimport { facetSemanticValues, resolveDefinition } from './util';\nimport { renderSemanticLayer } from './semantic-layer';\nimport { renderAliasLayer } from './alias-layer';\n\nexport type Facet<\n  K extends string = string,\n  P extends string = string,\n  L extends PhysicalLayer<string, Series<any>> =\n    | ExponentialPhysicalLayer<P>\n    | LinearPhysicalLayer<P>\n    | ColorsPhysicalLayer,\n  Q extends string = string,\n> = {\n  physical: L;\n  semantic?: SemanticLayer<K, P, ValueOfSeries<L['series']>, Q>;\n  alias?: AliasLayer<Q>;\n  definitions?: Definitions<Series<ValueOfSeries<L['series']>>>;\n};\n\nexport const isColorPhysicalLayer = (\n  layer: PhysicalLayer<string, Series<any>>,\n  firstSeriesInLayer: Series,\n): layer is ColorsPhysicalLayer => {\n  return 'keyPoint' in firstSeriesInLayer;\n};\n\nexport const isExponentialLayer = (\n  layer: PhysicalLayer,\n  firstSeriesInLayer: Series,\n): layer is ExponentialPhysicalLayer => {\n  return 'base' in firstSeriesInLayer;\n};\n\nexport const isLinearLayer = (\n  layer: PhysicalLayer,\n  firstSeriesInLayer: Series,\n): layer is LinearPhysicalLayer => {\n  return 'slope' in firstSeriesInLayer;\n};\n\nexport const getFirstSeriesInPhysicalLayer = (\n  layer: PhysicalLayer<string, Series<any>>,\n  ...definitions: Definitions[]\n): Series => {\n  const seriesIds = Object.keys(layer.series);\n  const conditionIds = Object.keys(layer.series[seriesIds[0]]);\n  const series = layer.series[seriesIds[0]][conditionIds[0]]!;\n  return resolveDefinition(\n    series,\n    'series',\n    () => true,\n    layer.definitions ?? {},\n    ...definitions,\n  );\n};\n\nexport const renderFacet = ({\n  physical,\n  semantic,\n  alias,\n  definitions = {},\n}: Facet) => {\n  const facetDefinitions = definitions as Definitions;\n  const semanticValues = facetSemanticValues(semantic) as SemanticValues;\n  const firstSeries = getFirstSeriesInPhysicalLayer(physical, facetDefinitions);\n  return [\n    isColorPhysicalLayer(physical, firstSeries)\n      ? renderPhysicalColorLayer(physical, semanticValues, facetDefinitions)\n      : isExponentialLayer(physical, firstSeries)\n      ? renderExponentialLayer(physical, semanticValues, facetDefinitions)\n      : isLinearLayer(physical, firstSeries)\n      ? renderLinearLayer(physical, semanticValues, facetDefinitions)\n      : '/* Invalid physical layer */',\n    ...(semantic ? [renderSemanticLayer(semantic)] : []),\n    ...(alias ? [renderAliasLayer(alias)] : []),\n  ].join('\\n\\n');\n};\n\nexport const auditFacet = (\n  { physical, semantic, definitions = {} }: Facet,\n  auditOptions: AuditOptions,\n) => {\n  const facetDefinitions = definitions as Definitions;\n  const semanticValues = facetSemanticValues(semantic) as SemanticValues;\n  const firstSeries = getFirstSeriesInPhysicalLayer(physical, facetDefinitions);\n  return isColorPhysicalLayer(physical, firstSeries)\n    ? auditPhysicalColorLayer(\n        physical,\n        auditOptions,\n        semanticValues,\n        facetDefinitions,\n      )\n    : isExponentialLayer(physical, firstSeries)\n    ? auditExponentialLayer(\n        physical,\n        auditOptions,\n        semanticValues,\n        facetDefinitions,\n      )\n    : auditLinearLayer(\n        physical,\n        auditOptions,\n        semanticValues,\n        facetDefinitions,\n      );\n};\n", "// Required notice: Copyright (c) 2024, Will Shown <ch-ui@willshown.com>\n\nimport { ColorsPhysicalLayer } from './physical-layer';\nimport {\n  Conditions,\n  ExponentialSeries,\n  LinearSeries,\n  ResolvedHelicalArcSeries,\n  SemanticLayer,\n} from './types';\nimport { Facet, renderFacet } from './facet';\n\nexport type TokenSet = Record<string, Facet>;\n\n// Default token set values\n\nexport const defaultColorDefs = {\n  accompanyingSeries: {\n    emissiveRelation: {\n      initial: 0,\n      slope: 1000,\n      method: 'floor',\n    },\n  },\n  series: {\n    neutralArc: {\n      keyPoint: [0.47, 0.014, 256],\n      lowerCp: 0.8,\n      upperCp: 0.88,\n      torsion: 0,\n      physicalValueRelation: { extends: 'emissiveRelation' },\n    } as ResolvedHelicalArcSeries,\n    accentArc: {\n      keyPoint: [0.43, 0.4, 256],\n      lowerCp: 1,\n      upperCp: 1,\n      torsion: -12,\n      physicalValueRelation: { extends: 'emissiveRelation' },\n    } as ResolvedHelicalArcSeries,\n  },\n};\n\nexport const defaultPhysicalColors = {\n  definitions: defaultColorDefs,\n  conditions: {\n    srgb: [':root'],\n    p3: ['@media (color-gamut: p3)', ':root'],\n    rec2020: ['@media (color-gamut: rec2020)', ':root'],\n  },\n  series: {\n    neutral: {\n      srgb: { extends: 'neutralArc' },\n      p3: { extends: 'neutralArc' },\n      rec2020: { extends: 'neutralArc' },\n    },\n    accent: {\n      srgb: { extends: 'accentArc' },\n      p3: { extends: 'accentArc' },\n      rec2020: { extends: 'accentArc' },\n    },\n  },\n  namespace: 'ch-',\n} satisfies ColorsPhysicalLayer;\n\nexport const defaultSemanticColors = {\n  conditions: {\n    light: [':root'],\n    dark: ['@media (prefers-color-scheme: dark)', ':root'],\n  },\n  sememes: {\n    'bg-base': {\n      light: ['neutral', 975],\n      dark: ['neutral', 150],\n    },\n    'bg-input': {\n      light: ['neutral', 950],\n      dark: ['neutral', 175],\n    },\n    'bg-hover': {\n      light: ['neutral', 925],\n      dark: ['neutral', 200],\n    },\n    'bg-accent': {\n      light: ['accent', 500],\n      dark: ['accent', 550],\n    },\n    'bg-accentHover': {\n      light: ['accent', 550],\n      dark: ['accent', 600],\n    },\n    'fg-accent': {\n      light: ['accent', 500],\n      dark: ['accent', 550],\n    },\n    'fg-accentHover': {\n      light: ['accent', 550],\n      dark: ['accent', 600],\n    },\n    'bg-neutral': {\n      light: ['neutral', 500],\n      dark: ['neutral', 550],\n    },\n    'bg-neutralHover': {\n      light: ['neutral', 550],\n      dark: ['neutral', 600],\n    },\n    'fg-base': {\n      light: ['neutral', 0],\n      dark: ['neutral', 900],\n    },\n    'fg-separator': {\n      light: ['neutral', 925],\n      dark: ['neutral', 250],\n    },\n    'fg-description': {\n      light: ['neutral', 300],\n      dark: ['neutral', 700],\n    },\n  },\n  namespace: 'ch-',\n} satisfies SemanticLayer;\n\nconst defaultWeights = {\n  initial: 0,\n  slope: 1,\n  naming: {\n    regular: 400,\n    bold: 700,\n  },\n} satisfies LinearSeries;\n\nconst defaultExponentialKeys = {\n  '2xs': -3,\n  xs: -2,\n  s: -1,\n  base: 0,\n  lg: 1,\n  xl: 2,\n  '2xl': 3,\n  '3xl': 4,\n  '4xl': 5,\n} satisfies ExponentialSeries['naming'];\n\nconst defaultSizes = {\n  initial: 1,\n  unit: 'rem',\n  base: 1.2,\n  naming: defaultExponentialKeys,\n} satisfies ExponentialSeries;\n\nconst lineHeightSnapTo = {\n  method: 'ceil',\n  initial: 0,\n  slope: 0.25,\n} satisfies ExponentialSeries['snapTo'];\n\nconst defaultLineHeights = {\n  initial: 1.25,\n  unit: 'rem',\n  base: defaultSizes.base - 0.05, // <- larger type sizes benefit from less leading\n  naming: defaultExponentialKeys,\n  snapTo: lineHeightSnapTo,\n} satisfies ExponentialSeries;\n\nconst proseLineHeights = {\n  initial: 1.33,\n  unit: 'rem',\n  base: defaultSizes.base - 0.03,\n  naming: defaultExponentialKeys,\n  snapTo: lineHeightSnapTo,\n} satisfies ExponentialSeries;\n\nconst baseCondition = {\n  base: [':root'],\n} satisfies Conditions;\n\nconst defaultGaps = {\n  initial: 0.25,\n  unit: 'rem',\n  base: 2,\n  naming: {\n    hairline: -2,\n    half: -1,\n    '1': 0,\n    '2': 1,\n    '3': 2,\n    '4': 3,\n    '5': 4,\n    '6': 5,\n    '7': 6,\n    '8': 7,\n  },\n} satisfies ExponentialSeries;\n\nexport const defaultTokenSet = {\n  colors: {\n    physical: defaultPhysicalColors,\n    semantic: defaultSemanticColors,\n  },\n  fontSizes: {\n    physical: {\n      conditions: baseCondition,\n      series: {\n        'text-size': { base: defaultSizes },\n      },\n      namespace: 'ch-',\n    },\n  },\n  lineHeights: {\n    physical: {\n      conditions: baseCondition,\n      series: {\n        'system-leading': { base: defaultLineHeights },\n        'prose-leading': { base: proseLineHeights },\n      },\n      namespace: 'ch-',\n    },\n  },\n  lengths: {\n    physical: {\n      conditions: baseCondition,\n      series: {\n        gap: { base: defaultGaps },\n      },\n      namespace: 'ch-',\n    },\n  },\n} satisfies TokenSet;\n\nexport const renderTokenSet = (tokenSet: TokenSet) => {\n  return Object.values(tokenSet)\n    .map((facet) => renderFacet(facet))\n    .join('\\n\\n');\n};\n"],
  "mappings": "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",
  "names": ["sememe", "series", "series", "invariant", "initial"]
}
