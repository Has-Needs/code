"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// packages/tokens/src/index.ts
var src_exports = {};
__export(src_exports, {
  auditExponentialLayer: () => auditExponentialLayer,
  auditExponentialTokens: () => auditExponentialTokens,
  auditFacet: () => auditFacet,
  auditHelicalArcTokens: () => auditHelicalArcTokens,
  auditLinearLayer: () => auditLinearLayer,
  auditLinearTokens: () => auditLinearTokens,
  auditPhysicalColorLayer: () => auditPhysicalColorLayer,
  constellationFromPalette: () => constellationFromPalette,
  default: () => src_default,
  defaultColorDefs: () => defaultColorDefs,
  defaultPhysicalColors: () => defaultPhysicalColors,
  defaultSemanticColors: () => defaultSemanticColors,
  defaultTokenSet: () => defaultTokenSet,
  escapeValue: () => escapeValue,
  facetSemanticValues: () => facetSemanticValues,
  getFirstSeriesInPhysicalLayer: () => getFirstSeriesInPhysicalLayer,
  isColorPhysicalLayer: () => isColorPhysicalLayer,
  isExponentialLayer: () => isExponentialLayer,
  isLinearLayer: () => isLinearLayer,
  nameFromValue: () => nameFromValue,
  parseAlphaLuminosity: () => import_colors.parseAlphaLuminosity,
  physicalValueFromValueRelation: () => physicalValueFromValueRelation,
  renderCondition: () => renderCondition,
  renderExponentialLayer: () => renderExponentialLayer,
  renderExponentialTokens: () => renderExponentialTokens,
  renderFacet: () => renderFacet,
  renderHelicalArcTokens: () => renderHelicalArcTokens,
  renderLinearLayer: () => renderLinearLayer,
  renderLinearTokens: () => renderLinearTokens,
  renderPhysicalColorLayer: () => renderPhysicalColorLayer,
  renderSemanticLayer: () => renderSemanticLayer,
  renderTokenSet: () => renderTokenSet,
  resolveAccompanyingSeries: () => resolveAccompanyingSeries,
  resolveDefinition: () => resolveDefinition,
  resolveNaming: () => resolveNaming,
  seriesValues: () => seriesValues,
  variableNameFromValue: () => variableNameFromValue
});
module.exports = __toCommonJS(src_exports);
var import_postcss = require("postcss");

// packages/tokens/src/physical-layer/helical-arc.ts
var import_colors = require("@ch-ui/colors");

// packages/tokens/src/util/render-condition.ts
var indent = (text, level) => [...Array(level)].reduce((acc, _) => `  ${acc}`, text);
var renderCondition = (block, level = 0, statements) => {
  if (statements && statements.length > 0) {
    const [statement, ...nextStatements] = statements;
    return `${indent(`${statement} {`, level)}
${renderCondition(
      block,
      level + 1,
      nextStatements
    )}
${indent("}", level)}`;
  } else {
    return level > 0 ? block.replace(/^(.+)/gm, indent("$1", level)) : block;
  }
};

// packages/tokens/src/util/series-values.ts
var seriesValues = ({ values = [], naming }, semanticValues) => {
  const seriesAnnotatedValues = Array.from(
    /* @__PURE__ */ new Set([
      ...values,
      ...naming && typeof naming !== "string" ? Object.values(naming) : [],
      ...semanticValues ? Array.from(semanticValues.keys()) : []
    ])
  ).sort().reduce((acc, value) => {
    acc.set(value, { physical: [], semantic: [] });
    return acc;
  }, /* @__PURE__ */ new Map());
  values.forEach((directValue) => {
    seriesAnnotatedValues.get(directValue)?.physical.push("values");
  });
  if (naming && typeof naming !== "string") {
    Object.values(naming).forEach((nameValue) => {
      seriesAnnotatedValues.get(nameValue)?.physical.push("naming");
    });
  }
  if (semanticValues) {
    semanticValues.forEach((annotations, value) => {
      seriesAnnotatedValues.get(value)?.semantic.push(...annotations);
    });
  }
  return seriesAnnotatedValues;
};
var facetSemanticValues = (semanticLayer) => {
  return semanticLayer ? Object.entries(semanticLayer.sememes).reduce(
    (acc, [sememeName, sememe]) => {
      Object.entries(sememe).forEach(([conditionId, sememe2]) => {
        const [seriesId, value] = sememe2;
        const annotation = {
          sememeName,
          conditionId
        };
        if (!acc[seriesId]) {
          acc[seriesId] = /* @__PURE__ */ new Map();
        }
        if (acc[seriesId].has(value)) {
          acc[seriesId].get(value).push(annotation);
        } else {
          acc[seriesId].set(value, [annotation]);
        }
      });
      return acc;
    },
    {}
  ) : {};
};
var defaultRelation = {
  initial: 0,
  slope: 1,
  method: "floor"
};
var physicalValueFromValueRelation = (value, { initial, slope } = defaultRelation) => (value - initial) / slope;
var resolveNaming = (naming = "toString") => typeof naming === "string" ? "toString" : Object.entries(naming).reduce((acc, [name, value]) => {
  acc.set(value, name);
  return acc;
}, /* @__PURE__ */ new Map());
var escapeValue = (value) => value.replace("/", "\\/").replace(".", "\\.");
var nameFromValue = (value, resolvedNaming) => {
  if (typeof resolvedNaming === "string" ? resolvedNaming === "toString" : !resolvedNaming.has(value)) {
    return escapeValue(`${value}`);
  } else {
    return resolvedNaming.get(value);
  }
};
var variableNameFromValue = (value, resolvedNaming, seriesId, namespace = "") => `--${namespace}${seriesId}-${nameFromValue(value, resolvedNaming)}`;

// packages/tokens/src/util/resolve-definitions.ts
var import_invariant = __toESM(require("invariant"), 1);
var resolveDefinitionImpl = (target, typeKey, ...definitions) => {
  if (!target.extends) {
    return target;
  } else {
    const source = definitions.find(
      ({ [typeKey]: typeDefinitions = {} }) => target.extends in typeDefinitions
    )?.[typeKey]?.[target.extends] ?? {};
    return {
      ...resolveDefinitionImpl(source, typeKey, ...definitions),
      ...target
    };
  }
};
var resolveDefinition = (target, typeKey, invariantCheck, ...definitions) => {
  const resolvedDefinition = resolveDefinitionImpl(
    target,
    typeKey,
    ...definitions
  );
  (0, import_invariant.default)(
    invariantCheck(resolvedDefinition),
    `Definition ${target.extends} could not be resolved.`
  );
  return resolvedDefinition;
};
var resolveAccompanyingSeries = (target, ...definitions) => {
  return resolveDefinition(
    target,
    "accompanyingSeries",
    ({ initial, slope, method }) => Number.isFinite(initial) && Number.isFinite(slope) && typeof method === "string",
    ...definitions
  );
};

// packages/tokens/src/physical-layer/render-physical-layer.ts
var renderPhysicalLayer = ({ conditions, series, namespace = "", definitions: layerDefinitions = {} }, renderTokens, invariantCheck, semanticValues, ...ancestorDefinitions) => {
  return `${Object.entries(conditions).map(
    ([conditionId, statements]) => renderCondition(
      Object.entries(series).filter(([_, series2]) => series2[conditionId]).map(([seriesId, { [conditionId]: series2 }]) => {
        const resolvedSeries = resolveDefinition(
          series2,
          "series",
          invariantCheck,
          layerDefinitions,
          ...ancestorDefinitions
        );
        const resolvedNaming = resolveNaming(resolvedSeries.naming);
        const values = Array.from(
          seriesValues(resolvedSeries, semanticValues?.[seriesId]).keys()
        );
        return renderTokens(
          {
            seriesId,
            conditionId,
            series: resolvedSeries,
            namespace,
            resolvedNaming,
            values
          },
          layerDefinitions,
          ...ancestorDefinitions
        ).join("\n");
      }).join("\n\n"),
      0,
      statements
    )
  ).join("\n\n")}`;
};

// packages/tokens/src/physical-layer/audit-physical-layer.ts
var auditPhysicalLayer = ({ series, namespace = "", definitions: layerDefinitions = {} }, { condition }, auditTokens, semanticValues, ...ancestorDefinitions) => {
  return Object.fromEntries(
    Object.entries(series).map(([seriesId, { [condition]: series2 }]) => {
      const resolvedSeries = resolveDefinition(
        series2,
        "series",
        () => true,
        layerDefinitions,
        ...ancestorDefinitions
      );
      const resolvedNaming = resolveNaming(resolvedSeries.naming);
      const values = seriesValues(resolvedSeries, semanticValues?.[seriesId]);
      return [
        seriesId,
        auditTokens(
          {
            seriesId,
            series: resolvedSeries,
            namespace,
            resolvedNaming,
            values
          },
          layerDefinitions,
          ...ancestorDefinitions
        )
      ];
    })
  );
};

// packages/tokens/src/physical-layer/helical-arc.ts
var helicalArcSeriesCheck = (resolvedSeries) => {
  return Array.isArray(resolvedSeries.keyPoint) && Number.isFinite(resolvedSeries.lowerCp) && Number.isFinite(resolvedSeries.upperCp) && Number.isFinite(resolvedSeries.torsion);
};
var helicalArcNamedVectors = ({
  series,
  seriesId,
  namespace,
  values = [],
  resolvedNaming
}, ...definitions) => (0, import_colors.getOklabVectorsFromLuminosities)(
  values.map((value) => {
    const [l] = (0, import_colors.parseAlphaLuminosity)(value);
    const resolvedPhysicalValueRelation = resolveAccompanyingSeries(
      series.physicalValueRelation,
      ...definitions
    );
    return physicalValueFromValueRelation(l, resolvedPhysicalValueRelation);
  }),
  constellationFromPalette(series)
).map((oklabVector, index) => {
  return {
    value: values[index],
    variableName: variableNameFromValue(
      values[index],
      resolvedNaming,
      seriesId,
      namespace
    ),
    oklabVector
  };
});
var renderHelicalArcTokens = (params, ...definitions) => helicalArcNamedVectors(params, ...definitions).map(
  ({ oklabVector, value, variableName }) => {
    const [_, alpha] = (0, import_colors.parseAlphaLuminosity)(value);
    return `${variableName}: ${(0, import_colors.oklabVectorToValue)(
      oklabVector,
      params.conditionId,
      alpha
    )};`;
  }
);
var renderPhysicalColorLayer = (layer, semanticValues, ...definitions) => renderPhysicalLayer(
  layer,
  renderHelicalArcTokens,
  helicalArcSeriesCheck,
  semanticValues,
  ...definitions
);
var auditHelicalArcTokens = ({ values, ...params }, ...definitions) => helicalArcNamedVectors(
  {
    ...params,
    values: Array.from(values.keys())
  },
  ...definitions
).map(({ value, variableName }) => ({
  variableName,
  value,
  seriesId: params.seriesId,
  ...values.get(value)
}));
var auditPhysicalColorLayer = (layer, auditOptions, semanticValues, ...definitions) => auditPhysicalLayer(
  layer,
  auditOptions,
  auditHelicalArcTokens,
  semanticValues,
  ...definitions
);
var constellationFromPalette = (helicalArcConfig, curveDepth = 32) => (0, import_colors.constellationFromHelicalArc)(
  (0, import_colors.helicalArcFromConfig)(helicalArcConfig),
  curveDepth
);

// packages/tokens/src/physical-layer/exponential.ts
var import_invariant2 = __toESM(require("invariant"), 1);
var exponentialSeriesCheck = (resolvedSeries) => {
  return Number.isFinite(resolvedSeries.initial) && Number.isFinite(resolvedSeries.base);
};
var exponentialNamedResolvedValues = ({
  series,
  seriesId,
  namespace,
  values = [],
  resolvedNaming
}, ...definitions) => {
  const { initial, base, snapTo } = series;
  (0, import_invariant2.default)(
    initial && base,
    `Series ${seriesId} values could not be resolved.`
  );
  return values.map((value) => {
    const preSnappedValue = initial * Math.pow(base, value);
    if (snapTo) {
      const { initial: initial2, slope, method } = resolveAccompanyingSeries(
        snapTo,
        ...definitions
      );
      return initial2 + slope * Math[method]((preSnappedValue - initial2) / slope);
    } else {
      return preSnappedValue;
    }
  }).map((resolvedValue, index) => {
    return {
      value: values[index],
      variableName: variableNameFromValue(
        values[index],
        resolvedNaming,
        seriesId,
        namespace
      ),
      resolvedValue
    };
  });
};
var renderExponentialTokens = (params, ...definitions) => exponentialNamedResolvedValues(params, ...definitions).map(
  ({ resolvedValue, variableName }) => {
    return `${variableName}: ${resolvedValue.toFixed(3)}${params.series.unit};`;
  }
);
var renderExponentialLayer = (layer, semanticValues, ...definitions) => renderPhysicalLayer(
  layer,
  renderExponentialTokens,
  exponentialSeriesCheck,
  semanticValues,
  ...definitions
);
var auditExponentialTokens = ({ values, ...params }, ...definitions) => exponentialNamedResolvedValues(
  {
    ...params,
    values: Array.from(values.keys())
  },
  ...definitions
).map(({ value, variableName }) => ({
  variableName,
  value,
  seriesId: params.seriesId,
  ...values.get(value)
}));
var auditExponentialLayer = (layer, auditOptions, semanticValues, ...definitions) => auditPhysicalLayer(
  layer,
  auditOptions,
  auditExponentialTokens,
  semanticValues,
  ...definitions
);

// packages/tokens/src/physical-layer/linenar.ts
var checkLinearSeries = (resolvedSeries) => {
  return Number.isFinite(resolvedSeries.initial) && Number.isFinite(resolvedSeries.slope);
};
var linearNamedResolvedValues = ({
  series,
  seriesId,
  namespace,
  values = [],
  resolvedNaming
}, ...definitions) => {
  const { initial, slope } = series;
  return values.map((value) => initial + slope * value).map((resolvedValue, index) => {
    return {
      value: values[index],
      variableName: variableNameFromValue(
        values[index],
        resolvedNaming,
        seriesId,
        namespace
      ),
      resolvedValue
    };
  });
};
var renderLinearTokens = (params, ...definitions) => linearNamedResolvedValues(params, ...definitions).map(
  ({ variableName, resolvedValue }) => {
    return `${variableName}: ${resolvedValue.toFixed(3)}${params.series.unit};`;
  }
);
var renderLinearLayer = (layer, semanticValues, ...definitions) => renderPhysicalLayer(
  layer,
  renderLinearTokens,
  checkLinearSeries,
  semanticValues,
  ...definitions
);
var auditLinearTokens = ({ values, ...params }, ...definitions) => linearNamedResolvedValues(
  {
    ...params,
    values: Array.from(values.keys())
  },
  ...definitions
).map(({ value, variableName }) => ({
  variableName,
  value,
  seriesId: params.seriesId,
  ...values.get(value)
}));
var auditLinearLayer = (layer, auditOptions, semanticValues, ...definitions) => auditPhysicalLayer(
  layer,
  auditOptions,
  auditLinearTokens,
  semanticValues,
  ...definitions
);

// packages/tokens/src/semantic-layer.ts
var renderSemanticLayer = ({
  conditions,
  sememes,
  namespace = "",
  physicalNamespace = namespace
}) => {
  return Object.entries(conditions).map(
    ([conditionId, statements]) => renderCondition(
      Object.entries(sememes).filter(([, sememe]) => sememe[conditionId]).map(([sememeName, sememe]) => {
        const [seriesName, value] = sememe[conditionId];
        return `--${namespace}${sememeName}: var(--${physicalNamespace}${seriesName}-${escapeValue(
          `${value}`
        )});`;
      }).join("\n"),
      0,
      statements
    )
  ).join("\n\n");
};

// packages/tokens/src/alias-layer.ts
var renderAliasLayer = ({
  conditions,
  aliases,
  namespace = "",
  semanticNamespace = namespace
}) => {
  return Object.entries(conditions).map(
    ([conditionId, statements]) => renderCondition(
      Object.entries(aliases).filter(([_, sememeAliases]) => sememeAliases[conditionId]).map(([sememeName, sememeAliases]) => {
        return sememeAliases[conditionId].map(
          (aliasName) => `--${namespace}${aliasName}: var(--${semanticNamespace}${sememeName});`
        ).join("\n");
      }).join("\n"),
      0,
      statements
    )
  ).join("\n\n");
};

// packages/tokens/src/facet.ts
var isColorPhysicalLayer = (layer, firstSeriesInLayer) => {
  return "keyPoint" in firstSeriesInLayer;
};
var isExponentialLayer = (layer, firstSeriesInLayer) => {
  return "base" in firstSeriesInLayer;
};
var isLinearLayer = (layer, firstSeriesInLayer) => {
  return "slope" in firstSeriesInLayer;
};
var getFirstSeriesInPhysicalLayer = (layer, ...definitions) => {
  const seriesIds = Object.keys(layer.series);
  const conditionIds = Object.keys(layer.series[seriesIds[0]]);
  const series = layer.series[seriesIds[0]][conditionIds[0]];
  return resolveDefinition(
    series,
    "series",
    () => true,
    layer.definitions ?? {},
    ...definitions
  );
};
var renderFacet = ({
  physical,
  semantic,
  alias,
  definitions = {}
}) => {
  const facetDefinitions = definitions;
  const semanticValues = facetSemanticValues(semantic);
  const firstSeries = getFirstSeriesInPhysicalLayer(physical, facetDefinitions);
  return [
    isColorPhysicalLayer(physical, firstSeries) ? renderPhysicalColorLayer(physical, semanticValues, facetDefinitions) : isExponentialLayer(physical, firstSeries) ? renderExponentialLayer(physical, semanticValues, facetDefinitions) : isLinearLayer(physical, firstSeries) ? renderLinearLayer(physical, semanticValues, facetDefinitions) : "/* Invalid physical layer */",
    ...semantic ? [renderSemanticLayer(semantic)] : [],
    ...alias ? [renderAliasLayer(alias)] : []
  ].join("\n\n");
};
var auditFacet = ({ physical, semantic, definitions = {} }, auditOptions) => {
  const facetDefinitions = definitions;
  const semanticValues = facetSemanticValues(semantic);
  const firstSeries = getFirstSeriesInPhysicalLayer(physical, facetDefinitions);
  return isColorPhysicalLayer(physical, firstSeries) ? auditPhysicalColorLayer(
    physical,
    auditOptions,
    semanticValues,
    facetDefinitions
  ) : isExponentialLayer(physical, firstSeries) ? auditExponentialLayer(
    physical,
    auditOptions,
    semanticValues,
    facetDefinitions
  ) : auditLinearLayer(
    physical,
    auditOptions,
    semanticValues,
    facetDefinitions
  );
};

// packages/tokens/src/token-set.ts
var defaultColorDefs = {
  accompanyingSeries: {
    emissiveRelation: {
      initial: 0,
      slope: 1e3,
      method: "floor"
    }
  },
  series: {
    neutralArc: {
      keyPoint: [0.47, 0.014, 256],
      lowerCp: 0.8,
      upperCp: 0.88,
      torsion: 0,
      physicalValueRelation: { extends: "emissiveRelation" }
    },
    accentArc: {
      keyPoint: [0.43, 0.4, 256],
      lowerCp: 1,
      upperCp: 1,
      torsion: -12,
      physicalValueRelation: { extends: "emissiveRelation" }
    }
  }
};
var defaultPhysicalColors = {
  definitions: defaultColorDefs,
  conditions: {
    srgb: [":root"],
    p3: ["@media (color-gamut: p3)", ":root"],
    rec2020: ["@media (color-gamut: rec2020)", ":root"]
  },
  series: {
    neutral: {
      srgb: { extends: "neutralArc" },
      p3: { extends: "neutralArc" },
      rec2020: { extends: "neutralArc" }
    },
    accent: {
      srgb: { extends: "accentArc" },
      p3: { extends: "accentArc" },
      rec2020: { extends: "accentArc" }
    }
  },
  namespace: "ch-"
};
var defaultSemanticColors = {
  conditions: {
    light: [":root"],
    dark: ["@media (prefers-color-scheme: dark)", ":root"]
  },
  sememes: {
    "bg-base": {
      light: ["neutral", 975],
      dark: ["neutral", 150]
    },
    "bg-input": {
      light: ["neutral", 950],
      dark: ["neutral", 175]
    },
    "bg-hover": {
      light: ["neutral", 925],
      dark: ["neutral", 200]
    },
    "bg-accent": {
      light: ["accent", 500],
      dark: ["accent", 550]
    },
    "bg-accentHover": {
      light: ["accent", 550],
      dark: ["accent", 600]
    },
    "fg-accent": {
      light: ["accent", 500],
      dark: ["accent", 550]
    },
    "fg-accentHover": {
      light: ["accent", 550],
      dark: ["accent", 600]
    },
    "bg-neutral": {
      light: ["neutral", 500],
      dark: ["neutral", 550]
    },
    "bg-neutralHover": {
      light: ["neutral", 550],
      dark: ["neutral", 600]
    },
    "fg-base": {
      light: ["neutral", 0],
      dark: ["neutral", 900]
    },
    "fg-separator": {
      light: ["neutral", 925],
      dark: ["neutral", 250]
    },
    "fg-description": {
      light: ["neutral", 300],
      dark: ["neutral", 700]
    }
  },
  namespace: "ch-"
};
var defaultExponentialKeys = {
  "2xs": -3,
  xs: -2,
  s: -1,
  base: 0,
  lg: 1,
  xl: 2,
  "2xl": 3,
  "3xl": 4,
  "4xl": 5
};
var defaultSizes = {
  initial: 1,
  unit: "rem",
  base: 1.2,
  naming: defaultExponentialKeys
};
var lineHeightSnapTo = {
  method: "ceil",
  initial: 0,
  slope: 0.25
};
var defaultLineHeights = {
  initial: 1.25,
  unit: "rem",
  base: defaultSizes.base - 0.05,
  // <- larger type sizes benefit from less leading
  naming: defaultExponentialKeys,
  snapTo: lineHeightSnapTo
};
var proseLineHeights = {
  initial: 1.33,
  unit: "rem",
  base: defaultSizes.base - 0.03,
  naming: defaultExponentialKeys,
  snapTo: lineHeightSnapTo
};
var baseCondition = {
  base: [":root"]
};
var defaultGaps = {
  initial: 0.25,
  unit: "rem",
  base: 2,
  naming: {
    hairline: -2,
    half: -1,
    "1": 0,
    "2": 1,
    "3": 2,
    "4": 3,
    "5": 4,
    "6": 5,
    "7": 6,
    "8": 7
  }
};
var defaultTokenSet = {
  colors: {
    physical: defaultPhysicalColors,
    semantic: defaultSemanticColors
  },
  fontSizes: {
    physical: {
      conditions: baseCondition,
      series: {
        "text-size": { base: defaultSizes }
      },
      namespace: "ch-"
    }
  },
  lineHeights: {
    physical: {
      conditions: baseCondition,
      series: {
        "system-leading": { base: defaultLineHeights },
        "prose-leading": { base: proseLineHeights }
      },
      namespace: "ch-"
    }
  },
  lengths: {
    physical: {
      conditions: baseCondition,
      series: {
        gap: { base: defaultGaps }
      },
      namespace: "ch-"
    }
  }
};
var renderTokenSet = (tokenSet) => {
  return Object.values(tokenSet).map((facet) => renderFacet(facet)).join("\n\n");
};

// packages/tokens/src/index.ts
var creator = (opts) => {
  return {
    postcssPlugin: "@ch-ui/tokens",
    AtRule: {
      async tokens(rule) {
        const config = await opts?.config(rule.params) ?? {};
        rule.replaceWith(
          (0, import_postcss.parse)(renderTokenSet(config), {
            from: rule.source?.input.file ?? "unknown"
          })
        );
      }
    }
  };
};
creator.postcss = true;
var src_default = creator;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  auditExponentialLayer,
  auditExponentialTokens,
  auditFacet,
  auditHelicalArcTokens,
  auditLinearLayer,
  auditLinearTokens,
  auditPhysicalColorLayer,
  constellationFromPalette,
  defaultColorDefs,
  defaultPhysicalColors,
  defaultSemanticColors,
  defaultTokenSet,
  escapeValue,
  facetSemanticValues,
  getFirstSeriesInPhysicalLayer,
  isColorPhysicalLayer,
  isExponentialLayer,
  isLinearLayer,
  nameFromValue,
  parseAlphaLuminosity,
  physicalValueFromValueRelation,
  renderCondition,
  renderExponentialLayer,
  renderExponentialTokens,
  renderFacet,
  renderHelicalArcTokens,
  renderLinearLayer,
  renderLinearTokens,
  renderPhysicalColorLayer,
  renderSemanticLayer,
  renderTokenSet,
  resolveAccompanyingSeries,
  resolveDefinition,
  resolveNaming,
  seriesValues,
  variableNameFromValue
});
//# sourceMappingURL=index.cjs.map
