import type { Scope } from '@radix-ui/react-context';
import { DismissableLayer } from '@radix-ui/react-dismissable-layer';
import { FocusScope } from '@radix-ui/react-focus-scope';
import * as PopperPrimitive from '@radix-ui/react-popper';
import { Portal as PortalPrimitive } from '@radix-ui/react-portal';
import { Primitive } from '@radix-ui/react-primitive';
import React, { type ComponentPropsWithRef, type ElementRef, type RefObject, type ReactNode, type ComponentPropsWithoutRef } from 'react';
import { type ThemedClassName } from '../../util';
type ScopedProps<P> = P & {
    __scopePopover?: Scope;
};
declare const createPopoverScope: import("@radix-ui/react-context").CreateScope;
interface PopoverRootProps {
    children?: ReactNode;
    open?: boolean;
    defaultOpen?: boolean;
    onOpenChange?: (open: boolean) => void;
    modal?: boolean;
}
type PopperAnchorProps = ComponentPropsWithoutRef<typeof PopperPrimitive.Anchor>;
interface PopoverAnchorProps extends PopperAnchorProps {
}
type PopoverTriggerElement = ElementRef<typeof Primitive.button>;
type PrimitiveButtonProps = ComponentPropsWithoutRef<typeof Primitive.button>;
interface PopoverTriggerProps extends PrimitiveButtonProps {
}
interface PopoverVirtualTriggerProps {
    virtualRef: RefObject<PopoverTriggerElement>;
}
type PortalProps = ComponentPropsWithoutRef<typeof PortalPrimitive>;
interface PopoverPortalProps {
    children?: ReactNode;
    /**
     * Specify a container element to portal the content into.
     */
    container?: PortalProps['container'];
    /**
     * Used to force mounting when more control is needed. Useful when
     * controlling animation with React animation libraries.
     */
    forceMount?: true;
}
type PopoverContentProps = ThemedClassName<PopoverContentTypeProps> & {
    /**
     * Used to force mounting when more control is needed. Useful when
     * controlling animation with React animation libraries.
     */
    forceMount?: boolean;
};
export interface PopoverContentTypeProps extends Omit<PopoverContentImplProps, 'trapFocus' | 'disableOutsidePointerEvents'> {
}
type FocusScopeProps = ComponentPropsWithoutRef<typeof FocusScope>;
type DismissableLayerProps = ComponentPropsWithoutRef<typeof DismissableLayer>;
type PopperContentProps = ThemedClassName<ComponentPropsWithoutRef<typeof PopperPrimitive.Content>>;
interface PopoverContentImplProps extends Omit<PopperContentProps, 'onPlaced'>, Omit<DismissableLayerProps, 'onDismiss'> {
    /**
     * Whether focus should be trapped within the `Popover`
     * (default: false)
     */
    trapFocus?: FocusScopeProps['trapped'];
    /**
     * Event handler called when auto-focusing on open.
     * Can be prevented.
     */
    onOpenAutoFocus?: FocusScopeProps['onMountAutoFocus'];
    /**
     * Event handler called when auto-focusing on close.
     * Can be prevented.
     */
    onCloseAutoFocus?: FocusScopeProps['onUnmountAutoFocus'];
}
interface PopoverCloseProps extends PrimitiveButtonProps {
}
type PopperArrowProps = ThemedClassName<ComponentPropsWithoutRef<typeof PopperPrimitive.Arrow>>;
interface PopoverArrowProps extends PopperArrowProps {
}
type PopoverViewportProps = ThemedClassName<ComponentPropsWithRef<typeof Primitive.div>> & {
    asChild?: boolean;
    constrainInline?: boolean;
    constrainBlock?: boolean;
};
type PopoverContentInteractOutsideEvent = Parameters<NonNullable<PopoverContentProps['onInteractOutside']>>[0];
export declare const Popover: {
    Root: React.FC<PopoverRootProps>;
    Anchor: React.ForwardRefExoticComponent<PopoverAnchorProps & React.RefAttributes<HTMLDivElement>>;
    Trigger: React.ForwardRefExoticComponent<PopoverTriggerProps & React.RefAttributes<HTMLButtonElement>>;
    VirtualTrigger: {
        (props: ScopedProps<PopoverVirtualTriggerProps>): React.JSX.Element;
        displayName: string;
    };
    Portal: React.FC<PopoverPortalProps>;
    Content: React.ForwardRefExoticComponent<Omit<PopoverContentTypeProps, "className"> & {
        classNames?: import("@dxos/react-ui-types").ClassNameValue;
    } & {
        /**
         * Used to force mounting when more control is needed. Useful when
         * controlling animation with React animation libraries.
         */
        forceMount?: boolean;
    } & React.RefAttributes<HTMLDivElement>>;
    Close: React.ForwardRefExoticComponent<PopoverCloseProps & React.RefAttributes<HTMLButtonElement>>;
    Arrow: React.ForwardRefExoticComponent<PopoverArrowProps & React.RefAttributes<SVGSVGElement>>;
    Viewport: React.ForwardRefExoticComponent<Omit<PopoverViewportProps, "ref"> & React.RefAttributes<HTMLDivElement>>;
};
export { createPopoverScope };
export type { PopoverRootProps, PopoverAnchorProps, PopoverTriggerProps, PopoverVirtualTriggerProps, PopoverPortalProps, PopoverContentProps, PopoverCloseProps, PopoverArrowProps, PopoverViewportProps, PopoverContentInteractOutsideEvent, };
//# sourceMappingURL=Popover.d.ts.map