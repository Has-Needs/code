import type { Scope } from '@radix-ui/react-context';
import { DismissableLayer } from '@radix-ui/react-dismissable-layer';
import * as PopperPrimitive from '@radix-ui/react-popper';
import { Primitive } from '@radix-ui/react-primitive';
import { type TooltipProps } from '@radix-ui/react-tooltip';
import React, { type ComponentPropsWithoutRef, type ElementRef, type SyntheticEvent, type MutableRefObject, type ReactNode } from 'react';
type TooltipScopedProps<P = {}> = P & {
    __scopeTooltip?: Scope;
};
declare const createTooltipScope: import("@radix-ui/react-context").CreateScope;
type TooltipContextValue = {
    contentId: string;
    open: boolean;
    stateAttribute: 'closed' | 'delayed-open' | 'instant-open';
    trigger: TooltipTriggerElement | null;
    onTriggerChange(trigger: TooltipTriggerElement | null): void;
    onTriggerEnter(): void;
    onTriggerLeave(): void;
    onOpen(): void;
    onClose(): void;
    onPointerInTransitChange(inTransit: boolean): void;
    isPointerInTransitRef: MutableRefObject<boolean>;
    disableHoverableContent: boolean;
};
declare const useTooltipContext: (consumerName: string, scope: Scope<TooltipContextValue | undefined>) => TooltipContextValue;
interface TooltipProviderProps {
    children?: ReactNode;
    open?: boolean;
    defaultOpen?: boolean;
    onOpenChange?: (open: boolean) => void;
    /**
     * The duration from when the pointer enters the trigger until the tooltip gets opened. This will
     * override the prop with the same name passed to Provider.
     * @defaultValue 700
     */
    delayDuration?: number;
    /**
     * When `true`, trying to hover the content will result in the tooltip closing as the pointer leaves the trigger.
     * @defaultValue false
     */
    disableHoverableContent?: boolean;
    /**
     * How much time a user has to enter another trigger without incurring a delay again.
     * @defaultValue 300
     */
    skipDelayDuration?: number;
}
type TooltipTriggerElement = ElementRef<typeof Primitive.button>;
type PrimitiveButtonProps = ComponentPropsWithoutRef<typeof Primitive.button>;
type TooltipTriggerProps = PrimitiveButtonProps & Pick<TooltipProps, 'delayDuration'> & {
    content?: string;
    side?: TooltipSide;
    onInteract?: (event: SyntheticEvent) => void;
};
interface TooltipContentProps extends TooltipContentImplProps {
    /**
     * Used to force mounting when more control is needed. Useful when
     * controlling animation with React animation libraries.
     */
    forceMount?: true;
}
type DismissableLayerProps = ComponentPropsWithoutRef<typeof DismissableLayer>;
type PopperContentProps = ComponentPropsWithoutRef<typeof PopperPrimitive.Content>;
interface TooltipContentImplProps extends Omit<PopperContentProps, 'onPlaced'> {
    /**
     * A more descriptive label for accessibility purpose
     */
    'aria-label'?: string;
    /**
     * Event handler called when the escape key is down.
     * Can be prevented.
     */
    onEscapeKeyDown?: DismissableLayerProps['onEscapeKeyDown'];
    /**
     * Event handler called when the a `pointerdown` event happens outside of the `Tooltip`.
     * Can be prevented.
     */
    onPointerDownOutside?: DismissableLayerProps['onPointerDownOutside'];
}
type TooltipSide = NonNullable<TooltipContentProps['side']>;
export declare const Tooltip: {
    Provider: React.FC<TooltipProviderProps>;
    Trigger: React.ForwardRefExoticComponent<Omit<Omit<React.DetailedHTMLProps<React.ButtonHTMLAttributes<HTMLButtonElement>, HTMLButtonElement>, "ref"> & {
        ref?: ((instance: HTMLButtonElement | null) => void | React.DO_NOT_USE_OR_YOU_WILL_BE_FIRED_CALLBACK_REF_RETURN_VALUES[keyof React.DO_NOT_USE_OR_YOU_WILL_BE_FIRED_CALLBACK_REF_RETURN_VALUES]) | React.RefObject<HTMLButtonElement> | null | undefined;
    } & {
        asChild?: boolean;
    }, "ref"> & Pick<TooltipProps, "delayDuration"> & {
        content?: string;
        side?: TooltipSide;
        onInteract?: (event: SyntheticEvent) => void;
    } & React.RefAttributes<HTMLButtonElement>>;
};
export { createTooltipScope, useTooltipContext };
export type { TooltipProviderProps, TooltipTriggerProps, TooltipScopedProps, TooltipSide };
//# sourceMappingURL=Tooltip.d.ts.map