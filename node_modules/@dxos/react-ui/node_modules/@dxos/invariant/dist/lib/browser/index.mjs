// packages/common/invariant/src/invariant.ts
var invariant = (condition, message, meta) => {
  if (condition) {
    return;
  }
  if (message?.startsWith("BUG")) {
    debugger;
  }
  let errorMessage = "invariant violation";
  if (message) {
    errorMessage += `: ${message}`;
  }
  if (meta?.A) {
    errorMessage += ` [${meta.A[0]}]`;
  }
  if (meta?.F) {
    errorMessage += ` at ${getRelativeFilename(meta.F)}:${meta.L}`;
  }
  const error = new InvariantViolation(errorMessage);
  Error.captureStackTrace(error, invariant);
  throw error;
};
var InvariantViolation = class extends Error {
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, new.target.prototype);
  }
};
var getRelativeFilename = (filename) => {
  const match = filename.match(/.+\/(packages\/.+\/.+)/);
  if (match) {
    const [, filePath] = match;
    return filePath;
  }
  return filename;
};
var failedInvariant = (message1, message2, meta) => {
  let errorMessage = "invariant violation";
  const message = [
    message1,
    message2
  ].filter((str) => typeof str === "string").join(" ");
  if (message) {
    errorMessage += `: ${message}`;
  }
  if (meta?.A) {
    errorMessage += ` [${meta.A[0]}]`;
  }
  if (meta?.F) {
    errorMessage += ` at ${getRelativeFilename(meta.F)}:${meta.L}`;
  }
  throw new InvariantViolation(errorMessage);
};

// packages/common/invariant/src/assert.ts
var assertArgument = (condition, message) => {
  if (!condition) {
    const error = new TypeError(message);
    Error.captureStackTrace(error, assertArgument);
    throw error;
  }
};
var assertState = (condition, message) => {
  if (!condition) {
    const error = new InvalidStateError(message);
    Error.captureStackTrace(error, assertState);
    throw error;
  }
};
var InvalidStateError = class extends Error {
};
export {
  InvalidStateError,
  InvariantViolation,
  assertArgument,
  assertState,
  failedInvariant,
  invariant
};
//# sourceMappingURL=index.mjs.map
