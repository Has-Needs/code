import Observable from 'zen-observable';
import type { ObservableLike, Subscriber } from 'zen-observable/esm';
import PushStream from 'zen-push';
import { type Event } from './events';
export { Observable, PushStream, type Subscriber };
/**
 * Observable which supports multiple subscribers and stores the current value.
 *
 * The current value is emitted to new subscribers on subscription.
 */
export declare class MulticastObservable<T> extends Observable<T> {
    protected _value?: T | undefined;
    private readonly _observers;
    private readonly _observable;
    private readonly _completed;
    constructor(subscriber: Observable<T> | Subscriber<T>, _value?: T | undefined);
    static from<T>(value: Observable<T> | ObservableLike<T> | ArrayLike<T> | Event<T>, initialValue?: T): MulticastObservable<T>;
    static of<T>(...items: T[]): MulticastObservable<T>;
    /**
     * @returns Stable reference to an observable that always returns `undefined`.
     */
    static empty(): MulticastObservable<null>;
    /**
     * Get the current value of the observable.
     */
    get(): T;
    /**
     * Wait for the observable to complete.
     *
     * @returns Promise that resolves to the value of the observable at the time of completion.
     */
    wait({ timeout }?: {
        timeout?: number;
    }): Promise<T>;
    forEach(callback: (value: T) => void): Promise<void>;
    map<R>(callback: (value: T) => R): MulticastObservable<R>;
    filter(callback: (value: T) => boolean): MulticastObservable<T>;
    reduce<R = T>(callback: (previousValue: R, currentValue: T) => R, initialValue?: R): MulticastObservable<R>;
    flatMap<R>(callback: (value: T) => MulticastObservable<R>): MulticastObservable<R>;
    concat<R>(...observables: Array<Observable<R>>): MulticastObservable<R>;
    /**
     * Concatenates multicast observables without losing the current value.
     * @param reducer reduces the values of any multicast observables being concatenated into a single value
     * @param observables observables to concatenate
     * @returns concatenated observable
     */
    losslessConcat<R>(reducer: (currentValue: R, newValues: R[]) => R, ...observables: Array<Observable<R>>): MulticastObservable<R>;
    private _subscribe;
    private _handlers;
}
//# sourceMappingURL=observable.d.ts.map