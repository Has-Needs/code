import { type Context } from '@dxos/context';
import { type MaybePromise } from '@dxos/util';
/**
 * A task that can be scheduled to run in the next event loop iteration.
 * Could be triggered multiple times, but only runs once.
 * If a new task is triggered while a previous one is running, the next run would occur immediately after the current run has finished.
 */
export declare class DeferredTask {
    private readonly _ctx;
    private readonly _callback;
    private _scheduled;
    private _currentTask;
    private _nextTask;
    constructor(_ctx: Context, _callback: () => Promise<void>);
    get scheduled(): boolean;
    /**
     * Schedule the task to run asynchronously.
     */
    schedule(): void;
    /**
     * Schedule the task to run and wait for it to finish.
     */
    runBlocking(): Promise<void>;
    /**
     * Waits for the current task to finish if it is running.
     * Does not schedule a new task.
     */
    join(): Promise<void>;
}
export declare const runInContext: (ctx: Context, fn: () => void) => void;
export declare const runInContextAsync: (ctx: Context, fn: () => MaybePromise<void>) => Promise<void>;
export declare const scheduleMicroTask: (ctx: Context, fn: () => MaybePromise<void>) => void;
export declare const scheduleTask: (ctx: Context, fn: () => MaybePromise<void>, afterMs?: number) => void;
/**
 * Run the task in the next event loop iteration, and then repeat in `interval` ms after the previous iteration completes.
 */
export declare const scheduleTaskInterval: (ctx: Context, task: () => Promise<void>, interval: number) => void;
export declare const scheduleExponentialBackoffTaskInterval: (ctx: Context, task: () => Promise<void>, initialInterval: number) => void;
//# sourceMappingURL=task-scheduling.d.ts.map