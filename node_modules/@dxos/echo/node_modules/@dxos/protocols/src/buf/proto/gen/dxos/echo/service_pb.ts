//
// Copyright 2021 DXOS.org
//

// @generated by protoc-gen-es v2.1.0 with parameter "target=ts,import_extension=js"
// @generated from file dxos/echo/service.proto (package dxos.echo.service, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv1";
import { fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv1";
import { file_dxos_keys } from "../keys_pb.js";
import type { EmptySchema } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_empty } from "@bufbuild/protobuf/wkt";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file dxos/echo/service.proto.
 */
export const file_dxos_echo_service: GenFile = /*@__PURE__*/
  fileDesc("ChdkeG9zL2VjaG8vc2VydmljZS5wcm90bxIRZHhvcy5lY2hvLnNlcnZpY2UiPQoQU3Vic2NyaWJlUmVxdWVzdBIXCg9zdWJzY3JpcHRpb25faWQYASABKAkSEAoIc3BhY2VfaWQYAiABKAkiTAoWQmF0Y2hlZERvY3VtZW50VXBkYXRlcxIyCgd1cGRhdGVzGAEgAygLMiEuZHhvcy5lY2hvLnNlcnZpY2UuRG9jdW1lbnRVcGRhdGUiXAoNVXBkYXRlUmVxdWVzdBIXCg9zdWJzY3JpcHRpb25faWQYASABKAkSMgoHdXBkYXRlcxgCIAMoCzIhLmR4b3MuZWNoby5zZXJ2aWNlLkRvY3VtZW50VXBkYXRlIlkKGVVwZGF0ZVN1YnNjcmlwdGlvblJlcXVlc3QSFwoPc3Vic2NyaXB0aW9uX2lkGAEgASgJEg8KB2FkZF9pZHMYAyADKAkSEgoKcmVtb3ZlX2lkcxgEIAMoCSIkCgxGbHVzaFJlcXVlc3QSFAoMZG9jdW1lbnRfaWRzGAEgAygJIlcKDkRvY3VtZW50VXBkYXRlEhMKC2RvY3VtZW50X2lkGAEgASgJEhAKCG11dGF0aW9uGAIgASgMEhMKBmlzX25ldxgDIAEoCEgAiAEBQgkKB19pc19uZXcicwoMRG9jSGVhZHNMaXN0EjYKB2VudHJpZXMYASADKAsyJS5keG9zLmVjaG8uc2VydmljZS5Eb2NIZWFkc0xpc3QuRW50cnkaKwoFRW50cnkSEwoLZG9jdW1lbnRfaWQYASABKAkSDQoFaGVhZHMYAiADKAkiLwoXR2V0RG9jdW1lbnRIZWFkc1JlcXVlc3QSFAoMZG9jdW1lbnRfaWRzGAEgAygJIkoKGEdldERvY3VtZW50SGVhZHNSZXNwb25zZRIuCgVoZWFkcxgBIAEoCzIfLmR4b3MuZWNoby5zZXJ2aWNlLkRvY0hlYWRzTGlzdCJRCh9XYWl0VW50aWxIZWFkc1JlcGxpY2F0ZWRSZXF1ZXN0Ei4KBWhlYWRzGAEgASgLMh8uZHhvcy5lY2hvLnNlcnZpY2UuRG9jSGVhZHNMaXN0IisKE1JlSW5kZXhIZWFkc1JlcXVlc3QSFAoMZG9jdW1lbnRfaWRzGAEgAygJIiwKGEdldFNwYWNlU3luY1N0YXRlUmVxdWVzdBIQCghzcGFjZV9pZBgBIAEoCSL6AQoOU3BhY2VTeW5jU3RhdGUSOgoFcGVlcnMYASADKAsyKy5keG9zLmVjaG8uc2VydmljZS5TcGFjZVN5bmNTdGF0ZS5QZWVyU3RhdGUaqwEKCVBlZXJTdGF0ZRIPCgdwZWVyX2lkGAEgASgJEhkKEW1pc3Npbmdfb25fcmVtb3RlGAogASgFEhgKEG1pc3Npbmdfb25fbG9jYWwYCyABKAUSGwoTZGlmZmVyZW50X2RvY3VtZW50cxgMIAEoBRIcChRsb2NhbF9kb2N1bWVudF9jb3VudBgNIAEoBRIdChVyZW1vdGVfZG9jdW1lbnRfY291bnQYDiABKAUyoQYKC0RhdGFTZXJ2aWNlEl0KCVN1YnNjcmliZRIjLmR4b3MuZWNoby5zZXJ2aWNlLlN1YnNjcmliZVJlcXVlc3QaKS5keG9zLmVjaG8uc2VydmljZS5CYXRjaGVkRG9jdW1lbnRVcGRhdGVzMAESWgoSVXBkYXRlU3Vic2NyaXB0aW9uEiwuZHhvcy5lY2hvLnNlcnZpY2UuVXBkYXRlU3Vic2NyaXB0aW9uUmVxdWVzdBoWLmdvb2dsZS5wcm90b2J1Zi5FbXB0eRJCCgZVcGRhdGUSIC5keG9zLmVjaG8uc2VydmljZS5VcGRhdGVSZXF1ZXN0GhYuZ29vZ2xlLnByb3RvYnVmLkVtcHR5EkAKBUZsdXNoEh8uZHhvcy5lY2hvLnNlcnZpY2UuRmx1c2hSZXF1ZXN0GhYuZ29vZ2xlLnByb3RvYnVmLkVtcHR5EmsKEEdldERvY3VtZW50SGVhZHMSKi5keG9zLmVjaG8uc2VydmljZS5HZXREb2N1bWVudEhlYWRzUmVxdWVzdBorLmR4b3MuZWNoby5zZXJ2aWNlLkdldERvY3VtZW50SGVhZHNSZXNwb25zZRJmChhXYWl0VW50aWxIZWFkc1JlcGxpY2F0ZWQSMi5keG9zLmVjaG8uc2VydmljZS5XYWl0VW50aWxIZWFkc1JlcGxpY2F0ZWRSZXF1ZXN0GhYuZ29vZ2xlLnByb3RvYnVmLkVtcHR5Ek4KDFJlSW5kZXhIZWFkcxImLmR4b3MuZWNoby5zZXJ2aWNlLlJlSW5kZXhIZWFkc1JlcXVlc3QaFi5nb29nbGUucHJvdG9idWYuRW1wdHkSPwoNVXBkYXRlSW5kZXhlcxIWLmdvb2dsZS5wcm90b2J1Zi5FbXB0eRoWLmdvb2dsZS5wcm90b2J1Zi5FbXB0eRJrChdTdWJzY3JpYmVTcGFjZVN5bmNTdGF0ZRIrLmR4b3MuZWNoby5zZXJ2aWNlLkdldFNwYWNlU3luY1N0YXRlUmVxdWVzdBohLmR4b3MuZWNoby5zZXJ2aWNlLlNwYWNlU3luY1N0YXRlMAFiBnByb3RvMw", [file_dxos_keys, file_google_protobuf_empty]);

/**
 * @generated from message dxos.echo.service.SubscribeRequest
 */
export type SubscribeRequest = Message<"dxos.echo.service.SubscribeRequest"> & {
  /**
   * @generated from field: string subscription_id = 1;
   */
  subscriptionId: string;

  /**
   * @generated from field: string space_id = 2;
   */
  spaceId: string;
};

/**
 * Describes the message dxos.echo.service.SubscribeRequest.
 * Use `create(SubscribeRequestSchema)` to create a new message.
 */
export const SubscribeRequestSchema: GenMessage<SubscribeRequest> = /*@__PURE__*/
  messageDesc(file_dxos_echo_service, 0);

/**
 * @generated from message dxos.echo.service.BatchedDocumentUpdates
 */
export type BatchedDocumentUpdates = Message<"dxos.echo.service.BatchedDocumentUpdates"> & {
  /**
   * @generated from field: repeated dxos.echo.service.DocumentUpdate updates = 1;
   */
  updates: DocumentUpdate[];
};

/**
 * Describes the message dxos.echo.service.BatchedDocumentUpdates.
 * Use `create(BatchedDocumentUpdatesSchema)` to create a new message.
 */
export const BatchedDocumentUpdatesSchema: GenMessage<BatchedDocumentUpdates> = /*@__PURE__*/
  messageDesc(file_dxos_echo_service, 1);

/**
 * @generated from message dxos.echo.service.UpdateRequest
 */
export type UpdateRequest = Message<"dxos.echo.service.UpdateRequest"> & {
  /**
   * @generated from field: string subscription_id = 1;
   */
  subscriptionId: string;

  /**
   * @generated from field: repeated dxos.echo.service.DocumentUpdate updates = 2;
   */
  updates: DocumentUpdate[];
};

/**
 * Describes the message dxos.echo.service.UpdateRequest.
 * Use `create(UpdateRequestSchema)` to create a new message.
 */
export const UpdateRequestSchema: GenMessage<UpdateRequest> = /*@__PURE__*/
  messageDesc(file_dxos_echo_service, 2);

/**
 * @generated from message dxos.echo.service.UpdateSubscriptionRequest
 */
export type UpdateSubscriptionRequest = Message<"dxos.echo.service.UpdateSubscriptionRequest"> & {
  /**
   * *
   * Id of the subscription to update.
   * Subscription id is returned by `Subscribe` rpc.
   *
   * @generated from field: string subscription_id = 1;
   */
  subscriptionId: string;

  /**
   * *
   * Automerge document ids to subscribe for updates.
   * Used for already existing documents.
   * To add new document use `write` rpc.
   *
   * @generated from field: repeated string add_ids = 3;
   */
  addIds: string[];

  /**
   * *
   * Automerge document ids to unsubscribe from.
   *
   * @generated from field: repeated string remove_ids = 4;
   */
  removeIds: string[];
};

/**
 * Describes the message dxos.echo.service.UpdateSubscriptionRequest.
 * Use `create(UpdateSubscriptionRequestSchema)` to create a new message.
 */
export const UpdateSubscriptionRequestSchema: GenMessage<UpdateSubscriptionRequest> = /*@__PURE__*/
  messageDesc(file_dxos_echo_service, 3);

/**
 * @generated from message dxos.echo.service.FlushRequest
 */
export type FlushRequest = Message<"dxos.echo.service.FlushRequest"> & {
  /**
   * *
   * Automerge specific document ids to wait to flush.
   *
   * @generated from field: repeated string document_ids = 1;
   */
  documentIds: string[];
};

/**
 * Describes the message dxos.echo.service.FlushRequest.
 * Use `create(FlushRequestSchema)` to create a new message.
 */
export const FlushRequestSchema: GenMessage<FlushRequest> = /*@__PURE__*/
  messageDesc(file_dxos_echo_service, 4);

/**
 * @generated from message dxos.echo.service.DocumentUpdate
 */
export type DocumentUpdate = Message<"dxos.echo.service.DocumentUpdate"> & {
  /**
   * *
   * Automerge document id.
   *
   * @generated from field: string document_id = 1;
   */
  documentId: string;

  /**
   * *
   * Automerge document incremental update.
   * Value returned by `Automerge.saveSince()`.
   *
   * @generated from field: bytes mutation = 2;
   */
  mutation: Uint8Array;

  /**
   * *
   * Set to true for init mutation of document.
   * default: undefined.
   *
   * @generated from field: optional bool is_new = 3;
   */
  isNew?: boolean;
};

/**
 * Describes the message dxos.echo.service.DocumentUpdate.
 * Use `create(DocumentUpdateSchema)` to create a new message.
 */
export const DocumentUpdateSchema: GenMessage<DocumentUpdate> = /*@__PURE__*/
  messageDesc(file_dxos_echo_service, 5);

/**
 * @generated from message dxos.echo.service.DocHeadsList
 */
export type DocHeadsList = Message<"dxos.echo.service.DocHeadsList"> & {
  /**
   * @generated from field: repeated dxos.echo.service.DocHeadsList.Entry entries = 1;
   */
  entries: DocHeadsList_Entry[];
};

/**
 * Describes the message dxos.echo.service.DocHeadsList.
 * Use `create(DocHeadsListSchema)` to create a new message.
 */
export const DocHeadsListSchema: GenMessage<DocHeadsList> = /*@__PURE__*/
  messageDesc(file_dxos_echo_service, 6);

/**
 * @generated from message dxos.echo.service.DocHeadsList.Entry
 */
export type DocHeadsList_Entry = Message<"dxos.echo.service.DocHeadsList.Entry"> & {
  /**
   * @generated from field: string document_id = 1;
   */
  documentId: string;

  /**
   * @generated from field: repeated string heads = 2;
   */
  heads: string[];
};

/**
 * Describes the message dxos.echo.service.DocHeadsList.Entry.
 * Use `create(DocHeadsList_EntrySchema)` to create a new message.
 */
export const DocHeadsList_EntrySchema: GenMessage<DocHeadsList_Entry> = /*@__PURE__*/
  messageDesc(file_dxos_echo_service, 6, 0);

/**
 * @generated from message dxos.echo.service.GetDocumentHeadsRequest
 */
export type GetDocumentHeadsRequest = Message<"dxos.echo.service.GetDocumentHeadsRequest"> & {
  /**
   * @generated from field: repeated string document_ids = 1;
   */
  documentIds: string[];
};

/**
 * Describes the message dxos.echo.service.GetDocumentHeadsRequest.
 * Use `create(GetDocumentHeadsRequestSchema)` to create a new message.
 */
export const GetDocumentHeadsRequestSchema: GenMessage<GetDocumentHeadsRequest> = /*@__PURE__*/
  messageDesc(file_dxos_echo_service, 7);

/**
 * @generated from message dxos.echo.service.GetDocumentHeadsResponse
 */
export type GetDocumentHeadsResponse = Message<"dxos.echo.service.GetDocumentHeadsResponse"> & {
  /**
   * @generated from field: dxos.echo.service.DocHeadsList heads = 1;
   */
  heads?: DocHeadsList;
};

/**
 * Describes the message dxos.echo.service.GetDocumentHeadsResponse.
 * Use `create(GetDocumentHeadsResponseSchema)` to create a new message.
 */
export const GetDocumentHeadsResponseSchema: GenMessage<GetDocumentHeadsResponse> = /*@__PURE__*/
  messageDesc(file_dxos_echo_service, 8);

/**
 * @generated from message dxos.echo.service.WaitUntilHeadsReplicatedRequest
 */
export type WaitUntilHeadsReplicatedRequest = Message<"dxos.echo.service.WaitUntilHeadsReplicatedRequest"> & {
  /**
   * @generated from field: dxos.echo.service.DocHeadsList heads = 1;
   */
  heads?: DocHeadsList;
};

/**
 * Describes the message dxos.echo.service.WaitUntilHeadsReplicatedRequest.
 * Use `create(WaitUntilHeadsReplicatedRequestSchema)` to create a new message.
 */
export const WaitUntilHeadsReplicatedRequestSchema: GenMessage<WaitUntilHeadsReplicatedRequest> = /*@__PURE__*/
  messageDesc(file_dxos_echo_service, 9);

/**
 * @generated from message dxos.echo.service.ReIndexHeadsRequest
 */
export type ReIndexHeadsRequest = Message<"dxos.echo.service.ReIndexHeadsRequest"> & {
  /**
   * @generated from field: repeated string document_ids = 1;
   */
  documentIds: string[];
};

/**
 * Describes the message dxos.echo.service.ReIndexHeadsRequest.
 * Use `create(ReIndexHeadsRequestSchema)` to create a new message.
 */
export const ReIndexHeadsRequestSchema: GenMessage<ReIndexHeadsRequest> = /*@__PURE__*/
  messageDesc(file_dxos_echo_service, 10);

/**
 * @generated from message dxos.echo.service.GetSpaceSyncStateRequest
 */
export type GetSpaceSyncStateRequest = Message<"dxos.echo.service.GetSpaceSyncStateRequest"> & {
  /**
   * @generated from field: string space_id = 1;
   */
  spaceId: string;
};

/**
 * Describes the message dxos.echo.service.GetSpaceSyncStateRequest.
 * Use `create(GetSpaceSyncStateRequestSchema)` to create a new message.
 */
export const GetSpaceSyncStateRequestSchema: GenMessage<GetSpaceSyncStateRequest> = /*@__PURE__*/
  messageDesc(file_dxos_echo_service, 11);

/**
 * @generated from message dxos.echo.service.SpaceSyncState
 */
export type SpaceSyncState = Message<"dxos.echo.service.SpaceSyncState"> & {
  /**
   * @generated from field: repeated dxos.echo.service.SpaceSyncState.PeerState peers = 1;
   */
  peers: SpaceSyncState_PeerState[];
};

/**
 * Describes the message dxos.echo.service.SpaceSyncState.
 * Use `create(SpaceSyncStateSchema)` to create a new message.
 */
export const SpaceSyncStateSchema: GenMessage<SpaceSyncState> = /*@__PURE__*/
  messageDesc(file_dxos_echo_service, 12);

/**
 * @generated from message dxos.echo.service.SpaceSyncState.PeerState
 */
export type SpaceSyncState_PeerState = Message<"dxos.echo.service.SpaceSyncState.PeerState"> & {
  /**
   * @generated from field: string peer_id = 1;
   */
  peerId: string;

  /**
   * *
   * Documents that are present locally but not on the remote peer.
   *
   * @generated from field: int32 missing_on_remote = 10;
   */
  missingOnRemote: number;

  /**
   * *
   * Documents that are present on the remote peer but not locally.
   *
   * @generated from field: int32 missing_on_local = 11;
   */
  missingOnLocal: number;

  /**
   * *
   * Documents that are present on both peers but have different heads.
   *
   * @generated from field: int32 different_documents = 12;
   */
  differentDocuments: number;

  /**
   * *
   * Total number of documents locally.
   *
   * @generated from field: int32 local_document_count = 13;
   */
  localDocumentCount: number;

  /**
   * *
   * Total number of documents on the remote peer.
   *
   * @generated from field: int32 remote_document_count = 14;
   */
  remoteDocumentCount: number;
};

/**
 * Describes the message dxos.echo.service.SpaceSyncState.PeerState.
 * Use `create(SpaceSyncState_PeerStateSchema)` to create a new message.
 */
export const SpaceSyncState_PeerStateSchema: GenMessage<SpaceSyncState_PeerState> = /*@__PURE__*/
  messageDesc(file_dxos_echo_service, 12, 0);

/**
 * @generated from service dxos.echo.service.DataService
 */
export const DataService: GenService<{
  /**
   * *
   * Subscribe to incremental updates of multiple automerge socuments.
   * Which documents are subscribed to is defined in the `UpdateSubscription`.
   * Used to propagate changes from services to client.
   *
   * @generated from rpc dxos.echo.service.DataService.Subscribe
   */
  subscribe: {
    methodKind: "server_streaming";
    input: typeof SubscribeRequestSchema;
    output: typeof BatchedDocumentUpdatesSchema;
  },
  /**
   * *
   * Change which documents are subscribed to for specific subscription.
   *
   * @generated from rpc dxos.echo.service.DataService.UpdateSubscription
   */
  updateSubscription: {
    methodKind: "unary";
    input: typeof UpdateSubscriptionRequestSchema;
    output: typeof EmptySchema;
  },
  /**
   * *
   * Write incremental updates to multiple automerge documents.
   * Used to propagate changes from client to services.
   *
   * @generated from rpc dxos.echo.service.DataService.Update
   */
  update: {
    methodKind: "unary";
    input: typeof UpdateRequestSchema;
    output: typeof EmptySchema;
  },
  /**
   * @generated from rpc dxos.echo.service.DataService.Flush
   */
  flush: {
    methodKind: "unary";
    input: typeof FlushRequestSchema;
    output: typeof EmptySchema;
  },
  /**
   * @generated from rpc dxos.echo.service.DataService.GetDocumentHeads
   */
  getDocumentHeads: {
    methodKind: "unary";
    input: typeof GetDocumentHeadsRequestSchema;
    output: typeof GetDocumentHeadsResponseSchema;
  },
  /**
   * / Wait until the we have the specified changes on the worker locally. Does not take into account the index or client.
   *
   * @generated from rpc dxos.echo.service.DataService.WaitUntilHeadsReplicated
   */
  waitUntilHeadsReplicated: {
    methodKind: "unary";
    input: typeof WaitUntilHeadsReplicatedRequestSchema;
    output: typeof EmptySchema;
  },
  /**
   * / Update heads index for selected docuemnts.
   *
   * @generated from rpc dxos.echo.service.DataService.ReIndexHeads
   */
  reIndexHeads: {
    methodKind: "unary";
    input: typeof ReIndexHeadsRequestSchema;
    output: typeof EmptySchema;
  },
  /**
   * / Wait for any pending index updates.
   *
   * @generated from rpc dxos.echo.service.DataService.UpdateIndexes
   */
  updateIndexes: {
    methodKind: "unary";
    input: typeof EmptySchema;
    output: typeof EmptySchema;
  },
  /**
   * TODO(dmaretskyi): Stream subscription.
   *
   * @generated from rpc dxos.echo.service.DataService.SubscribeSpaceSyncState
   */
  subscribeSpaceSyncState: {
    methodKind: "server_streaming";
    input: typeof GetSpaceSyncStateRequestSchema;
    output: typeof SpaceSyncStateSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_dxos_echo_service, 0);

