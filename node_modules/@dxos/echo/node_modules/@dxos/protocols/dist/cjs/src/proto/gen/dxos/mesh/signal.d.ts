import type { Stream, RequestOptions } from "@dxos/codec-protobuf";
import substitutions from "../../../substitutions.js";
/**
 * @deprecated
 *
 * Defined in:
 *   {@link file://./../../../dxos/mesh/signal.proto}
 */
export interface JoinRequest {
    swarm: Uint8Array;
    peer: Uint8Array;
    /**
     * Options:
     *   - proto3_optional = true
     */
    metadata?: ReturnType<(typeof substitutions)["google.protobuf.Struct"]["decode"]>;
}
/**
 * @deprecated
 *
 * Defined in:
 *   {@link file://./../../../dxos/mesh/signal.proto}
 */
export interface Message {
    author: Uint8Array;
    recipient: Uint8Array;
    payload: ReturnType<(typeof substitutions)["google.protobuf.Any"]["decode"]>;
    /**
     * Options:
     *   - proto3_optional = true
     */
    metadata?: ReturnType<(typeof substitutions)["google.protobuf.Struct"]["decode"]>;
}
/**
 * @deprecated
 *
 * Defined in:
 *   {@link file://./../../../dxos/mesh/signal.proto}
 */
export interface ReceptionRequest {
    peer: Uint8Array;
}
/**
 * @deprecated
 *
 * Defined in:
 *   {@link file://./../../../dxos/mesh/signal.proto}
 */
export interface SwarmEvent {
    /**
     * The peer was announced as available on the swarm.
     */
    peerAvailable?: SwarmEvent.PeerAvailable;
    /**
     * The peer left, or their announcement timed out.
     */
    peerLeft?: SwarmEvent.PeerLeft;
}
export declare namespace SwarmEvent {
    /**
     * Defined in:
     *   {@link file://./../../../dxos/mesh/signal.proto}
     */
    interface PeerAvailable {
        peer: Uint8Array;
        since: ReturnType<(typeof substitutions)["google.protobuf.Timestamp"]["decode"]>;
        /**
         * Options:
         *   - proto3_optional = true
         */
        until?: ReturnType<(typeof substitutions)["google.protobuf.Timestamp"]["decode"]>;
        /**
         * Only relevant in Pub/Sub. Optional, the host topic to eagerly send PeerAvailable messages back to.
         *
         * Options:
         *   - proto3_optional = true
         */
        announceBackToHost?: Uint8Array;
    }
    /**
     * Defined in:
     *   {@link file://./../../../dxos/mesh/signal.proto}
     */
    interface PeerLeft {
        peer: Uint8Array;
    }
}
/**
 * @deprecated
 *
 * Defined in:
 *   {@link file://./../../../dxos/mesh/signal.proto}
 */
export interface HostEvent {
    announceBack?: HostEvent.AnnounceBack;
}
export declare namespace HostEvent {
    /**
     * Defined in:
     *   {@link file://./../../../dxos/mesh/signal.proto}
     */
    interface AnnounceBack {
        swarm: Uint8Array;
        peerAvailable: SwarmEvent.PeerAvailable;
    }
}
/**
 * @deprecated
 *
 * Defined in:
 *   {@link file://./../../../dxos/mesh/signal.proto}
 */
export interface PeerEvent {
    message?: Message;
}
/**
 * @deprecated
 *
 * Defined in:
 *   {@link file://./../../../dxos/mesh/signal.proto}
 */
export declare enum SignalState {
    CONNECTING = 0,
    RECONNECTING = 1,
    CONNECTED = 2,
    DISCONNECTED = 3,
    ERROR = 4,
    CLOSED = 5
}
/**
 * @deprecated
 *
 * Defined in:
 *   {@link file://./../../../dxos/mesh/signal.proto}
 */
export interface Signal {
    join: (request: JoinRequest, options?: RequestOptions) => Stream<SwarmEvent>;
    receiveMessages: (request: ReceptionRequest, options?: RequestOptions) => Stream<Message>;
    sendMessage: (request: Message, options?: RequestOptions) => Promise<void>;
}
//# sourceMappingURL=signal.d.ts.map