import { Schema } from 'effect';
/**
 * Filter by object type and properties.
 *
 * Clauses are combined using logical AND.
 */
declare const FilterObject_: Schema.Struct<{
    type: Schema.Literal<["object"]>;
    typename: Schema.Union<[Schema.refine<string, typeof Schema.NonEmptyString>, typeof Schema.Null]>;
    id: Schema.optional<Schema.Array$<import("@dxos/keys").ObjectIdClass>>;
    /**
     * Filter by property.
     * Must not include object ID.
     */
    props: Schema.Record$<Schema.SchemaClass<string, string, never>, Schema.suspend<FilterObject | FilterTextSearch | FilterCompare | FilterIn | FilterRange | FilterNot | FilterAnd | FilterOr, FilterObject | FilterTextSearch | FilterCompare | FilterIn | FilterRange | FilterNot | FilterAnd | FilterOr, never>>;
    /**
     * Objects that have any of the given foreign keys.
     */
    foreignKeys: Schema.optional<Schema.Array$<Schema.Schema<{
        readonly source: string;
        readonly id: string;
    }, {
        readonly source: string;
        readonly id: string;
    }, never>>>;
}>;
export interface FilterObject extends Schema.Schema.Type<typeof FilterObject_> {
}
export declare const FilterObject: Schema.Schema<FilterObject>;
declare const FilterCompare_: Schema.Struct<{
    type: Schema.Literal<["compare"]>;
    operator: Schema.Literal<["eq", "neq", "gt", "gte", "lt", "lte"]>;
    value: typeof Schema.Unknown;
}>;
export interface FilterCompare extends Schema.Schema.Type<typeof FilterCompare_> {
}
export declare const FilterCompare: Schema.Schema<FilterCompare>;
declare const FilterIn_: Schema.Struct<{
    type: Schema.Literal<["in"]>;
    values: Schema.Array$<typeof Schema.Any>;
}>;
export interface FilterIn extends Schema.Schema.Type<typeof FilterIn_> {
}
export declare const FilterIn: Schema.Schema<FilterIn>;
declare const FilterRange_: Schema.Struct<{
    type: Schema.Literal<["range"]>;
    from: typeof Schema.Any;
    to: typeof Schema.Any;
}>;
export interface FilterRange extends Schema.Schema.Type<typeof FilterRange_> {
}
export declare const FilterRange: Schema.Schema<FilterRange>;
declare const FilterTextSearch_: Schema.Struct<{
    type: Schema.Literal<["text-search"]>;
    text: typeof Schema.String;
    searchKind: Schema.optional<Schema.Literal<["full-text", "vector"]>>;
}>;
export interface FilterTextSearch extends Schema.Schema.Type<typeof FilterTextSearch_> {
}
export declare const FilterTextSearch: Schema.Schema<FilterTextSearch>;
declare const FilterNot_: Schema.Struct<{
    type: Schema.Literal<["not"]>;
    filter: Schema.suspend<FilterObject | FilterTextSearch | FilterCompare | FilterIn | FilterRange | FilterNot | FilterAnd | FilterOr, FilterObject | FilterTextSearch | FilterCompare | FilterIn | FilterRange | FilterNot | FilterAnd | FilterOr, never>;
}>;
export interface FilterNot extends Schema.Schema.Type<typeof FilterNot_> {
}
export declare const FilterNot: Schema.Schema<FilterNot>;
declare const FilterAnd_: Schema.Struct<{
    type: Schema.Literal<["and"]>;
    filters: Schema.Array$<Schema.suspend<FilterObject | FilterTextSearch | FilterCompare | FilterIn | FilterRange | FilterNot | FilterAnd | FilterOr, FilterObject | FilterTextSearch | FilterCompare | FilterIn | FilterRange | FilterNot | FilterAnd | FilterOr, never>>;
}>;
export interface FilterAnd extends Schema.Schema.Type<typeof FilterAnd_> {
}
export declare const FilterAnd: Schema.Schema<FilterAnd>;
declare const FilterOr_: Schema.Struct<{
    type: Schema.Literal<["or"]>;
    filters: Schema.Array$<Schema.suspend<FilterObject | FilterTextSearch | FilterCompare | FilterIn | FilterRange | FilterNot | FilterAnd | FilterOr, FilterObject | FilterTextSearch | FilterCompare | FilterIn | FilterRange | FilterNot | FilterAnd | FilterOr, never>>;
}>;
export interface FilterOr extends Schema.Schema.Type<typeof FilterOr_> {
}
export declare const FilterOr: Schema.Schema<FilterOr>;
export declare const Filter: Schema.Union<[Schema.Schema<FilterObject, FilterObject, never>, Schema.Schema<FilterTextSearch, FilterTextSearch, never>, Schema.Schema<FilterCompare, FilterCompare, never>, Schema.Schema<FilterIn, FilterIn, never>, Schema.Schema<FilterRange, FilterRange, never>, Schema.Schema<FilterNot, FilterNot, never>, Schema.Schema<FilterAnd, FilterAnd, never>, Schema.Schema<FilterOr, FilterOr, never>]>;
export type Filter = Schema.Schema.Type<typeof Filter>;
/**
 * Query objects by type, id, and/or predicates.
 */
declare const QuerySelectClause_: Schema.Struct<{
    type: Schema.Literal<["select"]>;
    filter: Schema.suspend<FilterObject | FilterTextSearch | FilterCompare | FilterIn | FilterRange | FilterNot | FilterAnd | FilterOr, FilterObject | FilterTextSearch | FilterCompare | FilterIn | FilterRange | FilterNot | FilterAnd | FilterOr, never>;
}>;
export interface QuerySelectClause extends Schema.Schema.Type<typeof QuerySelectClause_> {
}
export declare const QuerySelectClause: Schema.Schema<QuerySelectClause>;
/**
 * Filter objects from selection.
 */
declare const QueryFilterClause_: Schema.Struct<{
    type: Schema.Literal<["filter"]>;
    selection: Schema.suspend<QuerySelectClause | QueryFilterClause | QueryReferenceTraversalClause | QueryIncomingReferencesClause | QueryRelationClause | QueryRelationTraversalClause | QueryUnionClause | QuerySetDifferenceClause | QueryOptionsClause, QuerySelectClause | QueryFilterClause | QueryReferenceTraversalClause | QueryIncomingReferencesClause | QueryRelationClause | QueryRelationTraversalClause | QueryUnionClause | QuerySetDifferenceClause | QueryOptionsClause, never>;
    filter: Schema.suspend<FilterObject | FilterTextSearch | FilterCompare | FilterIn | FilterRange | FilterNot | FilterAnd | FilterOr, FilterObject | FilterTextSearch | FilterCompare | FilterIn | FilterRange | FilterNot | FilterAnd | FilterOr, never>;
}>;
export interface QueryFilterClause extends Schema.Schema.Type<typeof QueryFilterClause_> {
}
export declare const QueryFilterClause: Schema.Schema<QueryFilterClause>;
/**
 * Traverse references from an anchor object.
 */
declare const QueryReferenceTraversalClause_: Schema.Struct<{
    type: Schema.Literal<["reference-traversal"]>;
    anchor: Schema.suspend<QuerySelectClause | QueryFilterClause | QueryReferenceTraversalClause | QueryIncomingReferencesClause | QueryRelationClause | QueryRelationTraversalClause | QueryUnionClause | QuerySetDifferenceClause | QueryOptionsClause, QuerySelectClause | QueryFilterClause | QueryReferenceTraversalClause | QueryIncomingReferencesClause | QueryRelationClause | QueryRelationTraversalClause | QueryUnionClause | QuerySetDifferenceClause | QueryOptionsClause, never>;
    property: typeof Schema.String;
}>;
export interface QueryReferenceTraversalClause extends Schema.Schema.Type<typeof QueryReferenceTraversalClause_> {
}
export declare const QueryReferenceTraversalClause: Schema.Schema<QueryReferenceTraversalClause>;
/**
 * Traverse incoming references to an anchor object.
 */
declare const QueryIncomingReferencesClause_: Schema.Struct<{
    type: Schema.Literal<["incoming-references"]>;
    anchor: Schema.suspend<QuerySelectClause | QueryFilterClause | QueryReferenceTraversalClause | QueryIncomingReferencesClause | QueryRelationClause | QueryRelationTraversalClause | QueryUnionClause | QuerySetDifferenceClause | QueryOptionsClause, QuerySelectClause | QueryFilterClause | QueryReferenceTraversalClause | QueryIncomingReferencesClause | QueryRelationClause | QueryRelationTraversalClause | QueryUnionClause | QuerySetDifferenceClause | QueryOptionsClause, never>;
    property: typeof Schema.String;
    typename: Schema.Union<[Schema.refine<string, typeof Schema.NonEmptyString>, typeof Schema.Null]>;
}>;
export interface QueryIncomingReferencesClause extends Schema.Schema.Type<typeof QueryIncomingReferencesClause_> {
}
export declare const QueryIncomingReferencesClause: Schema.Schema<QueryIncomingReferencesClause>;
/**
 * Traverse relations connecting to an anchor object.
 */
declare const QueryRelationClause_: Schema.Struct<{
    type: Schema.Literal<["relation"]>;
    anchor: Schema.suspend<QuerySelectClause | QueryFilterClause | QueryReferenceTraversalClause | QueryIncomingReferencesClause | QueryRelationClause | QueryRelationTraversalClause | QueryUnionClause | QuerySetDifferenceClause | QueryOptionsClause, QuerySelectClause | QueryFilterClause | QueryReferenceTraversalClause | QueryIncomingReferencesClause | QueryRelationClause | QueryRelationTraversalClause | QueryUnionClause | QuerySetDifferenceClause | QueryOptionsClause, never>;
    /**
     * outgoing: anchor is the source of the relation.
     * incoming: anchor is the target of the relation.
     * both: anchor is either the source or target of the relation.
     */
    direction: Schema.Literal<["outgoing", "incoming", "both"]>;
    filter: Schema.optional<Schema.suspend<FilterObject | FilterTextSearch | FilterCompare | FilterIn | FilterRange | FilterNot | FilterAnd | FilterOr, FilterObject | FilterTextSearch | FilterCompare | FilterIn | FilterRange | FilterNot | FilterAnd | FilterOr, never>>;
}>;
export interface QueryRelationClause extends Schema.Schema.Type<typeof QueryRelationClause_> {
}
export declare const QueryRelationClause: Schema.Schema<QueryRelationClause>;
/**
 * Traverse into the source or target of a relation.
 */
declare const QueryRelationTraversalClause_: Schema.Struct<{
    type: Schema.Literal<["relation-traversal"]>;
    anchor: Schema.suspend<QuerySelectClause | QueryFilterClause | QueryReferenceTraversalClause | QueryIncomingReferencesClause | QueryRelationClause | QueryRelationTraversalClause | QueryUnionClause | QuerySetDifferenceClause | QueryOptionsClause, QuerySelectClause | QueryFilterClause | QueryReferenceTraversalClause | QueryIncomingReferencesClause | QueryRelationClause | QueryRelationTraversalClause | QueryUnionClause | QuerySetDifferenceClause | QueryOptionsClause, never>;
    direction: Schema.Literal<["source", "target", "both"]>;
}>;
export interface QueryRelationTraversalClause extends Schema.Schema.Type<typeof QueryRelationTraversalClause_> {
}
export declare const QueryRelationTraversalClause: Schema.Schema<QueryRelationTraversalClause>;
/**
 * Union of multiple queries.
 */
declare const QueryUnionClause_: Schema.Struct<{
    type: Schema.Literal<["union"]>;
    queries: Schema.Array$<Schema.suspend<QuerySelectClause | QueryFilterClause | QueryReferenceTraversalClause | QueryIncomingReferencesClause | QueryRelationClause | QueryRelationTraversalClause | QueryUnionClause | QuerySetDifferenceClause | QueryOptionsClause, QuerySelectClause | QueryFilterClause | QueryReferenceTraversalClause | QueryIncomingReferencesClause | QueryRelationClause | QueryRelationTraversalClause | QueryUnionClause | QuerySetDifferenceClause | QueryOptionsClause, never>>;
}>;
export interface QueryUnionClause extends Schema.Schema.Type<typeof QueryUnionClause_> {
}
export declare const QueryUnionClause: Schema.Schema<QueryUnionClause>;
/**
 * Set difference of two queries.
 */
declare const QuerySetDifferenceClause_: Schema.Struct<{
    type: Schema.Literal<["set-difference"]>;
    source: Schema.suspend<QuerySelectClause | QueryFilterClause | QueryReferenceTraversalClause | QueryIncomingReferencesClause | QueryRelationClause | QueryRelationTraversalClause | QueryUnionClause | QuerySetDifferenceClause | QueryOptionsClause, QuerySelectClause | QueryFilterClause | QueryReferenceTraversalClause | QueryIncomingReferencesClause | QueryRelationClause | QueryRelationTraversalClause | QueryUnionClause | QuerySetDifferenceClause | QueryOptionsClause, never>;
    exclude: Schema.suspend<QuerySelectClause | QueryFilterClause | QueryReferenceTraversalClause | QueryIncomingReferencesClause | QueryRelationClause | QueryRelationTraversalClause | QueryUnionClause | QuerySetDifferenceClause | QueryOptionsClause, QuerySelectClause | QueryFilterClause | QueryReferenceTraversalClause | QueryIncomingReferencesClause | QueryRelationClause | QueryRelationTraversalClause | QueryUnionClause | QuerySetDifferenceClause | QueryOptionsClause, never>;
}>;
export interface QuerySetDifferenceClause extends Schema.Schema.Type<typeof QuerySetDifferenceClause_> {
}
export declare const QuerySetDifferenceClause: Schema.Schema<QuerySetDifferenceClause>;
/**
 * Add options to a query.
 */
declare const QueryOptionsClause_: Schema.Struct<{
    type: Schema.Literal<["options"]>;
    query: Schema.suspend<QuerySelectClause | QueryFilterClause | QueryReferenceTraversalClause | QueryIncomingReferencesClause | QueryRelationClause | QueryRelationTraversalClause | QueryUnionClause | QuerySetDifferenceClause | QueryOptionsClause, QuerySelectClause | QueryFilterClause | QueryReferenceTraversalClause | QueryIncomingReferencesClause | QueryRelationClause | QueryRelationTraversalClause | QueryUnionClause | QuerySetDifferenceClause | QueryOptionsClause, never>;
    options: Schema.suspend<{
        readonly deleted?: "include" | "exclude" | "only" | undefined;
        readonly spaceIds?: readonly string[] | undefined;
    }, {
        readonly deleted?: "include" | "exclude" | "only" | undefined;
        readonly spaceIds?: readonly string[] | undefined;
    }, never>;
}>;
export interface QueryOptionsClause extends Schema.Schema.Type<typeof QueryOptionsClause_> {
}
export declare const QueryOptionsClause: Schema.Schema<QueryOptionsClause>;
declare const Query_: Schema.Union<[Schema.Schema<QuerySelectClause, QuerySelectClause, never>, Schema.Schema<QueryFilterClause, QueryFilterClause, never>, Schema.Schema<QueryReferenceTraversalClause, QueryReferenceTraversalClause, never>, Schema.Schema<QueryIncomingReferencesClause, QueryIncomingReferencesClause, never>, Schema.Schema<QueryRelationClause, QueryRelationClause, never>, Schema.Schema<QueryRelationTraversalClause, QueryRelationTraversalClause, never>, Schema.Schema<QueryUnionClause, QueryUnionClause, never>, Schema.Schema<QuerySetDifferenceClause, QuerySetDifferenceClause, never>, Schema.Schema<QueryOptionsClause, QueryOptionsClause, never>]>;
export type Query = Schema.Schema.Type<typeof Query_>;
export declare const Query: Schema.Schema<Query>;
export declare const QueryOptions: Schema.Struct<{
    spaceIds: Schema.optional<Schema.Array$<typeof Schema.String>>;
    deleted: Schema.optional<Schema.Literal<["include", "exclude", "only"]>>;
}>;
export interface QueryOptions extends Schema.Schema.Type<typeof QueryOptions> {
}
export declare const visit: (query: Query, visitor: (node: Query) => void) => void;
export {};
//# sourceMappingURL=ast.d.ts.map