{
  "version": 3,
  "sources": ["../../../src/buffer-patch.ts", "../../../src/precompiled-mapping/create-message-mapper.ts", "../../../src/precompiled-mapping/codegen.ts", "../../../src/codec.ts", "../../../src/encoding.ts", "../../../src/mapping.ts", "../../../src/sanitizer.ts", "../../../src/schema.ts", "../../../src/service.ts", "../../../src/substitutions/struct.ts", "../../../src/substitutions/any.ts", "../../../src/substitutions/timestamp.ts", "../../../src/compression.ts", "../../../src/util.ts"],
  "sourcesContent": ["//\n// Copyright 2021 DXOS.org\n//\n\nimport { arrayToBuffer } from '@dxos/util';\n\nimport type { Codec } from './codec';\n\n/**\n * Protobuf codec returns instances of Uint8Arrays, but some storages expect to receive Buffers.\n * This function patches the encode method to convert result into a Buffer.\n */\nexport const patchBufferCodec = (codec: Codec<any>) => ({\n  encode: (x: any) => arrayToBuffer(codec.encode(x)),\n  decode: codec.decode.bind(codec),\n});\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport pb from 'protobufjs';\n\nimport { invariant } from '@dxos/invariant';\n\nimport { codegen, ref } from './codegen';\nimport { type MapingDescriptors, type TypeMapperContext } from '../mapping';\n\nexport type Mapper = (obj: any, extraArgs: any[]) => any;\n\nexport const createMessageMapper = (type: pb.Type, substitutions: MapingDescriptors): Mapper =>\n  createMessageMapperCached(type, substitutions, {}).map;\n\nconst createMessageMapperCached = (\n  type: pb.Type,\n  substitutions: MapingDescriptors,\n  cache: Record<string, { map: Mapper }>,\n) => {\n  if (!cache[type.fullName]) {\n    // Indirection to allow for recursive message types.\n    cache[type.fullName] = {} as any;\n    cache[type.fullName].map = codegen(`${type.name}$map`, ['obj', 'extraArgs'], (c) => {\n      c`const res = {};`;\n      for (const field of type.fieldsArray) {\n        field.resolve();\n        c`if(obj.${field.name} !== undefined && obj.${field.name} !== null) {`;\n        {\n          const genMapScalar = (value: string) => {\n            const substitution = field.resolvedType && substitutions[field.resolvedType.fullName.slice(1)];\n            if (substitution) {\n              const context: TypeMapperContext = {\n                messageName: type.fullName.slice(1),\n                fieldName: field.name,\n              };\n              c`${ref(substitution)}(${value}, ${ref(context)}, ...extraArgs)`;\n            } else if (field.resolvedType && field.resolvedType instanceof pb.Type) {\n              const mapper = createMessageMapperCached(field.resolvedType, substitutions, cache);\n              c`${ref(mapper)}.map(${value}, extraArgs)`;\n            } else {\n              c`${value}`;\n            }\n          };\n\n          if (field.repeated) {\n            c`res.${field.name} = obj.${field.name}.map(item => `;\n            genMapScalar('item');\n            c`);`;\n          } else if (field.map) {\n            invariant(field instanceof pb.MapField);\n            c`res.${field.name} = {};`;\n            c`for(const key of Object.keys(obj.${field.name})) {`;\n            {\n              c`res.${field.name}[key] = `;\n              genMapScalar(`obj.${field.name}[key]`);\n              c`;`;\n            }\n            c`}`;\n          } else {\n            c`res.${field.name} = `;\n            genMapScalar(`obj.${field.name}`);\n            c`;`;\n          }\n        }\n        c`}`;\n        if (!field.getOption('proto3_optional') && !field.repeated && !field.map && !field.partOf) {\n          c`else {`;\n          {\n            if (field.resolvedType instanceof pb.Type) {\n              const mapper = createMessageMapperCached(field.resolvedType, substitutions, cache);\n              c`res.${field.name} = ${ref(mapper)}.map({}, extraArgs);`;\n            } else if (field.resolvedType instanceof pb.Enum) {\n              `res.${field.name} = 0;`;\n            } else {\n              c`res.${field.name} = ${getDefaultValue(field.type)};`;\n            }\n          }\n          c`}`;\n        }\n      }\n      c`return res;`;\n    });\n  }\n\n  return cache[type.fullName];\n};\n\nconst getDefaultValue = (type: string): string => {\n  switch (type) {\n    case 'double':\n    case 'float':\n    case 'int32':\n    case 'sfixed32':\n    case 'uint32':\n    case 'sint32':\n    case 'fixed32':\n      return '0';\n    case 'sint64':\n    case 'int64':\n    case 'uint64':\n    case 'fixed64':\n    case 'sfixed64':\n      return '\"0\"';\n    case 'bool':\n      return 'false';\n    case 'string':\n      return '\"\"';\n    case 'bytes':\n      return 'new Uint8Array()';\n    default:\n      throw new Error(`Unknown type: ${type}`);\n  }\n};\n", "//\n// Copyright 2022 DXOS.org\n//\n\nconst Ref = Symbol('Ref');\n\ninterface Ref {\n  [Ref]: true;\n  value: any;\n}\n\n/**\n * Pass a JS value by reference rather then parsing it as code.\n *\n * Usage example:\n *\n * ```typescript\n * const double = x => x * 2;;\n * codegen('add', ['a', 'b'], c => {\n *   c`const c = a + b;`;\n *   c`return ${ref(double)}(c)`;\n * });\n * ```\n *\n * would generate a function:\n *\n * ```typescript\n * const double = x => x * 2;;\n * function add(a, b) {\n *   const c = a + b;\n *   return double(c);\n * }\n * ```\n */\nexport const ref = (value: any): Ref => ({\n  [Ref]: true,\n  value,\n});\n\nconst isRef = (value: any): value is Ref => value[Ref] === true;\n\n/**\n * DSL for runtime code generation.\n *\n * Example:\n *\n * ```typescript\n * const multiplier = 5;\n * codegen('add', ['a', 'b'], c => {\n *   c`const c = a + b;`;\n *   c`return c * ${multiplier};`;\n * });\n * ```\n *\n * would generate a function:\n *\n * ```typescript\n * function add(a, b) {\n *   const c = a + b;\n *   return c * 5;\n * }\n * ```\n *\n * @param name Function name. Will appear in stack traces.\n * @param args Names of function arguments.\n * @param gen Closure that builds the function source.\n * @param ctx Optional record with context variables that will appear in function's scope.\n */\nexport const codegen = (\n  name: string,\n  args: string[],\n  gen: (c: (parts: TemplateStringsArray, ...args: any[]) => void) => void,\n  ctx: Record<string, any> = {},\n): ((...args: any[]) => any) => {\n  const newCtx = { ...ctx };\n  let nextAnnon = 1;\n\n  let buf = '';\n  gen((parts, ...args) => {\n    const preprocessArg = (arg: any) => {\n      if (isRef(arg)) {\n        const name = `anon${nextAnnon++}`;\n        newCtx[name] = arg.value;\n        return name;\n      } else {\n        return arg;\n      }\n    };\n    buf += parts.map((s, i) => s + (i < args.length ? preprocessArg(args[i]) : '')).join('') + '\\n';\n  });\n\n  const code = `return function ${name}(${args.join(', ')}) {\\n${buf}\\n}`;\n\n  // eslint-disable-next-line no-new-func\n  return Function(...Object.keys(newCtx), code)(...Object.values(newCtx));\n};\n", "//\n// Copyright 2020 DXOS.org\n//\n\nimport { type IConversionOptions } from 'protobufjs';\nimport type protobufjs from 'protobufjs';\n\nimport { type Any, type EncodingOptions, type WithTypeUrl } from './common';\nimport { type BidirectionalMapingDescriptors } from './mapping';\nimport { createMessageMapper, type Mapper } from './precompiled-mapping/create-message-mapper';\nimport type { Schema } from './schema';\n\nexport const OBJECT_CONVERSION_OPTIONS: IConversionOptions = {\n  // Represent long integers as strings.\n  longs: String,\n\n  // Will set empty repeated fields to [] instead of undefined.\n  arrays: true,\n};\n\nconst JSON_CONVERSION_OPTIONS: IConversionOptions = {\n  // TODO(dmaretskyi): Internal crash with the current version of protobufjs.\n  // longs: String,\n  enums: String,\n  bytes: String,\n  defaults: false,\n  json: true,\n};\n\n/**\n * Defines a generic encoder/decoder.\n */\nexport interface Codec<T> {\n  encode(obj: T, opts?: EncodingOptions): Uint8Array;\n  decode(buffer: Uint8Array, opts?: EncodingOptions): T;\n}\n\n/**\n * Protocol buffer codec.\n */\nexport class ProtoCodec<T = any> implements Codec<T> {\n  private readonly _encodeMapper: Mapper;\n  private readonly _decodeMapper: Mapper;\n\n  constructor(\n    private readonly _type: protobufjs.Type,\n    private readonly _mapping: BidirectionalMapingDescriptors,\n    private readonly _schema: Schema<any>,\n  ) {\n    this._encodeMapper = createMessageMapper(this._type, this._mapping.encode);\n    this._decodeMapper = createMessageMapper(this._type, this._mapping.decode);\n  }\n\n  /**\n   * Underlying protobuf.js type descriptor.\n   */\n  get protoType(): protobufjs.Type {\n    return this._type;\n  }\n\n  get substitutionMappings(): BidirectionalMapingDescriptors {\n    return this._mapping;\n  }\n\n  /**\n   * Reference to the protobuf schema this codec was created from.\n   */\n  get schema(): Schema<any> {\n    // TODO(burdon): Add to generic type.\n    return this._schema;\n  }\n\n  encode(value: T, options: EncodingOptions = {}): Uint8Array {\n    const sub = this._encodeMapper(value, [this._schema, options]);\n    return this._type.encode(sub).finish();\n  }\n\n  decode(data: Uint8Array, options: EncodingOptions = {}): T {\n    const obj = this._type.toObject(this._type.decode(data), OBJECT_CONVERSION_OPTIONS);\n    return this._decodeMapper(obj, [this._schema, options]);\n  }\n\n  encodeAsAny(value: T, options: EncodingOptions = {}): WithTypeUrl<Any> {\n    return {\n      '@type': 'google.protobuf.Any',\n      type_url: this._type.fullName.slice(1),\n      value: this.encode(value, options),\n    };\n  }\n\n  fromObject(obj: any): T {\n    return this._decodeMapper(this._type.fromObject(obj).toJSON(), [this._schema]);\n  }\n\n  /**\n   * Dynamically add new definitions to this codec. Mutates the underlying schema.\n   */\n  addJson(schema: any): void {\n    this._schema.addJson(schema);\n  }\n\n  encodeToJson(value: T, options: EncodingOptions = {}): any {\n    const sub = this._encodeMapper(value, [this._schema, options]);\n    return this._type.toObject(sub, JSON_CONVERSION_OPTIONS);\n  }\n\n  decodeFromJson(data: any, options: EncodingOptions = {}): T {\n    const obj = this._type.toObject(this._type.fromObject(data), OBJECT_CONVERSION_OPTIONS);\n    return this._decodeMapper(obj, [this._schema, options]);\n  }\n}\n", "//\n// Copyright 2021 DXOS.org\n//\n\nimport * as protobuf from 'protobufjs';\n\nimport { type Struct } from './substitutions';\n\nexport const encodeProtobuf = (root: protobuf.Root): Struct => root.toJSON();\n\nexport const decodeProtobuf = (struct: Struct): protobuf.Root => protobuf.Root.fromJSON(struct);\n", "//\n// Copyright 2020 DXOS.org\n//\n\nimport protobufjs from 'protobufjs';\n\nimport { invariant } from '@dxos/invariant';\n\nimport { type Substitutions } from './common';\n\nexport type TypeMapperContext = {\n  /**\n   * Message FQN.\n   */\n  messageName: string;\n\n  fieldName: string;\n};\n\nexport type TypeMapper = (value: any, context: TypeMapperContext, ...extraArgs: any) => any;\n\nexport type MapingDescriptors = Partial<Record<string, TypeMapper>>;\n\nexport interface BidirectionalMapingDescriptors {\n  encode: MapingDescriptors;\n  decode: MapingDescriptors;\n}\n\nexport const createMappingDescriptors = (substitutions: Substitutions): BidirectionalMapingDescriptors => {\n  const encode: MapingDescriptors = {};\n  const decode: MapingDescriptors = {};\n  for (const type of Object.keys(substitutions)) {\n    encode[type] = substitutions[type].encode;\n    decode[type] = substitutions[type].decode;\n  }\n  return {\n    encode,\n    decode,\n  };\n};\n\nexport type FieldMapper = (value: any, typeName: string) => Promise<any>;\n\nexport const mapMessage = async (type: protobufjs.Type, mapper: FieldMapper, obj: any) => {\n  const res: any = {};\n  for (const field of type.fieldsArray) {\n    if (!(field.name in obj)) {\n      continue;\n    }\n    res[field.name] = await mapField(field, mapper, obj[field.name]);\n  }\n\n  return res;\n};\n\nconst mapField = async (field: protobufjs.Field, mapper: FieldMapper, value: any) => {\n  if (!field.required && (value === null || value === undefined)) {\n    return value;\n  } else if (field.repeated) {\n    return await Promise.all(value.map((value: any) => mapScalarField(field, mapper, value)));\n  } else if (field.map) {\n    invariant(field instanceof protobufjs.MapField);\n    return await asyncObjectMap((value) => mapScalarField(field, mapper, value), value);\n  } else {\n    return mapScalarField(field, mapper, value);\n  }\n};\n\nconst mapScalarField = async (field: protobufjs.Field, mapper: FieldMapper, value: any) => {\n  if (!field.resolved) {\n    field.resolve();\n  }\n\n  const typeName = field.resolvedType?.fullName.slice(1); // Name of the protobuf message type if the field type is not primitive.\n  if (typeName) {\n    return await mapper(value, typeName);\n  }\n\n  if (field.resolvedType && field.resolvedType instanceof protobufjs.Type) {\n    return await mapMessage(field.resolvedType, mapper, value);\n  }\n\n  return value;\n};\n\nconst asyncObjectMap = async <K extends keyof any, T, U>(\n  map: (value: T, key: K) => Promise<U>,\n  record: Record<K, T>,\n): Promise<Record<K, U>> => {\n  const res: Record<K, U> = {} as any;\n\n  await Promise.all(\n    Object.entries(record).map(async ([key, value]) => {\n      res[key as keyof typeof res] = await map(value as T, key as K);\n    }),\n  );\n\n  return res;\n};\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport pb from 'protobufjs';\n\nexport interface SanitizeContext {\n  errors: string[];\n}\n\n/**\n * Sanitiaze all enum fields in object based on protobuf type.\n * @param type\n * @param value\n * @param path\n * @param context\n */\nexport const sanitize = (type: pb.Type, value: any, path: string, context: SanitizeContext) => {\n  if (!value) {\n    return;\n  }\n\n  for (const key of Object.keys(value)) {\n    if (!type.fields[key]) {\n      // Ignore unknown fields.\n      continue;\n    }\n\n    const field = type.fields[key];\n    if (field.repeated) {\n      continue; // TODO(dmaretskyi): Implement.\n    }\n\n    field.resolve();\n    if (!field.resolvedType) {\n      continue;\n    }\n    if (field.resolvedType instanceof pb.Type) {\n      sanitize(field.resolvedType, value[key], `${path}.${key}`, context);\n    } else if (field.resolvedType instanceof pb.Enum) {\n      value[key] = sanitizeEnum(field.resolvedType, value[key], `${path}.${key}`, context);\n    }\n  }\n};\n\nconst sanitizeEnum = (type: pb.Enum, value: any, path: string, context: SanitizeContext): any => {\n  if (type.valuesById[value]) {\n    return value;\n  }\n\n  if (typeof value === 'string') {\n    const normalizedValue = value.toLowerCase();\n    for (const [name, tag] of Object.entries(type.values)) {\n      if (name.toLowerCase() === normalizedValue) {\n        return tag;\n      }\n    }\n  }\n\n  context.errors.push(`Invalid enum value: value=${JSON.stringify(value)} enum=${type.fullName} path=${path}`);\n\n  return value;\n};\n", "//\n// Copyright 2021 DXOS.org\n//\n\nimport merge from 'lodash.merge';\nimport pb from 'protobufjs';\n\nimport { ProtoCodec } from './codec';\nimport { type Substitutions } from './common';\nimport { type BidirectionalMapingDescriptors, createMappingDescriptors } from './mapping';\nimport { ServiceDescriptor } from './service';\n\nexport class Schema<T, S extends {} = {}> {\n  static fromJson<T extends Record<string, any>, S extends Record<string, any> = {}>(\n    schema: any,\n    substitutions: Substitutions = {},\n  ): Schema<T, S> {\n    const root = pb.Root.fromJSON(schema);\n    return new Schema(root, substitutions);\n  }\n\n  private readonly _mapping: BidirectionalMapingDescriptors;\n\n  private readonly _codecCache = new Map<string, ProtoCodec>();\n\n  // prettier-ignore\n  constructor(\n    private _typesRoot: pb.Root,\n    substitutions: Substitutions,\n  ) {\n    this._mapping = createMappingDescriptors(substitutions);\n  }\n\n  getCodecForType<K extends keyof T & string>(typeName: K): ProtoCodec<T[K]> {\n    if (typeof typeName !== 'string') {\n      throw new TypeError('Expected `typeName` argument to be a string');\n    }\n\n    let codec = this._codecCache.get(typeName);\n    if (codec) {\n      return codec;\n    }\n\n    if (codec === null) {\n      throw new Error(`Type not found: \"${typeName}\"`);\n    }\n\n    const type = this._typesRoot.lookupType(typeName);\n    codec = new ProtoCodec(type, this._mapping, this);\n    this._codecCache.set(typeName, codec);\n    return codec;\n  }\n\n  hasType(typeName: string): boolean {\n    if (typeName === '') {\n      return false;\n    }\n\n    if (this._codecCache.has(typeName)) {\n      return true;\n    }\n\n    try {\n      this.tryGetCodecForType(typeName);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  tryGetCodecForType(typeName: string): ProtoCodec {\n    if (typeName === '') {\n      throw new Error(`Type not found: \"${typeName}\"`);\n    }\n\n    if (typeof typeName !== 'string') {\n      throw new TypeError('Expected `typeName` argument to be a string');\n    }\n\n    let codec = this._codecCache.get(typeName);\n    if (codec) {\n      return codec;\n    }\n\n    if (codec === null) {\n      throw new Error(`Type not found: \"${typeName}\"`);\n    }\n\n    const type = this._typesRoot.lookupType(typeName);\n    codec = new ProtoCodec(type, this._mapping, this);\n    this._codecCache.set(typeName, codec);\n    return codec;\n  }\n\n  getService<K extends keyof S & string>(name: K): ServiceDescriptor<S[K]> {\n    if (typeof name !== 'string') {\n      throw new TypeError('Expected `name` argument to be a string');\n    }\n\n    const service = this._typesRoot.lookupService(name);\n    return new ServiceDescriptor(service, this);\n  }\n\n  /**\n   * Dynamically add new definitions to this schema.\n   */\n  addJson(schema: any): void {\n    if (!schema.nested) {\n      throw new Error('Invalid schema: missing nested object');\n    }\n\n    this._typesRoot = pb.Root.fromJSON(merge(this._typesRoot.toJSON(), schema));\n  }\n}\n", "//\n// Copyright 2021 DXOS.org\n//\n\nimport type pb from 'protobufjs';\n\nimport { invariant } from '@dxos/invariant';\nimport { getAsyncProviderValue } from '@dxos/util';\n\nimport { type Any, type EncodingOptions } from './common';\nimport { type RequestOptions } from './request-options';\nimport type { Schema } from './schema';\nimport { Stream } from './stream';\n\n/**\n * Service endpoint.\n */\nexport interface ServiceBackend {\n  call(method: string, request: Any, requestOptions?: RequestOptions): Promise<Any>;\n  callStream(method: string, request: Any, requestOptions?: RequestOptions): Stream<Any>;\n}\n\nexport type ServiceProvider<Service> = Service | (() => Service) | (() => Promise<Service>);\n\n/**\n * Client/server service wrapper.\n */\nexport class ServiceDescriptor<S> {\n  // prettier-ignore\n  constructor(\n    private readonly _service: pb.Service,\n    private readonly _schema: Schema<any>,\n  ) {}\n\n  get serviceProto(): pb.Service {\n    return this._service;\n  }\n\n  get name(): string {\n    return this._service.fullName.slice(1);\n  }\n\n  createClient(backend: ServiceBackend, encodingOptions?: EncodingOptions): Service & S {\n    return new Service(backend, this._service, this._schema, encodingOptions) as Service & S;\n  }\n\n  createServer(handlers: ServiceProvider<S>, encodingOptions?: EncodingOptions): ServiceHandler<S> {\n    return new ServiceHandler(this._service, this._schema, handlers, encodingOptions);\n  }\n}\n\n/**\n * Represents service instance.\n */\nexport class Service {\n  constructor(backend: ServiceBackend, service: pb.Service, schema: Schema<any>, encodingOptions?: EncodingOptions) {\n    for (const method of service.methodsArray) {\n      method.resolve();\n      invariant(method.resolvedRequestType);\n      invariant(method.resolvedResponseType);\n      invariant(!method.requestStream, 'Streaming RPC requests are not supported.');\n\n      // TODO(dmaretskyi): What about primitive types.\n      const requestCodec = schema.tryGetCodecForType(method.resolvedRequestType.fullName);\n      const responseCodec = schema.tryGetCodecForType(method.resolvedResponseType.fullName);\n      const methodName = mapRpcMethodName(method.name);\n\n      if (method.responseStream) {\n        (this as any)[methodName] = (request: unknown, requestOptions?: RequestOptions) => {\n          const encoded = requestCodec.encode(request, encodingOptions);\n          const stream = backend.callStream(\n            method.name,\n            {\n              value: encoded,\n              type_url: method.resolvedRequestType!.fullName,\n            },\n            requestOptions,\n          );\n          return Stream.map(stream, (data) => responseCodec.decode(data.value!, encodingOptions));\n        };\n      } else {\n        (this as any)[methodName] = async (request: unknown, requestOptions?: RequestOptions) => {\n          const encoded = requestCodec.encode(request, encodingOptions);\n          const response = await backend.call(\n            method.name,\n            {\n              value: encoded,\n              type_url: method.resolvedRequestType!.fullName,\n            },\n            requestOptions,\n          );\n          return responseCodec.decode(response.value, encodingOptions);\n        };\n      }\n\n      // Set function name so that is properly named in stack traces.\n      Object.defineProperty((this as any)[methodName], 'name', {\n        value: methodName,\n      });\n    }\n  }\n}\n\n/**\n * Represents service endpoint implementation.\n */\nexport class ServiceHandler<S = {}> implements ServiceBackend {\n  constructor(\n    private readonly _serviceDefinition: pb.Service,\n    private readonly _schema: Schema<any>,\n    private readonly _serviceProvider: ServiceProvider<S>,\n    private readonly _encodingOptions?: EncodingOptions,\n  ) {}\n\n  /**\n   * Request/response method call.\n   */\n  async call(methodName: string, request: Any, options?: RequestOptions): Promise<Any> {\n    const { method, requestCodec, responseCodec } = this._getMethodInfo(methodName);\n    invariant(!method.requestStream, 'Invalid RPC method call: request streaming mismatch.');\n    invariant(!method.responseStream, `Invalid RPC method call: response streaming mismatch. ${methodName}`);\n\n    const mappedMethodName = mapRpcMethodName(methodName);\n\n    const handler = await this._getHandler(mappedMethodName);\n    const requestDecoded = requestCodec.decode(request.value!, this._encodingOptions);\n    const response = await handler(requestDecoded, options);\n    const responseEncoded = responseCodec.encode(response, this._encodingOptions);\n\n    return {\n      value: responseEncoded,\n      type_url: method.resolvedResponseType!.fullName,\n    };\n  }\n\n  /**\n   * Streaming method call.\n   */\n  callStream(methodName: string, request: Any, options?: RequestOptions): Stream<Any> {\n    const { method, requestCodec, responseCodec } = this._getMethodInfo(methodName);\n    invariant(!method.requestStream, 'Invalid RPC method call: request streaming mismatch.');\n    invariant(method.responseStream, `Invalid RPC method call: response streaming mismatch., ${methodName}`);\n\n    const mappedMethodName = mapRpcMethodName(methodName);\n    const handlerPromise = this._getHandler(mappedMethodName);\n\n    const requestDecoded = requestCodec.decode(request.value!, this._encodingOptions);\n    const responseStream = Stream.unwrapPromise(\n      handlerPromise.then((handler) => handler(requestDecoded, options) as Stream<unknown>),\n    );\n    return Stream.map(\n      responseStream,\n      (data): Any => ({\n        value: responseCodec.encode(data, this._encodingOptions),\n        type_url: method.resolvedResponseType!.fullName,\n      }),\n    );\n  }\n\n  private async _getHandler(method: string): Promise<(request: unknown, options?: RequestOptions) => unknown> {\n    const service: S = await getAsyncProviderValue(this._serviceProvider);\n    const handler = service[method as keyof S];\n    invariant(handler, `Handler is missing: ${method}`);\n    return (handler as any).bind(service);\n  }\n\n  private _getMethodInfo(methodName: string) {\n    const method = this._serviceDefinition.methods[methodName];\n    invariant(!!method, `Method not found: ${methodName}`);\n\n    method.resolve();\n    invariant(method.resolvedRequestType);\n    invariant(method.resolvedResponseType);\n\n    const requestCodec = this._schema.tryGetCodecForType(method.resolvedRequestType.fullName);\n    const responseCodec = this._schema.tryGetCodecForType(method.resolvedResponseType.fullName);\n\n    return { method, requestCodec, responseCodec };\n  }\n}\n\nconst mapRpcMethodName = (name: string) => name[0].toLocaleLowerCase() + name.substring(1);\n", "//\n// Copyright 2022 DXOS.org\n//\n\nexport type Struct = Record<string, any>;\n\nconst encodeStructValue = (structValue: any, visitedObjects: WeakSet<any>): any => {\n  const valueType = typeof structValue;\n  switch (valueType) {\n    case 'undefined': {\n      return { nullValue: 0 };\n    }\n    case 'number': {\n      return { numberValue: structValue };\n    }\n    case 'string': {\n      return { stringValue: structValue };\n    }\n    case 'boolean': {\n      return { boolValue: structValue };\n    }\n    case 'object': {\n      // null, Array, Object will have typeof 'object'\n      if (structValue === null || visitedObjects.has(structValue)) {\n        return { nullValue: 0 };\n      }\n\n      try {\n        if (Array.isArray(structValue)) {\n          return { listValue: { values: structValue.map((value) => encodeStructValue(value, visitedObjects)) } };\n        }\n        return { structValue: encodeStruct(structValue, visitedObjects) };\n      } finally {\n        visitedObjects.delete(structValue);\n      }\n    }\n    default: {\n      return { nullValue: 0 };\n    }\n  }\n};\n\nconst encodeStruct = (struct: Struct, visitedObjects = new WeakSet<any>()): any => ({\n  fields: Object.fromEntries(\n    Object.entries(struct).map(([key, value]) => [key, encodeStructValue(value, visitedObjects)]),\n  ),\n});\n\nconst decodeStructValue = (structValue: any): any => {\n  const [key, v]: [string, any] = Object.entries(structValue)[0];\n  switch (key) {\n    case 'nullValue': {\n      return null;\n    }\n    case 'numberValue': {\n      return v;\n    }\n    case 'stringValue': {\n      return v;\n    }\n    case 'boolValue': {\n      return v;\n    }\n    case 'structValue': {\n      return decodeStruct(v);\n    }\n    case 'listValue': {\n      return v.values.map(decodeStructValue);\n    }\n    default:\n      throw new Error(`Unsupported type: ${key}`);\n  }\n};\n\nconst decodeStruct = (struct: any): Struct =>\n  Object.fromEntries(Object.entries(struct.fields || {}).map(([key, value]) => [key, decodeStructValue(value)]));\n\nexport const structSubstitutions = {\n  'google.protobuf.Struct': {\n    encode: (value: Struct): any => encodeStruct(value),\n    decode: (value: any): Struct => decodeStruct(value),\n  },\n};\n", "//\n// Copyright 2021 DXOS.org\n//\n\nimport { structSubstitutions } from './struct';\nimport { type EncodingOptions, type WithTypeUrl } from '../common';\nimport { type TypeMapperContext } from '../mapping';\nimport type { Schema } from '../schema';\n\nexport const anySubstitutions = {\n  'google.protobuf.Any': {\n    encode: (\n      value: WithTypeUrl<{}>,\n      context: TypeMapperContext,\n      schema: Schema<any>,\n      options: EncodingOptions,\n    ): any => {\n      const field = schema.getCodecForType(context.messageName).protoType.fields[context.fieldName];\n      if (options.preserveAny || field.getOption('preserve_any')) {\n        if (value['@type'] && value['@type'] !== 'google.protobuf.Any') {\n          throw new Error(\n            'Can only encode google.protobuf.Any with @type set to google.protobuf.Any in preserveAny mode.',\n          );\n        }\n        return value;\n      }\n\n      if (typeof value['@type'] !== 'string') {\n        throw new Error('Cannot encode google.protobuf.Any without @type string field');\n      }\n\n      if (value['@type'] === 'google.protobuf.Any') {\n        return value as any;\n      }\n\n      if (value['@type'] === 'google.protobuf.Struct') {\n        const codec = schema.tryGetCodecForType(value['@type']);\n        return codec.encodeAsAny(structSubstitutions['google.protobuf.Struct'].encode(value));\n      }\n\n      const codec = schema.tryGetCodecForType(value['@type']);\n      return codec.encodeAsAny(value);\n    },\n\n    decode: (\n      value: any,\n      context: TypeMapperContext,\n      schema: Schema<any>,\n      options: EncodingOptions,\n    ): WithTypeUrl<any> => {\n      const field = schema.getCodecForType(context.messageName).protoType.fields[context.fieldName];\n      if (options.preserveAny || field.getOption('preserve_any')) {\n        return {\n          '@type': 'google.protobuf.Any',\n          type_url: value.type_url ?? '',\n          value: value.value ?? new Uint8Array(),\n        };\n      }\n\n      if (!schema.hasType(value.type_url)) {\n        return {\n          '@type': 'google.protobuf.Any',\n          ...value,\n        };\n      }\n      const codec = schema.tryGetCodecForType(value.type_url);\n      let data = codec.decode(value.value);\n\n      if (value.type_url === 'google.protobuf.Struct') {\n        data = structSubstitutions['google.protobuf.Struct'].decode(data);\n      }\n\n      return {\n        ...data,\n        '@type': value.type_url,\n      };\n    },\n  },\n};\n", "//\n// Copyright 2022 DXOS.org\n//\n\nexport const timestampSubstitutions = {\n  'google.protobuf.Timestamp': {\n    encode: (value: Date): any => {\n      const unixMilliseconds = value.getTime();\n      return {\n        seconds: Math.floor(unixMilliseconds / 1000).toString(),\n        nanos: (unixMilliseconds % 1000) * 1e6,\n      };\n    },\n\n    decode: (value: any): Date => new Date(parseInt(value.seconds ?? '0') * 1000 + (value.nanos ?? 0) / 1e6),\n  },\n};\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { compress, decompress } from 'compress-json';\n\nexport const compressSchema = (data: any): any => compress(data);\n\nexport const decompressSchema = (data: any): any => decompress(data);\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { Trigger } from '@dxos/async';\n\nimport { type Stream } from './stream';\n\nexport const getFirstStreamValue = async <T extends {}>(\n  stream: Stream<T>,\n  { timeout }: { timeout?: number } = {},\n): Promise<T> => {\n  try {\n    const trigger = new Trigger<T>();\n    stream.subscribe((value) => trigger.wake(value));\n    return await trigger.wait({ timeout });\n  } finally {\n    await stream.close();\n  }\n};\n"],
  "mappings": "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",
  "names": ["arrayToBuffer", "patchBufferCodec", "codec", "encode", "x", "arrayToBuffer", "decode", "bind", "pb", "invariant", "Ref", "Symbol", "ref", "value", "isRef", "codegen", "name", "args", "gen", "ctx", "newCtx", "nextAnnon", "buf", "parts", "preprocessArg", "arg", "map", "s", "i", "length", "join", "code", "Function", "Object", "keys", "values", "createMessageMapper", "type", "substitutions", "createMessageMapperCached", "map", "cache", "fullName", "codegen", "name", "c", "field", "fieldsArray", "resolve", "genMapScalar", "value", "substitution", "resolvedType", "slice", "context", "messageName", "fieldName", "ref", "pb", "Type", "mapper", "repeated", "invariant", "MapField", "getOption", "partOf", "Enum", "getDefaultValue", "Error", "OBJECT_CONVERSION_OPTIONS", "longs", "String", "arrays", "JSON_CONVERSION_OPTIONS", "enums", "bytes", "defaults", "json", "ProtoCodec", "_type", "_mapping", "_schema", "_encodeMapper", "createMessageMapper", "encode", "_decodeMapper", "decode", "protoType", "substitutionMappings", "schema", "value", "options", "sub", "finish", "data", "obj", "toObject", "encodeAsAny", "type_url", "fullName", "slice", "fromObject", "toJSON", "addJson", "encodeToJson", "decodeFromJson", "protobuf", "encodeProtobuf", "root", "toJSON", "decodeProtobuf", "struct", "Root", "fromJSON", "protobufjs", "invariant", "createMappingDescriptors", "substitutions", "encode", "decode", "type", "Object", "keys", "mapMessage", "mapper", "obj", "res", "field", "fieldsArray", "name", "mapField", "value", "required", "undefined", "repeated", "Promise", "all", "map", "mapScalarField", "MapField", "asyncObjectMap", "resolved", "resolve", "typeName", "resolvedType", "fullName", "slice", "Type", "record", "entries", "key", "pb", "sanitize", "type", "value", "path", "context", "key", "Object", "keys", "fields", "field", "repeated", "resolve", "resolvedType", "pb", "Type", "Enum", "sanitizeEnum", "valuesById", "normalizedValue", "toLowerCase", "name", "tag", "entries", "values", "errors", "push", "JSON", "stringify", "fullName", "merge", "pb", "invariant", "getAsyncProviderValue", "ServiceDescriptor", "_service", "_schema", "serviceProto", "name", "fullName", "slice", "createClient", "backend", "encodingOptions", "Service", "createServer", "handlers", "ServiceHandler", "service", "schema", "method", "methodsArray", "resolve", "invariant", "resolvedRequestType", "resolvedResponseType", "requestStream", "requestCodec", "tryGetCodecForType", "responseCodec", "methodName", "mapRpcMethodName", "responseStream", "request", "requestOptions", "encoded", "encode", "stream", "callStream", "value", "type_url", "Stream", "map", "data", "decode", "response", "call", "Object", "defineProperty", "_serviceDefinition", "_serviceProvider", "_encodingOptions", "options", "_getMethodInfo", "mappedMethodName", "handler", "_getHandler", "requestDecoded", "responseEncoded", "handlerPromise", "unwrapPromise", "then", "getAsyncProviderValue", "bind", "methods", "toLocaleLowerCase", "substring", "Schema", "fromJson", "schema", "substitutions", "root", "pb", "Root", "fromJSON", "_typesRoot", "_codecCache", "Map", "_mapping", "createMappingDescriptors", "getCodecForType", "typeName", "TypeError", "codec", "get", "Error", "type", "lookupType", "ProtoCodec", "set", "hasType", "has", "tryGetCodecForType", "getService", "name", "service", "lookupService", "ServiceDescriptor", "addJson", "nested", "merge", "toJSON", "encodeStructValue", "structValue", "visitedObjects", "valueType", "nullValue", "numberValue", "stringValue", "boolValue", "has", "Array", "isArray", "listValue", "values", "map", "value", "encodeStruct", "delete", "struct", "WeakSet", "fields", "Object", "fromEntries", "entries", "key", "decodeStructValue", "v", "decodeStruct", "Error", "structSubstitutions", "encode", "decode", "anySubstitutions", "encode", "value", "context", "schema", "options", "field", "getCodecForType", "messageName", "protoType", "fields", "fieldName", "preserveAny", "getOption", "Error", "codec", "tryGetCodecForType", "encodeAsAny", "structSubstitutions", "decode", "type_url", "Uint8Array", "hasType", "data", "timestampSubstitutions", "encode", "value", "unixMilliseconds", "getTime", "seconds", "Math", "floor", "toString", "nanos", "decode", "Date", "parseInt", "compress", "decompress", "compressSchema", "data", "compress", "decompressSchema", "decompress", "Trigger", "getFirstStreamValue", "stream", "timeout", "trigger", "Trigger", "subscribe", "value", "wake", "wait", "close"]
}
