"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var node_exports = {};
__export(node_exports, {
  Timeframe: () => Timeframe
});
module.exports = __toCommonJS(node_exports);
var import_node_util = require("node:util");
var import_debug = require("@dxos/debug");
var Timeframe = class _Timeframe {
  constructor(frames = []) {
    this._frames = /* @__PURE__ */ new Map();
    for (const [key, seq] of frames) {
      this.set(key, seq);
    }
  }
  toJSON() {
    return this.frames().reduce((frames, [key, seq]) => {
      frames[key.truncate()] = seq;
      return frames;
    }, {});
  }
  toString() {
    return `(${this.frames().map(([key, seq]) => `${key.truncate()}[${seq}]`).join(", ")})`;
  }
  equals(object) {
    return this.size() === object.size() && this.frames().every(([key, seq]) => object.get(key) === seq);
  }
  // TODO(burdon): Rename getFrame.
  get(key) {
    return this._frames.get(key.toHex())?.seq;
  }
  // TODO(burdon): Rename setFrame.
  set(key, seq) {
    const hex = key.toHex();
    this._frames.set(hex, {
      key,
      seq
    });
  }
  // TODO(burdon): Change to getter.
  frames() {
    return Array.from(this._frames.values()).map(({ key, seq }) => [
      key,
      seq
    ]);
  }
  // TODO(burdon): Change to getter.
  size() {
    return this._frames.size;
  }
  // TODO(burdon): Change to getter (empty).
  isEmpty() {
    return this.size() === 0;
  }
  /**
  * Returns a new timeframe with specified keys removed.
  * @param keys
  */
  withoutKeys(keys) {
    return new _Timeframe(this.frames().filter(([frameKey]) => keys.every((key) => !key.equals(frameKey))));
  }
  map(fn) {
    return new _Timeframe(this.frames().map(fn));
  }
  /**
  * Returns a total amount of messages represented by this timeframe.
  */
  totalMessages() {
    return Array.from(this._frames.values()).reduce((result, { seq }) => result + seq + 1, 0);
  }
  /**
  * Returns a total amount of messages that are present in this timeframe but are missing in `base`.
  */
  newMessages(base) {
    return Array.from(this._frames.entries()).reduce((result, [hex, { seq }]) => result + Math.max(seq - (base._frames.get(hex)?.seq ?? -1), 0), 0);
  }
  /**
  * Used by NodeJS to get textual representation of this object in `console.log`.
  */
  [import_node_util.inspect.custom]() {
    return `Timeframe${this.toString()}`;
  }
  [import_debug.equalsSymbol](other) {
    if (!(other instanceof _Timeframe)) {
      return false;
    }
    return this.equals(other);
  }
  /**
  * Merges the values, updating the highest sequence numbers.
  * @param timeframes
  */
  static merge(...timeframes) {
    const result = new _Timeframe();
    for (const timeframe of timeframes) {
      for (const [hex, entry] of timeframe._frames) {
        const currentEntry = result._frames.get(hex);
        if (currentEntry === void 0 || entry.seq > currentEntry.seq) {
          result._frames.set(hex, entry);
        }
      }
    }
    return result;
  }
  /**
  * Compares two timeframes and returns an array of frames from the first timeframe where the sequence number
  * is greater than the associated sequence number from the second timeframe.
  */
  static dependencies(tf1, tf2) {
    const result = new _Timeframe();
    for (const [hex, entry] of tf1._frames) {
      const otherEntry = tf2._frames.get(hex);
      if (otherEntry === void 0 || otherEntry.seq < entry.seq) {
        result._frames.set(hex, entry);
      }
    }
    return result;
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Timeframe
});
//# sourceMappingURL=index.cjs.map
