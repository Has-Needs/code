"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var node_exports = {};
__export(node_exports, {
  InvalidStateError: () => InvalidStateError,
  InvariantViolation: () => InvariantViolation,
  assertArgument: () => assertArgument,
  assertState: () => assertState,
  failedInvariant: () => failedInvariant,
  invariant: () => invariant
});
module.exports = __toCommonJS(node_exports);
var invariant = (condition, message, meta) => {
  if (condition) {
    return;
  }
  if (message?.startsWith("BUG")) {
    debugger;
  }
  let errorMessage = "invariant violation";
  if (message) {
    errorMessage += `: ${message}`;
  }
  if (meta?.A) {
    errorMessage += ` [${meta.A[0]}]`;
  }
  if (meta?.F) {
    errorMessage += ` at ${getRelativeFilename(meta.F)}:${meta.L}`;
  }
  const error = new InvariantViolation(errorMessage);
  Error.captureStackTrace(error, invariant);
  throw error;
};
var InvariantViolation = class extends Error {
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, new.target.prototype);
  }
};
var getRelativeFilename = (filename) => {
  const match = filename.match(/.+\/(packages\/.+\/.+)/);
  if (match) {
    const [, filePath] = match;
    return filePath;
  }
  return filename;
};
var failedInvariant = (message1, message2, meta) => {
  let errorMessage = "invariant violation";
  const message = [
    message1,
    message2
  ].filter((str) => typeof str === "string").join(" ");
  if (message) {
    errorMessage += `: ${message}`;
  }
  if (meta?.A) {
    errorMessage += ` [${meta.A[0]}]`;
  }
  if (meta?.F) {
    errorMessage += ` at ${getRelativeFilename(meta.F)}:${meta.L}`;
  }
  throw new InvariantViolation(errorMessage);
};
var assertArgument = (condition, message) => {
  if (!condition) {
    const error = new TypeError(message);
    Error.captureStackTrace(error, assertArgument);
    throw error;
  }
};
var assertState = (condition, message) => {
  if (!condition) {
    const error = new InvalidStateError(message);
    Error.captureStackTrace(error, assertState);
    throw error;
  }
};
var InvalidStateError = class extends Error {
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  InvalidStateError,
  InvariantViolation,
  assertArgument,
  assertState,
  failedInvariant,
  invariant
});
//# sourceMappingURL=index.cjs.map
