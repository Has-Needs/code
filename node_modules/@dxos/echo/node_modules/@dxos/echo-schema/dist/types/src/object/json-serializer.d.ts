import { type EncodedReference } from '@dxos/echo-protocol';
import { type ObjectJSON } from './model';
import { Ref, type RefResolver } from '../ref';
import { type AnyEchoObject } from '../types';
type DeepReplaceRef<T> = T extends Ref<any> ? EncodedReference : T extends object ? {
    [K in keyof T]: DeepReplaceRef<T[K]>;
} : T;
type SerializedObject<T extends {
    id: string;
}> = {
    [K in keyof T]: DeepReplaceRef<T[K]>;
} & ObjectJSON;
/**
 * Converts object to it's JSON representation.
 */
export declare const objectToJSON: <T extends AnyEchoObject>(obj: T) => SerializedObject<T>;
/**
 * Creates an object from it's json representation.
 * Performs schema validation.
 * References and schema will be resolvable if the `refResolver` is provided.
 *
 * The function need to be async to support resolving the schema as well as the relation endpoints.
 */
export declare const objectFromJSON: (jsonData: unknown, { refResolver }?: {
    refResolver?: RefResolver;
}) => Promise<AnyEchoObject>;
export {};
//# sourceMappingURL=json-serializer.d.ts.map