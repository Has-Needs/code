{
  "version": 3,
  "sources": ["../../../src/Key.ts", "../../../src/Obj.ts", "../../../src/Ref.ts", "../../../src/Relation.ts", "../../../src/Type.ts", "../../../src/index.ts", "../../../src/query/dsl.ts"],
  "sourcesContent": ["//\n// Copyright 2025 DXOS.org\n//\n\nexport { SpaceId, ObjectId } from '@dxos/keys';\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { Schema } from 'effect';\n\nimport * as EchoSchema from '@dxos/echo-schema';\nimport { assertArgument, invariant } from '@dxos/invariant';\nimport { type DXN } from '@dxos/keys';\nimport type * as LiveObject from '@dxos/live-object';\nimport { live } from '@dxos/live-object';\nimport { assumeType } from '@dxos/util';\n\nimport type * as Ref from './Ref';\nimport type * as Relation from './Relation';\nimport type * as Type from './Type';\n\n// NOTE: Don't export: Obj.Any and Obj.Obj form the public API.\ninterface ObjBase extends Type.OfKind<EchoSchema.EntityKind.Object> {\n  readonly id: EchoSchema.ObjectId;\n}\n\n/**\n * Object type with specific properties.\n */\nexport type Obj<Props> = ObjBase & Props;\n\n/**\n * Base type for all ECHO objects.\n */\nexport interface Any extends ObjBase {}\n\ntype MakeProps<T> = {\n  id?: EchoSchema.ObjectId;\n} & Type.Properties<T>;\n\n/**\n * Creates new object.\n */\n// TODO(dmaretskyi): Move meta into props.\nexport const make = <S extends Type.Obj.Any>(\n  schema: S,\n  props: NoInfer<MakeProps<Schema.Schema.Type<S>>>,\n  meta?: EchoSchema.ObjectMeta,\n): LiveObject.Live<Schema.Schema.Type<S>> => {\n  assertArgument(\n    EchoSchema.getTypeAnnotation(schema)?.kind === EchoSchema.EntityKind.Object,\n    'Expected an object schema',\n  );\n\n  if (props[EchoSchema.MetaId] != null) {\n    meta = props[EchoSchema.MetaId] as any;\n    delete props[EchoSchema.MetaId];\n  }\n\n  return live<Schema.Schema.Type<S>>(schema, props as any, meta);\n};\n\nexport const isObject = (obj: unknown): obj is Any => {\n  assumeType<EchoSchema.InternalObjectProps>(obj);\n  return typeof obj === 'object' && obj !== null && obj[EchoSchema.EntityKindId] === EchoSchema.EntityKind.Object;\n};\n\n/**\n * Test if object or relation is an instance of a schema.\n * @example\n * ```ts\n * const john = Obj.make(Person, { name: 'John' });\n * const johnIsPerson = Obj.instanceOf(Person)(john);\n *\n * const isPerson = Obj.instanceOf(Person);\n * if(isPerson(john)) {\n *   // john is Person\n * }\n * ```\n */\nexport const instanceOf: {\n  <S extends Type.Relation.Any | Type.Obj.Any>(schema: S): (value: unknown) => value is Schema.Schema.Type<S>;\n  <S extends Type.Relation.Any | Type.Obj.Any>(schema: S, value: unknown): value is Schema.Schema.Type<S>;\n} = ((\n  ...args: [schema: Type.Relation.Any | Type.Obj.Any, value: unknown] | [schema: Type.Relation.Any | Type.Obj.Any]\n) => {\n  if (args.length === 1) {\n    return (obj: unknown) => EchoSchema.isInstanceOf(args[0], obj);\n  }\n\n  return EchoSchema.isInstanceOf(args[0], args[1]);\n}) as any;\n\nexport const getSchema = EchoSchema.getSchema;\n\n// TODO(dmaretskyi): Allow returning undefined.\nexport const getDXN = (obj: Any): DXN => {\n  assertArgument(!Schema.isSchema(obj), 'Object should not be a schema.');\n  const dxn = EchoSchema.getObjectDXN(obj);\n  invariant(dxn != null, 'Invalid object.');\n  return dxn;\n};\n\n/**\n * @returns The DXN of the object's type.\n * @example dxn:example.com/type/Contact:1.0.0\n */\n// TODO(burdon): Expando does not have a type.\nexport const getTypeDXN = EchoSchema.getType;\n\n/**\n * @returns The typename of the object's type.\n * @example `example.com/type/Contact`\n */\nexport const getTypename = (obj: Any): string | undefined => {\n  const schema = getSchema(obj);\n  if (schema == null) {\n    // Try to extract typename from DXN.\n    return EchoSchema.getType(obj)?.asTypeDXN()?.type;\n  }\n\n  return EchoSchema.getSchemaTypename(schema);\n};\n\n// TODO(dmaretskyi): Allow returning undefined.\nexport const getMeta = (obj: Any): EchoSchema.ObjectMeta => {\n  const meta = EchoSchema.getMeta(obj);\n  invariant(meta != null, 'Invalid object.');\n  return meta;\n};\n\n// TODO(dmaretskyi): Default to `false`.\nexport const isDeleted = (obj: Any): boolean => {\n  const deleted = EchoSchema.isDeleted(obj);\n  invariant(typeof deleted === 'boolean', 'Invalid object.');\n  return deleted;\n};\n\nexport const getLabel = (obj: Any): string | undefined => {\n  const schema = getSchema(obj);\n  if (schema != null) {\n    return EchoSchema.getLabel(schema, obj);\n  }\n};\n\n/**\n * JSON representation of an object.\n */\nexport type JSON = EchoSchema.ObjectJSON;\n\n/**\n * Converts object to its JSON representation.\n *\n * The same algorithm is used when calling the standard `JSON.stringify(obj)` function.\n */\nexport const toJSON = (obj: Any | Relation.Any): JSON => EchoSchema.objectToJSON(obj);\n\n/**\n * Creates an object from its json representation, performing schema validation.\n * References and schemas will be resolvable if the `refResolver` is provided.\n *\n * The function need to be async to support resolving the schema as well as the relation endpoints.\n */\nexport const fromJSON: (json: unknown, options?: { refResolver?: Ref.Resolver }) => Promise<Any> =\n  EchoSchema.objectFromJSON as any;\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport * as EchoSchema from '@dxos/echo-schema';\n\nimport type * as Obj from './Obj';\n\nexport type Ref<T> = EchoSchema.Ref<T>;\nexport type Any = EchoSchema.Ref<Obj.Any>;\n\nexport const Array = EchoSchema.RefArray;\n\n/**\n * Extract reference target.\n */\nexport type Target<R extends Any> = R extends EchoSchema.Ref<infer T> ? T : never;\n\n/**\n * Reference resolver.\n */\nexport type Resolver = EchoSchema.RefResolver;\n\nexport const isRef: (value: unknown) => value is Any = EchoSchema.Ref.isRef;\n\nexport const make = EchoSchema.Ref.make;\n\n// TODO(dmaretskyi): Consider just allowing `make` to accept DXN.\nexport const fromDXN = EchoSchema.Ref.fromDXN;\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { type Schema } from 'effect';\n\nimport { raise } from '@dxos/debug';\nimport * as EchoSchema from '@dxos/echo-schema';\nimport { assertArgument, invariant } from '@dxos/invariant';\nimport { DXN } from '@dxos/keys';\nimport { type Live, live } from '@dxos/live-object';\nimport { assumeType } from '@dxos/util';\n\nimport type * as Obj from './Obj';\nimport type * as Type from './Type';\n\n// NOTE: Don't export: Relation.Relation and Relation.Any form the public API.\ninterface RelationBase<Source, Target>\n  extends Type.Relation.Endpoints<Source, Target>,\n    Type.OfKind<EchoSchema.EntityKind.Relation> {\n  readonly id: EchoSchema.ObjectId;\n}\n\n/**\n * Relation type with specific properties.\n */\nexport type Relation<Source extends Obj.Any, Target extends Obj.Any, Props> = RelationBase<Source, Target> & Props;\n\n/**\n * Base type for all ECHO relations.\n */\nexport interface Any extends RelationBase<Obj.Any, Obj.Any> {}\n\n// TODO(dmaretskyi): Has to be `unique symbol`.\nexport const Source: unique symbol = EchoSchema.RelationSourceId as any;\nexport type Source = typeof Source;\nexport const Target: unique symbol = EchoSchema.RelationTargetId as any;\nexport type Target = typeof Target;\n\ntype MakeProps<T extends Any> = {\n  id?: EchoSchema.ObjectId;\n  [Source]: T[Source];\n  [Target]: T[Target];\n} & Type.Properties<T>;\n\n/**\n * Creates new relation.\n * @param schema - Relation schema.\n * @param props - Relation properties. Endpoints are passed as [Relation.Source] and [Relation.Target] keys.\n * @param meta - Relation metadata.\n * @returns\n */\n// NOTE: Writing the definition this way (with generic over schema) makes typescript perfer to infer the type from the first param (this schema) rather than the second param (the props).\n// TODO(dmaretskyi): Move meta into props.\nexport const make = <S extends Type.Relation.Any>(\n  schema: S,\n  props: NoInfer<MakeProps<Schema.Schema.Type<S>>>,\n  meta?: EchoSchema.ObjectMeta,\n): Live<Schema.Schema.Type<S> & Type.OfKind<EchoSchema.EntityKind.Relation>> => {\n  assertArgument(\n    EchoSchema.getTypeAnnotation(schema)?.kind === EchoSchema.EntityKind.Relation,\n    'Expected a relation schema',\n  );\n\n  if (props[EchoSchema.MetaId] != null) {\n    meta = props[EchoSchema.MetaId] as any;\n    delete props[EchoSchema.MetaId];\n  }\n\n  const sourceDXN = EchoSchema.getObjectDXN(props[Source]) ?? raise(new Error('Unresolved relation source'));\n  const targetDXN = EchoSchema.getObjectDXN(props[Target]) ?? raise(new Error('Unresolved relation target'));\n  (props as any)[EchoSchema.RelationSourceDXNId] = sourceDXN;\n  (props as any)[EchoSchema.RelationTargetDXNId] = targetDXN;\n\n  return live<Schema.Schema.Type<S>>(schema, props as any, meta);\n};\n\nexport const isRelation = (value: unknown): value is Any => {\n  if (typeof value !== 'object' || value === null) {\n    return false;\n  }\n  if (EchoSchema.ATTR_RELATION_SOURCE in value || EchoSchema.ATTR_RELATION_TARGET in value) {\n    return true;\n  }\n\n  const kind = (value as any)[EchoSchema.EntityKindId];\n  return kind === EchoSchema.EntityKind.Relation;\n};\n\n/**\n * @returns Relation source DXN.\n * @throws If the object is not a relation.\n */\nexport const getSourceDXN = (value: Any): DXN => {\n  assertArgument(isRelation(value), 'Expected a relation');\n  assumeType<EchoSchema.InternalObjectProps>(value);\n  const dxn = (value as EchoSchema.InternalObjectProps)[EchoSchema.RelationSourceDXNId];\n  invariant(dxn instanceof DXN);\n  return dxn;\n};\n\n/**\n * @returns Relation target DXN.\n * @throws If the object is not a relation.\n */\nexport const getTargetDXN = (value: Any): DXN => {\n  assertArgument(isRelation(value), 'Expected a relation');\n  assumeType<EchoSchema.InternalObjectProps>(value);\n  const dxn = (value as EchoSchema.InternalObjectProps)[EchoSchema.RelationTargetDXNId];\n  invariant(dxn instanceof DXN);\n  return dxn;\n};\n\n/**\n * @returns Relation source.\n * @throws If the object is not a relation.\n */\nexport const getSource = <T extends Any>(relation: T): Type.Relation.Source<T> => {\n  assertArgument(isRelation(relation), 'Expected a relation');\n  assumeType<EchoSchema.InternalObjectProps>(relation);\n  const obj = (relation as EchoSchema.InternalObjectProps)[EchoSchema.RelationSourceId];\n  invariant(obj !== undefined, `Invalid source: ${relation.id}`);\n  return obj as Type.Relation.Source<T>;\n};\n\n/**\n * @returns Relation target.\n * @throws If the object is not a relation.\n */\nexport const getTarget = <T extends Any>(relation: T): Type.Relation.Target<T> => {\n  assertArgument(isRelation(relation), 'Expected a relation');\n  assumeType<EchoSchema.InternalObjectProps>(relation);\n  const obj = (relation as EchoSchema.InternalObjectProps)[EchoSchema.RelationTargetId];\n  invariant(obj !== undefined, `Invalid target: ${relation.id}`);\n  return obj as Type.Relation.Target<T>;\n};\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { type Schema } from 'effect';\nimport type { Simplify } from 'effect/Schema';\n\nimport type { EncodedReference } from '@dxos/echo-protocol';\nimport * as EchoSchema from '@dxos/echo-schema';\nimport type { ToMutable } from '@dxos/echo-schema';\nimport { invariant } from '@dxos/invariant';\nimport type * as Keys from '@dxos/keys';\n\nimport type * as RelationModule from './Relation';\n\nexport const KindId: unique symbol = EchoSchema.EntityKindId as any;\nexport type KindId = typeof KindId;\n\nexport { EntityKind as Kind } from '@dxos/echo-schema';\n\n/**\n * Assigns a kind to an Object or Relation instance.\n */\n// NOTE: Needed to make `isRelation` and `isObject` checks work.\nexport interface OfKind<Kind extends EchoSchema.EntityKind> {\n  readonly id: Keys.ObjectId;\n  readonly [KindId]: Kind;\n}\n\ninterface ObjJsonProps {\n  id: string;\n}\n\ninterface RelationJsonProps {\n  id: string;\n  [EchoSchema.ATTR_RELATION_SOURCE]: string;\n  [EchoSchema.ATTR_RELATION_TARGET]: string;\n}\n\n/**\n * Returns all properties of an object or relation except for the id and kind.\n */\nexport type Properties<T> = Omit<T, 'id' | KindId | RelationModule.Source | RelationModule.Target>;\n\n/**\n * Base ECHO schema type.\n */\nexport type Schema = EchoSchema.EchoSchema;\n\n/**\n * Return type of the `Obj` schema constructor.\n *\n * This typedef avoids `TS4023` error (name from external module cannot be used named).\n * See Effect's note on interface types.\n */\nexport interface obj<Self extends Schema.Schema.Any>\n  extends Schema.AnnotableClass<\n      obj<Self>,\n      OfKind<EchoSchema.EntityKind.Object> & ToMutable<Schema.Schema.Type<Self>>,\n      Simplify<ObjJsonProps & ToMutable<Schema.Schema.Encoded<Self>>>,\n      Schema.Schema.Context<Self>\n    >,\n    EchoSchema.TypeMeta {}\n\n/**\n * Object schema.\n */\nexport const Obj: {\n  (opts: EchoSchema.TypeMeta): <Self extends Schema.Schema.Any>(self: Self) => obj<Self>;\n} = EchoSchema.EchoObject as any;\n\n/**\n * Object schema type definitions.\n */\nexport namespace Obj {\n  /**\n   * Type that represents an arbitrary schema type of an object.\n   * NOTE: This is not an instance type.\n   */\n  // TODO(dmaretskyi): If schema was covariant, we could specify props in here, like `id: ObjectId`.\n  export type Any = Schema.Schema.AnyNoContext;\n}\n\n/**\n * Return type of the `Relation` schema constructor.\n *\n * This typedef avoids `TS4023` error (name from external module cannot be used named).\n * See Effect's note on interface types.\n */\nexport interface relation<\n  Self extends Schema.Schema.Any,\n  SourceSchema extends Schema.Schema.Any,\n  TargetSchema extends Schema.Schema.Any,\n> extends Schema.AnnotableClass<\n      relation<Self, SourceSchema, TargetSchema>,\n      OfKind<EchoSchema.EntityKind.Relation> &\n        Relation.Endpoints<Schema.Schema.Type<SourceSchema>, Schema.Schema.Type<TargetSchema>> &\n        ToMutable<Schema.Schema.Type<Self>>,\n      Simplify<RelationJsonProps & ToMutable<Schema.Schema.Encoded<Self>>>,\n      Schema.Schema.Context<Self>\n    >,\n    EchoSchema.TypeMeta {}\n\n/**\n * Relation schema.\n */\n// TODO(dmaretskyi): I have to redefine the type here so that the definition uses symbols from @dxos/echo/Relation.\nexport const Relation: {\n  <Source extends Schema.Schema.AnyNoContext, Target extends Schema.Schema.AnyNoContext>(\n    opts: EchoSchema.EchoRelationOptions<Source, Target>,\n  ): <Self extends Schema.Schema.Any>(self: Self) => relation<Self, Source, Target>;\n} = EchoSchema.EchoRelation as any;\n\n/**\n * Relation schema type definitions.\n */\nexport namespace Relation {\n  /**\n   * Type that represents an arbitrary schema type of a relation.\n   * NOTE: This is not an instance type.\n   */\n  // TODO(dmaretskyi): If schema was covariant, we could specify props in here, like `id: ObjectId`.\n  export type Any = Schema.Schema.AnyNoContext;\n\n  /**\n   * Get relation target type.\n   */\n  export type Target<A> = A extends Relation.Endpoints<infer _S, infer T> ? T : never;\n\n  /**\n   * Get relation source type.\n   */\n  export type Source<A> = A extends Relation.Endpoints<infer S, infer _T> ? S : never;\n\n  export type Endpoints<Source, Target> = {\n    [RelationModule.Source]: Source;\n    [RelationModule.Target]: Target;\n  };\n}\n\n/**\n * Return type of the `Ref` schema constructor.\n *\n * This typedef avoids `TS4023` error (name from external module cannot be used named).\n * See Effect's note on interface types.\n */\nexport interface ref<TargetSchema extends Schema.Schema.Any>\n  extends EchoSchema.Ref$<Schema.Schema.Type<TargetSchema>> {}\n\n/**\n * Ref schema.\n */\nexport const Ref: <S extends Obj.Any>(schema: S) => ref<S> = EchoSchema.Ref;\n\nexport interface Ref<T> extends Schema.SchemaClass<EchoSchema.Ref<T>, EncodedReference> {}\n\n// TODO(buurdon): Move to Ref?\nexport namespace Ref {\n  /**\n   * Type that represents an arbitrary schema type of a reference.\n   * NOTE: This is not an instance type.\n   */\n  export type Any = Schema.Schema<EchoSchema.Ref<any>, EncodedReference>;\n}\n\n/**\n * Gets the full DXN of the schema.\n * Will include the version if it's a `type` DXN.\n * @example \"dxn:example.com/type/Person:0.1.0\"\n * @example \"dxn:echo:SSSSSSSSSS:XXXXXXXXXXXXX\"\n */\nexport const getDXN = (schema: Obj.Any | Relation.Any): Keys.DXN | undefined => {\n  return EchoSchema.getSchemaDXN(schema);\n};\n\n/**\n * @param schema - Schema to get the typename from.\n * @returns The typename of the schema. Example: `example.com/type/Person`.\n */\nexport const getTypename = (schema: Obj.Any | Relation.Any): string => {\n  const typename = EchoSchema.getSchemaTypename(schema);\n  invariant(typeof typename === 'string' && !typename.startsWith('dxn:'), 'Invalid typename');\n  return typename;\n};\n\n/**\n * Gets the version of the schema.\n * @example 0.1.0\n */\nexport const getVersion = (schema: Obj.Any | Relation.Any): string => {\n  const version = EchoSchema.getSchemaVersion(schema);\n  invariant(typeof version === 'string' && version.match(/^\\d+\\.\\d+\\.\\d+$/), 'Invalid version');\n  return version;\n};\n\n/**\n * ECHO type metadata.\n */\nexport type Meta = EchoSchema.TypeAnnotation;\n\n/**\n * Gets the meta data of the schema.\n */\nexport const getMeta = (schema: Obj.Any | Relation.Any): Meta | undefined => {\n  return EchoSchema.getTypeAnnotation(schema);\n};\n\n/**\n * @returns True if the schema is mutable.\n */\nexport const isMutable = EchoSchema.isMutable;\n\nexport { SpaceId, ObjectId, DXN } from '@dxos/keys';\n\nexport interface Expando extends OfKind<EchoSchema.EntityKind.Object> {\n  [key: string]: any;\n}\n\nexport const Expando: Schema.Schema<\n  Expando,\n  Simplify<ObjJsonProps & { [key: string]: any }>,\n  never\n> = EchoSchema.Expando as any;\n\nexport {\n  // TODO(burdon): Standardize.\n  Format,\n  JsonSchemaType as JsonSchema,\n  toEffectSchema,\n  toJsonSchema,\n} from '@dxos/echo-schema';\n", "//\n// Copyright 2025 DXOS.org\n//\n\nexport * as Key from './Key';\nexport * as Obj from './Obj';\nexport * as Ref from './Ref';\nexport * as Relation from './Relation';\nexport * as Type from './Type';\n\nexport { DXN } from '@dxos/keys';\nexport { Filter, Query } from './query';\nexport { type Live } from '@dxos/live-object';\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { Schema } from 'effect';\nimport type { Simplify } from 'effect/Schema';\n\nimport { raise } from '@dxos/debug';\nimport { type ForeignKey, type QueryAST } from '@dxos/echo-protocol';\nimport { getTypeReference } from '@dxos/echo-schema';\nimport { assertArgument } from '@dxos/invariant';\nimport { DXN, ObjectId } from '@dxos/keys';\n\nimport * as Ref from '../Ref';\nimport type * as Type from '../Type';\n\n// TODO(dmaretskyi): Split up into interfaces for objects and relations so they can have separate verbs.\n// TODO(dmaretskyi): Undirected relation traversals.\n\nexport interface Query<T> {\n  // TODO(dmaretskyi): See new effect-schema approach to variance.\n  '~Query': { value: T };\n\n  ast: QueryAST.Query;\n\n  /**\n   * Filter the current selection based on a filter.\n   * @param filter - Filter to select the objects.\n   * @returns Query for the selected objects.\n   */\n  select(filter: Filter<T>): Query<T>;\n  select(props: Filter.Props<T>): Query<T>;\n\n  /**\n   * Traverse an outgoing reference.\n   * @param key - Property path inside T that is a reference.\n   * @returns Query for the target of the reference.\n   */\n  reference<K extends RefPropKey<T>>(key: K): Query<T[K] extends Ref.Any ? Ref.Target<T[K]> : never>;\n\n  /**\n   * Find objects referencing this object.\n   * @param target - Schema of the referencing object.\n   * @param key - Property path inside the referencing object that is a reference.\n   * @returns Query for the referencing objects.\n   */\n  // TODO(dmaretskyi): any way to enforce `Ref.Target<Schema.Schema.Type<S>[key]> == T`?\n  // TODO(dmaretskyi): Ability to go through arrays of references.\n  referencedBy<S extends Schema.Schema.All>(\n    target: S,\n    key: RefPropKey<Schema.Schema.Type<S>>,\n  ): Query<Schema.Schema.Type<S>>;\n\n  /**\n   * Find relations where this object is the source.\n   * @returns Query for the relation objects.\n   * @param relation - Schema of the relation.\n   * @param predicates - Predicates to filter the relation objects.\n   */\n  sourceOf<S extends Schema.Schema.All>(\n    relation: S,\n    predicates?: Filter.Props<Schema.Schema.Type<S>>,\n  ): Query<Schema.Schema.Type<S>>;\n\n  /**\n   * Find relations where this object is the target.\n   * @returns Query for the relation objects.\n   * @param relation - Schema of the relation.\n   * @param predicates - Predicates to filter the relation objects.\n   */\n  targetOf<S extends Schema.Schema.All>(\n    relation: S,\n    predicates?: Filter.Props<Schema.Schema.Type<S>>,\n  ): Query<Schema.Schema.Type<S>>;\n\n  /**\n   * For a query for relations, get the source objects.\n   * @returns Query for the source objects.\n   */\n  source(): Query<Type.Relation.Source<T>>;\n\n  /**\n   * For a query for relations, get the target objects.\n   * @returns Query for the target objects.\n   */\n  target(): Query<Type.Relation.Target<T>>;\n\n  /**\n   * Add options to a query.\n   */\n  options(options: QueryAST.QueryOptions): Query<T>;\n}\n\ninterface QueryAPI {\n  is(value: unknown): value is Query.Any;\n\n  /**\n   * Select objects based on a filter.\n   * @param filter - Filter to select the objects.\n   * @returns Query for the selected objects.\n   */\n  select<F extends Filter.Any>(filter: F): Query<Filter.Type<F>>;\n\n  /**\n   * Query for objects of a given schema.\n   * @param schema - Schema of the objects.\n   * @param predicates - Predicates to filter the objects.\n   * @returns Query for the objects.\n   *\n   * Shorthand for: `Query.select(Filter.type(schema, predicates))`.\n   */\n  type<S extends Schema.Schema.All>(\n    schema: S,\n    predicates?: Filter.Props<Schema.Schema.Type<S>>,\n  ): Query<Schema.Schema.Type<S>>;\n\n  /**\n   * Combine results of multiple queries.\n   * @param queries - Queries to combine.\n   * @returns Query for the combined results.\n   */\n  // TODO(dmaretskyi): Rename to `combine` or `union`.\n  all<T>(...queries: Query<T>[]): Query<T>;\n\n  /**\n   * Subtract one query from another.\n   * @param source - Query to subtract from.\n   * @param exclude - Query to subtract.\n   * @returns Query for the results of the source query minus the results of the exclude query.\n   */\n  without<T>(source: Query<T>, exclude: Query<T>): Query<T>;\n}\n\nexport declare namespace Query {\n  export type Any = Query<any>;\n\n  export type Type<Q extends Any> = Q extends Query<infer T> ? T : never;\n\n  export type TextSearchOptions = {\n    // TODO(dmaretskyi): Hybrid search.\n    type?: 'full-text' | 'vector';\n  };\n}\n\nexport interface Filter<T> {\n  // TODO(dmaretskyi): See new effect-schema approach to variance.\n  '~Filter': { value: T };\n\n  ast: QueryAST.Filter;\n}\n\ntype Intersection<Types extends readonly unknown[]> = Types extends [infer First, ...infer Rest]\n  ? First & Intersection<Rest>\n  : unknown;\n\ninterface FilterAPI {\n  is(value: unknown): value is Filter<any>;\n\n  /**\n   * Filter that matches all objects.\n   */\n  everything(): Filter<any>;\n\n  /**\n   * Filter that matches no objects.\n   */\n  nothing(): Filter<any>;\n\n  /**\n   * Filter by object IDs.\n   */\n  // TODO(dmaretskyi): Rename to `Filter.id`.\n  ids(...id: ObjectId[]): Filter<any>;\n\n  /**\n   * Filter by type.\n   */\n  type<S extends Schema.Schema.All>(\n    schema: S,\n    props?: Filter.Props<Schema.Schema.Type<S>>,\n  ): Filter<Schema.Schema.Type<S>>;\n\n  /**\n   * Filter by non-qualified typename.\n   */\n  typename(typename: string): Filter<any>;\n\n  /**\n   * Filter by fully qualified type DXN.\n   */\n  typeDXN(dxn: DXN): Filter<any>;\n\n  /**\n   * Filter by properties.\n   *\n   * INTERNAL API: Do not use.\n   */\n  _props<T>(props: Filter.Props<T>): Filter<T>;\n\n  /**\n   * Full-text or vector search.\n   */\n  text(\n    // TODO(dmaretskyi): Consider passing a vector here, but really the embedding should be done on the query-executor side.\n    text: string,\n    options?: Query.TextSearchOptions,\n  ): Filter<any>;\n\n  /**\n   * Filter by foreign keys.\n   */\n  foreignKeys<S extends Schema.Schema.All>(schema: S, keys: ForeignKey[]): Filter<Schema.Schema.Type<S>>;\n\n  /**\n   * Predicate for property to be equal to the provided value.\n   */\n  eq<T>(value: T): Filter<T>;\n\n  /**\n   * Predicate for property to be not equal to the provided value.\n   */\n  neq<T>(value: T): Filter<T>;\n\n  /**\n   * Predicate for property to be greater than the provided value.\n   */\n  gt<T>(value: T): Filter<T>;\n\n  /**\n   * Predicate for property to be greater than the provided value.\n   */\n  gt<T>(value: T): Filter<T>;\n\n  /**\n   * Predicate for property to be greater than or equal to the provided value.\n   */\n  gte<T>(value: T): Filter<T>;\n\n  /**\n   * Predicate for property to be less than the provided value.\n   */\n  lt<T>(value: T): Filter<T>;\n\n  /**\n   * Predicate for property to be less than or equal to the provided value.\n   */\n  lte<T>(value: T): Filter<T>;\n\n  /**\n   * Predicate for property to be in the provided array.\n   * @param values - Values to check against.\n   */\n  in<T>(...values: T[]): Filter<T>;\n\n  /**\n   * Predicate for property to be in the provided range.\n   * @param from - Start of the range (inclusive).\n   * @param to - End of the range (exclusive).\n   */\n  between<T>(from: T, to: T): Filter<T>;\n\n  /**\n   * Negate the filter.\n   */\n  not<F extends Filter.Any>(filter: F): Filter<Filter.Type<F>>;\n\n  /**\n   * Combine filters with a logical AND.\n   */\n  and<FS extends Filter.Any[]>(...filters: FS): Filter<Filter.And<FS>>;\n\n  /**\n   * Combine filters with a logical OR.\n   */\n  or<FS extends Filter.Any[]>(...filters: FS): Filter<Filter.Or<FS>>;\n\n  // TODO(dmaretskyi): Add `Filter.match` to support pattern matching on string props.\n}\n\nexport declare namespace Filter {\n  type Props<T> = {\n    // Predicate or a value as a shorthand for `eq`.\n    [K in keyof T & string]?: Filter<T[K]> | T[K];\n  };\n\n  type Any = Filter<any>;\n\n  type Type<F extends Any> = F extends Filter<infer T> ? T : never;\n\n  type And<FS extends readonly Any[]> = Simplify<Intersection<{ [K in keyof FS]: Type<FS[K]> }>>;\n\n  type Or<FS extends readonly Any[]> = Simplify<{ [K in keyof FS]: Type<FS[K]> }[number]>;\n}\n\nclass FilterClass implements Filter<any> {\n  private static variance: Filter<any>['~Filter'] = {} as Filter<any>['~Filter'];\n\n  static is(value: unknown): value is Filter<any> {\n    return typeof value === 'object' && value !== null && '~Filter' in value;\n  }\n\n  static everything(): FilterClass {\n    return new FilterClass({\n      type: 'object',\n      typename: null,\n      props: {},\n    });\n  }\n\n  static nothing(): FilterClass {\n    return new FilterClass({\n      type: 'not',\n      filter: {\n        type: 'object',\n        typename: null,\n        props: {},\n      },\n    });\n  }\n\n  static relation() {\n    return new FilterClass({\n      type: 'object',\n      typename: null,\n      props: {},\n    });\n  }\n\n  static ids(...ids: ObjectId[]): Filter<any> {\n    assertArgument(\n      ids.every((id) => ObjectId.isValid(id)),\n      'ids must be valid',\n    );\n\n    if (ids.length === 0) {\n      return Filter.nothing();\n    }\n\n    return new FilterClass({\n      type: 'object',\n      typename: null,\n      id: ids,\n      props: {},\n    });\n  }\n\n  static type<S extends Schema.Schema.All>(\n    schema: S,\n    props?: Filter.Props<Schema.Schema.Type<S>>,\n  ): Filter<Schema.Schema.Type<S>> {\n    const dxn = getTypeReference(schema)?.toDXN() ?? raise(new TypeError('Schema has no DXN'));\n    return new FilterClass({\n      type: 'object',\n      typename: dxn.toString(),\n      ...propsFilterToAst(props ?? {}),\n    });\n  }\n\n  static typename(typename: string): Filter<any> {\n    assertArgument(!typename.startsWith('dxn:'), 'Typename must no be qualified');\n    return new FilterClass({\n      type: 'object',\n      typename: DXN.fromTypename(typename).toString(),\n      props: {},\n    });\n  }\n\n  static typeDXN(dxn: DXN): Filter<any> {\n    return new FilterClass({\n      type: 'object',\n      typename: dxn.toString(),\n      props: {},\n    });\n  }\n\n  /**\n   * @internal\n   */\n  static _props<T>(props: Filter.Props<T>): Filter<T> {\n    return new FilterClass({\n      type: 'object',\n      typename: null,\n      ...propsFilterToAst(props),\n    });\n  }\n\n  static text(text: string, options?: Query.TextSearchOptions): Filter<any> {\n    return new FilterClass({\n      type: 'text-search',\n      text,\n      searchKind: options?.type,\n    });\n  }\n\n  static foreignKeys<S extends Schema.Schema.All>(schema: S, keys: ForeignKey[]): Filter<Schema.Schema.Type<S>> {\n    const dxn = getTypeReference(schema)?.toDXN() ?? raise(new TypeError('Schema has no DXN'));\n    return new FilterClass({\n      type: 'object',\n      typename: dxn.toString(),\n      props: {},\n      foreignKeys: keys,\n    });\n  }\n\n  static eq<T>(value: T): Filter<T> {\n    if (!Ref.isRef(value) && typeof value === 'object' && value !== null) {\n      throw new TypeError('Cannot use object as a value for eq filter');\n    }\n\n    return new FilterClass({\n      type: 'compare',\n      operator: 'eq',\n      value: Ref.isRef(value) ? value.noInline().encode() : value,\n    });\n  }\n\n  static neq<T>(value: T): Filter<T> {\n    return new FilterClass({\n      type: 'compare',\n      operator: 'neq',\n      value,\n    });\n  }\n\n  static gt<T>(value: T): Filter<T> {\n    return new FilterClass({\n      type: 'compare',\n      operator: 'gt',\n      value,\n    });\n  }\n\n  static gte<T>(value: T): Filter<T> {\n    return new FilterClass({\n      type: 'compare',\n      operator: 'gte',\n      value,\n    });\n  }\n\n  static lt<T>(value: T): Filter<T> {\n    return new FilterClass({\n      type: 'compare',\n      operator: 'lt',\n      value,\n    });\n  }\n\n  static lte<T>(value: T): Filter<T> {\n    return new FilterClass({\n      type: 'compare',\n      operator: 'lte',\n      value,\n    });\n  }\n\n  static in<T>(...values: T[]): Filter<T> {\n    return new FilterClass({\n      type: 'in',\n      values,\n    });\n  }\n\n  static between<T>(from: T, to: T): Filter<T> {\n    return new FilterClass({\n      type: 'range',\n      from,\n      to,\n    });\n  }\n\n  static not<F extends Filter.Any>(filter: F): Filter<Filter.Type<F>> {\n    return new FilterClass({\n      type: 'not',\n      filter: filter.ast,\n    });\n  }\n\n  static and<T>(...filters: Filter<T>[]): Filter<T> {\n    return new FilterClass({\n      type: 'and',\n      filters: filters.map((f) => f.ast),\n    });\n  }\n\n  static or<T>(...filters: Filter<T>[]): Filter<T> {\n    return new FilterClass({\n      type: 'or',\n      filters: filters.map((f) => f.ast),\n    });\n  }\n\n  private constructor(public readonly ast: QueryAST.Filter) {}\n\n  '~Filter' = FilterClass.variance;\n}\n\nexport const Filter: FilterAPI = FilterClass;\n\n/**\n * All property paths inside T that are references.\n */\n// TODO(dmaretskyi): Filter only properties that are references (or optional references, or unions that include references).\ntype RefPropKey<T> = keyof T & string;\n\nconst propsFilterToAst = (predicates: Filter.Props<any>): Pick<QueryAST.FilterObject, 'id' | 'props'> => {\n  let idFilter: readonly ObjectId[] | undefined;\n  if ('id' in predicates) {\n    assertArgument(typeof predicates.id === 'string' || Array.isArray(predicates.id), 'invalid id filter');\n    idFilter = typeof predicates.id === 'string' ? [predicates.id] : predicates.id;\n    Schema.Array(ObjectId).pipe(Schema.validateSync)(idFilter);\n  }\n\n  return {\n    id: idFilter,\n    props: Object.fromEntries(\n      Object.entries(predicates)\n        .filter(([prop, _value]) => prop !== 'id')\n        .map(([prop, predicate]) => [prop, Filter.is(predicate) ? predicate.ast : Filter.eq(predicate).ast]),\n    ) as Record<string, QueryAST.Filter>,\n  };\n};\n\nclass QueryClass implements Query<any> {\n  private static variance: Query<any>['~Query'] = {} as Query<any>['~Query'];\n\n  static is(value: unknown): value is Query<any> {\n    return typeof value === 'object' && value !== null && '~Query' in value;\n  }\n\n  static select<F extends Filter.Any>(filter: F): Query<Filter.Type<F>> {\n    return new QueryClass({\n      type: 'select',\n      filter: filter.ast,\n    });\n  }\n\n  static type(schema: Schema.Schema.All, predicates?: Filter.Props<unknown>): Query<any> {\n    return new QueryClass({\n      type: 'select',\n      filter: FilterClass.type(schema, predicates).ast,\n    });\n  }\n\n  static all(...queries: Query<any>[]): Query<any> {\n    if (queries.length === 0) {\n      throw new TypeError(\n        'Query.all combines results of multiple queries, to query all objects use Query.select(Filter.everything())',\n      );\n    }\n    return new QueryClass({\n      type: 'union',\n      queries: queries.map((q) => q.ast),\n    });\n  }\n\n  static without<T>(source: Query<T>, exclude: Query<T>): Query<T> {\n    return new QueryClass({\n      type: 'set-difference',\n      source: source.ast,\n      exclude: exclude.ast,\n    });\n  }\n\n  constructor(public readonly ast: QueryAST.Query) {}\n\n  '~Query' = QueryClass.variance;\n\n  select(filter: Filter<any> | Filter.Props<any>): Query<any> {\n    if (Filter.is(filter)) {\n      return new QueryClass({\n        type: 'filter',\n        selection: this.ast,\n        filter: filter.ast,\n      });\n    } else {\n      return new QueryClass({\n        type: 'filter',\n        selection: this.ast,\n        filter: FilterClass._props(filter).ast,\n      });\n    }\n  }\n\n  reference(key: string): Query<any> {\n    return new QueryClass({\n      type: 'reference-traversal',\n      anchor: this.ast,\n      property: key,\n    });\n  }\n\n  referencedBy(target: Schema.Schema.All, key: string): Query<any> {\n    const dxn = getTypeReference(target)?.toDXN() ?? raise(new TypeError('Target schema has no DXN'));\n    return new QueryClass({\n      type: 'incoming-references',\n      anchor: this.ast,\n      property: key,\n      typename: dxn.toString(),\n    });\n  }\n\n  sourceOf(relation: Schema.Schema.All, predicates?: Filter.Props<unknown> | undefined): Query<any> {\n    return new QueryClass({\n      type: 'relation',\n      anchor: this.ast,\n      direction: 'outgoing',\n      filter: FilterClass.type(relation, predicates).ast,\n    });\n  }\n\n  targetOf(relation: Schema.Schema.All, predicates?: Filter.Props<unknown> | undefined): Query<any> {\n    return new QueryClass({\n      type: 'relation',\n      anchor: this.ast,\n      direction: 'incoming',\n      filter: FilterClass.type(relation, predicates).ast,\n    });\n  }\n\n  source(): Query<any> {\n    return new QueryClass({\n      type: 'relation-traversal',\n      anchor: this.ast,\n      direction: 'source',\n    });\n  }\n\n  target(): Query<any> {\n    return new QueryClass({\n      type: 'relation-traversal',\n      anchor: this.ast,\n      direction: 'target',\n    });\n  }\n\n  options(options: QueryAST.QueryOptions): Query<any> {\n    return new QueryClass({\n      type: 'options',\n      query: this.ast,\n      options,\n    });\n  }\n}\n\nexport const Query: QueryAPI = QueryClass;\n"],
  "mappings": "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",
  "names": ["SpaceId", "ObjectId", "getLabel", "getMeta", "getSchema", "isDeleted", "Schema", "EchoSchema", "assertArgument", "invariant", "live", "assumeType", "make", "schema", "props", "meta", "getTypeAnnotation", "kind", "EntityKind", "Object", "MetaId", "isObject", "obj", "EntityKindId", "instanceOf", "args", "length", "isInstanceOf", "getDXN", "isSchema", "dxn", "getObjectDXN", "getTypeDXN", "getType", "getTypename", "asTypeDXN", "type", "getSchemaTypename", "deleted", "toJSON", "objectToJSON", "fromJSON", "objectFromJSON", "Array", "make", "EchoSchema", "Array", "RefArray", "isRef", "Ref", "make", "fromDXN", "make", "raise", "EchoSchema", "assertArgument", "invariant", "DXN", "live", "assumeType", "Source", "RelationSourceId", "Target", "RelationTargetId", "schema", "props", "meta", "getTypeAnnotation", "kind", "EntityKind", "Relation", "MetaId", "sourceDXN", "getObjectDXN", "Error", "targetDXN", "RelationSourceDXNId", "RelationTargetDXNId", "isRelation", "value", "ATTR_RELATION_SOURCE", "ATTR_RELATION_TARGET", "EntityKindId", "getSourceDXN", "dxn", "getTargetDXN", "getSource", "relation", "obj", "undefined", "id", "getTarget", "DXN", "Expando", "EntityKind", "ObjectId", "Ref", "SpaceId", "getDXN", "getMeta", "getTypename", "isMutable", "EchoSchema", "invariant", "Kind", "Format", "JsonSchema", "toEffectSchema", "toJsonSchema", "KindId", "EntityKindId", "Obj", "EchoObject", "Relation", "EchoRelation", "schema", "getSchemaDXN", "typename", "getSchemaTypename", "startsWith", "getVersion", "version", "getSchemaVersion", "match", "getTypeAnnotation", "DXN", "Schema", "raise", "getTypeReference", "assertArgument", "DXN", "ObjectId", "FilterClass", "variance", "is", "value", "everything", "type", "typename", "props", "nothing", "filter", "relation", "ids", "assertArgument", "every", "id", "ObjectId", "isValid", "length", "Filter", "schema", "dxn", "getTypeReference", "toDXN", "raise", "TypeError", "toString", "propsFilterToAst", "startsWith", "DXN", "fromTypename", "typeDXN", "_props", "text", "options", "searchKind", "foreignKeys", "keys", "eq", "isRef", "operator", "noInline", "encode", "neq", "gt", "gte", "lt", "lte", "in", "values", "between", "from", "to", "not", "ast", "and", "filters", "map", "f", "or", "predicates", "idFilter", "Array", "isArray", "Schema", "pipe", "validateSync", "Object", "fromEntries", "entries", "prop", "_value", "predicate", "QueryClass", "select", "all", "queries", "q", "without", "source", "exclude", "selection", "reference", "key", "anchor", "property", "referencedBy", "target", "sourceOf", "direction", "targetOf", "query", "Query"]
}
