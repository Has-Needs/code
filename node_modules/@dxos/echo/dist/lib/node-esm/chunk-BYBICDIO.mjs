import { createRequire } from 'node:module';const require = createRequire(import.meta.url);
var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// packages/core/echo/echo/src/Key.ts
var Key_exports = {};
__export(Key_exports, {
  ObjectId: () => ObjectId,
  SpaceId: () => SpaceId
});
import { SpaceId, ObjectId } from "@dxos/keys";

// packages/core/echo/echo/src/Obj.ts
var Obj_exports = {};
__export(Obj_exports, {
  fromJSON: () => fromJSON,
  getDXN: () => getDXN,
  getLabel: () => getLabel2,
  getMeta: () => getMeta2,
  getSchema: () => getSchema2,
  getTypeDXN: () => getTypeDXN,
  getTypename: () => getTypename,
  instanceOf: () => instanceOf,
  isDeleted: () => isDeleted2,
  isObject: () => isObject,
  make: () => make,
  toJSON: () => toJSON
});
import { Schema } from "effect";
import * as EchoSchema from "@dxos/echo-schema";
import { assertArgument, invariant } from "@dxos/invariant";
import { live } from "@dxos/live-object";
import { assumeType } from "@dxos/util";
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/core/echo/echo/src/Obj.ts";
var make = (schema, props, meta) => {
  assertArgument(EchoSchema.getTypeAnnotation(schema)?.kind === EchoSchema.EntityKind.Object, "Expected an object schema");
  if (props[EchoSchema.MetaId] != null) {
    meta = props[EchoSchema.MetaId];
    delete props[EchoSchema.MetaId];
  }
  return live(schema, props, meta);
};
var isObject = (obj) => {
  assumeType(obj);
  return typeof obj === "object" && obj !== null && obj[EchoSchema.EntityKindId] === EchoSchema.EntityKind.Object;
};
var instanceOf = (...args) => {
  if (args.length === 1) {
    return (obj) => EchoSchema.isInstanceOf(args[0], obj);
  }
  return EchoSchema.isInstanceOf(args[0], args[1]);
};
var getSchema2 = EchoSchema.getSchema;
var getDXN = (obj) => {
  assertArgument(!Schema.isSchema(obj), "Object should not be a schema.");
  const dxn = EchoSchema.getObjectDXN(obj);
  invariant(dxn != null, "Invalid object.", {
    F: __dxlog_file,
    L: 96,
    S: void 0,
    A: [
      "dxn != null",
      "'Invalid object.'"
    ]
  });
  return dxn;
};
var getTypeDXN = EchoSchema.getType;
var getTypename = (obj) => {
  const schema = getSchema2(obj);
  if (schema == null) {
    return EchoSchema.getType(obj)?.asTypeDXN()?.type;
  }
  return EchoSchema.getSchemaTypename(schema);
};
var getMeta2 = (obj) => {
  const meta = EchoSchema.getMeta(obj);
  invariant(meta != null, "Invalid object.", {
    F: __dxlog_file,
    L: 124,
    S: void 0,
    A: [
      "meta != null",
      "'Invalid object.'"
    ]
  });
  return meta;
};
var isDeleted2 = (obj) => {
  const deleted = EchoSchema.isDeleted(obj);
  invariant(typeof deleted === "boolean", "Invalid object.", {
    F: __dxlog_file,
    L: 131,
    S: void 0,
    A: [
      "typeof deleted === 'boolean'",
      "'Invalid object.'"
    ]
  });
  return deleted;
};
var getLabel2 = (obj) => {
  const schema = getSchema2(obj);
  if (schema != null) {
    return EchoSchema.getLabel(schema, obj);
  }
};
var toJSON = (obj) => EchoSchema.objectToJSON(obj);
var fromJSON = EchoSchema.objectFromJSON;

// packages/core/echo/echo/src/Ref.ts
var Ref_exports = {};
__export(Ref_exports, {
  Array: () => Array2,
  fromDXN: () => fromDXN,
  isRef: () => isRef,
  make: () => make2
});
import * as EchoSchema2 from "@dxos/echo-schema";
var Array2 = EchoSchema2.RefArray;
var isRef = EchoSchema2.Ref.isRef;
var make2 = EchoSchema2.Ref.make;
var fromDXN = EchoSchema2.Ref.fromDXN;

// packages/core/echo/echo/src/Relation.ts
var Relation_exports = {};
__export(Relation_exports, {
  Source: () => Source,
  Target: () => Target,
  getSource: () => getSource,
  getSourceDXN: () => getSourceDXN,
  getTarget: () => getTarget,
  getTargetDXN: () => getTargetDXN,
  isRelation: () => isRelation,
  make: () => make3
});
import { raise } from "@dxos/debug";
import * as EchoSchema3 from "@dxos/echo-schema";
import { assertArgument as assertArgument2, invariant as invariant2 } from "@dxos/invariant";
import { DXN } from "@dxos/keys";
import { live as live2 } from "@dxos/live-object";
import { assumeType as assumeType2 } from "@dxos/util";
var __dxlog_file2 = "/home/runner/work/dxos/dxos/packages/core/echo/echo/src/Relation.ts";
var Source = EchoSchema3.RelationSourceId;
var Target = EchoSchema3.RelationTargetId;
var make3 = (schema, props, meta) => {
  assertArgument2(EchoSchema3.getTypeAnnotation(schema)?.kind === EchoSchema3.EntityKind.Relation, "Expected a relation schema");
  if (props[EchoSchema3.MetaId] != null) {
    meta = props[EchoSchema3.MetaId];
    delete props[EchoSchema3.MetaId];
  }
  const sourceDXN = EchoSchema3.getObjectDXN(props[Source]) ?? raise(new Error("Unresolved relation source"));
  const targetDXN = EchoSchema3.getObjectDXN(props[Target]) ?? raise(new Error("Unresolved relation target"));
  props[EchoSchema3.RelationSourceDXNId] = sourceDXN;
  props[EchoSchema3.RelationTargetDXNId] = targetDXN;
  return live2(schema, props, meta);
};
var isRelation = (value) => {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  if (EchoSchema3.ATTR_RELATION_SOURCE in value || EchoSchema3.ATTR_RELATION_TARGET in value) {
    return true;
  }
  const kind = value[EchoSchema3.EntityKindId];
  return kind === EchoSchema3.EntityKind.Relation;
};
var getSourceDXN = (value) => {
  assertArgument2(isRelation(value), "Expected a relation");
  assumeType2(value);
  const dxn = value[EchoSchema3.RelationSourceDXNId];
  invariant2(dxn instanceof DXN, void 0, {
    F: __dxlog_file2,
    L: 98,
    S: void 0,
    A: [
      "dxn instanceof DXN",
      ""
    ]
  });
  return dxn;
};
var getTargetDXN = (value) => {
  assertArgument2(isRelation(value), "Expected a relation");
  assumeType2(value);
  const dxn = value[EchoSchema3.RelationTargetDXNId];
  invariant2(dxn instanceof DXN, void 0, {
    F: __dxlog_file2,
    L: 110,
    S: void 0,
    A: [
      "dxn instanceof DXN",
      ""
    ]
  });
  return dxn;
};
var getSource = (relation) => {
  assertArgument2(isRelation(relation), "Expected a relation");
  assumeType2(relation);
  const obj = relation[EchoSchema3.RelationSourceId];
  invariant2(obj !== void 0, `Invalid source: ${relation.id}`, {
    F: __dxlog_file2,
    L: 122,
    S: void 0,
    A: [
      "obj !== undefined",
      "`Invalid source: ${relation.id}`"
    ]
  });
  return obj;
};
var getTarget = (relation) => {
  assertArgument2(isRelation(relation), "Expected a relation");
  assumeType2(relation);
  const obj = relation[EchoSchema3.RelationTargetId];
  invariant2(obj !== void 0, `Invalid target: ${relation.id}`, {
    F: __dxlog_file2,
    L: 134,
    S: void 0,
    A: [
      "obj !== undefined",
      "`Invalid target: ${relation.id}`"
    ]
  });
  return obj;
};

// packages/core/echo/echo/src/Type.ts
var Type_exports = {};
__export(Type_exports, {
  DXN: () => DXN2,
  Expando: () => Expando2,
  Format: () => Format,
  JsonSchema: () => JsonSchemaType,
  Kind: () => EntityKind3,
  KindId: () => KindId,
  Obj: () => Obj,
  ObjectId: () => ObjectId2,
  Ref: () => Ref3,
  Relation: () => Relation,
  SpaceId: () => SpaceId2,
  getDXN: () => getDXN2,
  getMeta: () => getMeta3,
  getTypename: () => getTypename2,
  getVersion: () => getVersion,
  isMutable: () => isMutable2,
  toEffectSchema: () => toEffectSchema,
  toJsonSchema: () => toJsonSchema
});
import * as EchoSchema4 from "@dxos/echo-schema";
import { invariant as invariant3 } from "@dxos/invariant";
import { EntityKind as EntityKind3 } from "@dxos/echo-schema";
import { SpaceId as SpaceId2, ObjectId as ObjectId2, DXN as DXN2 } from "@dxos/keys";
import {
  Format,
  JsonSchemaType,
  toEffectSchema,
  toJsonSchema
} from "@dxos/echo-schema";
var __dxlog_file3 = "/home/runner/work/dxos/dxos/packages/core/echo/echo/src/Type.ts";
var KindId = EchoSchema4.EntityKindId;
var Obj = EchoSchema4.EchoObject;
var Relation = EchoSchema4.EchoRelation;
var Ref3 = EchoSchema4.Ref;
var getDXN2 = (schema) => {
  return EchoSchema4.getSchemaDXN(schema);
};
var getTypename2 = (schema) => {
  const typename = EchoSchema4.getSchemaTypename(schema);
  invariant3(typeof typename === "string" && !typename.startsWith("dxn:"), "Invalid typename", {
    F: __dxlog_file3,
    L: 182,
    S: void 0,
    A: [
      "typeof typename === 'string' && !typename.startsWith('dxn:')",
      "'Invalid typename'"
    ]
  });
  return typename;
};
var getVersion = (schema) => {
  const version = EchoSchema4.getSchemaVersion(schema);
  invariant3(typeof version === "string" && version.match(/^\d+\.\d+\.\d+$/), "Invalid version", {
    F: __dxlog_file3,
    L: 192,
    S: void 0,
    A: [
      "typeof version === 'string' && version.match(/^\\d+\\.\\d+\\.\\d+$/)",
      "'Invalid version'"
    ]
  });
  return version;
};
var getMeta3 = (schema) => {
  return EchoSchema4.getTypeAnnotation(schema);
};
var isMutable2 = EchoSchema4.isMutable;
var Expando2 = EchoSchema4.Expando;

// packages/core/echo/echo/src/index.ts
import { DXN as DXN4 } from "@dxos/keys";

// packages/core/echo/echo/src/query/dsl.ts
import { Schema as Schema2 } from "effect";
import { raise as raise2 } from "@dxos/debug";
import { getTypeReference } from "@dxos/echo-schema";
import { assertArgument as assertArgument3 } from "@dxos/invariant";
import { DXN as DXN3, ObjectId as ObjectId3 } from "@dxos/keys";
var FilterClass = class _FilterClass {
  static {
    this.variance = {};
  }
  static is(value) {
    return typeof value === "object" && value !== null && "~Filter" in value;
  }
  static everything() {
    return new _FilterClass({
      type: "object",
      typename: null,
      props: {}
    });
  }
  static nothing() {
    return new _FilterClass({
      type: "not",
      filter: {
        type: "object",
        typename: null,
        props: {}
      }
    });
  }
  static relation() {
    return new _FilterClass({
      type: "object",
      typename: null,
      props: {}
    });
  }
  static ids(...ids) {
    assertArgument3(ids.every((id) => ObjectId3.isValid(id)), "ids must be valid");
    if (ids.length === 0) {
      return Filter.nothing();
    }
    return new _FilterClass({
      type: "object",
      typename: null,
      id: ids,
      props: {}
    });
  }
  static type(schema, props) {
    const dxn = getTypeReference(schema)?.toDXN() ?? raise2(new TypeError("Schema has no DXN"));
    return new _FilterClass({
      type: "object",
      typename: dxn.toString(),
      ...propsFilterToAst(props ?? {})
    });
  }
  static typename(typename) {
    assertArgument3(!typename.startsWith("dxn:"), "Typename must no be qualified");
    return new _FilterClass({
      type: "object",
      typename: DXN3.fromTypename(typename).toString(),
      props: {}
    });
  }
  static typeDXN(dxn) {
    return new _FilterClass({
      type: "object",
      typename: dxn.toString(),
      props: {}
    });
  }
  /**
  * @internal
  */
  static _props(props) {
    return new _FilterClass({
      type: "object",
      typename: null,
      ...propsFilterToAst(props)
    });
  }
  static text(text, options) {
    return new _FilterClass({
      type: "text-search",
      text,
      searchKind: options?.type
    });
  }
  static foreignKeys(schema, keys) {
    const dxn = getTypeReference(schema)?.toDXN() ?? raise2(new TypeError("Schema has no DXN"));
    return new _FilterClass({
      type: "object",
      typename: dxn.toString(),
      props: {},
      foreignKeys: keys
    });
  }
  static eq(value) {
    if (!isRef(value) && typeof value === "object" && value !== null) {
      throw new TypeError("Cannot use object as a value for eq filter");
    }
    return new _FilterClass({
      type: "compare",
      operator: "eq",
      value: isRef(value) ? value.noInline().encode() : value
    });
  }
  static neq(value) {
    return new _FilterClass({
      type: "compare",
      operator: "neq",
      value
    });
  }
  static gt(value) {
    return new _FilterClass({
      type: "compare",
      operator: "gt",
      value
    });
  }
  static gte(value) {
    return new _FilterClass({
      type: "compare",
      operator: "gte",
      value
    });
  }
  static lt(value) {
    return new _FilterClass({
      type: "compare",
      operator: "lt",
      value
    });
  }
  static lte(value) {
    return new _FilterClass({
      type: "compare",
      operator: "lte",
      value
    });
  }
  static in(...values) {
    return new _FilterClass({
      type: "in",
      values
    });
  }
  static between(from, to) {
    return new _FilterClass({
      type: "range",
      from,
      to
    });
  }
  static not(filter) {
    return new _FilterClass({
      type: "not",
      filter: filter.ast
    });
  }
  static and(...filters) {
    return new _FilterClass({
      type: "and",
      filters: filters.map((f) => f.ast)
    });
  }
  static or(...filters) {
    return new _FilterClass({
      type: "or",
      filters: filters.map((f) => f.ast)
    });
  }
  constructor(ast) {
    this.ast = ast;
    this["~Filter"] = _FilterClass.variance;
  }
};
var Filter = FilterClass;
var propsFilterToAst = (predicates) => {
  let idFilter;
  if ("id" in predicates) {
    assertArgument3(typeof predicates.id === "string" || Array.isArray(predicates.id), "invalid id filter");
    idFilter = typeof predicates.id === "string" ? [
      predicates.id
    ] : predicates.id;
    Schema2.Array(ObjectId3).pipe(Schema2.validateSync)(idFilter);
  }
  return {
    id: idFilter,
    props: Object.fromEntries(Object.entries(predicates).filter(([prop, _value]) => prop !== "id").map(([prop, predicate]) => [
      prop,
      Filter.is(predicate) ? predicate.ast : Filter.eq(predicate).ast
    ]))
  };
};
var QueryClass = class _QueryClass {
  static {
    this.variance = {};
  }
  static is(value) {
    return typeof value === "object" && value !== null && "~Query" in value;
  }
  static select(filter) {
    return new _QueryClass({
      type: "select",
      filter: filter.ast
    });
  }
  static type(schema, predicates) {
    return new _QueryClass({
      type: "select",
      filter: FilterClass.type(schema, predicates).ast
    });
  }
  static all(...queries) {
    if (queries.length === 0) {
      throw new TypeError("Query.all combines results of multiple queries, to query all objects use Query.select(Filter.everything())");
    }
    return new _QueryClass({
      type: "union",
      queries: queries.map((q) => q.ast)
    });
  }
  static without(source, exclude) {
    return new _QueryClass({
      type: "set-difference",
      source: source.ast,
      exclude: exclude.ast
    });
  }
  constructor(ast) {
    this.ast = ast;
    this["~Query"] = _QueryClass.variance;
  }
  select(filter) {
    if (Filter.is(filter)) {
      return new _QueryClass({
        type: "filter",
        selection: this.ast,
        filter: filter.ast
      });
    } else {
      return new _QueryClass({
        type: "filter",
        selection: this.ast,
        filter: FilterClass._props(filter).ast
      });
    }
  }
  reference(key) {
    return new _QueryClass({
      type: "reference-traversal",
      anchor: this.ast,
      property: key
    });
  }
  referencedBy(target, key) {
    const dxn = getTypeReference(target)?.toDXN() ?? raise2(new TypeError("Target schema has no DXN"));
    return new _QueryClass({
      type: "incoming-references",
      anchor: this.ast,
      property: key,
      typename: dxn.toString()
    });
  }
  sourceOf(relation, predicates) {
    return new _QueryClass({
      type: "relation",
      anchor: this.ast,
      direction: "outgoing",
      filter: FilterClass.type(relation, predicates).ast
    });
  }
  targetOf(relation, predicates) {
    return new _QueryClass({
      type: "relation",
      anchor: this.ast,
      direction: "incoming",
      filter: FilterClass.type(relation, predicates).ast
    });
  }
  source() {
    return new _QueryClass({
      type: "relation-traversal",
      anchor: this.ast,
      direction: "source"
    });
  }
  target() {
    return new _QueryClass({
      type: "relation-traversal",
      anchor: this.ast,
      direction: "target"
    });
  }
  options(options) {
    return new _QueryClass({
      type: "options",
      query: this.ast,
      options
    });
  }
};
var Query = QueryClass;

export {
  Key_exports,
  Obj_exports,
  Ref_exports,
  Relation_exports,
  Type_exports,
  Filter,
  Query,
  DXN4 as DXN
};
//# sourceMappingURL=chunk-BYBICDIO.mjs.map
