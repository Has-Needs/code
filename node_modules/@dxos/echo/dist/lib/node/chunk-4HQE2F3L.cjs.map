{
  "version": 3,
  "sources": ["../../../src/Key.ts", "../../../src/Obj.ts", "../../../src/Ref.ts", "../../../src/Relation.ts", "../../../src/Type.ts", "../../../src/index.ts", "../../../src/query/dsl.ts"],
  "sourcesContent": ["//\n// Copyright 2025 DXOS.org\n//\n\nexport { SpaceId, ObjectId } from '@dxos/keys';\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { Schema } from 'effect';\n\nimport * as EchoSchema from '@dxos/echo-schema';\nimport { assertArgument, invariant } from '@dxos/invariant';\nimport { type DXN } from '@dxos/keys';\nimport type * as LiveObject from '@dxos/live-object';\nimport { live } from '@dxos/live-object';\nimport { assumeType } from '@dxos/util';\n\nimport type * as Ref from './Ref';\nimport type * as Relation from './Relation';\nimport type * as Type from './Type';\n\n// NOTE: Don't export: Obj.Any and Obj.Obj form the public API.\ninterface ObjBase extends Type.OfKind<EchoSchema.EntityKind.Object> {\n  readonly id: EchoSchema.ObjectId;\n}\n\n/**\n * Object type with specific properties.\n */\nexport type Obj<Props> = ObjBase & Props;\n\n/**\n * Base type for all ECHO objects.\n */\nexport interface Any extends ObjBase {}\n\ntype MakeProps<T> = {\n  id?: EchoSchema.ObjectId;\n} & Type.Properties<T>;\n\n/**\n * Creates new object.\n */\n// TODO(dmaretskyi): Move meta into props.\nexport const make = <S extends Type.Obj.Any>(\n  schema: S,\n  props: NoInfer<MakeProps<Schema.Schema.Type<S>>>,\n  meta?: EchoSchema.ObjectMeta,\n): LiveObject.Live<Schema.Schema.Type<S>> => {\n  assertArgument(\n    EchoSchema.getTypeAnnotation(schema)?.kind === EchoSchema.EntityKind.Object,\n    'Expected an object schema',\n  );\n\n  if (props[EchoSchema.MetaId] != null) {\n    meta = props[EchoSchema.MetaId] as any;\n    delete props[EchoSchema.MetaId];\n  }\n\n  return live<Schema.Schema.Type<S>>(schema, props as any, meta);\n};\n\nexport const isObject = (obj: unknown): obj is Any => {\n  assumeType<EchoSchema.InternalObjectProps>(obj);\n  return typeof obj === 'object' && obj !== null && obj[EchoSchema.EntityKindId] === EchoSchema.EntityKind.Object;\n};\n\n/**\n * Test if object or relation is an instance of a schema.\n * @example\n * ```ts\n * const john = Obj.make(Person, { name: 'John' });\n * const johnIsPerson = Obj.instanceOf(Person)(john);\n *\n * const isPerson = Obj.instanceOf(Person);\n * if(isPerson(john)) {\n *   // john is Person\n * }\n * ```\n */\nexport const instanceOf: {\n  <S extends Type.Relation.Any | Type.Obj.Any>(schema: S): (value: unknown) => value is Schema.Schema.Type<S>;\n  <S extends Type.Relation.Any | Type.Obj.Any>(schema: S, value: unknown): value is Schema.Schema.Type<S>;\n} = ((\n  ...args: [schema: Type.Relation.Any | Type.Obj.Any, value: unknown] | [schema: Type.Relation.Any | Type.Obj.Any]\n) => {\n  if (args.length === 1) {\n    return (obj: unknown) => EchoSchema.isInstanceOf(args[0], obj);\n  }\n\n  return EchoSchema.isInstanceOf(args[0], args[1]);\n}) as any;\n\nexport const getSchema = EchoSchema.getSchema;\n\n// TODO(dmaretskyi): Allow returning undefined.\nexport const getDXN = (obj: Any): DXN => {\n  assertArgument(!Schema.isSchema(obj), 'Object should not be a schema.');\n  const dxn = EchoSchema.getObjectDXN(obj);\n  invariant(dxn != null, 'Invalid object.');\n  return dxn;\n};\n\n/**\n * @returns The DXN of the object's type.\n * @example dxn:example.com/type/Contact:1.0.0\n */\n// TODO(burdon): Expando does not have a type.\nexport const getTypeDXN = EchoSchema.getType;\n\n/**\n * @returns The typename of the object's type.\n * @example `example.com/type/Contact`\n */\nexport const getTypename = (obj: Any): string | undefined => {\n  const schema = getSchema(obj);\n  if (schema == null) {\n    // Try to extract typename from DXN.\n    return EchoSchema.getType(obj)?.asTypeDXN()?.type;\n  }\n\n  return EchoSchema.getSchemaTypename(schema);\n};\n\n// TODO(dmaretskyi): Allow returning undefined.\nexport const getMeta = (obj: Any): EchoSchema.ObjectMeta => {\n  const meta = EchoSchema.getMeta(obj);\n  invariant(meta != null, 'Invalid object.');\n  return meta;\n};\n\n// TODO(dmaretskyi): Default to `false`.\nexport const isDeleted = (obj: Any): boolean => {\n  const deleted = EchoSchema.isDeleted(obj);\n  invariant(typeof deleted === 'boolean', 'Invalid object.');\n  return deleted;\n};\n\nexport const getLabel = (obj: Any): string | undefined => {\n  const schema = getSchema(obj);\n  if (schema != null) {\n    return EchoSchema.getLabel(schema, obj);\n  }\n};\n\n/**\n * JSON representation of an object.\n */\nexport type JSON = EchoSchema.ObjectJSON;\n\n/**\n * Converts object to its JSON representation.\n *\n * The same algorithm is used when calling the standard `JSON.stringify(obj)` function.\n */\nexport const toJSON = (obj: Any | Relation.Any): JSON => EchoSchema.objectToJSON(obj);\n\n/**\n * Creates an object from its json representation, performing schema validation.\n * References and schemas will be resolvable if the `refResolver` is provided.\n *\n * The function need to be async to support resolving the schema as well as the relation endpoints.\n */\nexport const fromJSON: (json: unknown, options?: { refResolver?: Ref.Resolver }) => Promise<Any> =\n  EchoSchema.objectFromJSON as any;\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport * as EchoSchema from '@dxos/echo-schema';\n\nimport type * as Obj from './Obj';\n\nexport type Ref<T> = EchoSchema.Ref<T>;\nexport type Any = EchoSchema.Ref<Obj.Any>;\n\nexport const Array = EchoSchema.RefArray;\n\n/**\n * Extract reference target.\n */\nexport type Target<R extends Any> = R extends EchoSchema.Ref<infer T> ? T : never;\n\n/**\n * Reference resolver.\n */\nexport type Resolver = EchoSchema.RefResolver;\n\nexport const isRef: (value: unknown) => value is Any = EchoSchema.Ref.isRef;\n\nexport const make = EchoSchema.Ref.make;\n\n// TODO(dmaretskyi): Consider just allowing `make` to accept DXN.\nexport const fromDXN = EchoSchema.Ref.fromDXN;\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { type Schema } from 'effect';\n\nimport { raise } from '@dxos/debug';\nimport * as EchoSchema from '@dxos/echo-schema';\nimport { assertArgument, invariant } from '@dxos/invariant';\nimport { DXN } from '@dxos/keys';\nimport { type Live, live } from '@dxos/live-object';\nimport { assumeType } from '@dxos/util';\n\nimport type * as Obj from './Obj';\nimport type * as Type from './Type';\n\n// NOTE: Don't export: Relation.Relation and Relation.Any form the public API.\ninterface RelationBase<Source, Target>\n  extends Type.Relation.Endpoints<Source, Target>,\n    Type.OfKind<EchoSchema.EntityKind.Relation> {\n  readonly id: EchoSchema.ObjectId;\n}\n\n/**\n * Relation type with specific properties.\n */\nexport type Relation<Source extends Obj.Any, Target extends Obj.Any, Props> = RelationBase<Source, Target> & Props;\n\n/**\n * Base type for all ECHO relations.\n */\nexport interface Any extends RelationBase<Obj.Any, Obj.Any> {}\n\n// TODO(dmaretskyi): Has to be `unique symbol`.\nexport const Source: unique symbol = EchoSchema.RelationSourceId as any;\nexport type Source = typeof Source;\nexport const Target: unique symbol = EchoSchema.RelationTargetId as any;\nexport type Target = typeof Target;\n\ntype MakeProps<T extends Any> = {\n  id?: EchoSchema.ObjectId;\n  [Source]: T[Source];\n  [Target]: T[Target];\n} & Type.Properties<T>;\n\n/**\n * Creates new relation.\n * @param schema - Relation schema.\n * @param props - Relation properties. Endpoints are passed as [Relation.Source] and [Relation.Target] keys.\n * @param meta - Relation metadata.\n * @returns\n */\n// NOTE: Writing the definition this way (with generic over schema) makes typescript perfer to infer the type from the first param (this schema) rather than the second param (the props).\n// TODO(dmaretskyi): Move meta into props.\nexport const make = <S extends Type.Relation.Any>(\n  schema: S,\n  props: NoInfer<MakeProps<Schema.Schema.Type<S>>>,\n  meta?: EchoSchema.ObjectMeta,\n): Live<Schema.Schema.Type<S> & Type.OfKind<EchoSchema.EntityKind.Relation>> => {\n  assertArgument(\n    EchoSchema.getTypeAnnotation(schema)?.kind === EchoSchema.EntityKind.Relation,\n    'Expected a relation schema',\n  );\n\n  if (props[EchoSchema.MetaId] != null) {\n    meta = props[EchoSchema.MetaId] as any;\n    delete props[EchoSchema.MetaId];\n  }\n\n  const sourceDXN = EchoSchema.getObjectDXN(props[Source]) ?? raise(new Error('Unresolved relation source'));\n  const targetDXN = EchoSchema.getObjectDXN(props[Target]) ?? raise(new Error('Unresolved relation target'));\n  (props as any)[EchoSchema.RelationSourceDXNId] = sourceDXN;\n  (props as any)[EchoSchema.RelationTargetDXNId] = targetDXN;\n\n  return live<Schema.Schema.Type<S>>(schema, props as any, meta);\n};\n\nexport const isRelation = (value: unknown): value is Any => {\n  if (typeof value !== 'object' || value === null) {\n    return false;\n  }\n  if (EchoSchema.ATTR_RELATION_SOURCE in value || EchoSchema.ATTR_RELATION_TARGET in value) {\n    return true;\n  }\n\n  const kind = (value as any)[EchoSchema.EntityKindId];\n  return kind === EchoSchema.EntityKind.Relation;\n};\n\n/**\n * @returns Relation source DXN.\n * @throws If the object is not a relation.\n */\nexport const getSourceDXN = (value: Any): DXN => {\n  assertArgument(isRelation(value), 'Expected a relation');\n  assumeType<EchoSchema.InternalObjectProps>(value);\n  const dxn = (value as EchoSchema.InternalObjectProps)[EchoSchema.RelationSourceDXNId];\n  invariant(dxn instanceof DXN);\n  return dxn;\n};\n\n/**\n * @returns Relation target DXN.\n * @throws If the object is not a relation.\n */\nexport const getTargetDXN = (value: Any): DXN => {\n  assertArgument(isRelation(value), 'Expected a relation');\n  assumeType<EchoSchema.InternalObjectProps>(value);\n  const dxn = (value as EchoSchema.InternalObjectProps)[EchoSchema.RelationTargetDXNId];\n  invariant(dxn instanceof DXN);\n  return dxn;\n};\n\n/**\n * @returns Relation source.\n * @throws If the object is not a relation.\n */\nexport const getSource = <T extends Any>(relation: T): Type.Relation.Source<T> => {\n  assertArgument(isRelation(relation), 'Expected a relation');\n  assumeType<EchoSchema.InternalObjectProps>(relation);\n  const obj = (relation as EchoSchema.InternalObjectProps)[EchoSchema.RelationSourceId];\n  invariant(obj !== undefined, `Invalid source: ${relation.id}`);\n  return obj as Type.Relation.Source<T>;\n};\n\n/**\n * @returns Relation target.\n * @throws If the object is not a relation.\n */\nexport const getTarget = <T extends Any>(relation: T): Type.Relation.Target<T> => {\n  assertArgument(isRelation(relation), 'Expected a relation');\n  assumeType<EchoSchema.InternalObjectProps>(relation);\n  const obj = (relation as EchoSchema.InternalObjectProps)[EchoSchema.RelationTargetId];\n  invariant(obj !== undefined, `Invalid target: ${relation.id}`);\n  return obj as Type.Relation.Target<T>;\n};\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { type Schema } from 'effect';\nimport type { Simplify } from 'effect/Schema';\n\nimport type { EncodedReference } from '@dxos/echo-protocol';\nimport * as EchoSchema from '@dxos/echo-schema';\nimport type { ToMutable } from '@dxos/echo-schema';\nimport { invariant } from '@dxos/invariant';\nimport type * as Keys from '@dxos/keys';\n\nimport type * as RelationModule from './Relation';\n\nexport const KindId: unique symbol = EchoSchema.EntityKindId as any;\nexport type KindId = typeof KindId;\n\nexport { EntityKind as Kind } from '@dxos/echo-schema';\n\n/**\n * Assigns a kind to an Object or Relation instance.\n */\n// NOTE: Needed to make `isRelation` and `isObject` checks work.\nexport interface OfKind<Kind extends EchoSchema.EntityKind> {\n  readonly id: Keys.ObjectId;\n  readonly [KindId]: Kind;\n}\n\ninterface ObjJsonProps {\n  id: string;\n}\n\ninterface RelationJsonProps {\n  id: string;\n  [EchoSchema.ATTR_RELATION_SOURCE]: string;\n  [EchoSchema.ATTR_RELATION_TARGET]: string;\n}\n\n/**\n * Returns all properties of an object or relation except for the id and kind.\n */\nexport type Properties<T> = Omit<T, 'id' | KindId | RelationModule.Source | RelationModule.Target>;\n\n/**\n * Base ECHO schema type.\n */\nexport type Schema = EchoSchema.EchoSchema;\n\n/**\n * Return type of the `Obj` schema constructor.\n *\n * This typedef avoids `TS4023` error (name from external module cannot be used named).\n * See Effect's note on interface types.\n */\nexport interface obj<Self extends Schema.Schema.Any>\n  extends Schema.AnnotableClass<\n      obj<Self>,\n      OfKind<EchoSchema.EntityKind.Object> & ToMutable<Schema.Schema.Type<Self>>,\n      Simplify<ObjJsonProps & ToMutable<Schema.Schema.Encoded<Self>>>,\n      Schema.Schema.Context<Self>\n    >,\n    EchoSchema.TypeMeta {}\n\n/**\n * Object schema.\n */\nexport const Obj: {\n  (opts: EchoSchema.TypeMeta): <Self extends Schema.Schema.Any>(self: Self) => obj<Self>;\n} = EchoSchema.EchoObject as any;\n\n/**\n * Object schema type definitions.\n */\nexport namespace Obj {\n  /**\n   * Type that represents an arbitrary schema type of an object.\n   * NOTE: This is not an instance type.\n   */\n  // TODO(dmaretskyi): If schema was covariant, we could specify props in here, like `id: ObjectId`.\n  export type Any = Schema.Schema.AnyNoContext;\n}\n\n/**\n * Return type of the `Relation` schema constructor.\n *\n * This typedef avoids `TS4023` error (name from external module cannot be used named).\n * See Effect's note on interface types.\n */\nexport interface relation<\n  Self extends Schema.Schema.Any,\n  SourceSchema extends Schema.Schema.Any,\n  TargetSchema extends Schema.Schema.Any,\n> extends Schema.AnnotableClass<\n      relation<Self, SourceSchema, TargetSchema>,\n      OfKind<EchoSchema.EntityKind.Relation> &\n        Relation.Endpoints<Schema.Schema.Type<SourceSchema>, Schema.Schema.Type<TargetSchema>> &\n        ToMutable<Schema.Schema.Type<Self>>,\n      Simplify<RelationJsonProps & ToMutable<Schema.Schema.Encoded<Self>>>,\n      Schema.Schema.Context<Self>\n    >,\n    EchoSchema.TypeMeta {}\n\n/**\n * Relation schema.\n */\n// TODO(dmaretskyi): I have to redefine the type here so that the definition uses symbols from @dxos/echo/Relation.\nexport const Relation: {\n  <Source extends Schema.Schema.AnyNoContext, Target extends Schema.Schema.AnyNoContext>(\n    opts: EchoSchema.EchoRelationOptions<Source, Target>,\n  ): <Self extends Schema.Schema.Any>(self: Self) => relation<Self, Source, Target>;\n} = EchoSchema.EchoRelation as any;\n\n/**\n * Relation schema type definitions.\n */\nexport namespace Relation {\n  /**\n   * Type that represents an arbitrary schema type of a relation.\n   * NOTE: This is not an instance type.\n   */\n  // TODO(dmaretskyi): If schema was covariant, we could specify props in here, like `id: ObjectId`.\n  export type Any = Schema.Schema.AnyNoContext;\n\n  /**\n   * Get relation target type.\n   */\n  export type Target<A> = A extends Relation.Endpoints<infer _S, infer T> ? T : never;\n\n  /**\n   * Get relation source type.\n   */\n  export type Source<A> = A extends Relation.Endpoints<infer S, infer _T> ? S : never;\n\n  export type Endpoints<Source, Target> = {\n    [RelationModule.Source]: Source;\n    [RelationModule.Target]: Target;\n  };\n}\n\n/**\n * Return type of the `Ref` schema constructor.\n *\n * This typedef avoids `TS4023` error (name from external module cannot be used named).\n * See Effect's note on interface types.\n */\nexport interface ref<TargetSchema extends Schema.Schema.Any>\n  extends EchoSchema.Ref$<Schema.Schema.Type<TargetSchema>> {}\n\n/**\n * Ref schema.\n */\nexport const Ref: <S extends Obj.Any>(schema: S) => ref<S> = EchoSchema.Ref;\n\nexport interface Ref<T> extends Schema.SchemaClass<EchoSchema.Ref<T>, EncodedReference> {}\n\n// TODO(buurdon): Move to Ref?\nexport namespace Ref {\n  /**\n   * Type that represents an arbitrary schema type of a reference.\n   * NOTE: This is not an instance type.\n   */\n  export type Any = Schema.Schema<EchoSchema.Ref<any>, EncodedReference>;\n}\n\n/**\n * Gets the full DXN of the schema.\n * Will include the version if it's a `type` DXN.\n * @example \"dxn:example.com/type/Person:0.1.0\"\n * @example \"dxn:echo:SSSSSSSSSS:XXXXXXXXXXXXX\"\n */\nexport const getDXN = (schema: Obj.Any | Relation.Any): Keys.DXN | undefined => {\n  return EchoSchema.getSchemaDXN(schema);\n};\n\n/**\n * @param schema - Schema to get the typename from.\n * @returns The typename of the schema. Example: `example.com/type/Person`.\n */\nexport const getTypename = (schema: Obj.Any | Relation.Any): string => {\n  const typename = EchoSchema.getSchemaTypename(schema);\n  invariant(typeof typename === 'string' && !typename.startsWith('dxn:'), 'Invalid typename');\n  return typename;\n};\n\n/**\n * Gets the version of the schema.\n * @example 0.1.0\n */\nexport const getVersion = (schema: Obj.Any | Relation.Any): string => {\n  const version = EchoSchema.getSchemaVersion(schema);\n  invariant(typeof version === 'string' && version.match(/^\\d+\\.\\d+\\.\\d+$/), 'Invalid version');\n  return version;\n};\n\n/**\n * ECHO type metadata.\n */\nexport type Meta = EchoSchema.TypeAnnotation;\n\n/**\n * Gets the meta data of the schema.\n */\nexport const getMeta = (schema: Obj.Any | Relation.Any): Meta | undefined => {\n  return EchoSchema.getTypeAnnotation(schema);\n};\n\n/**\n * @returns True if the schema is mutable.\n */\nexport const isMutable = EchoSchema.isMutable;\n\nexport { SpaceId, ObjectId, DXN } from '@dxos/keys';\n\nexport interface Expando extends OfKind<EchoSchema.EntityKind.Object> {\n  [key: string]: any;\n}\n\nexport const Expando: Schema.Schema<\n  Expando,\n  Simplify<ObjJsonProps & { [key: string]: any }>,\n  never\n> = EchoSchema.Expando as any;\n\nexport {\n  // TODO(burdon): Standardize.\n  Format,\n  JsonSchemaType as JsonSchema,\n  toEffectSchema,\n  toJsonSchema,\n} from '@dxos/echo-schema';\n", "//\n// Copyright 2025 DXOS.org\n//\n\nexport * as Key from './Key';\nexport * as Obj from './Obj';\nexport * as Ref from './Ref';\nexport * as Relation from './Relation';\nexport * as Type from './Type';\n\nexport { DXN } from '@dxos/keys';\nexport { Filter, Query } from './query';\nexport { type Live } from '@dxos/live-object';\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { Schema } from 'effect';\nimport type { Simplify } from 'effect/Schema';\n\nimport { raise } from '@dxos/debug';\nimport { type ForeignKey, type QueryAST } from '@dxos/echo-protocol';\nimport { getTypeReference } from '@dxos/echo-schema';\nimport { assertArgument } from '@dxos/invariant';\nimport { DXN, ObjectId } from '@dxos/keys';\n\nimport * as Ref from '../Ref';\nimport type * as Type from '../Type';\n\n// TODO(dmaretskyi): Split up into interfaces for objects and relations so they can have separate verbs.\n// TODO(dmaretskyi): Undirected relation traversals.\n\nexport interface Query<T> {\n  // TODO(dmaretskyi): See new effect-schema approach to variance.\n  '~Query': { value: T };\n\n  ast: QueryAST.Query;\n\n  /**\n   * Filter the current selection based on a filter.\n   * @param filter - Filter to select the objects.\n   * @returns Query for the selected objects.\n   */\n  select(filter: Filter<T>): Query<T>;\n  select(props: Filter.Props<T>): Query<T>;\n\n  /**\n   * Traverse an outgoing reference.\n   * @param key - Property path inside T that is a reference.\n   * @returns Query for the target of the reference.\n   */\n  reference<K extends RefPropKey<T>>(key: K): Query<T[K] extends Ref.Any ? Ref.Target<T[K]> : never>;\n\n  /**\n   * Find objects referencing this object.\n   * @param target - Schema of the referencing object.\n   * @param key - Property path inside the referencing object that is a reference.\n   * @returns Query for the referencing objects.\n   */\n  // TODO(dmaretskyi): any way to enforce `Ref.Target<Schema.Schema.Type<S>[key]> == T`?\n  // TODO(dmaretskyi): Ability to go through arrays of references.\n  referencedBy<S extends Schema.Schema.All>(\n    target: S,\n    key: RefPropKey<Schema.Schema.Type<S>>,\n  ): Query<Schema.Schema.Type<S>>;\n\n  /**\n   * Find relations where this object is the source.\n   * @returns Query for the relation objects.\n   * @param relation - Schema of the relation.\n   * @param predicates - Predicates to filter the relation objects.\n   */\n  sourceOf<S extends Schema.Schema.All>(\n    relation: S,\n    predicates?: Filter.Props<Schema.Schema.Type<S>>,\n  ): Query<Schema.Schema.Type<S>>;\n\n  /**\n   * Find relations where this object is the target.\n   * @returns Query for the relation objects.\n   * @param relation - Schema of the relation.\n   * @param predicates - Predicates to filter the relation objects.\n   */\n  targetOf<S extends Schema.Schema.All>(\n    relation: S,\n    predicates?: Filter.Props<Schema.Schema.Type<S>>,\n  ): Query<Schema.Schema.Type<S>>;\n\n  /**\n   * For a query for relations, get the source objects.\n   * @returns Query for the source objects.\n   */\n  source(): Query<Type.Relation.Source<T>>;\n\n  /**\n   * For a query for relations, get the target objects.\n   * @returns Query for the target objects.\n   */\n  target(): Query<Type.Relation.Target<T>>;\n\n  /**\n   * Add options to a query.\n   */\n  options(options: QueryAST.QueryOptions): Query<T>;\n}\n\ninterface QueryAPI {\n  is(value: unknown): value is Query.Any;\n\n  /**\n   * Select objects based on a filter.\n   * @param filter - Filter to select the objects.\n   * @returns Query for the selected objects.\n   */\n  select<F extends Filter.Any>(filter: F): Query<Filter.Type<F>>;\n\n  /**\n   * Query for objects of a given schema.\n   * @param schema - Schema of the objects.\n   * @param predicates - Predicates to filter the objects.\n   * @returns Query for the objects.\n   *\n   * Shorthand for: `Query.select(Filter.type(schema, predicates))`.\n   */\n  type<S extends Schema.Schema.All>(\n    schema: S,\n    predicates?: Filter.Props<Schema.Schema.Type<S>>,\n  ): Query<Schema.Schema.Type<S>>;\n\n  /**\n   * Combine results of multiple queries.\n   * @param queries - Queries to combine.\n   * @returns Query for the combined results.\n   */\n  // TODO(dmaretskyi): Rename to `combine` or `union`.\n  all<T>(...queries: Query<T>[]): Query<T>;\n\n  /**\n   * Subtract one query from another.\n   * @param source - Query to subtract from.\n   * @param exclude - Query to subtract.\n   * @returns Query for the results of the source query minus the results of the exclude query.\n   */\n  without<T>(source: Query<T>, exclude: Query<T>): Query<T>;\n}\n\nexport declare namespace Query {\n  export type Any = Query<any>;\n\n  export type Type<Q extends Any> = Q extends Query<infer T> ? T : never;\n\n  export type TextSearchOptions = {\n    // TODO(dmaretskyi): Hybrid search.\n    type?: 'full-text' | 'vector';\n  };\n}\n\nexport interface Filter<T> {\n  // TODO(dmaretskyi): See new effect-schema approach to variance.\n  '~Filter': { value: T };\n\n  ast: QueryAST.Filter;\n}\n\ntype Intersection<Types extends readonly unknown[]> = Types extends [infer First, ...infer Rest]\n  ? First & Intersection<Rest>\n  : unknown;\n\ninterface FilterAPI {\n  is(value: unknown): value is Filter<any>;\n\n  /**\n   * Filter that matches all objects.\n   */\n  everything(): Filter<any>;\n\n  /**\n   * Filter that matches no objects.\n   */\n  nothing(): Filter<any>;\n\n  /**\n   * Filter by object IDs.\n   */\n  // TODO(dmaretskyi): Rename to `Filter.id`.\n  ids(...id: ObjectId[]): Filter<any>;\n\n  /**\n   * Filter by type.\n   */\n  type<S extends Schema.Schema.All>(\n    schema: S,\n    props?: Filter.Props<Schema.Schema.Type<S>>,\n  ): Filter<Schema.Schema.Type<S>>;\n\n  /**\n   * Filter by non-qualified typename.\n   */\n  typename(typename: string): Filter<any>;\n\n  /**\n   * Filter by fully qualified type DXN.\n   */\n  typeDXN(dxn: DXN): Filter<any>;\n\n  /**\n   * Filter by properties.\n   *\n   * INTERNAL API: Do not use.\n   */\n  _props<T>(props: Filter.Props<T>): Filter<T>;\n\n  /**\n   * Full-text or vector search.\n   */\n  text(\n    // TODO(dmaretskyi): Consider passing a vector here, but really the embedding should be done on the query-executor side.\n    text: string,\n    options?: Query.TextSearchOptions,\n  ): Filter<any>;\n\n  /**\n   * Filter by foreign keys.\n   */\n  foreignKeys<S extends Schema.Schema.All>(schema: S, keys: ForeignKey[]): Filter<Schema.Schema.Type<S>>;\n\n  /**\n   * Predicate for property to be equal to the provided value.\n   */\n  eq<T>(value: T): Filter<T>;\n\n  /**\n   * Predicate for property to be not equal to the provided value.\n   */\n  neq<T>(value: T): Filter<T>;\n\n  /**\n   * Predicate for property to be greater than the provided value.\n   */\n  gt<T>(value: T): Filter<T>;\n\n  /**\n   * Predicate for property to be greater than the provided value.\n   */\n  gt<T>(value: T): Filter<T>;\n\n  /**\n   * Predicate for property to be greater than or equal to the provided value.\n   */\n  gte<T>(value: T): Filter<T>;\n\n  /**\n   * Predicate for property to be less than the provided value.\n   */\n  lt<T>(value: T): Filter<T>;\n\n  /**\n   * Predicate for property to be less than or equal to the provided value.\n   */\n  lte<T>(value: T): Filter<T>;\n\n  /**\n   * Predicate for property to be in the provided array.\n   * @param values - Values to check against.\n   */\n  in<T>(...values: T[]): Filter<T>;\n\n  /**\n   * Predicate for property to be in the provided range.\n   * @param from - Start of the range (inclusive).\n   * @param to - End of the range (exclusive).\n   */\n  between<T>(from: T, to: T): Filter<T>;\n\n  /**\n   * Negate the filter.\n   */\n  not<F extends Filter.Any>(filter: F): Filter<Filter.Type<F>>;\n\n  /**\n   * Combine filters with a logical AND.\n   */\n  and<FS extends Filter.Any[]>(...filters: FS): Filter<Filter.And<FS>>;\n\n  /**\n   * Combine filters with a logical OR.\n   */\n  or<FS extends Filter.Any[]>(...filters: FS): Filter<Filter.Or<FS>>;\n\n  // TODO(dmaretskyi): Add `Filter.match` to support pattern matching on string props.\n}\n\nexport declare namespace Filter {\n  type Props<T> = {\n    // Predicate or a value as a shorthand for `eq`.\n    [K in keyof T & string]?: Filter<T[K]> | T[K];\n  };\n\n  type Any = Filter<any>;\n\n  type Type<F extends Any> = F extends Filter<infer T> ? T : never;\n\n  type And<FS extends readonly Any[]> = Simplify<Intersection<{ [K in keyof FS]: Type<FS[K]> }>>;\n\n  type Or<FS extends readonly Any[]> = Simplify<{ [K in keyof FS]: Type<FS[K]> }[number]>;\n}\n\nclass FilterClass implements Filter<any> {\n  private static variance: Filter<any>['~Filter'] = {} as Filter<any>['~Filter'];\n\n  static is(value: unknown): value is Filter<any> {\n    return typeof value === 'object' && value !== null && '~Filter' in value;\n  }\n\n  static everything(): FilterClass {\n    return new FilterClass({\n      type: 'object',\n      typename: null,\n      props: {},\n    });\n  }\n\n  static nothing(): FilterClass {\n    return new FilterClass({\n      type: 'not',\n      filter: {\n        type: 'object',\n        typename: null,\n        props: {},\n      },\n    });\n  }\n\n  static relation() {\n    return new FilterClass({\n      type: 'object',\n      typename: null,\n      props: {},\n    });\n  }\n\n  static ids(...ids: ObjectId[]): Filter<any> {\n    assertArgument(\n      ids.every((id) => ObjectId.isValid(id)),\n      'ids must be valid',\n    );\n\n    if (ids.length === 0) {\n      return Filter.nothing();\n    }\n\n    return new FilterClass({\n      type: 'object',\n      typename: null,\n      id: ids,\n      props: {},\n    });\n  }\n\n  static type<S extends Schema.Schema.All>(\n    schema: S,\n    props?: Filter.Props<Schema.Schema.Type<S>>,\n  ): Filter<Schema.Schema.Type<S>> {\n    const dxn = getTypeReference(schema)?.toDXN() ?? raise(new TypeError('Schema has no DXN'));\n    return new FilterClass({\n      type: 'object',\n      typename: dxn.toString(),\n      ...propsFilterToAst(props ?? {}),\n    });\n  }\n\n  static typename(typename: string): Filter<any> {\n    assertArgument(!typename.startsWith('dxn:'), 'Typename must no be qualified');\n    return new FilterClass({\n      type: 'object',\n      typename: DXN.fromTypename(typename).toString(),\n      props: {},\n    });\n  }\n\n  static typeDXN(dxn: DXN): Filter<any> {\n    return new FilterClass({\n      type: 'object',\n      typename: dxn.toString(),\n      props: {},\n    });\n  }\n\n  /**\n   * @internal\n   */\n  static _props<T>(props: Filter.Props<T>): Filter<T> {\n    return new FilterClass({\n      type: 'object',\n      typename: null,\n      ...propsFilterToAst(props),\n    });\n  }\n\n  static text(text: string, options?: Query.TextSearchOptions): Filter<any> {\n    return new FilterClass({\n      type: 'text-search',\n      text,\n      searchKind: options?.type,\n    });\n  }\n\n  static foreignKeys<S extends Schema.Schema.All>(schema: S, keys: ForeignKey[]): Filter<Schema.Schema.Type<S>> {\n    const dxn = getTypeReference(schema)?.toDXN() ?? raise(new TypeError('Schema has no DXN'));\n    return new FilterClass({\n      type: 'object',\n      typename: dxn.toString(),\n      props: {},\n      foreignKeys: keys,\n    });\n  }\n\n  static eq<T>(value: T): Filter<T> {\n    if (!Ref.isRef(value) && typeof value === 'object' && value !== null) {\n      throw new TypeError('Cannot use object as a value for eq filter');\n    }\n\n    return new FilterClass({\n      type: 'compare',\n      operator: 'eq',\n      value: Ref.isRef(value) ? value.noInline().encode() : value,\n    });\n  }\n\n  static neq<T>(value: T): Filter<T> {\n    return new FilterClass({\n      type: 'compare',\n      operator: 'neq',\n      value,\n    });\n  }\n\n  static gt<T>(value: T): Filter<T> {\n    return new FilterClass({\n      type: 'compare',\n      operator: 'gt',\n      value,\n    });\n  }\n\n  static gte<T>(value: T): Filter<T> {\n    return new FilterClass({\n      type: 'compare',\n      operator: 'gte',\n      value,\n    });\n  }\n\n  static lt<T>(value: T): Filter<T> {\n    return new FilterClass({\n      type: 'compare',\n      operator: 'lt',\n      value,\n    });\n  }\n\n  static lte<T>(value: T): Filter<T> {\n    return new FilterClass({\n      type: 'compare',\n      operator: 'lte',\n      value,\n    });\n  }\n\n  static in<T>(...values: T[]): Filter<T> {\n    return new FilterClass({\n      type: 'in',\n      values,\n    });\n  }\n\n  static between<T>(from: T, to: T): Filter<T> {\n    return new FilterClass({\n      type: 'range',\n      from,\n      to,\n    });\n  }\n\n  static not<F extends Filter.Any>(filter: F): Filter<Filter.Type<F>> {\n    return new FilterClass({\n      type: 'not',\n      filter: filter.ast,\n    });\n  }\n\n  static and<T>(...filters: Filter<T>[]): Filter<T> {\n    return new FilterClass({\n      type: 'and',\n      filters: filters.map((f) => f.ast),\n    });\n  }\n\n  static or<T>(...filters: Filter<T>[]): Filter<T> {\n    return new FilterClass({\n      type: 'or',\n      filters: filters.map((f) => f.ast),\n    });\n  }\n\n  private constructor(public readonly ast: QueryAST.Filter) {}\n\n  '~Filter' = FilterClass.variance;\n}\n\nexport const Filter: FilterAPI = FilterClass;\n\n/**\n * All property paths inside T that are references.\n */\n// TODO(dmaretskyi): Filter only properties that are references (or optional references, or unions that include references).\ntype RefPropKey<T> = keyof T & string;\n\nconst propsFilterToAst = (predicates: Filter.Props<any>): Pick<QueryAST.FilterObject, 'id' | 'props'> => {\n  let idFilter: readonly ObjectId[] | undefined;\n  if ('id' in predicates) {\n    assertArgument(typeof predicates.id === 'string' || Array.isArray(predicates.id), 'invalid id filter');\n    idFilter = typeof predicates.id === 'string' ? [predicates.id] : predicates.id;\n    Schema.Array(ObjectId).pipe(Schema.validateSync)(idFilter);\n  }\n\n  return {\n    id: idFilter,\n    props: Object.fromEntries(\n      Object.entries(predicates)\n        .filter(([prop, _value]) => prop !== 'id')\n        .map(([prop, predicate]) => [prop, Filter.is(predicate) ? predicate.ast : Filter.eq(predicate).ast]),\n    ) as Record<string, QueryAST.Filter>,\n  };\n};\n\nclass QueryClass implements Query<any> {\n  private static variance: Query<any>['~Query'] = {} as Query<any>['~Query'];\n\n  static is(value: unknown): value is Query<any> {\n    return typeof value === 'object' && value !== null && '~Query' in value;\n  }\n\n  static select<F extends Filter.Any>(filter: F): Query<Filter.Type<F>> {\n    return new QueryClass({\n      type: 'select',\n      filter: filter.ast,\n    });\n  }\n\n  static type(schema: Schema.Schema.All, predicates?: Filter.Props<unknown>): Query<any> {\n    return new QueryClass({\n      type: 'select',\n      filter: FilterClass.type(schema, predicates).ast,\n    });\n  }\n\n  static all(...queries: Query<any>[]): Query<any> {\n    if (queries.length === 0) {\n      throw new TypeError(\n        'Query.all combines results of multiple queries, to query all objects use Query.select(Filter.everything())',\n      );\n    }\n    return new QueryClass({\n      type: 'union',\n      queries: queries.map((q) => q.ast),\n    });\n  }\n\n  static without<T>(source: Query<T>, exclude: Query<T>): Query<T> {\n    return new QueryClass({\n      type: 'set-difference',\n      source: source.ast,\n      exclude: exclude.ast,\n    });\n  }\n\n  constructor(public readonly ast: QueryAST.Query) {}\n\n  '~Query' = QueryClass.variance;\n\n  select(filter: Filter<any> | Filter.Props<any>): Query<any> {\n    if (Filter.is(filter)) {\n      return new QueryClass({\n        type: 'filter',\n        selection: this.ast,\n        filter: filter.ast,\n      });\n    } else {\n      return new QueryClass({\n        type: 'filter',\n        selection: this.ast,\n        filter: FilterClass._props(filter).ast,\n      });\n    }\n  }\n\n  reference(key: string): Query<any> {\n    return new QueryClass({\n      type: 'reference-traversal',\n      anchor: this.ast,\n      property: key,\n    });\n  }\n\n  referencedBy(target: Schema.Schema.All, key: string): Query<any> {\n    const dxn = getTypeReference(target)?.toDXN() ?? raise(new TypeError('Target schema has no DXN'));\n    return new QueryClass({\n      type: 'incoming-references',\n      anchor: this.ast,\n      property: key,\n      typename: dxn.toString(),\n    });\n  }\n\n  sourceOf(relation: Schema.Schema.All, predicates?: Filter.Props<unknown> | undefined): Query<any> {\n    return new QueryClass({\n      type: 'relation',\n      anchor: this.ast,\n      direction: 'outgoing',\n      filter: FilterClass.type(relation, predicates).ast,\n    });\n  }\n\n  targetOf(relation: Schema.Schema.All, predicates?: Filter.Props<unknown> | undefined): Query<any> {\n    return new QueryClass({\n      type: 'relation',\n      anchor: this.ast,\n      direction: 'incoming',\n      filter: FilterClass.type(relation, predicates).ast,\n    });\n  }\n\n  source(): Query<any> {\n    return new QueryClass({\n      type: 'relation-traversal',\n      anchor: this.ast,\n      direction: 'source',\n    });\n  }\n\n  target(): Query<any> {\n    return new QueryClass({\n      type: 'relation-traversal',\n      anchor: this.ast,\n      direction: 'target',\n    });\n  }\n\n  options(options: QueryAST.QueryOptions): Query<any> {\n    return new QueryClass({\n      type: 'options',\n      query: this.ast,\n      options,\n    });\n  }\n}\n\nexport const Query: QueryAPI = QueryClass;\n"],
  "mappings": "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",
  "names": ["import_invariant", "import_keys", "import_live_object", "import_util", "import_echo_schema", "import_effect", "import_debug", "getLabel", "getMeta", "getSchema", "isDeleted", "make", "schema", "props", "meta", "assertArgument", "getTypeAnnotation", "kind", "EntityKind", "Object", "MetaId", "live", "isObject", "obj", "assumeType", "EntityKindId", "instanceOf", "args", "length", "isInstanceOf", "getDXN", "Schema", "isSchema", "dxn", "getObjectDXN", "invariant", "getTypeDXN", "getType", "getTypename", "asTypeDXN", "type", "getSchemaTypename", "deleted", "toJSON", "objectToJSON", "fromJSON", "objectFromJSON", "Array", "RefArray", "isRef", "Ref", "fromDXN", "Source", "RelationSourceId", "Target", "RelationTargetId", "Relation", "sourceDXN", "raise", "Error", "targetDXN", "RelationSourceDXNId", "RelationTargetDXNId", "isRelation", "value", "ATTR_RELATION_SOURCE", "ATTR_RELATION_TARGET", "getSourceDXN", "DXN", "getTargetDXN", "getSource", "relation", "undefined", "id", "getTarget", "Expando", "ObjectId", "SpaceId", "isMutable", "KindId", "Obj", "EchoObject", "EchoRelation", "getSchemaDXN", "typename", "startsWith", "getVersion", "version", "getSchemaVersion", "match", "FilterClass", "variance", "is", "everything", "nothing", "filter", "ids", "every", "isValid", "Filter", "getTypeReference", "toDXN", "TypeError", "toString", "propsFilterToAst", "fromTypename", "typeDXN", "_props", "text", "options", "searchKind", "foreignKeys", "keys", "eq", "operator", "noInline", "encode", "neq", "gt", "gte", "lt", "lte", "in", "values", "between", "from", "to", "not", "ast", "and", "filters", "map", "f", "or", "predicates", "idFilter", "isArray", "pipe", "validateSync", "fromEntries", "entries", "prop", "_value", "predicate", "QueryClass", "select", "all", "queries", "q", "without", "source", "exclude", "selection", "reference", "key", "anchor", "property", "referencedBy", "target", "sourceOf", "direction", "targetOf", "query", "Query"]
}
