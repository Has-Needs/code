"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var chunk_4HQE2F3L_exports = {};
__export(chunk_4HQE2F3L_exports, {
  DXN: () => import_keys4.DXN,
  Filter: () => Filter,
  Key_exports: () => Key_exports,
  Obj_exports: () => Obj_exports,
  Query: () => Query,
  Ref_exports: () => Ref_exports,
  Relation_exports: () => Relation_exports,
  Type_exports: () => Type_exports
});
module.exports = __toCommonJS(chunk_4HQE2F3L_exports);
var import_keys = require("@dxos/keys");
var import_effect = require("effect");
var EchoSchema = __toESM(require("@dxos/echo-schema"));
var import_invariant = require("@dxos/invariant");
var import_live_object = require("@dxos/live-object");
var import_util = require("@dxos/util");
var EchoSchema2 = __toESM(require("@dxos/echo-schema"));
var import_debug = require("@dxos/debug");
var EchoSchema3 = __toESM(require("@dxos/echo-schema"));
var import_invariant2 = require("@dxos/invariant");
var import_keys2 = require("@dxos/keys");
var import_live_object2 = require("@dxos/live-object");
var import_util2 = require("@dxos/util");
var EchoSchema4 = __toESM(require("@dxos/echo-schema"));
var import_invariant3 = require("@dxos/invariant");
var import_echo_schema = require("@dxos/echo-schema");
var import_keys3 = require("@dxos/keys");
var import_echo_schema2 = require("@dxos/echo-schema");
var import_keys4 = require("@dxos/keys");
var import_effect2 = require("effect");
var import_debug2 = require("@dxos/debug");
var import_echo_schema3 = require("@dxos/echo-schema");
var import_invariant4 = require("@dxos/invariant");
var import_keys5 = require("@dxos/keys");
var __defProp2 = Object.defineProperty;
var __export2 = (target, all) => {
  for (var name in all)
    __defProp2(target, name, { get: all[name], enumerable: true });
};
var Key_exports = {};
__export2(Key_exports, {
  ObjectId: () => import_keys.ObjectId,
  SpaceId: () => import_keys.SpaceId
});
var Obj_exports = {};
__export2(Obj_exports, {
  fromJSON: () => fromJSON,
  getDXN: () => getDXN,
  getLabel: () => getLabel2,
  getMeta: () => getMeta2,
  getSchema: () => getSchema2,
  getTypeDXN: () => getTypeDXN,
  getTypename: () => getTypename,
  instanceOf: () => instanceOf,
  isDeleted: () => isDeleted2,
  isObject: () => isObject,
  make: () => make,
  toJSON: () => toJSON
});
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/core/echo/echo/src/Obj.ts";
var make = (schema, props, meta) => {
  (0, import_invariant.assertArgument)(EchoSchema.getTypeAnnotation(schema)?.kind === EchoSchema.EntityKind.Object, "Expected an object schema");
  if (props[EchoSchema.MetaId] != null) {
    meta = props[EchoSchema.MetaId];
    delete props[EchoSchema.MetaId];
  }
  return (0, import_live_object.live)(schema, props, meta);
};
var isObject = (obj) => {
  (0, import_util.assumeType)(obj);
  return typeof obj === "object" && obj !== null && obj[EchoSchema.EntityKindId] === EchoSchema.EntityKind.Object;
};
var instanceOf = (...args) => {
  if (args.length === 1) {
    return (obj) => EchoSchema.isInstanceOf(args[0], obj);
  }
  return EchoSchema.isInstanceOf(args[0], args[1]);
};
var getSchema2 = EchoSchema.getSchema;
var getDXN = (obj) => {
  (0, import_invariant.assertArgument)(!import_effect.Schema.isSchema(obj), "Object should not be a schema.");
  const dxn = EchoSchema.getObjectDXN(obj);
  (0, import_invariant.invariant)(dxn != null, "Invalid object.", {
    F: __dxlog_file,
    L: 96,
    S: void 0,
    A: [
      "dxn != null",
      "'Invalid object.'"
    ]
  });
  return dxn;
};
var getTypeDXN = EchoSchema.getType;
var getTypename = (obj) => {
  const schema = getSchema2(obj);
  if (schema == null) {
    return EchoSchema.getType(obj)?.asTypeDXN()?.type;
  }
  return EchoSchema.getSchemaTypename(schema);
};
var getMeta2 = (obj) => {
  const meta = EchoSchema.getMeta(obj);
  (0, import_invariant.invariant)(meta != null, "Invalid object.", {
    F: __dxlog_file,
    L: 124,
    S: void 0,
    A: [
      "meta != null",
      "'Invalid object.'"
    ]
  });
  return meta;
};
var isDeleted2 = (obj) => {
  const deleted = EchoSchema.isDeleted(obj);
  (0, import_invariant.invariant)(typeof deleted === "boolean", "Invalid object.", {
    F: __dxlog_file,
    L: 131,
    S: void 0,
    A: [
      "typeof deleted === 'boolean'",
      "'Invalid object.'"
    ]
  });
  return deleted;
};
var getLabel2 = (obj) => {
  const schema = getSchema2(obj);
  if (schema != null) {
    return EchoSchema.getLabel(schema, obj);
  }
};
var toJSON = (obj) => EchoSchema.objectToJSON(obj);
var fromJSON = EchoSchema.objectFromJSON;
var Ref_exports = {};
__export2(Ref_exports, {
  Array: () => Array2,
  fromDXN: () => fromDXN,
  isRef: () => isRef,
  make: () => make2
});
var Array2 = EchoSchema2.RefArray;
var isRef = EchoSchema2.Ref.isRef;
var make2 = EchoSchema2.Ref.make;
var fromDXN = EchoSchema2.Ref.fromDXN;
var Relation_exports = {};
__export2(Relation_exports, {
  Source: () => Source,
  Target: () => Target,
  getSource: () => getSource,
  getSourceDXN: () => getSourceDXN,
  getTarget: () => getTarget,
  getTargetDXN: () => getTargetDXN,
  isRelation: () => isRelation,
  make: () => make3
});
var __dxlog_file2 = "/home/runner/work/dxos/dxos/packages/core/echo/echo/src/Relation.ts";
var Source = EchoSchema3.RelationSourceId;
var Target = EchoSchema3.RelationTargetId;
var make3 = (schema, props, meta) => {
  (0, import_invariant2.assertArgument)(EchoSchema3.getTypeAnnotation(schema)?.kind === EchoSchema3.EntityKind.Relation, "Expected a relation schema");
  if (props[EchoSchema3.MetaId] != null) {
    meta = props[EchoSchema3.MetaId];
    delete props[EchoSchema3.MetaId];
  }
  const sourceDXN = EchoSchema3.getObjectDXN(props[Source]) ?? (0, import_debug.raise)(new Error("Unresolved relation source"));
  const targetDXN = EchoSchema3.getObjectDXN(props[Target]) ?? (0, import_debug.raise)(new Error("Unresolved relation target"));
  props[EchoSchema3.RelationSourceDXNId] = sourceDXN;
  props[EchoSchema3.RelationTargetDXNId] = targetDXN;
  return (0, import_live_object2.live)(schema, props, meta);
};
var isRelation = (value) => {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  if (EchoSchema3.ATTR_RELATION_SOURCE in value || EchoSchema3.ATTR_RELATION_TARGET in value) {
    return true;
  }
  const kind = value[EchoSchema3.EntityKindId];
  return kind === EchoSchema3.EntityKind.Relation;
};
var getSourceDXN = (value) => {
  (0, import_invariant2.assertArgument)(isRelation(value), "Expected a relation");
  (0, import_util2.assumeType)(value);
  const dxn = value[EchoSchema3.RelationSourceDXNId];
  (0, import_invariant2.invariant)(dxn instanceof import_keys2.DXN, void 0, {
    F: __dxlog_file2,
    L: 98,
    S: void 0,
    A: [
      "dxn instanceof DXN",
      ""
    ]
  });
  return dxn;
};
var getTargetDXN = (value) => {
  (0, import_invariant2.assertArgument)(isRelation(value), "Expected a relation");
  (0, import_util2.assumeType)(value);
  const dxn = value[EchoSchema3.RelationTargetDXNId];
  (0, import_invariant2.invariant)(dxn instanceof import_keys2.DXN, void 0, {
    F: __dxlog_file2,
    L: 110,
    S: void 0,
    A: [
      "dxn instanceof DXN",
      ""
    ]
  });
  return dxn;
};
var getSource = (relation) => {
  (0, import_invariant2.assertArgument)(isRelation(relation), "Expected a relation");
  (0, import_util2.assumeType)(relation);
  const obj = relation[EchoSchema3.RelationSourceId];
  (0, import_invariant2.invariant)(obj !== void 0, `Invalid source: ${relation.id}`, {
    F: __dxlog_file2,
    L: 122,
    S: void 0,
    A: [
      "obj !== undefined",
      "`Invalid source: ${relation.id}`"
    ]
  });
  return obj;
};
var getTarget = (relation) => {
  (0, import_invariant2.assertArgument)(isRelation(relation), "Expected a relation");
  (0, import_util2.assumeType)(relation);
  const obj = relation[EchoSchema3.RelationTargetId];
  (0, import_invariant2.invariant)(obj !== void 0, `Invalid target: ${relation.id}`, {
    F: __dxlog_file2,
    L: 134,
    S: void 0,
    A: [
      "obj !== undefined",
      "`Invalid target: ${relation.id}`"
    ]
  });
  return obj;
};
var Type_exports = {};
__export2(Type_exports, {
  DXN: () => import_keys3.DXN,
  Expando: () => Expando2,
  Format: () => import_echo_schema2.Format,
  JsonSchema: () => import_echo_schema2.JsonSchemaType,
  Kind: () => import_echo_schema.EntityKind,
  KindId: () => KindId,
  Obj: () => Obj,
  ObjectId: () => import_keys3.ObjectId,
  Ref: () => Ref3,
  Relation: () => Relation,
  SpaceId: () => import_keys3.SpaceId,
  getDXN: () => getDXN2,
  getMeta: () => getMeta3,
  getTypename: () => getTypename2,
  getVersion: () => getVersion,
  isMutable: () => isMutable2,
  toEffectSchema: () => import_echo_schema2.toEffectSchema,
  toJsonSchema: () => import_echo_schema2.toJsonSchema
});
var __dxlog_file3 = "/home/runner/work/dxos/dxos/packages/core/echo/echo/src/Type.ts";
var KindId = EchoSchema4.EntityKindId;
var Obj = EchoSchema4.EchoObject;
var Relation = EchoSchema4.EchoRelation;
var Ref3 = EchoSchema4.Ref;
var getDXN2 = (schema) => {
  return EchoSchema4.getSchemaDXN(schema);
};
var getTypename2 = (schema) => {
  const typename = EchoSchema4.getSchemaTypename(schema);
  (0, import_invariant3.invariant)(typeof typename === "string" && !typename.startsWith("dxn:"), "Invalid typename", {
    F: __dxlog_file3,
    L: 182,
    S: void 0,
    A: [
      "typeof typename === 'string' && !typename.startsWith('dxn:')",
      "'Invalid typename'"
    ]
  });
  return typename;
};
var getVersion = (schema) => {
  const version = EchoSchema4.getSchemaVersion(schema);
  (0, import_invariant3.invariant)(typeof version === "string" && version.match(/^\d+\.\d+\.\d+$/), "Invalid version", {
    F: __dxlog_file3,
    L: 192,
    S: void 0,
    A: [
      "typeof version === 'string' && version.match(/^\\d+\\.\\d+\\.\\d+$/)",
      "'Invalid version'"
    ]
  });
  return version;
};
var getMeta3 = (schema) => {
  return EchoSchema4.getTypeAnnotation(schema);
};
var isMutable2 = EchoSchema4.isMutable;
var Expando2 = EchoSchema4.Expando;
var FilterClass = class _FilterClass {
  static {
    this.variance = {};
  }
  static is(value) {
    return typeof value === "object" && value !== null && "~Filter" in value;
  }
  static everything() {
    return new _FilterClass({
      type: "object",
      typename: null,
      props: {}
    });
  }
  static nothing() {
    return new _FilterClass({
      type: "not",
      filter: {
        type: "object",
        typename: null,
        props: {}
      }
    });
  }
  static relation() {
    return new _FilterClass({
      type: "object",
      typename: null,
      props: {}
    });
  }
  static ids(...ids) {
    (0, import_invariant4.assertArgument)(ids.every((id) => import_keys5.ObjectId.isValid(id)), "ids must be valid");
    if (ids.length === 0) {
      return Filter.nothing();
    }
    return new _FilterClass({
      type: "object",
      typename: null,
      id: ids,
      props: {}
    });
  }
  static type(schema, props) {
    const dxn = (0, import_echo_schema3.getTypeReference)(schema)?.toDXN() ?? (0, import_debug2.raise)(new TypeError("Schema has no DXN"));
    return new _FilterClass({
      type: "object",
      typename: dxn.toString(),
      ...propsFilterToAst(props ?? {})
    });
  }
  static typename(typename) {
    (0, import_invariant4.assertArgument)(!typename.startsWith("dxn:"), "Typename must no be qualified");
    return new _FilterClass({
      type: "object",
      typename: import_keys5.DXN.fromTypename(typename).toString(),
      props: {}
    });
  }
  static typeDXN(dxn) {
    return new _FilterClass({
      type: "object",
      typename: dxn.toString(),
      props: {}
    });
  }
  /**
  * @internal
  */
  static _props(props) {
    return new _FilterClass({
      type: "object",
      typename: null,
      ...propsFilterToAst(props)
    });
  }
  static text(text, options) {
    return new _FilterClass({
      type: "text-search",
      text,
      searchKind: options?.type
    });
  }
  static foreignKeys(schema, keys) {
    const dxn = (0, import_echo_schema3.getTypeReference)(schema)?.toDXN() ?? (0, import_debug2.raise)(new TypeError("Schema has no DXN"));
    return new _FilterClass({
      type: "object",
      typename: dxn.toString(),
      props: {},
      foreignKeys: keys
    });
  }
  static eq(value) {
    if (!isRef(value) && typeof value === "object" && value !== null) {
      throw new TypeError("Cannot use object as a value for eq filter");
    }
    return new _FilterClass({
      type: "compare",
      operator: "eq",
      value: isRef(value) ? value.noInline().encode() : value
    });
  }
  static neq(value) {
    return new _FilterClass({
      type: "compare",
      operator: "neq",
      value
    });
  }
  static gt(value) {
    return new _FilterClass({
      type: "compare",
      operator: "gt",
      value
    });
  }
  static gte(value) {
    return new _FilterClass({
      type: "compare",
      operator: "gte",
      value
    });
  }
  static lt(value) {
    return new _FilterClass({
      type: "compare",
      operator: "lt",
      value
    });
  }
  static lte(value) {
    return new _FilterClass({
      type: "compare",
      operator: "lte",
      value
    });
  }
  static in(...values) {
    return new _FilterClass({
      type: "in",
      values
    });
  }
  static between(from, to) {
    return new _FilterClass({
      type: "range",
      from,
      to
    });
  }
  static not(filter) {
    return new _FilterClass({
      type: "not",
      filter: filter.ast
    });
  }
  static and(...filters) {
    return new _FilterClass({
      type: "and",
      filters: filters.map((f) => f.ast)
    });
  }
  static or(...filters) {
    return new _FilterClass({
      type: "or",
      filters: filters.map((f) => f.ast)
    });
  }
  constructor(ast) {
    this.ast = ast;
    this["~Filter"] = _FilterClass.variance;
  }
};
var Filter = FilterClass;
var propsFilterToAst = (predicates) => {
  let idFilter;
  if ("id" in predicates) {
    (0, import_invariant4.assertArgument)(typeof predicates.id === "string" || Array.isArray(predicates.id), "invalid id filter");
    idFilter = typeof predicates.id === "string" ? [
      predicates.id
    ] : predicates.id;
    import_effect2.Schema.Array(import_keys5.ObjectId).pipe(import_effect2.Schema.validateSync)(idFilter);
  }
  return {
    id: idFilter,
    props: Object.fromEntries(Object.entries(predicates).filter(([prop, _value]) => prop !== "id").map(([prop, predicate]) => [
      prop,
      Filter.is(predicate) ? predicate.ast : Filter.eq(predicate).ast
    ]))
  };
};
var QueryClass = class _QueryClass {
  static {
    this.variance = {};
  }
  static is(value) {
    return typeof value === "object" && value !== null && "~Query" in value;
  }
  static select(filter) {
    return new _QueryClass({
      type: "select",
      filter: filter.ast
    });
  }
  static type(schema, predicates) {
    return new _QueryClass({
      type: "select",
      filter: FilterClass.type(schema, predicates).ast
    });
  }
  static all(...queries) {
    if (queries.length === 0) {
      throw new TypeError("Query.all combines results of multiple queries, to query all objects use Query.select(Filter.everything())");
    }
    return new _QueryClass({
      type: "union",
      queries: queries.map((q) => q.ast)
    });
  }
  static without(source, exclude) {
    return new _QueryClass({
      type: "set-difference",
      source: source.ast,
      exclude: exclude.ast
    });
  }
  constructor(ast) {
    this.ast = ast;
    this["~Query"] = _QueryClass.variance;
  }
  select(filter) {
    if (Filter.is(filter)) {
      return new _QueryClass({
        type: "filter",
        selection: this.ast,
        filter: filter.ast
      });
    } else {
      return new _QueryClass({
        type: "filter",
        selection: this.ast,
        filter: FilterClass._props(filter).ast
      });
    }
  }
  reference(key) {
    return new _QueryClass({
      type: "reference-traversal",
      anchor: this.ast,
      property: key
    });
  }
  referencedBy(target, key) {
    const dxn = (0, import_echo_schema3.getTypeReference)(target)?.toDXN() ?? (0, import_debug2.raise)(new TypeError("Target schema has no DXN"));
    return new _QueryClass({
      type: "incoming-references",
      anchor: this.ast,
      property: key,
      typename: dxn.toString()
    });
  }
  sourceOf(relation, predicates) {
    return new _QueryClass({
      type: "relation",
      anchor: this.ast,
      direction: "outgoing",
      filter: FilterClass.type(relation, predicates).ast
    });
  }
  targetOf(relation, predicates) {
    return new _QueryClass({
      type: "relation",
      anchor: this.ast,
      direction: "incoming",
      filter: FilterClass.type(relation, predicates).ast
    });
  }
  source() {
    return new _QueryClass({
      type: "relation-traversal",
      anchor: this.ast,
      direction: "source"
    });
  }
  target() {
    return new _QueryClass({
      type: "relation-traversal",
      anchor: this.ast,
      direction: "target"
    });
  }
  options(options) {
    return new _QueryClass({
      type: "options",
      query: this.ast,
      options
    });
  }
};
var Query = QueryClass;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  DXN,
  Filter,
  Key_exports,
  Obj_exports,
  Query,
  Ref_exports,
  Relation_exports,
  Type_exports
});
//# sourceMappingURL=chunk-4HQE2F3L.cjs.map
