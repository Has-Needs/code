import { Schema } from 'effect';
import type { Simplify } from 'effect/Schema';
import { type ForeignKey, type QueryAST } from '@dxos/echo-protocol';
import { DXN, ObjectId } from '@dxos/keys';
import * as Ref from '../Ref';
import type * as Type from '../Type';
export interface Query<T> {
    '~Query': {
        value: T;
    };
    ast: QueryAST.Query;
    /**
     * Filter the current selection based on a filter.
     * @param filter - Filter to select the objects.
     * @returns Query for the selected objects.
     */
    select(filter: Filter<T>): Query<T>;
    select(props: Filter.Props<T>): Query<T>;
    /**
     * Traverse an outgoing reference.
     * @param key - Property path inside T that is a reference.
     * @returns Query for the target of the reference.
     */
    reference<K extends RefPropKey<T>>(key: K): Query<T[K] extends Ref.Any ? Ref.Target<T[K]> : never>;
    /**
     * Find objects referencing this object.
     * @param target - Schema of the referencing object.
     * @param key - Property path inside the referencing object that is a reference.
     * @returns Query for the referencing objects.
     */
    referencedBy<S extends Schema.Schema.All>(target: S, key: RefPropKey<Schema.Schema.Type<S>>): Query<Schema.Schema.Type<S>>;
    /**
     * Find relations where this object is the source.
     * @returns Query for the relation objects.
     * @param relation - Schema of the relation.
     * @param predicates - Predicates to filter the relation objects.
     */
    sourceOf<S extends Schema.Schema.All>(relation: S, predicates?: Filter.Props<Schema.Schema.Type<S>>): Query<Schema.Schema.Type<S>>;
    /**
     * Find relations where this object is the target.
     * @returns Query for the relation objects.
     * @param relation - Schema of the relation.
     * @param predicates - Predicates to filter the relation objects.
     */
    targetOf<S extends Schema.Schema.All>(relation: S, predicates?: Filter.Props<Schema.Schema.Type<S>>): Query<Schema.Schema.Type<S>>;
    /**
     * For a query for relations, get the source objects.
     * @returns Query for the source objects.
     */
    source(): Query<Type.Relation.Source<T>>;
    /**
     * For a query for relations, get the target objects.
     * @returns Query for the target objects.
     */
    target(): Query<Type.Relation.Target<T>>;
    /**
     * Add options to a query.
     */
    options(options: QueryAST.QueryOptions): Query<T>;
}
interface QueryAPI {
    is(value: unknown): value is Query.Any;
    /**
     * Select objects based on a filter.
     * @param filter - Filter to select the objects.
     * @returns Query for the selected objects.
     */
    select<F extends Filter.Any>(filter: F): Query<Filter.Type<F>>;
    /**
     * Query for objects of a given schema.
     * @param schema - Schema of the objects.
     * @param predicates - Predicates to filter the objects.
     * @returns Query for the objects.
     *
     * Shorthand for: `Query.select(Filter.type(schema, predicates))`.
     */
    type<S extends Schema.Schema.All>(schema: S, predicates?: Filter.Props<Schema.Schema.Type<S>>): Query<Schema.Schema.Type<S>>;
    /**
     * Combine results of multiple queries.
     * @param queries - Queries to combine.
     * @returns Query for the combined results.
     */
    all<T>(...queries: Query<T>[]): Query<T>;
    /**
     * Subtract one query from another.
     * @param source - Query to subtract from.
     * @param exclude - Query to subtract.
     * @returns Query for the results of the source query minus the results of the exclude query.
     */
    without<T>(source: Query<T>, exclude: Query<T>): Query<T>;
}
export declare namespace Query {
    type Any = Query<any>;
    type Type<Q extends Any> = Q extends Query<infer T> ? T : never;
    type TextSearchOptions = {
        type?: 'full-text' | 'vector';
    };
}
export interface Filter<T> {
    '~Filter': {
        value: T;
    };
    ast: QueryAST.Filter;
}
type Intersection<Types extends readonly unknown[]> = Types extends [infer First, ...infer Rest] ? First & Intersection<Rest> : unknown;
interface FilterAPI {
    is(value: unknown): value is Filter<any>;
    /**
     * Filter that matches all objects.
     */
    everything(): Filter<any>;
    /**
     * Filter that matches no objects.
     */
    nothing(): Filter<any>;
    /**
     * Filter by object IDs.
     */
    ids(...id: ObjectId[]): Filter<any>;
    /**
     * Filter by type.
     */
    type<S extends Schema.Schema.All>(schema: S, props?: Filter.Props<Schema.Schema.Type<S>>): Filter<Schema.Schema.Type<S>>;
    /**
     * Filter by non-qualified typename.
     */
    typename(typename: string): Filter<any>;
    /**
     * Filter by fully qualified type DXN.
     */
    typeDXN(dxn: DXN): Filter<any>;
    /**
     * Filter by properties.
     *
     * INTERNAL API: Do not use.
     */
    _props<T>(props: Filter.Props<T>): Filter<T>;
    /**
     * Full-text or vector search.
     */
    text(text: string, options?: Query.TextSearchOptions): Filter<any>;
    /**
     * Filter by foreign keys.
     */
    foreignKeys<S extends Schema.Schema.All>(schema: S, keys: ForeignKey[]): Filter<Schema.Schema.Type<S>>;
    /**
     * Predicate for property to be equal to the provided value.
     */
    eq<T>(value: T): Filter<T>;
    /**
     * Predicate for property to be not equal to the provided value.
     */
    neq<T>(value: T): Filter<T>;
    /**
     * Predicate for property to be greater than the provided value.
     */
    gt<T>(value: T): Filter<T>;
    /**
     * Predicate for property to be greater than the provided value.
     */
    gt<T>(value: T): Filter<T>;
    /**
     * Predicate for property to be greater than or equal to the provided value.
     */
    gte<T>(value: T): Filter<T>;
    /**
     * Predicate for property to be less than the provided value.
     */
    lt<T>(value: T): Filter<T>;
    /**
     * Predicate for property to be less than or equal to the provided value.
     */
    lte<T>(value: T): Filter<T>;
    /**
     * Predicate for property to be in the provided array.
     * @param values - Values to check against.
     */
    in<T>(...values: T[]): Filter<T>;
    /**
     * Predicate for property to be in the provided range.
     * @param from - Start of the range (inclusive).
     * @param to - End of the range (exclusive).
     */
    between<T>(from: T, to: T): Filter<T>;
    /**
     * Negate the filter.
     */
    not<F extends Filter.Any>(filter: F): Filter<Filter.Type<F>>;
    /**
     * Combine filters with a logical AND.
     */
    and<FS extends Filter.Any[]>(...filters: FS): Filter<Filter.And<FS>>;
    /**
     * Combine filters with a logical OR.
     */
    or<FS extends Filter.Any[]>(...filters: FS): Filter<Filter.Or<FS>>;
}
export declare namespace Filter {
    type Props<T> = {
        [K in keyof T & string]?: Filter<T[K]> | T[K];
    };
    type Any = Filter<any>;
    type Type<F extends Any> = F extends Filter<infer T> ? T : never;
    type And<FS extends readonly Any[]> = Simplify<Intersection<{
        [K in keyof FS]: Type<FS[K]>;
    }>>;
    type Or<FS extends readonly Any[]> = Simplify<{
        [K in keyof FS]: Type<FS[K]>;
    }[number]>;
}
export declare const Filter: FilterAPI;
/**
 * All property paths inside T that are references.
 */
type RefPropKey<T> = keyof T & string;
export declare const Query: QueryAPI;
export {};
//# sourceMappingURL=dsl.d.ts.map