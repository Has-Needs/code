import * as EchoSchema from '@dxos/echo-schema';
import type * as Obj from './Obj';
export type Ref<T> = EchoSchema.Ref<T>;
export type Any = EchoSchema.Ref<Obj.Any>;
export declare const Array: Readonly<{
    targets: <T extends EchoSchema.AnyEchoObject>(refs: EchoSchema.Ref<T>[]) => T[];
    loadAll: <T extends EchoSchema.AnyEchoObject>(refs: EchoSchema.Ref<T>[]) => Promise<T[]>;
    removeById: (refs: EchoSchema.Ref<EchoSchema.AnyEchoObject>[], id: EchoSchema.ObjectId) => void;
}>;
/**
 * Extract reference target.
 */
export type Target<R extends Any> = R extends EchoSchema.Ref<infer T> ? T : never;
/**
 * Reference resolver.
 */
export type Resolver = EchoSchema.RefResolver;
export declare const isRef: (value: unknown) => value is Any;
export declare const make: <T extends EchoSchema.WithId>(object: T) => EchoSchema.Ref<T>;
export declare const fromDXN: (dxn: import("@dxos/keys").DXN) => EchoSchema.Ref<any>;
//# sourceMappingURL=Ref.d.ts.map