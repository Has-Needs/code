import { Schema } from 'effect';
import * as EchoSchema from '@dxos/echo-schema';
import { type DXN } from '@dxos/keys';
import type * as LiveObject from '@dxos/live-object';
import type * as Ref from './Ref';
import type * as Relation from './Relation';
import type * as Type from './Type';
interface ObjBase extends Type.OfKind<EchoSchema.EntityKind.Object> {
    readonly id: EchoSchema.ObjectId;
}
/**
 * Object type with specific properties.
 */
export type Obj<Props> = ObjBase & Props;
/**
 * Base type for all ECHO objects.
 */
export interface Any extends ObjBase {
}
type MakeProps<T> = {
    id?: EchoSchema.ObjectId;
} & Type.Properties<T>;
/**
 * Creates new object.
 */
export declare const make: <S extends Type.Obj.Any>(schema: S, props: NoInfer<MakeProps<Schema.Schema.Type<S>>>, meta?: EchoSchema.ObjectMeta) => LiveObject.Live<Schema.Schema.Type<S>>;
export declare const isObject: (obj: unknown) => obj is Any;
/**
 * Test if object or relation is an instance of a schema.
 * @example
 * ```ts
 * const john = Obj.make(Person, { name: 'John' });
 * const johnIsPerson = Obj.instanceOf(Person)(john);
 *
 * const isPerson = Obj.instanceOf(Person);
 * if(isPerson(john)) {
 *   // john is Person
 * }
 * ```
 */
export declare const instanceOf: {
    <S extends Type.Relation.Any | Type.Obj.Any>(schema: S): (value: unknown) => value is Schema.Schema.Type<S>;
    <S extends Type.Relation.Any | Type.Obj.Any>(schema: S, value: unknown): value is Schema.Schema.Type<S>;
};
export declare const getSchema: (obj: unknown | undefined) => Schema.Schema.AnyNoContext | undefined;
export declare const getDXN: (obj: Any) => DXN;
/**
 * @returns The DXN of the object's type.
 * @example dxn:example.com/type/Contact:1.0.0
 */
export declare const getTypeDXN: (obj: EchoSchema.BaseObject) => DXN | undefined;
/**
 * @returns The typename of the object's type.
 * @example `example.com/type/Contact`
 */
export declare const getTypename: (obj: Any) => string | undefined;
export declare const getMeta: (obj: Any) => EchoSchema.ObjectMeta;
export declare const isDeleted: (obj: Any) => boolean;
export declare const getLabel: (obj: Any) => string | undefined;
/**
 * JSON representation of an object.
 */
export type JSON = EchoSchema.ObjectJSON;
/**
 * Converts object to its JSON representation.
 *
 * The same algorithm is used when calling the standard `JSON.stringify(obj)` function.
 */
export declare const toJSON: (obj: Any | Relation.Any) => JSON;
/**
 * Creates an object from its json representation, performing schema validation.
 * References and schemas will be resolvable if the `refResolver` is provided.
 *
 * The function need to be async to support resolving the schema as well as the relation endpoints.
 */
export declare const fromJSON: (json: unknown, options?: {
    refResolver?: Ref.Resolver;
}) => Promise<Any>;
export {};
//# sourceMappingURL=Obj.d.ts.map