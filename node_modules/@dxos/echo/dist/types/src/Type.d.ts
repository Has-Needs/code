import { type Schema } from 'effect';
import type { Simplify } from 'effect/Schema';
import type { EncodedReference } from '@dxos/echo-protocol';
import * as EchoSchema from '@dxos/echo-schema';
import type { ToMutable } from '@dxos/echo-schema';
import type * as Keys from '@dxos/keys';
import type * as RelationModule from './Relation';
export declare const KindId: unique symbol;
export type KindId = typeof KindId;
export { EntityKind as Kind } from '@dxos/echo-schema';
/**
 * Assigns a kind to an Object or Relation instance.
 */
export interface OfKind<Kind extends EchoSchema.EntityKind> {
    readonly id: Keys.ObjectId;
    readonly [KindId]: Kind;
}
interface ObjJsonProps {
    id: string;
}
interface RelationJsonProps {
    id: string;
    [EchoSchema.ATTR_RELATION_SOURCE]: string;
    [EchoSchema.ATTR_RELATION_TARGET]: string;
}
/**
 * Returns all properties of an object or relation except for the id and kind.
 */
export type Properties<T> = Omit<T, 'id' | KindId | RelationModule.Source | RelationModule.Target>;
/**
 * Base ECHO schema type.
 */
export type Schema = EchoSchema.EchoSchema;
/**
 * Return type of the `Obj` schema constructor.
 *
 * This typedef avoids `TS4023` error (name from external module cannot be used named).
 * See Effect's note on interface types.
 */
export interface obj<Self extends Schema.Schema.Any> extends Schema.AnnotableClass<obj<Self>, OfKind<EchoSchema.EntityKind.Object> & ToMutable<Schema.Schema.Type<Self>>, Simplify<ObjJsonProps & ToMutable<Schema.Schema.Encoded<Self>>>, Schema.Schema.Context<Self>>, EchoSchema.TypeMeta {
}
/**
 * Object schema.
 */
export declare const Obj: {
    (opts: EchoSchema.TypeMeta): <Self extends Schema.Schema.Any>(self: Self) => obj<Self>;
};
/**
 * Object schema type definitions.
 */
export declare namespace Obj {
    /**
     * Type that represents an arbitrary schema type of an object.
     * NOTE: This is not an instance type.
     */
    type Any = Schema.Schema.AnyNoContext;
}
/**
 * Return type of the `Relation` schema constructor.
 *
 * This typedef avoids `TS4023` error (name from external module cannot be used named).
 * See Effect's note on interface types.
 */
export interface relation<Self extends Schema.Schema.Any, SourceSchema extends Schema.Schema.Any, TargetSchema extends Schema.Schema.Any> extends Schema.AnnotableClass<relation<Self, SourceSchema, TargetSchema>, OfKind<EchoSchema.EntityKind.Relation> & Relation.Endpoints<Schema.Schema.Type<SourceSchema>, Schema.Schema.Type<TargetSchema>> & ToMutable<Schema.Schema.Type<Self>>, Simplify<RelationJsonProps & ToMutable<Schema.Schema.Encoded<Self>>>, Schema.Schema.Context<Self>>, EchoSchema.TypeMeta {
}
/**
 * Relation schema.
 */
export declare const Relation: {
    <Source extends Schema.Schema.AnyNoContext, Target extends Schema.Schema.AnyNoContext>(opts: EchoSchema.EchoRelationOptions<Source, Target>): <Self extends Schema.Schema.Any>(self: Self) => relation<Self, Source, Target>;
};
/**
 * Relation schema type definitions.
 */
export declare namespace Relation {
    /**
     * Type that represents an arbitrary schema type of a relation.
     * NOTE: This is not an instance type.
     */
    type Any = Schema.Schema.AnyNoContext;
    /**
     * Get relation target type.
     */
    type Target<A> = A extends Relation.Endpoints<infer _S, infer T> ? T : never;
    /**
     * Get relation source type.
     */
    type Source<A> = A extends Relation.Endpoints<infer S, infer _T> ? S : never;
    type Endpoints<Source, Target> = {
        [RelationModule.Source]: Source;
        [RelationModule.Target]: Target;
    };
}
/**
 * Return type of the `Ref` schema constructor.
 *
 * This typedef avoids `TS4023` error (name from external module cannot be used named).
 * See Effect's note on interface types.
 */
export interface ref<TargetSchema extends Schema.Schema.Any> extends EchoSchema.Ref$<Schema.Schema.Type<TargetSchema>> {
}
/**
 * Ref schema.
 */
export declare const Ref: <S extends Obj.Any>(schema: S) => ref<S>;
export interface Ref<T> extends Schema.SchemaClass<EchoSchema.Ref<T>, EncodedReference> {
}
export declare namespace Ref {
    /**
     * Type that represents an arbitrary schema type of a reference.
     * NOTE: This is not an instance type.
     */
    type Any = Schema.Schema<EchoSchema.Ref<any>, EncodedReference>;
}
/**
 * Gets the full DXN of the schema.
 * Will include the version if it's a `type` DXN.
 * @example "dxn:example.com/type/Person:0.1.0"
 * @example "dxn:echo:SSSSSSSSSS:XXXXXXXXXXXXX"
 */
export declare const getDXN: (schema: Obj.Any | Relation.Any) => Keys.DXN | undefined;
/**
 * @param schema - Schema to get the typename from.
 * @returns The typename of the schema. Example: `example.com/type/Person`.
 */
export declare const getTypename: (schema: Obj.Any | Relation.Any) => string;
/**
 * Gets the version of the schema.
 * @example 0.1.0
 */
export declare const getVersion: (schema: Obj.Any | Relation.Any) => string;
/**
 * ECHO type metadata.
 */
export type Meta = EchoSchema.TypeAnnotation;
/**
 * Gets the meta data of the schema.
 */
export declare const getMeta: (schema: Obj.Any | Relation.Any) => Meta | undefined;
/**
 * @returns True if the schema is mutable.
 */
export declare const isMutable: (schema: Schema.Schema.AnyNoContext) => schema is EchoSchema.EchoSchema;
export { SpaceId, ObjectId, DXN } from '@dxos/keys';
export interface Expando extends OfKind<EchoSchema.EntityKind.Object> {
    [key: string]: any;
}
export declare const Expando: Schema.Schema<Expando, Simplify<ObjJsonProps & {
    [key: string]: any;
}>, never>;
export { Format, JsonSchemaType as JsonSchema, toEffectSchema, toJsonSchema, } from '@dxos/echo-schema';
//# sourceMappingURL=Type.d.ts.map