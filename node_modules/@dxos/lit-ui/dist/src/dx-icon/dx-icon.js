//
// Copyright 2025 DXOS.org
//
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { svg, LitElement } from 'lit';
import { customElement, property } from 'lit/decorators.js';
const ICONS_URL = '/icons.svg';
let DxIcon = class DxIcon extends LitElement {
    constructor() {
        super(...arguments);
        // TODO(thure): Get Hue type used in theme.
        this.size = 4;
        this.icon = 'ph--placeholder--regular';
        this.noCache = true;
    }
    render() {
        const url = this.noCache ? `${ICONS_URL}?nocache=${new Date().getMinutes()}` : ICONS_URL;
        const href = `${url}#${this.icon}`;
        return svg `<svg class="dx-icon" data-size=${this.size}><use href=${href} /></svg>`;
    }
    createRenderRoot() {
        return this;
    }
};
__decorate([
    property({ type: String })
], DxIcon.prototype, "size", void 0);
__decorate([
    property({ type: String })
], DxIcon.prototype, "icon", void 0);
__decorate([
    property({ type: Boolean })
], DxIcon.prototype, "noCache", void 0);
DxIcon = __decorate([
    customElement('dx-icon')
], DxIcon);
export { DxIcon };
//# sourceMappingURL=dx-icon.js.map