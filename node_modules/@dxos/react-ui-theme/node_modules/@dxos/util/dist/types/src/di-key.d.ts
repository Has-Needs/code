import { inspect } from 'node:util';
export declare const symbolSingleton: unique symbol;
export type SingletonFactory<T> = () => T;
export declare class SymbolDiKey<T> {
    symbol: symbol;
    constructor(name: string);
    [symbolSingleton]?: SingletonFactory<T>;
    toString(): string;
    [inspect.custom](): string;
}
export type ConstructorDiKey<T> = {
    new (...args: any[]): T;
    [symbolSingleton]?: SingletonFactory<T>;
};
/**
 * Represents a key for an entry in a DI container.
 * Class constructors can be used as is.
 * Multiple keys can be combined into a single key to represent parameterized types.
 * Composite keys maintain referential equality.
 * Keys can optionally have a singleton factory attached to them.
 */
export type DiKey<T> = {
    new (...args: any[]): T;
} | SymbolDiKey<T>;
export declare const DiKey: {
    /**
     * Needed to ensure referential equality of combined keys.
     *
     * This is a multilevel map of maps, where the maps are also used as keys.
     *
     * Good luck :)
     */
    "__#50@#combinedRegistry": WeakMap<WeakKey, any>;
    define<T>(name: string): DiKey<T>;
    singleton<T>(name: string, factory: SingletonFactory<T>): DiKey<T>;
    stringify(id: DiKey<any>): string;
    /**
     * Create composite keys to represent parameterized types.
     *
     * @example DiKey.combine(A, B, C) => "A<B, C>"
     *
     * Maintains referential equality: `DiKey.combine(A, B) === DiKey.combine(A, B)`
     */
    combine(...ids: DiKey<any>[]): any;
    getSingletonFactory<T>(id: DiKey<T>): SingletonFactory<T> | undefined;
    "__#50@#lookupCombined"(map: WeakMap<any, any>, [first, ...rest]: DiKey<any>[]): WeakMap<any, any>;
    "__#50@#combinedDescription"([first, ...rest]: DiKey<any>[]): string;
};
//# sourceMappingURL=di-key.d.ts.map