import { createRequire } from 'node:module';const require = createRequire(import.meta.url);
import {
  ATTR_DELETED,
  ATTR_META,
  ATTR_RELATION_SOURCE,
  ATTR_RELATION_TARGET,
  ATTR_SELF_DXN,
  ATTR_TYPE,
  DeletedId,
  EXPANDO_TYPENAME,
  EchoObject,
  EchoRelation,
  EntityKind,
  EntityKindId,
  EntityKindSchema,
  Expando,
  FIELD_PATH_ANNOTATION,
  FieldLookupAnnotationId,
  FieldPath,
  GeneratorAnnotation,
  GeneratorAnnotationId,
  JSON_SCHEMA_ECHO_REF_ID,
  LabelAnnotation,
  LabelAnnotationId,
  MetaId,
  ObjectMetaSchema,
  PropertyMeta,
  PropertyMetaAnnotationId,
  Ref,
  RefArray,
  RefImpl,
  RefTypeId,
  ReferenceAnnotationId,
  RelationSourceDXNId,
  RelationSourceId,
  RelationTargetDXNId,
  RelationTargetId,
  SchemaId,
  SchemaMetaSymbol,
  SchemaValidator,
  SelfDXNId,
  StaticRefResolver,
  TypeAnnotation,
  TypeAnnotationId,
  TypeId,
  TypeIdentifierAnnotationId,
  TypedObject,
  TypedRelation,
  Typename,
  Version,
  assertObjectModelShape,
  attachTypedJsonSerializer,
  checkIdNotPresentOnSchema,
  compareForeignKeys,
  create,
  createAnnotationHelper,
  createEchoReferenceSchema,
  createQueueDXN,
  createSchemaReference,
  defineHiddenProperty,
  foreignKey,
  foreignKeyEquals,
  getEntityKind,
  getLabel,
  getLabelForObject,
  getMeta,
  getObjectDXN,
  getObjectMeta,
  getPropertyMetaAnnotation,
  getRefSavedTarget,
  getReferenceAnnotation,
  getSchema,
  getSchemaDXN,
  getSchemaReference,
  getSchemaTypename,
  getSchemaVersion,
  getType,
  getTypeAnnotation,
  getTypeIdentifierAnnotation,
  getTypename,
  isDeleted,
  makeTypedEntityClass,
  objectFromJSON,
  objectToJSON,
  refFromEncodedReference,
  setRefResolver,
  setSchema,
  setTypename
} from "./chunk-54NDCEXR.mjs";

// packages/core/echo/echo-schema/src/index.ts
import { JsonPath as JsonPath2, splitJsonPath as splitJsonPath2, JsonProp } from "@dxos/effect";
import { ObjectId as ObjectId2 } from "@dxos/keys";
import { ForeignKey } from "@dxos/echo-protocol";

// packages/core/echo/echo-schema/src/formats/number.ts
import { Schema } from "effect";

// packages/core/echo/echo-schema/src/formats/types.ts
import { Option, SchemaAST, pipe } from "effect";
var TypeEnum = /* @__PURE__ */ function(TypeEnum2) {
  TypeEnum2["Array"] = "array";
  TypeEnum2["Object"] = "object";
  TypeEnum2["String"] = "string";
  TypeEnum2["Number"] = "number";
  TypeEnum2["Boolean"] = "boolean";
  TypeEnum2["Ref"] = "ref";
  return TypeEnum2;
}({});
var getTypeEnum = (property) => {
  switch (property.type) {
    case "array":
      return "array";
    case "object":
      return "object";
    case "string":
      return "string";
    case "number":
      return "number";
    case "boolean":
      return "boolean";
    default:
      return void 0;
  }
};
var FormatAnnotationId = Symbol.for("@dxos/schema/annotation/Format");
var FormatAnnotation = createAnnotationHelper(FormatAnnotationId);
var getFormatAnnotation = (node) => pipe(SchemaAST.getAnnotation(FormatAnnotationId)(node), Option.getOrUndefined);
var FormatEnum = /* @__PURE__ */ function(FormatEnum2) {
  FormatEnum2["None"] = "none";
  FormatEnum2["String"] = "string";
  FormatEnum2["Number"] = "number";
  FormatEnum2["Boolean"] = "boolean";
  FormatEnum2["Ref"] = "ref";
  FormatEnum2["DID"] = "did";
  FormatEnum2["DXN"] = "dxn";
  FormatEnum2["Email"] = "email";
  FormatEnum2["Formula"] = "formula";
  FormatEnum2["Hostname"] = "hostname";
  FormatEnum2["JSON"] = "json";
  FormatEnum2["Markdown"] = "markdown";
  FormatEnum2["Regex"] = "regex";
  FormatEnum2["SingleSelect"] = "single-select";
  FormatEnum2["MultiSelect"] = "multi-select";
  FormatEnum2["URL"] = "url";
  FormatEnum2["UUID"] = "uuid";
  FormatEnum2["Currency"] = "currency";
  FormatEnum2["Integer"] = "integer";
  FormatEnum2["Percent"] = "percent";
  FormatEnum2["Timestamp"] = "timestamp";
  FormatEnum2["DateTime"] = "date-time";
  FormatEnum2["Date"] = "date";
  FormatEnum2["Time"] = "time";
  FormatEnum2["Duration"] = "duration";
  FormatEnum2["GeoPoint"] = "latlng";
  return FormatEnum2;
}({});
var FormatEnums = Object.values(FormatEnum).sort();
var PropertyKind = {
  type: TypeEnum,
  format: FormatEnum
};
var typeToFormat = {
  ["string"]: "string",
  ["number"]: "number",
  ["boolean"]: "boolean"
};
var formatToType = {
  ["none"]: void 0,
  ["string"]: "string",
  ["number"]: "number",
  ["boolean"]: "boolean",
  ["ref"]: "ref",
  ["did"]: "string",
  ["dxn"]: "string",
  ["email"]: "string",
  ["formula"]: "string",
  ["hostname"]: "string",
  ["json"]: "string",
  ["markdown"]: "string",
  ["regex"]: "string",
  ["url"]: "string",
  ["uuid"]: "string",
  ["single-select"]: "string",
  ["multi-select"]: "object",
  ["date"]: "string",
  ["date-time"]: "string",
  ["duration"]: "string",
  ["time"]: "string",
  ["currency"]: "number",
  ["integer"]: "number",
  ["percent"]: "number",
  ["timestamp"]: "number",
  ["latlng"]: "object"
};
var OptionsAnnotationId = Symbol.for("@dxos/schema/annotation/Options");
var getOptionsAnnotation = (node) => pipe(SchemaAST.getAnnotation(OptionsAnnotationId)(node), Option.getOrUndefined);

// packages/core/echo/echo-schema/src/formats/number.ts
var encodeMultipleOf = (divisor) => 1 / Math.pow(10, divisor);
var encodeMultiple = (divisor) => (self) => divisor === void 0 || divisor === 0 ? self : self.pipe(Schema.multipleOf(encodeMultipleOf(divisor)));
var DecimalPrecision = Schema.transform(Schema.Number, Schema.Number, {
  strict: true,
  encode: (value) => encodeMultipleOf(value),
  decode: (value) => Math.log10(1 / value)
}).annotations({
  title: "Number of digits"
});
var CurrencyAnnotationId = Symbol.for("@dxos/schema/annotation/Currency");
var Currency = ({ decimals, code } = {
  decimals: 2
}) => Schema.Number.pipe(encodeMultiple(decimals), FormatAnnotation.set(FormatEnum.Currency), Schema.annotations({
  title: "Currency",
  description: "Currency value",
  ...code ? {
    [CurrencyAnnotationId]: code.toUpperCase()
  } : {}
}));
var Integer = () => Schema.Number.pipe(Schema.int(), FormatAnnotation.set(FormatEnum.Integer), Schema.annotations({
  title: "Integer",
  description: "Integer value"
}));
var Percent = ({ decimals } = {
  decimals: 2
}) => Schema.Number.pipe(encodeMultiple(decimals), FormatAnnotation.set(FormatEnum.Percent), Schema.annotations({
  title: "Percent",
  description: "Percentage value"
}));
var Timestamp = Schema.Number.pipe(FormatAnnotation.set(FormatEnum.Timestamp), Schema.annotations({
  title: "Timestamp",
  description: "Unix timestamp"
}));

// packages/core/echo/echo-schema/src/formats/object.ts
import { Schema as Schema2 } from "effect";
import { clamp } from "@dxos/util";
var GeoPoint = Schema2.Tuple(Schema2.Number.pipe(Schema2.clamp(-180, 180), Schema2.multipleOf(1e-5)).annotations({
  title: "Longitude"
}), Schema2.Number.pipe(Schema2.clamp(-90, 90), Schema2.multipleOf(1e-5)).annotations({
  title: "Latitude"
}), Schema2.optionalElement(Schema2.Number).annotations({
  title: "Height ASL (m)"
})).pipe(FormatAnnotation.set(FormatEnum.GeoPoint), Schema2.annotations({
  title: "GeoPoint",
  description: "GeoJSON Position"
}));
(function(GeoLocation2) {
  GeoLocation2.toGeoPoint = ({ longitude, latitude, height }) => {
    const clampedLongitude = clamp(longitude, -180, 180);
    const clampedLatitude = clamp(latitude, -90, 90);
    return height !== void 0 ? [
      clampedLongitude,
      clampedLatitude,
      height
    ] : [
      clampedLongitude,
      clampedLatitude
    ];
  };
  GeoLocation2.fromGeoPoint = (geoPoint) => {
    if (!geoPoint) {
      return {
        longitude: 0,
        latitude: 0
      };
    }
    const result = {
      longitude: geoPoint[0],
      latitude: geoPoint[1]
    };
    if (geoPoint[2] !== void 0) {
      result.height = geoPoint[2];
    }
    return result;
  };
})(GeoLocation || (GeoLocation = {}));
var GeoLocation;

// packages/core/echo/echo-schema/src/formats/format.ts
import { Schema as Schema5 } from "effect";
import * as Keys from "@dxos/keys";

// packages/core/echo/echo-schema/src/formats/date.ts
import { Schema as Schema3, SchemaAST as SchemaAST2 } from "effect";
var SimpleDate = Schema3.Struct({
  year: Schema3.Number.pipe(Schema3.between(1900, 9999)),
  month: Schema3.Number.pipe(Schema3.between(1, 12)),
  day: Schema3.Number.pipe(Schema3.between(1, 31))
});
var SimpleTime = Schema3.Struct({
  hours: Schema3.Number.pipe(Schema3.between(0, 23)),
  minutes: Schema3.Number.pipe(Schema3.between(0, 59)),
  seconds: Schema3.Number.pipe(Schema3.between(0, 59))
});
var SimpleDateTime = Schema3.extend(SimpleDate, SimpleTime);
var DateOnly = (
  /* Schema.transformOrFail(Schema.String, SimpleDate, {
    strict: true,
    decode: (str, _, ast) => {
      if (!isValidDateFormat(str)) {
        return ParseResult.fail(new ParseResult.Type(ast, str, 'Expected YYYY-MM-DD format'));
      }
      if (!isValidDate(str)) {
        return ParseResult.fail(new ParseResult.Type(ast, str, 'Invalid date'));
      }
  
      const [year, month, day] = str.split('-').map(Number);
      return ParseResult.succeed({ year, month, day });
    },
    encode: (date) => {
      return ParseResult.succeed(
        [
          date.year.toString().padStart(4, '0'),
          date.month.toString().padStart(2, '0'),
          date.day.toString().padStart(2, '0'),
        ].join('-'),
      );
    },
  }) */
  Schema3.String.pipe(FormatAnnotation.set(FormatEnum.Date), Schema3.annotations({
    title: "Date",
    description: "Valid date in ISO format"
  }))
);
var TimeOnly = (
  /* Schema.transformOrFail(Schema.String, SimpleTime, {
    strict: true,
    decode: (str, _, ast) => {
      if (!isValidTimeFormat(str)) {
        return ParseResult.fail(new ParseResult.Type(ast, str, 'Expected HH:mm:ss format'));
      }
  
      const [hours, minutes, seconds] = str.split(':').map(Number);
      return ParseResult.succeed({ hours, minutes, seconds });
    },
    encode: (time) => {
      return ParseResult.succeed(
        [
          time.hours.toString().padStart(2, '0'),
          time.minutes.toString().padStart(2, '0'),
          time.seconds.toString().padStart(2, '0'),
        ].join(':'),
      );
    },
  }) */
  Schema3.String.pipe(FormatAnnotation.set(FormatEnum.Time), Schema3.annotations({
    title: "Time",
    description: "Valid time in ISO format"
  }))
);
var DateTime = (
  /* Schema.transformOrFail(Schema.String, SimpleDateTime, {
    strict: false,
    decode: (str, _, ast) => {
      const [date, time] = str.split('T');
      if (!isValidDateFormat(date)) {
        return ParseResult.fail(new ParseResult.Type(ast, date, 'Expected YYYY-MM-DD format'));
      }
      if (!isValidDate(date)) {
        return ParseResult.fail(new ParseResult.Type(ast, date, 'Invalid date'));
      }
      if (!isValidTimeFormat(time)) {
        return ParseResult.fail(new ParseResult.Type(ast, str, 'Expected HH:mm:ss format'));
      }
  
      const [year, month, day] = date.split('-').map(Number);
      const [hours, minutes, seconds] = time.split(':').map(Number);
      return ParseResult.succeed({ year, month, day, hours, minutes, seconds });
    },
    encode: (datetime) => {
      return ParseResult.succeed(
        [
          [
            datetime.year.toString().padStart(4, '0'),
            datetime.month.toString().padStart(2, '0'),
            datetime.day.toString().padStart(2, '0'),
          ].join('-'),
          [
            datetime.hours.toString().padStart(2, '0'),
            datetime.minutes.toString().padStart(2, '0'),
            datetime.seconds.toString().padStart(2, '0'),
          ].join(':'),
        ].join('T'),
      );
    },
  }) */
  Schema3.String.pipe(FormatAnnotation.set(FormatEnum.DateTime), Schema3.annotations({
    title: "DateTime",
    description: "Valid date and time in ISO format"
  }))
);
var Duration = Schema3.String.pipe(FormatAnnotation.set(FormatEnum.Duration), Schema3.annotations({
  title: "Duration",
  description: "Duration in ISO 8601 format",
  [SchemaAST2.ExamplesAnnotationId]: [
    "1h",
    "3D"
  ]
}));

// packages/core/echo/echo-schema/src/formats/string.ts
import { SchemaAST as SchemaAST3, Schema as Schema4 } from "effect";
var Email = Schema4.String.pipe(Schema4.pattern(/^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/), FormatAnnotation.set(FormatEnum.Email), Schema4.annotations({
  title: "Email",
  description: "Email address"
}));
var Formula = Schema4.String.pipe(FormatAnnotation.set(FormatEnum.Formula));
var Hostname = Schema4.String.pipe(FormatAnnotation.set(FormatEnum.Hostname));
var JSON = Schema4.String.pipe(FormatAnnotation.set(FormatEnum.JSON));
var Markdown = Schema4.String.pipe(FormatAnnotation.set(FormatEnum.Markdown));
var Regex = Schema4.String.pipe(FormatAnnotation.set(FormatEnum.Regex));
var URL = Schema4.String.pipe(Schema4.pattern(/^(\w+?:\/\/)?([\da-z.-]+)\.([a-z.]{2,6})([/\w .-]*)*\/?$/i), FormatAnnotation.set(FormatEnum.URL), Schema4.annotations({
  title: "URL",
  description: "URL"
}));
var UUID = Schema4.UUID.pipe(FormatAnnotation.set(FormatEnum.UUID), Schema4.annotations({
  [SchemaAST3.ExamplesAnnotationId]: [
    "3e4666bf-d5e5-4aa7-b8ce-cefe41c7568a"
  ]
}));

// packages/core/echo/echo-schema/src/formats/format.ts
(function(Format2) {
  Format2.DXN = Keys.DXN;
  Format2.Email = Email;
  Format2.Formula = Formula;
  Format2.Hostname = Hostname;
  Format2.JSON = JSON;
  Format2.Markdown = Markdown;
  Format2.Regex = Regex;
  Format2.URL = URL;
  Format2.UUID = Schema5.UUID;
  Format2.Currency = Currency;
  Format2.Integer = Integer;
  Format2.Percent = Percent;
  Format2.Timestamp = Timestamp;
  Format2.DateTime = DateTime;
  Format2.Date = DateOnly;
  Format2.Time = TimeOnly;
  Format2.Duration = Duration;
  Format2.GeoPoint = GeoPoint;
})(Format || (Format = {}));
var Format;

// packages/core/echo/echo-schema/src/formats/select.ts
import { Schema as Schema6 } from "effect";
var SelectOptionSchema = Schema6.Struct({
  /** Stable identifier for the option. */
  id: Schema6.NonEmptyString,
  title: Schema6.String,
  /** Color palette used for visual styling. */
  color: Schema6.String
}).pipe(Schema6.mutable);

// packages/core/echo/echo-schema/src/json/json-schema.ts
import { JSONSchema, Option as Option2, Schema as Schema8, SchemaAST as SchemaAST5 } from "effect";
import { raise } from "@dxos/debug";
import { mapAst } from "@dxos/effect";
import { invariant } from "@dxos/invariant";
import { DXN as DXN2, ObjectId } from "@dxos/keys";
import { clearUndefined, orderKeys, removeProperties } from "@dxos/util";

// packages/core/echo/echo-schema/src/json/annotations.ts
import { SchemaAST as SchemaAST4 } from "effect";
var CustomAnnotations = {
  format: FormatAnnotationId,
  currency: CurrencyAnnotationId
};
var DecodedAnnotations = {
  title: SchemaAST4.TitleAnnotationId,
  description: SchemaAST4.DescriptionAnnotationId
};
var EchoAnnotations = {
  // TODO(dmaretskyi): `FieldLookupAnnotationId` might go here, but lets remove it entirely and use LabelAnnotation instead.
  meta: PropertyMetaAnnotationId,
  generator: GeneratorAnnotationId,
  labelProp: LabelAnnotationId
};

// packages/core/echo/echo-schema/src/json-schema/json-schema-type.ts
import { Schema as Schema7 } from "effect";
import { JsonPath } from "@dxos/effect";
var SimpleTypes = Schema7.Literal("array", "boolean", "integer", "null", "number", "object", "string");
var NonNegativeInteger = Schema7.Number.pipe(Schema7.greaterThanOrEqualTo(0));
var StringArray = Schema7.Array(Schema7.String).pipe(Schema7.mutable);
var JsonSchemaOrBoolean = Schema7.Union(Schema7.suspend(() => JsonSchemaType), Schema7.Boolean);
var JsonSchemaEchoAnnotations = Schema7.Struct({
  /**
  * Label for this schema.
  * Mapped from {@link LabelAnnotationId}.
  */
  labelProp: Schema7.optional(Schema7.Union(JsonPath, Schema7.Array(JsonPath))),
  /**
  * Generator function for this schema.
  * Mapped from {@link GeneratorAnnotationId}.
  */
  generator: Schema7.optional(Schema7.Union(Schema7.String, Schema7.Tuple(Schema7.String, Schema7.Number))),
  /**
  * {@link PropertyMeta} annotations get serialized here.
  */
  meta: Schema7.optional(Schema7.Record({
    key: Schema7.String,
    value: Schema7.Any
  }).pipe(Schema7.mutable)),
  /**
  * @deprecated
  */
  // TODO(dmaretskyi): We risk old schema not passing validation due to the extra fields. Remove when we are sure this is safe
  type: Schema7.optional(Schema7.Struct({
    typename: Schema7.String,
    version: Schema7.String,
    // Not used.
    schemaId: Schema7.optional(Schema7.String)
  }).pipe(Schema7.mutable)),
  /**
  * @deprecated Superseded by `meta`.
  */
  annotations: Schema7.optional(Schema7.Record({
    key: Schema7.String,
    value: Schema7.Any
  }).pipe(Schema7.mutable))
}).pipe(Schema7.mutable);
var _JsonSchemaType = Schema7.Struct({
  /**
  * Identifier for this schema.
  * This schema might be referenced by $ref clause in other schemas.
  */
  // TODO(dmaretskyi): Specify how the ids are generated.
  // TODO(dmaretskyi): For type dxns, should this include the version?
  $id: Schema7.optional(Schema7.String),
  /**
  * Schema of this schema.
  * Set to "https://json-schema.org/draft-07/schema".
  */
  $schema: Schema7.optional(Schema7.String),
  /**
  * Reference to another schema.
  */
  $ref: Schema7.optional(Schema7.String),
  /**
  * Comments are ignored when interpreting the schema.
  */
  $comment: Schema7.optional(Schema7.String),
  /**
  * Defines whether this schema is an object schema or a relation schema.
  */
  entityKind: Schema7.optional(EntityKindSchema),
  /**
  * Typename of this schema.
  * Only on schema representing an ECHO object.
  *
  * @example 'example.com/type/MyType'
  */
  typename: Schema7.optional(Schema7.String),
  /**
  * Version of this schema.
  * Custom dialect for ECHO.
  */
  version: Schema7.optional(Schema7.String),
  /**
  * Target of this relation.
  * Only for relation schemas.
  * The referenced schema must be an object schema.
  */
  relationTarget: Schema7.optional(Schema7.suspend(() => JsonSchemaType)),
  /**
  * Source of this relation.
  * Only for relation schemas.
  * The referenced schema must be an object schema.
  */
  relationSource: Schema7.optional(Schema7.suspend(() => JsonSchemaType)),
  /**
  * Title of this schema.
  */
  title: Schema7.optional(Schema7.String),
  /**
  * Description of this schema.
  */
  description: Schema7.optional(Schema7.String),
  /**
  * Whether this schema is read-only.
  */
  readOnly: Schema7.optional(Schema7.Boolean),
  /**
  * Whether this schema is write-only.
  */
  writeOnly: Schema7.optional(Schema7.Boolean),
  /**
  * Examples of instances of this schema.
  */
  examples: Schema7.optional(Schema7.Array(Schema7.Any)),
  /**
  * Default value for this schema.
  */
  default: Schema7.optional(Schema7.Any),
  /**
  * This schema only matches values that are equal to this value.
  */
  const: Schema7.optional(Schema7.Any),
  /**
  * This schema only matches one of the values in this array.
  */
  enum: Schema7.optional(Schema7.Array(Schema7.Any)),
  /**
  * Base type of the schema.
  */
  type: Schema7.optional(Schema7.Union(SimpleTypes, Schema7.Array(SimpleTypes))),
  //
  // Numbers.
  //
  multipleOf: Schema7.optional(Schema7.Number.pipe(Schema7.greaterThan(0))),
  maximum: Schema7.optional(Schema7.Number),
  exclusiveMaximum: Schema7.optional(Schema7.Number),
  minimum: Schema7.optional(Schema7.Number),
  exclusiveMinimum: Schema7.optional(Schema7.Number),
  //
  // Strings.
  //
  maxLength: Schema7.optional(NonNegativeInteger),
  /**
  * Regex pattern for strings.
  */
  pattern: Schema7.optional(Schema7.String.pipe(FormatAnnotation.set(FormatEnum.Regex))),
  /**
  * Serialized from {@link FormatAnnotationId}.
  */
  format: Schema7.optional(Schema7.String),
  //
  // Arrays
  //
  minLength: Schema7.optional(NonNegativeInteger),
  items: Schema7.optional(Schema7.Union(Schema7.suspend(() => JsonSchemaType), Schema7.Array(Schema7.suspend(() => JsonSchemaType)))),
  additionalItems: Schema7.optional(Schema7.Union(Schema7.suspend(() => JsonSchemaType), Schema7.Boolean)),
  maxItems: Schema7.optional(NonNegativeInteger),
  minItems: Schema7.optional(NonNegativeInteger),
  uniqueItems: Schema7.optional(Schema7.Boolean),
  contains: Schema7.optional(Schema7.suspend(() => JsonSchemaType)),
  //
  // Objects
  //
  maxProperties: Schema7.optional(NonNegativeInteger),
  minProperties: Schema7.optional(NonNegativeInteger),
  required: Schema7.optional(StringArray),
  /**
  * Non-standard JSON Schema extension.
  * Defines the order of properties in the object.
  * The unmentioned properties are placed at the end.
  *
  * Related: https://github.com/json-schema/json-schema/issues/119
  */
  propertyOrder: Schema7.optional(StringArray),
  additionalProperties: Schema7.optional(JsonSchemaOrBoolean),
  properties: Schema7.optional(Schema7.Record({
    key: Schema7.String,
    value: Schema7.suspend(() => JsonSchemaType)
  }).pipe(Schema7.mutable)),
  patternProperties: Schema7.optional(Schema7.Record({
    key: Schema7.String,
    value: Schema7.suspend(() => JsonSchemaType)
  }).pipe(Schema7.mutable)),
  propertyNames: Schema7.optional(Schema7.suspend(() => JsonSchemaType)),
  definitions: Schema7.optional(Schema7.mutable(Schema7.Record({
    key: Schema7.String,
    value: Schema7.suspend(() => JsonSchemaType)
  }))),
  dependencies: Schema7.optional(Schema7.Record({
    key: Schema7.String,
    value: Schema7.suspend(() => Schema7.Union(Schema7.String, StringArray, JsonSchemaType)).annotations({
      identifier: "dependency",
      description: "Dependency"
    })
  })),
  contentMediaType: Schema7.optional(Schema7.String),
  contentEncoding: Schema7.optional(Schema7.String),
  if: Schema7.optional(Schema7.suspend(() => JsonSchemaType)),
  then: Schema7.optional(Schema7.suspend(() => JsonSchemaType)),
  else: Schema7.optional(Schema7.suspend(() => JsonSchemaType)),
  allOf: Schema7.optional(Schema7.Array(Schema7.suspend(() => JsonSchemaType))),
  anyOf: Schema7.optional(Schema7.Array(Schema7.suspend(() => JsonSchemaType))),
  oneOf: Schema7.optional(Schema7.Array(Schema7.suspend(() => JsonSchemaType))),
  not: Schema7.optional(Schema7.suspend(() => JsonSchemaType)),
  $defs: Schema7.optional(Schema7.mutable(Schema7.Record({
    key: Schema7.String,
    value: Schema7.suspend(() => JsonSchemaType)
  }))),
  //
  // ECHO extensions.
  //
  currency: Schema7.optional(Schema7.String),
  reference: Schema7.optional(Schema7.mutable(Schema7.Struct({
    schema: Schema7.suspend(() => JsonSchemaType),
    schemaVersion: Schema7.optional(Schema7.String),
    schemaObject: Schema7.optional(Schema7.String)
  }))),
  /**
  * ECHO-specific annotations.
  */
  // TODO(dmaretskyi): Since we are adding a lot of new extensions to the JSON Schema, it is safer to namespace them here.
  annotations: Schema7.optional(Schema7.mutable(JsonSchemaEchoAnnotations)),
  /**
  * @deprecated Use `annotations` instead.
  */
  echo: Schema7.optional(Schema7.mutable(JsonSchemaEchoAnnotations))
}).annotations({
  identifier: "jsonSchema",
  description: "JSON Schema"
});
var JsonSchemaFields = Object.keys(_JsonSchemaType.fields);
var JsonSchemaType = _JsonSchemaType.pipe(Schema7.mutable);
var getSchemaProperty = (schema, property) => {
  return schema.properties?.[property];
};
var setSchemaProperty = (schema, property, value) => {
  schema.properties ??= {};
  schema.properties[property] = value;
  return schema;
};
var ECHO_ANNOTATIONS_NS_DEPRECATED_KEY = "echo";
var ECHO_ANNOTATIONS_NS_KEY = "annotations";
var getNormalizedEchoAnnotations = (obj) => {
  if (obj[ECHO_ANNOTATIONS_NS_KEY] != null && obj[ECHO_ANNOTATIONS_NS_DEPRECATED_KEY] != null) {
    return normalizeEchoAnnotations({
      ...obj[ECHO_ANNOTATIONS_NS_DEPRECATED_KEY],
      ...obj[ECHO_ANNOTATIONS_NS_KEY]
    });
  } else if (obj[ECHO_ANNOTATIONS_NS_KEY] != null) {
    return normalizeEchoAnnotations(obj[ECHO_ANNOTATIONS_NS_KEY]);
  } else if (obj[ECHO_ANNOTATIONS_NS_DEPRECATED_KEY] != null) {
    return normalizeEchoAnnotations(obj[ECHO_ANNOTATIONS_NS_DEPRECATED_KEY]);
  } else {
    return void 0;
  }
};
var normalizeEchoAnnotations = (obj) => {
  if (!obj.annotations) {
    return obj;
  } else {
    const res = {
      ...obj,
      meta: {
        ...obj.annotations,
        ...obj.meta ?? {}
      }
    };
    delete res.annotations;
    return res;
  }
};

// packages/core/echo/echo-schema/src/json-schema/json-schema-normalize.ts
var normalizeSchema = (schema) => {
  const copy = structuredClone(schema);
  go(copy);
  return copy;
};
var go = (schema) => {
  if (typeof schema !== "object" || schema === null) {
    return;
  }
  if (schema.exclusiveMaximum === true) {
    schema.exclusiveMaximum = schema.maximum;
    delete schema.exclusiveMaximum;
  } else if (schema.exclusiveMaximum === false) {
    delete schema.exclusiveMaximum;
  }
  if (schema.exclusiveMinimum === true) {
    schema.exclusiveMinimum = schema.minimum;
    delete schema.exclusiveMinimum;
  } else if (schema.exclusiveMinimum === false) {
    delete schema.exclusiveMinimum;
  }
  for (const key of Object.keys(schema)) {
    if (!JsonSchemaFields.includes(key)) {
      delete schema[key];
    }
  }
  if (schema.properties) {
    goOnRecord(schema.properties);
  }
  if (schema.patternProperties) {
    goOnRecord(schema.patternProperties);
  }
  if (schema.propertyNames) {
    go(schema.propertyNames);
  }
  if (schema.definitions) {
    goOnRecord(schema.definitions);
  }
  if (schema.items) {
    maybeGoOnArray(schema.items);
  }
  if (schema.additionalItems) {
    maybeGoOnArray(schema.additionalItems);
  }
  if (schema.contains) {
    go(schema.contains);
  }
  if (schema.if) {
    go(schema.if);
  }
  if (schema.then) {
    go(schema.then);
  }
  if (schema.else) {
    go(schema.else);
  }
  if (schema.allOf) {
    maybeGoOnArray(schema.allOf);
  }
  if (schema.anyOf) {
    maybeGoOnArray(schema.anyOf);
  }
  if (schema.oneOf) {
    maybeGoOnArray(schema.oneOf);
  }
  if (schema.not) {
    go(schema.not);
  }
  if (schema.$defs) {
    goOnRecord(schema.$defs);
  }
  if (schema.reference) {
    go(schema.reference.schema);
  }
};
var maybeGoOnArray = (value) => {
  if (Array.isArray(value)) {
    for (const item of value) {
      go(item);
    }
  } else if (typeof value === "object" && value !== null) {
    go(value);
  }
};
var goOnRecord = (record) => {
  for (const key of Object.keys(record)) {
    go(record[key]);
  }
};

// packages/core/echo/echo-schema/src/json/json-schema.ts
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/core/echo/echo-schema/src/json/json-schema.ts";
var createJsonSchema = (schema = Schema8.Struct({})) => {
  const jsonSchema = _toJsonSchema(schema);
  jsonSchema.type = "object";
  delete jsonSchema.anyOf;
  return jsonSchema;
};
var PropType = /* @__PURE__ */ function(PropType2) {
  PropType2[PropType2["NONE"] = 0] = "NONE";
  PropType2[PropType2["STRING"] = 1] = "STRING";
  PropType2[PropType2["NUMBER"] = 2] = "NUMBER";
  PropType2[PropType2["BOOLEAN"] = 3] = "BOOLEAN";
  PropType2[PropType2["DATE"] = 4] = "DATE";
  PropType2[PropType2["REF"] = 5] = "REF";
  PropType2[PropType2["RECORD"] = 6] = "RECORD";
  PropType2[PropType2["ENUM"] = 7] = "ENUM";
  return PropType2;
}({});
var toPropType = (type) => {
  switch (type) {
    case 1:
      return "string";
    case 2:
      return "number";
    case 3:
      return "boolean";
    case 4:
      return "date";
    case 5:
      return "ref";
    case 6:
      return "object";
    default:
      throw new Error(`Invalid type: ${type}`);
  }
};
var JSON_SCHEMA_URL = "http://json-schema.org/draft-07/schema#";
var toJsonSchema = (schema, options = {}) => {
  let jsonSchema = _toJsonSchema(schema);
  if (options.strict) {
    jsonSchema = removeProperties(jsonSchema, (key, value) => {
      if (key === "$id" && value === "/schemas/any") {
        return true;
      }
      if (key === "$ref" && value === "#/$defs/dependency") {
        return true;
      }
      if (key === "$ref" && value === "#/$defs/jsonSchema") {
        return true;
      }
      return false;
    });
  }
  return jsonSchema;
};
var _toJsonSchema = (schema) => {
  invariant(schema, void 0, {
    F: __dxlog_file,
    L: 110,
    S: void 0,
    A: [
      "schema",
      ""
    ]
  });
  const withRefinements = withEchoRefinements(schema.ast, "#");
  let jsonSchema = JSONSchema.fromAST(withRefinements, {
    definitions: {}
  });
  jsonSchema.$schema = JSON_SCHEMA_URL;
  if (jsonSchema.properties && "id" in jsonSchema.properties) {
    jsonSchema.properties = orderKeys(jsonSchema.properties, [
      "id"
    ]);
  }
  const echoIdentifier = getTypeIdentifierAnnotation(schema);
  if (echoIdentifier) {
    jsonSchema.$id = echoIdentifier;
  }
  const objectAnnotation = getTypeAnnotation(schema);
  if (objectAnnotation) {
    if (!jsonSchema.$id) {
      jsonSchema.$id = DXN2.fromTypename(objectAnnotation.typename).toString();
    }
    jsonSchema.entityKind = objectAnnotation.kind;
    jsonSchema.version = objectAnnotation.version;
    jsonSchema.typename = objectAnnotation.typename;
    if (jsonSchema.entityKind === EntityKind.Relation) {
      jsonSchema.relationTarget = {
        $ref: objectAnnotation.sourceSchema
      };
      jsonSchema.relationSource = {
        $ref: objectAnnotation.targetSchema
      };
    }
  }
  jsonSchema = orderKeys(jsonSchema, [
    "$schema",
    "$id",
    "entityKind",
    "typename",
    "version",
    "relationTarget",
    "relationSource",
    "type",
    "enum",
    "properties",
    "required",
    "propertyOrder",
    "items",
    "additionalProperties",
    "anyOf",
    "oneOf"
  ]);
  return jsonSchema;
};
var withEchoRefinements = (ast, path, suspendCache = /* @__PURE__ */ new Map()) => {
  if (path) {
    suspendCache.set(ast, path);
  }
  let recursiveResult;
  if (SchemaAST5.isSuspend(ast)) {
    const suspendedAst = ast.f();
    const cachedPath = suspendCache.get(suspendedAst);
    if (cachedPath) {
      recursiveResult = new SchemaAST5.Suspend(() => withEchoRefinements(suspendedAst, path, suspendCache), {
        [SchemaAST5.JSONSchemaAnnotationId]: {
          $ref: cachedPath
        }
      });
    } else {
      const jsonSchema = _toJsonSchema(Schema8.make(suspendedAst));
      recursiveResult = new SchemaAST5.Suspend(() => withEchoRefinements(suspendedAst, path, suspendCache), {
        [SchemaAST5.JSONSchemaAnnotationId]: jsonSchema
      });
    }
  } else if (SchemaAST5.isTypeLiteral(ast)) {
    recursiveResult = mapAst(ast, (ast2, key) => withEchoRefinements(ast2, path && typeof key === "string" ? `${path}/${key}` : void 0, suspendCache));
    recursiveResult = addJsonSchemaFields(recursiveResult, {
      propertyOrder: [
        ...ast.propertySignatures.map((p) => p.name)
      ]
    });
  } else if (SchemaAST5.isUndefinedKeyword(ast)) {
    return ast;
  } else {
    recursiveResult = mapAst(ast, (ast2, key) => withEchoRefinements(ast2, path && (typeof key === "string" || typeof key === "number") ? `${path}/${key}` : void 0, suspendCache));
  }
  const annotationFields = annotations_toJsonSchemaFields(ast.annotations);
  if (Object.keys(annotationFields).length === 0) {
    return recursiveResult;
  } else {
    return addJsonSchemaFields(recursiveResult, annotationFields);
  }
};
var toEffectSchema = (root, _defs) => {
  const defs = root.$defs ? {
    ..._defs,
    ...root.$defs
  } : _defs ?? {};
  if ("type" in root && root.type === "object") {
    return objectToEffectSchema(root, defs);
  }
  let result = Schema8.Unknown;
  if ("$id" in root) {
    switch (root.$id) {
      case "/schemas/any": {
        result = anyToEffectSchema(root);
        break;
      }
      case "/schemas/unknown": {
        result = Schema8.Unknown;
        break;
      }
      case "/schemas/{}":
      case "/schemas/object": {
        result = Schema8.Object;
        break;
      }
      // Custom ECHO object reference.
      case "/schemas/echo/ref": {
        result = refToEffectSchema(root);
      }
    }
  } else if ("enum" in root) {
    result = Schema8.Union(...root.enum.map((e) => Schema8.Literal(e)));
  } else if ("oneOf" in root) {
    result = Schema8.Union(...root.oneOf.map((v) => toEffectSchema(v, defs)));
  } else if ("anyOf" in root) {
    result = Schema8.Union(...root.anyOf.map((v) => toEffectSchema(v, defs)));
  } else if ("type" in root) {
    switch (root.type) {
      case "string": {
        result = Schema8.String;
        if (root.pattern) {
          result = result.pipe(Schema8.pattern(new RegExp(root.pattern)));
        }
        break;
      }
      case "number": {
        result = Schema8.Number;
        break;
      }
      case "integer": {
        result = Schema8.Number.pipe(Schema8.int());
        break;
      }
      case "boolean": {
        result = Schema8.Boolean;
        break;
      }
      case "array": {
        if (Array.isArray(root.items)) {
          result = Schema8.Tuple(...root.items.map((v) => toEffectSchema(v, defs)));
        } else {
          invariant(root.items, void 0, {
            F: __dxlog_file,
            L: 294,
            S: void 0,
            A: [
              "root.items",
              ""
            ]
          });
          const items = root.items;
          result = Array.isArray(items) ? Schema8.Tuple(...items.map((v) => toEffectSchema(v, defs))) : Schema8.Array(toEffectSchema(items, defs));
        }
        break;
      }
      case "null": {
        result = Schema8.Null;
        break;
      }
    }
  } else if ("$ref" in root) {
    const refSegments = root.$ref.split("/");
    const jsonSchema = defs[refSegments[refSegments.length - 1]];
    invariant(jsonSchema, `missing definition for ${root.$ref}`, {
      F: __dxlog_file,
      L: 310,
      S: void 0,
      A: [
        "jsonSchema",
        "`missing definition for ${root.$ref}`"
      ]
    });
    result = toEffectSchema(jsonSchema, defs).pipe(Schema8.annotations({
      identifier: refSegments[refSegments.length - 1]
    }));
  }
  const annotations = jsonSchemaFieldsToAnnotations(root);
  result = result.annotations(annotations);
  return result;
};
var objectToEffectSchema = (root, defs) => {
  invariant("type" in root && root.type === "object", `not an object: ${root}`, {
    F: __dxlog_file,
    L: 325,
    S: void 0,
    A: [
      "'type' in root && root.type === 'object'",
      "`not an object: ${root}`"
    ]
  });
  const echoRefinement = root[ECHO_ANNOTATIONS_NS_DEPRECATED_KEY];
  const isEchoObject = echoRefinement != null || "$id" in root && typeof root.$id === "string" && root.$id.startsWith("dxn:");
  let fields = {};
  const propertyList = Object.entries(root.properties ?? {});
  let immutableIdField;
  for (const [key, value] of propertyList) {
    if (isEchoObject && key === "id") {
      immutableIdField = toEffectSchema(value, defs);
    } else {
      fields[key] = root.required?.includes(key) ? toEffectSchema(value, defs) : Schema8.optional(toEffectSchema(value, defs));
    }
  }
  if (root.propertyOrder) {
    fields = orderKeys(fields, root.propertyOrder);
  }
  let schema;
  if (root.patternProperties) {
    invariant(propertyList.length === 0, "pattern properties mixed with regular properties are not supported", {
      F: __dxlog_file,
      L: 351,
      S: void 0,
      A: [
        "propertyList.length === 0",
        "'pattern properties mixed with regular properties are not supported'"
      ]
    });
    invariant(Object.keys(root.patternProperties).length === 1 && Object.keys(root.patternProperties)[0] === "", "only one pattern property is supported", {
      F: __dxlog_file,
      L: 352,
      S: void 0,
      A: [
        "Object.keys(root.patternProperties).length === 1 && Object.keys(root.patternProperties)[0] === ''",
        "'only one pattern property is supported'"
      ]
    });
    schema = Schema8.Record({
      key: Schema8.String,
      value: toEffectSchema(root.patternProperties[""], defs)
    });
  } else if (typeof root.additionalProperties !== "object") {
    schema = Schema8.Struct(fields);
  } else {
    const indexValue = toEffectSchema(root.additionalProperties, defs);
    if (propertyList.length > 0) {
      schema = Schema8.Struct(fields, {
        key: Schema8.String,
        value: indexValue
      });
    } else {
      schema = Schema8.Record({
        key: Schema8.String,
        value: indexValue
      });
    }
  }
  if (immutableIdField) {
    schema = Schema8.extend(Schema8.mutable(schema), Schema8.Struct({
      id: immutableIdField
    }));
  }
  const annotations = jsonSchemaFieldsToAnnotations(root);
  return schema.annotations(annotations);
};
var anyToEffectSchema = (root) => {
  const echoRefinement = root[ECHO_ANNOTATIONS_NS_DEPRECATED_KEY];
  if (echoRefinement?.reference != null) {
    const echoId = root.$id.startsWith("dxn:echo:") ? root.$id : void 0;
    return createEchoReferenceSchema(echoId, echoRefinement.reference.typename, echoRefinement.reference.version);
  }
  return Schema8.Any;
};
var refToEffectSchema = (root) => {
  if (!("reference" in root)) {
    return Ref(Expando);
  }
  const reference = root.reference;
  if (typeof reference !== "object") {
    throw new Error("Invalid reference field in ref schema");
  }
  const targetSchemaDXN = DXN2.parse(reference.schema.$ref);
  invariant(targetSchemaDXN.kind === DXN2.kind.TYPE, void 0, {
    F: __dxlog_file,
    L: 403,
    S: void 0,
    A: [
      "targetSchemaDXN.kind === DXN.kind.TYPE",
      ""
    ]
  });
  return createEchoReferenceSchema(targetSchemaDXN.toString(), targetSchemaDXN.kind === DXN2.kind.TYPE ? targetSchemaDXN.parts[0] : void 0, reference.schemaVersion);
};
var annotations_toJsonSchemaFields = (annotations) => {
  const schemaFields = {};
  const echoAnnotations = {};
  for (const [key, annotationId] of Object.entries(EchoAnnotations)) {
    if (annotations[annotationId] != null) {
      echoAnnotations[key] = annotations[annotationId];
    }
  }
  if (Object.keys(echoAnnotations).length > 0) {
    schemaFields[ECHO_ANNOTATIONS_NS_KEY] = echoAnnotations;
  }
  const echoIdentifier = annotations[TypeIdentifierAnnotationId];
  if (echoIdentifier) {
    schemaFields[ECHO_ANNOTATIONS_NS_KEY] ??= {};
    schemaFields[ECHO_ANNOTATIONS_NS_KEY].schemaId = echoIdentifier;
  }
  for (const [key, annotationId] of Object.entries(CustomAnnotations)) {
    const value = annotations[annotationId];
    if (value != null) {
      schemaFields[key] = value;
    }
  }
  return schemaFields;
};
var decodeTypeIdentifierAnnotation = (schema) => {
  if (schema.$id && schema.$id.startsWith("dxn:echo:")) {
    return schema.$id;
  } else if (schema.$id && schema.$id.startsWith("dxn:type:") && schema?.echo?.type?.schemaId) {
    const id = schema?.echo?.type?.schemaId;
    if (ObjectId.isValid(id)) {
      return DXN2.fromLocalObjectId(id).toString();
    }
  }
  return void 0;
};
var decodeTypeAnnotation = (schema) => {
  if (schema.typename) {
    const annotation = {
      // TODO(dmaretskyi): Decoding default.
      kind: schema.entityKind ? Schema8.decodeSync(EntityKindSchema)(schema.entityKind) : EntityKind.Object,
      typename: schema.typename,
      version: schema.version ?? "0.1.0"
    };
    if (annotation.kind === EntityKind.Relation) {
      const source = schema.relationSource?.$ref ?? raise(new Error("Relation source not set"));
      const target = schema.relationTarget?.$ref ?? raise(new Error("Relation target not set"));
      annotation.sourceSchema = DXN2.parse(source).toString();
      annotation.targetSchema = DXN2.parse(target).toString();
    }
    return annotation;
  }
  if (!schema.typename && schema?.echo?.type) {
    return {
      kind: EntityKind.Object,
      typename: schema.echo.type.typename,
      version: schema.echo.type.version
    };
  }
  return void 0;
};
var jsonSchemaFieldsToAnnotations = (schema) => {
  const annotations = {};
  const echoAnnotations = getNormalizedEchoAnnotations(schema) ?? {};
  if (echoAnnotations) {
    for (const [key, annotationId] of Object.entries(EchoAnnotations)) {
      if (echoAnnotations[key]) {
        annotations[annotationId] = echoAnnotations[key];
      }
    }
  }
  annotations[TypeIdentifierAnnotationId] = decodeTypeIdentifierAnnotation(schema);
  annotations[TypeAnnotationId] = decodeTypeAnnotation(schema);
  for (const [key, annotationId] of Object.entries({
    ...CustomAnnotations,
    ...DecodedAnnotations
  })) {
    if (key in schema) {
      annotations[annotationId] = schema[key];
    }
  }
  return clearUndefined(annotations);
};
var makeAnnotatedRefinement = (ast, annotations) => {
  return new SchemaAST5.Refinement(ast, () => Option2.none(), annotations);
};
var addJsonSchemaFields = (ast, schema) => makeAnnotatedRefinement(ast, {
  [SchemaAST5.JSONSchemaAnnotationId]: schema
});

// packages/core/echo/echo-schema/src/query/query.ts
import { Schema as Schema9 } from "effect";
var SortDirection = Schema9.Union(Schema9.Literal("asc"), Schema9.Literal("desc"));
var FieldSort = Schema9.Struct({
  fieldId: Schema9.String,
  direction: SortDirection
}).pipe(Schema9.mutable);
var FieldSortType = FieldSort;
var QuerySchema = Schema9.Struct({
  typename: Schema9.optional(Schema9.String),
  sort: Schema9.optional(Schema9.Array(FieldSort))
}).pipe(Schema9.mutable);
var QueryType = QuerySchema;

// packages/core/echo/echo-schema/src/types/types.ts
import { SchemaAST as SchemaAST6, Schema as Schema10 } from "effect";
import { Reference } from "@dxos/echo-protocol";
import { splitJsonPath } from "@dxos/effect";
import { DXN as DXN3 } from "@dxos/keys";
import { getDeep, setDeep } from "@dxos/util";
var RawObject = (schema) => {
  return Schema10.make(SchemaAST6.omit(schema.ast, [
    "id"
  ]));
};
var splitMeta = (object) => {
  const meta = object[ATTR_META];
  delete object[ATTR_META];
  return {
    meta,
    object
  };
};
var getValue = (obj, path) => {
  return getDeep(obj, splitJsonPath(path).map((p) => p.replace(/[[\]]/g, "")));
};
var setValue = (obj, path, value) => {
  return setDeep(obj, splitJsonPath(path).map((p) => p.replace(/[[\]]/g, "")), value);
};
var getTypeReference = (schema) => {
  if (!schema) {
    return void 0;
  }
  const schemaDXN = getSchemaDXN(schema);
  if (!schemaDXN) {
    return void 0;
  }
  return Reference.fromDXN(schemaDXN);
};
var requireTypeReference = (schema) => {
  const typeReference = getTypeReference(schema);
  if (typeReference == null) {
    throw new Error("Schema must be defined via TypedObject.");
  }
  return typeReference;
};
var isInstanceOf = (schema, object) => {
  if (object == null) {
    return false;
  }
  const schemaDXN = getSchemaDXN(schema);
  if (!schemaDXN) {
    throw new Error("Schema must have an object annotation.");
  }
  const type = getType(object);
  if (type && DXN3.equals(type, schemaDXN)) {
    return true;
  }
  const typename = getTypename(object);
  if (!typename) {
    return false;
  }
  const typeDXN = schemaDXN.asTypeDXN();
  if (!typeDXN) {
    return false;
  }
  return typeDXN.type === typename;
};

// packages/core/echo/echo-schema/src/projection/compose.ts
import { invariant as invariant5 } from "@dxos/invariant";

// packages/core/echo/echo-schema/src/schema/echo-schema.ts
import { Schema as Schema13, SchemaAST as SchemaAST8 } from "effect";
import { invariant as invariant3 } from "@dxos/invariant";

// packages/core/echo/echo-schema/src/schema/manipulation.ts
import { SchemaAST as SchemaAST7, Schema as Schema11 } from "effect";
import { invariant as invariant2 } from "@dxos/invariant";
var __dxlog_file2 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-schema/src/schema/manipulation.ts";
var addFieldsToSchema = (schema, fields) => {
  const schemaExtension = Schema11.partial(Schema11.Struct(fields));
  return Schema11.extend(schema, schemaExtension).annotations(schema.ast.annotations);
};
var updateFieldsInSchema = (schema, fields) => {
  const ast = schema.ast;
  invariant2(SchemaAST7.isTypeLiteral(ast), void 0, {
    F: __dxlog_file2,
    L: 27,
    S: void 0,
    A: [
      "SchemaAST.isTypeLiteral(ast)",
      ""
    ]
  });
  const updatedProperties = [
    ...ast.propertySignatures
  ];
  const propertiesToUpdate = Schema11.partial(Schema11.Struct(fields)).ast.propertySignatures;
  for (const property of propertiesToUpdate) {
    const index = updatedProperties.findIndex((p) => p.name === property.name);
    if (index !== -1) {
      updatedProperties[index] = property;
    } else {
      updatedProperties.push(property);
    }
  }
  return Schema11.make(new SchemaAST7.TypeLiteral(updatedProperties, ast.indexSignatures, ast.annotations));
};
var removeFieldsFromSchema = (schema, fieldNames) => {
  return Schema11.make(SchemaAST7.omit(schema.ast, fieldNames)).annotations(schema.ast.annotations);
};
var updateFieldNameInSchema = (schema, { before, after }) => {
  const ast = schema.ast;
  invariant2(SchemaAST7.isTypeLiteral(ast), void 0, {
    F: __dxlog_file2,
    L: 55,
    S: void 0,
    A: [
      "SchemaAST.isTypeLiteral(ast)",
      ""
    ]
  });
  return Schema11.make(new SchemaAST7.TypeLiteral(ast.propertySignatures.map((p) => p.name === before ? new SchemaAST7.PropertySignature(after, p.type, p.isOptional, p.isReadonly, p.annotations) : p), ast.indexSignatures, ast.annotations));
};
var setTypenameInSchema = (schema, typename) => {
  const existingAnnotation = schema.ast.annotations[TypeAnnotationId];
  invariant2(existingAnnotation, `Missing ${String(TypeAnnotationId)}`, {
    F: __dxlog_file2,
    L: 75,
    S: void 0,
    A: [
      "existingAnnotation",
      "`Missing ${String(TypeAnnotationId)}`"
    ]
  });
  return schema.annotations({
    ...schema.ast.annotations,
    [TypeAnnotationId]: {
      kind: existingAnnotation.kind,
      typename,
      version: existingAnnotation.version
    }
  });
};

// packages/core/echo/echo-schema/src/schema/snapshot.ts
var getSnapshot = (object) => {
  if (typeof object !== "object") {
    return object;
  }
  if (Array.isArray(object)) {
    return object.map(getSnapshot);
  }
  const result = {};
  for (const key in object) {
    result[key] = getSnapshot(object[key]);
  }
  return result;
};

// packages/core/echo/echo-schema/src/schema/stored-schema.ts
import { Schema as Schema12 } from "effect";
var StoredSchema = Schema12.Struct({
  typename: Typename,
  version: Version,
  jsonSchema: JsonSchemaType
}).pipe(EchoObject({
  typename: "dxos.org/type/Schema",
  version: "0.1.0"
}));

// packages/core/echo/echo-schema/src/schema/echo-schema.ts
var __dxlog_file3 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-schema/src/schema/echo-schema.ts";
var ImmutableSchema = class {
  constructor(_schema) {
    this._schema = _schema;
    this._objectAnnotation = getTypeAnnotation(this._schema);
    invariant3(this._objectAnnotation, void 0, {
      F: __dxlog_file3,
      L: 45,
      S: this,
      A: [
        "this._objectAnnotation",
        ""
      ]
    });
  }
  //
  // Effect Schema (push to abstract base class).
  //
  get [Schema13.TypeId]() {
    return schemaVariance;
  }
  get Type() {
    return this._schema.Type;
  }
  get Encoded() {
    return this._schema.Encoded;
  }
  get Context() {
    return this._schema.Context;
  }
  get ast() {
    return this._schema.ast;
  }
  get annotations() {
    return this._schema.annotations;
  }
  get pipe() {
    return this._schema.pipe;
  }
  //
  // TypedObject
  //
  get typename() {
    return this._objectAnnotation.typename;
  }
  get version() {
    return this._objectAnnotation.version;
  }
  //
  // BaseSchema
  //
  get readonly() {
    return true;
  }
  get snapshot() {
    return this._schema;
  }
  // TODO(burdon): Change from getter since this is expensive.
  get jsonSchema() {
    return toJsonSchema(this._schema);
  }
  get mutable() {
    throw new Error("Schema is readonly.");
  }
};
var EchoSchemaConstructor = () => {
  var _a;
  return _a = Schema13.TypeId, class {
    static get _schema() {
      return Schema13.Union(StoredSchema, Schema13.instanceOf(EchoSchema)).annotations(StoredSchema.ast.annotations);
    }
    static {
      this[_a] = schemaVariance;
    }
    static get ast() {
      const schema = this._schema;
      return schema.ast;
    }
    static get annotations() {
      const schema = this._schema;
      return schema.annotations.bind(schema);
    }
    static get pipe() {
      const schema = this._schema;
      return schema.pipe.bind(schema);
    }
  };
};
var isMutable = (schema) => {
  return schema instanceof EchoSchema;
};
var schemaVariance = {
  _A: (_) => _,
  _I: (_) => _,
  _R: (_) => _
};
var EchoSchema = class extends EchoSchemaConstructor() {
  constructor(_storedSchema) {
    super(), this._storedSchema = _storedSchema, this._isDirty = true;
  }
  //
  // Effect Schema (push to abstract base class).
  //
  get [Schema13.TypeId]() {
    return schemaVariance;
  }
  get Type() {
    return this._storedSchema;
  }
  get Encoded() {
    return this._storedSchema;
  }
  get Context() {
    const schema = this._getSchema();
    return schema.Context;
  }
  get ast() {
    const schema = this._getSchema();
    return schema.ast;
  }
  get annotations() {
    const schema = this._getSchema();
    return schema.annotations.bind(schema);
  }
  get pipe() {
    const schema = this._getSchema();
    return schema.pipe.bind(schema);
  }
  //
  // BaseSchema
  //
  get typename() {
    return this._storedSchema.typename;
  }
  get version() {
    return this._storedSchema.version;
  }
  get readonly() {
    return false;
  }
  /**
  * Returns an immutable schema snapshot of the current state of the schema.
  */
  get snapshot() {
    return this._getSchema();
  }
  /**
  * @reactive
  */
  get jsonSchema() {
    return this._storedSchema.jsonSchema;
  }
  /**
  * Returns a mutable schema.
  */
  get mutable() {
    invariant3(!this.readonly, "Schema is not mutable", {
      F: __dxlog_file3,
      L: 258,
      S: this,
      A: [
        "!this.readonly",
        "'Schema is not mutable'"
      ]
    });
    return this;
  }
  //
  // Mutable Schema
  //
  /**
  * Id of the ECHO object containing the schema.
  */
  get id() {
    return this._storedSchema.id;
  }
  get [SchemaMetaSymbol]() {
    return {
      id: this.id,
      typename: this.typename,
      version: this._storedSchema.version
    };
  }
  /**
  * Reference to the underlying stored schema object.
  */
  get storedSchema() {
    return this._storedSchema;
  }
  getProperties() {
    const ast = this._getSchema().ast;
    invariant3(SchemaAST8.isTypeLiteral(ast), void 0, {
      F: __dxlog_file3,
      L: 286,
      S: this,
      A: [
        "SchemaAST.isTypeLiteral(ast)",
        ""
      ]
    });
    return [
      ...ast.propertySignatures
    ].filter((p) => p.name !== "id").map(unwrapOptionality);
  }
  //
  // Mutation methods.
  // TODO(burdon): Create separate interface for dynamic schema.
  // TODO(burdon): Deprecate direct manipulation? Use JSONSchema directly.
  //
  /**
  * @throws Error if the schema is readonly.
  */
  updateTypename(typename) {
    const updated = setTypenameInSchema(this._getSchema(), typename);
    this._storedSchema.typename = typename;
    this._storedSchema.jsonSchema = toJsonSchema(updated);
  }
  /**
  * @throws Error if the schema is readonly.
  */
  addFields(fields) {
    const extended = addFieldsToSchema(this._getSchema(), fields);
    this._storedSchema.jsonSchema = toJsonSchema(extended);
  }
  /**
  * @throws Error if the schema is readonly.
  */
  updateFields(fields) {
    const updated = updateFieldsInSchema(this._getSchema(), fields);
    this._storedSchema.jsonSchema = toJsonSchema(updated);
  }
  /**
  * @throws Error if the schema is readonly.
  */
  updateFieldPropertyName({ before, after }) {
    const renamed = updateFieldNameInSchema(this._getSchema(), {
      before,
      after
    });
    this._storedSchema.jsonSchema = toJsonSchema(renamed);
  }
  /**
  * @throws Error if the schema is readonly.
  */
  removeFields(fieldNames) {
    const removed = removeFieldsFromSchema(this._getSchema(), fieldNames);
    this._storedSchema.jsonSchema = toJsonSchema(removed);
  }
  //
  // Internals
  //
  /**
  * Called by EchoSchemaRegistry on update.
  */
  _invalidate() {
    this._isDirty = true;
  }
  /**
  * Rebuilds this schema if it is dirty.
  */
  _rebuild() {
    if (this._isDirty || this._schema == null) {
      this._schema = toEffectSchema(getSnapshot(this._storedSchema.jsonSchema));
      this._isDirty = false;
    }
  }
  _getSchema() {
    this._rebuild();
    return this._schema;
  }
};
var unwrapOptionality = (property) => {
  if (!SchemaAST8.isUnion(property.type)) {
    return property;
  }
  return {
    ...property,
    type: property.type.types.find((type) => !SchemaAST8.isUndefinedKeyword(type))
  };
};

// packages/core/echo/echo-schema/src/schema/runtime-schema-registry.ts
import { raise as raise2 } from "@dxos/debug";
import { invariant as invariant4 } from "@dxos/invariant";
import { defaultMap } from "@dxos/util";
var __dxlog_file4 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-schema/src/schema/runtime-schema-registry.ts";
var RuntimeSchemaRegistry = class {
  constructor() {
    this._registry = /* @__PURE__ */ new Map();
    this._registry.set(StoredSchema.typename, [
      StoredSchema
    ]);
  }
  get schemas() {
    return Array.from(this._registry.values()).flat();
  }
  hasSchema(schema) {
    const typename = getSchemaTypename(schema);
    const version = getSchemaVersion(schema);
    invariant4(typename, void 0, {
      F: __dxlog_file4,
      L: 33,
      S: this,
      A: [
        "typename",
        ""
      ]
    });
    const schemas = this._registry.get(typename);
    return schemas?.some((schema2) => getSchemaVersion(schema2) === version) ?? false;
  }
  getSchemaByDXN(dxn) {
    const components = dxn.asTypeDXN();
    if (!components) {
      return void 0;
    }
    const { type, version } = components;
    const allSchemas = this._registry.get(type) ?? [];
    if (version) {
      return allSchemas.find((s) => getSchemaVersion(s) === version);
    } else {
      return allSchemas.sort((a, b) => (getSchemaVersion(a) ?? "0.0.0").localeCompare(getSchemaVersion(b) ?? "0.0.0"))[0];
    }
  }
  /**
  * @deprecated Use getSchemaByDXN.
  */
  getSchema(typename) {
    return this._registry.get(typename)?.[0];
  }
  addSchema(types) {
    types.forEach((schema) => {
      const typename = getSchemaTypename(schema) ?? raise2(new TypeError("Schema has no typename"));
      const version = getSchemaVersion(schema) ?? raise2(new TypeError("Schema has no version"));
      const versions = defaultMap(this._registry, typename, () => []);
      if (versions.some((schema2) => getSchemaVersion(schema2) === version)) {
        throw new Error(`Schema version already registered: ${typename}:${version}`);
      }
      versions.push(schema);
    });
  }
};

// packages/core/echo/echo-schema/src/projection/compose.ts
var __dxlog_file5 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-schema/src/projection/compose.ts";
var composeSchema = (source, target) => {
  const result = getSnapshot(target);
  invariant5("type" in result && result.type === "object", "source schema must be an object", {
    F: __dxlog_file5,
    L: 17,
    S: void 0,
    A: [
      "'type' in result && result.type === 'object'",
      "'source schema must be an object'"
    ]
  });
  invariant5("type" in source && source.type === "object", "target schema must be an object", {
    F: __dxlog_file5,
    L: 18,
    S: void 0,
    A: [
      "'type' in source && source.type === 'object'",
      "'target schema must be an object'"
    ]
  });
  for (const prop in result.properties) {
    const propSchema = source.properties[prop];
    const annotations = propSchema?.annotations?.meta;
    if (annotations) {
      result.properties[prop].annotations ??= {};
      result.properties[prop].annotations.meta ??= {};
      for (const key in annotations) {
        result.properties[prop].annotations.meta[key] ??= {};
        Object.assign(result.properties[prop].annotations.meta[key], annotations[key], {
          ...result.properties[prop].annotations.meta[key]
        });
      }
    }
  }
  return result;
};
export {
  ATTR_DELETED,
  ATTR_META,
  ATTR_RELATION_SOURCE,
  ATTR_RELATION_TARGET,
  ATTR_SELF_DXN,
  ATTR_TYPE,
  Currency,
  CurrencyAnnotationId,
  DecimalPrecision,
  DeletedId,
  ECHO_ANNOTATIONS_NS_DEPRECATED_KEY,
  ECHO_ANNOTATIONS_NS_KEY,
  EXPANDO_TYPENAME,
  EchoObject,
  EchoRelation,
  EchoSchema,
  Email,
  EntityKind,
  EntityKindId,
  EntityKindSchema,
  Expando,
  FIELD_PATH_ANNOTATION,
  FieldLookupAnnotationId,
  FieldPath,
  FieldSortType,
  ForeignKey,
  Format,
  FormatAnnotation,
  FormatAnnotationId,
  FormatEnum,
  FormatEnums,
  Formula,
  GeneratorAnnotation,
  GeneratorAnnotationId,
  GeoLocation,
  GeoPoint,
  Hostname,
  ImmutableSchema,
  JSON,
  JSON_SCHEMA_ECHO_REF_ID,
  JsonPath2 as JsonPath,
  JsonProp,
  JsonSchemaEchoAnnotations,
  JsonSchemaFields,
  JsonSchemaType,
  LabelAnnotation,
  LabelAnnotationId,
  Markdown,
  MetaId,
  ObjectId2 as ObjectId,
  ObjectMetaSchema,
  OptionsAnnotationId,
  PropType,
  PropertyKind,
  PropertyMeta,
  PropertyMetaAnnotationId,
  QueryType,
  RawObject,
  Ref,
  RefArray,
  RefImpl,
  RefTypeId,
  ReferenceAnnotationId,
  Regex,
  RelationSourceDXNId,
  RelationSourceId,
  RelationTargetDXNId,
  RelationTargetId,
  RuntimeSchemaRegistry,
  SchemaId,
  SchemaMetaSymbol,
  SchemaValidator,
  SelectOptionSchema,
  SelfDXNId,
  StaticRefResolver,
  StoredSchema,
  TypeAnnotation,
  TypeAnnotationId,
  TypeEnum,
  TypeId,
  TypeIdentifierAnnotationId,
  TypedObject,
  TypedRelation,
  Typename,
  URL,
  UUID,
  Version,
  addFieldsToSchema,
  assertObjectModelShape,
  attachTypedJsonSerializer,
  checkIdNotPresentOnSchema,
  compareForeignKeys,
  composeSchema,
  create,
  createAnnotationHelper,
  createEchoReferenceSchema,
  createJsonSchema,
  createQueueDXN,
  createSchemaReference,
  defineHiddenProperty,
  foreignKey,
  foreignKeyEquals,
  formatToType,
  getEntityKind,
  getFormatAnnotation,
  getLabel,
  getLabelForObject,
  getMeta,
  getNormalizedEchoAnnotations,
  getObjectDXN,
  getObjectMeta,
  getOptionsAnnotation,
  getPropertyMetaAnnotation,
  getRefSavedTarget,
  getReferenceAnnotation,
  getSchema,
  getSchemaDXN,
  getSchemaProperty,
  getSchemaReference,
  getSchemaTypename,
  getSchemaVersion,
  getSnapshot,
  getType,
  getTypeAnnotation,
  getTypeEnum,
  getTypeIdentifierAnnotation,
  getTypeReference,
  getTypename,
  getValue,
  isDeleted,
  isInstanceOf,
  isMutable,
  makeTypedEntityClass,
  normalizeSchema,
  objectFromJSON,
  objectToJSON,
  refFromEncodedReference,
  removeFieldsFromSchema,
  requireTypeReference,
  setRefResolver,
  setSchema,
  setSchemaProperty,
  setTypename,
  setTypenameInSchema,
  setValue,
  splitJsonPath2 as splitJsonPath,
  splitMeta,
  toEffectSchema,
  toJsonSchema,
  toPropType,
  typeToFormat,
  updateFieldNameInSchema,
  updateFieldsInSchema
};
//# sourceMappingURL=index.mjs.map
