"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var chunk_BRS5374V_exports = {};
__export(chunk_BRS5374V_exports, {
  ATTR_DELETED: () => ATTR_DELETED,
  ATTR_META: () => ATTR_META,
  ATTR_RELATION_SOURCE: () => ATTR_RELATION_SOURCE,
  ATTR_RELATION_TARGET: () => ATTR_RELATION_TARGET,
  ATTR_SELF_DXN: () => ATTR_SELF_DXN,
  ATTR_TYPE: () => ATTR_TYPE,
  DeletedId: () => DeletedId,
  EXPANDO_TYPENAME: () => EXPANDO_TYPENAME,
  EchoObject: () => EchoObject,
  EchoRelation: () => EchoRelation,
  EntityKind: () => EntityKind,
  EntityKindId: () => EntityKindId,
  EntityKindSchema: () => EntityKindSchema,
  Expando: () => Expando,
  FIELD_PATH_ANNOTATION: () => FIELD_PATH_ANNOTATION,
  FieldLookupAnnotationId: () => FieldLookupAnnotationId,
  FieldPath: () => FieldPath,
  GeneratorAnnotation: () => GeneratorAnnotation,
  GeneratorAnnotationId: () => GeneratorAnnotationId,
  JSON_SCHEMA_ECHO_REF_ID: () => JSON_SCHEMA_ECHO_REF_ID,
  LabelAnnotation: () => LabelAnnotation,
  LabelAnnotationId: () => LabelAnnotationId,
  MetaId: () => MetaId,
  ObjectMetaSchema: () => ObjectMetaSchema,
  PropertyMeta: () => PropertyMeta,
  PropertyMetaAnnotationId: () => PropertyMetaAnnotationId,
  Ref: () => Ref,
  RefArray: () => RefArray,
  RefImpl: () => RefImpl,
  RefTypeId: () => RefTypeId,
  ReferenceAnnotationId: () => ReferenceAnnotationId,
  RelationSourceDXNId: () => RelationSourceDXNId,
  RelationSourceId: () => RelationSourceId,
  RelationTargetDXNId: () => RelationTargetDXNId,
  RelationTargetId: () => RelationTargetId,
  SchemaId: () => SchemaId,
  SchemaMetaSymbol: () => SchemaMetaSymbol,
  SchemaValidator: () => SchemaValidator,
  SelfDXNId: () => SelfDXNId,
  StaticRefResolver: () => StaticRefResolver,
  TypeAnnotation: () => TypeAnnotation,
  TypeAnnotationId: () => TypeAnnotationId,
  TypeId: () => TypeId,
  TypeIdentifierAnnotationId: () => TypeIdentifierAnnotationId,
  TypedObject: () => TypedObject,
  TypedRelation: () => TypedRelation,
  Typename: () => Typename,
  Version: () => Version,
  assertObjectModelShape: () => assertObjectModelShape,
  attachTypedJsonSerializer: () => attachTypedJsonSerializer,
  checkIdNotPresentOnSchema: () => checkIdNotPresentOnSchema,
  compareForeignKeys: () => compareForeignKeys,
  create: () => create,
  createAnnotationHelper: () => createAnnotationHelper,
  createEchoReferenceSchema: () => createEchoReferenceSchema,
  createQueueDXN: () => createQueueDXN,
  createSchemaReference: () => createSchemaReference,
  defineHiddenProperty: () => defineHiddenProperty,
  foreignKey: () => foreignKey,
  foreignKeyEquals: () => foreignKeyEquals,
  getEntityKind: () => getEntityKind,
  getLabel: () => getLabel,
  getLabelForObject: () => getLabelForObject,
  getMeta: () => getMeta,
  getObjectDXN: () => getObjectDXN,
  getObjectMeta: () => getObjectMeta,
  getPropertyMetaAnnotation: () => getPropertyMetaAnnotation,
  getRefSavedTarget: () => getRefSavedTarget,
  getReferenceAnnotation: () => getReferenceAnnotation,
  getSchema: () => getSchema,
  getSchemaDXN: () => getSchemaDXN,
  getSchemaReference: () => getSchemaReference,
  getSchemaTypename: () => getSchemaTypename,
  getSchemaVersion: () => getSchemaVersion,
  getType: () => getType,
  getTypeAnnotation: () => getTypeAnnotation,
  getTypeIdentifierAnnotation: () => getTypeIdentifierAnnotation,
  getTypename: () => getTypename,
  isDeleted: () => isDeleted,
  makeTypedEntityClass: () => makeTypedEntityClass,
  objectFromJSON: () => objectFromJSON,
  objectToJSON: () => objectToJSON,
  refFromEncodedReference: () => refFromEncodedReference,
  setRefResolver: () => setRefResolver,
  setSchema: () => setSchema,
  setTypename: () => setTypename
});
module.exports = __toCommonJS(chunk_BRS5374V_exports);
var import_effect = require("effect");
var import_effect2 = require("effect");
var import_effect3 = require("effect");
var import_invariant = require("@dxos/invariant");
var import_keys = require("@dxos/keys");
var import_invariant2 = require("@dxos/invariant");
var import_keys2 = require("@dxos/keys");
var import_util = require("@dxos/util");
var import_effect4 = require("effect");
var import_effect5 = require("@dxos/effect");
var import_invariant3 = require("@dxos/invariant");
var import_keys3 = require("@dxos/keys");
var import_util2 = require("@dxos/util");
var import_invariant4 = require("@dxos/invariant");
var import_keys4 = require("@dxos/keys");
var import_effect6 = require("effect");
var import_effect7 = require("effect");
var import_echo_protocol = require("@dxos/echo-protocol");
var import_invariant5 = require("@dxos/invariant");
var import_util3 = require("@dxos/util");
var import_effect8 = require("effect");
var import_echo_protocol2 = require("@dxos/echo-protocol");
var import_runtime = require("@dxos/echo-signals/runtime");
var import_invariant6 = require("@dxos/invariant");
var import_keys5 = require("@dxos/keys");
var import_util4 = require("@dxos/util");
var import_effect9 = require("effect");
var import_debug = require("@dxos/debug");
var import_echo_protocol3 = require("@dxos/echo-protocol");
var import_invariant7 = require("@dxos/invariant");
var import_keys6 = require("@dxos/keys");
var import_util5 = require("@dxos/util");
var import_debug2 = require("@dxos/debug");
var import_invariant8 = require("@dxos/invariant");
var import_keys7 = require("@dxos/keys");
var import_debug3 = require("@dxos/debug");
var import_effect10 = require("effect");
var import_debug4 = require("@dxos/debug");
var import_invariant9 = require("@dxos/invariant");
var import_keys8 = require("@dxos/keys");
var import_effect11 = require("effect");
var import_keys9 = require("@dxos/keys");
var import_effect12 = require("effect");
var import_invariant10 = require("@dxos/invariant");
var import_effect13 = require("effect");
var import_invariant11 = require("@dxos/invariant");
var import_effect14 = require("effect");
var import_invariant12 = require("@dxos/invariant");
var createAnnotationHelper = (id) => {
  return {
    get: (schema) => import_effect.SchemaAST.getAnnotation(schema, id),
    set: (value) => (schema) => schema.annotations({
      [id]: value
    })
  };
};
var EntityKind = /* @__PURE__ */ function(EntityKind2) {
  EntityKind2["Object"] = "object";
  EntityKind2["Relation"] = "relation";
  return EntityKind2;
}({});
var EntityKindSchema = import_effect2.Schema.Enums(EntityKind);
var TypeIdentifierAnnotationId = Symbol.for("@dxos/schema/annotation/TypeIdentifier");
var getTypeIdentifierAnnotation = (schema) => (0, import_effect3.flow)(import_effect3.SchemaAST.getAnnotation(TypeIdentifierAnnotationId), import_effect3.Option.getOrElse(() => void 0))(schema.ast);
var TypeAnnotationId = Symbol.for("@dxos/schema/annotation/Type");
var Typename = import_effect3.Schema.String.pipe(import_effect3.Schema.pattern(/^[a-zA-Z]\w+\.[a-zA-Z]\w{1,}\/[\w/_-]+$/));
var Version = import_effect3.Schema.String.pipe(import_effect3.Schema.pattern(/^\d+.\d+.\d+$/));
var TypeAnnotation = import_effect3.Schema.Struct({
  kind: import_effect3.Schema.Enums(EntityKind),
  typename: Typename,
  version: Version,
  /**
  * If this is a relation, the schema of the source object.
  * Must be present if entity kind is {@link EntityKind.Relation}.
  */
  sourceSchema: import_effect3.Schema.optional(import_keys.DXN.Schema),
  /**
  * If this is a relation, the schema of the target object.
  * Must be present if entity kind is {@link EntityKind.Relation}.
  */
  targetSchema: import_effect3.Schema.optional(import_keys.DXN.Schema)
});
var getTypeAnnotation = (schema) => {
  (0, import_invariant.assertArgument)(schema != null && schema.ast != null, "invalid schema");
  return (0, import_effect3.flow)(import_effect3.SchemaAST.getAnnotation(TypeAnnotationId), import_effect3.Option.getOrElse(() => void 0))(schema.ast);
};
var getEntityKind = (schema) => getTypeAnnotation(schema)?.kind;
var getSchemaTypename = (schema) => getTypeAnnotation(schema)?.typename;
var getSchemaVersion = (schema) => getTypeAnnotation(schema)?.version;
var PropertyMetaAnnotationId = Symbol.for("@dxos/schema/annotation/PropertyMeta");
var PropertyMeta = (name, value) => {
  return (self) => {
    const existingMeta = self.ast.annotations[PropertyMetaAnnotationId];
    return self.annotations({
      [PropertyMetaAnnotationId]: {
        ...existingMeta,
        [name]: value
      }
    });
  };
};
var getPropertyMetaAnnotation = (prop, name) => (0, import_effect3.pipe)(import_effect3.SchemaAST.getAnnotation(PropertyMetaAnnotationId)(prop.type), import_effect3.Option.map((meta) => meta[name]), import_effect3.Option.getOrElse(() => void 0));
var ReferenceAnnotationId = Symbol.for("@dxos/schema/annotation/Reference");
var getReferenceAnnotation = (schema) => (0, import_effect3.pipe)(import_effect3.SchemaAST.getAnnotation(ReferenceAnnotationId)(schema.ast), import_effect3.Option.getOrElse(() => void 0));
var SchemaMetaSymbol = Symbol.for("@dxos/schema/SchemaMeta");
var LabelAnnotationId = Symbol.for("@dxos/schema/annotation/Label");
var LabelAnnotation = createAnnotationHelper(LabelAnnotationId);
var FieldLookupAnnotationId = Symbol.for("@dxos/schema/annotation/FieldLookup");
var GeneratorAnnotationId = Symbol.for("@dxos/schema/annotation/Generator");
var GeneratorAnnotation = createAnnotationHelper(GeneratorAnnotationId);
var getSchemaDXN = (schema) => {
  (0, import_invariant.assertArgument)(import_effect3.Schema.isSchema(schema), "invalid schema");
  const id = getTypeIdentifierAnnotation(schema);
  if (id) {
    return import_keys.DXN.parse(id);
  }
  const objectAnnotation = getTypeAnnotation(schema);
  if (!objectAnnotation) {
    return void 0;
  }
  return import_keys.DXN.fromTypenameAndVersion(objectAnnotation.typename, objectAnnotation.version);
};
var FIELD_PATH_ANNOTATION = "path";
var FieldPath = (path) => PropertyMeta(FIELD_PATH_ANNOTATION, path);
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/core/echo/echo-schema/src/object/model.ts";
var EntityKindId = Symbol("@dxos/echo/EntityKind");
var SelfDXNId = Symbol("@dxos/echo/Self");
var ATTR_SELF_DXN = "@self";
var TypeId = Symbol("@dxos/echo/Type");
var ATTR_TYPE = "@type";
var SchemaId = Symbol("@dxos/echo/Schema");
var DeletedId = Symbol("@dxos/echo/Deleted");
var ATTR_DELETED = "@deleted";
var MetaId = Symbol("@dxos/echo/Meta");
var ATTR_META = "@meta";
var RelationSourceDXNId = Symbol("@dxos/echo/RelationSourceDXN");
var ATTR_RELATION_SOURCE = "@relationSource";
var RelationTargetDXNId = Symbol("@dxos/echo/RelationTargetDXN");
var ATTR_RELATION_TARGET = "@relationTarget";
var RelationSourceId = Symbol("@dxos/echo/RelationSource");
var RelationTargetId = Symbol("@dxos/echo/RelationTarget");
function assertObjectModelShape(obj) {
  (0, import_invariant2.invariant)(typeof obj === "object" && obj !== null, "Invalid object model: not an object", {
    F: __dxlog_file,
    L: 147,
    S: this,
    A: [
      "typeof obj === 'object' && obj !== null",
      "'Invalid object model: not an object'"
    ]
  });
  (0, import_util.assumeType)(obj);
  (0, import_invariant2.invariant)(import_keys2.ObjectId.isValid(obj.id), "Invalid object model: invalid id", {
    F: __dxlog_file,
    L: 149,
    S: this,
    A: [
      "ObjectId.isValid(obj.id)",
      "'Invalid object model: invalid id'"
    ]
  });
  (0, import_invariant2.invariant)(obj[TypeId] === void 0 || obj[TypeId] instanceof import_keys2.DXN, "Invalid object model: invalid type", {
    F: __dxlog_file,
    L: 150,
    S: this,
    A: [
      "obj[TypeId] === undefined || obj[TypeId] instanceof DXN",
      "'Invalid object model: invalid type'"
    ]
  });
  (0, import_invariant2.invariant)(obj[EntityKindId] === EntityKind.Object || obj[EntityKindId] === EntityKind.Relation, "Invalid object model: invalid entity kind", {
    F: __dxlog_file,
    L: 151,
    S: this,
    A: [
      "obj[EntityKindId] === EntityKind.Object || obj[EntityKindId] === EntityKind.Relation",
      "'Invalid object model: invalid entity kind'"
    ]
  });
  if (obj[EntityKindId] === EntityKind.Relation) {
    (0, import_invariant2.invariant)(obj[RelationSourceDXNId] instanceof import_keys2.DXN, "Invalid object model: invalid relation source", {
      F: __dxlog_file,
      L: 156,
      S: this,
      A: [
        "obj[RelationSourceDXNId] instanceof DXN",
        "'Invalid object model: invalid relation source'"
      ]
    });
    (0, import_invariant2.invariant)(obj[RelationTargetDXNId] instanceof import_keys2.DXN, "Invalid object model: invalid relation target", {
      F: __dxlog_file,
      L: 157,
      S: this,
      A: [
        "obj[RelationTargetDXNId] instanceof DXN",
        "'Invalid object model: invalid relation target'"
      ]
    });
    (0, import_invariant2.invariant)(!(obj[RelationSourceId] instanceof import_keys2.DXN), "Invalid object model: source pointer is a DXN", {
      F: __dxlog_file,
      L: 158,
      S: this,
      A: [
        "!(obj[RelationSourceId] instanceof DXN)",
        "'Invalid object model: source pointer is a DXN'"
      ]
    });
    (0, import_invariant2.invariant)(!(obj[RelationTargetId] instanceof import_keys2.DXN), "Invalid object model: target pointer is a DXN", {
      F: __dxlog_file,
      L: 159,
      S: this,
      A: [
        "!(obj[RelationTargetId] instanceof DXN)",
        "'Invalid object model: target pointer is a DXN'"
      ]
    });
  }
}
var __dxlog_file2 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-schema/src/object/accessors.ts";
var getObjectDXN = (object) => {
  (0, import_invariant3.invariant)(!import_effect4.Schema.isSchema(object), "schema not allowed in this function", {
    F: __dxlog_file2,
    L: 24,
    S: void 0,
    A: [
      "!Schema.isSchema(object)",
      "'schema not allowed in this function'"
    ]
  });
  (0, import_invariant3.assertArgument)(typeof object === "object" && object != null, "expected object");
  (0, import_util2.assumeType)(object);
  if (!import_keys3.ObjectId.isValid(object.id)) {
    throw new TypeError("Object id is not valid.");
  }
  return import_keys3.DXN.fromLocalObjectId(object.id);
};
var getSchema = (obj) => {
  if (obj) {
    return obj[SchemaId];
  }
};
var setSchema = (obj, schema) => {
  Object.defineProperty(obj, SchemaId, {
    value: schema,
    writable: false,
    enumerable: false,
    configurable: false
  });
};
var getLabelForObject = (obj) => {
  const schema = getSchema(obj);
  if (schema) {
    return getLabel(schema, obj);
  }
};
var getLabel = (schema, object) => {
  let annotation = schema.ast.annotations[LabelAnnotationId];
  if (!annotation) {
    return void 0;
  }
  if (!Array.isArray(annotation)) {
    annotation = [
      annotation
    ];
  }
  for (const accessor of annotation) {
    (0, import_invariant3.assertArgument)(typeof accessor === "string", "Label annotation must be a string or an array of strings");
    const value = (0, import_effect5.getField)(object, accessor);
    switch (typeof value) {
      case "string":
      case "number":
      case "boolean":
      case "bigint":
      case "symbol":
        return value.toString();
      case "undefined":
      case "object":
      case "function":
        continue;
    }
  }
  return void 0;
};
var __dxlog_file3 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-schema/src/object/typename.ts";
var getTypename = (obj) => {
  const schema = getSchema(obj);
  if (schema != null) {
    return getSchemaTypename(schema);
  } else {
    const type = getType(obj);
    return type?.asTypeDXN()?.type;
  }
};
var setTypename = (obj, typename) => {
  (0, import_invariant4.invariant)(typename instanceof import_keys4.DXN, "Invalid type.", {
    F: __dxlog_file3,
    L: 34,
    S: void 0,
    A: [
      "typename instanceof DXN",
      "'Invalid type.'"
    ]
  });
  Object.defineProperty(obj, TypeId, {
    value: typename,
    writable: false,
    enumerable: false,
    configurable: false
  });
};
var getType = (obj) => {
  if (!obj) {
    return void 0;
  }
  const type = obj[TypeId];
  if (!type) {
    return void 0;
  }
  (0, import_invariant4.invariant)(type instanceof import_keys4.DXN, "Invalid object.", {
    F: __dxlog_file3,
    L: 58,
    S: void 0,
    A: [
      "type instanceof DXN",
      "'Invalid object.'"
    ]
  });
  return type;
};
var makeTypedEntityClass = (typename, version, baseSchema) => {
  var _a2;
  return class {
    static {
      this.typename = typename;
    }
    static {
      this.version = version;
    }
    static {
      this[_a2] = schemaVariance;
    }
    static {
      this.ast = baseSchema.ast;
    }
    static {
      this.annotations = baseSchema.annotations.bind(baseSchema);
    }
    static {
      this.pipe = baseSchema.pipe.bind(baseSchema);
    }
    // TODO(burdon): Comment required.
    static [(_a2 = import_effect6.Schema.TypeId, Symbol.hasInstance)](obj) {
      return obj != null && getTypename(obj) === typename;
    }
    // TODO(burdon): Throw APIError.
    constructor() {
      throw new Error("Use live(Typename, { ...fields }) to instantiate an object.");
    }
  };
};
var schemaVariance = {
  _A: (_) => _,
  _I: (_) => _,
  _R: (_) => _
};
var __dxlog_file4 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-schema/src/object/meta.ts";
var ObjectMetaSchema = import_effect7.Schema.Struct({
  keys: import_effect7.Schema.mutable(import_effect7.Schema.Array(import_echo_protocol.ForeignKey))
});
var foreignKey = (source, id) => ({
  source,
  id
});
var foreignKeyEquals = (a, b) => a.source === b.source && a.id === b.id;
var getObjectMeta = (object) => {
  return getMeta(object);
};
var getMeta = (obj) => {
  const metadata = obj[MetaId];
  (0, import_invariant5.invariant)(metadata, "ObjectMeta not found.", {
    F: __dxlog_file4,
    L: 44,
    S: void 0,
    A: [
      "metadata",
      "'ObjectMeta not found.'"
    ]
  });
  return metadata;
};
var compareForeignKeys = (a, b) => (0, import_util3.intersection)(getMeta(a).keys, getMeta(b).keys, foreignKeyEquals).length > 0;
var __dxlog_file5 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-schema/src/ref/ref.ts";
var JSON_SCHEMA_ECHO_REF_ID = "/schemas/echo/ref";
var getSchemaReference = (property) => {
  const { $id, reference: { schema: { $ref } = {} } = {} } = property;
  if ($id === JSON_SCHEMA_ECHO_REF_ID && $ref) {
    return {
      typename: import_keys5.DXN.parse($ref).typename
    };
  }
};
var createSchemaReference = (typename) => {
  return {
    $id: JSON_SCHEMA_ECHO_REF_ID,
    reference: {
      schema: {
        $ref: import_keys5.DXN.fromTypename(typename).toString()
      }
    }
  };
};
var RefTypeId = Symbol("@dxos/echo-schema/Ref");
var Ref = (schema) => {
  (0, import_invariant6.assertArgument)(import_effect8.Schema.isSchema(schema), "Must call with an instance of effect-schema");
  const annotation = getTypeAnnotation(schema);
  if (annotation == null) {
    throw new Error("Reference target must be an ECHO schema.");
  }
  return createEchoReferenceSchema(getTypeIdentifierAnnotation(schema), annotation.typename, annotation.version, getSchemaExpectedName(schema.ast));
};
Ref.isRef = (obj) => {
  return obj && typeof obj === "object" && RefTypeId in obj;
};
Ref.hasObjectId = (id) => (ref) => ref.dxn.isLocalObjectId() && ref.dxn.parts[1] === id;
Ref.isRefSchema = (schema) => {
  return Ref.isRefSchemaAST(schema.ast);
};
Ref.isRefSchemaAST = (ast) => {
  return import_effect8.SchemaAST.getAnnotation(ast, ReferenceAnnotationId).pipe(import_effect8.Option.isSome);
};
Ref.make = (obj) => {
  if (typeof obj !== "object" || obj === null) {
    throw new TypeError("Expected: ECHO object.");
  }
  const id = obj.id;
  (0, import_invariant6.invariant)(import_keys5.ObjectId.isValid(id), "Invalid object ID", {
    F: __dxlog_file5,
    L: 188,
    S: void 0,
    A: [
      "ObjectId.isValid(id)",
      "'Invalid object ID'"
    ]
  });
  const dxn = import_echo_protocol2.Reference.localObjectReference(id).toDXN();
  return new RefImpl(dxn, obj);
};
Ref.fromDXN = (dxn) => {
  return new RefImpl(dxn);
};
var createEchoReferenceSchema = (echoId, typename, version, schemaName) => {
  if (!echoId && !typename) {
    throw new TypeError("Either echoId or typename must be provided.");
  }
  const referenceInfo = {
    schema: {
      // TODO(dmaretskyi): Include version?
      $ref: echoId ?? import_keys5.DXN.fromTypename(typename).toString()
    },
    schemaVersion: version
  };
  const refSchema = import_effect8.Schema.declare([], {
    encode: () => {
      return (value) => {
        return import_effect8.Effect.succeed({
          "/": value.dxn.toString()
        });
      };
    },
    decode: () => {
      return (value) => {
        if (Ref.isRef(value)) {
          return import_effect8.Effect.succeed(value);
        }
        if (typeof value !== "object" || value == null || typeof value["/"] !== "string") {
          return import_effect8.Effect.fail(new import_effect8.ParseResult.Unexpected(value, "reference"));
        }
        return import_effect8.Effect.succeed(Ref.fromDXN(import_keys5.DXN.parse(value["/"])));
      };
    }
  }, {
    jsonSchema: {
      $id: JSON_SCHEMA_ECHO_REF_ID,
      reference: referenceInfo
    },
    [ReferenceAnnotationId]: {
      typename: typename ?? "",
      version
    }
  });
  return refSchema;
};
var getSchemaExpectedName = (ast) => {
  return import_effect8.SchemaAST.getIdentifierAnnotation(ast).pipe(import_effect8.Option.orElse(() => import_effect8.SchemaAST.getTitleAnnotation(ast)), import_effect8.Option.orElse(() => import_effect8.SchemaAST.getDescriptionAnnotation(ast)), import_effect8.Option.getOrElse(() => void 0));
};
var _a;
_a = RefTypeId;
var RefImpl = class {
  constructor(dxn, target) {
    this.#resolver = void 0;
    this.#signal = import_runtime.compositeRuntime.createSignal();
    this.#target = void 0;
    this.#resolverCallback = () => {
      this.#signal.notifyWrite();
    };
    this[_a] = refVariance;
    this.#dxn = dxn;
    this.#target = target;
  }
  #dxn;
  #resolver;
  #signal;
  #target;
  #resolverCallback;
  /**
  * @inheritdoc
  */
  get dxn() {
    return this.#dxn;
  }
  /**
  * @inheritdoc
  */
  get target() {
    this.#signal.notifyRead();
    if (this.#target) {
      return this.#target;
    }
    (0, import_invariant6.invariant)(this.#resolver, "Resolver is not set", {
      F: __dxlog_file5,
      L: 334,
      S: this,
      A: [
        "this.#resolver",
        "'Resolver is not set'"
      ]
    });
    return this.#resolver.resolveSync(this.#dxn, true, this.#resolverCallback);
  }
  /**
  * @inheritdoc
  */
  async load() {
    (0, import_invariant6.invariant)(this.#resolver, "Resolver is not set", {
      F: __dxlog_file5,
      L: 342,
      S: this,
      A: [
        "this.#resolver",
        "'Resolver is not set'"
      ]
    });
    const obj = await this.#resolver.resolve(this.#dxn);
    if (obj == null) {
      throw new Error("Object not found");
    }
    return obj;
  }
  /**
  * @inheritdoc
  */
  async tryLoad() {
    (0, import_invariant6.invariant)(this.#resolver, "Resolver is not set", {
      F: __dxlog_file5,
      L: 354,
      S: this,
      A: [
        "this.#resolver",
        "'Resolver is not set'"
      ]
    });
    return await this.#resolver.resolve(this.#dxn);
  }
  /**
  * Do not inline the target object in the reference.
  * Makes .target unavailable unless the reference is connected to a database context.
  */
  noInline() {
    this.#target = void 0;
    return this;
  }
  encode() {
    return {
      "/": this.#dxn.toString(),
      ...this.#target ? {
        target: this.#target
      } : {}
    };
  }
  /**
  * Serializes the reference to a JSON object.
  * The serialization format is compatible with the IPLD-style encoded references.
  * When a reference has a saved target (i.e. the target or object holding the reference is not in the database),
  * the target is included in the serialized object.
  */
  toJSON() {
    return this.encode();
  }
  toString() {
    if (this.#target) {
      return `Ref(${this.#target.toString()})`;
    }
    return `Ref(${this.#dxn.toString()})`;
  }
  /**
  * Internal method to set the resolver.
  * @internal
  */
  _setResolver(resolver) {
    this.#resolver = resolver;
  }
  /**
  * Internal method to get the saved target.
  * Not the same as `target` which is resolved from the resolver.
  * @internal
  */
  _getSavedTarget() {
    return this.#target;
  }
};
var setRefResolver = (ref, resolver) => {
  (0, import_invariant6.invariant)(ref instanceof RefImpl, "Ref is not an instance of RefImpl", {
    F: __dxlog_file5,
    L: 416,
    S: void 0,
    A: [
      "ref instanceof RefImpl",
      "'Ref is not an instance of RefImpl'"
    ]
  });
  ref._setResolver(resolver);
};
var getRefSavedTarget = (ref) => {
  (0, import_invariant6.invariant)(ref instanceof RefImpl, "Ref is not an instance of RefImpl", {
    F: __dxlog_file5,
    L: 424,
    S: void 0,
    A: [
      "ref instanceof RefImpl",
      "'Ref is not an instance of RefImpl'"
    ]
  });
  return ref._getSavedTarget();
};
var refVariance = {
  _T: null
};
var refFromEncodedReference = (encodedReference, resolver) => {
  const dxn = import_keys5.DXN.parse(encodedReference["/"]);
  const ref = new RefImpl(dxn);
  if (resolver) {
    setRefResolver(ref, resolver);
  }
  return ref;
};
var StaticRefResolver = class {
  constructor() {
    this.objects = /* @__PURE__ */ new Map();
    this.schemas = /* @__PURE__ */ new Map();
  }
  addObject(obj) {
    this.objects.set(obj.id, obj);
    return this;
  }
  addSchema(schema) {
    const dxn = getSchemaDXN(schema);
    (0, import_invariant6.invariant)(dxn, "Schema has no DXN", {
      F: __dxlog_file5,
      L: 456,
      S: this,
      A: [
        "dxn",
        "'Schema has no DXN'"
      ]
    });
    this.schemas.set(dxn.toString(), schema);
    return this;
  }
  resolveSync(dxn, _load, _onLoad) {
    const id = dxn?.asEchoDXN()?.echoId;
    if (id == null) {
      return void 0;
    }
    return this.objects.get(id);
  }
  async resolve(dxn) {
    const id = dxn?.asEchoDXN()?.echoId;
    if (id == null) {
      return void 0;
    }
    return this.objects.get(id);
  }
  async resolveSchema(dxn) {
    return this.schemas.get(dxn.toString());
  }
};
var RefArray = Object.freeze({
  /**
  * @returns all resolved targets.
  */
  targets: (refs) => {
    return refs.map((ref) => ref.target).filter(import_util4.isNonNullable);
  },
  /**
  * Load all referenced objects.
  */
  loadAll: (refs) => {
    return Promise.all(refs.map((ref) => ref.load()));
  },
  /**
  * Removes the ref with the given id.
  */
  removeById: (refs, id) => {
    const index = refs.findIndex(Ref.hasObjectId(id));
    if (index >= 0) {
      refs.splice(index, 1);
    }
  }
});
var defineHiddenProperty = (object, key, value) => {
  Object.defineProperty(object, key, {
    enumerable: false,
    configurable: true,
    value
  });
};
var __dxlog_file6 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-schema/src/object/json-serializer.ts";
var objectToJSON = (obj) => {
  const typename = getType(obj)?.toString();
  (0, import_invariant7.invariant)(typename && typeof typename === "string", void 0, {
    F: __dxlog_file6,
    L: 48,
    S: void 0,
    A: [
      "typename && typeof typename === 'string'",
      ""
    ]
  });
  return typedJsonSerializer.call(obj);
};
var objectFromJSON = async (jsonData, { refResolver } = {}) => {
  (0, import_util5.assumeType)(jsonData);
  (0, import_invariant7.assertArgument)(typeof jsonData === "object" && jsonData !== null, "expect object");
  (0, import_invariant7.assertArgument)(typeof jsonData[ATTR_TYPE] === "string", "expected object to have a type");
  (0, import_invariant7.assertArgument)(typeof jsonData.id === "string", "expected object to have an id");
  const type = import_keys6.DXN.parse(jsonData[ATTR_TYPE]);
  const schema = await refResolver?.resolveSchema(type);
  (0, import_invariant7.invariant)(schema === void 0 || import_effect9.Schema.isSchema(schema), void 0, {
    F: __dxlog_file6,
    L: 70,
    S: void 0,
    A: [
      "schema === undefined || Schema.isSchema(schema)",
      ""
    ]
  });
  let obj;
  if (schema != null) {
    obj = await schema.pipe(import_effect9.Schema.decodeUnknownPromise)(jsonData);
    if (refResolver) {
      setRefResolverOnData(obj, refResolver);
    }
  } else {
    obj = decodeGeneric(jsonData, {
      refResolver
    });
  }
  (0, import_invariant7.invariant)(import_keys6.ObjectId.isValid(obj.id), "Invalid object id", {
    F: __dxlog_file6,
    L: 82,
    S: void 0,
    A: [
      "ObjectId.isValid(obj.id)",
      "'Invalid object id'"
    ]
  });
  setTypename(obj, type);
  if (schema) {
    setSchema(obj, schema);
  }
  const isRelation = typeof jsonData[ATTR_RELATION_SOURCE] === "string" || typeof jsonData[ATTR_RELATION_TARGET] === "string";
  if (isRelation) {
    const sourceDxn = import_keys6.DXN.parse(jsonData[ATTR_RELATION_SOURCE] ?? (0, import_debug.raise)(new TypeError("Missing relation source")));
    const targetDxn = import_keys6.DXN.parse(jsonData[ATTR_RELATION_TARGET] ?? (0, import_debug.raise)(new TypeError("Missing relation target")));
    const source = await refResolver?.resolve(sourceDxn);
    const target = await refResolver?.resolve(targetDxn);
    defineHiddenProperty(obj, EntityKindId, EntityKind.Relation);
    defineHiddenProperty(obj, RelationSourceDXNId, sourceDxn);
    defineHiddenProperty(obj, RelationTargetDXNId, targetDxn);
    defineHiddenProperty(obj, RelationSourceId, source);
    defineHiddenProperty(obj, RelationTargetId, target);
  } else {
    defineHiddenProperty(obj, EntityKindId, EntityKind.Object);
  }
  if (typeof jsonData[ATTR_META] === "object") {
    const meta = await ObjectMetaSchema.pipe(import_effect9.Schema.decodeUnknownPromise)(jsonData[ATTR_META]);
    (0, import_invariant7.invariant)(Array.isArray(meta.keys), void 0, {
      F: __dxlog_file6,
      L: 112,
      S: void 0,
      A: [
        "Array.isArray(meta.keys)",
        ""
      ]
    });
    defineHiddenProperty(obj, MetaId, meta);
  }
  assertObjectModelShape(obj);
  (0, import_invariant7.invariant)(obj[ATTR_TYPE] === void 0, "Invalid object model", {
    F: __dxlog_file6,
    L: 118,
    S: void 0,
    A: [
      "(obj as any)[ATTR_TYPE] === undefined",
      "'Invalid object model'"
    ]
  });
  (0, import_invariant7.invariant)(obj[ATTR_SELF_DXN] === void 0, "Invalid object model", {
    F: __dxlog_file6,
    L: 119,
    S: void 0,
    A: [
      "(obj as any)[ATTR_SELF_DXN] === undefined",
      "'Invalid object model'"
    ]
  });
  (0, import_invariant7.invariant)(obj[ATTR_DELETED] === void 0, "Invalid object model", {
    F: __dxlog_file6,
    L: 120,
    S: void 0,
    A: [
      "(obj as any)[ATTR_DELETED] === undefined",
      "'Invalid object model'"
    ]
  });
  (0, import_invariant7.invariant)(obj[ATTR_RELATION_SOURCE] === void 0, "Invalid object model", {
    F: __dxlog_file6,
    L: 121,
    S: void 0,
    A: [
      "(obj as any)[ATTR_RELATION_SOURCE] === undefined",
      "'Invalid object model'"
    ]
  });
  (0, import_invariant7.invariant)(obj[ATTR_RELATION_TARGET] === void 0, "Invalid object model", {
    F: __dxlog_file6,
    L: 122,
    S: void 0,
    A: [
      "(obj as any)[ATTR_RELATION_TARGET] === undefined",
      "'Invalid object model'"
    ]
  });
  (0, import_invariant7.invariant)(obj[ATTR_META] === void 0, "Invalid object model", {
    F: __dxlog_file6,
    L: 123,
    S: void 0,
    A: [
      "(obj as any)[ATTR_META] === undefined",
      "'Invalid object model'"
    ]
  });
  return obj;
};
var decodeGeneric = (jsonData, options) => {
  const { [ATTR_TYPE]: _type, [ATTR_META]: _meta, [ATTR_DELETED]: _deleted, [ATTR_RELATION_SOURCE]: _relationSource, [ATTR_RELATION_TARGET]: _relationTarget, [ATTR_SELF_DXN]: _selfDxn, ...props } = jsonData;
  return (0, import_util5.deepMapValues)(props, (value, recurse) => {
    if ((0, import_echo_protocol3.isEncodedReference)(value)) {
      return refFromEncodedReference(value, options.refResolver);
    }
    return recurse(value);
  });
};
var setRefResolverOnData = (obj, refResolver) => {
  const go = (value) => {
    if (Ref.isRef(value)) {
      setRefResolver(value, refResolver);
    } else {
      (0, import_util5.visitValues)(value, go);
    }
  };
  go(obj);
};
var attachTypedJsonSerializer = (obj) => {
  const descriptor = Object.getOwnPropertyDescriptor(obj, "toJSON");
  if (descriptor) {
    return;
  }
  Object.defineProperty(obj, "toJSON", {
    value: typedJsonSerializer,
    writable: false,
    enumerable: false,
    configurable: false
  });
};
var typedJsonSerializer = function() {
  const { id, [TypeId]: typename, [MetaId]: meta, ...rest } = this;
  const result = {
    id,
    [ATTR_TYPE]: typename.toString()
  };
  if (this[RelationSourceDXNId]) {
    const sourceDXN = this[RelationSourceDXNId];
    (0, import_invariant7.invariant)(sourceDXN instanceof import_keys6.DXN, void 0, {
      F: __dxlog_file6,
      L: 185,
      S: this,
      A: [
        "sourceDXN instanceof DXN",
        ""
      ]
    });
    result[ATTR_RELATION_SOURCE] = sourceDXN.toString();
  }
  if (this[RelationTargetDXNId]) {
    const targetDXN = this[RelationTargetDXNId];
    (0, import_invariant7.invariant)(targetDXN instanceof import_keys6.DXN, void 0, {
      F: __dxlog_file6,
      L: 190,
      S: this,
      A: [
        "targetDXN instanceof DXN",
        ""
      ]
    });
    result[ATTR_RELATION_TARGET] = targetDXN.toString();
  }
  if (meta) {
    result[ATTR_META] = serializeData(meta);
  }
  Object.assign(result, serializeData(rest));
  return result;
};
var serializeData = (data) => {
  return (0, import_util5.deepMapValues)(data, (value, recurse) => {
    if (Ref.isRef(value)) {
      return value.noInline().encode();
    }
    return recurse(value);
  });
};
var attachedTypedObjectInspector = (obj) => {
  const descriptor = Object.getOwnPropertyDescriptor(obj, import_debug3.inspectCustom);
  if (descriptor) {
    return;
  }
  Object.defineProperty(obj, import_debug3.inspectCustom, {
    value: typedObjectInspectFunction,
    writable: false,
    enumerable: false,
    configurable: true
  });
};
var typedObjectInspectFunction = function(depth, options, inspect) {
  const { id, ...props } = this;
  return inspect({
    id,
    [ATTR_TYPE]: getType(this),
    ...props,
    [ATTR_META]: this[MetaId]
  }, options);
};
var create = (schema, data) => {
  const annotation = getTypeAnnotation(schema);
  if (!annotation) {
    throw new Error("Schema is not an object schema");
  }
  (0, import_invariant8.assertArgument)(!("@type" in data), "@type is not allowed");
  (0, import_invariant8.assertArgument)(!(RelationSourceDXNId in data), "Relation source DXN is not allowed in the constructor");
  (0, import_invariant8.assertArgument)(!(RelationTargetDXNId in data), "Relation target DXN is not allowed in the constructor");
  (0, import_invariant8.assertArgument)(RelationSourceId in data === RelationTargetId in data, "Relation source and target must be provided together");
  const obj = {
    ...data,
    id: data.id ?? import_keys7.ObjectId.random()
  };
  const kind = RelationSourceId in data ? EntityKind.Relation : EntityKind.Object;
  defineHiddenProperty(obj, EntityKindId, kind);
  setTypename(obj, getSchemaDXN(schema) ?? (0, import_invariant8.failedInvariant)("Missing schema DXN"));
  setSchema(obj, schema);
  attachTypedJsonSerializer(obj);
  attachedTypedObjectInspector(obj);
  defineHiddenProperty(obj, MetaId, {
    keys: []
  });
  if (kind === EntityKind.Relation) {
    const sourceDXN = getObjectDXN(data[RelationSourceId]) ?? (0, import_debug2.raise)(new Error("Unresolved relation source"));
    const targetDXN = getObjectDXN(data[RelationTargetId]) ?? (0, import_debug2.raise)(new Error("Unresolved relation target"));
    defineHiddenProperty(obj, RelationSourceDXNId, sourceDXN);
    defineHiddenProperty(obj, RelationTargetDXNId, targetDXN);
  }
  assertObjectModelShape(obj);
  return obj;
};
var __dxlog_file7 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-schema/src/object/entity.ts";
var EchoObject = ({ typename, version }) => {
  return (self) => {
    (0, import_invariant9.invariant)(typeof TypeAnnotationId === "symbol", "Sanity.", {
      F: __dxlog_file7,
      L: 33,
      S: void 0,
      A: [
        "typeof TypeAnnotationId === 'symbol'",
        "'Sanity.'"
      ]
    });
    (0, import_invariant9.invariant)(import_effect10.SchemaAST.isTypeLiteral(self.ast), "Schema must be a TypeLiteral.", {
      F: __dxlog_file7,
      L: 34,
      S: void 0,
      A: [
        "SchemaAST.isTypeLiteral(self.ast)",
        "'Schema must be a TypeLiteral.'"
      ]
    });
    const schemaWithId = import_effect10.Schema.extend(import_effect10.Schema.mutable(self), import_effect10.Schema.Struct({
      id: import_effect10.Schema.String
    }));
    const ast = import_effect10.SchemaAST.annotations(schemaWithId.ast, {
      // TODO(dmaretskyi): `extend` kills the annotations.
      ...self.ast.annotations,
      [TypeAnnotationId]: {
        kind: EntityKind.Object,
        typename,
        version
      }
    });
    return makeEchoObjectSchema(
      /* self.fields, */
      ast,
      typename,
      version
    );
  };
};
var getDXNForRelationSchemaRef = (schema) => {
  const identifier = getTypeIdentifierAnnotation(schema);
  if (identifier) {
    return identifier;
  }
  const typename = getSchemaTypename(schema);
  if (!typename) {
    throw new Error("Schema must have a typename");
  }
  return import_keys8.DXN.fromTypename(typename).toString();
};
var EchoRelation = (options) => {
  const sourceDXN = getDXNForRelationSchemaRef(options.source);
  const targetDXN = getDXNForRelationSchemaRef(options.target);
  if (getEntityKind(options.source) !== EntityKind.Object) {
    (0, import_debug4.raise)(new Error("Source schema must be an echo object schema."));
  }
  if (getEntityKind(options.target) !== EntityKind.Object) {
    (0, import_debug4.raise)(new Error("Target schema must be an echo object schema."));
  }
  return (self) => {
    (0, import_invariant9.invariant)(import_effect10.SchemaAST.isTypeLiteral(self.ast), "Schema must be a TypeLiteral.", {
      F: __dxlog_file7,
      L: 89,
      S: void 0,
      A: [
        "SchemaAST.isTypeLiteral(self.ast)",
        "'Schema must be a TypeLiteral.'"
      ]
    });
    const schemaWithId = import_effect10.Schema.extend(import_effect10.Schema.mutable(self), import_effect10.Schema.Struct({
      id: import_effect10.Schema.String
    }));
    const ast = import_effect10.SchemaAST.annotations(schemaWithId.ast, {
      // TODO(dmaretskyi): `extend` kills the annotations.
      ...self.ast.annotations,
      [TypeAnnotationId]: {
        kind: EntityKind.Relation,
        typename: options.typename,
        version: options.version,
        sourceSchema: sourceDXN,
        targetSchema: targetDXN
      }
    });
    return makeEchoObjectSchema(
      /* self.fields, */
      ast,
      options.typename,
      options.version
    );
  };
};
var makeEchoObjectSchema = (ast, typename, version) => {
  return class EchoObjectSchemaClass extends import_effect10.Schema.make(ast) {
    static {
      this.typename = typename;
    }
    static {
      this.version = version;
    }
    static annotations(annotations) {
      const schema = import_effect10.Schema.make(ast).annotations(annotations);
      return makeEchoObjectSchema(
        /* fields, */
        schema.ast,
        typename,
        version
      );
    }
    // static make(
    //   props: RequiredKeys<Schema.TypeLiteral.Constructor<Fields, []>> extends never
    //     ? void | Simplify<Schema.TypeLiteral.Constructor<Fields, []>>
    //     : Simplify<Schema.TypeLiteral.Constructor<Fields, []>>,
    //   options?: MakeOptions,
    // ): Simplify<Schema.TypeLiteral.Type<Fields, []>> {
    //   const propsWithDefaults: any = _lazilyMergeDefaults(fields, { ...(props as any) });
    //   return _getDisableValidationMakeOption(options)
    //     ? propsWithDefaults
    //     : ParseResult.validateSync(this)(propsWithDefaults);
    // }
    static instanceOf(value) {
      return import_effect10.Schema.is(this)(value);
    }
  };
};
var EXPANDO_TYPENAME = "dxos.org/type/Expando";
var ExpandoSchema = import_effect11.Schema.Struct({}, {
  key: import_effect11.Schema.String,
  value: import_effect11.Schema.Any
}).pipe(EchoObject({
  typename: EXPANDO_TYPENAME,
  version: "0.1.0"
}));
var Expando = ExpandoSchema;
var createQueueDXN = (spaceId = import_keys9.SpaceId.random(), queueId = import_keys9.ObjectId.random()) => new import_keys9.DXN(import_keys9.DXN.kind.QUEUE, [
  import_keys9.QueueSubspaceTags.DATA,
  spaceId,
  queueId
]);
var __dxlog_file8 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-schema/src/object/typed-object.ts";
var TypedObject = ({ typename: _typename, version: _version, disableValidation }) => {
  const typename = Typename.make(_typename, {
    disableValidation
  });
  const version = Version.make(_version, {
    disableValidation
  });
  return (fields, options) => {
    const schema = options?.record ? import_effect12.Schema.Struct(fields, {
      key: import_effect12.Schema.String,
      value: import_effect12.Schema.Any
    }) : import_effect12.Schema.Struct(fields);
    const typeSchema = import_effect12.Schema.extend(import_effect12.Schema.mutable(options?.partial ? import_effect12.Schema.partial(schema) : schema), import_effect12.Schema.Struct({
      id: import_effect12.Schema.String
    }));
    (0, import_invariant10.invariant)(typeof EntityKind.Object === "string", void 0, {
      F: __dxlog_file8,
      L: 64,
      S: void 0,
      A: [
        "typeof EntityKind.Object === 'string'",
        ""
      ]
    });
    const annotatedSchema = typeSchema.annotations({
      [TypeAnnotationId]: {
        kind: EntityKind.Object,
        typename,
        version
      }
    });
    return class TypedObject extends makeTypedEntityClass(typename, version, annotatedSchema) {
    };
  };
};
var __dxlog_file9 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-schema/src/object/typed-relation.ts";
var TypedRelation = ({ typename: _typename, version: _version, disableValidation }) => {
  const typename = Typename.make(_typename, {
    disableValidation
  });
  const version = Version.make(_version, {
    disableValidation
  });
  return (fields, options) => {
    const schema = options?.record ? import_effect13.Schema.Struct(fields, {
      key: import_effect13.Schema.String,
      value: import_effect13.Schema.Any
    }) : import_effect13.Schema.Struct(fields);
    const typeSchema = import_effect13.Schema.extend(import_effect13.Schema.mutable(options?.partial ? import_effect13.Schema.partial(schema) : schema), import_effect13.Schema.Struct({
      id: import_effect13.Schema.String
    }));
    (0, import_invariant11.invariant)(typeof EntityKind.Relation === "string", void 0, {
      F: __dxlog_file9,
      L: 68,
      S: void 0,
      A: [
        "typeof EntityKind.Relation === 'string'",
        ""
      ]
    });
    const annotatedSchema = typeSchema.annotations({
      [TypeAnnotationId]: {
        kind: EntityKind.Relation,
        typename,
        version
      }
    });
    return class TypedRelation extends makeTypedEntityClass(typename, version, annotatedSchema) {
    };
  };
};
var isDeleted = (obj) => {
  if (obj[DeletedId] === void 0) {
    throw new Error("Object does not support deletion marker");
  }
  return obj[DeletedId] ?? false;
};
var __dxlog_file10 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-schema/src/object/schema-validator.ts";
var SchemaValidator = class {
  /**
  * Recursively check that schema specifies constructions we can handle.
  * Validates there are no ambiguous discriminated union types.
  */
  static validateSchema(schema) {
    const visitAll = (nodes) => nodes.forEach((node) => this.validateSchema(import_effect14.Schema.make(node)));
    if (import_effect14.SchemaAST.isUnion(schema.ast)) {
      const typeAstList = schema.ast.types.filter((type) => import_effect14.SchemaAST.isTypeLiteral(type));
      if (typeAstList.length > 1) {
        getTypeDiscriminators(typeAstList);
      }
      visitAll(typeAstList);
    } else if (import_effect14.SchemaAST.isTupleType(schema.ast)) {
      const positionalTypes = schema.ast.elements.map((t) => t.type);
      const allTypes = positionalTypes.concat(schema.ast.rest.map((t) => t.type));
      visitAll(allTypes);
    } else if (import_effect14.SchemaAST.isTypeLiteral(schema.ast)) {
      visitAll(import_effect14.SchemaAST.getPropertySignatures(schema.ast).map((p) => p.type));
    }
  }
  static hasTypeAnnotation(rootObjectSchema, property, annotation) {
    try {
      let type = this.getPropertySchema(rootObjectSchema, [
        property
      ]);
      if (import_effect14.SchemaAST.isTupleType(type.ast)) {
        type = this.getPropertySchema(rootObjectSchema, [
          property,
          "0"
        ]);
      }
      return type.ast.annotations[annotation] != null;
    } catch (err) {
      return false;
    }
  }
  static getPropertySchema(rootObjectSchema, propertyPath, getProperty = () => null) {
    let schema = rootObjectSchema;
    for (let i = 0; i < propertyPath.length; i++) {
      const propertyName = propertyPath[i];
      const tupleAst = unwrapArray(schema.ast);
      if (tupleAst != null) {
        schema = getArrayElementSchema(tupleAst, propertyName);
      } else {
        const propertyType = getPropertyType(schema.ast, propertyName.toString(), (propertyName2) => getProperty([
          ...propertyPath.slice(0, i),
          propertyName2
        ]));
        if (propertyType == null) {
          throw new TypeError(`unknown property: ${String(propertyName)} on object. Path: ${propertyPath}`);
        }
        schema = import_effect14.Schema.make(propertyType).annotations(propertyType.annotations);
      }
    }
    return schema;
  }
  static getTargetPropertySchema(target, prop) {
    const schema = target[SchemaId];
    (0, import_invariant12.invariant)(schema, "target has no schema", {
      F: __dxlog_file10,
      L: 81,
      S: this,
      A: [
        "schema",
        "'target has no schema'"
      ]
    });
    const arrayAst = unwrapArray(schema.ast);
    if (arrayAst != null) {
      return getArrayElementSchema(arrayAst, prop);
    }
    const propertyType = getPropertyType(schema.ast, prop.toString(), (prop2) => target[prop2]);
    if (propertyType == null) {
      return import_effect14.Schema.Any;
    }
    (0, import_invariant12.invariant)(propertyType, `invalid property: ${prop.toString()}`, {
      F: __dxlog_file10,
      L: 92,
      S: this,
      A: [
        "propertyType",
        "`invalid property: ${prop.toString()}`"
      ]
    });
    return import_effect14.Schema.make(propertyType);
  }
};
var getArrayElementSchema = (tupleAst, property) => {
  const elementIndex = typeof property === "string" ? parseInt(property, 10) : Number.NaN;
  if (Number.isNaN(elementIndex)) {
    (0, import_invariant12.invariant)(property === "length", `invalid array property: ${String(property)}`, {
      F: __dxlog_file10,
      L: 108,
      S: void 0,
      A: [
        "property === 'length'",
        "`invalid array property: ${String(property)}`"
      ]
    });
    return import_effect14.Schema.Number;
  }
  if (elementIndex < tupleAst.elements.length) {
    const elementType = tupleAst.elements[elementIndex].type;
    return import_effect14.Schema.make(elementType).annotations(elementType.annotations);
  }
  const restType = tupleAst.rest;
  return import_effect14.Schema.make(restType[0].type).annotations(restType[0].annotations);
};
var flattenUnion = (typeAst) => import_effect14.SchemaAST.isUnion(typeAst) ? typeAst.types.flatMap(flattenUnion) : [
  typeAst
];
var getProperties = (typeAst, getTargetPropertyFn) => {
  const astCandidates = flattenUnion(typeAst);
  const typeAstList = astCandidates.filter((type) => import_effect14.SchemaAST.isTypeLiteral(type));
  if (typeAstList.length === 0) {
    return [];
  }
  if (typeAstList.length === 1) {
    return import_effect14.SchemaAST.getPropertySignatures(typeAstList[0]);
  }
  const typeDiscriminators = getTypeDiscriminators(typeAstList);
  const targetPropertyValue = getTargetPropertyFn(String(typeDiscriminators[0].name));
  const typeIndex = typeDiscriminators.findIndex((p) => targetPropertyValue === p.type.literal);
  (0, import_invariant12.invariant)(typeIndex !== -1, "discriminator field not set on target", {
    F: __dxlog_file10,
    L: 139,
    S: void 0,
    A: [
      "typeIndex !== -1",
      "'discriminator field not set on target'"
    ]
  });
  return import_effect14.SchemaAST.getPropertySignatures(typeAstList[typeIndex]);
};
var getPropertyType = (ast, propertyName, getTargetPropertyFn) => {
  const anyOrObject = unwrapAst(ast, (candidate) => import_effect14.SchemaAST.isAnyKeyword(candidate) || import_effect14.SchemaAST.isObjectKeyword(candidate));
  if (anyOrObject != null) {
    return ast;
  }
  const typeOrDiscriminatedUnion = unwrapAst(ast, (t) => {
    return import_effect14.SchemaAST.isTypeLiteral(t) || import_effect14.SchemaAST.isUnion(t) && t.types.some((t2) => import_effect14.SchemaAST.isTypeLiteral(t2));
  });
  if (typeOrDiscriminatedUnion == null) {
    return null;
  }
  const targetProperty = getProperties(typeOrDiscriminatedUnion, getTargetPropertyFn).find((p) => p.name === propertyName);
  if (targetProperty != null) {
    return unwrapAst(targetProperty.type);
  }
  const indexSignatureType = unwrapAst(ast, import_effect14.SchemaAST.isTypeLiteral);
  if (indexSignatureType && import_effect14.SchemaAST.isTypeLiteral(indexSignatureType) && indexSignatureType.indexSignatures.length > 0) {
    return unwrapAst(indexSignatureType.indexSignatures[0].type);
  }
  return null;
};
var getTypeDiscriminators = (typeAstList) => {
  const discriminatorPropCandidates = typeAstList.flatMap(import_effect14.SchemaAST.getPropertySignatures).filter((p) => import_effect14.SchemaAST.isLiteral(p.type));
  const propertyName = discriminatorPropCandidates[0].name;
  const isValidDiscriminator = discriminatorPropCandidates.every((p) => p.name === propertyName && !p.isOptional);
  const everyTypeHasDiscriminator = discriminatorPropCandidates.length === typeAstList.length;
  const isDiscriminatedUnion = isValidDiscriminator && everyTypeHasDiscriminator;
  (0, import_invariant12.invariant)(isDiscriminatedUnion, "type ambiguity: every type in a union must have a single unique-literal field", {
    F: __dxlog_file10,
    L: 190,
    S: void 0,
    A: [
      "isDiscriminatedUnion",
      "'type ambiguity: every type in a union must have a single unique-literal field'"
    ]
  });
  return discriminatorPropCandidates;
};
var unwrapAst = (rootAst, predicate) => {
  let ast = rootAst;
  while (ast != null) {
    if (predicate?.(ast)) {
      return ast;
    }
    if (import_effect14.SchemaAST.isUnion(ast)) {
      const next = ast.types.find((t) => predicate != null && predicate(t) || import_effect14.SchemaAST.isSuspend(t));
      if (next != null) {
        ast = next;
        continue;
      }
    }
    if (import_effect14.SchemaAST.isSuspend(ast)) {
      ast = ast.f();
    } else {
      return predicate == null ? ast : null;
    }
  }
  return null;
};
var unwrapArray = (ast) => unwrapAst(ast, import_effect14.SchemaAST.isTupleType);
var checkIdNotPresentOnSchema = (schema) => {
  (0, import_invariant12.invariant)(import_effect14.SchemaAST.isTypeLiteral(schema.ast), void 0, {
    F: __dxlog_file10,
    L: 233,
    S: void 0,
    A: [
      "SchemaAST.isTypeLiteral(schema.ast)",
      ""
    ]
  });
  const idProperty = import_effect14.SchemaAST.getPropertySignatures(schema.ast).find((prop) => prop.name === "id");
  if (idProperty != null) {
    throw new Error('"id" property name is reserved');
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ATTR_DELETED,
  ATTR_META,
  ATTR_RELATION_SOURCE,
  ATTR_RELATION_TARGET,
  ATTR_SELF_DXN,
  ATTR_TYPE,
  DeletedId,
  EXPANDO_TYPENAME,
  EchoObject,
  EchoRelation,
  EntityKind,
  EntityKindId,
  EntityKindSchema,
  Expando,
  FIELD_PATH_ANNOTATION,
  FieldLookupAnnotationId,
  FieldPath,
  GeneratorAnnotation,
  GeneratorAnnotationId,
  JSON_SCHEMA_ECHO_REF_ID,
  LabelAnnotation,
  LabelAnnotationId,
  MetaId,
  ObjectMetaSchema,
  PropertyMeta,
  PropertyMetaAnnotationId,
  Ref,
  RefArray,
  RefImpl,
  RefTypeId,
  ReferenceAnnotationId,
  RelationSourceDXNId,
  RelationSourceId,
  RelationTargetDXNId,
  RelationTargetId,
  SchemaId,
  SchemaMetaSymbol,
  SchemaValidator,
  SelfDXNId,
  StaticRefResolver,
  TypeAnnotation,
  TypeAnnotationId,
  TypeId,
  TypeIdentifierAnnotationId,
  TypedObject,
  TypedRelation,
  Typename,
  Version,
  assertObjectModelShape,
  attachTypedJsonSerializer,
  checkIdNotPresentOnSchema,
  compareForeignKeys,
  create,
  createAnnotationHelper,
  createEchoReferenceSchema,
  createQueueDXN,
  createSchemaReference,
  defineHiddenProperty,
  foreignKey,
  foreignKeyEquals,
  getEntityKind,
  getLabel,
  getLabelForObject,
  getMeta,
  getObjectDXN,
  getObjectMeta,
  getPropertyMetaAnnotation,
  getRefSavedTarget,
  getReferenceAnnotation,
  getSchema,
  getSchemaDXN,
  getSchemaReference,
  getSchemaTypename,
  getSchemaVersion,
  getType,
  getTypeAnnotation,
  getTypeIdentifierAnnotation,
  getTypename,
  isDeleted,
  makeTypedEntityClass,
  objectFromJSON,
  objectToJSON,
  refFromEncodedReference,
  setRefResolver,
  setSchema,
  setTypename
});
//# sourceMappingURL=chunk-BRS5374V.cjs.map
