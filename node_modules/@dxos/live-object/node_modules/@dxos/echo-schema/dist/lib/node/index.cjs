"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var node_exports = {};
__export(node_exports, {
  ATTR_DELETED: () => import_chunk_BRS5374V.ATTR_DELETED,
  ATTR_META: () => import_chunk_BRS5374V.ATTR_META,
  ATTR_RELATION_SOURCE: () => import_chunk_BRS5374V.ATTR_RELATION_SOURCE,
  ATTR_RELATION_TARGET: () => import_chunk_BRS5374V.ATTR_RELATION_TARGET,
  ATTR_SELF_DXN: () => import_chunk_BRS5374V.ATTR_SELF_DXN,
  ATTR_TYPE: () => import_chunk_BRS5374V.ATTR_TYPE,
  Currency: () => Currency,
  CurrencyAnnotationId: () => CurrencyAnnotationId,
  DecimalPrecision: () => DecimalPrecision,
  DeletedId: () => import_chunk_BRS5374V.DeletedId,
  ECHO_ANNOTATIONS_NS_DEPRECATED_KEY: () => ECHO_ANNOTATIONS_NS_DEPRECATED_KEY,
  ECHO_ANNOTATIONS_NS_KEY: () => ECHO_ANNOTATIONS_NS_KEY,
  EXPANDO_TYPENAME: () => import_chunk_BRS5374V.EXPANDO_TYPENAME,
  EchoObject: () => import_chunk_BRS5374V.EchoObject,
  EchoRelation: () => import_chunk_BRS5374V.EchoRelation,
  EchoSchema: () => EchoSchema,
  Email: () => Email,
  EntityKind: () => import_chunk_BRS5374V.EntityKind,
  EntityKindId: () => import_chunk_BRS5374V.EntityKindId,
  EntityKindSchema: () => import_chunk_BRS5374V.EntityKindSchema,
  Expando: () => import_chunk_BRS5374V.Expando,
  FIELD_PATH_ANNOTATION: () => import_chunk_BRS5374V.FIELD_PATH_ANNOTATION,
  FieldLookupAnnotationId: () => import_chunk_BRS5374V.FieldLookupAnnotationId,
  FieldPath: () => import_chunk_BRS5374V.FieldPath,
  FieldSortType: () => FieldSortType,
  ForeignKey: () => import_echo_protocol.ForeignKey,
  Format: () => Format,
  FormatAnnotation: () => FormatAnnotation,
  FormatAnnotationId: () => FormatAnnotationId,
  FormatEnum: () => FormatEnum,
  FormatEnums: () => FormatEnums,
  Formula: () => Formula,
  GeneratorAnnotation: () => import_chunk_BRS5374V.GeneratorAnnotation,
  GeneratorAnnotationId: () => import_chunk_BRS5374V.GeneratorAnnotationId,
  GeoLocation: () => GeoLocation,
  GeoPoint: () => GeoPoint,
  Hostname: () => Hostname,
  ImmutableSchema: () => ImmutableSchema,
  JSON: () => JSON,
  JSON_SCHEMA_ECHO_REF_ID: () => import_chunk_BRS5374V.JSON_SCHEMA_ECHO_REF_ID,
  JsonPath: () => import_effect.JsonPath,
  JsonProp: () => import_effect.JsonProp,
  JsonSchemaEchoAnnotations: () => JsonSchemaEchoAnnotations,
  JsonSchemaFields: () => JsonSchemaFields,
  JsonSchemaType: () => JsonSchemaType,
  LabelAnnotation: () => import_chunk_BRS5374V.LabelAnnotation,
  LabelAnnotationId: () => import_chunk_BRS5374V.LabelAnnotationId,
  Markdown: () => Markdown,
  MetaId: () => import_chunk_BRS5374V.MetaId,
  ObjectId: () => import_keys.ObjectId,
  ObjectMetaSchema: () => import_chunk_BRS5374V.ObjectMetaSchema,
  OptionsAnnotationId: () => OptionsAnnotationId,
  PropType: () => PropType,
  PropertyKind: () => PropertyKind,
  PropertyMeta: () => import_chunk_BRS5374V.PropertyMeta,
  PropertyMetaAnnotationId: () => import_chunk_BRS5374V.PropertyMetaAnnotationId,
  QueryType: () => QueryType,
  RawObject: () => RawObject,
  Ref: () => import_chunk_BRS5374V.Ref,
  RefArray: () => import_chunk_BRS5374V.RefArray,
  RefImpl: () => import_chunk_BRS5374V.RefImpl,
  RefTypeId: () => import_chunk_BRS5374V.RefTypeId,
  ReferenceAnnotationId: () => import_chunk_BRS5374V.ReferenceAnnotationId,
  Regex: () => Regex,
  RelationSourceDXNId: () => import_chunk_BRS5374V.RelationSourceDXNId,
  RelationSourceId: () => import_chunk_BRS5374V.RelationSourceId,
  RelationTargetDXNId: () => import_chunk_BRS5374V.RelationTargetDXNId,
  RelationTargetId: () => import_chunk_BRS5374V.RelationTargetId,
  RuntimeSchemaRegistry: () => RuntimeSchemaRegistry,
  SchemaId: () => import_chunk_BRS5374V.SchemaId,
  SchemaMetaSymbol: () => import_chunk_BRS5374V.SchemaMetaSymbol,
  SchemaValidator: () => import_chunk_BRS5374V.SchemaValidator,
  SelectOptionSchema: () => SelectOptionSchema,
  SelfDXNId: () => import_chunk_BRS5374V.SelfDXNId,
  StaticRefResolver: () => import_chunk_BRS5374V.StaticRefResolver,
  StoredSchema: () => StoredSchema,
  TypeAnnotation: () => import_chunk_BRS5374V.TypeAnnotation,
  TypeAnnotationId: () => import_chunk_BRS5374V.TypeAnnotationId,
  TypeEnum: () => TypeEnum,
  TypeId: () => import_chunk_BRS5374V.TypeId,
  TypeIdentifierAnnotationId: () => import_chunk_BRS5374V.TypeIdentifierAnnotationId,
  TypedObject: () => import_chunk_BRS5374V.TypedObject,
  TypedRelation: () => import_chunk_BRS5374V.TypedRelation,
  Typename: () => import_chunk_BRS5374V.Typename,
  URL: () => URL,
  UUID: () => UUID,
  Version: () => import_chunk_BRS5374V.Version,
  addFieldsToSchema: () => addFieldsToSchema,
  assertObjectModelShape: () => import_chunk_BRS5374V.assertObjectModelShape,
  attachTypedJsonSerializer: () => import_chunk_BRS5374V.attachTypedJsonSerializer,
  checkIdNotPresentOnSchema: () => import_chunk_BRS5374V.checkIdNotPresentOnSchema,
  compareForeignKeys: () => import_chunk_BRS5374V.compareForeignKeys,
  composeSchema: () => composeSchema,
  create: () => import_chunk_BRS5374V.create,
  createAnnotationHelper: () => import_chunk_BRS5374V.createAnnotationHelper,
  createEchoReferenceSchema: () => import_chunk_BRS5374V.createEchoReferenceSchema,
  createJsonSchema: () => createJsonSchema,
  createQueueDXN: () => import_chunk_BRS5374V.createQueueDXN,
  createSchemaReference: () => import_chunk_BRS5374V.createSchemaReference,
  defineHiddenProperty: () => import_chunk_BRS5374V.defineHiddenProperty,
  foreignKey: () => import_chunk_BRS5374V.foreignKey,
  foreignKeyEquals: () => import_chunk_BRS5374V.foreignKeyEquals,
  formatToType: () => formatToType,
  getEntityKind: () => import_chunk_BRS5374V.getEntityKind,
  getFormatAnnotation: () => getFormatAnnotation,
  getLabel: () => import_chunk_BRS5374V.getLabel,
  getLabelForObject: () => import_chunk_BRS5374V.getLabelForObject,
  getMeta: () => import_chunk_BRS5374V.getMeta,
  getNormalizedEchoAnnotations: () => getNormalizedEchoAnnotations,
  getObjectDXN: () => import_chunk_BRS5374V.getObjectDXN,
  getObjectMeta: () => import_chunk_BRS5374V.getObjectMeta,
  getOptionsAnnotation: () => getOptionsAnnotation,
  getPropertyMetaAnnotation: () => import_chunk_BRS5374V.getPropertyMetaAnnotation,
  getRefSavedTarget: () => import_chunk_BRS5374V.getRefSavedTarget,
  getReferenceAnnotation: () => import_chunk_BRS5374V.getReferenceAnnotation,
  getSchema: () => import_chunk_BRS5374V.getSchema,
  getSchemaDXN: () => import_chunk_BRS5374V.getSchemaDXN,
  getSchemaProperty: () => getSchemaProperty,
  getSchemaReference: () => import_chunk_BRS5374V.getSchemaReference,
  getSchemaTypename: () => import_chunk_BRS5374V.getSchemaTypename,
  getSchemaVersion: () => import_chunk_BRS5374V.getSchemaVersion,
  getSnapshot: () => getSnapshot,
  getType: () => import_chunk_BRS5374V.getType,
  getTypeAnnotation: () => import_chunk_BRS5374V.getTypeAnnotation,
  getTypeEnum: () => getTypeEnum,
  getTypeIdentifierAnnotation: () => import_chunk_BRS5374V.getTypeIdentifierAnnotation,
  getTypeReference: () => getTypeReference,
  getTypename: () => import_chunk_BRS5374V.getTypename,
  getValue: () => getValue,
  isDeleted: () => import_chunk_BRS5374V.isDeleted,
  isInstanceOf: () => isInstanceOf,
  isMutable: () => isMutable,
  makeTypedEntityClass: () => import_chunk_BRS5374V.makeTypedEntityClass,
  normalizeSchema: () => normalizeSchema,
  objectFromJSON: () => import_chunk_BRS5374V.objectFromJSON,
  objectToJSON: () => import_chunk_BRS5374V.objectToJSON,
  refFromEncodedReference: () => import_chunk_BRS5374V.refFromEncodedReference,
  removeFieldsFromSchema: () => removeFieldsFromSchema,
  requireTypeReference: () => requireTypeReference,
  setRefResolver: () => import_chunk_BRS5374V.setRefResolver,
  setSchema: () => import_chunk_BRS5374V.setSchema,
  setSchemaProperty: () => setSchemaProperty,
  setTypename: () => import_chunk_BRS5374V.setTypename,
  setTypenameInSchema: () => setTypenameInSchema,
  setValue: () => setValue,
  splitJsonPath: () => import_effect.splitJsonPath,
  splitMeta: () => splitMeta,
  toEffectSchema: () => toEffectSchema,
  toJsonSchema: () => toJsonSchema,
  toPropType: () => toPropType,
  typeToFormat: () => typeToFormat,
  updateFieldNameInSchema: () => updateFieldNameInSchema,
  updateFieldsInSchema: () => updateFieldsInSchema
});
module.exports = __toCommonJS(node_exports);
var import_chunk_BRS5374V = require("./chunk-BRS5374V.cjs");
var import_effect = require("@dxos/effect");
var import_keys = require("@dxos/keys");
var import_echo_protocol = require("@dxos/echo-protocol");
var import_effect2 = require("effect");
var import_effect3 = require("effect");
var import_effect4 = require("effect");
var import_util = require("@dxos/util");
var import_effect5 = require("effect");
var Keys = __toESM(require("@dxos/keys"));
var import_effect6 = require("effect");
var import_effect7 = require("effect");
var import_effect8 = require("effect");
var import_effect9 = require("effect");
var import_debug = require("@dxos/debug");
var import_effect10 = require("@dxos/effect");
var import_invariant = require("@dxos/invariant");
var import_keys2 = require("@dxos/keys");
var import_util2 = require("@dxos/util");
var import_effect11 = require("effect");
var import_effect12 = require("effect");
var import_effect13 = require("@dxos/effect");
var import_effect14 = require("effect");
var import_effect15 = require("effect");
var import_echo_protocol2 = require("@dxos/echo-protocol");
var import_effect16 = require("@dxos/effect");
var import_keys3 = require("@dxos/keys");
var import_util3 = require("@dxos/util");
var import_invariant2 = require("@dxos/invariant");
var import_effect17 = require("effect");
var import_invariant3 = require("@dxos/invariant");
var import_effect18 = require("effect");
var import_invariant4 = require("@dxos/invariant");
var import_effect19 = require("effect");
var import_debug2 = require("@dxos/debug");
var import_invariant5 = require("@dxos/invariant");
var import_util4 = require("@dxos/util");
var TypeEnum = /* @__PURE__ */ function(TypeEnum2) {
  TypeEnum2["Array"] = "array";
  TypeEnum2["Object"] = "object";
  TypeEnum2["String"] = "string";
  TypeEnum2["Number"] = "number";
  TypeEnum2["Boolean"] = "boolean";
  TypeEnum2["Ref"] = "ref";
  return TypeEnum2;
}({});
var getTypeEnum = (property) => {
  switch (property.type) {
    case "array":
      return "array";
    case "object":
      return "object";
    case "string":
      return "string";
    case "number":
      return "number";
    case "boolean":
      return "boolean";
    default:
      return void 0;
  }
};
var FormatAnnotationId = Symbol.for("@dxos/schema/annotation/Format");
var FormatAnnotation = (0, import_chunk_BRS5374V.createAnnotationHelper)(FormatAnnotationId);
var getFormatAnnotation = (node) => (0, import_effect3.pipe)(import_effect3.SchemaAST.getAnnotation(FormatAnnotationId)(node), import_effect3.Option.getOrUndefined);
var FormatEnum = /* @__PURE__ */ function(FormatEnum2) {
  FormatEnum2["None"] = "none";
  FormatEnum2["String"] = "string";
  FormatEnum2["Number"] = "number";
  FormatEnum2["Boolean"] = "boolean";
  FormatEnum2["Ref"] = "ref";
  FormatEnum2["DID"] = "did";
  FormatEnum2["DXN"] = "dxn";
  FormatEnum2["Email"] = "email";
  FormatEnum2["Formula"] = "formula";
  FormatEnum2["Hostname"] = "hostname";
  FormatEnum2["JSON"] = "json";
  FormatEnum2["Markdown"] = "markdown";
  FormatEnum2["Regex"] = "regex";
  FormatEnum2["SingleSelect"] = "single-select";
  FormatEnum2["MultiSelect"] = "multi-select";
  FormatEnum2["URL"] = "url";
  FormatEnum2["UUID"] = "uuid";
  FormatEnum2["Currency"] = "currency";
  FormatEnum2["Integer"] = "integer";
  FormatEnum2["Percent"] = "percent";
  FormatEnum2["Timestamp"] = "timestamp";
  FormatEnum2["DateTime"] = "date-time";
  FormatEnum2["Date"] = "date";
  FormatEnum2["Time"] = "time";
  FormatEnum2["Duration"] = "duration";
  FormatEnum2["GeoPoint"] = "latlng";
  return FormatEnum2;
}({});
var FormatEnums = Object.values(FormatEnum).sort();
var PropertyKind = {
  type: TypeEnum,
  format: FormatEnum
};
var typeToFormat = {
  ["string"]: "string",
  ["number"]: "number",
  ["boolean"]: "boolean"
};
var formatToType = {
  ["none"]: void 0,
  ["string"]: "string",
  ["number"]: "number",
  ["boolean"]: "boolean",
  ["ref"]: "ref",
  ["did"]: "string",
  ["dxn"]: "string",
  ["email"]: "string",
  ["formula"]: "string",
  ["hostname"]: "string",
  ["json"]: "string",
  ["markdown"]: "string",
  ["regex"]: "string",
  ["url"]: "string",
  ["uuid"]: "string",
  ["single-select"]: "string",
  ["multi-select"]: "object",
  ["date"]: "string",
  ["date-time"]: "string",
  ["duration"]: "string",
  ["time"]: "string",
  ["currency"]: "number",
  ["integer"]: "number",
  ["percent"]: "number",
  ["timestamp"]: "number",
  ["latlng"]: "object"
};
var OptionsAnnotationId = Symbol.for("@dxos/schema/annotation/Options");
var getOptionsAnnotation = (node) => (0, import_effect3.pipe)(import_effect3.SchemaAST.getAnnotation(OptionsAnnotationId)(node), import_effect3.Option.getOrUndefined);
var encodeMultipleOf = (divisor) => 1 / Math.pow(10, divisor);
var encodeMultiple = (divisor) => (self) => divisor === void 0 || divisor === 0 ? self : self.pipe(import_effect2.Schema.multipleOf(encodeMultipleOf(divisor)));
var DecimalPrecision = import_effect2.Schema.transform(import_effect2.Schema.Number, import_effect2.Schema.Number, {
  strict: true,
  encode: (value) => encodeMultipleOf(value),
  decode: (value) => Math.log10(1 / value)
}).annotations({
  title: "Number of digits"
});
var CurrencyAnnotationId = Symbol.for("@dxos/schema/annotation/Currency");
var Currency = ({ decimals, code } = {
  decimals: 2
}) => import_effect2.Schema.Number.pipe(encodeMultiple(decimals), FormatAnnotation.set(FormatEnum.Currency), import_effect2.Schema.annotations({
  title: "Currency",
  description: "Currency value",
  ...code ? {
    [CurrencyAnnotationId]: code.toUpperCase()
  } : {}
}));
var Integer = () => import_effect2.Schema.Number.pipe(import_effect2.Schema.int(), FormatAnnotation.set(FormatEnum.Integer), import_effect2.Schema.annotations({
  title: "Integer",
  description: "Integer value"
}));
var Percent = ({ decimals } = {
  decimals: 2
}) => import_effect2.Schema.Number.pipe(encodeMultiple(decimals), FormatAnnotation.set(FormatEnum.Percent), import_effect2.Schema.annotations({
  title: "Percent",
  description: "Percentage value"
}));
var Timestamp = import_effect2.Schema.Number.pipe(FormatAnnotation.set(FormatEnum.Timestamp), import_effect2.Schema.annotations({
  title: "Timestamp",
  description: "Unix timestamp"
}));
var GeoPoint = import_effect4.Schema.Tuple(import_effect4.Schema.Number.pipe(import_effect4.Schema.clamp(-180, 180), import_effect4.Schema.multipleOf(1e-5)).annotations({
  title: "Longitude"
}), import_effect4.Schema.Number.pipe(import_effect4.Schema.clamp(-90, 90), import_effect4.Schema.multipleOf(1e-5)).annotations({
  title: "Latitude"
}), import_effect4.Schema.optionalElement(import_effect4.Schema.Number).annotations({
  title: "Height ASL (m)"
})).pipe(FormatAnnotation.set(FormatEnum.GeoPoint), import_effect4.Schema.annotations({
  title: "GeoPoint",
  description: "GeoJSON Position"
}));
(function(GeoLocation2) {
  GeoLocation2.toGeoPoint = ({ longitude, latitude, height }) => {
    const clampedLongitude = (0, import_util.clamp)(longitude, -180, 180);
    const clampedLatitude = (0, import_util.clamp)(latitude, -90, 90);
    return height !== void 0 ? [
      clampedLongitude,
      clampedLatitude,
      height
    ] : [
      clampedLongitude,
      clampedLatitude
    ];
  };
  GeoLocation2.fromGeoPoint = (geoPoint) => {
    if (!geoPoint) {
      return {
        longitude: 0,
        latitude: 0
      };
    }
    const result = {
      longitude: geoPoint[0],
      latitude: geoPoint[1]
    };
    if (geoPoint[2] !== void 0) {
      result.height = geoPoint[2];
    }
    return result;
  };
})(GeoLocation || (GeoLocation = {}));
var GeoLocation;
var SimpleDate = import_effect6.Schema.Struct({
  year: import_effect6.Schema.Number.pipe(import_effect6.Schema.between(1900, 9999)),
  month: import_effect6.Schema.Number.pipe(import_effect6.Schema.between(1, 12)),
  day: import_effect6.Schema.Number.pipe(import_effect6.Schema.between(1, 31))
});
var SimpleTime = import_effect6.Schema.Struct({
  hours: import_effect6.Schema.Number.pipe(import_effect6.Schema.between(0, 23)),
  minutes: import_effect6.Schema.Number.pipe(import_effect6.Schema.between(0, 59)),
  seconds: import_effect6.Schema.Number.pipe(import_effect6.Schema.between(0, 59))
});
var SimpleDateTime = import_effect6.Schema.extend(SimpleDate, SimpleTime);
var DateOnly = (
  /* Schema.transformOrFail(Schema.String, SimpleDate, {
    strict: true,
    decode: (str, _, ast) => {
      if (!isValidDateFormat(str)) {
        return ParseResult.fail(new ParseResult.Type(ast, str, 'Expected YYYY-MM-DD format'));
      }
      if (!isValidDate(str)) {
        return ParseResult.fail(new ParseResult.Type(ast, str, 'Invalid date'));
      }
  
      const [year, month, day] = str.split('-').map(Number);
      return ParseResult.succeed({ year, month, day });
    },
    encode: (date) => {
      return ParseResult.succeed(
        [
          date.year.toString().padStart(4, '0'),
          date.month.toString().padStart(2, '0'),
          date.day.toString().padStart(2, '0'),
        ].join('-'),
      );
    },
  }) */
  import_effect6.Schema.String.pipe(FormatAnnotation.set(FormatEnum.Date), import_effect6.Schema.annotations({
    title: "Date",
    description: "Valid date in ISO format"
  }))
);
var TimeOnly = (
  /* Schema.transformOrFail(Schema.String, SimpleTime, {
    strict: true,
    decode: (str, _, ast) => {
      if (!isValidTimeFormat(str)) {
        return ParseResult.fail(new ParseResult.Type(ast, str, 'Expected HH:mm:ss format'));
      }
  
      const [hours, minutes, seconds] = str.split(':').map(Number);
      return ParseResult.succeed({ hours, minutes, seconds });
    },
    encode: (time) => {
      return ParseResult.succeed(
        [
          time.hours.toString().padStart(2, '0'),
          time.minutes.toString().padStart(2, '0'),
          time.seconds.toString().padStart(2, '0'),
        ].join(':'),
      );
    },
  }) */
  import_effect6.Schema.String.pipe(FormatAnnotation.set(FormatEnum.Time), import_effect6.Schema.annotations({
    title: "Time",
    description: "Valid time in ISO format"
  }))
);
var DateTime = (
  /* Schema.transformOrFail(Schema.String, SimpleDateTime, {
    strict: false,
    decode: (str, _, ast) => {
      const [date, time] = str.split('T');
      if (!isValidDateFormat(date)) {
        return ParseResult.fail(new ParseResult.Type(ast, date, 'Expected YYYY-MM-DD format'));
      }
      if (!isValidDate(date)) {
        return ParseResult.fail(new ParseResult.Type(ast, date, 'Invalid date'));
      }
      if (!isValidTimeFormat(time)) {
        return ParseResult.fail(new ParseResult.Type(ast, str, 'Expected HH:mm:ss format'));
      }
  
      const [year, month, day] = date.split('-').map(Number);
      const [hours, minutes, seconds] = time.split(':').map(Number);
      return ParseResult.succeed({ year, month, day, hours, minutes, seconds });
    },
    encode: (datetime) => {
      return ParseResult.succeed(
        [
          [
            datetime.year.toString().padStart(4, '0'),
            datetime.month.toString().padStart(2, '0'),
            datetime.day.toString().padStart(2, '0'),
          ].join('-'),
          [
            datetime.hours.toString().padStart(2, '0'),
            datetime.minutes.toString().padStart(2, '0'),
            datetime.seconds.toString().padStart(2, '0'),
          ].join(':'),
        ].join('T'),
      );
    },
  }) */
  import_effect6.Schema.String.pipe(FormatAnnotation.set(FormatEnum.DateTime), import_effect6.Schema.annotations({
    title: "DateTime",
    description: "Valid date and time in ISO format"
  }))
);
var Duration = import_effect6.Schema.String.pipe(FormatAnnotation.set(FormatEnum.Duration), import_effect6.Schema.annotations({
  title: "Duration",
  description: "Duration in ISO 8601 format",
  [import_effect6.SchemaAST.ExamplesAnnotationId]: [
    "1h",
    "3D"
  ]
}));
var Email = import_effect7.Schema.String.pipe(import_effect7.Schema.pattern(/^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/), FormatAnnotation.set(FormatEnum.Email), import_effect7.Schema.annotations({
  title: "Email",
  description: "Email address"
}));
var Formula = import_effect7.Schema.String.pipe(FormatAnnotation.set(FormatEnum.Formula));
var Hostname = import_effect7.Schema.String.pipe(FormatAnnotation.set(FormatEnum.Hostname));
var JSON = import_effect7.Schema.String.pipe(FormatAnnotation.set(FormatEnum.JSON));
var Markdown = import_effect7.Schema.String.pipe(FormatAnnotation.set(FormatEnum.Markdown));
var Regex = import_effect7.Schema.String.pipe(FormatAnnotation.set(FormatEnum.Regex));
var URL = import_effect7.Schema.String.pipe(import_effect7.Schema.pattern(/^(\w+?:\/\/)?([\da-z.-]+)\.([a-z.]{2,6})([/\w .-]*)*\/?$/i), FormatAnnotation.set(FormatEnum.URL), import_effect7.Schema.annotations({
  title: "URL",
  description: "URL"
}));
var UUID = import_effect7.Schema.UUID.pipe(FormatAnnotation.set(FormatEnum.UUID), import_effect7.Schema.annotations({
  [import_effect7.SchemaAST.ExamplesAnnotationId]: [
    "3e4666bf-d5e5-4aa7-b8ce-cefe41c7568a"
  ]
}));
(function(Format2) {
  Format2.DXN = Keys.DXN;
  Format2.Email = Email;
  Format2.Formula = Formula;
  Format2.Hostname = Hostname;
  Format2.JSON = JSON;
  Format2.Markdown = Markdown;
  Format2.Regex = Regex;
  Format2.URL = URL;
  Format2.UUID = import_effect5.Schema.UUID;
  Format2.Currency = Currency;
  Format2.Integer = Integer;
  Format2.Percent = Percent;
  Format2.Timestamp = Timestamp;
  Format2.DateTime = DateTime;
  Format2.Date = DateOnly;
  Format2.Time = TimeOnly;
  Format2.Duration = Duration;
  Format2.GeoPoint = GeoPoint;
})(Format || (Format = {}));
var Format;
var SelectOptionSchema = import_effect8.Schema.Struct({
  /** Stable identifier for the option. */
  id: import_effect8.Schema.NonEmptyString,
  title: import_effect8.Schema.String,
  /** Color palette used for visual styling. */
  color: import_effect8.Schema.String
}).pipe(import_effect8.Schema.mutable);
var CustomAnnotations = {
  format: FormatAnnotationId,
  currency: CurrencyAnnotationId
};
var DecodedAnnotations = {
  title: import_effect11.SchemaAST.TitleAnnotationId,
  description: import_effect11.SchemaAST.DescriptionAnnotationId
};
var EchoAnnotations = {
  // TODO(dmaretskyi): `FieldLookupAnnotationId` might go here, but lets remove it entirely and use LabelAnnotation instead.
  meta: import_chunk_BRS5374V.PropertyMetaAnnotationId,
  generator: import_chunk_BRS5374V.GeneratorAnnotationId,
  labelProp: import_chunk_BRS5374V.LabelAnnotationId
};
var SimpleTypes = import_effect12.Schema.Literal("array", "boolean", "integer", "null", "number", "object", "string");
var NonNegativeInteger = import_effect12.Schema.Number.pipe(import_effect12.Schema.greaterThanOrEqualTo(0));
var StringArray = import_effect12.Schema.Array(import_effect12.Schema.String).pipe(import_effect12.Schema.mutable);
var JsonSchemaOrBoolean = import_effect12.Schema.Union(import_effect12.Schema.suspend(() => JsonSchemaType), import_effect12.Schema.Boolean);
var JsonSchemaEchoAnnotations = import_effect12.Schema.Struct({
  /**
  * Label for this schema.
  * Mapped from {@link LabelAnnotationId}.
  */
  labelProp: import_effect12.Schema.optional(import_effect12.Schema.Union(import_effect13.JsonPath, import_effect12.Schema.Array(import_effect13.JsonPath))),
  /**
  * Generator function for this schema.
  * Mapped from {@link GeneratorAnnotationId}.
  */
  generator: import_effect12.Schema.optional(import_effect12.Schema.Union(import_effect12.Schema.String, import_effect12.Schema.Tuple(import_effect12.Schema.String, import_effect12.Schema.Number))),
  /**
  * {@link PropertyMeta} annotations get serialized here.
  */
  meta: import_effect12.Schema.optional(import_effect12.Schema.Record({
    key: import_effect12.Schema.String,
    value: import_effect12.Schema.Any
  }).pipe(import_effect12.Schema.mutable)),
  /**
  * @deprecated
  */
  // TODO(dmaretskyi): We risk old schema not passing validation due to the extra fields. Remove when we are sure this is safe
  type: import_effect12.Schema.optional(import_effect12.Schema.Struct({
    typename: import_effect12.Schema.String,
    version: import_effect12.Schema.String,
    // Not used.
    schemaId: import_effect12.Schema.optional(import_effect12.Schema.String)
  }).pipe(import_effect12.Schema.mutable)),
  /**
  * @deprecated Superseded by `meta`.
  */
  annotations: import_effect12.Schema.optional(import_effect12.Schema.Record({
    key: import_effect12.Schema.String,
    value: import_effect12.Schema.Any
  }).pipe(import_effect12.Schema.mutable))
}).pipe(import_effect12.Schema.mutable);
var _JsonSchemaType = import_effect12.Schema.Struct({
  /**
  * Identifier for this schema.
  * This schema might be referenced by $ref clause in other schemas.
  */
  // TODO(dmaretskyi): Specify how the ids are generated.
  // TODO(dmaretskyi): For type dxns, should this include the version?
  $id: import_effect12.Schema.optional(import_effect12.Schema.String),
  /**
  * Schema of this schema.
  * Set to "https://json-schema.org/draft-07/schema".
  */
  $schema: import_effect12.Schema.optional(import_effect12.Schema.String),
  /**
  * Reference to another schema.
  */
  $ref: import_effect12.Schema.optional(import_effect12.Schema.String),
  /**
  * Comments are ignored when interpreting the schema.
  */
  $comment: import_effect12.Schema.optional(import_effect12.Schema.String),
  /**
  * Defines whether this schema is an object schema or a relation schema.
  */
  entityKind: import_effect12.Schema.optional(import_chunk_BRS5374V.EntityKindSchema),
  /**
  * Typename of this schema.
  * Only on schema representing an ECHO object.
  *
  * @example 'example.com/type/MyType'
  */
  typename: import_effect12.Schema.optional(import_effect12.Schema.String),
  /**
  * Version of this schema.
  * Custom dialect for ECHO.
  */
  version: import_effect12.Schema.optional(import_effect12.Schema.String),
  /**
  * Target of this relation.
  * Only for relation schemas.
  * The referenced schema must be an object schema.
  */
  relationTarget: import_effect12.Schema.optional(import_effect12.Schema.suspend(() => JsonSchemaType)),
  /**
  * Source of this relation.
  * Only for relation schemas.
  * The referenced schema must be an object schema.
  */
  relationSource: import_effect12.Schema.optional(import_effect12.Schema.suspend(() => JsonSchemaType)),
  /**
  * Title of this schema.
  */
  title: import_effect12.Schema.optional(import_effect12.Schema.String),
  /**
  * Description of this schema.
  */
  description: import_effect12.Schema.optional(import_effect12.Schema.String),
  /**
  * Whether this schema is read-only.
  */
  readOnly: import_effect12.Schema.optional(import_effect12.Schema.Boolean),
  /**
  * Whether this schema is write-only.
  */
  writeOnly: import_effect12.Schema.optional(import_effect12.Schema.Boolean),
  /**
  * Examples of instances of this schema.
  */
  examples: import_effect12.Schema.optional(import_effect12.Schema.Array(import_effect12.Schema.Any)),
  /**
  * Default value for this schema.
  */
  default: import_effect12.Schema.optional(import_effect12.Schema.Any),
  /**
  * This schema only matches values that are equal to this value.
  */
  const: import_effect12.Schema.optional(import_effect12.Schema.Any),
  /**
  * This schema only matches one of the values in this array.
  */
  enum: import_effect12.Schema.optional(import_effect12.Schema.Array(import_effect12.Schema.Any)),
  /**
  * Base type of the schema.
  */
  type: import_effect12.Schema.optional(import_effect12.Schema.Union(SimpleTypes, import_effect12.Schema.Array(SimpleTypes))),
  //
  // Numbers.
  //
  multipleOf: import_effect12.Schema.optional(import_effect12.Schema.Number.pipe(import_effect12.Schema.greaterThan(0))),
  maximum: import_effect12.Schema.optional(import_effect12.Schema.Number),
  exclusiveMaximum: import_effect12.Schema.optional(import_effect12.Schema.Number),
  minimum: import_effect12.Schema.optional(import_effect12.Schema.Number),
  exclusiveMinimum: import_effect12.Schema.optional(import_effect12.Schema.Number),
  //
  // Strings.
  //
  maxLength: import_effect12.Schema.optional(NonNegativeInteger),
  /**
  * Regex pattern for strings.
  */
  pattern: import_effect12.Schema.optional(import_effect12.Schema.String.pipe(FormatAnnotation.set(FormatEnum.Regex))),
  /**
  * Serialized from {@link FormatAnnotationId}.
  */
  format: import_effect12.Schema.optional(import_effect12.Schema.String),
  //
  // Arrays
  //
  minLength: import_effect12.Schema.optional(NonNegativeInteger),
  items: import_effect12.Schema.optional(import_effect12.Schema.Union(import_effect12.Schema.suspend(() => JsonSchemaType), import_effect12.Schema.Array(import_effect12.Schema.suspend(() => JsonSchemaType)))),
  additionalItems: import_effect12.Schema.optional(import_effect12.Schema.Union(import_effect12.Schema.suspend(() => JsonSchemaType), import_effect12.Schema.Boolean)),
  maxItems: import_effect12.Schema.optional(NonNegativeInteger),
  minItems: import_effect12.Schema.optional(NonNegativeInteger),
  uniqueItems: import_effect12.Schema.optional(import_effect12.Schema.Boolean),
  contains: import_effect12.Schema.optional(import_effect12.Schema.suspend(() => JsonSchemaType)),
  //
  // Objects
  //
  maxProperties: import_effect12.Schema.optional(NonNegativeInteger),
  minProperties: import_effect12.Schema.optional(NonNegativeInteger),
  required: import_effect12.Schema.optional(StringArray),
  /**
  * Non-standard JSON Schema extension.
  * Defines the order of properties in the object.
  * The unmentioned properties are placed at the end.
  *
  * Related: https://github.com/json-schema/json-schema/issues/119
  */
  propertyOrder: import_effect12.Schema.optional(StringArray),
  additionalProperties: import_effect12.Schema.optional(JsonSchemaOrBoolean),
  properties: import_effect12.Schema.optional(import_effect12.Schema.Record({
    key: import_effect12.Schema.String,
    value: import_effect12.Schema.suspend(() => JsonSchemaType)
  }).pipe(import_effect12.Schema.mutable)),
  patternProperties: import_effect12.Schema.optional(import_effect12.Schema.Record({
    key: import_effect12.Schema.String,
    value: import_effect12.Schema.suspend(() => JsonSchemaType)
  }).pipe(import_effect12.Schema.mutable)),
  propertyNames: import_effect12.Schema.optional(import_effect12.Schema.suspend(() => JsonSchemaType)),
  definitions: import_effect12.Schema.optional(import_effect12.Schema.mutable(import_effect12.Schema.Record({
    key: import_effect12.Schema.String,
    value: import_effect12.Schema.suspend(() => JsonSchemaType)
  }))),
  dependencies: import_effect12.Schema.optional(import_effect12.Schema.Record({
    key: import_effect12.Schema.String,
    value: import_effect12.Schema.suspend(() => import_effect12.Schema.Union(import_effect12.Schema.String, StringArray, JsonSchemaType)).annotations({
      identifier: "dependency",
      description: "Dependency"
    })
  })),
  contentMediaType: import_effect12.Schema.optional(import_effect12.Schema.String),
  contentEncoding: import_effect12.Schema.optional(import_effect12.Schema.String),
  if: import_effect12.Schema.optional(import_effect12.Schema.suspend(() => JsonSchemaType)),
  then: import_effect12.Schema.optional(import_effect12.Schema.suspend(() => JsonSchemaType)),
  else: import_effect12.Schema.optional(import_effect12.Schema.suspend(() => JsonSchemaType)),
  allOf: import_effect12.Schema.optional(import_effect12.Schema.Array(import_effect12.Schema.suspend(() => JsonSchemaType))),
  anyOf: import_effect12.Schema.optional(import_effect12.Schema.Array(import_effect12.Schema.suspend(() => JsonSchemaType))),
  oneOf: import_effect12.Schema.optional(import_effect12.Schema.Array(import_effect12.Schema.suspend(() => JsonSchemaType))),
  not: import_effect12.Schema.optional(import_effect12.Schema.suspend(() => JsonSchemaType)),
  $defs: import_effect12.Schema.optional(import_effect12.Schema.mutable(import_effect12.Schema.Record({
    key: import_effect12.Schema.String,
    value: import_effect12.Schema.suspend(() => JsonSchemaType)
  }))),
  //
  // ECHO extensions.
  //
  currency: import_effect12.Schema.optional(import_effect12.Schema.String),
  reference: import_effect12.Schema.optional(import_effect12.Schema.mutable(import_effect12.Schema.Struct({
    schema: import_effect12.Schema.suspend(() => JsonSchemaType),
    schemaVersion: import_effect12.Schema.optional(import_effect12.Schema.String),
    schemaObject: import_effect12.Schema.optional(import_effect12.Schema.String)
  }))),
  /**
  * ECHO-specific annotations.
  */
  // TODO(dmaretskyi): Since we are adding a lot of new extensions to the JSON Schema, it is safer to namespace them here.
  annotations: import_effect12.Schema.optional(import_effect12.Schema.mutable(JsonSchemaEchoAnnotations)),
  /**
  * @deprecated Use `annotations` instead.
  */
  echo: import_effect12.Schema.optional(import_effect12.Schema.mutable(JsonSchemaEchoAnnotations))
}).annotations({
  identifier: "jsonSchema",
  description: "JSON Schema"
});
var JsonSchemaFields = Object.keys(_JsonSchemaType.fields);
var JsonSchemaType = _JsonSchemaType.pipe(import_effect12.Schema.mutable);
var getSchemaProperty = (schema, property) => {
  return schema.properties?.[property];
};
var setSchemaProperty = (schema, property, value) => {
  schema.properties ??= {};
  schema.properties[property] = value;
  return schema;
};
var ECHO_ANNOTATIONS_NS_DEPRECATED_KEY = "echo";
var ECHO_ANNOTATIONS_NS_KEY = "annotations";
var getNormalizedEchoAnnotations = (obj) => {
  if (obj[ECHO_ANNOTATIONS_NS_KEY] != null && obj[ECHO_ANNOTATIONS_NS_DEPRECATED_KEY] != null) {
    return normalizeEchoAnnotations({
      ...obj[ECHO_ANNOTATIONS_NS_DEPRECATED_KEY],
      ...obj[ECHO_ANNOTATIONS_NS_KEY]
    });
  } else if (obj[ECHO_ANNOTATIONS_NS_KEY] != null) {
    return normalizeEchoAnnotations(obj[ECHO_ANNOTATIONS_NS_KEY]);
  } else if (obj[ECHO_ANNOTATIONS_NS_DEPRECATED_KEY] != null) {
    return normalizeEchoAnnotations(obj[ECHO_ANNOTATIONS_NS_DEPRECATED_KEY]);
  } else {
    return void 0;
  }
};
var normalizeEchoAnnotations = (obj) => {
  if (!obj.annotations) {
    return obj;
  } else {
    const res = {
      ...obj,
      meta: {
        ...obj.annotations,
        ...obj.meta ?? {}
      }
    };
    delete res.annotations;
    return res;
  }
};
var normalizeSchema = (schema) => {
  const copy = structuredClone(schema);
  go(copy);
  return copy;
};
var go = (schema) => {
  if (typeof schema !== "object" || schema === null) {
    return;
  }
  if (schema.exclusiveMaximum === true) {
    schema.exclusiveMaximum = schema.maximum;
    delete schema.exclusiveMaximum;
  } else if (schema.exclusiveMaximum === false) {
    delete schema.exclusiveMaximum;
  }
  if (schema.exclusiveMinimum === true) {
    schema.exclusiveMinimum = schema.minimum;
    delete schema.exclusiveMinimum;
  } else if (schema.exclusiveMinimum === false) {
    delete schema.exclusiveMinimum;
  }
  for (const key of Object.keys(schema)) {
    if (!JsonSchemaFields.includes(key)) {
      delete schema[key];
    }
  }
  if (schema.properties) {
    goOnRecord(schema.properties);
  }
  if (schema.patternProperties) {
    goOnRecord(schema.patternProperties);
  }
  if (schema.propertyNames) {
    go(schema.propertyNames);
  }
  if (schema.definitions) {
    goOnRecord(schema.definitions);
  }
  if (schema.items) {
    maybeGoOnArray(schema.items);
  }
  if (schema.additionalItems) {
    maybeGoOnArray(schema.additionalItems);
  }
  if (schema.contains) {
    go(schema.contains);
  }
  if (schema.if) {
    go(schema.if);
  }
  if (schema.then) {
    go(schema.then);
  }
  if (schema.else) {
    go(schema.else);
  }
  if (schema.allOf) {
    maybeGoOnArray(schema.allOf);
  }
  if (schema.anyOf) {
    maybeGoOnArray(schema.anyOf);
  }
  if (schema.oneOf) {
    maybeGoOnArray(schema.oneOf);
  }
  if (schema.not) {
    go(schema.not);
  }
  if (schema.$defs) {
    goOnRecord(schema.$defs);
  }
  if (schema.reference) {
    go(schema.reference.schema);
  }
};
var maybeGoOnArray = (value) => {
  if (Array.isArray(value)) {
    for (const item of value) {
      go(item);
    }
  } else if (typeof value === "object" && value !== null) {
    go(value);
  }
};
var goOnRecord = (record) => {
  for (const key of Object.keys(record)) {
    go(record[key]);
  }
};
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/core/echo/echo-schema/src/json/json-schema.ts";
var createJsonSchema = (schema = import_effect9.Schema.Struct({})) => {
  const jsonSchema = _toJsonSchema(schema);
  jsonSchema.type = "object";
  delete jsonSchema.anyOf;
  return jsonSchema;
};
var PropType = /* @__PURE__ */ function(PropType2) {
  PropType2[PropType2["NONE"] = 0] = "NONE";
  PropType2[PropType2["STRING"] = 1] = "STRING";
  PropType2[PropType2["NUMBER"] = 2] = "NUMBER";
  PropType2[PropType2["BOOLEAN"] = 3] = "BOOLEAN";
  PropType2[PropType2["DATE"] = 4] = "DATE";
  PropType2[PropType2["REF"] = 5] = "REF";
  PropType2[PropType2["RECORD"] = 6] = "RECORD";
  PropType2[PropType2["ENUM"] = 7] = "ENUM";
  return PropType2;
}({});
var toPropType = (type) => {
  switch (type) {
    case 1:
      return "string";
    case 2:
      return "number";
    case 3:
      return "boolean";
    case 4:
      return "date";
    case 5:
      return "ref";
    case 6:
      return "object";
    default:
      throw new Error(`Invalid type: ${type}`);
  }
};
var JSON_SCHEMA_URL = "http://json-schema.org/draft-07/schema#";
var toJsonSchema = (schema, options = {}) => {
  let jsonSchema = _toJsonSchema(schema);
  if (options.strict) {
    jsonSchema = (0, import_util2.removeProperties)(jsonSchema, (key, value) => {
      if (key === "$id" && value === "/schemas/any") {
        return true;
      }
      if (key === "$ref" && value === "#/$defs/dependency") {
        return true;
      }
      if (key === "$ref" && value === "#/$defs/jsonSchema") {
        return true;
      }
      return false;
    });
  }
  return jsonSchema;
};
var _toJsonSchema = (schema) => {
  (0, import_invariant.invariant)(schema, void 0, {
    F: __dxlog_file,
    L: 110,
    S: void 0,
    A: [
      "schema",
      ""
    ]
  });
  const withRefinements = withEchoRefinements(schema.ast, "#");
  let jsonSchema = import_effect9.JSONSchema.fromAST(withRefinements, {
    definitions: {}
  });
  jsonSchema.$schema = JSON_SCHEMA_URL;
  if (jsonSchema.properties && "id" in jsonSchema.properties) {
    jsonSchema.properties = (0, import_util2.orderKeys)(jsonSchema.properties, [
      "id"
    ]);
  }
  const echoIdentifier = (0, import_chunk_BRS5374V.getTypeIdentifierAnnotation)(schema);
  if (echoIdentifier) {
    jsonSchema.$id = echoIdentifier;
  }
  const objectAnnotation = (0, import_chunk_BRS5374V.getTypeAnnotation)(schema);
  if (objectAnnotation) {
    if (!jsonSchema.$id) {
      jsonSchema.$id = import_keys2.DXN.fromTypename(objectAnnotation.typename).toString();
    }
    jsonSchema.entityKind = objectAnnotation.kind;
    jsonSchema.version = objectAnnotation.version;
    jsonSchema.typename = objectAnnotation.typename;
    if (jsonSchema.entityKind === import_chunk_BRS5374V.EntityKind.Relation) {
      jsonSchema.relationTarget = {
        $ref: objectAnnotation.sourceSchema
      };
      jsonSchema.relationSource = {
        $ref: objectAnnotation.targetSchema
      };
    }
  }
  jsonSchema = (0, import_util2.orderKeys)(jsonSchema, [
    "$schema",
    "$id",
    "entityKind",
    "typename",
    "version",
    "relationTarget",
    "relationSource",
    "type",
    "enum",
    "properties",
    "required",
    "propertyOrder",
    "items",
    "additionalProperties",
    "anyOf",
    "oneOf"
  ]);
  return jsonSchema;
};
var withEchoRefinements = (ast, path, suspendCache = /* @__PURE__ */ new Map()) => {
  if (path) {
    suspendCache.set(ast, path);
  }
  let recursiveResult;
  if (import_effect9.SchemaAST.isSuspend(ast)) {
    const suspendedAst = ast.f();
    const cachedPath = suspendCache.get(suspendedAst);
    if (cachedPath) {
      recursiveResult = new import_effect9.SchemaAST.Suspend(() => withEchoRefinements(suspendedAst, path, suspendCache), {
        [import_effect9.SchemaAST.JSONSchemaAnnotationId]: {
          $ref: cachedPath
        }
      });
    } else {
      const jsonSchema = _toJsonSchema(import_effect9.Schema.make(suspendedAst));
      recursiveResult = new import_effect9.SchemaAST.Suspend(() => withEchoRefinements(suspendedAst, path, suspendCache), {
        [import_effect9.SchemaAST.JSONSchemaAnnotationId]: jsonSchema
      });
    }
  } else if (import_effect9.SchemaAST.isTypeLiteral(ast)) {
    recursiveResult = (0, import_effect10.mapAst)(ast, (ast2, key) => withEchoRefinements(ast2, path && typeof key === "string" ? `${path}/${key}` : void 0, suspendCache));
    recursiveResult = addJsonSchemaFields(recursiveResult, {
      propertyOrder: [
        ...ast.propertySignatures.map((p) => p.name)
      ]
    });
  } else if (import_effect9.SchemaAST.isUndefinedKeyword(ast)) {
    return ast;
  } else {
    recursiveResult = (0, import_effect10.mapAst)(ast, (ast2, key) => withEchoRefinements(ast2, path && (typeof key === "string" || typeof key === "number") ? `${path}/${key}` : void 0, suspendCache));
  }
  const annotationFields = annotations_toJsonSchemaFields(ast.annotations);
  if (Object.keys(annotationFields).length === 0) {
    return recursiveResult;
  } else {
    return addJsonSchemaFields(recursiveResult, annotationFields);
  }
};
var toEffectSchema = (root, _defs) => {
  const defs = root.$defs ? {
    ..._defs,
    ...root.$defs
  } : _defs ?? {};
  if ("type" in root && root.type === "object") {
    return objectToEffectSchema(root, defs);
  }
  let result = import_effect9.Schema.Unknown;
  if ("$id" in root) {
    switch (root.$id) {
      case "/schemas/any": {
        result = anyToEffectSchema(root);
        break;
      }
      case "/schemas/unknown": {
        result = import_effect9.Schema.Unknown;
        break;
      }
      case "/schemas/{}":
      case "/schemas/object": {
        result = import_effect9.Schema.Object;
        break;
      }
      // Custom ECHO object reference.
      case "/schemas/echo/ref": {
        result = refToEffectSchema(root);
      }
    }
  } else if ("enum" in root) {
    result = import_effect9.Schema.Union(...root.enum.map((e) => import_effect9.Schema.Literal(e)));
  } else if ("oneOf" in root) {
    result = import_effect9.Schema.Union(...root.oneOf.map((v) => toEffectSchema(v, defs)));
  } else if ("anyOf" in root) {
    result = import_effect9.Schema.Union(...root.anyOf.map((v) => toEffectSchema(v, defs)));
  } else if ("type" in root) {
    switch (root.type) {
      case "string": {
        result = import_effect9.Schema.String;
        if (root.pattern) {
          result = result.pipe(import_effect9.Schema.pattern(new RegExp(root.pattern)));
        }
        break;
      }
      case "number": {
        result = import_effect9.Schema.Number;
        break;
      }
      case "integer": {
        result = import_effect9.Schema.Number.pipe(import_effect9.Schema.int());
        break;
      }
      case "boolean": {
        result = import_effect9.Schema.Boolean;
        break;
      }
      case "array": {
        if (Array.isArray(root.items)) {
          result = import_effect9.Schema.Tuple(...root.items.map((v) => toEffectSchema(v, defs)));
        } else {
          (0, import_invariant.invariant)(root.items, void 0, {
            F: __dxlog_file,
            L: 294,
            S: void 0,
            A: [
              "root.items",
              ""
            ]
          });
          const items = root.items;
          result = Array.isArray(items) ? import_effect9.Schema.Tuple(...items.map((v) => toEffectSchema(v, defs))) : import_effect9.Schema.Array(toEffectSchema(items, defs));
        }
        break;
      }
      case "null": {
        result = import_effect9.Schema.Null;
        break;
      }
    }
  } else if ("$ref" in root) {
    const refSegments = root.$ref.split("/");
    const jsonSchema = defs[refSegments[refSegments.length - 1]];
    (0, import_invariant.invariant)(jsonSchema, `missing definition for ${root.$ref}`, {
      F: __dxlog_file,
      L: 310,
      S: void 0,
      A: [
        "jsonSchema",
        "`missing definition for ${root.$ref}`"
      ]
    });
    result = toEffectSchema(jsonSchema, defs).pipe(import_effect9.Schema.annotations({
      identifier: refSegments[refSegments.length - 1]
    }));
  }
  const annotations = jsonSchemaFieldsToAnnotations(root);
  result = result.annotations(annotations);
  return result;
};
var objectToEffectSchema = (root, defs) => {
  (0, import_invariant.invariant)("type" in root && root.type === "object", `not an object: ${root}`, {
    F: __dxlog_file,
    L: 325,
    S: void 0,
    A: [
      "'type' in root && root.type === 'object'",
      "`not an object: ${root}`"
    ]
  });
  const echoRefinement = root[ECHO_ANNOTATIONS_NS_DEPRECATED_KEY];
  const isEchoObject = echoRefinement != null || "$id" in root && typeof root.$id === "string" && root.$id.startsWith("dxn:");
  let fields = {};
  const propertyList = Object.entries(root.properties ?? {});
  let immutableIdField;
  for (const [key, value] of propertyList) {
    if (isEchoObject && key === "id") {
      immutableIdField = toEffectSchema(value, defs);
    } else {
      fields[key] = root.required?.includes(key) ? toEffectSchema(value, defs) : import_effect9.Schema.optional(toEffectSchema(value, defs));
    }
  }
  if (root.propertyOrder) {
    fields = (0, import_util2.orderKeys)(fields, root.propertyOrder);
  }
  let schema;
  if (root.patternProperties) {
    (0, import_invariant.invariant)(propertyList.length === 0, "pattern properties mixed with regular properties are not supported", {
      F: __dxlog_file,
      L: 351,
      S: void 0,
      A: [
        "propertyList.length === 0",
        "'pattern properties mixed with regular properties are not supported'"
      ]
    });
    (0, import_invariant.invariant)(Object.keys(root.patternProperties).length === 1 && Object.keys(root.patternProperties)[0] === "", "only one pattern property is supported", {
      F: __dxlog_file,
      L: 352,
      S: void 0,
      A: [
        "Object.keys(root.patternProperties).length === 1 && Object.keys(root.patternProperties)[0] === ''",
        "'only one pattern property is supported'"
      ]
    });
    schema = import_effect9.Schema.Record({
      key: import_effect9.Schema.String,
      value: toEffectSchema(root.patternProperties[""], defs)
    });
  } else if (typeof root.additionalProperties !== "object") {
    schema = import_effect9.Schema.Struct(fields);
  } else {
    const indexValue = toEffectSchema(root.additionalProperties, defs);
    if (propertyList.length > 0) {
      schema = import_effect9.Schema.Struct(fields, {
        key: import_effect9.Schema.String,
        value: indexValue
      });
    } else {
      schema = import_effect9.Schema.Record({
        key: import_effect9.Schema.String,
        value: indexValue
      });
    }
  }
  if (immutableIdField) {
    schema = import_effect9.Schema.extend(import_effect9.Schema.mutable(schema), import_effect9.Schema.Struct({
      id: immutableIdField
    }));
  }
  const annotations = jsonSchemaFieldsToAnnotations(root);
  return schema.annotations(annotations);
};
var anyToEffectSchema = (root) => {
  const echoRefinement = root[ECHO_ANNOTATIONS_NS_DEPRECATED_KEY];
  if (echoRefinement?.reference != null) {
    const echoId = root.$id.startsWith("dxn:echo:") ? root.$id : void 0;
    return (0, import_chunk_BRS5374V.createEchoReferenceSchema)(echoId, echoRefinement.reference.typename, echoRefinement.reference.version);
  }
  return import_effect9.Schema.Any;
};
var refToEffectSchema = (root) => {
  if (!("reference" in root)) {
    return (0, import_chunk_BRS5374V.Ref)(import_chunk_BRS5374V.Expando);
  }
  const reference = root.reference;
  if (typeof reference !== "object") {
    throw new Error("Invalid reference field in ref schema");
  }
  const targetSchemaDXN = import_keys2.DXN.parse(reference.schema.$ref);
  (0, import_invariant.invariant)(targetSchemaDXN.kind === import_keys2.DXN.kind.TYPE, void 0, {
    F: __dxlog_file,
    L: 403,
    S: void 0,
    A: [
      "targetSchemaDXN.kind === DXN.kind.TYPE",
      ""
    ]
  });
  return (0, import_chunk_BRS5374V.createEchoReferenceSchema)(targetSchemaDXN.toString(), targetSchemaDXN.kind === import_keys2.DXN.kind.TYPE ? targetSchemaDXN.parts[0] : void 0, reference.schemaVersion);
};
var annotations_toJsonSchemaFields = (annotations) => {
  const schemaFields = {};
  const echoAnnotations = {};
  for (const [key, annotationId] of Object.entries(EchoAnnotations)) {
    if (annotations[annotationId] != null) {
      echoAnnotations[key] = annotations[annotationId];
    }
  }
  if (Object.keys(echoAnnotations).length > 0) {
    schemaFields[ECHO_ANNOTATIONS_NS_KEY] = echoAnnotations;
  }
  const echoIdentifier = annotations[import_chunk_BRS5374V.TypeIdentifierAnnotationId];
  if (echoIdentifier) {
    schemaFields[ECHO_ANNOTATIONS_NS_KEY] ??= {};
    schemaFields[ECHO_ANNOTATIONS_NS_KEY].schemaId = echoIdentifier;
  }
  for (const [key, annotationId] of Object.entries(CustomAnnotations)) {
    const value = annotations[annotationId];
    if (value != null) {
      schemaFields[key] = value;
    }
  }
  return schemaFields;
};
var decodeTypeIdentifierAnnotation = (schema) => {
  if (schema.$id && schema.$id.startsWith("dxn:echo:")) {
    return schema.$id;
  } else if (schema.$id && schema.$id.startsWith("dxn:type:") && schema?.echo?.type?.schemaId) {
    const id = schema?.echo?.type?.schemaId;
    if (import_keys2.ObjectId.isValid(id)) {
      return import_keys2.DXN.fromLocalObjectId(id).toString();
    }
  }
  return void 0;
};
var decodeTypeAnnotation = (schema) => {
  if (schema.typename) {
    const annotation = {
      // TODO(dmaretskyi): Decoding default.
      kind: schema.entityKind ? import_effect9.Schema.decodeSync(import_chunk_BRS5374V.EntityKindSchema)(schema.entityKind) : import_chunk_BRS5374V.EntityKind.Object,
      typename: schema.typename,
      version: schema.version ?? "0.1.0"
    };
    if (annotation.kind === import_chunk_BRS5374V.EntityKind.Relation) {
      const source = schema.relationSource?.$ref ?? (0, import_debug.raise)(new Error("Relation source not set"));
      const target = schema.relationTarget?.$ref ?? (0, import_debug.raise)(new Error("Relation target not set"));
      annotation.sourceSchema = import_keys2.DXN.parse(source).toString();
      annotation.targetSchema = import_keys2.DXN.parse(target).toString();
    }
    return annotation;
  }
  if (!schema.typename && schema?.echo?.type) {
    return {
      kind: import_chunk_BRS5374V.EntityKind.Object,
      typename: schema.echo.type.typename,
      version: schema.echo.type.version
    };
  }
  return void 0;
};
var jsonSchemaFieldsToAnnotations = (schema) => {
  const annotations = {};
  const echoAnnotations = getNormalizedEchoAnnotations(schema) ?? {};
  if (echoAnnotations) {
    for (const [key, annotationId] of Object.entries(EchoAnnotations)) {
      if (echoAnnotations[key]) {
        annotations[annotationId] = echoAnnotations[key];
      }
    }
  }
  annotations[import_chunk_BRS5374V.TypeIdentifierAnnotationId] = decodeTypeIdentifierAnnotation(schema);
  annotations[import_chunk_BRS5374V.TypeAnnotationId] = decodeTypeAnnotation(schema);
  for (const [key, annotationId] of Object.entries({
    ...CustomAnnotations,
    ...DecodedAnnotations
  })) {
    if (key in schema) {
      annotations[annotationId] = schema[key];
    }
  }
  return (0, import_util2.clearUndefined)(annotations);
};
var makeAnnotatedRefinement = (ast, annotations) => {
  return new import_effect9.SchemaAST.Refinement(ast, () => import_effect9.Option.none(), annotations);
};
var addJsonSchemaFields = (ast, schema) => makeAnnotatedRefinement(ast, {
  [import_effect9.SchemaAST.JSONSchemaAnnotationId]: schema
});
var SortDirection = import_effect14.Schema.Union(import_effect14.Schema.Literal("asc"), import_effect14.Schema.Literal("desc"));
var FieldSort = import_effect14.Schema.Struct({
  fieldId: import_effect14.Schema.String,
  direction: SortDirection
}).pipe(import_effect14.Schema.mutable);
var FieldSortType = FieldSort;
var QuerySchema = import_effect14.Schema.Struct({
  typename: import_effect14.Schema.optional(import_effect14.Schema.String),
  sort: import_effect14.Schema.optional(import_effect14.Schema.Array(FieldSort))
}).pipe(import_effect14.Schema.mutable);
var QueryType = QuerySchema;
var RawObject = (schema) => {
  return import_effect15.Schema.make(import_effect15.SchemaAST.omit(schema.ast, [
    "id"
  ]));
};
var splitMeta = (object) => {
  const meta = object[import_chunk_BRS5374V.ATTR_META];
  delete object[import_chunk_BRS5374V.ATTR_META];
  return {
    meta,
    object
  };
};
var getValue = (obj, path) => {
  return (0, import_util3.getDeep)(obj, (0, import_effect16.splitJsonPath)(path).map((p) => p.replace(/[[\]]/g, "")));
};
var setValue = (obj, path, value) => {
  return (0, import_util3.setDeep)(obj, (0, import_effect16.splitJsonPath)(path).map((p) => p.replace(/[[\]]/g, "")), value);
};
var getTypeReference = (schema) => {
  if (!schema) {
    return void 0;
  }
  const schemaDXN = (0, import_chunk_BRS5374V.getSchemaDXN)(schema);
  if (!schemaDXN) {
    return void 0;
  }
  return import_echo_protocol2.Reference.fromDXN(schemaDXN);
};
var requireTypeReference = (schema) => {
  const typeReference = getTypeReference(schema);
  if (typeReference == null) {
    throw new Error("Schema must be defined via TypedObject.");
  }
  return typeReference;
};
var isInstanceOf = (schema, object) => {
  if (object == null) {
    return false;
  }
  const schemaDXN = (0, import_chunk_BRS5374V.getSchemaDXN)(schema);
  if (!schemaDXN) {
    throw new Error("Schema must have an object annotation.");
  }
  const type = (0, import_chunk_BRS5374V.getType)(object);
  if (type && import_keys3.DXN.equals(type, schemaDXN)) {
    return true;
  }
  const typename = (0, import_chunk_BRS5374V.getTypename)(object);
  if (!typename) {
    return false;
  }
  const typeDXN = schemaDXN.asTypeDXN();
  if (!typeDXN) {
    return false;
  }
  return typeDXN.type === typename;
};
var __dxlog_file2 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-schema/src/schema/manipulation.ts";
var addFieldsToSchema = (schema, fields) => {
  const schemaExtension = import_effect18.Schema.partial(import_effect18.Schema.Struct(fields));
  return import_effect18.Schema.extend(schema, schemaExtension).annotations(schema.ast.annotations);
};
var updateFieldsInSchema = (schema, fields) => {
  const ast = schema.ast;
  (0, import_invariant4.invariant)(import_effect18.SchemaAST.isTypeLiteral(ast), void 0, {
    F: __dxlog_file2,
    L: 27,
    S: void 0,
    A: [
      "SchemaAST.isTypeLiteral(ast)",
      ""
    ]
  });
  const updatedProperties = [
    ...ast.propertySignatures
  ];
  const propertiesToUpdate = import_effect18.Schema.partial(import_effect18.Schema.Struct(fields)).ast.propertySignatures;
  for (const property of propertiesToUpdate) {
    const index = updatedProperties.findIndex((p) => p.name === property.name);
    if (index !== -1) {
      updatedProperties[index] = property;
    } else {
      updatedProperties.push(property);
    }
  }
  return import_effect18.Schema.make(new import_effect18.SchemaAST.TypeLiteral(updatedProperties, ast.indexSignatures, ast.annotations));
};
var removeFieldsFromSchema = (schema, fieldNames) => {
  return import_effect18.Schema.make(import_effect18.SchemaAST.omit(schema.ast, fieldNames)).annotations(schema.ast.annotations);
};
var updateFieldNameInSchema = (schema, { before, after }) => {
  const ast = schema.ast;
  (0, import_invariant4.invariant)(import_effect18.SchemaAST.isTypeLiteral(ast), void 0, {
    F: __dxlog_file2,
    L: 55,
    S: void 0,
    A: [
      "SchemaAST.isTypeLiteral(ast)",
      ""
    ]
  });
  return import_effect18.Schema.make(new import_effect18.SchemaAST.TypeLiteral(ast.propertySignatures.map((p) => p.name === before ? new import_effect18.SchemaAST.PropertySignature(after, p.type, p.isOptional, p.isReadonly, p.annotations) : p), ast.indexSignatures, ast.annotations));
};
var setTypenameInSchema = (schema, typename) => {
  const existingAnnotation = schema.ast.annotations[import_chunk_BRS5374V.TypeAnnotationId];
  (0, import_invariant4.invariant)(existingAnnotation, `Missing ${String(import_chunk_BRS5374V.TypeAnnotationId)}`, {
    F: __dxlog_file2,
    L: 75,
    S: void 0,
    A: [
      "existingAnnotation",
      "`Missing ${String(TypeAnnotationId)}`"
    ]
  });
  return schema.annotations({
    ...schema.ast.annotations,
    [import_chunk_BRS5374V.TypeAnnotationId]: {
      kind: existingAnnotation.kind,
      typename,
      version: existingAnnotation.version
    }
  });
};
var getSnapshot = (object) => {
  if (typeof object !== "object") {
    return object;
  }
  if (Array.isArray(object)) {
    return object.map(getSnapshot);
  }
  const result = {};
  for (const key in object) {
    result[key] = getSnapshot(object[key]);
  }
  return result;
};
var StoredSchema = import_effect19.Schema.Struct({
  typename: import_chunk_BRS5374V.Typename,
  version: import_chunk_BRS5374V.Version,
  jsonSchema: JsonSchemaType
}).pipe((0, import_chunk_BRS5374V.EchoObject)({
  typename: "dxos.org/type/Schema",
  version: "0.1.0"
}));
var __dxlog_file3 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-schema/src/schema/echo-schema.ts";
var ImmutableSchema = class {
  constructor(_schema) {
    this._schema = _schema;
    this._objectAnnotation = (0, import_chunk_BRS5374V.getTypeAnnotation)(this._schema);
    (0, import_invariant3.invariant)(this._objectAnnotation, void 0, {
      F: __dxlog_file3,
      L: 45,
      S: this,
      A: [
        "this._objectAnnotation",
        ""
      ]
    });
  }
  //
  // Effect Schema (push to abstract base class).
  //
  get [import_effect17.Schema.TypeId]() {
    return schemaVariance;
  }
  get Type() {
    return this._schema.Type;
  }
  get Encoded() {
    return this._schema.Encoded;
  }
  get Context() {
    return this._schema.Context;
  }
  get ast() {
    return this._schema.ast;
  }
  get annotations() {
    return this._schema.annotations;
  }
  get pipe() {
    return this._schema.pipe;
  }
  //
  // TypedObject
  //
  get typename() {
    return this._objectAnnotation.typename;
  }
  get version() {
    return this._objectAnnotation.version;
  }
  //
  // BaseSchema
  //
  get readonly() {
    return true;
  }
  get snapshot() {
    return this._schema;
  }
  // TODO(burdon): Change from getter since this is expensive.
  get jsonSchema() {
    return toJsonSchema(this._schema);
  }
  get mutable() {
    throw new Error("Schema is readonly.");
  }
};
var EchoSchemaConstructor = () => {
  var _a;
  return _a = import_effect17.Schema.TypeId, class {
    static get _schema() {
      return import_effect17.Schema.Union(StoredSchema, import_effect17.Schema.instanceOf(EchoSchema)).annotations(StoredSchema.ast.annotations);
    }
    static {
      this[_a] = schemaVariance;
    }
    static get ast() {
      const schema = this._schema;
      return schema.ast;
    }
    static get annotations() {
      const schema = this._schema;
      return schema.annotations.bind(schema);
    }
    static get pipe() {
      const schema = this._schema;
      return schema.pipe.bind(schema);
    }
  };
};
var isMutable = (schema) => {
  return schema instanceof EchoSchema;
};
var schemaVariance = {
  _A: (_) => _,
  _I: (_) => _,
  _R: (_) => _
};
var EchoSchema = class extends EchoSchemaConstructor() {
  constructor(_storedSchema) {
    super(), this._storedSchema = _storedSchema, this._isDirty = true;
  }
  //
  // Effect Schema (push to abstract base class).
  //
  get [import_effect17.Schema.TypeId]() {
    return schemaVariance;
  }
  get Type() {
    return this._storedSchema;
  }
  get Encoded() {
    return this._storedSchema;
  }
  get Context() {
    const schema = this._getSchema();
    return schema.Context;
  }
  get ast() {
    const schema = this._getSchema();
    return schema.ast;
  }
  get annotations() {
    const schema = this._getSchema();
    return schema.annotations.bind(schema);
  }
  get pipe() {
    const schema = this._getSchema();
    return schema.pipe.bind(schema);
  }
  //
  // BaseSchema
  //
  get typename() {
    return this._storedSchema.typename;
  }
  get version() {
    return this._storedSchema.version;
  }
  get readonly() {
    return false;
  }
  /**
  * Returns an immutable schema snapshot of the current state of the schema.
  */
  get snapshot() {
    return this._getSchema();
  }
  /**
  * @reactive
  */
  get jsonSchema() {
    return this._storedSchema.jsonSchema;
  }
  /**
  * Returns a mutable schema.
  */
  get mutable() {
    (0, import_invariant3.invariant)(!this.readonly, "Schema is not mutable", {
      F: __dxlog_file3,
      L: 258,
      S: this,
      A: [
        "!this.readonly",
        "'Schema is not mutable'"
      ]
    });
    return this;
  }
  //
  // Mutable Schema
  //
  /**
  * Id of the ECHO object containing the schema.
  */
  get id() {
    return this._storedSchema.id;
  }
  get [import_chunk_BRS5374V.SchemaMetaSymbol]() {
    return {
      id: this.id,
      typename: this.typename,
      version: this._storedSchema.version
    };
  }
  /**
  * Reference to the underlying stored schema object.
  */
  get storedSchema() {
    return this._storedSchema;
  }
  getProperties() {
    const ast = this._getSchema().ast;
    (0, import_invariant3.invariant)(import_effect17.SchemaAST.isTypeLiteral(ast), void 0, {
      F: __dxlog_file3,
      L: 286,
      S: this,
      A: [
        "SchemaAST.isTypeLiteral(ast)",
        ""
      ]
    });
    return [
      ...ast.propertySignatures
    ].filter((p) => p.name !== "id").map(unwrapOptionality);
  }
  //
  // Mutation methods.
  // TODO(burdon): Create separate interface for dynamic schema.
  // TODO(burdon): Deprecate direct manipulation? Use JSONSchema directly.
  //
  /**
  * @throws Error if the schema is readonly.
  */
  updateTypename(typename) {
    const updated = setTypenameInSchema(this._getSchema(), typename);
    this._storedSchema.typename = typename;
    this._storedSchema.jsonSchema = toJsonSchema(updated);
  }
  /**
  * @throws Error if the schema is readonly.
  */
  addFields(fields) {
    const extended = addFieldsToSchema(this._getSchema(), fields);
    this._storedSchema.jsonSchema = toJsonSchema(extended);
  }
  /**
  * @throws Error if the schema is readonly.
  */
  updateFields(fields) {
    const updated = updateFieldsInSchema(this._getSchema(), fields);
    this._storedSchema.jsonSchema = toJsonSchema(updated);
  }
  /**
  * @throws Error if the schema is readonly.
  */
  updateFieldPropertyName({ before, after }) {
    const renamed = updateFieldNameInSchema(this._getSchema(), {
      before,
      after
    });
    this._storedSchema.jsonSchema = toJsonSchema(renamed);
  }
  /**
  * @throws Error if the schema is readonly.
  */
  removeFields(fieldNames) {
    const removed = removeFieldsFromSchema(this._getSchema(), fieldNames);
    this._storedSchema.jsonSchema = toJsonSchema(removed);
  }
  //
  // Internals
  //
  /**
  * Called by EchoSchemaRegistry on update.
  */
  _invalidate() {
    this._isDirty = true;
  }
  /**
  * Rebuilds this schema if it is dirty.
  */
  _rebuild() {
    if (this._isDirty || this._schema == null) {
      this._schema = toEffectSchema(getSnapshot(this._storedSchema.jsonSchema));
      this._isDirty = false;
    }
  }
  _getSchema() {
    this._rebuild();
    return this._schema;
  }
};
var unwrapOptionality = (property) => {
  if (!import_effect17.SchemaAST.isUnion(property.type)) {
    return property;
  }
  return {
    ...property,
    type: property.type.types.find((type) => !import_effect17.SchemaAST.isUndefinedKeyword(type))
  };
};
var __dxlog_file4 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-schema/src/schema/runtime-schema-registry.ts";
var RuntimeSchemaRegistry = class {
  constructor() {
    this._registry = /* @__PURE__ */ new Map();
    this._registry.set(StoredSchema.typename, [
      StoredSchema
    ]);
  }
  get schemas() {
    return Array.from(this._registry.values()).flat();
  }
  hasSchema(schema) {
    const typename = (0, import_chunk_BRS5374V.getSchemaTypename)(schema);
    const version = (0, import_chunk_BRS5374V.getSchemaVersion)(schema);
    (0, import_invariant5.invariant)(typename, void 0, {
      F: __dxlog_file4,
      L: 33,
      S: this,
      A: [
        "typename",
        ""
      ]
    });
    const schemas = this._registry.get(typename);
    return schemas?.some((schema2) => (0, import_chunk_BRS5374V.getSchemaVersion)(schema2) === version) ?? false;
  }
  getSchemaByDXN(dxn) {
    const components = dxn.asTypeDXN();
    if (!components) {
      return void 0;
    }
    const { type, version } = components;
    const allSchemas = this._registry.get(type) ?? [];
    if (version) {
      return allSchemas.find((s) => (0, import_chunk_BRS5374V.getSchemaVersion)(s) === version);
    } else {
      return allSchemas.sort((a, b) => ((0, import_chunk_BRS5374V.getSchemaVersion)(a) ?? "0.0.0").localeCompare((0, import_chunk_BRS5374V.getSchemaVersion)(b) ?? "0.0.0"))[0];
    }
  }
  /**
  * @deprecated Use getSchemaByDXN.
  */
  getSchema(typename) {
    return this._registry.get(typename)?.[0];
  }
  addSchema(types) {
    types.forEach((schema) => {
      const typename = (0, import_chunk_BRS5374V.getSchemaTypename)(schema) ?? (0, import_debug2.raise)(new TypeError("Schema has no typename"));
      const version = (0, import_chunk_BRS5374V.getSchemaVersion)(schema) ?? (0, import_debug2.raise)(new TypeError("Schema has no version"));
      const versions = (0, import_util4.defaultMap)(this._registry, typename, () => []);
      if (versions.some((schema2) => (0, import_chunk_BRS5374V.getSchemaVersion)(schema2) === version)) {
        throw new Error(`Schema version already registered: ${typename}:${version}`);
      }
      versions.push(schema);
    });
  }
};
var __dxlog_file5 = "/home/runner/work/dxos/dxos/packages/core/echo/echo-schema/src/projection/compose.ts";
var composeSchema = (source, target) => {
  const result = getSnapshot(target);
  (0, import_invariant2.invariant)("type" in result && result.type === "object", "source schema must be an object", {
    F: __dxlog_file5,
    L: 17,
    S: void 0,
    A: [
      "'type' in result && result.type === 'object'",
      "'source schema must be an object'"
    ]
  });
  (0, import_invariant2.invariant)("type" in source && source.type === "object", "target schema must be an object", {
    F: __dxlog_file5,
    L: 18,
    S: void 0,
    A: [
      "'type' in source && source.type === 'object'",
      "'target schema must be an object'"
    ]
  });
  for (const prop in result.properties) {
    const propSchema = source.properties[prop];
    const annotations = propSchema?.annotations?.meta;
    if (annotations) {
      result.properties[prop].annotations ??= {};
      result.properties[prop].annotations.meta ??= {};
      for (const key in annotations) {
        result.properties[prop].annotations.meta[key] ??= {};
        Object.assign(result.properties[prop].annotations.meta[key], annotations[key], {
          ...result.properties[prop].annotations.meta[key]
        });
      }
    }
  }
  return result;
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ATTR_DELETED,
  ATTR_META,
  ATTR_RELATION_SOURCE,
  ATTR_RELATION_TARGET,
  ATTR_SELF_DXN,
  ATTR_TYPE,
  Currency,
  CurrencyAnnotationId,
  DecimalPrecision,
  DeletedId,
  ECHO_ANNOTATIONS_NS_DEPRECATED_KEY,
  ECHO_ANNOTATIONS_NS_KEY,
  EXPANDO_TYPENAME,
  EchoObject,
  EchoRelation,
  EchoSchema,
  Email,
  EntityKind,
  EntityKindId,
  EntityKindSchema,
  Expando,
  FIELD_PATH_ANNOTATION,
  FieldLookupAnnotationId,
  FieldPath,
  FieldSortType,
  ForeignKey,
  Format,
  FormatAnnotation,
  FormatAnnotationId,
  FormatEnum,
  FormatEnums,
  Formula,
  GeneratorAnnotation,
  GeneratorAnnotationId,
  GeoLocation,
  GeoPoint,
  Hostname,
  ImmutableSchema,
  JSON,
  JSON_SCHEMA_ECHO_REF_ID,
  JsonPath,
  JsonProp,
  JsonSchemaEchoAnnotations,
  JsonSchemaFields,
  JsonSchemaType,
  LabelAnnotation,
  LabelAnnotationId,
  Markdown,
  MetaId,
  ObjectId,
  ObjectMetaSchema,
  OptionsAnnotationId,
  PropType,
  PropertyKind,
  PropertyMeta,
  PropertyMetaAnnotationId,
  QueryType,
  RawObject,
  Ref,
  RefArray,
  RefImpl,
  RefTypeId,
  ReferenceAnnotationId,
  Regex,
  RelationSourceDXNId,
  RelationSourceId,
  RelationTargetDXNId,
  RelationTargetId,
  RuntimeSchemaRegistry,
  SchemaId,
  SchemaMetaSymbol,
  SchemaValidator,
  SelectOptionSchema,
  SelfDXNId,
  StaticRefResolver,
  StoredSchema,
  TypeAnnotation,
  TypeAnnotationId,
  TypeEnum,
  TypeId,
  TypeIdentifierAnnotationId,
  TypedObject,
  TypedRelation,
  Typename,
  URL,
  UUID,
  Version,
  addFieldsToSchema,
  assertObjectModelShape,
  attachTypedJsonSerializer,
  checkIdNotPresentOnSchema,
  compareForeignKeys,
  composeSchema,
  create,
  createAnnotationHelper,
  createEchoReferenceSchema,
  createJsonSchema,
  createQueueDXN,
  createSchemaReference,
  defineHiddenProperty,
  foreignKey,
  foreignKeyEquals,
  formatToType,
  getEntityKind,
  getFormatAnnotation,
  getLabel,
  getLabelForObject,
  getMeta,
  getNormalizedEchoAnnotations,
  getObjectDXN,
  getObjectMeta,
  getOptionsAnnotation,
  getPropertyMetaAnnotation,
  getRefSavedTarget,
  getReferenceAnnotation,
  getSchema,
  getSchemaDXN,
  getSchemaProperty,
  getSchemaReference,
  getSchemaTypename,
  getSchemaVersion,
  getSnapshot,
  getType,
  getTypeAnnotation,
  getTypeEnum,
  getTypeIdentifierAnnotation,
  getTypeReference,
  getTypename,
  getValue,
  isDeleted,
  isInstanceOf,
  isMutable,
  makeTypedEntityClass,
  normalizeSchema,
  objectFromJSON,
  objectToJSON,
  refFromEncodedReference,
  removeFieldsFromSchema,
  requireTypeReference,
  setRefResolver,
  setSchema,
  setSchemaProperty,
  setTypename,
  setTypenameInSchema,
  setValue,
  splitJsonPath,
  splitMeta,
  toEffectSchema,
  toJsonSchema,
  toPropType,
  typeToFormat,
  updateFieldNameInSchema,
  updateFieldsInSchema
});
//# sourceMappingURL=index.cjs.map
