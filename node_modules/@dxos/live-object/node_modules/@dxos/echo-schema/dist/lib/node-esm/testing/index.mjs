import { createRequire } from 'node:module';const require = createRequire(import.meta.url);
import {
  EchoObject,
  EchoRelation,
  Expando,
  Ref,
  TypedObject
} from "../chunk-54NDCEXR.mjs";

// packages/core/echo/echo-schema/src/testing/types.ts
import { Schema } from "effect";
(function(Testing2) {
  const Circle = Schema.Struct({
    type: Schema.Literal("circle"),
    radius: Schema.Number
  });
  const Square = Schema.Struct({
    type: Schema.Literal("square"),
    side: Schema.Number
  });
  const Shape = Schema.Union(Circle, Square);
  const TestNestedSchema = Schema.mutable(Schema.Struct({
    field: Schema.String
  }));
  Testing2.TestNestedType = TestNestedSchema.pipe(EchoObject({
    typename: "example.com/type/TestNested",
    version: "0.1.0"
  }));
  class EmptySchemaType extends TypedObject({
    typename: "example.com/type/Empty",
    version: "0.1.0"
  })({}) {
  }
  Testing2.EmptySchemaType = EmptySchemaType;
  const fields = {
    string: Schema.String,
    number: Schema.Number,
    nullableShapeArray: Schema.mutable(Schema.Array(Schema.Union(Shape, Schema.Null))),
    boolean: Schema.Boolean,
    null: Schema.Null,
    undefined: Schema.Undefined,
    stringArray: Schema.mutable(Schema.Array(Schema.String)),
    twoDimNumberArray: Schema.mutable(Schema.Array(Schema.mutable(Schema.Array(Schema.Number)))),
    object: TestNestedSchema,
    objectArray: Schema.mutable(Schema.Array(TestNestedSchema)),
    nested: Schema.optional(Ref(Testing2.TestNestedType)),
    other: Schema.Any
  };
  Testing2.TestSchema = Schema.mutable(Schema.partial(Schema.Struct(fields)));
  class TestSchemaType extends TypedObject({
    typename: "example.com/type/Test",
    version: "0.1.0"
  })(fields, {
    partial: true
  }) {
  }
  Testing2.TestSchemaType = TestSchemaType;
  Testing2.TestType = Testing2.TestSchema.pipe(EchoObject({
    typename: "example.com/type/Test",
    version: "0.1.0"
  }));
  class TestClass {
    constructor() {
      this.field = "value";
    }
    toJSON() {
      return {
        field: this.field
      };
    }
  }
  Testing2.TestClass = TestClass;
  Testing2.TestSchemaWithClass = Schema.mutable(Schema.extend(Testing2.TestSchema, Schema.mutable(Schema.Struct({
    classInstance: Schema.optional(Schema.instanceOf(TestClass))
  }))));
  class Contact extends TypedObject({
    typename: "example.com/type/Contact",
    version: "0.1.0"
  })({
    name: Schema.String,
    username: Schema.String,
    email: Schema.String,
    tasks: Schema.suspend(() => Schema.mutable(Schema.Array(Ref(Task)))),
    address: Schema.Struct({
      city: Schema.optional(Schema.String),
      state: Schema.optional(Schema.String),
      zip: Schema.optional(Schema.String),
      coordinates: Schema.Struct({
        lat: Schema.optional(Schema.Number),
        lng: Schema.optional(Schema.Number)
      })
    })
  }, {
    partial: true
  }) {
  }
  Testing2.Contact = Contact;
  class Task extends TypedObject({
    typename: "example.com/type/Task",
    version: "0.1.0"
  })({
    title: Schema.optional(Schema.String),
    completed: Schema.optional(Schema.Boolean),
    assignee: Schema.optional(Ref(Contact)),
    previous: Schema.optional(Schema.suspend(() => Ref(Task))),
    subTasks: Schema.optional(Schema.mutable(Schema.Array(Schema.suspend(() => Ref(Task))))),
    description: Schema.optional(Schema.String)
  }, {
    partial: true
  }) {
  }
  Testing2.Task = Task;
  (function(RecordType) {
    RecordType[RecordType["UNDEFINED"] = 0] = "UNDEFINED";
    RecordType[RecordType["PERSONAL"] = 1] = "PERSONAL";
    RecordType[RecordType["WORK"] = 2] = "WORK";
  })(Testing2.RecordType || (Testing2.RecordType = {}));
  class Container extends TypedObject({
    typename: "example.com/type/Container",
    version: "0.1.0"
  })({
    objects: Schema.mutable(Schema.Array(Ref(Expando))),
    records: Schema.mutable(Schema.Array(Schema.partial(Schema.Struct({
      title: Schema.String,
      description: Schema.String,
      contacts: Schema.mutable(Schema.Array(Ref(Contact))),
      type: Schema.Enums(Testing2.RecordType)
    }))))
  }, {
    partial: true
  }) {
  }
  Testing2.Container = Container;
  Testing2.HasManager = Schema.Struct({
    since: Schema.optional(Schema.String)
  }).pipe(EchoRelation({
    typename: "example.com/type/HasManager",
    version: "0.1.0",
    source: Contact,
    target: Contact
  }));
})(Testing || (Testing = {}));
var Testing;

// packages/core/echo/echo-schema/src/testing/utils.ts
import { effect } from "@preact/signals-core";
import { registerSignalsRuntime } from "@dxos/echo-signals";
import { deepMapValues } from "@dxos/util";
registerSignalsRuntime();
var updateCounter = (touch) => {
  let updateCount = -1;
  const unsubscribe = effect(() => {
    touch();
    updateCount++;
  });
  return {
    // https://github.com/tc39/proposal-explicit-resource-management
    [Symbol.dispose]: unsubscribe,
    get count() {
      return updateCount;
    }
  };
};
var prepareAstForCompare = (obj) => deepMapValues(obj, (value, recurse, key) => {
  if (typeof value === "function") {
    return null;
  }
  if (value instanceof RegExp) {
    return value;
  }
  if (typeof value === "object") {
    const clone = {
      ...value
    };
    for (const sym of Object.getOwnPropertySymbols(clone)) {
      clone[sym.toString()] = clone[sym];
      delete clone[sym];
    }
    return recurse(clone);
  }
  return recurse(value);
});
export {
  Testing,
  prepareAstForCompare,
  updateCounter
};
//# sourceMappingURL=index.mjs.map
