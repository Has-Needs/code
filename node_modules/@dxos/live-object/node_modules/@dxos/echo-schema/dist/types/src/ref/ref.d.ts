import { Schema, SchemaAST } from 'effect';
import { type EncodedReference } from '@dxos/echo-protocol';
import { DXN, ObjectId } from '@dxos/keys';
import { type JsonSchemaType } from '../json-schema';
import type { BaseObject, WithId } from '../types';
/**
 * The `$id` field for an ECHO reference schema.
 */
export declare const JSON_SCHEMA_ECHO_REF_ID = "/schemas/echo/ref";
export declare const getSchemaReference: (property: JsonSchemaType) => {
    typename: string;
} | undefined;
export declare const createSchemaReference: (typename: string) => JsonSchemaType;
export declare const RefTypeId: unique symbol;
/**
 * Reference Schema.
 */
export interface Ref$<T extends WithId> extends Schema.SchemaClass<Ref<T>, EncodedReference> {
}
export interface RefFn {
    <S extends Schema.Schema.Any>(schema: S): Ref$<Schema.Schema.Type<S>>;
    /**
     * @returns True if the object is a reference.
     */
    isRef: (obj: any) => obj is Ref<any>;
    /**
     * @returns True if the reference points to the given object id.
     */
    hasObjectId: (id: ObjectId) => (ref: Ref<any>) => boolean;
    /**
     * @returns True if the schema is a reference schema.
     */
    isRefSchema: (schema: Schema.Schema<any, any>) => schema is Ref$<any>;
    /**
     * @returns True if the schema AST is a reference schema.
     */
    isRefSchemaAST: (ast: SchemaAST.AST) => boolean;
    /**
     * Constructs a reference that points to the given object.
     */
    make: <T extends WithId>(object: T) => Ref<T>;
    /**
     * Constructs a reference that points to the object specified by the provided DXN.
     */
    fromDXN: (dxn: DXN) => Ref<any>;
}
/**
 * Schema builder for references.
 */
export declare const Ref: RefFn;
/**
 * Represents materialized reference to a target.
 * This is the data type for the fields marked as ref.
 */
export interface Ref<T> {
    /**
     * Target object DXN.
     */
    get dxn(): DXN;
    /**
     * @returns The reference target.
     * May return `undefined` if the object is not loaded in the working set.
     * Accessing this property, even if it returns `undefined` will trigger the object to be loaded to the working set.
     *
     * @reactive Supports signal subscriptions.
     */
    get target(): T | undefined;
    /**
     * @returns Promise that will resolves with the target object.
     * Will load the object from disk if it is not present in the working set.
     * @throws If the object is not available locally.
     */
    load(): Promise<T>;
    /**
     * @returns Promise that will resolves with the target object or undefined if the object is not loaded locally.
     */
    tryLoad(): Promise<T | undefined>;
    /**
     * Do not inline the target object in the reference.
     * Makes .target unavailable unless the reference is connected to a database context.
     *
     * When serialized with toJSON, the difference is between:
     * `{ "/": "dxn:..." }`
     * and
     * `{ "/": "dxn:...", "target": { ... } }`
     */
    noInline(): this;
    /**
     * Serializes the reference to a JSON object.
     * The serialization format is compatible with the IPLD-style encoded references.
     * When a reference has a saved target (i.e. the target or object holding the reference is not in the database),
     * the target is included in the serialized object.
     *
     * Examples:
     * `{ "/": "dxn:..." }`
     * `{ "/": "dxn:...", "target": { ... } }`
     */
    encode(): EncodedReference;
    [RefTypeId]: {
        _T: T;
    };
}
export declare namespace Ref {
    /**
     * Target of the reference.
     */
    type Target<R> = R extends Ref<infer U> ? U : never;
}
/**
 * `reference` field on the schema object.
 */
export type JsonSchemaReferenceInfo = {
    schema: {
        $ref: string;
    };
    schemaVersion?: string;
};
export interface RefResolver {
    /**
     * Resolve ref synchronously from the objects in the working set.
     *
     * @param dxn
     * @param load If true the resolver should attempt to load the object from disk.
     * @param onLoad Callback to call when the object is loaded.
     */
    resolveSync(dxn: DXN, load: boolean, onLoad?: () => void): BaseObject | undefined;
    /**
     * Resolver ref asynchronously.
     */
    resolve(dxn: DXN): Promise<BaseObject | undefined>;
    resolveSchema(dxn: DXN): Promise<Schema.Schema.AnyNoContext | undefined>;
}
export declare class RefImpl<T> implements Ref<T> {
    #private;
    constructor(dxn: DXN, target?: T);
    /**
     * @inheritdoc
     */
    get dxn(): DXN;
    /**
     * @inheritdoc
     */
    get target(): T | undefined;
    /**
     * @inheritdoc
     */
    load(): Promise<T>;
    /**
     * @inheritdoc
     */
    tryLoad(): Promise<T | undefined>;
    /**
     * Do not inline the target object in the reference.
     * Makes .target unavailable unless the reference is connected to a database context.
     */
    noInline(): this;
    encode(): EncodedReference;
    /**
     * Serializes the reference to a JSON object.
     * The serialization format is compatible with the IPLD-style encoded references.
     * When a reference has a saved target (i.e. the target or object holding the reference is not in the database),
     * the target is included in the serialized object.
     */
    toJSON(): EncodedReference;
    toString(): string;
    [RefTypeId]: {
        _T: any;
    };
}
/**
 * Internal API for setting the reference resolver.
 */
export declare const setRefResolver: (ref: Ref<any>, resolver: RefResolver) => void;
/**
 * Internal API for getting the saved target on a reference.
 */
export declare const getRefSavedTarget: (ref: Ref<any>) => BaseObject | undefined;
export declare const refFromEncodedReference: (encodedReference: EncodedReference, resolver?: RefResolver) => Ref<any>;
export declare class StaticRefResolver implements RefResolver {
    objects: Map<string, BaseObject>;
    schemas: Map<DXN.String, Schema.Schema.AnyNoContext>;
    addObject(obj: BaseObject): this;
    addSchema(schema: Schema.Schema.AnyNoContext): this;
    resolveSync(dxn: DXN, _load: boolean, _onLoad?: () => void): BaseObject | undefined;
    resolve(dxn: DXN): Promise<BaseObject | undefined>;
    resolveSchema(dxn: DXN): Promise<Schema.Schema.AnyNoContext | undefined>;
}
//# sourceMappingURL=ref.d.ts.map