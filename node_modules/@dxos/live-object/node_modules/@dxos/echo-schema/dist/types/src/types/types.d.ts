import { Schema } from 'effect';
import { Reference } from '@dxos/echo-protocol';
import { type JsonPath } from '@dxos/effect';
import { type ObjectMeta, type EntityKindId } from '../object';
import { ATTR_META } from '../object/model';
/**
 * Base type for all data objects (reactive, ECHO, and other raw objects).
 * NOTE: This describes the base type for all database objects.
 * It is stricter than `T extends {}` or `T extends object`.
 */
export type BaseObject = Record<string, any>;
/**
 * Marker interface for object with an `id`.
 */
export type HasId = {
    readonly id: string;
};
export type WithId = BaseObject & HasId;
export type ExcludeId<T extends BaseObject> = Omit<T, 'id'>;
export type CreationProps<T extends BaseObject> = Omit<T, 'id' | typeof EntityKindId>;
export type PropertyKey<T extends BaseObject> = Extract<keyof ExcludeId<T>, string>;
export type WithMeta = {
    [ATTR_META]?: ObjectMeta;
};
/**
 * The raw object should not include the ECHO id, but may include metadata.
 */
export declare const RawObject: <S extends Schema.Schema.AnyNoContext>(schema: S) => Schema.Schema<ExcludeId<Schema.Schema.Type<S>> & WithMeta, Schema.Schema.Encoded<S>>;
/**
 * @deprecated No longer used.
 */
export interface CommonObjectData {
    id: string;
    __typename: string | null;
    __meta: ObjectMeta;
}
/**
 * @deprecated No longer used.
 */
export interface AnyObjectData extends CommonObjectData {
    /**
     * Fields of the object.
     */
    [key: string]: any;
}
/**
 * Object data type in JSON-encodable format.
 * References are encoded in the IPLD format.
 * `__typename` is the string DXN of the object type.
 * Meta is added under `__meta` key.
 * @deprecated No longer used.
 */
export type ObjectData<S> = Schema.Schema.Encoded<S> & CommonObjectData;
/**
 * Utility to split meta property from raw object.
 * @deprecated Bad API.
 */
export declare const splitMeta: <T>(object: T & WithMeta) => {
    object: T;
    meta?: ObjectMeta;
};
export declare const getValue: <T extends object>(obj: T, path: JsonPath) => any;
export declare const setValue: <T extends object>(obj: T, path: JsonPath, value: any) => T;
/**
 * Returns a reference that will be used to point to a schema.
 * @deprecated Use {@link getSchemaDXN} instead.
 */
export declare const getTypeReference: (schema: Schema.Schema.All | undefined) => Reference | undefined;
/**
 * Returns a reference that will be used to point to a schema.
 * @throws If it is not possible to reference this schema.
 *
 * @deprecated Use {@link getSchemaDXN} instead.
 */
export declare const requireTypeReference: (schema: Schema.Schema.AnyNoContext) => Reference;
/**
 * Checks if the object is an instance of the schema.
 * Only typename is compared, the schema version is ignored.
 *
 * The following cases are considered to mean that the object is an instance of the schema:
 *  - Object was created with this exact schema.
 *  - Object was created with a different version of this schema.
 *  - Object was created with a different schema (maybe dynamic) that has the same typename.
 */
export declare const isInstanceOf: <Schema extends Schema.Schema.AnyNoContext>(schema: Schema, object: any) => object is Schema.Schema.Type<Schema>;
/**
 * Object that has an associated typename.
 * The typename is retrievable using {@link getTypename}.
 * The object can be used with {@link isInstanceOf} to check if it is an instance of a schema.
 */
export type HasTypename = {};
/**
 * Canonical type for all ECHO objects.
 * @deprecated Use `AnyEchoObject` instead.
 */
export interface BaseEchoObject extends HasId, HasTypename {
}
export interface AnyEchoObject extends BaseEchoObject {
}
//# sourceMappingURL=types.d.ts.map