import type { DXN, ObjectId } from '@dxos/keys';
import { type RawString } from './automerge';
import type { ForeignKey } from './foreign-key';
import { type EncodedReference } from './reference';
import { type SpaceDocVersion } from './space-doc-version';
export type SpaceState = {
    rootUrl?: string;
};
/**
 * Array indexes get converted to strings.
 */
export type ObjectProp = string;
export type ObjectPropPath = ObjectProp[];
/**
 * Link to all documents that hold objects in the space.
 */
export interface DatabaseDirectory {
    version?: SpaceDocVersion;
    access?: {
        spaceKey: string;
    };
    /**
     * Objects inlined in the current document.
     */
    objects?: {
        [id: string]: ObjectStructure;
    };
    /**
     * Object id points to an automerge doc url where the object is embedded.
     */
    links?: {
        [echoId: string]: string | RawString;
    };
    /**
     * @deprecated
     * For backward compatibility.
     */
    experimental_spaceKey?: string;
}
export declare const DatabaseDirectory: Readonly<{
    /**
     * @returns Space key in hex of the space that owns the document. In hex format. Without 0x prefix.
     */
    getSpaceKey: (doc: DatabaseDirectory) => string | null;
    getInlineObject: (doc: DatabaseDirectory, id: ObjectId) => ObjectStructure | undefined;
    getLink: (doc: DatabaseDirectory, id: ObjectId) => string | undefined;
    make: ({ spaceKey, objects, links, }: {
        spaceKey: string;
        objects?: Record<string, ObjectStructure>;
        links?: Record<string, RawString>;
    }) => DatabaseDirectory;
}>;
/**
 * Representation of an ECHO object in an AM document.
 */
export type ObjectStructure = {
    system?: ObjectSystem;
    meta: ObjectMeta;
    /**
     * User-defined data.
     * Adheres to schema in `system.type`
     */
    data: Record<string, any>;
};
export declare const ObjectStructure: Readonly<{
    /**
     * @throws On invalid object structure.
     */
    getTypeReference: (object: ObjectStructure) => EncodedReference | undefined;
    /**
     * @throws On invalid object structure.
     */
    getEntityKind: (object: ObjectStructure) => "object" | "relation";
    isDeleted: (object: ObjectStructure) => boolean;
    getRelationSource: (object: ObjectStructure) => EncodedReference | undefined;
    getRelationTarget: (object: ObjectStructure) => EncodedReference | undefined;
    /**
     * @returns All references in the data section of the object.
     */
    getAllOutgoingReferences: (object: ObjectStructure) => {
        path: ObjectPropPath;
        reference: EncodedReference;
    }[];
    makeObject: ({ type, data, keys, }: {
        type: DXN.String;
        deleted?: boolean;
        keys?: ForeignKey[];
        data?: unknown;
    }) => ObjectStructure;
    makeRelation: ({ type, source, target, deleted, keys, data, }: {
        type: DXN.String;
        source: EncodedReference;
        target: EncodedReference;
        deleted?: boolean;
        keys?: ForeignKey[];
        data?: unknown;
    }) => ObjectStructure;
}>;
/**
 * Echo object metadata.
 */
export type ObjectMeta = {
    /**
     * Foreign keys.
     */
    keys: ForeignKey[];
};
/**
 * Automerge object system properties.
 * (Is automerge specific.)
 */
export type ObjectSystem = {
    /**
     * Entity kind.
     */
    kind?: 'object' | 'relation';
    /**
     * Object reference ('protobuf' protocol) type.
     */
    type?: EncodedReference;
    /**
     * Deletion marker.
     */
    deleted?: boolean;
    /**
     * Only for relations.
     */
    source?: EncodedReference;
    /**
     * Only for relations.w
     */
    target?: EncodedReference;
};
/**
 * Id property name.
 */
export declare const PROPERTY_ID = "id";
/**
 * Data namespace.
 * The key on {@link ObjectStructure} that contains the user-defined data.
 */
export declare const DATA_NAMESPACE = "data";
//# sourceMappingURL=document-structure.d.ts.map