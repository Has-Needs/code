{
  "version": 3,
  "sources": ["../../../src/keys.ts", "../../../src/browser/subtle.ts", "../../../src/validator.ts", "../../../src/verify.ts", "../../../src/uuid.ts"],
  "sourcesContent": ["//\n// Copyright 2020 DXOS.org\n//\n\nimport { invariant } from '@dxos/invariant';\nimport { type KeyPair, PublicKey, type PublicKeyLike, PUBLIC_KEY_LENGTH, SECRET_KEY_LENGTH } from '@dxos/keys';\n\nimport crypto from '#hypercore-crypto';\n\nexport const SIGNATURE_LENGTH = 64;\n\n/**\n * @deprecated\n */\n// TODO(burdon): Remove.\nexport const createId = (): string => PublicKey.stringify(randomBytes(32));\n\nexport const createKeyPair = (seed?: Buffer): KeyPair => {\n  if (seed) {\n    invariant(seed.length >= 32, 'Seedphrase too sort. Expecting length of 32.');\n    return crypto.keyPair(seed.slice(0, 32));\n  }\n\n  // TODO(burdon): Enable seed for debugging.\n  return crypto.keyPair();\n};\n\n// TODO(burdon): Buffer.\nexport const validateKeyPair = (publicKey: PublicKey, secretKey: Buffer) =>\n  crypto.validateKeyPair({ publicKey: publicKey.asBuffer(), secretKey });\n\n// TODO(dmaretskyi): Slicing because webcrypto keys are too long.\nexport const discoveryKey = (key: PublicKeyLike): Buffer =>\n  crypto.discoveryKey(PublicKey.from(key).asBuffer().slice(1));\n\n/**\n * Return random bytes of length.\n * @param [length=32]\n * @return {Buffer}\n */\nexport const randomBytes = (length = 32): Buffer => crypto.randomBytes(length);\n\n/**\n * Sign the contents of message with secret_key\n * @param {Buffer} message\n * @param {Buffer} secretKey\n * @returns {Buffer} signature\n */\nexport const sign = (message: Buffer, secretKey: Buffer): Buffer => {\n  invariant(Buffer.isBuffer(message));\n  invariant(Buffer.isBuffer(secretKey) && secretKey.length === SECRET_KEY_LENGTH);\n\n  return crypto.sign(message, secretKey);\n};\n\n/**\n * Verifies the signature against the message and public_key.\n * @param {Buffer} message\n * @param {Buffer} publicKey\n * @param {Buffer} signature\n * @return {boolean}\n */\nexport const verify = (message: Buffer, signature: Buffer, publicKey: Buffer): boolean => {\n  invariant(Buffer.isBuffer(message));\n  invariant(Buffer.isBuffer(signature) && signature.length === SIGNATURE_LENGTH);\n  invariant(Buffer.isBuffer(publicKey) && publicKey.length === PUBLIC_KEY_LENGTH);\n\n  return crypto.verify(message, signature, publicKey);\n};\n", "//\n// Copyright 2022 DXOS.org\n//\n\n// Replacement implementation for the browser (see package.json).\n\nexport const subtleCrypto = crypto.subtle;\n\nexport const webcrypto = crypto;\n", "//\n// Copyright 2020 DXOS.org\n//\n\nimport { PublicKey } from '@dxos/keys';\n\nimport { verify } from '#hypercore-crypto';\n\n/**\n * Generator for signature validation function.\n * @param {String} publicKey\n */\nexport const getSignatureValidator = (publicKey: string) => (message: Buffer, signature: Buffer) =>\n  verify(message, signature, PublicKey.bufferize(publicKey));\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { type PublicKey } from '@dxos/keys';\n\nimport { subtleCrypto } from './subtle';\n\n/**\n * Verify a signature with the given key.\n */\nexport const verifySignature = async (\n  key: PublicKey,\n  message: Uint8Array,\n  signature: Uint8Array,\n  algorithm: { name: string; namedCurve?: string } = { name: 'ECDSA', namedCurve: 'P-256' },\n): Promise<boolean> => {\n  let publicKey!: CryptoKey;\n\n  try {\n    publicKey = await subtleCrypto.importKey('raw', key.asUint8Array(), algorithm, true, ['verify']);\n  } catch {\n    return false;\n  }\n\n  return subtleCrypto.verify(\n    {\n      name: algorithm.name,\n      hash: 'SHA-256',\n    },\n    publicKey,\n    signature,\n    message,\n  );\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { webcrypto } from './subtle';\n\nexport const randomUUID = (): string => {\n  return webcrypto.randomUUID();\n};\n"],
  "mappings": ";;;AAIA,SAASA,iBAAiB;AAC1B,SAAuBC,WAA+BC,mBAAmBC,yBAAyB;AAElG,OAAOC,aAAY;;AAEZ,IAAMC,mBAAmB;AAMzB,IAAMC,WAAW,MAAcL,UAAUM,UAAUC,YAAY,EAAA,CAAA;AAE/D,IAAMC,gBAAgB,CAACC,SAAAA;AAC5B,MAAIA,MAAM;AACRV,cAAUU,KAAKC,UAAU,IAAI,gDAAA;;;;;;;;;AAC7B,WAAOP,QAAOQ,QAAQF,KAAKG,MAAM,GAAG,EAAA,CAAA;EACtC;AAGA,SAAOT,QAAOQ,QAAO;AACvB;AAGO,IAAME,kBAAkB,CAACC,WAAsBC,cACpDZ,QAAOU,gBAAgB;EAAEC,WAAWA,UAAUE,SAAQ;EAAID;AAAU,CAAA;AAG/D,IAAME,eAAe,CAACC,QAC3Bf,QAAOc,aAAajB,UAAUmB,KAAKD,GAAAA,EAAKF,SAAQ,EAAGJ,MAAM,CAAA,CAAA;AAOpD,IAAML,cAAc,CAACG,SAAS,OAAeP,QAAOI,YAAYG,MAAAA;AAQhE,IAAMU,OAAO,CAACC,SAAiBN,cAAAA;AACpChB,YAAUuB,OAAOC,SAASF,OAAAA,GAAAA,QAAAA;;;;;;;;;AAC1BtB,YAAUuB,OAAOC,SAASR,SAAAA,KAAcA,UAAUL,WAAWR,mBAAAA,QAAAA;;;;;;;;;AAE7D,SAAOC,QAAOiB,KAAKC,SAASN,SAAAA;AAC9B;AASO,IAAMS,SAAS,CAACH,SAAiBI,WAAmBX,cAAAA;AACzDf,YAAUuB,OAAOC,SAASF,OAAAA,GAAAA,QAAAA;;;;;;;;;AAC1BtB,YAAUuB,OAAOC,SAASE,SAAAA,KAAcA,UAAUf,WAAWN,kBAAAA,QAAAA;;;;;;;;;AAC7DL,YAAUuB,OAAOC,SAAST,SAAAA,KAAcA,UAAUJ,WAAWT,mBAAAA,QAAAA;;;;;;;;;AAE7D,SAAOE,QAAOqB,OAAOH,SAASI,WAAWX,SAAAA;AAC3C;;;AC9DO,IAAMY,eAAeC,OAAOC;AAE5B,IAAMC,YAAYF;;;ACJzB,SAASG,aAAAA,kBAAiB;AAE1B,SAASC,UAAAA,eAAc;AAMhB,IAAMC,wBAAwB,CAACC,cAAsB,CAACC,SAAiBC,cAC5EC,QAAOF,SAASC,WAAWE,WAAUC,UAAUL,SAAAA,CAAAA;;;ACF1C,IAAMM,kBAAkB,OAC7BC,KACAC,SACAC,WACAC,YAAmD;EAAEC,MAAM;EAASC,YAAY;AAAQ,MAAC;AAEzF,MAAIC;AAEJ,MAAI;AACFA,gBAAY,MAAMC,aAAaC,UAAU,OAAOR,IAAIS,aAAY,GAAIN,WAAW,MAAM;MAAC;KAAS;EACjG,QAAQ;AACN,WAAO;EACT;AAEA,SAAOI,aAAaG,OAClB;IACEN,MAAMD,UAAUC;IAChBO,MAAM;EACR,GACAL,WACAJ,WACAD,OAAAA;AAEJ;;;AC5BO,IAAMW,aAAa,MAAA;AACxB,SAAOC,UAAUD,WAAU;AAC7B;",
  "names": ["invariant", "PublicKey", "PUBLIC_KEY_LENGTH", "SECRET_KEY_LENGTH", "crypto", "SIGNATURE_LENGTH", "createId", "stringify", "randomBytes", "createKeyPair", "seed", "length", "keyPair", "slice", "validateKeyPair", "publicKey", "secretKey", "asBuffer", "discoveryKey", "key", "from", "sign", "message", "Buffer", "isBuffer", "verify", "signature", "subtleCrypto", "crypto", "subtle", "webcrypto", "PublicKey", "verify", "getSignatureValidator", "publicKey", "message", "signature", "verify", "PublicKey", "bufferize", "verifySignature", "key", "message", "signature", "algorithm", "name", "namedCurve", "publicKey", "subtleCrypto", "importKey", "asUint8Array", "verify", "hash", "randomUUID", "webcrypto"]
}
