{
  "version": 3,
  "sources": ["../../../src/callback.ts", "../../../src/chain.ts", "../../../src/cleanup.ts", "../../../src/debounce.ts", "../../../src/errors.ts", "../../../src/timeout.ts", "../../../src/event-emitter.ts", "../../../src/events.ts", "../../../src/latch.ts", "../../../src/mutex.ts", "../../../src/observable.ts", "../../../src/trigger.ts", "../../../src/observable-value.ts", "../../../src/persistent-lifecycle.ts", "../../../src/task-scheduling.ts", "../../../src/track-leaks.ts", "../../../src/push-iterable.ts", "../../../src/sink.ts", "../../../src/stream-to-array.ts", "../../../src/test-stream.ts", "../../../src/testing.ts", "../../../src/timer.ts", "../../../src/until.ts", "../../../src/update-scheduler.ts"],
  "sourcesContent": ["//\n// Copyright 2020 DXOS.org\n//\n\n/**\n * Helper to convert a callback based API into a promise based API.\n */\nexport const createPromiseFromCallback = <T = void>(\n  run: (cb: (error?: Error, value?: T) => void) => void,\n): Promise<T> =>\n  new Promise((resolve, reject) => {\n    run((error, value) => {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(value!);\n      }\n    });\n  });\n", "//\n// Copyright 2022 DXOS.org\n//\n\ntype Transform = (...args: any) => Promise<any>;\n\n/**\n * Async reducer iteratively applies functions to the given array of elements.\n */\nexport const asyncChain =\n  <T>(chain: Transform[]) =>\n  async (elements: Promise<T[]>) => {\n    let result = await elements;\n    for (const part of chain) {\n      result = await Promise.all(result.map(async (element) => await part(element)));\n    }\n\n    return result;\n  };\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { ComplexMap, type PrimitiveProjection } from '@dxos/util';\n\nexport type CleanupFn = () => void;\n\n/**\n * Combine multiple cleanup functions into a single cleanup function.\n * Can be used in effect hooks in conjunction with `addEventListener`.\n */\nexport const combine = (...cleanupFns: (CleanupFn | CleanupFn[])[]): CleanupFn => {\n  return () => {\n    cleanupFns.flat().forEach((cleanupFn) => cleanupFn());\n  };\n};\n\nexport const timeout = (cb: Function, ms = 0): CleanupFn => {\n  const t = setTimeout(cb, ms);\n  return () => clearTimeout(t);\n};\n\nexport const interval = (cb: Function, ms: number): CleanupFn => {\n  const t = setInterval(cb, ms);\n  return () => clearInterval(t);\n};\n\ntype EventMap<T> = T extends Window\n  ? WindowEventMap\n  : T extends Document\n    ? DocumentEventMap\n    : T extends HTMLElement\n      ? HTMLElementEventMap\n      : Record<string, Event>;\n\n/**\n * Add the event listener and return a cleanup function.\n * Can be used in effect hooks in conjunction with `combine`.\n */\nexport function addEventListener<T extends EventTarget, K extends keyof EventMap<T>>(\n  target: T,\n  type: K,\n  listener: (this: T, ev: EventMap<T>[K]) => any,\n  options?: boolean | AddEventListenerOptions,\n): CleanupFn {\n  target.addEventListener(type as string, listener as EventListener, options);\n  return () => target.removeEventListener(type as string, listener as EventListener, options);\n}\n\nexport class SubscriptionList {\n  private readonly _cleanups: CleanupFn[] = [];\n\n  add(cb: CleanupFn): this {\n    this._cleanups.push(cb);\n    return this;\n  }\n\n  clear(): void {\n    this._cleanups.forEach((cb) => cb());\n    this._cleanups.length = 0;\n  }\n}\n\nexport class SubscriptionSet<T = any> {\n  private readonly _cleanupMap: ComplexMap<T, CleanupFn>;\n\n  constructor(keyProjection: PrimitiveProjection<T>) {\n    this._cleanupMap = new ComplexMap<T, CleanupFn>(keyProjection);\n  }\n\n  set(key: T, cb: CleanupFn): this {\n    this._cleanupMap.set(key, cb);\n    return this;\n  }\n\n  clear(): void {\n    this._cleanupMap.forEach((cb) => cb());\n    this._cleanupMap.clear();\n  }\n}\n", "//\n// Copyright 2023 DXOS.org\n//\n\n/**\n * Debounce callback.\n */\nexport const debounce = (cb: (...args: any[]) => void, wait = 100): ((...args: any[]) => void) => {\n  let t: ReturnType<typeof setTimeout>;\n  return (...args: any[]) => {\n    clearTimeout(t);\n    t = setTimeout(() => cb(...args), wait);\n  };\n};\n", "//\n// Copyright 2020 DXOS.org\n//\n\nimport { type ObservableProvider } from './observable-value';\n\n// TODO(burdon): Move to debug.\n//  Use: https://nodejs.org/api/errors.html\nexport const toError = (err: any) => (err === undefined || typeof err === 'string' ? new Error(err) : err);\n\nexport class TimeoutError extends Error {\n  constructor(timeout?: number, label?: string) {\n    super(timeout ? `Timeout [${timeout.toLocaleString()}ms]${label === undefined ? '' : `: ${label}`}` : 'Timeout');\n  }\n}\n\nexport interface AsyncEvents<T = any> {\n  onSuccess?(result: T): void;\n  onTimeout?(err: TimeoutError): void;\n  onError(err: any): void;\n}\n\nexport const observableError = (observable: ObservableProvider<AsyncEvents>, err: any) => {\n  if (err instanceof TimeoutError) {\n    observable.callback.onTimeout?.(err);\n  } else {\n    observable.callback.onError(toError(err));\n  }\n};\n", "//\n// Copyright 2020 DXOS.org\n//\n\nimport { type Context, ContextDisposedError } from '@dxos/context';\n\nimport { createPromiseFromCallback } from './callback';\nimport { TimeoutError } from './errors';\n\n/**\n * Times out after delay.\n */\nexport const sleep = (ms: number) => {\n  return new Promise<void>((resolve) => {\n    const finish = Date.now() + ms;\n\n    // `setTimeout` does not guarantee execution at >= the scheduled time and may execute slightly early.\n    const sleeper = () => {\n      const delta = finish - Date.now();\n      if (delta > 0) {\n        setTimeout(sleeper, delta);\n      } else {\n        resolve();\n      }\n    };\n\n    sleeper();\n  });\n};\n\n/**\n * Can be used in long-running tasks to let other callbacks be invoked.\n */\nexport const asyncReturn = () => sleep(0);\n\n/**\n * Wait for promise or throw error.\n */\nexport const asyncTimeout = async <T>(\n  // TODO(dmaretskyi): This callback API is unintuitive and leads to bugs.\n  promise: Promise<T> | (() => Promise<T>),\n  timeout: number,\n  err?: Error | string,\n): Promise<T> => {\n  let timeoutId: NodeJS.Timeout;\n  const throwable = err === undefined || typeof err === 'string' ? new TimeoutError(timeout, err) : err;\n  const timeoutPromise = new Promise<T>((resolve, reject) => {\n    timeoutId = setTimeout(() => {\n      reject(throwable);\n    }, timeout);\n\n    unrefTimeout(timeoutId);\n  });\n\n  const conditionTimeout = typeof promise === 'function' ? createPromiseFromCallback<T>(promise) : promise;\n  return await Promise.race([conditionTimeout, timeoutPromise]).finally(() => {\n    clearTimeout(timeoutId);\n  });\n};\n\n/**\n * In Node.JS, `unref` prevents the timeout from blocking the process from exiting. Not available in browsers.\n * https://nodejs.org/api/timers.html#timeoutunref\n */\nexport const unrefTimeout = (timeoutId: NodeJS.Timeout) => {\n  if (typeof timeoutId === 'object' && 'unref' in timeoutId) {\n    timeoutId.unref();\n  }\n};\n\nexport const sleepWithContext = (ctx: Context, ms: number) => {\n  const error = new ContextDisposedError();\n  return new Promise<void>((resolve, reject) => {\n    if (ctx.disposed) {\n      reject(error);\n      return;\n    }\n\n    const timeout = setTimeout(() => {\n      clearDispose();\n      resolve();\n    }, ms);\n\n    const clearDispose = ctx.onDispose(() => {\n      clearTimeout(timeout);\n      reject(error);\n    });\n  });\n};\n", "//\n// Copyright 2020 DXOS.org\n//\n\nimport { type EventEmitter } from 'node:events';\n\nimport { asyncTimeout } from './timeout';\n\n/**\n * Adds the listener and returns a function to remove it.\n * Promotes removing listeners when cleaning up objects (to prevent leaks).\n */\nexport const onEvent = (eventEmitter: EventEmitter, eventName: string, callback: (args: any) => void) => {\n  eventEmitter.on(eventName, callback);\n  return () => eventEmitter.off(eventName, callback);\n};\n\n/**\n * @deprecated\n */\nexport const addListener = (eventEmitter: EventEmitter, eventName: string, callback: () => void) => {\n  const off = onEvent(eventEmitter, eventName, callback);\n  return {\n    remove: () => off(),\n  };\n};\n\n/**\n * Waits for an event with an optional test condition.\n */\nexport const waitForEvent = (\n  eventEmitter: EventEmitter,\n  eventName: string,\n  test?: (args: any) => boolean,\n  timeout?: number,\n  error?: Error | string,\n): Promise<any> => {\n  let off;\n\n  const promise = new Promise((resolve) => {\n    off = onEvent(eventEmitter, eventName, (...args) => {\n      if (!test || test(...args)) {\n        resolve(...args);\n      }\n    });\n  });\n\n  return timeout ? asyncTimeout(promise, timeout, error ?? new Error()).finally(off) : promise.finally(off);\n};\n", "//\n// Copyright 2020 DXOS.org\n//\n\nimport { Context } from '@dxos/context';\nimport { type MaybePromise } from '@dxos/util';\n\nimport { type CleanupFn } from './cleanup';\n\nexport type Effect = () => CleanupFn | undefined;\n\n/**\n * Effect that's been added to a specific Event.\n */\ninterface MaterializedEffect {\n  effect: Effect;\n  cleanup: CleanupFn | undefined;\n}\n\ninterface EventEmitterLike {\n  on(event: string, cb: (data?: any) => void): void;\n  off(event: string, cb: (data?: any) => void): void;\n}\n\nexport type ListenerOptions = {\n  weak?: boolean;\n  once?: boolean;\n};\n\ntype EventCallback<T> = (data: T) => MaybePromise<void>;\n\n// TODO(dmaretskyi): Remove this once the code is cleaned up.\nconst DO_NOT_ERROR_ON_ASYNC_CALLBACK = true;\n\n/**\n * An EventEmitter variant that does not do event multiplexing and represents a single event.\n *\n * ## Typical usage:\n * ```javascript\n * class Model {\n *   public readonly update = new Event<UpdateData>();\n *   private readonly privateEvent = new Event<void>();\n *\n *   onUpdate(data: UpdateData) {\n *     ...\n *     this.update.emit(data);\n *   }\n * }\n *\n * model.update.on(data => {\n *   ...\n * });\n * ```\n *\n * ## Advantages over traditional EventEmitter:\n * 1. User describes explicitly what events a class has as they are defined as class fields.\n * 2. User can explicitly define event visibility (public, protected, private).\n * 3. Having events as class fields allows the compiler to check for correct event usage.\n * 4. User can type the data that event will be emitting.\n * 5. Uses composition instead of inheritance.\n * 6. Removes the cases where event names intersect when used in cases with inheritance.\n * 7. Remove the need to namespace events when developing a class with events that will be used as a base-class.\n */\n// TODO(burdon): Rename EventSink? (Event is a built-in type).\nexport class Event<T = void> implements ReadOnlyEvent<T> {\n  /**\n   * Wrap objects that have on/off style event emitters.\n   */\n  static wrap<T>(emitter: EventEmitterLike, eventName: string): Event<T> {\n    const event = new Event<T>();\n\n    event.addEffect(() => {\n      const onEvent = (data: any) => event.emit(data);\n      emitter.on(eventName, onEvent);\n      return () => emitter.off(eventName, onEvent);\n    });\n\n    return event;\n  }\n\n  private readonly _listeners = new Set<EventListener<T>>();\n  private readonly _effects = new Set<MaterializedEffect>();\n\n  /**\n   * Emit an event.\n   * In most cases should only be called by the class or entity containing the event.\n   * All listeners are called in order of subscription with persistent ones first.\n   * Listeners are called synchronously in the same stack.\n   * A thrown exception in the listener will stop the event from being emitted to the rest of the listeners.\n   *\n   * @param data param that will be passed to all listeners.\n   */\n  emit(data: T): void {\n    for (const listener of this._listeners) {\n      listener.trigger(data);\n\n      if (listener.once) {\n        this._listeners.delete(listener);\n      }\n    }\n  }\n\n  /**\n   * Emit an event and wait for async listeners to complete.\n   * In most cases should only be called by the class or entity containing the event.\n   * All listeners are called in order of subscription with persistent ones first.\n   * Listeners are called sequentially.\n   *\n   * @param data param that will be passed to all listeners.\n   */\n  async emitAsync(data: T): Promise<void> {\n    for (const listener of this._listeners) {\n      await listener.triggerAsync(data);\n\n      if (listener.once) {\n        this._listeners.delete(listener);\n      }\n    }\n  }\n\n  /**\n   * Register an event listener.\n   * If provided callback was already registered as once-listener, it is made permanent.\n   *\n   * @param callback\n   * @param options.weak If true, the callback will be weakly referenced and will be garbage collected if no other references to it exist.\n   * @returns function that unsubscribes this event listener\n   */\n  on(callback: EventCallback<T>): CleanupFn;\n  on(ctx: Context, callback: EventCallback<T>, options?: ListenerOptions): CleanupFn;\n  on(_ctx: any, _callback?: EventCallback<T>, options?: ListenerOptions): CleanupFn {\n    const [ctx, callback] = _ctx instanceof Context ? [_ctx, _callback] : [new Context(), _ctx];\n    const weak = !!options?.weak;\n    const once = !!options?.once;\n\n    const listener = new EventListener(this, callback, ctx, once, weak);\n\n    this._addListener(listener);\n\n    return () => {\n      this._removeListener(listener);\n    };\n  }\n\n  /**\n   * Unsubscribe this callback from new events. Includes persistent and once-listeners.\n   * NOTE: It is recommended to use `Event.on`'s return value instead.\n   * If the callback is not subscribed this is no-op.\n   *\n   * @param callback\n   */\n  off(callback: (data: T) => void): void {\n    for (const listener of this._listeners) {\n      if (listener.derefCallback() === callback) {\n        this._removeListener(listener);\n      }\n    }\n  }\n\n  /**\n   * Register a callback to be called only once when the next event is emitted.\n   * If this callback is already registered as permanent listener, this is no-op.\n   *\n   * @param callback\n   */\n  once(callback: (data: T) => void): CleanupFn;\n  once(ctx: Context, callback: (data: T) => void): CleanupFn;\n  once(_ctx: any, _callback?: (data: T) => void): CleanupFn {\n    const [ctx, callback] = _ctx instanceof Context ? [_ctx, _callback] : [new Context(), _ctx];\n\n    const listener = new EventListener(this, callback, ctx, true, false);\n\n    this._addListener(listener);\n\n    return () => {\n      this._removeListener(listener);\n    };\n  }\n\n  /**\n   * An async iterator that iterates over events.\n   * This iterator runs indefinitely.\n   */\n  async *[Symbol.asyncIterator](): AsyncIterator<T> {\n    while (true) {\n      yield await new Promise((resolve) => {\n        this.once(resolve);\n      });\n    }\n  }\n\n  /**\n   * Returns a promise that resolves with the first event emitted that matches the provided predicate.\n   *\n   * @param predicate\n   */\n  waitFor(predicate: (data: T) => boolean): Promise<T> {\n    return new Promise((resolve) => {\n      const unsubscribe = this.on((data) => {\n        if (predicate(data)) {\n          unsubscribe();\n          resolve(data);\n        }\n      });\n    });\n  }\n\n  /**\n   * Returns a promise that resolves once a specific number of events was emitted since this method was called.\n   *\n   * @param expectedCount\n   */\n  waitForCount(expectedCount: number): Promise<T> {\n    let count = 0;\n    return this.waitFor(() => ++count === expectedCount);\n  }\n\n  /**\n   * Similar to waitFor, but the promise resolves immediately if the condition is already true.\n   */\n  // TODO(burdon): Should pass event property to predicate.\n  async waitForCondition(predicate: () => boolean): Promise<void> {\n    if (!predicate()) {\n      await this.waitFor(predicate);\n    }\n  }\n\n  /**\n   * Returns the number of persistent listeners.\n   */\n  listenerCount(): number {\n    return this._listeners.size;\n  }\n\n  /**\n   * Add a side effect that will be activated once the event has at least one subscriber.\n   * The provided callback can return a function that will be used to clean up after the last subscriber unsubscribes from the event.\n   * The API is similar to `useEffect` from React.\n   *\n   * ## Example:\n   * ```typescript\n   * event.addEffect(() => {\n   *   // do stuff\n   *   return () => {\n   *     // clean-up\n   *   };\n   * });\n   * ```\n   *\n   * @returns Callback that will remove this effect once called.\n   */\n  addEffect(effect: Effect): CleanupFn {\n    const handle: MaterializedEffect = { effect, cleanup: undefined };\n\n    if (this.listenerCount() > 0) {\n      handle.cleanup = handle.effect();\n    }\n\n    this._effects.add(handle);\n    return () => {\n      // eslint-disable-next-line no-unused-expressions\n      handle.cleanup?.();\n      this._effects.delete(handle);\n    };\n  }\n\n  /**\n   * Triggers an event with at least `timeout` milliseconds between each event.\n   * If the event is triggered more often, the event is delayed until the timeout is reached.\n   * If event is emitted for the first time or event wasn't fired for `timeout` milliseconds,\n   * the event is emitted after `timeout / 8` ms.\n   */\n  // TODO(burdon): Factor out generic function.\n  debounce(timeout = 0): Event<void> {\n    let firing: NodeJS.Timeout | undefined;\n    let lastFired: number | undefined;\n\n    const debouncedEvent = new Event<void>();\n    debouncedEvent.addEffect(() => {\n      const unsubscribe = this.on(() => {\n        if (!firing) {\n          const fireIn = !lastFired || Date.now() - lastFired > timeout ? timeout / 8 : timeout;\n          firing = setTimeout(() => {\n            lastFired = Date.now();\n            firing = undefined;\n            debouncedEvent.emit();\n          }, fireIn);\n        }\n      });\n\n      return () => {\n        unsubscribe();\n        clearTimeout(firing);\n      };\n    });\n\n    return debouncedEvent;\n  }\n\n  /**\n   * Turn any variant of `Event<T>` into an `Event<void>` discarding the callback parameter.\n   */\n  discardParameter(): Event<void> {\n    return this as any;\n  }\n\n  /**\n   * Pipe the events into another event.\n   * @param event\n   */\n  pipeInto(event: Event<T>): CleanupFn {\n    return this.on((data) => event.emit(data));\n  }\n\n  /**\n   * Overridden to not return implementation details.\n   */\n  toJSON(): { listenerCount: number } {\n    return {\n      listenerCount: this.listenerCount(),\n    };\n  }\n\n  private _addListener(listener: EventListener<T>): void {\n    this._listeners.add(listener);\n\n    if (this.listenerCount() === 1) {\n      this._runEffects();\n    }\n  }\n\n  /**\n   * @internal\n   */\n  _removeListener(listener: EventListener<T>): void {\n    this._listeners.delete(listener);\n    listener.remove();\n\n    if (this.listenerCount() === 0) {\n      this._cleanupEffects();\n    }\n  }\n\n  private _runEffects(): void {\n    for (const handle of this._effects) {\n      handle.cleanup = handle.effect();\n    }\n  }\n\n  private _cleanupEffects(): void {\n    for (const handle of this._effects) {\n      // eslint-disable-next-line no-unused-expressions\n      handle.cleanup?.();\n      handle.cleanup = undefined;\n    }\n  }\n}\n\n/**\n * A version of Event class which only has subscribe methods.\n * Useful in cases where you want to explicitly prohibit calling `emit` method.\n */\nexport interface ReadOnlyEvent<T = void> {\n  /**\n   * Register an event listener.\n   * If provided callback was already registered as once-listener, it is made permanent.\n   *\n   * @param callback\n   * @param options.weak If true, the callback will be weakly referenced and will be garbage collected if no other references to it exist.\n   * @returns function that unsubscribes this event listener\n   */\n  on(callback: (data: T) => void): CleanupFn;\n  on(ctx: Context, callback: (data: T) => void, options?: ListenerOptions): CleanupFn;\n\n  /**\n   * Unsubscribes this callback from new events. Includes persistent and once-listeners.\n   * NOTE: It is recommended to us `Event.on`'s return value.\n   * If the callback is not subscribed this is no-op.\n   *\n   * @param callback\n   */\n  off(callback: (data: T) => void): void;\n\n  /**\n   * Register a callback to be called only once when the next event is emitted.\n   * If this callback is already registered as permanent listener, this is no-op.\n   *\n   * @param callback\n   */\n  once(callback: (data: T) => void): CleanupFn;\n\n  /**\n   * An async iterator that iterates over events.\n   * This iterator runs indefinitely.\n   */\n  [Symbol.asyncIterator](): AsyncIterator<T>;\n\n  /**\n   * Returns a promise that resolves with the first event emitted that matches the provided predicate.\n   *\n   * @param predicate\n   */\n  waitFor(predicate: (data: T) => boolean): Promise<T>;\n\n  /**\n   * Returns a promise that resolves once a specific number of events was emitted since this method was called.\n   *\n   * @param expectedCount\n   */\n  waitForCount(expectedCount: number): Promise<T>;\n\n  /**\n   * Turn any variant of `Event<T>` into an `Event<void>` discarding the callback parameter.\n   */\n  discardParameter(): Event<void>;\n\n  /**\n   * Triggers an event with at least `timeout` milliseconds between each event.\n   * If the event is triggered more often, the event is delayed until the timeout is reached.\n   * If event is emitted for the first time or event wasn't fired for `timeout` milliseconds,\n   * the event is emitted after `timeout / 8` ms.\n   */\n  debounce(timeout?: number): Event<void>;\n}\n\nclass EventListener<T> {\n  public readonly callback: EventCallback<T> | WeakRef<EventCallback<T>>;\n\n  private readonly _clearDispose?: () => void = undefined;\n\n  constructor(\n    event: Event<T>,\n    listener: EventCallback<T>,\n    public readonly ctx: Context,\n    public readonly once: boolean,\n    public readonly weak: boolean,\n  ) {\n    this._clearDispose = ctx.onDispose(() => {\n      event._removeListener(this);\n    });\n\n    if (weak) {\n      this.callback = new WeakRef(listener);\n      weakListeners().registry?.register(\n        listener,\n        {\n          event: new WeakRef(event),\n          listener: this,\n        },\n        this,\n      );\n    } else {\n      this.callback = listener;\n    }\n  }\n\n  derefCallback(): EventCallback<T> | undefined {\n    return this.weak ? (this.callback as WeakRef<EventCallback<T>>).deref() : (this.callback as EventCallback<T>);\n  }\n\n  trigger(data: T): void {\n    let result!: MaybePromise<void>;\n    try {\n      const callback = this.derefCallback();\n      result = callback?.(data);\n    } catch (err: any) {\n      this.ctx.raise(err);\n    }\n\n    if (!DO_NOT_ERROR_ON_ASYNC_CALLBACK) {\n      if (result instanceof Promise) {\n        throw new TypeError('Event has async callbacks, use emitAsync instead');\n      }\n    }\n  }\n\n  async triggerAsync(data: T): Promise<void> {\n    try {\n      const callback = this.derefCallback();\n      await callback?.(data);\n    } catch (err: any) {\n      this.ctx.raise(err);\n    }\n  }\n\n  remove(): void {\n    this._clearDispose?.();\n    weakListeners().registry?.unregister(this);\n  }\n}\n\ntype HeldValue = {\n  event: WeakRef<Event<any>>;\n  listener: EventListener<any>;\n};\n\nlet weakListenersState: FinalizationRegistry<HeldValue> | null = null;\n\ntype WeakListeners = {\n  registry: FinalizationRegistry<HeldValue> | undefined;\n};\n\nconst FINALIZATION_REGISTRY_SUPPORTED = !!globalThis.FinalizationRegistry;\n\nconst weakListeners = (): WeakListeners => {\n  if (!FINALIZATION_REGISTRY_SUPPORTED) {\n    return { registry: undefined };\n  }\n  weakListenersState ??= new FinalizationRegistry(({ event, listener }) => {\n    event.deref()?._removeListener(listener);\n  });\n  return { registry: weakListenersState };\n};\n", "//\n// Copyright 2020 DXOS.org\n//\n\nimport { invariant } from '@dxos/invariant';\n\ntype LatchProps = {\n  count?: number;\n  timeout?: number;\n};\n\ntype LatchResult = [() => Promise<number>, () => number, (err: Error) => void];\n\n/**\n * Returns a callback and a promise that's resolved when the callback is called n times.\n */\n// TODO(burdon): Reconcile with until/trigger.\nexport const latch = ({ count = 1, timeout }: LatchProps = {}): LatchResult => {\n  invariant(count >= 0);\n\n  let t: ReturnType<typeof setTimeout>;\n  let doResolve: (value: number) => void;\n  let doReject: (err: Error) => void;\n  const promise = new Promise<number>((resolve, reject) => {\n    doResolve = (value) => {\n      clearTimeout(t);\n      resolve(value);\n    };\n\n    doReject = (err) => {\n      clearTimeout(t);\n      reject(err);\n    };\n  });\n\n  if (count === 0) {\n    setTimeout(() => {\n      doResolve(0);\n    });\n  } else {\n    if (timeout) {\n      t = setTimeout(() => {\n        doReject(new Error(`Timed out after ${timeout.toLocaleString()}ms`));\n      }, timeout);\n    }\n  }\n\n  let i = 0;\n  return [\n    async () => await promise,\n    () => {\n      if (++i === count) {\n        doResolve(i);\n      }\n\n      return i;\n    },\n    (err: Error) => doReject(err),\n  ];\n};\n", "//\n// Copyright 2020 DXOS.org\n//\n\n// Import explicit resource management polyfill.\nimport '@dxos/util';\nimport { warnAfterTimeout } from '@dxos/debug';\n\n/**\n * A locking mechanism to ensure that a given section of the code is executed by only one single \"thread\" at a time.\n *\n * Functions are chained in a structure similar to a linked list.\n * `_lastPromise` always contains the function that will finish executing last.\n *\n * Initially it is set to `Promise.resolve()` -- a promise that resolves immediately.\n * Enqueuing is done by attaching provided function to the `_lastPromise` via a `.then()` call\n * then updating the `_lastPromise` variable.\n *\n * It is important that enqueuing is done atomically:\n * there are no `await`s in `executeSynchronized` and it's not async while still returning a promise.\n *\n * Java docs reference on synchronized sections:\n * https://docs.oracle.com/javase/tutorial/essential/concurrency/locksync.html\n */\nexport class Mutex {\n  private _queue = Promise.resolve();\n  private _queueLength = 0;\n\n  private _tag: string | null = null;\n\n  get tag() {\n    return this._tag;\n  }\n\n  isLocked(): boolean {\n    return this._queueLength > 0;\n  }\n\n  /**\n   * Acquires the lock.\n   * Caller is responsible for releasing the lock using the returned callback.\n   * NOTE: Using `executeSynchronized` is preferred over using `acquire` directly.\n   * @returns Release callback\n   */\n  async acquire(tag?: string): Promise<MutexGuard> {\n    const prev = this._queue;\n\n    // Immediately update the promise before invoking any async actions so that next invocation waits for our task to complete.\n    let guard!: MutexGuard;\n    this._queueLength++;\n    this._queue = new Promise((resolve) => {\n      guard = new MutexGuard(() => {\n        this._queueLength--;\n        this._tag = null;\n        resolve();\n      });\n    });\n\n    await prev;\n\n    if (tag !== undefined) {\n      this._tag = tag;\n    }\n    return guard;\n  }\n\n  /**\n   * Waits for all previous executions to complete and then executes a given function.\n   * Only a single function can be executed at a time.\n   * Function are executed in the same order as `executeSynchronized` is called.\n   * WARNING: Calling `executeSynchronized` inside of `executeSynchronized` on the same lock instance is a deadlock.\n   */\n  async executeSynchronized<T>(fun: () => Promise<T>): Promise<T> {\n    const guard = await this.acquire();\n\n    try {\n      return await fun();\n    } finally {\n      guard.release();\n    }\n  }\n}\n\nexport class MutexGuard {\n  constructor(private readonly _release: () => void) {}\n\n  /**\n   * Releases the lock.\n   */\n  release(): void {\n    this._release();\n  }\n\n  [Symbol.dispose](): void {\n    this.release();\n  }\n}\n\nconst classMutexSymbol = Symbol('class-mutex');\n\ninterface LockableClass {\n  [classMutexSymbol]?: Mutex;\n}\n\nconst FORCE_DISABLE_WARNING = false;\n\n// Enabled only in tests by default.\nconst enableWarning = !FORCE_DISABLE_WARNING && (globalThis as any).mochaExecutor;\n\n/**\n * Same as `synchronized` in Java.\n * Uses a lock global to the current class instance.\n * This way every synchronized method on the same instance will share a single lock.\n */\nexport const synchronized = (\n  target: any,\n  propertyName: string,\n  descriptor: TypedPropertyDescriptor<(...args: any) => Promise<any>>,\n) => {\n  const method = descriptor.value!;\n  descriptor.value = async function synchronizedMethod(this: any & LockableClass, ...args: any) {\n    const mutex: Mutex = (this[classMutexSymbol] ??= new Mutex());\n\n    const tag = `${target.constructor.name}.${propertyName}`;\n\n    // Disable warning in prod to avoid performance penalty.\n    let guard;\n    if (!enableWarning) {\n      guard = await mutex.acquire(tag);\n    } else {\n      guard = await warnAfterTimeout(10_000, `lock on ${tag} (taken by ${mutex.tag})`, () => mutex.acquire(tag));\n    }\n\n    try {\n      return await method.apply(this, args);\n    } finally {\n      guard.release();\n    }\n  };\n  Object.defineProperty(descriptor.value, 'name', { value: propertyName + '$synchronized' });\n};\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport Observable from 'zen-observable';\nimport type { ObservableLike, Observer, Subscriber } from 'zen-observable/esm';\nimport PushStream from 'zen-push';\n\nimport { type Event } from './events';\nimport { Trigger } from './trigger';\n\nexport { Observable, PushStream, type Subscriber };\n\n// Inspired by:\n// https://github.com/zenparsing/zen-push/blob/39949f1/index.js#L93\n// https://github.com/apollographql/apollo-client/blob/a0eb4d6/src/utilities/observables/Concast.ts\n\n/**\n * Observable which supports multiple subscribers and stores the current value.\n *\n * The current value is emitted to new subscribers on subscription.\n */\nexport class MulticastObservable<T> extends Observable<T> {\n  private readonly _observers = new Set<Observer<T>>();\n  private readonly _observable: Observable<T>;\n  private readonly _completed = new Trigger();\n\n  constructor(\n    subscriber: Observable<T> | Subscriber<T>,\n    protected _value?: T,\n  ) {\n    super((observer) => this._subscribe(observer));\n\n    this._observable = typeof subscriber === 'function' ? new Observable(subscriber) : subscriber;\n    // Automatically subscribe to source observable.\n    // Ensures that the current value is always up to date.\n    // TODO(wittjosiah): Does this subscription need to be cleaned up? Where should that happen?\n    this._observable.subscribe(this._handlers);\n  }\n\n  static override from<T>(\n    value: Observable<T> | ObservableLike<T> | ArrayLike<T> | Event<T>,\n    initialValue?: T,\n  ): MulticastObservable<T> {\n    if ('emit' in value) {\n      return new MulticastObservable((observer) => {\n        // TODO(wittjosiah): Do error/complete matter for events?\n        value.on((data) => {\n          observer.next(data);\n        });\n      }, initialValue);\n    }\n\n    const observable = Observable.from(value);\n    return new MulticastObservable(observable, initialValue);\n  }\n\n  static override of<T>(...items: T[]): MulticastObservable<T> {\n    return new MulticastObservable(Observable.of(...items.slice(1)), items[0]);\n  }\n\n  /**\n   * @returns Stable reference to an observable that always returns `undefined`.\n   */\n  static empty(): MulticastObservable<null> {\n    return EMPTY_OBSERVABLE;\n  }\n\n  /**\n   * Get the current value of the observable.\n   */\n  get(): T {\n    // TODO(wittjosiah): Is there a better way to handle this?\n    //   `this._value` is not guaranteed to be set for compatibility with `Observable` base class.\n    //   `get()` should always return `T` to avoid having to sprinkle conditional logic.\n    if (this._value === undefined) {\n      throw new Error('MulticastObservable is not initialized.');\n    }\n\n    return this._value;\n  }\n\n  /**\n   * Wait for the observable to complete.\n   *\n   * @returns Promise that resolves to the value of the observable at the time of completion.\n   */\n  async wait({ timeout }: { timeout?: number } = {}): Promise<T> {\n    await this._completed.wait({ timeout });\n    return this.get();\n  }\n\n  override forEach(callback: (value: T) => void): Promise<void> {\n    return this._observable.forEach(callback);\n  }\n\n  override map<R>(callback: (value: T) => R): MulticastObservable<R> {\n    return new MulticastObservable(this._observable.map(callback), this._value && callback(this._value));\n  }\n\n  override filter(callback: (value: T) => boolean): MulticastObservable<T> {\n    return new MulticastObservable(\n      this._observable.filter(callback),\n      this._value && callback(this._value) ? this._value : undefined,\n    );\n  }\n\n  override reduce<R = T>(callback: (previousValue: R, currentValue: T) => R, initialValue?: R): MulticastObservable<R> {\n    return new MulticastObservable(\n      initialValue ? this._observable.reduce(callback, initialValue) : this._observable.reduce(callback),\n      initialValue ?? (this._value as R),\n    );\n  }\n\n  override flatMap<R>(callback: (value: T) => MulticastObservable<R>): MulticastObservable<R> {\n    return new MulticastObservable(this._observable.flatMap(callback), this._value && callback(this._value).get());\n  }\n\n  override concat<R>(...observables: Array<Observable<R>>): MulticastObservable<R> {\n    return new MulticastObservable(this._observable.concat(...observables), this._value as R);\n  }\n\n  /**\n   * Concatenates multicast observables without losing the current value.\n   * @param reducer reduces the values of any multicast observables being concatenated into a single value\n   * @param observables observables to concatenate\n   * @returns concatenated observable\n   */\n  losslessConcat<R>(\n    reducer: (currentValue: R, newValues: R[]) => R,\n    ...observables: Array<Observable<R>>\n  ): MulticastObservable<R> {\n    const multicast = observables.filter(\n      (observable): observable is MulticastObservable<R> => observable instanceof MulticastObservable,\n    );\n    const value = reducer(\n      this._value as R,\n      multicast.map((observable) => observable.get()),\n    );\n    return new MulticastObservable(this._observable.concat(...observables), value);\n  }\n\n  private _subscribe(observer: Observer<T>): () => void {\n    if (!this._observers.has(observer)) {\n      this._observers.add(observer);\n    }\n\n    if (this._value !== undefined) {\n      observer.next?.(this._value);\n    }\n\n    return () => {\n      this._observers.delete(observer);\n    };\n  }\n\n  private _handlers: Observer<T> = {\n    next: (value) => {\n      this._value = value;\n      this._observers.forEach((observer) => observer.next?.(value));\n    },\n    error: (err) => {\n      this._observers.forEach((observer) => observer.error?.(err));\n    },\n    complete: () => {\n      this._completed.wake();\n      this._observers.forEach((observer) => observer.complete?.());\n    },\n  };\n}\n\nconst EMPTY_OBSERVABLE = MulticastObservable.of(null);\n", "//\n// Copyright 2020 DXOS.org\n//\n\nimport { TimeoutError } from './errors';\nimport { asyncTimeout } from './timeout';\n\n/**\n * Returns a tuple containing a Promise that will be resolved when the resolver function is called.\n * @deprecated Use `Trigger` instead.\n */\nexport const trigger = <T = void>(timeout?: number): [() => Promise<T>, (arg: T) => void] => {\n  // eslint-disable-line @stayradiated/prefer-arrow-functions/prefer-arrow-functions\n  let callback: (arg: T) => void;\n\n  const promise = new Promise<T>((resolve, reject) => {\n    if (timeout) {\n      setTimeout(() => reject(new Error(`Timed out after ${timeout.toLocaleString()}ms`)), timeout);\n    }\n\n    callback = resolve;\n  });\n\n  const provider = () => promise;\n  const resolver = (value: T) => callback(value);\n\n  return [provider, resolver];\n};\n\nexport type TriggerOptions = {\n  autoReset: boolean;\n};\n\nexport enum TriggerState {\n  WAITING = 'WAITING',\n  RESOLVED = 'RESOLVED',\n  REJECTED = 'REJECTED',\n}\n\n/**\n * Enables blocked listeners to be awakened with optional timeouts.\n *\n * Has two states:\n * - WAITING: promise is in pending state and will be resolved once `wake()` is called.\n * - RESOLVED: promise is already resolved, and all calls to `wait()` resolve immediately.\n * - REJECTED: promise is rejected, and all calls to `wait()` return rejected promise.\n *\n * Trigger starts in WAITING state initially.\n * Use `reset()` to switch resolved trigger back to WAITING state.\n */\nexport class Trigger<T = void> {\n  private _promise!: Promise<T>;\n  private _resolve!: (value: T | PromiseLike<T>) => void;\n  private _reject!: (error: Error) => void;\n  private _state: TriggerState = TriggerState.WAITING;\n\n  constructor(private _options: TriggerOptions = { autoReset: false }) {\n    this.reset();\n  }\n\n  get state() {\n    return this._state;\n  }\n\n  /**\n   * Wait until wake is called, with optional timeout.\n   */\n  async wait({ timeout }: { timeout?: number } = {}): Promise<T> {\n    if (timeout) {\n      return asyncTimeout(this._promise, timeout, new TimeoutError(timeout));\n    } else {\n      return this._promise;\n    }\n  }\n\n  /**\n   * Wake blocked callers (if any).\n   * NOOP if the trigger is already resolved.\n   */\n  wake(value: T): this {\n    if (this._state !== TriggerState.WAITING) {\n      return this;\n    }\n    this._state = TriggerState.RESOLVED;\n    this._resolve(value);\n    if (this._options.autoReset) {\n      return this.reset();\n    }\n\n    return this;\n  }\n\n  /**\n   * Reset promise (new waiters will wait).\n   */\n  reset(): this {\n    this._state = TriggerState.WAITING;\n    this._promise = new Promise<T>((resolve, reject) => {\n      this._resolve = resolve;\n      this._reject = reject;\n    });\n\n    this._promise.catch(() => {}); // Prevent unhandled promise rejections.\n    return this;\n  }\n\n  /**\n   * Throw error to blocked callers (if any).\n   * NOOP if the trigger is already resolved.\n   */\n  throw(error: Error): this {\n    if (this._state !== TriggerState.WAITING) {\n      return this;\n    }\n    this._state = TriggerState.REJECTED;\n    this._reject(error);\n    if (this._options.autoReset) {\n      return this.reset();\n    }\n\n    return this;\n  }\n}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { createSetDispatch } from '@dxos/util';\n\nimport { type CleanupFn } from './cleanup';\n\n/**\n * Return type for processes that support cancellable subscriptions.\n * The handler object implements the observable events.\n * @deprecated\n */\nexport interface ObservableValue<Events, Value = unknown> {\n  value?: Value;\n  setValue(value: Value): void;\n  subscribe(handler: Events): CleanupFn;\n}\n\n/**\n * Provider that manages a set of subscriptions.\n * @deprecated\n */\n// TODO(burdon): Support multiple subscribers.\n//  https://betterprogramming.pub/compare-leading-javascript-functional-reactive-stream-libraries-544163c1ded6\n//  https://github.com/apollographql/apollo-client/tree/main/src/utilities/observables\n//  https://github.com/mostjs/core\nexport class ObservableProvider<Events extends {}, Value = unknown> implements ObservableValue<Events, Value> {\n  protected readonly _handlers = new Set<Events>();\n  private readonly _proxy = createSetDispatch<Events>({\n    handlers: this._handlers,\n  });\n\n  private _value?: Value;\n\n  /**\n   * Proxy used to dispatch callbacks to each subscription.\n   */\n  get callback(): Events {\n    return this._proxy;\n  }\n\n  get value() {\n    return this._value;\n  }\n\n  setValue(value: Value): void {\n    this._value = value;\n  }\n\n  subscribe(handler: Events): CleanupFn {\n    this._handlers.add(handler);\n    return () => {\n      this._handlers.delete(handler);\n    };\n  }\n}\n\n/**\n * @deprecated\n */\nexport interface CancellableObservableEvents {\n  onCancelled?(): void;\n}\n\n/**\n * @deprecated\n */\nexport interface CancellableObservable<Events extends CancellableObservableEvents, Value = unknown>\n  extends ObservableValue<Events, Value> {\n  cancel(): Promise<void>;\n}\n\n/**\n * Implements subscriptions with ability to be cancelled.\n * @deprecated\n */\nexport class CancellableObservableProvider<\n  Events extends CancellableObservableEvents,\n> extends ObservableProvider<Events> {\n  private _cancelled = false;\n\n  constructor(private readonly _handleCancel?: () => Promise<void>) {\n    super();\n  }\n\n  get cancelled() {\n    return this._cancelled;\n  }\n\n  async cancel(): Promise<void> {\n    if (this._cancelled) {\n      return;\n    }\n\n    this._cancelled = true;\n    await this._handleCancel?.();\n    this.callback.onCancelled?.();\n  }\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { LifecycleState, Resource, cancelWithContext } from '@dxos/context';\nimport { warnAfterTimeout } from '@dxos/debug';\nimport { log } from '@dxos/log';\n\nimport { synchronized } from './mutex';\nimport { DeferredTask } from './task-scheduling';\nimport { sleep } from './timeout';\n\nconst INIT_RESTART_DELAY = 100;\nconst DEFAULT_MAX_RESTART_DELAY = 5000;\n\nexport type PersistentLifecycleParams<T> = {\n  /**\n   * Create connection.\n   * If promise resolves successfully, connection is considered established.\n   */\n  start: () => Promise<T | undefined>;\n\n  /**\n   * Reset connection to initial state.\n   */\n  stop: (state: T) => Promise<void>;\n\n  /**\n   * Called after successful start.\n   */\n  onRestart?: () => Promise<void>;\n\n  /**\n   * Maximum delay between restartion attempts.\n   * Default: 5000ms\n   */\n  maxRestartDelay?: number;\n};\n\n/**\n * Handles restarts (e.g. persists connection).\n * Restarts are scheduled with exponential backoff.\n */\nexport class PersistentLifecycle<T> extends Resource {\n  private readonly _start: () => Promise<T | undefined>;\n  private readonly _stop: (state: T) => Promise<void>;\n  private readonly _onRestart?: () => Promise<void>;\n  private readonly _maxRestartDelay: number;\n\n  private _currentState: T | undefined = undefined;\n  private _restartTask?: DeferredTask = undefined;\n  private _restartAfter = 0;\n\n  constructor({ start, stop, onRestart, maxRestartDelay = DEFAULT_MAX_RESTART_DELAY }: PersistentLifecycleParams<T>) {\n    super();\n    this._start = start;\n    this._stop = stop;\n    this._onRestart = onRestart;\n    this._maxRestartDelay = maxRestartDelay;\n  }\n\n  get state() {\n    return this._currentState;\n  }\n\n  @synchronized\n  protected override async _open(): Promise<void> {\n    this._restartTask = new DeferredTask(this._ctx, async () => {\n      try {\n        await this._restart();\n      } catch (err) {\n        log.warn('Restart failed', { err });\n        this._restartTask?.schedule();\n      }\n    });\n\n    this._currentState = await this._start().catch((err) => {\n      log.warn('Start failed', { err });\n      this._restartTask?.schedule();\n      return undefined;\n    });\n  }\n\n  protected override async _close(): Promise<void> {\n    await this._restartTask?.join();\n    await this._stopCurrentState();\n    this._restartTask = undefined;\n  }\n\n  private async _restart(): Promise<void> {\n    log(`restarting in ${this._restartAfter}ms`, { state: this._lifecycleState });\n    await this._stopCurrentState();\n    if (this._lifecycleState !== LifecycleState.OPEN) {\n      return;\n    }\n    await cancelWithContext(this._ctx!, sleep(this._restartAfter));\n    this._restartAfter = Math.min(Math.max(this._restartAfter * 2, INIT_RESTART_DELAY), this._maxRestartDelay);\n\n    // May fail if the connection is not established.\n    await warnAfterTimeout(5_000, 'Connection establishment takes too long', async () => {\n      this._currentState = await this._start();\n    });\n\n    this._restartAfter = 0;\n    await this._onRestart?.();\n  }\n\n  private async _stopCurrentState(): Promise<void> {\n    if (this._currentState) {\n      try {\n        await this._stop(this._currentState);\n      } catch (err) {\n        log.catch(err);\n      }\n      this._currentState = undefined;\n    }\n  }\n\n  /**\n   * Scheduling restart should be done from outside.\n   */\n  @synchronized\n  async scheduleRestart(): Promise<void> {\n    if (this._lifecycleState !== LifecycleState.OPEN) {\n      return;\n    }\n    this._restartTask!.schedule();\n  }\n}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { ContextDisposedError, type Context } from '@dxos/context';\nimport { StackTrace } from '@dxos/debug';\nimport { type MaybePromise } from '@dxos/util';\n\nimport { trackResource } from './track-leaks';\nimport { Trigger } from './trigger';\n\n/**\n * A task that can be scheduled to run in the next event loop iteration.\n * Could be triggered multiple times, but only runs once.\n * If a new task is triggered while a previous one is running, the next run would occur immediately after the current run has finished.\n */\n// TODO(dmaretskyi): Consider calling `join` on context dispose.\n// TODO(burdon): Add throttling support.\nexport class DeferredTask {\n  private _scheduled = false;\n  private _currentTask: Promise<void> | null = null; // Can't be rejected.\n  private _nextTask = new Trigger();\n\n  constructor(\n    private readonly _ctx: Context,\n    private readonly _callback: () => Promise<void>,\n  ) {}\n\n  get scheduled() {\n    return this._scheduled;\n  }\n\n  /**\n   * Schedule the task to run asynchronously.\n   */\n  schedule(): void {\n    if (this._scheduled) {\n      return; // Already scheduled.\n    }\n\n    scheduleTask(this._ctx, async () => {\n      // The previous task might still be running, so we need to wait for it to finish.\n      await this._currentTask; // Can't be rejected.\n\n      // Reset the flag. New tasks can now be scheduled. They would wait for the callback to finish.\n      this._scheduled = false;\n      const completionTrigger = this._nextTask;\n      this._nextTask = new Trigger(); // Re-create the trigger as opposed to resetting it since there might be listeners waiting for it.\n\n      // Store the promise so that new tasks could wait for this one to finish.\n      this._currentTask = runInContextAsync(this._ctx, () => this._callback()).then(() => {\n        completionTrigger.wake();\n      });\n    });\n\n    this._scheduled = true;\n  }\n\n  /**\n   * Schedule the task to run and wait for it to finish.\n   */\n  async runBlocking(): Promise<void> {\n    if (this._ctx.disposed) {\n      throw new ContextDisposedError();\n    }\n\n    this.schedule();\n    await this._nextTask.wait();\n  }\n\n  /**\n   * Waits for the current task to finish if it is running.\n   * Does not schedule a new task.\n   */\n  async join(): Promise<void> {\n    await this._currentTask;\n  }\n}\n\nexport const runInContext = (ctx: Context, fn: () => void) => {\n  try {\n    fn();\n  } catch (err: any) {\n    ctx.raise(err);\n  }\n};\n\nexport const runInContextAsync = async (ctx: Context, fn: () => MaybePromise<void>) => {\n  try {\n    await fn();\n  } catch (err: any) {\n    ctx.raise(err);\n  }\n};\n\nexport const scheduleMicroTask = (ctx: Context, fn: () => MaybePromise<void>) => {\n  queueMicrotask(async () => {\n    if (ctx.disposed) {\n      return;\n    }\n    await runInContextAsync(ctx, fn);\n  });\n};\n\nexport const scheduleTask = (ctx: Context, fn: () => MaybePromise<void>, afterMs?: number) => {\n  const clearTracking = trackResource(() => ({\n    name: `task (${fn.name || 'anonymous'})`,\n    openStack: new StackTrace(),\n  }));\n\n  const timeout = setTimeout(async () => {\n    clearDispose();\n    await runInContextAsync(ctx, fn);\n    clearTracking();\n  }, afterMs);\n\n  const clearDispose = ctx.onDispose(() => {\n    clearTracking();\n    clearTimeout(timeout);\n  });\n};\n\n/**\n * Run the task in the next event loop iteration, and then repeat in `interval` ms after the previous iteration completes.\n */\nexport const scheduleTaskInterval = (ctx: Context, task: () => Promise<void>, interval: number) => {\n  const clearTracking = trackResource(() => ({\n    name: `repeating task (${task.name || 'anonymous'})`,\n    openStack: new StackTrace(),\n  }));\n\n  let timeoutId: NodeJS.Timeout;\n\n  const run = async () => {\n    await runInContextAsync(ctx, task);\n    if (ctx.disposed) {\n      return;\n    }\n    timeoutId = setTimeout(run, interval);\n  };\n\n  timeoutId = setTimeout(run, interval);\n  ctx.onDispose(() => {\n    clearTracking();\n    clearTimeout(timeoutId);\n  });\n};\n\nexport const scheduleExponentialBackoffTaskInterval = (\n  ctx: Context,\n  task: () => Promise<void>,\n  initialInterval: number,\n) => {\n  const clearTracking = trackResource(() => ({\n    name: `repeating task (${task.name || 'anonymous'})`,\n    openStack: new StackTrace(),\n  }));\n\n  let timeoutId: NodeJS.Timeout;\n\n  let interval = initialInterval;\n  const repeat = async () => {\n    await runInContextAsync(ctx, task);\n    if (ctx.disposed) {\n      return;\n    }\n    interval *= 2;\n    timeoutId = setTimeout(repeat, interval);\n  };\n\n  timeoutId = setTimeout(repeat, interval);\n  ctx.onDispose(() => {\n    clearTracking();\n    clearTimeout(timeoutId);\n  });\n};\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { StackTrace } from '@dxos/debug';\nimport { log } from '@dxos/log';\n\nconst enabled = typeof process !== 'undefined' && !!process.env.DX_TRACK_LEAKS;\n\ntype OpenResource = {\n  name: string;\n  openStack: StackTrace;\n};\n\nconst openResources = new Set<OpenResource>();\n\nconst handleSymbol = Symbol('checkLeaksHandle');\n\nexport const trackResource = (resourceProvider: () => OpenResource): (() => void) => {\n  if (!enabled) {\n    return () => {};\n  }\n  const resource = resourceProvider();\n\n  openResources.add(resource);\n\n  return () => {\n    openResources.delete(resource);\n  };\n};\n\n/**\n * Makes sure that the resource is at the end of the test.\n *\n * Example:\n *\n * ```typescript\n * @trackLeaks('open', 'close')\n * class Resource {}\n * ```\n */\nexport const trackLeaks =\n  (open: string, close: string): ClassDecorator =>\n  (target: any) => {\n    if (!enabled) {\n      return;\n    }\n\n    const openMethod = target.prototype[open];\n    const closeMethod = target.prototype[close];\n    if (!openMethod || !closeMethod) {\n      throw new Error(`Cannot find ${open} or ${close} method in ${target.name}`);\n    }\n\n    {\n      target.prototype[open] = async function (this: any, ...args: any) {\n        this[handleSymbol] = trackResource(() => ({\n          name: target.name,\n          openStack: new StackTrace(),\n        }));\n\n        return openMethod.apply(this, args);\n      };\n      Object.defineProperty(target.prototype[open], 'name', { value: open + '$checkLeaks' });\n    }\n\n    {\n      target.prototype[close] = async function (this: any, ...args: any) {\n        this[handleSymbol]?.();\n\n        return closeMethod.apply(this, args);\n      };\n      Object.defineProperty(target.prototype[close], 'name', { value: close + '$checkLeaks' });\n    }\n  };\n\nexport const dumpLeaks = () => {\n  if (!enabled) {\n    return;\n  }\n\n  log.info(`Leaked resources ${openResources.size}:`);\n  for (const resource of openResources) {\n    log.info(`- ${resource.name} at`);\n    log.info(resource.openStack.getStack(1));\n    log.info('\\n');\n  }\n};\n\nif (enabled) {\n  (global as any).dxDumpLeaks = dumpLeaks;\n}\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { invariant } from '@dxos/invariant';\n\nimport { Trigger } from './trigger';\n\ninterface PushAsyncIterable<T, TReturn = any> extends AsyncIterable<T, TReturn> {\n  /**\n   * Push a value into the iterable.\n   */\n  next(value: T): void;\n\n  /**\n   * Return a value from the iterable.\n   */\n  return(value?: TReturn): void;\n\n  /**\n   * Throw an error from the iterable.\n   */\n  throw(value?: any): void;\n}\n\n/**\n * Creates an async iterable where the data is pushed by calling methods on the iterable.\n */\nexport const makePushIterable = <T, TReturn = any>(): PushAsyncIterable<T, TReturn> => {\n  const buf: ({ kind: 'next'; value: T } | { kind: 'return'; value: TReturn } | { kind: 'throw'; value?: any })[] = [];\n  const trigger = new Trigger({ autoReset: true });\n\n  return {\n    [Symbol.asyncIterator]() {\n      return {\n        next: async (): Promise<IteratorResult<T, TReturn>> => {\n          while (buf.length === 0) {\n            await trigger.wait();\n          }\n\n          const item = buf.shift();\n          invariant(item);\n\n          switch (item.kind) {\n            case 'next':\n              return { value: item.value, done: false };\n            case 'return':\n              return { value: item.value, done: true };\n            case 'throw':\n              throw item.value;\n          }\n        },\n      };\n    },\n    next: (value: T) => {\n      buf.push({ kind: 'next', value });\n      trigger.wake();\n    },\n    return: (value: TReturn) => {\n      buf.push({ kind: 'return', value });\n      trigger.wake();\n    },\n    throw: (value?: any) => {\n      buf.push({ kind: 'throw', value });\n      trigger.wake();\n    },\n  };\n};\n", "//\n// Copyright 2020 DXOS.org\n//\n\nimport { type EventEmitter } from 'node:events';\n\nimport { trigger } from './trigger';\n\n/**\n * Waits for the specified number of events from the given emitter.\n */\nexport const sink = (emitter: EventEmitter, event: string, count = 1): Promise<void> => {\n  const [getPromise, resolve] = trigger();\n\n  let counter = 0;\n  const listener = () => {\n    if (++counter === count) {\n      emitter.off(event, listener);\n      resolve();\n    }\n  };\n\n  emitter.on(event, listener);\n\n  return getPromise();\n};\n", "//\n// Copyright 2022 DXOS.org\n//\n\n/**\n * Concatenate a readable stream's data into a single array.\n *\n * From https://github.com/stream-utils/stream-to-array, but does not depend on\n * any-promise which does not work in web workers due to using window in its\n * browser shim.\n */\nexport const streamToArray = (stream: NodeJS.ReadableStream): Promise<any[]> => {\n  let deferred: Promise<any[]>;\n\n  if (!stream.readable) {\n    deferred = Promise.resolve([]);\n  } else {\n    deferred = new Promise((resolve, reject) => {\n      // stream is already ended\n      if (!stream.readable) {\n        return resolve([]);\n      }\n\n      let arr: any[] = [];\n\n      const onData = (doc: any) => {\n        arr?.push(doc);\n      };\n\n      const onEnd = (err: any) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(arr);\n        }\n        cleanup();\n      };\n\n      const onClose = () => {\n        resolve(arr);\n        cleanup();\n      };\n\n      const cleanup = () => {\n        arr = [];\n        stream.removeListener('data', onData);\n        stream.removeListener('end', onEnd);\n        stream.removeListener('error', onEnd);\n        stream.removeListener('close', onClose);\n      };\n\n      stream.on('data', onData);\n      stream.on('end', onEnd);\n      stream.on('error', onEnd);\n      stream.on('close', onClose);\n    });\n  }\n\n  return deferred;\n};\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { Duplex } from 'node:stream';\n\nimport { Event } from './events';\nimport { asyncTimeout } from './timeout';\n\n/**\n * Duplex stream for testing.\n * If this stream is piped into another stream, use `push` to send data, and `assertReceivedAsync` to assert the received data.\n */\nexport class TestStream extends Duplex {\n  static async assertConnectivity(\n    stream1: TestStream,\n    stream2: TestStream,\n    { timeout = 200 }: { timeout?: number } = {},\n  ): Promise<void> {\n    stream1.push('ping');\n    stream2.push('pong');\n\n    await Promise.all([\n      stream2.assertReceivedAsync('ping', { timeout }),\n      stream1.assertReceivedAsync('pong', { timeout }),\n    ]);\n  }\n\n  private _received = Buffer.alloc(0);\n  private _onWrite = new Event();\n\n  override _write(chunk: any, encoding: BufferEncoding, callback: (error?: Error | null) => void): void {\n    this._received = Buffer.concat([this._received, chunk]);\n    this._onWrite.emit();\n    callback();\n  }\n\n  override _read(size: number): void {\n    // noop\n  }\n\n  assertReceivedAsync(data: Buffer | string, { timeout = 200 }: { timeout?: number } = {}): Promise<void> {\n    const dataBuffer = Buffer.isBuffer(data) ? data : Buffer.from(data);\n    return asyncTimeout(\n      this._onWrite.waitForCondition(() => this._received.equals(dataBuffer)),\n      timeout,\n    );\n  }\n}\n", "//\n// Copyright 2020 DXOS.org\n//\n\nimport { sleep } from './timeout';\nimport { Trigger } from './trigger';\n\n/**\n * NOTE: THIS SHOULD ONLY BE USED IN TESTS.\n *\n * Returns a Promise which resolves when `condFn` returns truthy.\n * The value returned by `condFn` is used to resolve the Promise.\n * @param condition Function to call.\n * @param [timeout] How long to wait, in milliseconds (0 = no timeout).\n * @param [interval=10] How frequently to check, in milliseconds.\n */\nexport const waitForCondition = <FunctionType extends (...args: any) => any>({\n  condition,\n  timeout = 0,\n  interval = 10,\n  error,\n  breakOnError = false,\n}: {\n  condition: FunctionType;\n  timeout?: number;\n  interval?: number;\n  error?: Error;\n  breakOnError?: boolean;\n}) => {\n  const stopTime = timeout ? Date.now() + timeout : 0;\n  const trigger = new Trigger<ReturnType<FunctionType>>();\n  const waiter = async () => {\n    // eslint-disable-next-line no-unmodified-loop-condition\n    while (!stopTime || Date.now() < stopTime) {\n      try {\n        // eslint-disable-next-line no-await-in-loop\n        const value = await condition();\n        if (value) {\n          trigger.wake(value);\n          break;\n        }\n      } catch (err: any) {\n        if (breakOnError === true) {\n          trigger.throw(err);\n        }\n      }\n\n      // eslint-disable-next-line no-await-in-loop\n      await sleep(interval);\n    }\n  };\n\n  setTimeout(waiter, 0);\n\n  return trigger.wait({ timeout });\n};\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { Event, type ReadOnlyEvent } from './events';\n\nexport type TimerOptions = { count: number; interval: number; jitter?: number };\n\nexport type TimerCallback = (i: number) => Promise<boolean | void>;\n\n/**\n * Manages callback invocations at a interval with a possible jitter.\n * Note: The interval excludes the running time of the callback.\n */\nexport class Timer {\n  private readonly _state = new Event<boolean>();\n  private _timer?: NodeJS.Timeout;\n  private _count = 0;\n\n  constructor(private readonly _callback: TimerCallback) {}\n\n  get state(): ReadOnlyEvent<boolean> {\n    return this._state;\n  }\n\n  get running() {\n    return !!this._timer;\n  }\n\n  start(options: TimerOptions, cb?: () => void): this {\n    if (isNaN(options.count) || isNaN(options.interval)) {\n      throw new Error(`Invalid options: ${JSON.stringify(options)}`);\n    }\n\n    if (this.running) {\n      this.stop();\n    }\n\n    const stop = () => {\n      this.stop();\n      cb?.();\n    };\n\n    const run = () => {\n      if (this._count >= (options.count ?? 0)) {\n        stop();\n      } else {\n        const interval = (options.interval ?? 0) + Math.random() * (options.jitter ?? 0);\n        this._timer = setTimeout(async () => {\n          await this._callback(this._count++);\n          run();\n        }, interval);\n      }\n    };\n\n    this._state.emit(true);\n    this._count = 0;\n\n    // Start asynchronously (give caller chance to register event listener).\n    setTimeout(run);\n    return this;\n  }\n\n  stop(): this {\n    clearInterval(this._timer);\n    this._timer = undefined;\n    this._state.emit(false);\n    return this;\n  }\n}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nexport type UntilCallback<T> = (resolve: (value: T) => void, reject: (error: Error) => void) => Promise<T> | void;\n\n/**\n * Awaits promise.\n */\n// TODO(burdon): Reconcile with latch/trigger.\nexport const until = <T = void>(cb: UntilCallback<T>, timeout?: number): Promise<T> => {\n  return new Promise((resolve, reject) => {\n    const t =\n      timeout &&\n      setTimeout(() => {\n        reject(new Error(`Timeout after ${t}ms`));\n      }, timeout);\n\n    setTimeout(async () => {\n      try {\n        await cb(\n          (value: T) => {\n            t && clearTimeout(t);\n            resolve(value);\n          },\n          (error: Error) => {\n            t && clearTimeout(t);\n            reject(error);\n          },\n        );\n      } catch (err) {\n        reject(err);\n      }\n    });\n  });\n};\n\n/**\n * Wait until promise resolves.\n */\n// TODO(burdon): Reconcile promises (with timeouts).\nexport const untilPromise = <T = void>(cb: () => Promise<T>) => cb();\n\n/**\n * Wait until error is thrown.\n */\nexport const untilError = (cb: () => Promise<any>) => {\n  return new Promise((resolve, reject) => {\n    setTimeout(async () => {\n      try {\n        await cb();\n        reject(new Error('No error was thrown.'));\n      } catch (err) {\n        resolve(err);\n      }\n    });\n  });\n};\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { type Context } from '@dxos/context';\n\nimport { scheduleMicroTask } from './task-scheduling';\n\nexport type UpdateSchedulerOptions = {\n  /**\n   * Maximum frequency of updates. If not specified, updates will be scheduled on every change.\n   */\n  maxFrequency?: number;\n};\n\n/**\n * Time period for update counting.\n */\nconst TIME_PERIOD = 1000;\n\nexport class UpdateScheduler {\n  /**\n   * Promise that resolves when the callback is done.\n   * Never rejects.\n   */\n  private _promise: Promise<any> | null = null;\n  private _scheduled = false;\n\n  private _lastUpdateTime = -TIME_PERIOD;\n\n  constructor(\n    private readonly _ctx: Context,\n    private readonly _callback: () => Promise<void>,\n    private readonly _params: UpdateSchedulerOptions = {},\n  ) {\n    _ctx.onDispose(async () => {\n      await this._promise; // Context waits for callback to finish.\n    });\n  }\n\n  trigger(): void {\n    if (this._scheduled) {\n      return;\n    }\n\n    scheduleMicroTask(this._ctx, async () => {\n      // The previous task might still be running, so we need to wait for it to finish.\n      await this._promise; // Can't be rejected.\n\n      // Check if the callback was called recently.\n      if (this._params.maxFrequency) {\n        const now = performance.now();\n        const delay = this._lastUpdateTime + TIME_PERIOD / this._params.maxFrequency - now;\n        if (delay > 0) {\n          await new Promise<void>((resolve) => {\n            const timeoutId = setTimeout(() => {\n              clearContext();\n              resolve();\n            }, delay);\n\n            const clearContext = this._ctx.onDispose(() => {\n              clearTimeout(timeoutId);\n              resolve();\n            });\n          });\n        }\n      }\n\n      if (this._ctx.disposed) {\n        return;\n      }\n\n      this._lastUpdateTime = performance.now();\n\n      // Reset the flag. New tasks can now be scheduled. They would wait for the callback to finish.\n      this._scheduled = false;\n      this._promise = this._callback().then(\n        () => {\n          this._promise = null;\n        },\n        (error) => {\n          this._promise = null;\n          this._ctx.raise(error);\n        },\n      );\n    });\n\n    this._scheduled = true;\n  }\n\n  forceTrigger(): void {\n    scheduleMicroTask(this._ctx, async () => {\n      this._callback().catch((err) => this._ctx.raise(err));\n    });\n  }\n\n  /**\n   * Waits for the current task to finish if it is running.\n   * Does not schedule a new task.\n   */\n  async join(): Promise<void> {\n    await this._promise;\n  }\n\n  /**\n   * Force schedule the task to run and wait for it to finish.\n   */\n  async runBlocking(): Promise<void> {\n    // The previous task might still be running, so we need to wait for it to finish.\n    await this._promise; // Can't be rejected.\n    this._promise = this._callback();\n    await this._promise;\n  }\n}\n"],
  "mappings": "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",
  "names": ["createPromiseFromCallback", "run", "Promise", "resolve", "reject", "error", "value", "asyncChain", "chain", "elements", "result", "part", "Promise", "all", "map", "element", "ComplexMap", "combine", "cleanupFns", "flat", "forEach", "cleanupFn", "timeout", "cb", "ms", "t", "setTimeout", "clearTimeout", "interval", "setInterval", "clearInterval", "addEventListener", "target", "type", "listener", "options", "removeEventListener", "SubscriptionList", "_cleanups", "add", "push", "clear", "length", "SubscriptionSet", "keyProjection", "_cleanupMap", "ComplexMap", "set", "key", "debounce", "cb", "wait", "t", "args", "clearTimeout", "setTimeout", "toError", "err", "undefined", "Error", "TimeoutError", "timeout", "label", "toLocaleString", "observableError", "observable", "callback", "onTimeout", "onError", "ContextDisposedError", "sleep", "ms", "Promise", "resolve", "finish", "Date", "now", "sleeper", "delta", "setTimeout", "asyncReturn", "asyncTimeout", "promise", "timeout", "err", "timeoutId", "throwable", "undefined", "TimeoutError", "timeoutPromise", "reject", "unrefTimeout", "conditionTimeout", "createPromiseFromCallback", "race", "finally", "clearTimeout", "unref", "sleepWithContext", "ctx", "error", "ContextDisposedError", "disposed", "clearDispose", "onDispose", "onEvent", "eventEmitter", "eventName", "callback", "on", "off", "addListener", "remove", "waitForEvent", "test", "timeout", "error", "promise", "Promise", "resolve", "args", "asyncTimeout", "Error", "finally", "Context", "DO_NOT_ERROR_ON_ASYNC_CALLBACK", "Event", "_listeners", "Set", "_effects", "wrap", "emitter", "eventName", "event", "addEffect", "onEvent", "data", "emit", "on", "off", "listener", "trigger", "once", "delete", "emitAsync", "triggerAsync", "_ctx", "_callback", "options", "ctx", "callback", "weak", "EventListener", "_addListener", "_removeListener", "derefCallback", "Symbol", "asyncIterator", "Promise", "resolve", "waitFor", "predicate", "unsubscribe", "waitForCount", "expectedCount", "count", "waitForCondition", "listenerCount", "size", "effect", "handle", "cleanup", "undefined", "add", "debounce", "timeout", "firing", "lastFired", "debouncedEvent", "fireIn", "Date", "now", "setTimeout", "clearTimeout", "discardParameter", "pipeInto", "toJSON", "_runEffects", "remove", "_cleanupEffects", "_clearDispose", "onDispose", "WeakRef", "weakListeners", "registry", "register", "deref", "result", "err", "raise", "TypeError", "unregister", "weakListenersState", "FINALIZATION_REGISTRY_SUPPORTED", "globalThis", "FinalizationRegistry", "invariant", "latch", "count", "timeout", "t", "doResolve", "doReject", "promise", "Promise", "resolve", "reject", "value", "clearTimeout", "err", "setTimeout", "Error", "toLocaleString", "i", "warnAfterTimeout", "Mutex", "_queue", "Promise", "resolve", "_queueLength", "_tag", "tag", "isLocked", "acquire", "prev", "guard", "MutexGuard", "undefined", "executeSynchronized", "fun", "release", "_release", "Symbol", "dispose", "classMutexSymbol", "FORCE_DISABLE_WARNING", "enableWarning", "globalThis", "mochaExecutor", "synchronized", "target", "propertyName", "descriptor", "method", "value", "synchronizedMethod", "args", "mutex", "name", "warnAfterTimeout", "apply", "Object", "defineProperty", "Observable", "PushStream", "trigger", "timeout", "callback", "promise", "Promise", "resolve", "reject", "setTimeout", "Error", "toLocaleString", "provider", "resolver", "value", "TriggerState", "Trigger", "_options", "autoReset", "_state", "reset", "state", "wait", "asyncTimeout", "_promise", "TimeoutError", "wake", "_resolve", "_reject", "catch", "throw", "error", "MulticastObservable", "Observable", "subscriber", "_value", "observer", "_subscribe", "_observers", "Set", "_completed", "Trigger", "_handlers", "next", "value", "forEach", "error", "err", "complete", "wake", "_observable", "subscribe", "from", "initialValue", "on", "data", "observable", "of", "items", "slice", "empty", "EMPTY_OBSERVABLE", "get", "undefined", "Error", "wait", "timeout", "callback", "map", "filter", "reduce", "flatMap", "concat", "observables", "losslessConcat", "reducer", "multicast", "has", "add", "delete", "createSetDispatch", "ObservableProvider", "_handlers", "Set", "_proxy", "createSetDispatch", "handlers", "callback", "value", "_value", "setValue", "subscribe", "handler", "add", "delete", "CancellableObservableProvider", "_handleCancel", "_cancelled", "cancelled", "cancel", "onCancelled", "LifecycleState", "Resource", "cancelWithContext", "warnAfterTimeout", "log", "ContextDisposedError", "StackTrace", "StackTrace", "log", "enabled", "process", "env", "DX_TRACK_LEAKS", "openResources", "Set", "handleSymbol", "Symbol", "trackResource", "resourceProvider", "resource", "add", "delete", "trackLeaks", "open", "close", "target", "openMethod", "prototype", "closeMethod", "Error", "name", "args", "openStack", "apply", "Object", "defineProperty", "value", "dumpLeaks", "info", "size", "getStack", "global", "dxDumpLeaks", "DeferredTask", "_ctx", "_callback", "_scheduled", "_currentTask", "_nextTask", "Trigger", "scheduled", "schedule", "scheduleTask", "completionTrigger", "runInContextAsync", "then", "wake", "runBlocking", "disposed", "ContextDisposedError", "wait", "join", "runInContext", "ctx", "fn", "err", "raise", "scheduleMicroTask", "queueMicrotask", "afterMs", "clearTracking", "trackResource", "name", "openStack", "StackTrace", "timeout", "setTimeout", "clearDispose", "onDispose", "clearTimeout", "scheduleTaskInterval", "task", "interval", "timeoutId", "run", "scheduleExponentialBackoffTaskInterval", "initialInterval", "repeat", "INIT_RESTART_DELAY", "DEFAULT_MAX_RESTART_DELAY", "PersistentLifecycle", "Resource", "start", "stop", "onRestart", "maxRestartDelay", "_currentState", "undefined", "_restartTask", "_restartAfter", "_start", "_stop", "_onRestart", "_maxRestartDelay", "state", "_open", "DeferredTask", "_ctx", "_restart", "err", "log", "warn", "schedule", "catch", "_close", "join", "_stopCurrentState", "_lifecycleState", "LifecycleState", "OPEN", "cancelWithContext", "sleep", "Math", "min", "max", "warnAfterTimeout", "scheduleRestart", "invariant", "makePushIterable", "buf", "trigger", "Trigger", "autoReset", "Symbol", "asyncIterator", "next", "length", "wait", "item", "shift", "invariant", "kind", "value", "done", "push", "wake", "return", "throw", "sink", "emitter", "event", "count", "getPromise", "resolve", "trigger", "counter", "listener", "off", "on", "streamToArray", "stream", "deferred", "readable", "Promise", "resolve", "reject", "arr", "onData", "doc", "push", "onEnd", "err", "cleanup", "onClose", "removeListener", "on", "Duplex", "TestStream", "Duplex", "_received", "Buffer", "alloc", "_onWrite", "Event", "assertConnectivity", "stream1", "stream2", "timeout", "push", "Promise", "all", "assertReceivedAsync", "_write", "chunk", "encoding", "callback", "concat", "emit", "_read", "size", "data", "dataBuffer", "isBuffer", "from", "asyncTimeout", "waitForCondition", "equals", "waitForCondition", "condition", "timeout", "interval", "error", "breakOnError", "stopTime", "Date", "now", "trigger", "Trigger", "waiter", "value", "wake", "err", "throw", "sleep", "setTimeout", "wait", "Timer", "_callback", "_state", "Event", "_count", "state", "running", "_timer", "start", "options", "cb", "isNaN", "count", "interval", "Error", "JSON", "stringify", "stop", "run", "Math", "random", "jitter", "setTimeout", "emit", "clearInterval", "undefined", "until", "cb", "timeout", "Promise", "resolve", "reject", "t", "setTimeout", "Error", "value", "clearTimeout", "error", "err", "untilPromise", "untilError", "TIME_PERIOD", "UpdateScheduler", "_ctx", "_callback", "_params", "_promise", "_scheduled", "_lastUpdateTime", "onDispose", "trigger", "scheduleMicroTask", "maxFrequency", "now", "performance", "delay", "Promise", "resolve", "timeoutId", "setTimeout", "clearContext", "clearTimeout", "disposed", "then", "error", "raise", "forceTrigger", "catch", "err", "join", "runBlocking"]
}
