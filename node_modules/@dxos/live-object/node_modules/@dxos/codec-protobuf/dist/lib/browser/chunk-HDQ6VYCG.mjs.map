{
  "version": 3,
  "sources": ["../../../src/stream.ts"],
  "sourcesContent": ["//\n// Copyright 2021 DXOS.org\n//\n\nimport { Context } from '@dxos/context';\nimport { invariant } from '@dxos/invariant';\nimport { log } from '@dxos/log';\nimport { throwUnhandledError, type MaybePromise } from '@dxos/util';\n\ntype Callbacks<T> = {\n  ctx: Context;\n\n  /**\n   * Advises that the producer is ready to stream the data.\n   * Called automatically with the first call to `next`.\n   */\n  ready: () => void;\n\n  /**\n   * Sends a message into the stream.\n   */\n  next: (message: T) => void;\n\n  /**\n   * Closes the stream.\n   * Optional error can be provided.\n   */\n  close: (err?: Error) => void;\n};\n\ntype Producer<T> = (callbacks: Callbacks<T>) => ((err?: Error) => void) | void;\n\nexport type StreamItem<T> = { ready: true } | { data: T } | { closed: true; error?: Error };\n\n// TODO(burdon): Implement Observable<T> pattern to simplify callbacks.\n// stream.subscribe({\n//   onData: (data: CustomData) => {\n//   },\n//   onOpen: () => {\n//   },\n//   onClose: () => {\n//   },\n//   onError: () => {\n//   }\n// });\n//\n// stream.unsubscribe();\n// await stream.close90:\n\n/**\n * Represents a typed stream of data.\n * In concept it's a Promise that can resolve multiple times.\n * Can only have one subscriber.\n * `close` must be called to clean-up the resources.\n */\nexport class Stream<T> {\n  /**\n   * Consumes the entire stream to the end until it closes and returns a promise with the resulting items.\n   */\n  static consume<T>(stream: Stream<T>): Promise<StreamItem<T>[]> {\n    return new Promise((resolve) => {\n      const items: StreamItem<T>[] = [];\n\n      stream.onReady(() => {\n        items.push({ ready: true });\n      });\n      stream.subscribe(\n        (data) => {\n          items.push({ data });\n        },\n        (error) => {\n          if (error) {\n            items.push({ closed: true, error });\n          } else {\n            items.push({ closed: true });\n          }\n          resolve(items);\n        },\n      );\n    });\n  }\n\n  static async consumeData<T>(stream: Stream<T>): Promise<T[]> {\n    const entries = await Stream.consume(stream);\n    const res: T[] = [];\n    for (const entry of entries) {\n      if ('data' in entry) {\n        res.push(entry.data);\n      } else if ('closed' in entry && entry.closed === true) {\n        if (entry.error) {\n          throw entry.error;\n        } else {\n          break;\n        }\n      }\n    }\n    return res;\n  }\n\n  static async first<T>(stream: Stream<T>): Promise<T | undefined> {\n    return new Promise((resolve, reject) => {\n      stream.subscribe(\n        (data) => {\n          resolve(data);\n          void stream.close();\n        },\n        (error) => {\n          if (error) {\n            reject(error);\n          } else {\n            resolve(undefined);\n          }\n        },\n      );\n    });\n  }\n\n  /**\n   * Maps all data coming through the stream.\n   */\n  static map<T, U>(source: Stream<T>, map: (data: T) => U): Stream<U> {\n    return new Stream(({ ready, next, close }) => {\n      source.onReady(ready);\n      source.subscribe((data) => next(map(data)), close);\n\n      return () => source.close();\n    });\n  }\n\n  /**\n   * Converts Promise<Stream<T>> to Stream<T>.\n   */\n  static unwrapPromise<T>(streamPromise: MaybePromise<Stream<T>>): Stream<T> {\n    if (streamPromise instanceof Stream) {\n      return streamPromise;\n    }\n\n    return new Stream(({ ready, next, close }) => {\n      streamPromise.then(\n        (stream) => {\n          stream.onReady(ready);\n          stream.subscribe(next, close);\n        },\n        (err) => {\n          close(err);\n        },\n      );\n      return () => {\n        streamPromise.then(\n          (stream) => stream.close(),\n          // eslint-disable-next-line n/handle-callback-err\n          (err) => {\n            /* already handled */\n          },\n        );\n      };\n    });\n  }\n\n  static fromPromise<T>(promise: Promise<T>): Stream<T> {\n    return new Stream(({ ready, next, close }) => {\n      promise.then(\n        (data) => {\n          ready();\n          next(data);\n          close();\n        },\n        (err) => {\n          close(err);\n        },\n      );\n    });\n  }\n\n  private readonly _ctx: Context;\n  private _messageHandler?: (msg: T) => void = undefined;\n  private _closeHandler?: (error?: Error) => void = undefined;\n  private _readyHandler?: () => void = undefined;\n\n  private _isClosed = false;\n  private _closeError: Error | undefined = undefined;\n  private _producerCleanup: ((err?: Error) => void) | undefined = undefined;\n  private _readyPromise: Promise<void>;\n  private _resolveReadyPromise!: () => void;\n  private _isReady = false;\n\n  /**\n   * Buffer messages before subscription. Set to null when buffer is no longer needed.\n   */\n  private _buffer: T[] | null = [];\n\n  constructor(producer: Producer<T>) {\n    this._readyPromise = new Promise((resolve) => {\n      this._resolveReadyPromise = resolve;\n    });\n\n    this._ctx = new Context({\n      onError: (err) => {\n        if (this._isClosed) {\n          return;\n        }\n\n        this._isClosed = true;\n        this._closeError = err;\n        this._producerCleanup?.(err);\n        this._closeHandler?.(err);\n        void this._ctx.dispose();\n      },\n    });\n    this._ctx.onDispose(() => this.close());\n\n    try {\n      const producerCleanup = producer({\n        ctx: this._ctx,\n\n        ready: () => {\n          this._markAsReady();\n        },\n\n        next: (msg) => {\n          if (this._isClosed) {\n            log('Stream is closed, dropping message.');\n            return;\n          }\n\n          this._markAsReady();\n\n          if (this._messageHandler) {\n            try {\n              this._messageHandler(msg);\n            } catch (err: any) {\n              // Stop error propagation.\n              throwUnhandledError(err);\n            }\n          } else {\n            invariant(this._buffer);\n            this._buffer.push(msg);\n          }\n        },\n\n        close: (err) => {\n          if (this._isClosed) {\n            return;\n          }\n\n          this._isClosed = true;\n          this._closeError = err;\n          this._producerCleanup?.(err);\n          try {\n            this._closeHandler?.(err);\n          } catch (err: any) {\n            // Stop error propagation.\n            throwUnhandledError(err);\n          }\n          void this._ctx.dispose();\n        },\n      });\n\n      if (producerCleanup) {\n        this._producerCleanup = producerCleanup;\n      }\n    } catch (err: any) {\n      this._ctx.raise(err);\n    }\n  }\n\n  private _markAsReady(): void {\n    if (!this._isReady) {\n      this._isReady = true;\n      this._readyHandler?.();\n      this._resolveReadyPromise();\n    }\n  }\n\n  // TODO(burdon): Can this be cancelled?\n  subscribe(onMessage: (msg: T) => void, onClose?: (err?: Error) => void): void {\n    invariant(!this._messageHandler, 'Stream is already subscribed to.');\n    invariant(!this._closeHandler, 'Stream is already subscribed to.');\n    invariant(this._buffer); // Must be not-null.\n\n    for (const message of this._buffer) {\n      try {\n        onMessage(message);\n      } catch (err: any) {\n        // Stop error propagation.\n        throwUnhandledError(err);\n      }\n    }\n\n    this._buffer = null;\n\n    // Stream might have already have been closed.\n    if (this._isClosed) {\n      onClose?.(this._closeError);\n      return;\n    }\n\n    this._messageHandler = onMessage;\n    this._closeHandler = onClose;\n  }\n\n  /**\n   * Resolves when stream is ready.\n   */\n  // TODO(burdon): Gather all callbacks into single observer.\n  waitUntilReady(): Promise<void> {\n    return this._readyPromise;\n  }\n\n  /**\n   * Registers a callback to be called when stream is ready.\n   */\n  onReady(onReady: () => void): void {\n    invariant(!this._readyHandler, 'Stream already has a handler for the ready event.');\n    this._readyHandler = onReady;\n    if (this._isReady) {\n      onReady();\n    }\n  }\n\n  /**\n   * Close the stream and dispose of any resources.\n   */\n  async close(): Promise<void> {\n    if (this._isClosed) {\n      return;\n    }\n\n    this._isClosed = true;\n    this._producerCleanup?.();\n    this._closeHandler?.(undefined);\n    await this._ctx.dispose();\n\n    // Clear function pointers.\n    this._messageHandler = undefined;\n    this._closeHandler = undefined;\n    this._producerCleanup = undefined;\n  }\n}\n"],
  "mappings": "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",
  "names": ["Context", "invariant", "log", "throwUnhandledError", "Stream", "producer", "_messageHandler", "undefined", "_closeHandler", "_readyHandler", "_isClosed", "_closeError", "_producerCleanup", "_isReady", "_buffer", "_readyPromise", "Promise", "resolve", "_resolveReadyPromise", "_ctx", "onError", "err", "dispose", "onDispose", "close", "producerCleanup", "ctx", "ready", "_markAsReady", "next", "msg", "push", "raise", "consume", "stream", "items", "onReady", "subscribe", "data", "error", "closed", "consumeData", "entries", "res", "entry", "first", "reject", "map", "source", "unwrapPromise", "streamPromise", "then", "fromPromise", "promise", "onMessage", "onClose", "message", "waitUntilReady"]
}
