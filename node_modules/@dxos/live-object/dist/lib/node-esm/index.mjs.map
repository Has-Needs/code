{
  "version": 3,
  "sources": ["../../../src/index.ts", "../../../src/snapshot.ts", "../../../src/live.ts"],
  "sourcesContent": ["//\n// Copyright 2024 DXOS.org\n//\n\n// TODO(dmaretskyi): Remove deprecated exports.\n\nimport * as EchoSchemaModule from '@dxos/echo-schema';\n\nexport * from './proxy';\nexport * from './snapshot';\nexport * from './object';\nexport * from './live';\n\n/**\n * @deprecated Use {@link Ref.make} instead.\n */\nexport const makeRef = EchoSchemaModule.Ref.make;\n\n/**\n * @deprecated Use {@link Ref.fromDXN} instead.\n */\nexport const refFromDXN = EchoSchemaModule.Ref.fromDXN;\n\n/**\n * @deprecated Import from `@dxos/echo-schema` instead.\n */\nexport const RefArray = EchoSchemaModule.RefArray;\n\n/**\n * @deprecated Import from `@dxos/echo-schema` instead.\n */\nexport const getObjectMeta = EchoSchemaModule.getObjectMeta;\n\n/**\n * @deprecated Import from `@dxos/echo-schema` instead.\n */\nexport const isDeleted = EchoSchemaModule.isDeleted;\n\n/**\n * @deprecated Import from `@dxos/echo-schema` instead.\n */\nexport const getType = EchoSchemaModule.getType;\n\n/**\n * @deprecated Import from `@dxos/echo-schema` instead.\n */\nexport const getMeta = EchoSchemaModule.getMeta;\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { type BaseObject, Ref } from '@dxos/echo-schema';\nimport { deepMapValues } from '@dxos/util';\n\nimport type { Live } from './live';\n\n/**\n * Returns an immutable snapshot of the live object.\n */\nexport const getSnapshot = <T extends BaseObject>(obj: Live<T>): T => {\n  return deepMapValues(obj, (value, recurse) => {\n    // Do not recurse on references.\n    if (Ref.isRef(value)) {\n      return { '/': value.dxn.toString() };\n    }\n\n    return recurse(value);\n  });\n};\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { isProxy } from './proxy/proxy';\n\n// This odd construct only serves one purpose: when you hover over `const x: Live<T>` you'd see `Live<T>` type.\ninterface _Live {}\n\n/**\n * Live reactive object marker interface (does not change the shape of the object.)\n * Accessing properties triggers signal semantics.\n *\n * It is recommended to use explicitly use this type when expecting reactive semantics, e.g. `Live<MyObject>`.\n * One common use case includes React components.\n */\nexport type Live<T> = _Live & T;\n\n/**\n * @returns true if the value is a reactive object.\n */\nexport const isLiveObject = (value: unknown): boolean => isProxy(value);\n"],
  "mappings": ";;;;;;;;;;;;;;;;AAMA,YAAYA,sBAAsB;;;ACFlC,SAA0BC,WAAW;AACrC,SAASC,qBAAqB;AAOvB,IAAMC,cAAc,CAAuBC,QAAAA;AAChD,SAAOC,cAAcD,KAAK,CAACE,OAAOC,YAAAA;AAEhC,QAAIC,IAAIC,MAAMH,KAAAA,GAAQ;AACpB,aAAO;QAAE,KAAKA,MAAMI,IAAIC,SAAQ;MAAG;IACrC;AAEA,WAAOJ,QAAQD,KAAAA;EACjB,CAAA;AACF;;;ACAO,IAAMM,eAAe,CAACC,UAA4BC,QAAQD,KAAAA;;;AFL1D,IAAME,UAA2BC,qBAAIC;AAKrC,IAAMC,aAA8BF,qBAAIG;AAKxC,IAAMC,YAA4BA;AAKlC,IAAMC,iBAAiCA;AAKvC,IAAMC,aAA6BA;AAKnC,IAAMC,WAA2BA;AAKjC,IAAMC,WAA2BA;",
  "names": ["EchoSchemaModule", "Ref", "deepMapValues", "getSnapshot", "obj", "deepMapValues", "value", "recurse", "Ref", "isRef", "dxn", "toString", "isLiveObject", "value", "isProxy", "makeRef", "Ref", "make", "refFromDXN", "fromDXN", "RefArray", "getObjectMeta", "isDeleted", "getType", "getMeta"]
}
