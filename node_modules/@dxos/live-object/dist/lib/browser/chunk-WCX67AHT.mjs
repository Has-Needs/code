import "@dxos/node-std/globals";

// packages/core/echo/live-object/src/proxy/array.ts
import { compositeRuntime } from "@dxos/echo-signals/runtime";
var ReactiveArray = class extends Array {
  static get [Symbol.species]() {
    return Array;
  }
  static {
    const BATCHED_METHODS = [
      "push",
      "pop",
      "shift",
      "unshift",
      "splice",
      "sort",
      "reverse"
    ];
    for (const method of BATCHED_METHODS) {
      Object.defineProperty(this.prototype, method, {
        enumerable: false,
        value: function(...args) {
          let result;
          compositeRuntime.batch(() => {
            result = Array.prototype[method].apply(this, args);
          });
          return result;
        }
      });
    }
  }
};

// packages/core/echo/live-object/src/proxy/proxy.ts
import { invariant } from "@dxos/invariant";
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/core/echo/live-object/src/proxy/proxy.ts";
var symbolIsProxy = Symbol.for("@dxos/schema/Proxy");
var isProxy = (value) => !!value?.[symbolIsProxy];
var isValidProxyTarget = (value) => {
  if (value == null || value[symbolIsProxy]) {
    return false;
  }
  if (value instanceof ReactiveArray) {
    return true;
  }
  return typeof value === "object" && Object.getPrototypeOf(value) === Object.prototype;
};
var getProxySlot = (proxy) => {
  const value = proxy[symbolIsProxy];
  invariant(value instanceof ProxyHandlerSlot, void 0, {
    F: __dxlog_file,
    L: 35,
    S: void 0,
    A: [
      "value instanceof ProxyHandlerSlot",
      ""
    ]
  });
  return value;
};
var getProxyTarget = (proxy) => {
  return getProxySlot(proxy).target;
};
var getProxyHandler = (proxy) => {
  return getProxySlot(proxy).handler;
};
var dangerouslySetProxyId = (obj, id) => {
  getProxySlot(obj).target.id = id;
};
var createProxy = (target, handler) => {
  const existingProxy = handler._proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const proxy = new Proxy(target, new ProxyHandlerSlot(target, handler));
  handler.init(target);
  handler._proxyMap.set(target, proxy);
  return proxy;
};
var ProxyHandlerSlot = class {
  /**
  * @param target Original object.
  * @param _handler Handles intercepted operations.
  */
  constructor(target, _handler) {
    this.target = target;
    this._handler = _handler;
  }
  get handler() {
    invariant(this._handler, void 0, {
      F: __dxlog_file,
      L: 94,
      S: this,
      A: [
        "this._handler",
        ""
      ]
    });
    return this._handler;
  }
  // TODO(burdon): Requires comment.
  setHandler(handler) {
    this._handler = handler;
  }
  /**
  * Get value.
  */
  get(target, prop, receiver) {
    if (prop === symbolIsProxy) {
      return this;
    }
    if (!this._handler || !this._handler.get) {
      return Reflect.get(target, prop, receiver);
    }
    return this._handler.get(target, prop, receiver);
  }
  static {
    const TRAPS = [
      "apply",
      "construct",
      "defineProperty",
      "deleteProperty",
      "get",
      "getOwnPropertyDescriptor",
      "getPrototypeOf",
      "has",
      "isExtensible",
      "ownKeys",
      "preventExtensions",
      "set",
      "setPrototypeOf"
    ];
    for (const trap of TRAPS) {
      if (trap === "get") {
        continue;
      }
      Object.defineProperty(this.prototype, trap, {
        enumerable: false,
        value: function(...args) {
          if (!this._handler || !this._handler[trap]) {
            return Reflect[trap](...args);
          }
          return this._handler[trap].apply(this._handler, args);
        }
      });
    }
  }
};

// packages/core/echo/live-object/src/proxy/types.ts
var objectData = Symbol.for("@dxos/live-object/objectData");

// packages/core/echo/live-object/src/object.ts
import { ObjectId, defineHiddenProperty as defineHiddenProperty3, getTypeAnnotation, Expando, ObjectMetaSchema, EntityKindId } from "@dxos/echo-schema";
import { MetaId } from "@dxos/echo-schema";

// packages/core/echo/live-object/src/typed-handler.ts
import { SchemaAST, Schema } from "effect";
import { inspectCustom } from "@dxos/debug";
import { defineHiddenProperty, DeletedId, getSchemaDXN, SchemaId, SchemaValidator, TypeId } from "@dxos/echo-schema";
import { compositeRuntime as compositeRuntime2 } from "@dxos/echo-signals/runtime";
import { invariant as invariant2 } from "@dxos/invariant";
var __dxlog_file2 = "/home/runner/work/dxos/dxos/packages/core/echo/live-object/src/typed-handler.ts";
var symbolSignal = Symbol("signal");
var symbolPropertySignal = Symbol("property-signal");
var TypedReactiveHandler = class _TypedReactiveHandler {
  constructor() {
    this._proxyMap = /* @__PURE__ */ new WeakMap();
  }
  static {
    this.instance = new _TypedReactiveHandler();
  }
  init(target) {
    invariant2(typeof target === "object" && target !== null, void 0, {
      F: __dxlog_file2,
      L: 59,
      S: this,
      A: [
        "typeof target === 'object' && target !== null",
        ""
      ]
    });
    invariant2(SchemaId in target, "Schema is not defined for the target", {
      F: __dxlog_file2,
      L: 60,
      S: this,
      A: [
        "SchemaId in target",
        "'Schema is not defined for the target'"
      ]
    });
    if (!(symbolSignal in target)) {
      defineHiddenProperty(target, symbolSignal, compositeRuntime2.createSignal());
      defineHiddenProperty(target, symbolPropertySignal, compositeRuntime2.createSignal());
    }
    defineHiddenProperty(target, DeletedId, false);
    for (const key of Object.getOwnPropertyNames(target)) {
      const descriptor = Object.getOwnPropertyDescriptor(target, key);
      if (descriptor.get) {
        continue;
      }
    }
    Object.defineProperty(target, inspectCustom, {
      enumerable: false,
      configurable: true,
      value: this._inspect.bind(target)
    });
  }
  get(target, prop, receiver) {
    switch (prop) {
      case objectData: {
        target[symbolSignal].notifyRead();
        return toJSON(target);
      }
    }
    if (Object.getOwnPropertyDescriptor(target, prop)?.get) {
      target[symbolPropertySignal].notifyRead();
      return Reflect.get(target, prop, receiver);
    }
    target[symbolSignal].notifyRead();
    target[symbolPropertySignal].notifyRead();
    const value = Reflect.get(target, prop, receiver);
    if (isValidProxyTarget(value)) {
      return createProxy(value, this);
    }
    return value;
  }
  set(target, prop, value, receiver) {
    if (Array.isArray(value)) {
      value = ReactiveArray.from(value);
    }
    let result = false;
    compositeRuntime2.batch(() => {
      const validatedValue = this._validateValue(target, prop, value);
      result = Reflect.set(target, prop, validatedValue, receiver);
      target[symbolSignal].notifyWrite();
    });
    return result;
  }
  ownKeys(target) {
    target[symbolSignal].notifyRead();
    target[symbolPropertySignal].notifyRead();
    return Reflect.ownKeys(target);
  }
  defineProperty(target, property, attributes) {
    const validatedValue = this._validateValue(target, property, attributes.value);
    const result = Reflect.defineProperty(target, property, {
      ...attributes,
      value: validatedValue
    });
    target[symbolPropertySignal].notifyWrite();
    return result;
  }
  _validateValue(target, prop, value) {
    const schema = SchemaValidator.getTargetPropertySchema(target, prop);
    const _ = Schema.asserts(schema)(value);
    if (Array.isArray(value)) {
      value = new ReactiveArray(...value);
    }
    if (isValidProxyTarget(value)) {
      setSchemaProperties(value, schema);
    }
    return value;
  }
  _inspect(_, options, inspectFn) {
    return `Typed ${inspectFn(this, {
      ...options,
      compact: true,
      showHidden: false,
      customInspect: false
    })}`;
  }
};
var toJSON = (target) => {
  return {
    "@type": "TypedReactiveObject",
    ...target
  };
};
var setSchemaProperties = (obj, schema) => {
  const schemaType = getSchemaDXN(schema);
  if (schemaType != null) {
    defineHiddenProperty(obj, TypeId, schemaType);
  }
  defineHiddenProperty(obj, SchemaId, schema);
  for (const key in obj) {
    if (isValidProxyTarget(obj[key])) {
      const elementSchema = SchemaValidator.getTargetPropertySchema(obj, key);
      if (elementSchema != null) {
        setSchemaProperties(obj[key], elementSchema);
      }
    }
  }
};
var prepareTypedTarget = (target, schema) => {
  if (!SchemaAST.isTypeLiteral(schema.ast)) {
    throw new Error("schema has to describe an object type");
  }
  SchemaValidator.validateSchema(schema);
  const _ = Schema.asserts(schema)(target);
  makeArraysReactive(target);
  setSchemaProperties(target, schema);
};
var makeArraysReactive = (target) => {
  for (const key in target) {
    if (target[symbolIsProxy]) {
      continue;
    }
    if (Array.isArray(target[key])) {
      target[key] = ReactiveArray.from(target[key]);
    }
    if (typeof target[key] === "object") {
      makeArraysReactive(target[key]);
    }
  }
};

// packages/core/echo/live-object/src/untyped-handler.ts
import { defineHiddenProperty as defineHiddenProperty2, DeletedId as DeletedId2, getTypename, TypeId as TypeId2 } from "@dxos/echo-schema";
import { compositeRuntime as compositeRuntime3 } from "@dxos/echo-signals/runtime";
import { invariant as invariant3 } from "@dxos/invariant";
var __dxlog_file3 = "/home/runner/work/dxos/dxos/packages/core/echo/live-object/src/untyped-handler.ts";
var symbolSignal2 = Symbol("signal");
var symbolPropertySignal2 = Symbol("property-signal");
var UntypedReactiveHandler = class _UntypedReactiveHandler {
  constructor() {
    // TODO(dmaretskyi): Does this work? Should this be a global variable instead?
    this._proxyMap = /* @__PURE__ */ new WeakMap();
  }
  static {
    this.instance = new _UntypedReactiveHandler();
  }
  init(target) {
    invariant3(typeof target === "object" && target !== null, void 0, {
      F: __dxlog_file3,
      L: 42,
      S: this,
      A: [
        "typeof target === 'object' && target !== null",
        ""
      ]
    });
    if (!(symbolSignal2 in target)) {
      defineHiddenProperty2(target, symbolSignal2, compositeRuntime3.createSignal());
      defineHiddenProperty2(target, symbolPropertySignal2, compositeRuntime3.createSignal());
    }
    defineHiddenProperty2(target, DeletedId2, false);
    for (const key of Object.getOwnPropertyNames(target)) {
      const descriptor = Object.getOwnPropertyDescriptor(target, key);
      if (descriptor.get) {
        continue;
      }
      if (Array.isArray(target[key]) && !(target[key] instanceof ReactiveArray)) {
        target[key] = ReactiveArray.from(target[key]);
      }
    }
  }
  get(target, prop, receiver) {
    if (Object.getOwnPropertyDescriptor(target, prop)?.get) {
      target[symbolPropertySignal2].notifyRead();
      return Reflect.get(target, prop, receiver);
    }
    target[symbolSignal2].notifyRead();
    target[symbolPropertySignal2].notifyRead();
    if (prop === objectData) {
      return toJSON2(target);
    }
    if (prop === TypeId2) {
      return void 0;
    }
    const value = Reflect.get(target, prop);
    if (isValidProxyTarget(value)) {
      const isTyped = getTypename(value) !== void 0;
      if (isTyped) {
        return createProxy(value, TypedReactiveHandler.instance);
      } else {
        return createProxy(value, this);
      }
    }
    return value;
  }
  set(target, prop, value, receiver) {
    if (Array.isArray(value)) {
      value = ReactiveArray.from(value);
    }
    const result = Reflect.set(target, prop, value);
    target[symbolSignal2].notifyWrite();
    return result;
  }
  ownKeys(target) {
    target[symbolSignal2].notifyRead();
    target[symbolPropertySignal2].notifyRead();
    return Reflect.ownKeys(target);
  }
  defineProperty(target, property, attributes) {
    const result = Reflect.defineProperty(target, property, attributes);
    target[symbolPropertySignal2].notifyWrite();
    return result;
  }
};
var toJSON2 = (target) => {
  return {
    "@type": "ReactiveObject",
    ...target
  };
};

// packages/core/echo/live-object/src/object.ts
var live = (objOrSchema, obj, meta) => {
  if (obj && objOrSchema !== Expando) {
    return createReactiveObject({
      ...obj
    }, meta, objOrSchema);
  } else if (obj && objOrSchema === Expando) {
    return createReactiveObject({
      ...obj
    }, meta, void 0, {
      expando: true
    });
  } else {
    return createReactiveObject(objOrSchema, meta);
  }
};
var createReactiveObject = (obj, meta, schema, options) => {
  if (!isValidProxyTarget(obj)) {
    throw new Error("Value cannot be made into a reactive object.");
  }
  if (schema) {
    const annotation = getTypeAnnotation(schema);
    const shouldGenerateId = options?.expando || !!annotation;
    if (shouldGenerateId) {
      setIdOnTarget(obj);
    }
    if (annotation) {
      defineHiddenProperty3(obj, EntityKindId, annotation.kind);
    }
    initMeta(obj, meta);
    prepareTypedTarget(obj, schema);
    return createProxy(obj, TypedReactiveHandler.instance);
  } else {
    if (options?.expando) {
      setIdOnTarget(obj);
    }
    initMeta(obj, meta);
    return createProxy(obj, UntypedReactiveHandler.instance);
  }
};
var setIdOnTarget = (target) => {
  if ("id" in target) {
    if (!ObjectId.isValid(target.id)) {
      throw new Error("Invalid object id format.");
    }
  } else {
    target.id = ObjectId.random();
  }
};
var initMeta = (obj, meta = {
  keys: []
}) => {
  prepareTypedTarget(meta, ObjectMetaSchema);
  defineHiddenProperty3(obj, MetaId, createProxy(meta, TypedReactiveHandler.instance));
};

export {
  ReactiveArray,
  symbolIsProxy,
  isProxy,
  isValidProxyTarget,
  getProxySlot,
  getProxyTarget,
  getProxyHandler,
  dangerouslySetProxyId,
  createProxy,
  objectData,
  live
};
//# sourceMappingURL=chunk-WCX67AHT.mjs.map
