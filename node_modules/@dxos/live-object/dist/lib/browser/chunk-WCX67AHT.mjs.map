{
  "version": 3,
  "sources": ["../../../src/proxy/array.ts", "../../../src/proxy/proxy.ts", "../../../src/proxy/types.ts", "../../../src/object.ts", "../../../src/typed-handler.ts", "../../../src/untyped-handler.ts"],
  "sourcesContent": ["//\n// Copyright 2024 DXOS.org\n//\n\nimport { compositeRuntime } from '@dxos/echo-signals/runtime';\n\n/**\n * Extends the native array to make sure that arrays methods are correctly reactive.\n */\nexport class ReactiveArray<T> extends Array<T> {\n  static override get [Symbol.species]() {\n    return Array;\n  }\n\n  static {\n    /**\n     * These methods will trigger proxy traps like `set` and `defineProperty` and emit signal notifications.\n     * We wrap them in a batch to avoid unnecessary signal notifications.\n     */\n    const BATCHED_METHODS = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'] as const;\n\n    for (const method of BATCHED_METHODS) {\n      Object.defineProperty(this.prototype, method, {\n        enumerable: false,\n        value: function (this: ReactiveArray<any>, ...args: any[]) {\n          let result!: any;\n          compositeRuntime.batch(() => {\n            result = Array.prototype[method].apply(this, args);\n          });\n          return result;\n        },\n      });\n    }\n  }\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { type BaseObject } from '@dxos/echo-schema';\nimport { invariant } from '@dxos/invariant';\n\nimport { ReactiveArray } from './array';\nimport { type ReactiveHandler } from './types';\nimport type { Live } from '../live';\n\nexport const symbolIsProxy = Symbol.for('@dxos/schema/Proxy');\n\n/**\n * Internal api.\n */\nexport const isProxy = (value: unknown) => !!(value as any)?.[symbolIsProxy];\n\nexport const isValidProxyTarget = (value: any): value is object => {\n  if (value == null || value[symbolIsProxy]) {\n    return false;\n  }\n  if (value instanceof ReactiveArray) {\n    return true;\n  }\n\n  return typeof value === 'object' && Object.getPrototypeOf(value) === Object.prototype;\n};\n\n/**\n * @deprecated\n */\nexport const getProxySlot = <T extends BaseObject>(proxy: Live<any>): ProxyHandlerSlot<T> => {\n  const value = (proxy as any)[symbolIsProxy];\n  invariant(value instanceof ProxyHandlerSlot);\n  return value;\n};\n\nexport const getProxyTarget = <T extends BaseObject>(proxy: Live<any>): T => {\n  return getProxySlot<T>(proxy).target;\n};\n\nexport const getProxyHandler = <T extends BaseObject>(proxy: Live<any>): ReactiveHandler<T> => {\n  return getProxySlot<T>(proxy).handler;\n};\n\n/**\n * Unsafe method to override id for debugging/testing and migration purposes.\n * @deprecated\n */\nexport const dangerouslySetProxyId = <T extends BaseObject>(obj: Live<T>, id: string) => {\n  (getProxySlot(obj).target as any).id = id;\n};\n\n/**\n * Create a reactive proxy object.\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy\n *\n * @param target Object or array. Passing in array will enable array methods.\n * @param handler ReactiveHandler instance.\n */\n// TODO(burdon): Document.\n// TODO(burdon): Tests for low-level functions.\nexport const createProxy = <T extends BaseObject>(target: T, handler: ReactiveHandler<T>): Live<T> => {\n  const existingProxy = handler._proxyMap.get(target);\n  if (existingProxy) {\n    return existingProxy;\n  }\n\n  // TODO(dmaretskyi): In the future this should be mutable to allow replacing the handler on-the-fly while maintaining the proxy identity.\n  const proxy = new Proxy(target, new ProxyHandlerSlot<T>(target, handler));\n  handler.init(target);\n\n  // TODO(dmaretskyi): Check if this will actually work; maybe a global WeakMap is better?\n  handler._proxyMap.set(target, proxy);\n  return proxy;\n};\n\n/**\n * Passed as the handler to the Proxy constructor.\n * Maintains a mutable slot for the actual handler.\n */\nclass ProxyHandlerSlot<T extends BaseObject> implements ProxyHandler<T> {\n  /**\n   * @param target Original object.\n   * @param _handler Handles intercepted operations.\n   */\n  constructor(\n    readonly target: T,\n    private _handler: ReactiveHandler<T>,\n  ) {}\n\n  get handler() {\n    invariant(this._handler);\n    return this._handler;\n  }\n\n  // TODO(burdon): Requires comment.\n  setHandler(handler: ReactiveHandler<T>): void {\n    this._handler = handler;\n  }\n\n  /**\n   * Get value.\n   */\n  get(target: T, prop: string | symbol, receiver: any): any {\n    if (prop === symbolIsProxy) {\n      return this;\n    }\n\n    if (!this._handler || !this._handler.get) {\n      return Reflect.get(target, prop, receiver);\n    }\n\n    return this._handler.get(target, prop, receiver);\n  }\n\n  static {\n    const TRAPS: (keyof ProxyHandler<any>)[] = [\n      'apply',\n      'construct',\n      'defineProperty',\n      'deleteProperty',\n      'get',\n      'getOwnPropertyDescriptor',\n      'getPrototypeOf',\n      'has',\n      'isExtensible',\n      'ownKeys',\n      'preventExtensions',\n      'set',\n      'setPrototypeOf',\n    ];\n\n    for (const trap of TRAPS) {\n      if (trap === 'get') {\n        continue;\n      }\n\n      Object.defineProperty(this.prototype, trap, {\n        enumerable: false,\n        value: function (this: ProxyHandlerSlot<any>, ...args: any[]) {\n          // log.info('trap', { trap, args });\n          if (!this._handler || !this._handler[trap]) {\n            return (Reflect[trap] as Function)(...args);\n          }\n\n          return (this._handler[trap] as Function).apply(this._handler, args);\n        },\n      });\n    }\n  }\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { type BaseObject } from '@dxos/echo-schema';\n\n/**\n * Reactive object proxy.\n */\nexport interface ReactiveHandler<T extends BaseObject> extends ProxyHandler<T> {\n  /**\n   * Target to Proxy mapping.\n   */\n  readonly _proxyMap: WeakMap<object, any>;\n\n  /**\n   * Called when a proxy is created for this target.\n   */\n  init(target: T): void;\n}\n\n/**\n * For debug-dumping the data of the object.\n */\nexport const objectData = Symbol.for('@dxos/live-object/objectData');\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { type Schema } from 'effect';\n\nimport {\n  ObjectId,\n  defineHiddenProperty,\n  getTypeAnnotation,\n  type BaseObject,\n  Expando,\n  type ObjectMeta,\n  ObjectMetaSchema,\n  EntityKindId,\n  type CreationProps,\n} from '@dxos/echo-schema';\nimport { MetaId } from '@dxos/echo-schema';\n\nimport type { Live } from './live';\nimport { createProxy, isValidProxyTarget } from './proxy';\nimport { prepareTypedTarget, TypedReactiveHandler } from './typed-handler';\nimport { UntypedReactiveHandler } from './untyped-handler';\n\n/**\n * Creates a reactive object from a plain Javascript object.\n * Optionally provides a TS-effect schema.\n */\n// TODO(dmaretskyi): Deep mutability.\n// TODO(dmaretskyi): Invert generics (generic over schema) to have better error messages.\n// TODO(dmaretskyi): Could mutate original object making it unusable.\n// TODO(burdon): Use Schema.make() to handle defaults?\nexport const live: {\n  <T extends BaseObject>(obj: T): Live<T>;\n  <T extends BaseObject>(\n    schema: Schema.Schema<T, any, never>,\n    obj: NoInfer<CreationProps<T>>,\n    meta?: ObjectMeta,\n  ): Live<T>;\n} = <T extends BaseObject>(\n  objOrSchema: Schema.Schema<T, any> | T,\n  obj?: CreationProps<T>,\n  meta?: ObjectMeta,\n): Live<T> => {\n  // TODO(dmaretskyi): Remove Expando special case.\n  if (obj && (objOrSchema as any) !== Expando) {\n    return createReactiveObject<T>({ ...obj } as T, meta, objOrSchema as Schema.Schema<T, any>);\n  } else if (obj && (objOrSchema as any) === Expando) {\n    return createReactiveObject<T>({ ...obj } as T, meta, undefined, { expando: true });\n  } else {\n    return createReactiveObject<T>(objOrSchema as T, meta);\n  }\n};\n\nconst createReactiveObject = <T extends BaseObject>(\n  obj: T,\n  meta?: ObjectMeta,\n  schema?: Schema.Schema<T>,\n  options?: { expando?: boolean },\n): Live<T> => {\n  if (!isValidProxyTarget(obj)) {\n    throw new Error('Value cannot be made into a reactive object.');\n  }\n\n  if (schema) {\n    const annotation = getTypeAnnotation(schema);\n    const shouldGenerateId = options?.expando || !!annotation;\n    if (shouldGenerateId) {\n      setIdOnTarget(obj);\n    }\n    if (annotation) {\n      defineHiddenProperty(obj, EntityKindId, annotation.kind);\n    }\n    initMeta(obj, meta);\n    prepareTypedTarget(obj, schema);\n    return createProxy<T>(obj, TypedReactiveHandler.instance);\n  } else {\n    if (options?.expando) {\n      setIdOnTarget(obj);\n    }\n    initMeta(obj, meta);\n    return createProxy<T>(obj, UntypedReactiveHandler.instance);\n  }\n};\n\n/**\n * Set ID on ECHO object targets during creation.\n * Used for objects with schema and the ones explicitly marked as Expando.\n */\nconst setIdOnTarget = (target: any) => {\n  // invariant(!('id' in target), 'Object already has an `id` field, which is reserved.');\n  if ('id' in target) {\n    if (!ObjectId.isValid(target.id)) {\n      throw new Error('Invalid object id format.');\n    }\n  } else {\n    target.id = ObjectId.random();\n  }\n};\n\n/**\n * Set metadata on object.\n */\n// TODO(dmaretskyi): Move to echo-schema.\nconst initMeta = <T>(obj: T, meta: ObjectMeta = { keys: [] }) => {\n  prepareTypedTarget(meta, ObjectMetaSchema);\n  defineHiddenProperty(obj, MetaId, createProxy(meta, TypedReactiveHandler.instance as any));\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { SchemaAST, Schema } from 'effect';\nimport { type InspectOptionsStylized } from 'node:util';\n\nimport { inspectCustom } from '@dxos/debug';\nimport { defineHiddenProperty, DeletedId, getSchemaDXN, SchemaId, SchemaValidator, TypeId } from '@dxos/echo-schema';\nimport { compositeRuntime, type GenericSignal } from '@dxos/echo-signals/runtime';\nimport { invariant } from '@dxos/invariant';\n\nimport {\n  createProxy,\n  isValidProxyTarget,\n  objectData,\n  ReactiveArray,\n  type ReactiveHandler,\n  symbolIsProxy,\n} from './proxy';\n\nconst symbolSignal = Symbol('signal');\nconst symbolPropertySignal = Symbol('property-signal');\n\ntype ProxyTarget = {\n  /**\n   * Typename or type DXN.\n   */\n  [TypeId]: string;\n\n  /**\n   * Schema for the root.\n   */\n  [SchemaId]: Schema.Schema.AnyNoContext;\n\n  /**\n   * For get and set operations on value properties.\n   */\n  // TODO(dmaretskyi): Turn into a map of signals per-field.\n  [symbolSignal]: GenericSignal;\n\n  /**\n   * For modifying the structure of the object.\n   */\n  [symbolPropertySignal]: GenericSignal;\n} & ({ [key: keyof any]: any } | any[]);\n\n/**\n * Typed in-memory reactive store (with Schema).\n */\nexport class TypedReactiveHandler implements ReactiveHandler<ProxyTarget> {\n  public static readonly instance: ReactiveHandler<any> = new TypedReactiveHandler();\n\n  readonly _proxyMap = new WeakMap<object, any>();\n\n  private constructor() {}\n\n  init(target: ProxyTarget): void {\n    invariant(typeof target === 'object' && target !== null);\n    invariant(SchemaId in target, 'Schema is not defined for the target');\n\n    if (!(symbolSignal in target)) {\n      defineHiddenProperty(target, symbolSignal, compositeRuntime.createSignal());\n      defineHiddenProperty(target, symbolPropertySignal, compositeRuntime.createSignal());\n    }\n\n    defineHiddenProperty(target, DeletedId, false);\n\n    for (const key of Object.getOwnPropertyNames(target)) {\n      const descriptor = Object.getOwnPropertyDescriptor(target, key)!;\n      if (descriptor.get) {\n        // Ignore getters.\n        continue;\n      }\n\n      // Array reactivity is already handled by the schema validator.\n    }\n\n    // Maybe have been set by `create`.\n    Object.defineProperty(target, inspectCustom, {\n      enumerable: false,\n      configurable: true,\n      value: this._inspect.bind(target),\n    });\n  }\n\n  get(target: ProxyTarget, prop: string | symbol, receiver: any): any {\n    switch (prop) {\n      case objectData: {\n        target[symbolSignal].notifyRead();\n        return toJSON(target);\n      }\n    }\n\n    // Handle getter properties. Will not subscribe the value signal.\n    if (Object.getOwnPropertyDescriptor(target, prop)?.get) {\n      target[symbolPropertySignal].notifyRead();\n\n      // TODO(dmaretskyi): Turn getters into computed fields.\n      return Reflect.get(target, prop, receiver);\n    }\n\n    target[symbolSignal].notifyRead();\n    target[symbolPropertySignal].notifyRead();\n\n    const value = Reflect.get(target, prop, receiver);\n    if (isValidProxyTarget(value)) {\n      return createProxy(value, this);\n    }\n\n    return value;\n  }\n\n  set(target: ProxyTarget, prop: string | symbol, value: any, receiver: any): boolean {\n    // Convert arrays to reactive arrays on write.\n    if (Array.isArray(value)) {\n      value = ReactiveArray.from(value);\n    }\n\n    let result: boolean = false;\n    compositeRuntime.batch(() => {\n      const validatedValue = this._validateValue(target, prop, value);\n      result = Reflect.set(target, prop, validatedValue, receiver);\n      target[symbolSignal].notifyWrite();\n    });\n    return result;\n  }\n\n  ownKeys(target: ProxyTarget): ArrayLike<string | symbol> {\n    // Touch both signals since `set` and `delete` operations may create or remove properties.\n    target[symbolSignal].notifyRead();\n    target[symbolPropertySignal].notifyRead();\n    return Reflect.ownKeys(target);\n  }\n\n  defineProperty(target: ProxyTarget, property: string | symbol, attributes: PropertyDescriptor): boolean {\n    const validatedValue = this._validateValue(target, property, attributes.value);\n    const result = Reflect.defineProperty(target, property, {\n      ...attributes,\n      value: validatedValue,\n    });\n    target[symbolPropertySignal].notifyWrite();\n    return result;\n  }\n\n  private _validateValue(target: any, prop: string | symbol, value: any) {\n    const schema = SchemaValidator.getTargetPropertySchema(target, prop);\n    const _ = Schema.asserts(schema)(value);\n    if (Array.isArray(value)) {\n      value = new ReactiveArray(...value);\n    }\n    if (isValidProxyTarget(value)) {\n      setSchemaProperties(value, schema);\n    }\n\n    return value;\n  }\n\n  private _inspect(\n    _: number,\n    options: InspectOptionsStylized,\n    inspectFn: (value: any, options?: InspectOptionsStylized) => string,\n  ): string {\n    return `Typed ${inspectFn(this, {\n      ...options,\n      compact: true,\n      showHidden: false,\n      customInspect: false,\n    })}`;\n  }\n}\n\nconst toJSON = (target: ProxyTarget): any => {\n  return { '@type': 'TypedReactiveObject', ...target };\n};\n\n/**\n * Recursively set AST on all potential proxy targets.\n */\nconst setSchemaProperties = (obj: any, schema: Schema.Schema.AnyNoContext) => {\n  const schemaType = getSchemaDXN(schema);\n  if (schemaType != null) {\n    defineHiddenProperty(obj, TypeId, schemaType);\n  }\n\n  defineHiddenProperty(obj, SchemaId, schema);\n  for (const key in obj) {\n    if (isValidProxyTarget(obj[key])) {\n      const elementSchema = SchemaValidator.getTargetPropertySchema(obj, key);\n      if (elementSchema != null) {\n        setSchemaProperties(obj[key], elementSchema);\n      }\n    }\n  }\n};\n\nexport const prepareTypedTarget = <T>(target: T, schema: Schema.Schema<T>) => {\n  // log.info('prepareTypedTarget', { target, schema });\n  if (!SchemaAST.isTypeLiteral(schema.ast)) {\n    throw new Error('schema has to describe an object type');\n  }\n\n  SchemaValidator.validateSchema(schema);\n  const _ = Schema.asserts(schema)(target);\n  makeArraysReactive(target);\n  setSchemaProperties(target, schema);\n};\n\nconst makeArraysReactive = (target: any) => {\n  for (const key in target) {\n    if (target[symbolIsProxy]) {\n      continue;\n    }\n    if (Array.isArray(target[key])) {\n      target[key] = ReactiveArray.from(target[key]);\n    }\n    if (typeof target[key] === 'object') {\n      makeArraysReactive(target[key]);\n    }\n  }\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { defineHiddenProperty, DeletedId, getTypename, TypeId } from '@dxos/echo-schema';\nimport { compositeRuntime, type GenericSignal } from '@dxos/echo-signals/runtime';\nimport { invariant } from '@dxos/invariant';\n\nimport { createProxy, isValidProxyTarget, objectData, ReactiveArray, type ReactiveHandler } from './proxy';\nimport { TypedReactiveHandler } from './typed-handler';\n\nconst symbolSignal = Symbol('signal');\nconst symbolPropertySignal = Symbol('property-signal');\n\ntype ProxyTarget = {\n  /**\n   * For get and set operations on value properties.\n   */\n  // TODO(dmaretskyi): Turn into a map of signals per-field.\n  [symbolSignal]: GenericSignal;\n\n  /**\n   * For modifying the structure of the object.\n   * This is a separate signal so that getter properties are supported.\n   */\n  [symbolPropertySignal]: GenericSignal;\n} & ({ [key: keyof any]: any } | any[]);\n\n/**\n * Untyped in-memory reactive store.\n * Target can be an array or object with any type of values including other reactive proxies.\n */\nexport class UntypedReactiveHandler implements ReactiveHandler<ProxyTarget> {\n  public static readonly instance: ReactiveHandler<any> = new UntypedReactiveHandler();\n\n  // TODO(dmaretskyi): Does this work? Should this be a global variable instead?\n  readonly _proxyMap = new WeakMap<object, any>();\n\n  private constructor() {}\n\n  init(target: ProxyTarget): void {\n    invariant(typeof target === 'object' && target !== null);\n\n    if (!(symbolSignal in target)) {\n      defineHiddenProperty(target, symbolSignal, compositeRuntime.createSignal());\n      defineHiddenProperty(target, symbolPropertySignal, compositeRuntime.createSignal());\n    }\n\n    defineHiddenProperty(target, DeletedId, false);\n\n    for (const key of Object.getOwnPropertyNames(target)) {\n      const descriptor = Object.getOwnPropertyDescriptor(target, key)!;\n      if (descriptor.get) {\n        // Ignore getters.\n        continue;\n      }\n\n      if (Array.isArray(target[key as any]) && !(target[key as any] instanceof ReactiveArray)) {\n        target[key as any] = ReactiveArray.from(target[key as any]);\n      }\n    }\n  }\n\n  get(target: ProxyTarget, prop: string | symbol, receiver: any): any {\n    // Handle getter properties. Will not subscribe the value signal.\n    if (Object.getOwnPropertyDescriptor(target, prop)?.get) {\n      target[symbolPropertySignal].notifyRead();\n\n      // TODO(dmaretskyi): Turn getters into computed fields.\n      return Reflect.get(target, prop, receiver);\n    }\n\n    target[symbolSignal].notifyRead();\n    target[symbolPropertySignal].notifyRead();\n\n    if (prop === objectData) {\n      return toJSON(target);\n    }\n\n    if (prop === TypeId) {\n      return undefined;\n    }\n\n    const value = Reflect.get(target, prop);\n\n    if (isValidProxyTarget(value)) {\n      const isTyped = getTypename(value) !== undefined;\n      if (isTyped) {\n        return createProxy(value, TypedReactiveHandler.instance);\n      } else {\n        // Note: Need to pass in `this` instance to createProxy to ensure that the same proxy is used for target.\n        // TODO(dmaretskyi): Not sure this note is relevant anymore since proxy handlers are singletons.\n        return createProxy(value, this);\n      }\n    }\n\n    return value;\n  }\n\n  set(target: ProxyTarget, prop: string | symbol, value: any, receiver: any): boolean {\n    // Convert arrays to reactive arrays on write.\n    if (Array.isArray(value)) {\n      value = ReactiveArray.from(value);\n    }\n\n    const result = Reflect.set(target, prop, value);\n    target[symbolSignal].notifyWrite();\n    return result;\n  }\n\n  ownKeys(target: ProxyTarget): ArrayLike<string | symbol> {\n    // Touch both signals since `set` and `delete` operations may create or remove properties.\n    target[symbolSignal].notifyRead();\n    target[symbolPropertySignal].notifyRead();\n    return Reflect.ownKeys(target);\n  }\n\n  defineProperty(target: ProxyTarget, property: string | symbol, attributes: PropertyDescriptor): boolean {\n    const result = Reflect.defineProperty(target, property, attributes);\n    target[symbolPropertySignal].notifyWrite();\n    return result;\n  }\n}\n\nconst toJSON = (target: any): any => {\n  // TODO(dmaretskyi): Why '@type' is ReactiveObject?\n  return { '@type': 'ReactiveObject', ...target };\n};\n"],
  "mappings": "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",
  "names": ["compositeRuntime", "ReactiveArray", "Array", "Symbol", "species", "BATCHED_METHODS", "method", "Object", "defineProperty", "prototype", "enumerable", "value", "args", "result", "compositeRuntime", "batch", "apply", "invariant", "symbolIsProxy", "Symbol", "for", "isProxy", "value", "isValidProxyTarget", "ReactiveArray", "Object", "getPrototypeOf", "prototype", "getProxySlot", "proxy", "invariant", "ProxyHandlerSlot", "getProxyTarget", "target", "getProxyHandler", "handler", "dangerouslySetProxyId", "obj", "id", "createProxy", "existingProxy", "_proxyMap", "get", "Proxy", "init", "set", "_handler", "setHandler", "prop", "receiver", "Reflect", "TRAPS", "trap", "defineProperty", "enumerable", "args", "apply", "objectData", "Symbol", "for", "ObjectId", "defineHiddenProperty", "getTypeAnnotation", "Expando", "ObjectMetaSchema", "EntityKindId", "MetaId", "SchemaAST", "Schema", "inspectCustom", "defineHiddenProperty", "DeletedId", "getSchemaDXN", "SchemaId", "SchemaValidator", "TypeId", "compositeRuntime", "invariant", "symbolSignal", "Symbol", "symbolPropertySignal", "TypedReactiveHandler", "_proxyMap", "WeakMap", "instance", "init", "target", "invariant", "SchemaId", "defineHiddenProperty", "compositeRuntime", "createSignal", "DeletedId", "key", "Object", "getOwnPropertyNames", "descriptor", "getOwnPropertyDescriptor", "get", "defineProperty", "inspectCustom", "enumerable", "configurable", "value", "_inspect", "bind", "prop", "receiver", "objectData", "notifyRead", "toJSON", "Reflect", "isValidProxyTarget", "createProxy", "set", "Array", "isArray", "ReactiveArray", "from", "result", "batch", "validatedValue", "_validateValue", "notifyWrite", "ownKeys", "property", "attributes", "schema", "SchemaValidator", "getTargetPropertySchema", "_", "Schema", "asserts", "setSchemaProperties", "options", "inspectFn", "compact", "showHidden", "customInspect", "obj", "schemaType", "getSchemaDXN", "TypeId", "elementSchema", "prepareTypedTarget", "SchemaAST", "isTypeLiteral", "ast", "Error", "validateSchema", "makeArraysReactive", "symbolIsProxy", "defineHiddenProperty", "DeletedId", "getTypename", "TypeId", "compositeRuntime", "invariant", "symbolSignal", "Symbol", "symbolPropertySignal", "UntypedReactiveHandler", "_proxyMap", "WeakMap", "instance", "init", "target", "invariant", "defineHiddenProperty", "compositeRuntime", "createSignal", "DeletedId", "key", "Object", "getOwnPropertyNames", "descriptor", "getOwnPropertyDescriptor", "get", "Array", "isArray", "ReactiveArray", "from", "prop", "receiver", "notifyRead", "Reflect", "objectData", "toJSON", "TypeId", "undefined", "value", "isValidProxyTarget", "isTyped", "getTypename", "createProxy", "TypedReactiveHandler", "set", "result", "notifyWrite", "ownKeys", "defineProperty", "property", "attributes", "live", "objOrSchema", "obj", "meta", "Expando", "createReactiveObject", "undefined", "expando", "schema", "options", "isValidProxyTarget", "Error", "annotation", "getTypeAnnotation", "shouldGenerateId", "setIdOnTarget", "defineHiddenProperty", "EntityKindId", "kind", "initMeta", "prepareTypedTarget", "createProxy", "TypedReactiveHandler", "instance", "UntypedReactiveHandler", "target", "ObjectId", "isValid", "id", "random", "keys", "ObjectMetaSchema", "MetaId"]
}
