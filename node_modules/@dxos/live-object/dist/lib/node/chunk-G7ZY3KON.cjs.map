{
  "version": 3,
  "sources": ["../../../src/proxy/array.ts", "../../../src/proxy/proxy.ts", "../../../src/proxy/types.ts", "../../../src/object.ts", "../../../src/typed-handler.ts", "../../../src/untyped-handler.ts"],
  "sourcesContent": ["//\n// Copyright 2024 DXOS.org\n//\n\nimport { compositeRuntime } from '@dxos/echo-signals/runtime';\n\n/**\n * Extends the native array to make sure that arrays methods are correctly reactive.\n */\nexport class ReactiveArray<T> extends Array<T> {\n  static override get [Symbol.species]() {\n    return Array;\n  }\n\n  static {\n    /**\n     * These methods will trigger proxy traps like `set` and `defineProperty` and emit signal notifications.\n     * We wrap them in a batch to avoid unnecessary signal notifications.\n     */\n    const BATCHED_METHODS = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'] as const;\n\n    for (const method of BATCHED_METHODS) {\n      Object.defineProperty(this.prototype, method, {\n        enumerable: false,\n        value: function (this: ReactiveArray<any>, ...args: any[]) {\n          let result!: any;\n          compositeRuntime.batch(() => {\n            result = Array.prototype[method].apply(this, args);\n          });\n          return result;\n        },\n      });\n    }\n  }\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { type BaseObject } from '@dxos/echo-schema';\nimport { invariant } from '@dxos/invariant';\n\nimport { ReactiveArray } from './array';\nimport { type ReactiveHandler } from './types';\nimport type { Live } from '../live';\n\nexport const symbolIsProxy = Symbol.for('@dxos/schema/Proxy');\n\n/**\n * Internal api.\n */\nexport const isProxy = (value: unknown) => !!(value as any)?.[symbolIsProxy];\n\nexport const isValidProxyTarget = (value: any): value is object => {\n  if (value == null || value[symbolIsProxy]) {\n    return false;\n  }\n  if (value instanceof ReactiveArray) {\n    return true;\n  }\n\n  return typeof value === 'object' && Object.getPrototypeOf(value) === Object.prototype;\n};\n\n/**\n * @deprecated\n */\nexport const getProxySlot = <T extends BaseObject>(proxy: Live<any>): ProxyHandlerSlot<T> => {\n  const value = (proxy as any)[symbolIsProxy];\n  invariant(value instanceof ProxyHandlerSlot);\n  return value;\n};\n\nexport const getProxyTarget = <T extends BaseObject>(proxy: Live<any>): T => {\n  return getProxySlot<T>(proxy).target;\n};\n\nexport const getProxyHandler = <T extends BaseObject>(proxy: Live<any>): ReactiveHandler<T> => {\n  return getProxySlot<T>(proxy).handler;\n};\n\n/**\n * Unsafe method to override id for debugging/testing and migration purposes.\n * @deprecated\n */\nexport const dangerouslySetProxyId = <T extends BaseObject>(obj: Live<T>, id: string) => {\n  (getProxySlot(obj).target as any).id = id;\n};\n\n/**\n * Create a reactive proxy object.\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy\n *\n * @param target Object or array. Passing in array will enable array methods.\n * @param handler ReactiveHandler instance.\n */\n// TODO(burdon): Document.\n// TODO(burdon): Tests for low-level functions.\nexport const createProxy = <T extends BaseObject>(target: T, handler: ReactiveHandler<T>): Live<T> => {\n  const existingProxy = handler._proxyMap.get(target);\n  if (existingProxy) {\n    return existingProxy;\n  }\n\n  // TODO(dmaretskyi): In the future this should be mutable to allow replacing the handler on-the-fly while maintaining the proxy identity.\n  const proxy = new Proxy(target, new ProxyHandlerSlot<T>(target, handler));\n  handler.init(target);\n\n  // TODO(dmaretskyi): Check if this will actually work; maybe a global WeakMap is better?\n  handler._proxyMap.set(target, proxy);\n  return proxy;\n};\n\n/**\n * Passed as the handler to the Proxy constructor.\n * Maintains a mutable slot for the actual handler.\n */\nclass ProxyHandlerSlot<T extends BaseObject> implements ProxyHandler<T> {\n  /**\n   * @param target Original object.\n   * @param _handler Handles intercepted operations.\n   */\n  constructor(\n    readonly target: T,\n    private _handler: ReactiveHandler<T>,\n  ) {}\n\n  get handler() {\n    invariant(this._handler);\n    return this._handler;\n  }\n\n  // TODO(burdon): Requires comment.\n  setHandler(handler: ReactiveHandler<T>): void {\n    this._handler = handler;\n  }\n\n  /**\n   * Get value.\n   */\n  get(target: T, prop: string | symbol, receiver: any): any {\n    if (prop === symbolIsProxy) {\n      return this;\n    }\n\n    if (!this._handler || !this._handler.get) {\n      return Reflect.get(target, prop, receiver);\n    }\n\n    return this._handler.get(target, prop, receiver);\n  }\n\n  static {\n    const TRAPS: (keyof ProxyHandler<any>)[] = [\n      'apply',\n      'construct',\n      'defineProperty',\n      'deleteProperty',\n      'get',\n      'getOwnPropertyDescriptor',\n      'getPrototypeOf',\n      'has',\n      'isExtensible',\n      'ownKeys',\n      'preventExtensions',\n      'set',\n      'setPrototypeOf',\n    ];\n\n    for (const trap of TRAPS) {\n      if (trap === 'get') {\n        continue;\n      }\n\n      Object.defineProperty(this.prototype, trap, {\n        enumerable: false,\n        value: function (this: ProxyHandlerSlot<any>, ...args: any[]) {\n          // log.info('trap', { trap, args });\n          if (!this._handler || !this._handler[trap]) {\n            return (Reflect[trap] as Function)(...args);\n          }\n\n          return (this._handler[trap] as Function).apply(this._handler, args);\n        },\n      });\n    }\n  }\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { type BaseObject } from '@dxos/echo-schema';\n\n/**\n * Reactive object proxy.\n */\nexport interface ReactiveHandler<T extends BaseObject> extends ProxyHandler<T> {\n  /**\n   * Target to Proxy mapping.\n   */\n  readonly _proxyMap: WeakMap<object, any>;\n\n  /**\n   * Called when a proxy is created for this target.\n   */\n  init(target: T): void;\n}\n\n/**\n * For debug-dumping the data of the object.\n */\nexport const objectData = Symbol.for('@dxos/live-object/objectData');\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { type Schema } from 'effect';\n\nimport {\n  ObjectId,\n  defineHiddenProperty,\n  getTypeAnnotation,\n  type BaseObject,\n  Expando,\n  type ObjectMeta,\n  ObjectMetaSchema,\n  EntityKindId,\n  type CreationProps,\n} from '@dxos/echo-schema';\nimport { MetaId } from '@dxos/echo-schema';\n\nimport type { Live } from './live';\nimport { createProxy, isValidProxyTarget } from './proxy';\nimport { prepareTypedTarget, TypedReactiveHandler } from './typed-handler';\nimport { UntypedReactiveHandler } from './untyped-handler';\n\n/**\n * Creates a reactive object from a plain Javascript object.\n * Optionally provides a TS-effect schema.\n */\n// TODO(dmaretskyi): Deep mutability.\n// TODO(dmaretskyi): Invert generics (generic over schema) to have better error messages.\n// TODO(dmaretskyi): Could mutate original object making it unusable.\n// TODO(burdon): Use Schema.make() to handle defaults?\nexport const live: {\n  <T extends BaseObject>(obj: T): Live<T>;\n  <T extends BaseObject>(\n    schema: Schema.Schema<T, any, never>,\n    obj: NoInfer<CreationProps<T>>,\n    meta?: ObjectMeta,\n  ): Live<T>;\n} = <T extends BaseObject>(\n  objOrSchema: Schema.Schema<T, any> | T,\n  obj?: CreationProps<T>,\n  meta?: ObjectMeta,\n): Live<T> => {\n  // TODO(dmaretskyi): Remove Expando special case.\n  if (obj && (objOrSchema as any) !== Expando) {\n    return createReactiveObject<T>({ ...obj } as T, meta, objOrSchema as Schema.Schema<T, any>);\n  } else if (obj && (objOrSchema as any) === Expando) {\n    return createReactiveObject<T>({ ...obj } as T, meta, undefined, { expando: true });\n  } else {\n    return createReactiveObject<T>(objOrSchema as T, meta);\n  }\n};\n\nconst createReactiveObject = <T extends BaseObject>(\n  obj: T,\n  meta?: ObjectMeta,\n  schema?: Schema.Schema<T>,\n  options?: { expando?: boolean },\n): Live<T> => {\n  if (!isValidProxyTarget(obj)) {\n    throw new Error('Value cannot be made into a reactive object.');\n  }\n\n  if (schema) {\n    const annotation = getTypeAnnotation(schema);\n    const shouldGenerateId = options?.expando || !!annotation;\n    if (shouldGenerateId) {\n      setIdOnTarget(obj);\n    }\n    if (annotation) {\n      defineHiddenProperty(obj, EntityKindId, annotation.kind);\n    }\n    initMeta(obj, meta);\n    prepareTypedTarget(obj, schema);\n    return createProxy<T>(obj, TypedReactiveHandler.instance);\n  } else {\n    if (options?.expando) {\n      setIdOnTarget(obj);\n    }\n    initMeta(obj, meta);\n    return createProxy<T>(obj, UntypedReactiveHandler.instance);\n  }\n};\n\n/**\n * Set ID on ECHO object targets during creation.\n * Used for objects with schema and the ones explicitly marked as Expando.\n */\nconst setIdOnTarget = (target: any) => {\n  // invariant(!('id' in target), 'Object already has an `id` field, which is reserved.');\n  if ('id' in target) {\n    if (!ObjectId.isValid(target.id)) {\n      throw new Error('Invalid object id format.');\n    }\n  } else {\n    target.id = ObjectId.random();\n  }\n};\n\n/**\n * Set metadata on object.\n */\n// TODO(dmaretskyi): Move to echo-schema.\nconst initMeta = <T>(obj: T, meta: ObjectMeta = { keys: [] }) => {\n  prepareTypedTarget(meta, ObjectMetaSchema);\n  defineHiddenProperty(obj, MetaId, createProxy(meta, TypedReactiveHandler.instance as any));\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { SchemaAST, Schema } from 'effect';\nimport { type InspectOptionsStylized } from 'node:util';\n\nimport { inspectCustom } from '@dxos/debug';\nimport { defineHiddenProperty, DeletedId, getSchemaDXN, SchemaId, SchemaValidator, TypeId } from '@dxos/echo-schema';\nimport { compositeRuntime, type GenericSignal } from '@dxos/echo-signals/runtime';\nimport { invariant } from '@dxos/invariant';\n\nimport {\n  createProxy,\n  isValidProxyTarget,\n  objectData,\n  ReactiveArray,\n  type ReactiveHandler,\n  symbolIsProxy,\n} from './proxy';\n\nconst symbolSignal = Symbol('signal');\nconst symbolPropertySignal = Symbol('property-signal');\n\ntype ProxyTarget = {\n  /**\n   * Typename or type DXN.\n   */\n  [TypeId]: string;\n\n  /**\n   * Schema for the root.\n   */\n  [SchemaId]: Schema.Schema.AnyNoContext;\n\n  /**\n   * For get and set operations on value properties.\n   */\n  // TODO(dmaretskyi): Turn into a map of signals per-field.\n  [symbolSignal]: GenericSignal;\n\n  /**\n   * For modifying the structure of the object.\n   */\n  [symbolPropertySignal]: GenericSignal;\n} & ({ [key: keyof any]: any } | any[]);\n\n/**\n * Typed in-memory reactive store (with Schema).\n */\nexport class TypedReactiveHandler implements ReactiveHandler<ProxyTarget> {\n  public static readonly instance: ReactiveHandler<any> = new TypedReactiveHandler();\n\n  readonly _proxyMap = new WeakMap<object, any>();\n\n  private constructor() {}\n\n  init(target: ProxyTarget): void {\n    invariant(typeof target === 'object' && target !== null);\n    invariant(SchemaId in target, 'Schema is not defined for the target');\n\n    if (!(symbolSignal in target)) {\n      defineHiddenProperty(target, symbolSignal, compositeRuntime.createSignal());\n      defineHiddenProperty(target, symbolPropertySignal, compositeRuntime.createSignal());\n    }\n\n    defineHiddenProperty(target, DeletedId, false);\n\n    for (const key of Object.getOwnPropertyNames(target)) {\n      const descriptor = Object.getOwnPropertyDescriptor(target, key)!;\n      if (descriptor.get) {\n        // Ignore getters.\n        continue;\n      }\n\n      // Array reactivity is already handled by the schema validator.\n    }\n\n    // Maybe have been set by `create`.\n    Object.defineProperty(target, inspectCustom, {\n      enumerable: false,\n      configurable: true,\n      value: this._inspect.bind(target),\n    });\n  }\n\n  get(target: ProxyTarget, prop: string | symbol, receiver: any): any {\n    switch (prop) {\n      case objectData: {\n        target[symbolSignal].notifyRead();\n        return toJSON(target);\n      }\n    }\n\n    // Handle getter properties. Will not subscribe the value signal.\n    if (Object.getOwnPropertyDescriptor(target, prop)?.get) {\n      target[symbolPropertySignal].notifyRead();\n\n      // TODO(dmaretskyi): Turn getters into computed fields.\n      return Reflect.get(target, prop, receiver);\n    }\n\n    target[symbolSignal].notifyRead();\n    target[symbolPropertySignal].notifyRead();\n\n    const value = Reflect.get(target, prop, receiver);\n    if (isValidProxyTarget(value)) {\n      return createProxy(value, this);\n    }\n\n    return value;\n  }\n\n  set(target: ProxyTarget, prop: string | symbol, value: any, receiver: any): boolean {\n    // Convert arrays to reactive arrays on write.\n    if (Array.isArray(value)) {\n      value = ReactiveArray.from(value);\n    }\n\n    let result: boolean = false;\n    compositeRuntime.batch(() => {\n      const validatedValue = this._validateValue(target, prop, value);\n      result = Reflect.set(target, prop, validatedValue, receiver);\n      target[symbolSignal].notifyWrite();\n    });\n    return result;\n  }\n\n  ownKeys(target: ProxyTarget): ArrayLike<string | symbol> {\n    // Touch both signals since `set` and `delete` operations may create or remove properties.\n    target[symbolSignal].notifyRead();\n    target[symbolPropertySignal].notifyRead();\n    return Reflect.ownKeys(target);\n  }\n\n  defineProperty(target: ProxyTarget, property: string | symbol, attributes: PropertyDescriptor): boolean {\n    const validatedValue = this._validateValue(target, property, attributes.value);\n    const result = Reflect.defineProperty(target, property, {\n      ...attributes,\n      value: validatedValue,\n    });\n    target[symbolPropertySignal].notifyWrite();\n    return result;\n  }\n\n  private _validateValue(target: any, prop: string | symbol, value: any) {\n    const schema = SchemaValidator.getTargetPropertySchema(target, prop);\n    const _ = Schema.asserts(schema)(value);\n    if (Array.isArray(value)) {\n      value = new ReactiveArray(...value);\n    }\n    if (isValidProxyTarget(value)) {\n      setSchemaProperties(value, schema);\n    }\n\n    return value;\n  }\n\n  private _inspect(\n    _: number,\n    options: InspectOptionsStylized,\n    inspectFn: (value: any, options?: InspectOptionsStylized) => string,\n  ): string {\n    return `Typed ${inspectFn(this, {\n      ...options,\n      compact: true,\n      showHidden: false,\n      customInspect: false,\n    })}`;\n  }\n}\n\nconst toJSON = (target: ProxyTarget): any => {\n  return { '@type': 'TypedReactiveObject', ...target };\n};\n\n/**\n * Recursively set AST on all potential proxy targets.\n */\nconst setSchemaProperties = (obj: any, schema: Schema.Schema.AnyNoContext) => {\n  const schemaType = getSchemaDXN(schema);\n  if (schemaType != null) {\n    defineHiddenProperty(obj, TypeId, schemaType);\n  }\n\n  defineHiddenProperty(obj, SchemaId, schema);\n  for (const key in obj) {\n    if (isValidProxyTarget(obj[key])) {\n      const elementSchema = SchemaValidator.getTargetPropertySchema(obj, key);\n      if (elementSchema != null) {\n        setSchemaProperties(obj[key], elementSchema);\n      }\n    }\n  }\n};\n\nexport const prepareTypedTarget = <T>(target: T, schema: Schema.Schema<T>) => {\n  // log.info('prepareTypedTarget', { target, schema });\n  if (!SchemaAST.isTypeLiteral(schema.ast)) {\n    throw new Error('schema has to describe an object type');\n  }\n\n  SchemaValidator.validateSchema(schema);\n  const _ = Schema.asserts(schema)(target);\n  makeArraysReactive(target);\n  setSchemaProperties(target, schema);\n};\n\nconst makeArraysReactive = (target: any) => {\n  for (const key in target) {\n    if (target[symbolIsProxy]) {\n      continue;\n    }\n    if (Array.isArray(target[key])) {\n      target[key] = ReactiveArray.from(target[key]);\n    }\n    if (typeof target[key] === 'object') {\n      makeArraysReactive(target[key]);\n    }\n  }\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { defineHiddenProperty, DeletedId, getTypename, TypeId } from '@dxos/echo-schema';\nimport { compositeRuntime, type GenericSignal } from '@dxos/echo-signals/runtime';\nimport { invariant } from '@dxos/invariant';\n\nimport { createProxy, isValidProxyTarget, objectData, ReactiveArray, type ReactiveHandler } from './proxy';\nimport { TypedReactiveHandler } from './typed-handler';\n\nconst symbolSignal = Symbol('signal');\nconst symbolPropertySignal = Symbol('property-signal');\n\ntype ProxyTarget = {\n  /**\n   * For get and set operations on value properties.\n   */\n  // TODO(dmaretskyi): Turn into a map of signals per-field.\n  [symbolSignal]: GenericSignal;\n\n  /**\n   * For modifying the structure of the object.\n   * This is a separate signal so that getter properties are supported.\n   */\n  [symbolPropertySignal]: GenericSignal;\n} & ({ [key: keyof any]: any } | any[]);\n\n/**\n * Untyped in-memory reactive store.\n * Target can be an array or object with any type of values including other reactive proxies.\n */\nexport class UntypedReactiveHandler implements ReactiveHandler<ProxyTarget> {\n  public static readonly instance: ReactiveHandler<any> = new UntypedReactiveHandler();\n\n  // TODO(dmaretskyi): Does this work? Should this be a global variable instead?\n  readonly _proxyMap = new WeakMap<object, any>();\n\n  private constructor() {}\n\n  init(target: ProxyTarget): void {\n    invariant(typeof target === 'object' && target !== null);\n\n    if (!(symbolSignal in target)) {\n      defineHiddenProperty(target, symbolSignal, compositeRuntime.createSignal());\n      defineHiddenProperty(target, symbolPropertySignal, compositeRuntime.createSignal());\n    }\n\n    defineHiddenProperty(target, DeletedId, false);\n\n    for (const key of Object.getOwnPropertyNames(target)) {\n      const descriptor = Object.getOwnPropertyDescriptor(target, key)!;\n      if (descriptor.get) {\n        // Ignore getters.\n        continue;\n      }\n\n      if (Array.isArray(target[key as any]) && !(target[key as any] instanceof ReactiveArray)) {\n        target[key as any] = ReactiveArray.from(target[key as any]);\n      }\n    }\n  }\n\n  get(target: ProxyTarget, prop: string | symbol, receiver: any): any {\n    // Handle getter properties. Will not subscribe the value signal.\n    if (Object.getOwnPropertyDescriptor(target, prop)?.get) {\n      target[symbolPropertySignal].notifyRead();\n\n      // TODO(dmaretskyi): Turn getters into computed fields.\n      return Reflect.get(target, prop, receiver);\n    }\n\n    target[symbolSignal].notifyRead();\n    target[symbolPropertySignal].notifyRead();\n\n    if (prop === objectData) {\n      return toJSON(target);\n    }\n\n    if (prop === TypeId) {\n      return undefined;\n    }\n\n    const value = Reflect.get(target, prop);\n\n    if (isValidProxyTarget(value)) {\n      const isTyped = getTypename(value) !== undefined;\n      if (isTyped) {\n        return createProxy(value, TypedReactiveHandler.instance);\n      } else {\n        // Note: Need to pass in `this` instance to createProxy to ensure that the same proxy is used for target.\n        // TODO(dmaretskyi): Not sure this note is relevant anymore since proxy handlers are singletons.\n        return createProxy(value, this);\n      }\n    }\n\n    return value;\n  }\n\n  set(target: ProxyTarget, prop: string | symbol, value: any, receiver: any): boolean {\n    // Convert arrays to reactive arrays on write.\n    if (Array.isArray(value)) {\n      value = ReactiveArray.from(value);\n    }\n\n    const result = Reflect.set(target, prop, value);\n    target[symbolSignal].notifyWrite();\n    return result;\n  }\n\n  ownKeys(target: ProxyTarget): ArrayLike<string | symbol> {\n    // Touch both signals since `set` and `delete` operations may create or remove properties.\n    target[symbolSignal].notifyRead();\n    target[symbolPropertySignal].notifyRead();\n    return Reflect.ownKeys(target);\n  }\n\n  defineProperty(target: ProxyTarget, property: string | symbol, attributes: PropertyDescriptor): boolean {\n    const result = Reflect.defineProperty(target, property, attributes);\n    target[symbolPropertySignal].notifyWrite();\n    return result;\n  }\n}\n\nconst toJSON = (target: any): any => {\n  // TODO(dmaretskyi): Why '@type' is ReactiveObject?\n  return { '@type': 'ReactiveObject', ...target };\n};\n"],
  "mappings": "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",
  "names": ["import_echo_schema", "import_runtime", "import_invariant", "ReactiveArray", "Array", "Symbol", "species", "BATCHED_METHODS", "method", "Object", "defineProperty", "prototype", "enumerable", "value", "args", "result", "compositeRuntime", "batch", "apply", "symbolIsProxy", "for", "isProxy", "isValidProxyTarget", "getPrototypeOf", "getProxySlot", "proxy", "invariant", "ProxyHandlerSlot", "getProxyTarget", "target", "getProxyHandler", "handler", "dangerouslySetProxyId", "obj", "id", "createProxy", "existingProxy", "_proxyMap", "get", "Proxy", "init", "set", "_handler", "setHandler", "prop", "receiver", "Reflect", "TRAPS", "trap", "objectData", "symbolSignal", "symbolPropertySignal", "TypedReactiveHandler", "WeakMap", "instance", "SchemaId", "defineHiddenProperty", "createSignal", "DeletedId", "key", "getOwnPropertyNames", "descriptor", "getOwnPropertyDescriptor", "inspectCustom", "configurable", "_inspect", "bind", "notifyRead", "toJSON", "isArray", "from", "validatedValue", "_validateValue", "notifyWrite", "ownKeys", "property", "attributes", "schema", "SchemaValidator", "getTargetPropertySchema", "_", "Schema", "asserts", "setSchemaProperties", "options", "inspectFn", "compact", "showHidden", "customInspect", "schemaType", "getSchemaDXN", "TypeId", "elementSchema", "prepareTypedTarget", "SchemaAST", "isTypeLiteral", "ast", "Error", "validateSchema", "makeArraysReactive", "UntypedReactiveHandler", "undefined", "isTyped", "getTypename", "live", "objOrSchema", "meta", "Expando", "createReactiveObject", "expando", "annotation", "getTypeAnnotation", "shouldGenerateId", "setIdOnTarget", "EntityKindId", "kind", "initMeta", "ObjectId", "isValid", "random", "keys", "ObjectMetaSchema", "MetaId"]
}
