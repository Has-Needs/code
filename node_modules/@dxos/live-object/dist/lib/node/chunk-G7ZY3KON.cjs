"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var chunk_G7ZY3KON_exports = {};
__export(chunk_G7ZY3KON_exports, {
  ReactiveArray: () => ReactiveArray,
  createProxy: () => createProxy,
  dangerouslySetProxyId: () => dangerouslySetProxyId,
  getProxyHandler: () => getProxyHandler,
  getProxySlot: () => getProxySlot,
  getProxyTarget: () => getProxyTarget,
  isProxy: () => isProxy,
  isValidProxyTarget: () => isValidProxyTarget,
  live: () => live,
  objectData: () => objectData,
  symbolIsProxy: () => symbolIsProxy
});
module.exports = __toCommonJS(chunk_G7ZY3KON_exports);
var import_runtime = require("@dxos/echo-signals/runtime");
var import_invariant = require("@dxos/invariant");
var import_echo_schema = require("@dxos/echo-schema");
var import_echo_schema2 = require("@dxos/echo-schema");
var import_effect = require("effect");
var import_debug = require("@dxos/debug");
var import_echo_schema3 = require("@dxos/echo-schema");
var import_runtime2 = require("@dxos/echo-signals/runtime");
var import_invariant2 = require("@dxos/invariant");
var import_echo_schema4 = require("@dxos/echo-schema");
var import_runtime3 = require("@dxos/echo-signals/runtime");
var import_invariant3 = require("@dxos/invariant");
var ReactiveArray = class extends Array {
  static get [Symbol.species]() {
    return Array;
  }
  static {
    const BATCHED_METHODS = [
      "push",
      "pop",
      "shift",
      "unshift",
      "splice",
      "sort",
      "reverse"
    ];
    for (const method of BATCHED_METHODS) {
      Object.defineProperty(this.prototype, method, {
        enumerable: false,
        value: function(...args) {
          let result;
          import_runtime.compositeRuntime.batch(() => {
            result = Array.prototype[method].apply(this, args);
          });
          return result;
        }
      });
    }
  }
};
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/core/echo/live-object/src/proxy/proxy.ts";
var symbolIsProxy = Symbol.for("@dxos/schema/Proxy");
var isProxy = (value) => !!value?.[symbolIsProxy];
var isValidProxyTarget = (value) => {
  if (value == null || value[symbolIsProxy]) {
    return false;
  }
  if (value instanceof ReactiveArray) {
    return true;
  }
  return typeof value === "object" && Object.getPrototypeOf(value) === Object.prototype;
};
var getProxySlot = (proxy) => {
  const value = proxy[symbolIsProxy];
  (0, import_invariant.invariant)(value instanceof ProxyHandlerSlot, void 0, {
    F: __dxlog_file,
    L: 35,
    S: void 0,
    A: [
      "value instanceof ProxyHandlerSlot",
      ""
    ]
  });
  return value;
};
var getProxyTarget = (proxy) => {
  return getProxySlot(proxy).target;
};
var getProxyHandler = (proxy) => {
  return getProxySlot(proxy).handler;
};
var dangerouslySetProxyId = (obj, id) => {
  getProxySlot(obj).target.id = id;
};
var createProxy = (target, handler) => {
  const existingProxy = handler._proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const proxy = new Proxy(target, new ProxyHandlerSlot(target, handler));
  handler.init(target);
  handler._proxyMap.set(target, proxy);
  return proxy;
};
var ProxyHandlerSlot = class {
  /**
  * @param target Original object.
  * @param _handler Handles intercepted operations.
  */
  constructor(target, _handler) {
    this.target = target;
    this._handler = _handler;
  }
  get handler() {
    (0, import_invariant.invariant)(this._handler, void 0, {
      F: __dxlog_file,
      L: 94,
      S: this,
      A: [
        "this._handler",
        ""
      ]
    });
    return this._handler;
  }
  // TODO(burdon): Requires comment.
  setHandler(handler) {
    this._handler = handler;
  }
  /**
  * Get value.
  */
  get(target, prop, receiver) {
    if (prop === symbolIsProxy) {
      return this;
    }
    if (!this._handler || !this._handler.get) {
      return Reflect.get(target, prop, receiver);
    }
    return this._handler.get(target, prop, receiver);
  }
  static {
    const TRAPS = [
      "apply",
      "construct",
      "defineProperty",
      "deleteProperty",
      "get",
      "getOwnPropertyDescriptor",
      "getPrototypeOf",
      "has",
      "isExtensible",
      "ownKeys",
      "preventExtensions",
      "set",
      "setPrototypeOf"
    ];
    for (const trap of TRAPS) {
      if (trap === "get") {
        continue;
      }
      Object.defineProperty(this.prototype, trap, {
        enumerable: false,
        value: function(...args) {
          if (!this._handler || !this._handler[trap]) {
            return Reflect[trap](...args);
          }
          return this._handler[trap].apply(this._handler, args);
        }
      });
    }
  }
};
var objectData = Symbol.for("@dxos/live-object/objectData");
var __dxlog_file2 = "/home/runner/work/dxos/dxos/packages/core/echo/live-object/src/typed-handler.ts";
var symbolSignal = Symbol("signal");
var symbolPropertySignal = Symbol("property-signal");
var TypedReactiveHandler = class _TypedReactiveHandler {
  constructor() {
    this._proxyMap = /* @__PURE__ */ new WeakMap();
  }
  static {
    this.instance = new _TypedReactiveHandler();
  }
  init(target) {
    (0, import_invariant2.invariant)(typeof target === "object" && target !== null, void 0, {
      F: __dxlog_file2,
      L: 59,
      S: this,
      A: [
        "typeof target === 'object' && target !== null",
        ""
      ]
    });
    (0, import_invariant2.invariant)(import_echo_schema3.SchemaId in target, "Schema is not defined for the target", {
      F: __dxlog_file2,
      L: 60,
      S: this,
      A: [
        "SchemaId in target",
        "'Schema is not defined for the target'"
      ]
    });
    if (!(symbolSignal in target)) {
      (0, import_echo_schema3.defineHiddenProperty)(target, symbolSignal, import_runtime2.compositeRuntime.createSignal());
      (0, import_echo_schema3.defineHiddenProperty)(target, symbolPropertySignal, import_runtime2.compositeRuntime.createSignal());
    }
    (0, import_echo_schema3.defineHiddenProperty)(target, import_echo_schema3.DeletedId, false);
    for (const key of Object.getOwnPropertyNames(target)) {
      const descriptor = Object.getOwnPropertyDescriptor(target, key);
      if (descriptor.get) {
        continue;
      }
    }
    Object.defineProperty(target, import_debug.inspectCustom, {
      enumerable: false,
      configurable: true,
      value: this._inspect.bind(target)
    });
  }
  get(target, prop, receiver) {
    switch (prop) {
      case objectData: {
        target[symbolSignal].notifyRead();
        return toJSON(target);
      }
    }
    if (Object.getOwnPropertyDescriptor(target, prop)?.get) {
      target[symbolPropertySignal].notifyRead();
      return Reflect.get(target, prop, receiver);
    }
    target[symbolSignal].notifyRead();
    target[symbolPropertySignal].notifyRead();
    const value = Reflect.get(target, prop, receiver);
    if (isValidProxyTarget(value)) {
      return createProxy(value, this);
    }
    return value;
  }
  set(target, prop, value, receiver) {
    if (Array.isArray(value)) {
      value = ReactiveArray.from(value);
    }
    let result = false;
    import_runtime2.compositeRuntime.batch(() => {
      const validatedValue = this._validateValue(target, prop, value);
      result = Reflect.set(target, prop, validatedValue, receiver);
      target[symbolSignal].notifyWrite();
    });
    return result;
  }
  ownKeys(target) {
    target[symbolSignal].notifyRead();
    target[symbolPropertySignal].notifyRead();
    return Reflect.ownKeys(target);
  }
  defineProperty(target, property, attributes) {
    const validatedValue = this._validateValue(target, property, attributes.value);
    const result = Reflect.defineProperty(target, property, {
      ...attributes,
      value: validatedValue
    });
    target[symbolPropertySignal].notifyWrite();
    return result;
  }
  _validateValue(target, prop, value) {
    const schema = import_echo_schema3.SchemaValidator.getTargetPropertySchema(target, prop);
    const _ = import_effect.Schema.asserts(schema)(value);
    if (Array.isArray(value)) {
      value = new ReactiveArray(...value);
    }
    if (isValidProxyTarget(value)) {
      setSchemaProperties(value, schema);
    }
    return value;
  }
  _inspect(_, options, inspectFn) {
    return `Typed ${inspectFn(this, {
      ...options,
      compact: true,
      showHidden: false,
      customInspect: false
    })}`;
  }
};
var toJSON = (target) => {
  return {
    "@type": "TypedReactiveObject",
    ...target
  };
};
var setSchemaProperties = (obj, schema) => {
  const schemaType = (0, import_echo_schema3.getSchemaDXN)(schema);
  if (schemaType != null) {
    (0, import_echo_schema3.defineHiddenProperty)(obj, import_echo_schema3.TypeId, schemaType);
  }
  (0, import_echo_schema3.defineHiddenProperty)(obj, import_echo_schema3.SchemaId, schema);
  for (const key in obj) {
    if (isValidProxyTarget(obj[key])) {
      const elementSchema = import_echo_schema3.SchemaValidator.getTargetPropertySchema(obj, key);
      if (elementSchema != null) {
        setSchemaProperties(obj[key], elementSchema);
      }
    }
  }
};
var prepareTypedTarget = (target, schema) => {
  if (!import_effect.SchemaAST.isTypeLiteral(schema.ast)) {
    throw new Error("schema has to describe an object type");
  }
  import_echo_schema3.SchemaValidator.validateSchema(schema);
  const _ = import_effect.Schema.asserts(schema)(target);
  makeArraysReactive(target);
  setSchemaProperties(target, schema);
};
var makeArraysReactive = (target) => {
  for (const key in target) {
    if (target[symbolIsProxy]) {
      continue;
    }
    if (Array.isArray(target[key])) {
      target[key] = ReactiveArray.from(target[key]);
    }
    if (typeof target[key] === "object") {
      makeArraysReactive(target[key]);
    }
  }
};
var __dxlog_file3 = "/home/runner/work/dxos/dxos/packages/core/echo/live-object/src/untyped-handler.ts";
var symbolSignal2 = Symbol("signal");
var symbolPropertySignal2 = Symbol("property-signal");
var UntypedReactiveHandler = class _UntypedReactiveHandler {
  constructor() {
    this._proxyMap = /* @__PURE__ */ new WeakMap();
  }
  static {
    this.instance = new _UntypedReactiveHandler();
  }
  init(target) {
    (0, import_invariant3.invariant)(typeof target === "object" && target !== null, void 0, {
      F: __dxlog_file3,
      L: 42,
      S: this,
      A: [
        "typeof target === 'object' && target !== null",
        ""
      ]
    });
    if (!(symbolSignal2 in target)) {
      (0, import_echo_schema4.defineHiddenProperty)(target, symbolSignal2, import_runtime3.compositeRuntime.createSignal());
      (0, import_echo_schema4.defineHiddenProperty)(target, symbolPropertySignal2, import_runtime3.compositeRuntime.createSignal());
    }
    (0, import_echo_schema4.defineHiddenProperty)(target, import_echo_schema4.DeletedId, false);
    for (const key of Object.getOwnPropertyNames(target)) {
      const descriptor = Object.getOwnPropertyDescriptor(target, key);
      if (descriptor.get) {
        continue;
      }
      if (Array.isArray(target[key]) && !(target[key] instanceof ReactiveArray)) {
        target[key] = ReactiveArray.from(target[key]);
      }
    }
  }
  get(target, prop, receiver) {
    if (Object.getOwnPropertyDescriptor(target, prop)?.get) {
      target[symbolPropertySignal2].notifyRead();
      return Reflect.get(target, prop, receiver);
    }
    target[symbolSignal2].notifyRead();
    target[symbolPropertySignal2].notifyRead();
    if (prop === objectData) {
      return toJSON2(target);
    }
    if (prop === import_echo_schema4.TypeId) {
      return void 0;
    }
    const value = Reflect.get(target, prop);
    if (isValidProxyTarget(value)) {
      const isTyped = (0, import_echo_schema4.getTypename)(value) !== void 0;
      if (isTyped) {
        return createProxy(value, TypedReactiveHandler.instance);
      } else {
        return createProxy(value, this);
      }
    }
    return value;
  }
  set(target, prop, value, receiver) {
    if (Array.isArray(value)) {
      value = ReactiveArray.from(value);
    }
    const result = Reflect.set(target, prop, value);
    target[symbolSignal2].notifyWrite();
    return result;
  }
  ownKeys(target) {
    target[symbolSignal2].notifyRead();
    target[symbolPropertySignal2].notifyRead();
    return Reflect.ownKeys(target);
  }
  defineProperty(target, property, attributes) {
    const result = Reflect.defineProperty(target, property, attributes);
    target[symbolPropertySignal2].notifyWrite();
    return result;
  }
};
var toJSON2 = (target) => {
  return {
    "@type": "ReactiveObject",
    ...target
  };
};
var live = (objOrSchema, obj, meta) => {
  if (obj && objOrSchema !== import_echo_schema.Expando) {
    return createReactiveObject({
      ...obj
    }, meta, objOrSchema);
  } else if (obj && objOrSchema === import_echo_schema.Expando) {
    return createReactiveObject({
      ...obj
    }, meta, void 0, {
      expando: true
    });
  } else {
    return createReactiveObject(objOrSchema, meta);
  }
};
var createReactiveObject = (obj, meta, schema, options) => {
  if (!isValidProxyTarget(obj)) {
    throw new Error("Value cannot be made into a reactive object.");
  }
  if (schema) {
    const annotation = (0, import_echo_schema.getTypeAnnotation)(schema);
    const shouldGenerateId = options?.expando || !!annotation;
    if (shouldGenerateId) {
      setIdOnTarget(obj);
    }
    if (annotation) {
      (0, import_echo_schema.defineHiddenProperty)(obj, import_echo_schema.EntityKindId, annotation.kind);
    }
    initMeta(obj, meta);
    prepareTypedTarget(obj, schema);
    return createProxy(obj, TypedReactiveHandler.instance);
  } else {
    if (options?.expando) {
      setIdOnTarget(obj);
    }
    initMeta(obj, meta);
    return createProxy(obj, UntypedReactiveHandler.instance);
  }
};
var setIdOnTarget = (target) => {
  if ("id" in target) {
    if (!import_echo_schema.ObjectId.isValid(target.id)) {
      throw new Error("Invalid object id format.");
    }
  } else {
    target.id = import_echo_schema.ObjectId.random();
  }
};
var initMeta = (obj, meta = {
  keys: []
}) => {
  prepareTypedTarget(meta, import_echo_schema.ObjectMetaSchema);
  (0, import_echo_schema.defineHiddenProperty)(obj, import_echo_schema2.MetaId, createProxy(meta, TypedReactiveHandler.instance));
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ReactiveArray,
  createProxy,
  dangerouslySetProxyId,
  getProxyHandler,
  getProxySlot,
  getProxyTarget,
  isProxy,
  isValidProxyTarget,
  live,
  objectData,
  symbolIsProxy
});
//# sourceMappingURL=chunk-G7ZY3KON.cjs.map
