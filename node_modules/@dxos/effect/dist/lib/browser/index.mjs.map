{
  "version": 3,
  "sources": ["../../../src/ast.ts", "../../../src/jsonPath.ts", "../../../src/url.ts"],
  "sourcesContent": ["//\n// Copyright 2024 DXOS.org\n//\n\nimport { Option, pipe, SchemaAST, Schema } from 'effect';\n\nimport { invariant } from '@dxos/invariant';\nimport { isNonNullable } from '@dxos/util';\n\nimport { type JsonPath, type JsonProp } from './jsonPath';\n\n//\n// Refs\n// https://effect.website/docs/schema/introduction\n// https://www.npmjs.com/package/@effect/schema\n// https://effect-ts.github.io/effect/schema/SchemaAST.ts.html\n//\n\nexport type SimpleType = 'object' | 'string' | 'number' | 'boolean' | 'enum' | 'literal';\n\n/**\n * Get the base type; e.g., traverse through refinements.\n */\nexport const getSimpleType = (node: SchemaAST.AST): SimpleType | undefined => {\n  if (\n    SchemaAST.isDeclaration(node) ||\n    SchemaAST.isObjectKeyword(node) ||\n    SchemaAST.isTypeLiteral(node) ||\n    isDiscriminatedUnion(node)\n  ) {\n    return 'object';\n  }\n\n  if (SchemaAST.isStringKeyword(node)) {\n    return 'string';\n  }\n  if (SchemaAST.isNumberKeyword(node)) {\n    return 'number';\n  }\n  if (SchemaAST.isBooleanKeyword(node)) {\n    return 'boolean';\n  }\n\n  if (SchemaAST.isEnums(node)) {\n    return 'enum';\n  }\n\n  if (SchemaAST.isLiteral(node)) {\n    return 'literal';\n  }\n};\n\nexport const isSimpleType = (node: SchemaAST.AST): boolean => !!getSimpleType(node);\n\nexport namespace SimpleType {\n  /**\n   * Returns the default empty value for a given SimpleType.\n   * Used for initializing new array values etc.\n   */\n  export const getDefaultValue = (type: SimpleType): any => {\n    switch (type) {\n      case 'string': {\n        return '';\n      }\n      case 'number': {\n        return 0;\n      }\n      case 'boolean': {\n        return false;\n      }\n      case 'object': {\n        return {};\n      }\n      default: {\n        throw new Error(`Unsupported type for default value: ${type}`);\n      }\n    }\n  };\n}\n\n//\n// Branded types\n//\n\nexport enum VisitResult {\n  CONTINUE = 0,\n  /**\n   * Skip visiting children.\n   */\n  SKIP = 1,\n  /**\n   * Stop traversing immediately.\n   */\n  EXIT = 2,\n}\n\nexport type Path = (string | number)[];\n\nexport type TestFn = (node: SchemaAST.AST, path: Path, depth: number) => VisitResult | boolean | undefined;\n\nexport type VisitorFn = (node: SchemaAST.AST, path: Path, depth: number) => void;\n\nconst defaultTest: TestFn = isSimpleType;\n\n/**\n * Visit leaf nodes.\n * Refs:\n * - https://github.com/syntax-tree/unist-util-visit?tab=readme-ov-file#visitor\n * - https://github.com/syntax-tree/unist-util-is?tab=readme-ov-file#test\n */\nexport const visit: {\n  (node: SchemaAST.AST, visitor: VisitorFn): void;\n  (node: SchemaAST.AST, test: TestFn, visitor: VisitorFn): void;\n} = (node: SchemaAST.AST, testOrVisitor: TestFn | VisitorFn, visitor?: VisitorFn): void => {\n  if (!visitor) {\n    visitNode(node, defaultTest, testOrVisitor);\n  } else {\n    visitNode(node, testOrVisitor as TestFn, visitor);\n  }\n};\n\nconst visitNode = (\n  node: SchemaAST.AST,\n  test: TestFn | undefined,\n  visitor: VisitorFn,\n  path: Path = [],\n  depth = 0,\n): VisitResult | undefined => {\n  const _result = test?.(node, path, depth);\n  const result: VisitResult =\n    _result === undefined\n      ? VisitResult.CONTINUE\n      : typeof _result === 'boolean'\n        ? _result\n          ? VisitResult.CONTINUE\n          : VisitResult.SKIP\n        : _result;\n\n  if (result === VisitResult.EXIT) {\n    return result;\n  }\n  if (result !== VisitResult.SKIP) {\n    visitor(node, path, depth);\n  }\n\n  // Object.\n  if (SchemaAST.isTypeLiteral(node)) {\n    for (const prop of SchemaAST.getPropertySignatures(node)) {\n      const currentPath = [...path, prop.name.toString()];\n      const result = visitNode(prop.type, test, visitor, currentPath, depth + 1);\n      if (result === VisitResult.EXIT) {\n        return result;\n      }\n    }\n  }\n\n  // Array.\n  else if (SchemaAST.isTupleType(node)) {\n    for (const [i, element] of node.elements.entries()) {\n      const currentPath = [...path, i];\n      const result = visitNode(element.type, test, visitor, currentPath, depth);\n      if (result === VisitResult.EXIT) {\n        return result;\n      }\n    }\n  }\n\n  // Branching union (e.g., optional, discriminated unions).\n  else if (SchemaAST.isUnion(node)) {\n    for (const type of node.types) {\n      const result = visitNode(type, test, visitor, path, depth);\n      if (result === VisitResult.EXIT) {\n        return result;\n      }\n    }\n  }\n\n  // Refinement.\n  else if (SchemaAST.isRefinement(node)) {\n    const result = visitNode(node.from, test, visitor, path, depth);\n    if (result === VisitResult.EXIT) {\n      return result;\n    }\n  }\n\n  // TODO(burdon): Transforms?\n};\n\n/**\n * Recursively descend into AST to find first node that passes the test.\n */\n// TODO(burdon): Rewrite using visitNode?\nexport const findNode = (node: SchemaAST.AST, test: (node: SchemaAST.AST) => boolean): SchemaAST.AST | undefined => {\n  if (test(node)) {\n    return node;\n  }\n\n  // Object.\n  else if (SchemaAST.isTypeLiteral(node)) {\n    for (const prop of SchemaAST.getPropertySignatures(node)) {\n      const child = findNode(prop.type, test);\n      if (child) {\n        return child;\n      }\n    }\n  }\n\n  // Tuple.\n  else if (SchemaAST.isTupleType(node)) {\n    for (const [_, element] of node.elements.entries()) {\n      const child = findNode(element.type, test);\n      if (child) {\n        return child;\n      }\n    }\n  }\n\n  // Branching union (e.g., optional, discriminated unions).\n  else if (SchemaAST.isUnion(node)) {\n    if (isOption(node)) {\n      for (const type of node.types) {\n        const child = findNode(type, test);\n        if (child) {\n          return child;\n        }\n      }\n    }\n  }\n\n  // Refinement.\n  else if (SchemaAST.isRefinement(node)) {\n    return findNode(node.from, test);\n  }\n};\n\n/**\n * Get the AST node for the given property (dot-path).\n */\nexport const findProperty = (\n  schema: Schema.Schema.AnyNoContext,\n  path: JsonPath | JsonProp,\n): SchemaAST.AST | undefined => {\n  const getProp = (node: SchemaAST.AST, path: JsonProp[]): SchemaAST.AST | undefined => {\n    const [name, ...rest] = path;\n    const typeNode = findNode(node, SchemaAST.isTypeLiteral);\n    invariant(typeNode);\n    for (const prop of SchemaAST.getPropertySignatures(typeNode)) {\n      if (prop.name === name) {\n        if (rest.length) {\n          return getProp(prop.type, rest);\n        } else {\n          return prop.type;\n        }\n      }\n    }\n  };\n\n  return getProp(schema.ast, path.split('.') as JsonProp[]);\n};\n\n//\n// Annotations\n//\n\nconst defaultAnnotations: Record<string, SchemaAST.Annotated> = {\n  ['ObjectKeyword' as const]: SchemaAST.objectKeyword,\n  ['StringKeyword' as const]: SchemaAST.stringKeyword,\n  ['NumberKeyword' as const]: SchemaAST.numberKeyword,\n  ['BooleanKeyword' as const]: SchemaAST.booleanKeyword,\n};\n\n/**\n * Get annotation or return undefined.\n * @param annotationId\n * @param noDefault If true, then return undefined for effect library defined values.\n */\nexport const getAnnotation =\n  <T>(annotationId: symbol, noDefault = true) =>\n  (node: SchemaAST.AST): T | undefined => {\n    // Title fallback seems to be the identifier.\n    const id = pipe(SchemaAST.getIdentifierAnnotation(node), Option.getOrUndefined);\n    const value = pipe(SchemaAST.getAnnotation<T>(annotationId)(node), Option.getOrUndefined);\n    if (noDefault && (value === defaultAnnotations[node._tag]?.annotations[annotationId] || value === id)) {\n      return undefined;\n    }\n\n    return value;\n  };\n\n/**\n * Recursively descend into AST to find first matching annotations.\n * Optionally skips default annotations for basic types (e.g., 'a string').\n */\n// TODO(burdon): Convert to effect pattern (i.e., return operator like getAnnotation).\nexport const findAnnotation = <T>(node: SchemaAST.AST, annotationId: symbol, noDefault = true): T | undefined => {\n  const getAnnotationById = getAnnotation(annotationId, noDefault);\n\n  const getBaseAnnotation = (node: SchemaAST.AST): T | undefined => {\n    const value = getAnnotationById(node);\n    if (value !== undefined) {\n      return value as T;\n    }\n\n    if (SchemaAST.isUnion(node)) {\n      if (isOption(node)) {\n        return getAnnotationById(node.types[0]) as T;\n      }\n    }\n  };\n\n  return getBaseAnnotation(node);\n};\n\n//\n// Unions\n//\n\n/**\n * Effect Schema.optional creates a union type with undefined as the second type.\n */\nexport const isOption = (node: SchemaAST.AST): boolean => {\n  return SchemaAST.isUnion(node) && node.types.length === 2 && SchemaAST.isUndefinedKeyword(node.types[1]);\n};\n\n/**\n * Determines if the node is a union of literal types.\n */\nexport const isLiteralUnion = (node: SchemaAST.AST): boolean => {\n  return SchemaAST.isUnion(node) && node.types.every(SchemaAST.isLiteral);\n};\n\n/**\n * Determines if the node is a discriminated union.\n */\nexport const isDiscriminatedUnion = (node: SchemaAST.AST): boolean => {\n  return SchemaAST.isUnion(node) && !!getDiscriminatingProps(node)?.length;\n};\n\n/**\n * Get the discriminating properties for the given union type.\n */\nexport const getDiscriminatingProps = (node: SchemaAST.AST): string[] | undefined => {\n  invariant(SchemaAST.isUnion(node));\n  if (isOption(node)) {\n    return;\n  }\n\n  // Get common literals across all types.\n  return node.types.reduce<string[]>((shared, type) => {\n    const props = SchemaAST.getPropertySignatures(type)\n      // TODO(burdon): Should check each literal is unique.\n      .filter((p) => SchemaAST.isLiteral(p.type))\n      .map((p) => p.name.toString());\n\n    // Return common literals.\n    return shared.length === 0 ? props : shared.filter((prop) => props.includes(prop));\n  }, []);\n};\n\n/**\n * Get the discriminated type for the given value.\n */\nexport const getDiscriminatedType = (\n  node: SchemaAST.AST,\n  value: Record<string, any> = {},\n): SchemaAST.AST | undefined => {\n  invariant(SchemaAST.isUnion(node));\n  invariant(value);\n  const props = getDiscriminatingProps(node);\n  if (!props?.length) {\n    return;\n  }\n\n  // Match provided values.\n  for (const type of node.types) {\n    const match = SchemaAST.getPropertySignatures(type)\n      .filter((prop) => props?.includes(prop.name.toString()))\n      .every((prop) => {\n        invariant(SchemaAST.isLiteral(prop.type));\n        return prop.type.literal === value[prop.name.toString()];\n      });\n\n    if (match) {\n      return type;\n    }\n  }\n\n  // Create union of discriminating properties.\n  // NOTE: This may not work with non-overlapping variants.\n  // TODO(burdon): Iterate through props and knock-out variants that don't match.\n  const fields = Object.fromEntries(\n    props\n      .map((prop) => {\n        const literals = node.types\n          .map((type) => {\n            const literal = SchemaAST.getPropertySignatures(type).find((p) => p.name.toString() === prop)!;\n            invariant(SchemaAST.isLiteral(literal.type));\n            return literal.type.literal;\n          })\n          .filter(isNonNullable);\n\n        return literals.length ? [prop, Schema.Literal(...literals)] : undefined;\n      })\n      .filter(isNonNullable),\n  );\n\n  const schema = Schema.Struct(fields);\n  return schema.ast;\n};\n\n/**\n * Maps AST nodes.\n * The user is responsible for recursively calling {@link mapAst} on the SchemaAST.\n * NOTE: Will evaluate suspended ASTs.\n */\nexport const mapAst = (\n  ast: SchemaAST.AST,\n  f: (ast: SchemaAST.AST, key: keyof any | undefined) => SchemaAST.AST,\n): SchemaAST.AST => {\n  switch (ast._tag) {\n    case 'TypeLiteral': {\n      return new SchemaAST.TypeLiteral(\n        ast.propertySignatures.map(\n          (prop) =>\n            new SchemaAST.PropertySignature(\n              prop.name,\n              f(prop.type, prop.name),\n              prop.isOptional,\n              prop.isReadonly,\n              prop.annotations,\n            ),\n        ),\n        ast.indexSignatures,\n      );\n    }\n    case 'Union': {\n      return SchemaAST.Union.make(ast.types.map(f), ast.annotations);\n    }\n    case 'TupleType': {\n      return new SchemaAST.TupleType(\n        ast.elements.map((t, index) => new SchemaAST.OptionalType(f(t.type, index), t.isOptional, t.annotations)),\n        ast.rest.map((t) => new SchemaAST.Type(f(t.type, undefined), t.annotations)),\n        ast.isReadonly,\n        ast.annotations,\n      );\n    }\n    case 'Suspend': {\n      const newAst = f(ast.f(), undefined);\n      return new SchemaAST.Suspend(() => newAst, ast.annotations);\n    }\n    default: {\n      // TODO(dmaretskyi): Support more nodes.\n      return ast;\n    }\n  }\n};\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { Schema, Option } from 'effect';\nimport { JSONPath } from 'jsonpath-plus';\n\nimport { invariant } from '@dxos/invariant';\n\nexport type JsonProp = string & { __JsonPath: true; __JsonProp: true };\nexport type JsonPath = string & { __JsonPath: true };\n\nconst PATH_REGEX = /^($|[a-zA-Z_$][\\w$]*(?:\\.[a-zA-Z_$][\\w$]*|\\[\\d+\\](?:\\.)?)*$)/;\nconst PROP_REGEX = /^\\w+$/;\n\n/**\n * https://www.ietf.org/archive/id/draft-goessner-dispatch-jsonpath-00.html\n */\nexport const JsonPath = Schema.String.pipe(Schema.pattern(PATH_REGEX)).annotations({\n  title: 'JSON path',\n  description: 'JSON path to a property',\n}) as any as Schema.Schema<JsonPath>;\nexport const JsonProp = Schema.NonEmptyString.pipe(\n  Schema.pattern(PROP_REGEX, {\n    message: () => 'Property name must contain only letters, numbers, and underscores',\n  }),\n) as any as Schema.Schema<JsonProp>;\n\nexport const isJsonPath = (value: unknown): value is JsonPath => {\n  return Option.isSome(Schema.validateOption(JsonPath)(value));\n};\n\n/**\n * Creates a JsonPath from an array of path segments.\n *\n * Currently supports:\n * - Simple property access (e.g., 'foo.bar')\n * - Array indexing with non-negative integers (e.g., 'foo[0]')\n * - Identifiers starting with letters, underscore, or $ (e.g., '$foo', '_bar')\n * - Dot notation for nested properties (e.g., 'foo.bar.baz')\n *\n * Does not support (yet?).\n * - Recursive descent (..)\n * - Wildcards (*)\n * - Array slicing\n * - Filters\n * - Negative indices\n *\n * @param path Array of string or number segments\n * @returns Valid JsonPath or undefined if invalid\n */\nexport const createJsonPath = (path: (string | number)[]): JsonPath => {\n  const candidatePath = path\n    .map((p, i) => {\n      if (typeof p === 'number') {\n        return `[${p}]`;\n      } else {\n        return i === 0 ? p : `.${p}`;\n      }\n    })\n    .join('');\n\n  invariant(isJsonPath(candidatePath), `Invalid JsonPath: ${candidatePath}`);\n  return candidatePath;\n};\n\n/**\n * Converts Effect validation path format (e.g. \"addresses.[0].zip\")\n * to JsonPath format (e.g., \"addresses[0].zip\")\n */\nexport const fromEffectValidationPath = (effectPath: string): JsonPath => {\n  // Handle array notation: convert \"prop.[0]\" to \"prop[0]\"\n  const jsonPath = effectPath.replace(/\\.\\[(\\d+)\\]/g, '[$1]');\n  invariant(isJsonPath(jsonPath), `Invalid JsonPath: ${jsonPath}`);\n  return jsonPath;\n};\n\n/**\n * Splits a JsonPath into its constituent parts.\n * Handles property access and array indexing.\n */\nexport const splitJsonPath = (path: JsonPath): string[] => {\n  if (!isJsonPath(path)) {\n    return [];\n  }\n\n  return (\n    path\n      .match(/[a-zA-Z_$][\\w$]*|\\[\\d+\\]/g)\n      ?.map((part) => (part.startsWith('[') ? part.replace(/[[\\]]/g, '') : part)) ?? []\n  );\n};\n\n/**\n * Applies a JsonPath to an object.\n */\nexport const getField = (object: any, path: JsonPath): any => {\n  // By default, JSONPath returns an array of results.\n  return JSONPath({ path, json: object })[0];\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { SchemaAST, type Schema, Option, pipe } from 'effect';\n\nimport { decamelize } from '@dxos/util';\n\nconst ParamKeyAnnotationId = Symbol.for('@dxos/schema/annotation/ParamKey');\n\ntype ParamKeyAnnotationValue = { key: string };\n\nexport const getParamKeyAnnotation: (annotated: SchemaAST.Annotated) => Option.Option<ParamKeyAnnotationValue> =\n  SchemaAST.getAnnotation<ParamKeyAnnotationValue>(ParamKeyAnnotationId);\n\nexport const ParamKeyAnnotation =\n  (value: ParamKeyAnnotationValue) =>\n  <S extends Schema.Annotable.All>(self: S): Schema.Annotable.Self<S> =>\n    self.annotations({ [ParamKeyAnnotationId]: value });\n\n/**\n * HTTP params parser.\n * Supports custom key serialization.\n */\nexport class UrlParser<T extends Record<string, any>> {\n  constructor(private readonly _schema: Schema.Struct<T>) {}\n\n  /**\n   * Parse URL params.\n   */\n  parse(_url: string): T {\n    const url = new URL(_url);\n    return Object.entries(this._schema.fields).reduce<Record<string, any>>((params, [key, type]) => {\n      let value = url.searchParams.get(decamelize(key));\n      if (value == null) {\n        value = url.searchParams.get(key);\n      }\n\n      if (value != null) {\n        if (SchemaAST.isNumberKeyword(type.ast)) {\n          params[key] = parseInt(value);\n        } else if (SchemaAST.isBooleanKeyword(type.ast)) {\n          params[key] = value === 'true' || value === '1';\n        } else {\n          params[key] = value;\n        }\n      }\n\n      return params;\n    }, {}) as T;\n  }\n\n  /**\n   * Return URL with encoded params.\n   */\n  create(_url: string, params: T): URL {\n    const url = new URL(_url);\n    Object.entries(params).forEach(([key, value]) => {\n      if (value !== undefined) {\n        const field = this._schema.fields[key];\n        if (field) {\n          const { key: serializedKey } = pipe(\n            getParamKeyAnnotation(field.ast),\n            Option.getOrElse(() => ({\n              key: decamelize(key),\n            })),\n          );\n\n          url.searchParams.set(serializedKey, String(value));\n        }\n      }\n    });\n\n    return url;\n  }\n}\n"],
  "mappings": "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",
  "names": ["Option", "pipe", "SchemaAST", "Schema", "invariant", "isNonNullable", "getSimpleType", "node", "isDeclaration", "isObjectKeyword", "isTypeLiteral", "isDiscriminatedUnion", "isStringKeyword", "isNumberKeyword", "isBooleanKeyword", "isEnums", "isLiteral", "isSimpleType", "SimpleType", "getDefaultValue", "type", "Error", "VisitResult", "defaultTest", "visit", "testOrVisitor", "visitor", "visitNode", "test", "path", "depth", "_result", "result", "undefined", "prop", "getPropertySignatures", "currentPath", "name", "toString", "isTupleType", "i", "element", "elements", "entries", "isUnion", "types", "isRefinement", "from", "findNode", "child", "_", "isOption", "findProperty", "schema", "getProp", "rest", "typeNode", "length", "ast", "split", "defaultAnnotations", "objectKeyword", "stringKeyword", "numberKeyword", "booleanKeyword", "getAnnotation", "annotationId", "noDefault", "id", "getIdentifierAnnotation", "getOrUndefined", "value", "_tag", "annotations", "findAnnotation", "getAnnotationById", "getBaseAnnotation", "isUndefinedKeyword", "isLiteralUnion", "every", "getDiscriminatingProps", "reduce", "shared", "props", "filter", "p", "map", "includes", "getDiscriminatedType", "match", "literal", "fields", "Object", "fromEntries", "literals", "find", "Literal", "Struct", "mapAst", "f", "TypeLiteral", "propertySignatures", "PropertySignature", "isOptional", "isReadonly", "indexSignatures", "Union", "make", "TupleType", "t", "index", "OptionalType", "Type", "newAst", "Suspend", "Schema", "Option", "JSONPath", "invariant", "PATH_REGEX", "PROP_REGEX", "JsonPath", "String", "pipe", "pattern", "annotations", "title", "description", "JsonProp", "NonEmptyString", "message", "isJsonPath", "value", "isSome", "validateOption", "createJsonPath", "path", "candidatePath", "map", "p", "i", "join", "fromEffectValidationPath", "effectPath", "jsonPath", "replace", "splitJsonPath", "match", "part", "startsWith", "getField", "object", "json", "SchemaAST", "Option", "pipe", "decamelize", "ParamKeyAnnotationId", "Symbol", "for", "getParamKeyAnnotation", "SchemaAST", "getAnnotation", "ParamKeyAnnotation", "value", "self", "annotations", "UrlParser", "_schema", "parse", "_url", "url", "URL", "Object", "entries", "fields", "reduce", "params", "key", "type", "searchParams", "get", "decamelize", "isNumberKeyword", "ast", "parseInt", "isBooleanKeyword", "create", "forEach", "undefined", "field", "serializedKey", "pipe", "Option", "getOrElse", "set", "String"]
}
