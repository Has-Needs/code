import { createRequire } from 'node:module';const require = createRequire(import.meta.url);

// packages/common/effect/src/ast.ts
import { Option, pipe, SchemaAST, Schema } from "effect";
import { invariant } from "@dxos/invariant";
import { isNonNullable } from "@dxos/util";
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/common/effect/src/ast.ts";
var getSimpleType = (node) => {
  if (SchemaAST.isDeclaration(node) || SchemaAST.isObjectKeyword(node) || SchemaAST.isTypeLiteral(node) || isDiscriminatedUnion(node)) {
    return "object";
  }
  if (SchemaAST.isStringKeyword(node)) {
    return "string";
  }
  if (SchemaAST.isNumberKeyword(node)) {
    return "number";
  }
  if (SchemaAST.isBooleanKeyword(node)) {
    return "boolean";
  }
  if (SchemaAST.isEnums(node)) {
    return "enum";
  }
  if (SchemaAST.isLiteral(node)) {
    return "literal";
  }
};
var isSimpleType = (node) => !!getSimpleType(node);
(function(SimpleType2) {
  SimpleType2.getDefaultValue = (type) => {
    switch (type) {
      case "string": {
        return "";
      }
      case "number": {
        return 0;
      }
      case "boolean": {
        return false;
      }
      case "object": {
        return {};
      }
      default: {
        throw new Error(`Unsupported type for default value: ${type}`);
      }
    }
  };
})(SimpleType || (SimpleType = {}));
var VisitResult = /* @__PURE__ */ function(VisitResult2) {
  VisitResult2[VisitResult2["CONTINUE"] = 0] = "CONTINUE";
  VisitResult2[VisitResult2["SKIP"] = 1] = "SKIP";
  VisitResult2[VisitResult2["EXIT"] = 2] = "EXIT";
  return VisitResult2;
}({});
var defaultTest = isSimpleType;
var visit = (node, testOrVisitor, visitor) => {
  if (!visitor) {
    visitNode(node, defaultTest, testOrVisitor);
  } else {
    visitNode(node, testOrVisitor, visitor);
  }
};
var visitNode = (node, test, visitor, path = [], depth = 0) => {
  const _result = test?.(node, path, depth);
  const result = _result === void 0 ? 0 : typeof _result === "boolean" ? _result ? 0 : 1 : _result;
  if (result === 2) {
    return result;
  }
  if (result !== 1) {
    visitor(node, path, depth);
  }
  if (SchemaAST.isTypeLiteral(node)) {
    for (const prop of SchemaAST.getPropertySignatures(node)) {
      const currentPath = [
        ...path,
        prop.name.toString()
      ];
      const result2 = visitNode(prop.type, test, visitor, currentPath, depth + 1);
      if (result2 === 2) {
        return result2;
      }
    }
  } else if (SchemaAST.isTupleType(node)) {
    for (const [i, element] of node.elements.entries()) {
      const currentPath = [
        ...path,
        i
      ];
      const result2 = visitNode(element.type, test, visitor, currentPath, depth);
      if (result2 === 2) {
        return result2;
      }
    }
  } else if (SchemaAST.isUnion(node)) {
    for (const type of node.types) {
      const result2 = visitNode(type, test, visitor, path, depth);
      if (result2 === 2) {
        return result2;
      }
    }
  } else if (SchemaAST.isRefinement(node)) {
    const result2 = visitNode(node.from, test, visitor, path, depth);
    if (result2 === 2) {
      return result2;
    }
  }
};
var findNode = (node, test) => {
  if (test(node)) {
    return node;
  } else if (SchemaAST.isTypeLiteral(node)) {
    for (const prop of SchemaAST.getPropertySignatures(node)) {
      const child = findNode(prop.type, test);
      if (child) {
        return child;
      }
    }
  } else if (SchemaAST.isTupleType(node)) {
    for (const [_, element] of node.elements.entries()) {
      const child = findNode(element.type, test);
      if (child) {
        return child;
      }
    }
  } else if (SchemaAST.isUnion(node)) {
    if (isOption(node)) {
      for (const type of node.types) {
        const child = findNode(type, test);
        if (child) {
          return child;
        }
      }
    }
  } else if (SchemaAST.isRefinement(node)) {
    return findNode(node.from, test);
  }
};
var findProperty = (schema, path) => {
  const getProp = (node, path2) => {
    const [name, ...rest] = path2;
    const typeNode = findNode(node, SchemaAST.isTypeLiteral);
    invariant(typeNode, void 0, {
      F: __dxlog_file,
      L: 246,
      S: void 0,
      A: [
        "typeNode",
        ""
      ]
    });
    for (const prop of SchemaAST.getPropertySignatures(typeNode)) {
      if (prop.name === name) {
        if (rest.length) {
          return getProp(prop.type, rest);
        } else {
          return prop.type;
        }
      }
    }
  };
  return getProp(schema.ast, path.split("."));
};
var defaultAnnotations = {
  ["ObjectKeyword"]: SchemaAST.objectKeyword,
  ["StringKeyword"]: SchemaAST.stringKeyword,
  ["NumberKeyword"]: SchemaAST.numberKeyword,
  ["BooleanKeyword"]: SchemaAST.booleanKeyword
};
var getAnnotation = (annotationId, noDefault = true) => (node) => {
  const id = pipe(SchemaAST.getIdentifierAnnotation(node), Option.getOrUndefined);
  const value = pipe(SchemaAST.getAnnotation(annotationId)(node), Option.getOrUndefined);
  if (noDefault && (value === defaultAnnotations[node._tag]?.annotations[annotationId] || value === id)) {
    return void 0;
  }
  return value;
};
var findAnnotation = (node, annotationId, noDefault = true) => {
  const getAnnotationById = getAnnotation(annotationId, noDefault);
  const getBaseAnnotation = (node2) => {
    const value = getAnnotationById(node2);
    if (value !== void 0) {
      return value;
    }
    if (SchemaAST.isUnion(node2)) {
      if (isOption(node2)) {
        return getAnnotationById(node2.types[0]);
      }
    }
  };
  return getBaseAnnotation(node);
};
var isOption = (node) => {
  return SchemaAST.isUnion(node) && node.types.length === 2 && SchemaAST.isUndefinedKeyword(node.types[1]);
};
var isLiteralUnion = (node) => {
  return SchemaAST.isUnion(node) && node.types.every(SchemaAST.isLiteral);
};
var isDiscriminatedUnion = (node) => {
  return SchemaAST.isUnion(node) && !!getDiscriminatingProps(node)?.length;
};
var getDiscriminatingProps = (node) => {
  invariant(SchemaAST.isUnion(node), void 0, {
    F: __dxlog_file,
    L: 343,
    S: void 0,
    A: [
      "SchemaAST.isUnion(node)",
      ""
    ]
  });
  if (isOption(node)) {
    return;
  }
  return node.types.reduce((shared, type) => {
    const props = SchemaAST.getPropertySignatures(type).filter((p) => SchemaAST.isLiteral(p.type)).map((p) => p.name.toString());
    return shared.length === 0 ? props : shared.filter((prop) => props.includes(prop));
  }, []);
};
var getDiscriminatedType = (node, value = {}) => {
  invariant(SchemaAST.isUnion(node), void 0, {
    F: __dxlog_file,
    L: 367,
    S: void 0,
    A: [
      "SchemaAST.isUnion(node)",
      ""
    ]
  });
  invariant(value, void 0, {
    F: __dxlog_file,
    L: 368,
    S: void 0,
    A: [
      "value",
      ""
    ]
  });
  const props = getDiscriminatingProps(node);
  if (!props?.length) {
    return;
  }
  for (const type of node.types) {
    const match = SchemaAST.getPropertySignatures(type).filter((prop) => props?.includes(prop.name.toString())).every((prop) => {
      invariant(SchemaAST.isLiteral(prop.type), void 0, {
        F: __dxlog_file,
        L: 379,
        S: void 0,
        A: [
          "SchemaAST.isLiteral(prop.type)",
          ""
        ]
      });
      return prop.type.literal === value[prop.name.toString()];
    });
    if (match) {
      return type;
    }
  }
  const fields = Object.fromEntries(props.map((prop) => {
    const literals = node.types.map((type) => {
      const literal = SchemaAST.getPropertySignatures(type).find((p) => p.name.toString() === prop);
      invariant(SchemaAST.isLiteral(literal.type), void 0, {
        F: __dxlog_file,
        L: 397,
        S: void 0,
        A: [
          "SchemaAST.isLiteral(literal.type)",
          ""
        ]
      });
      return literal.type.literal;
    }).filter(isNonNullable);
    return literals.length ? [
      prop,
      Schema.Literal(...literals)
    ] : void 0;
  }).filter(isNonNullable));
  const schema = Schema.Struct(fields);
  return schema.ast;
};
var mapAst = (ast, f) => {
  switch (ast._tag) {
    case "TypeLiteral": {
      return new SchemaAST.TypeLiteral(ast.propertySignatures.map((prop) => new SchemaAST.PropertySignature(prop.name, f(prop.type, prop.name), prop.isOptional, prop.isReadonly, prop.annotations)), ast.indexSignatures);
    }
    case "Union": {
      return SchemaAST.Union.make(ast.types.map(f), ast.annotations);
    }
    case "TupleType": {
      return new SchemaAST.TupleType(ast.elements.map((t, index) => new SchemaAST.OptionalType(f(t.type, index), t.isOptional, t.annotations)), ast.rest.map((t) => new SchemaAST.Type(f(t.type, void 0), t.annotations)), ast.isReadonly, ast.annotations);
    }
    case "Suspend": {
      const newAst = f(ast.f(), void 0);
      return new SchemaAST.Suspend(() => newAst, ast.annotations);
    }
    default: {
      return ast;
    }
  }
};
var SimpleType;

// packages/common/effect/src/jsonPath.ts
import { Schema as Schema2, Option as Option2 } from "effect";
import { JSONPath } from "jsonpath-plus";
import { invariant as invariant2 } from "@dxos/invariant";
var __dxlog_file2 = "/home/runner/work/dxos/dxos/packages/common/effect/src/jsonPath.ts";
var PATH_REGEX = /^($|[a-zA-Z_$][\w$]*(?:\.[a-zA-Z_$][\w$]*|\[\d+\](?:\.)?)*$)/;
var PROP_REGEX = /^\w+$/;
var JsonPath = Schema2.String.pipe(Schema2.pattern(PATH_REGEX)).annotations({
  title: "JSON path",
  description: "JSON path to a property"
});
var JsonProp = Schema2.NonEmptyString.pipe(Schema2.pattern(PROP_REGEX, {
  message: () => "Property name must contain only letters, numbers, and underscores"
}));
var isJsonPath = (value) => {
  return Option2.isSome(Schema2.validateOption(JsonPath)(value));
};
var createJsonPath = (path) => {
  const candidatePath = path.map((p, i) => {
    if (typeof p === "number") {
      return `[${p}]`;
    } else {
      return i === 0 ? p : `.${p}`;
    }
  }).join("");
  invariant2(isJsonPath(candidatePath), `Invalid JsonPath: ${candidatePath}`, {
    F: __dxlog_file2,
    L: 63,
    S: void 0,
    A: [
      "isJsonPath(candidatePath)",
      "`Invalid JsonPath: ${candidatePath}`"
    ]
  });
  return candidatePath;
};
var fromEffectValidationPath = (effectPath) => {
  const jsonPath = effectPath.replace(/\.\[(\d+)\]/g, "[$1]");
  invariant2(isJsonPath(jsonPath), `Invalid JsonPath: ${jsonPath}`, {
    F: __dxlog_file2,
    L: 74,
    S: void 0,
    A: [
      "isJsonPath(jsonPath)",
      "`Invalid JsonPath: ${jsonPath}`"
    ]
  });
  return jsonPath;
};
var splitJsonPath = (path) => {
  if (!isJsonPath(path)) {
    return [];
  }
  return path.match(/[a-zA-Z_$][\w$]*|\[\d+\]/g)?.map((part) => part.startsWith("[") ? part.replace(/[[\]]/g, "") : part) ?? [];
};
var getField = (object, path) => {
  return JSONPath({
    path,
    json: object
  })[0];
};

// packages/common/effect/src/url.ts
import { SchemaAST as SchemaAST2, Option as Option3, pipe as pipe2 } from "effect";
import { decamelize } from "@dxos/util";
var ParamKeyAnnotationId = Symbol.for("@dxos/schema/annotation/ParamKey");
var getParamKeyAnnotation = SchemaAST2.getAnnotation(ParamKeyAnnotationId);
var ParamKeyAnnotation = (value) => (self) => self.annotations({
  [ParamKeyAnnotationId]: value
});
var UrlParser = class {
  constructor(_schema) {
    this._schema = _schema;
  }
  /**
  * Parse URL params.
  */
  parse(_url) {
    const url = new URL(_url);
    return Object.entries(this._schema.fields).reduce((params, [key, type]) => {
      let value = url.searchParams.get(decamelize(key));
      if (value == null) {
        value = url.searchParams.get(key);
      }
      if (value != null) {
        if (SchemaAST2.isNumberKeyword(type.ast)) {
          params[key] = parseInt(value);
        } else if (SchemaAST2.isBooleanKeyword(type.ast)) {
          params[key] = value === "true" || value === "1";
        } else {
          params[key] = value;
        }
      }
      return params;
    }, {});
  }
  /**
  * Return URL with encoded params.
  */
  create(_url, params) {
    const url = new URL(_url);
    Object.entries(params).forEach(([key, value]) => {
      if (value !== void 0) {
        const field = this._schema.fields[key];
        if (field) {
          const { key: serializedKey } = pipe2(getParamKeyAnnotation(field.ast), Option3.getOrElse(() => ({
            key: decamelize(key)
          })));
          url.searchParams.set(serializedKey, String(value));
        }
      }
    });
    return url;
  }
};
export {
  JsonPath,
  JsonProp,
  ParamKeyAnnotation,
  SimpleType,
  UrlParser,
  VisitResult,
  createJsonPath,
  findAnnotation,
  findNode,
  findProperty,
  fromEffectValidationPath,
  getAnnotation,
  getDiscriminatedType,
  getDiscriminatingProps,
  getField,
  getParamKeyAnnotation,
  getSimpleType,
  isDiscriminatedUnion,
  isJsonPath,
  isLiteralUnion,
  isOption,
  isSimpleType,
  mapAst,
  splitJsonPath,
  visit
};
//# sourceMappingURL=index.mjs.map
