{
  "version": 3,
  "sources": ["../../../src/ast.ts", "../../../src/jsonPath.ts", "../../../src/url.ts"],
  "sourcesContent": ["//\n// Copyright 2024 DXOS.org\n//\n\nimport { Option, pipe, SchemaAST, Schema } from 'effect';\n\nimport { invariant } from '@dxos/invariant';\nimport { isNonNullable } from '@dxos/util';\n\nimport { type JsonPath, type JsonProp } from './jsonPath';\n\n//\n// Refs\n// https://effect.website/docs/schema/introduction\n// https://www.npmjs.com/package/@effect/schema\n// https://effect-ts.github.io/effect/schema/SchemaAST.ts.html\n//\n\nexport type SimpleType = 'object' | 'string' | 'number' | 'boolean' | 'enum' | 'literal';\n\n/**\n * Get the base type; e.g., traverse through refinements.\n */\nexport const getSimpleType = (node: SchemaAST.AST): SimpleType | undefined => {\n  if (\n    SchemaAST.isDeclaration(node) ||\n    SchemaAST.isObjectKeyword(node) ||\n    SchemaAST.isTypeLiteral(node) ||\n    isDiscriminatedUnion(node)\n  ) {\n    return 'object';\n  }\n\n  if (SchemaAST.isStringKeyword(node)) {\n    return 'string';\n  }\n  if (SchemaAST.isNumberKeyword(node)) {\n    return 'number';\n  }\n  if (SchemaAST.isBooleanKeyword(node)) {\n    return 'boolean';\n  }\n\n  if (SchemaAST.isEnums(node)) {\n    return 'enum';\n  }\n\n  if (SchemaAST.isLiteral(node)) {\n    return 'literal';\n  }\n};\n\nexport const isSimpleType = (node: SchemaAST.AST): boolean => !!getSimpleType(node);\n\nexport namespace SimpleType {\n  /**\n   * Returns the default empty value for a given SimpleType.\n   * Used for initializing new array values etc.\n   */\n  export const getDefaultValue = (type: SimpleType): any => {\n    switch (type) {\n      case 'string': {\n        return '';\n      }\n      case 'number': {\n        return 0;\n      }\n      case 'boolean': {\n        return false;\n      }\n      case 'object': {\n        return {};\n      }\n      default: {\n        throw new Error(`Unsupported type for default value: ${type}`);\n      }\n    }\n  };\n}\n\n//\n// Branded types\n//\n\nexport enum VisitResult {\n  CONTINUE = 0,\n  /**\n   * Skip visiting children.\n   */\n  SKIP = 1,\n  /**\n   * Stop traversing immediately.\n   */\n  EXIT = 2,\n}\n\nexport type Path = (string | number)[];\n\nexport type TestFn = (node: SchemaAST.AST, path: Path, depth: number) => VisitResult | boolean | undefined;\n\nexport type VisitorFn = (node: SchemaAST.AST, path: Path, depth: number) => void;\n\nconst defaultTest: TestFn = isSimpleType;\n\n/**\n * Visit leaf nodes.\n * Refs:\n * - https://github.com/syntax-tree/unist-util-visit?tab=readme-ov-file#visitor\n * - https://github.com/syntax-tree/unist-util-is?tab=readme-ov-file#test\n */\nexport const visit: {\n  (node: SchemaAST.AST, visitor: VisitorFn): void;\n  (node: SchemaAST.AST, test: TestFn, visitor: VisitorFn): void;\n} = (node: SchemaAST.AST, testOrVisitor: TestFn | VisitorFn, visitor?: VisitorFn): void => {\n  if (!visitor) {\n    visitNode(node, defaultTest, testOrVisitor);\n  } else {\n    visitNode(node, testOrVisitor as TestFn, visitor);\n  }\n};\n\nconst visitNode = (\n  node: SchemaAST.AST,\n  test: TestFn | undefined,\n  visitor: VisitorFn,\n  path: Path = [],\n  depth = 0,\n): VisitResult | undefined => {\n  const _result = test?.(node, path, depth);\n  const result: VisitResult =\n    _result === undefined\n      ? VisitResult.CONTINUE\n      : typeof _result === 'boolean'\n        ? _result\n          ? VisitResult.CONTINUE\n          : VisitResult.SKIP\n        : _result;\n\n  if (result === VisitResult.EXIT) {\n    return result;\n  }\n  if (result !== VisitResult.SKIP) {\n    visitor(node, path, depth);\n  }\n\n  // Object.\n  if (SchemaAST.isTypeLiteral(node)) {\n    for (const prop of SchemaAST.getPropertySignatures(node)) {\n      const currentPath = [...path, prop.name.toString()];\n      const result = visitNode(prop.type, test, visitor, currentPath, depth + 1);\n      if (result === VisitResult.EXIT) {\n        return result;\n      }\n    }\n  }\n\n  // Array.\n  else if (SchemaAST.isTupleType(node)) {\n    for (const [i, element] of node.elements.entries()) {\n      const currentPath = [...path, i];\n      const result = visitNode(element.type, test, visitor, currentPath, depth);\n      if (result === VisitResult.EXIT) {\n        return result;\n      }\n    }\n  }\n\n  // Branching union (e.g., optional, discriminated unions).\n  else if (SchemaAST.isUnion(node)) {\n    for (const type of node.types) {\n      const result = visitNode(type, test, visitor, path, depth);\n      if (result === VisitResult.EXIT) {\n        return result;\n      }\n    }\n  }\n\n  // Refinement.\n  else if (SchemaAST.isRefinement(node)) {\n    const result = visitNode(node.from, test, visitor, path, depth);\n    if (result === VisitResult.EXIT) {\n      return result;\n    }\n  }\n\n  // TODO(burdon): Transforms?\n};\n\n/**\n * Recursively descend into AST to find first node that passes the test.\n */\n// TODO(burdon): Rewrite using visitNode?\nexport const findNode = (node: SchemaAST.AST, test: (node: SchemaAST.AST) => boolean): SchemaAST.AST | undefined => {\n  if (test(node)) {\n    return node;\n  }\n\n  // Object.\n  else if (SchemaAST.isTypeLiteral(node)) {\n    for (const prop of SchemaAST.getPropertySignatures(node)) {\n      const child = findNode(prop.type, test);\n      if (child) {\n        return child;\n      }\n    }\n  }\n\n  // Tuple.\n  else if (SchemaAST.isTupleType(node)) {\n    for (const [_, element] of node.elements.entries()) {\n      const child = findNode(element.type, test);\n      if (child) {\n        return child;\n      }\n    }\n  }\n\n  // Branching union (e.g., optional, discriminated unions).\n  else if (SchemaAST.isUnion(node)) {\n    if (isOption(node)) {\n      for (const type of node.types) {\n        const child = findNode(type, test);\n        if (child) {\n          return child;\n        }\n      }\n    }\n  }\n\n  // Refinement.\n  else if (SchemaAST.isRefinement(node)) {\n    return findNode(node.from, test);\n  }\n};\n\n/**\n * Get the AST node for the given property (dot-path).\n */\nexport const findProperty = (\n  schema: Schema.Schema.AnyNoContext,\n  path: JsonPath | JsonProp,\n): SchemaAST.AST | undefined => {\n  const getProp = (node: SchemaAST.AST, path: JsonProp[]): SchemaAST.AST | undefined => {\n    const [name, ...rest] = path;\n    const typeNode = findNode(node, SchemaAST.isTypeLiteral);\n    invariant(typeNode);\n    for (const prop of SchemaAST.getPropertySignatures(typeNode)) {\n      if (prop.name === name) {\n        if (rest.length) {\n          return getProp(prop.type, rest);\n        } else {\n          return prop.type;\n        }\n      }\n    }\n  };\n\n  return getProp(schema.ast, path.split('.') as JsonProp[]);\n};\n\n//\n// Annotations\n//\n\nconst defaultAnnotations: Record<string, SchemaAST.Annotated> = {\n  ['ObjectKeyword' as const]: SchemaAST.objectKeyword,\n  ['StringKeyword' as const]: SchemaAST.stringKeyword,\n  ['NumberKeyword' as const]: SchemaAST.numberKeyword,\n  ['BooleanKeyword' as const]: SchemaAST.booleanKeyword,\n};\n\n/**\n * Get annotation or return undefined.\n * @param annotationId\n * @param noDefault If true, then return undefined for effect library defined values.\n */\nexport const getAnnotation =\n  <T>(annotationId: symbol, noDefault = true) =>\n  (node: SchemaAST.AST): T | undefined => {\n    // Title fallback seems to be the identifier.\n    const id = pipe(SchemaAST.getIdentifierAnnotation(node), Option.getOrUndefined);\n    const value = pipe(SchemaAST.getAnnotation<T>(annotationId)(node), Option.getOrUndefined);\n    if (noDefault && (value === defaultAnnotations[node._tag]?.annotations[annotationId] || value === id)) {\n      return undefined;\n    }\n\n    return value;\n  };\n\n/**\n * Recursively descend into AST to find first matching annotations.\n * Optionally skips default annotations for basic types (e.g., 'a string').\n */\n// TODO(burdon): Convert to effect pattern (i.e., return operator like getAnnotation).\nexport const findAnnotation = <T>(node: SchemaAST.AST, annotationId: symbol, noDefault = true): T | undefined => {\n  const getAnnotationById = getAnnotation(annotationId, noDefault);\n\n  const getBaseAnnotation = (node: SchemaAST.AST): T | undefined => {\n    const value = getAnnotationById(node);\n    if (value !== undefined) {\n      return value as T;\n    }\n\n    if (SchemaAST.isUnion(node)) {\n      if (isOption(node)) {\n        return getAnnotationById(node.types[0]) as T;\n      }\n    }\n  };\n\n  return getBaseAnnotation(node);\n};\n\n//\n// Unions\n//\n\n/**\n * Effect Schema.optional creates a union type with undefined as the second type.\n */\nexport const isOption = (node: SchemaAST.AST): boolean => {\n  return SchemaAST.isUnion(node) && node.types.length === 2 && SchemaAST.isUndefinedKeyword(node.types[1]);\n};\n\n/**\n * Determines if the node is a union of literal types.\n */\nexport const isLiteralUnion = (node: SchemaAST.AST): boolean => {\n  return SchemaAST.isUnion(node) && node.types.every(SchemaAST.isLiteral);\n};\n\n/**\n * Determines if the node is a discriminated union.\n */\nexport const isDiscriminatedUnion = (node: SchemaAST.AST): boolean => {\n  return SchemaAST.isUnion(node) && !!getDiscriminatingProps(node)?.length;\n};\n\n/**\n * Get the discriminating properties for the given union type.\n */\nexport const getDiscriminatingProps = (node: SchemaAST.AST): string[] | undefined => {\n  invariant(SchemaAST.isUnion(node));\n  if (isOption(node)) {\n    return;\n  }\n\n  // Get common literals across all types.\n  return node.types.reduce<string[]>((shared, type) => {\n    const props = SchemaAST.getPropertySignatures(type)\n      // TODO(burdon): Should check each literal is unique.\n      .filter((p) => SchemaAST.isLiteral(p.type))\n      .map((p) => p.name.toString());\n\n    // Return common literals.\n    return shared.length === 0 ? props : shared.filter((prop) => props.includes(prop));\n  }, []);\n};\n\n/**\n * Get the discriminated type for the given value.\n */\nexport const getDiscriminatedType = (\n  node: SchemaAST.AST,\n  value: Record<string, any> = {},\n): SchemaAST.AST | undefined => {\n  invariant(SchemaAST.isUnion(node));\n  invariant(value);\n  const props = getDiscriminatingProps(node);\n  if (!props?.length) {\n    return;\n  }\n\n  // Match provided values.\n  for (const type of node.types) {\n    const match = SchemaAST.getPropertySignatures(type)\n      .filter((prop) => props?.includes(prop.name.toString()))\n      .every((prop) => {\n        invariant(SchemaAST.isLiteral(prop.type));\n        return prop.type.literal === value[prop.name.toString()];\n      });\n\n    if (match) {\n      return type;\n    }\n  }\n\n  // Create union of discriminating properties.\n  // NOTE: This may not work with non-overlapping variants.\n  // TODO(burdon): Iterate through props and knock-out variants that don't match.\n  const fields = Object.fromEntries(\n    props\n      .map((prop) => {\n        const literals = node.types\n          .map((type) => {\n            const literal = SchemaAST.getPropertySignatures(type).find((p) => p.name.toString() === prop)!;\n            invariant(SchemaAST.isLiteral(literal.type));\n            return literal.type.literal;\n          })\n          .filter(isNonNullable);\n\n        return literals.length ? [prop, Schema.Literal(...literals)] : undefined;\n      })\n      .filter(isNonNullable),\n  );\n\n  const schema = Schema.Struct(fields);\n  return schema.ast;\n};\n\n/**\n * Maps AST nodes.\n * The user is responsible for recursively calling {@link mapAst} on the SchemaAST.\n * NOTE: Will evaluate suspended ASTs.\n */\nexport const mapAst = (\n  ast: SchemaAST.AST,\n  f: (ast: SchemaAST.AST, key: keyof any | undefined) => SchemaAST.AST,\n): SchemaAST.AST => {\n  switch (ast._tag) {\n    case 'TypeLiteral': {\n      return new SchemaAST.TypeLiteral(\n        ast.propertySignatures.map(\n          (prop) =>\n            new SchemaAST.PropertySignature(\n              prop.name,\n              f(prop.type, prop.name),\n              prop.isOptional,\n              prop.isReadonly,\n              prop.annotations,\n            ),\n        ),\n        ast.indexSignatures,\n      );\n    }\n    case 'Union': {\n      return SchemaAST.Union.make(ast.types.map(f), ast.annotations);\n    }\n    case 'TupleType': {\n      return new SchemaAST.TupleType(\n        ast.elements.map((t, index) => new SchemaAST.OptionalType(f(t.type, index), t.isOptional, t.annotations)),\n        ast.rest.map((t) => new SchemaAST.Type(f(t.type, undefined), t.annotations)),\n        ast.isReadonly,\n        ast.annotations,\n      );\n    }\n    case 'Suspend': {\n      const newAst = f(ast.f(), undefined);\n      return new SchemaAST.Suspend(() => newAst, ast.annotations);\n    }\n    default: {\n      // TODO(dmaretskyi): Support more nodes.\n      return ast;\n    }\n  }\n};\n", "//\n// Copyright 2025 DXOS.org\n//\n\nimport { Schema, Option } from 'effect';\nimport { JSONPath } from 'jsonpath-plus';\n\nimport { invariant } from '@dxos/invariant';\n\nexport type JsonProp = string & { __JsonPath: true; __JsonProp: true };\nexport type JsonPath = string & { __JsonPath: true };\n\nconst PATH_REGEX = /^($|[a-zA-Z_$][\\w$]*(?:\\.[a-zA-Z_$][\\w$]*|\\[\\d+\\](?:\\.)?)*$)/;\nconst PROP_REGEX = /^\\w+$/;\n\n/**\n * https://www.ietf.org/archive/id/draft-goessner-dispatch-jsonpath-00.html\n */\nexport const JsonPath = Schema.String.pipe(Schema.pattern(PATH_REGEX)).annotations({\n  title: 'JSON path',\n  description: 'JSON path to a property',\n}) as any as Schema.Schema<JsonPath>;\nexport const JsonProp = Schema.NonEmptyString.pipe(\n  Schema.pattern(PROP_REGEX, {\n    message: () => 'Property name must contain only letters, numbers, and underscores',\n  }),\n) as any as Schema.Schema<JsonProp>;\n\nexport const isJsonPath = (value: unknown): value is JsonPath => {\n  return Option.isSome(Schema.validateOption(JsonPath)(value));\n};\n\n/**\n * Creates a JsonPath from an array of path segments.\n *\n * Currently supports:\n * - Simple property access (e.g., 'foo.bar')\n * - Array indexing with non-negative integers (e.g., 'foo[0]')\n * - Identifiers starting with letters, underscore, or $ (e.g., '$foo', '_bar')\n * - Dot notation for nested properties (e.g., 'foo.bar.baz')\n *\n * Does not support (yet?).\n * - Recursive descent (..)\n * - Wildcards (*)\n * - Array slicing\n * - Filters\n * - Negative indices\n *\n * @param path Array of string or number segments\n * @returns Valid JsonPath or undefined if invalid\n */\nexport const createJsonPath = (path: (string | number)[]): JsonPath => {\n  const candidatePath = path\n    .map((p, i) => {\n      if (typeof p === 'number') {\n        return `[${p}]`;\n      } else {\n        return i === 0 ? p : `.${p}`;\n      }\n    })\n    .join('');\n\n  invariant(isJsonPath(candidatePath), `Invalid JsonPath: ${candidatePath}`);\n  return candidatePath;\n};\n\n/**\n * Converts Effect validation path format (e.g. \"addresses.[0].zip\")\n * to JsonPath format (e.g., \"addresses[0].zip\")\n */\nexport const fromEffectValidationPath = (effectPath: string): JsonPath => {\n  // Handle array notation: convert \"prop.[0]\" to \"prop[0]\"\n  const jsonPath = effectPath.replace(/\\.\\[(\\d+)\\]/g, '[$1]');\n  invariant(isJsonPath(jsonPath), `Invalid JsonPath: ${jsonPath}`);\n  return jsonPath;\n};\n\n/**\n * Splits a JsonPath into its constituent parts.\n * Handles property access and array indexing.\n */\nexport const splitJsonPath = (path: JsonPath): string[] => {\n  if (!isJsonPath(path)) {\n    return [];\n  }\n\n  return (\n    path\n      .match(/[a-zA-Z_$][\\w$]*|\\[\\d+\\]/g)\n      ?.map((part) => (part.startsWith('[') ? part.replace(/[[\\]]/g, '') : part)) ?? []\n  );\n};\n\n/**\n * Applies a JsonPath to an object.\n */\nexport const getField = (object: any, path: JsonPath): any => {\n  // By default, JSONPath returns an array of results.\n  return JSONPath({ path, json: object })[0];\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { SchemaAST, type Schema, Option, pipe } from 'effect';\n\nimport { decamelize } from '@dxos/util';\n\nconst ParamKeyAnnotationId = Symbol.for('@dxos/schema/annotation/ParamKey');\n\ntype ParamKeyAnnotationValue = { key: string };\n\nexport const getParamKeyAnnotation: (annotated: SchemaAST.Annotated) => Option.Option<ParamKeyAnnotationValue> =\n  SchemaAST.getAnnotation<ParamKeyAnnotationValue>(ParamKeyAnnotationId);\n\nexport const ParamKeyAnnotation =\n  (value: ParamKeyAnnotationValue) =>\n  <S extends Schema.Annotable.All>(self: S): Schema.Annotable.Self<S> =>\n    self.annotations({ [ParamKeyAnnotationId]: value });\n\n/**\n * HTTP params parser.\n * Supports custom key serialization.\n */\nexport class UrlParser<T extends Record<string, any>> {\n  constructor(private readonly _schema: Schema.Struct<T>) {}\n\n  /**\n   * Parse URL params.\n   */\n  parse(_url: string): T {\n    const url = new URL(_url);\n    return Object.entries(this._schema.fields).reduce<Record<string, any>>((params, [key, type]) => {\n      let value = url.searchParams.get(decamelize(key));\n      if (value == null) {\n        value = url.searchParams.get(key);\n      }\n\n      if (value != null) {\n        if (SchemaAST.isNumberKeyword(type.ast)) {\n          params[key] = parseInt(value);\n        } else if (SchemaAST.isBooleanKeyword(type.ast)) {\n          params[key] = value === 'true' || value === '1';\n        } else {\n          params[key] = value;\n        }\n      }\n\n      return params;\n    }, {}) as T;\n  }\n\n  /**\n   * Return URL with encoded params.\n   */\n  create(_url: string, params: T): URL {\n    const url = new URL(_url);\n    Object.entries(params).forEach(([key, value]) => {\n      if (value !== undefined) {\n        const field = this._schema.fields[key];\n        if (field) {\n          const { key: serializedKey } = pipe(\n            getParamKeyAnnotation(field.ast),\n            Option.getOrElse(() => ({\n              key: decamelize(key),\n            })),\n          );\n\n          url.searchParams.set(serializedKey, String(value));\n        }\n      }\n    });\n\n    return url;\n  }\n}\n"],
  "mappings": "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",
  "names": ["import_effect", "import_invariant", "import_util", "getSimpleType", "node", "SchemaAST", "isDeclaration", "isObjectKeyword", "isTypeLiteral", "isDiscriminatedUnion", "isStringKeyword", "isNumberKeyword", "isBooleanKeyword", "isEnums", "isLiteral", "isSimpleType", "SimpleType", "getDefaultValue", "type", "Error", "VisitResult", "defaultTest", "visit", "testOrVisitor", "visitor", "visitNode", "test", "path", "depth", "_result", "result", "undefined", "prop", "getPropertySignatures", "currentPath", "name", "toString", "isTupleType", "i", "element", "elements", "entries", "isUnion", "types", "isRefinement", "from", "findNode", "child", "_", "isOption", "findProperty", "schema", "getProp", "rest", "typeNode", "invariant", "length", "ast", "split", "defaultAnnotations", "objectKeyword", "stringKeyword", "numberKeyword", "booleanKeyword", "getAnnotation", "annotationId", "noDefault", "id", "pipe", "getIdentifierAnnotation", "Option", "getOrUndefined", "value", "_tag", "annotations", "findAnnotation", "getAnnotationById", "getBaseAnnotation", "isUndefinedKeyword", "isLiteralUnion", "every", "getDiscriminatingProps", "reduce", "shared", "props", "filter", "p", "map", "includes", "getDiscriminatedType", "match", "literal", "fields", "Object", "fromEntries", "literals", "find", "isNonNullable", "Schema", "Literal", "Struct", "mapAst", "f", "TypeLiteral", "propertySignatures", "PropertySignature", "isOptional", "isReadonly", "indexSignatures", "Union", "make", "TupleType", "t", "index", "OptionalType", "Type", "newAst", "Suspend", "PATH_REGEX", "PROP_REGEX", "JsonPath", "String", "pattern", "title", "description", "JsonProp", "NonEmptyString", "message", "isJsonPath", "isSome", "validateOption", "createJsonPath", "candidatePath", "join", "fromEffectValidationPath", "effectPath", "jsonPath", "replace", "splitJsonPath", "part", "startsWith", "getField", "object", "JSONPath", "json", "ParamKeyAnnotationId", "Symbol", "for", "getParamKeyAnnotation", "ParamKeyAnnotation", "self", "UrlParser", "_schema", "parse", "_url", "url", "URL", "params", "key", "searchParams", "get", "decamelize", "parseInt", "create", "forEach", "field", "serializedKey", "getOrElse", "set"]
}
