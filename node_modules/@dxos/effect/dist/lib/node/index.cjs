"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var node_exports = {};
__export(node_exports, {
  JsonPath: () => JsonPath,
  JsonProp: () => JsonProp,
  ParamKeyAnnotation: () => ParamKeyAnnotation,
  SimpleType: () => SimpleType,
  UrlParser: () => UrlParser,
  VisitResult: () => VisitResult,
  createJsonPath: () => createJsonPath,
  findAnnotation: () => findAnnotation,
  findNode: () => findNode,
  findProperty: () => findProperty,
  fromEffectValidationPath: () => fromEffectValidationPath,
  getAnnotation: () => getAnnotation,
  getDiscriminatedType: () => getDiscriminatedType,
  getDiscriminatingProps: () => getDiscriminatingProps,
  getField: () => getField,
  getParamKeyAnnotation: () => getParamKeyAnnotation,
  getSimpleType: () => getSimpleType,
  isDiscriminatedUnion: () => isDiscriminatedUnion,
  isJsonPath: () => isJsonPath,
  isLiteralUnion: () => isLiteralUnion,
  isOption: () => isOption,
  isSimpleType: () => isSimpleType,
  mapAst: () => mapAst,
  splitJsonPath: () => splitJsonPath,
  visit: () => visit
});
module.exports = __toCommonJS(node_exports);
var import_effect = require("effect");
var import_invariant = require("@dxos/invariant");
var import_util = require("@dxos/util");
var import_effect2 = require("effect");
var import_jsonpath_plus = require("jsonpath-plus");
var import_invariant2 = require("@dxos/invariant");
var import_effect3 = require("effect");
var import_util2 = require("@dxos/util");
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/common/effect/src/ast.ts";
var getSimpleType = (node) => {
  if (import_effect.SchemaAST.isDeclaration(node) || import_effect.SchemaAST.isObjectKeyword(node) || import_effect.SchemaAST.isTypeLiteral(node) || isDiscriminatedUnion(node)) {
    return "object";
  }
  if (import_effect.SchemaAST.isStringKeyword(node)) {
    return "string";
  }
  if (import_effect.SchemaAST.isNumberKeyword(node)) {
    return "number";
  }
  if (import_effect.SchemaAST.isBooleanKeyword(node)) {
    return "boolean";
  }
  if (import_effect.SchemaAST.isEnums(node)) {
    return "enum";
  }
  if (import_effect.SchemaAST.isLiteral(node)) {
    return "literal";
  }
};
var isSimpleType = (node) => !!getSimpleType(node);
(function(SimpleType2) {
  SimpleType2.getDefaultValue = (type) => {
    switch (type) {
      case "string": {
        return "";
      }
      case "number": {
        return 0;
      }
      case "boolean": {
        return false;
      }
      case "object": {
        return {};
      }
      default: {
        throw new Error(`Unsupported type for default value: ${type}`);
      }
    }
  };
})(SimpleType || (SimpleType = {}));
var VisitResult = /* @__PURE__ */ function(VisitResult2) {
  VisitResult2[VisitResult2["CONTINUE"] = 0] = "CONTINUE";
  VisitResult2[VisitResult2["SKIP"] = 1] = "SKIP";
  VisitResult2[VisitResult2["EXIT"] = 2] = "EXIT";
  return VisitResult2;
}({});
var defaultTest = isSimpleType;
var visit = (node, testOrVisitor, visitor) => {
  if (!visitor) {
    visitNode(node, defaultTest, testOrVisitor);
  } else {
    visitNode(node, testOrVisitor, visitor);
  }
};
var visitNode = (node, test, visitor, path = [], depth = 0) => {
  const _result = test?.(node, path, depth);
  const result = _result === void 0 ? 0 : typeof _result === "boolean" ? _result ? 0 : 1 : _result;
  if (result === 2) {
    return result;
  }
  if (result !== 1) {
    visitor(node, path, depth);
  }
  if (import_effect.SchemaAST.isTypeLiteral(node)) {
    for (const prop of import_effect.SchemaAST.getPropertySignatures(node)) {
      const currentPath = [
        ...path,
        prop.name.toString()
      ];
      const result2 = visitNode(prop.type, test, visitor, currentPath, depth + 1);
      if (result2 === 2) {
        return result2;
      }
    }
  } else if (import_effect.SchemaAST.isTupleType(node)) {
    for (const [i, element] of node.elements.entries()) {
      const currentPath = [
        ...path,
        i
      ];
      const result2 = visitNode(element.type, test, visitor, currentPath, depth);
      if (result2 === 2) {
        return result2;
      }
    }
  } else if (import_effect.SchemaAST.isUnion(node)) {
    for (const type of node.types) {
      const result2 = visitNode(type, test, visitor, path, depth);
      if (result2 === 2) {
        return result2;
      }
    }
  } else if (import_effect.SchemaAST.isRefinement(node)) {
    const result2 = visitNode(node.from, test, visitor, path, depth);
    if (result2 === 2) {
      return result2;
    }
  }
};
var findNode = (node, test) => {
  if (test(node)) {
    return node;
  } else if (import_effect.SchemaAST.isTypeLiteral(node)) {
    for (const prop of import_effect.SchemaAST.getPropertySignatures(node)) {
      const child = findNode(prop.type, test);
      if (child) {
        return child;
      }
    }
  } else if (import_effect.SchemaAST.isTupleType(node)) {
    for (const [_, element] of node.elements.entries()) {
      const child = findNode(element.type, test);
      if (child) {
        return child;
      }
    }
  } else if (import_effect.SchemaAST.isUnion(node)) {
    if (isOption(node)) {
      for (const type of node.types) {
        const child = findNode(type, test);
        if (child) {
          return child;
        }
      }
    }
  } else if (import_effect.SchemaAST.isRefinement(node)) {
    return findNode(node.from, test);
  }
};
var findProperty = (schema, path) => {
  const getProp = (node, path2) => {
    const [name, ...rest] = path2;
    const typeNode = findNode(node, import_effect.SchemaAST.isTypeLiteral);
    (0, import_invariant.invariant)(typeNode, void 0, {
      F: __dxlog_file,
      L: 246,
      S: void 0,
      A: [
        "typeNode",
        ""
      ]
    });
    for (const prop of import_effect.SchemaAST.getPropertySignatures(typeNode)) {
      if (prop.name === name) {
        if (rest.length) {
          return getProp(prop.type, rest);
        } else {
          return prop.type;
        }
      }
    }
  };
  return getProp(schema.ast, path.split("."));
};
var defaultAnnotations = {
  ["ObjectKeyword"]: import_effect.SchemaAST.objectKeyword,
  ["StringKeyword"]: import_effect.SchemaAST.stringKeyword,
  ["NumberKeyword"]: import_effect.SchemaAST.numberKeyword,
  ["BooleanKeyword"]: import_effect.SchemaAST.booleanKeyword
};
var getAnnotation = (annotationId, noDefault = true) => (node) => {
  const id = (0, import_effect.pipe)(import_effect.SchemaAST.getIdentifierAnnotation(node), import_effect.Option.getOrUndefined);
  const value = (0, import_effect.pipe)(import_effect.SchemaAST.getAnnotation(annotationId)(node), import_effect.Option.getOrUndefined);
  if (noDefault && (value === defaultAnnotations[node._tag]?.annotations[annotationId] || value === id)) {
    return void 0;
  }
  return value;
};
var findAnnotation = (node, annotationId, noDefault = true) => {
  const getAnnotationById = getAnnotation(annotationId, noDefault);
  const getBaseAnnotation = (node2) => {
    const value = getAnnotationById(node2);
    if (value !== void 0) {
      return value;
    }
    if (import_effect.SchemaAST.isUnion(node2)) {
      if (isOption(node2)) {
        return getAnnotationById(node2.types[0]);
      }
    }
  };
  return getBaseAnnotation(node);
};
var isOption = (node) => {
  return import_effect.SchemaAST.isUnion(node) && node.types.length === 2 && import_effect.SchemaAST.isUndefinedKeyword(node.types[1]);
};
var isLiteralUnion = (node) => {
  return import_effect.SchemaAST.isUnion(node) && node.types.every(import_effect.SchemaAST.isLiteral);
};
var isDiscriminatedUnion = (node) => {
  return import_effect.SchemaAST.isUnion(node) && !!getDiscriminatingProps(node)?.length;
};
var getDiscriminatingProps = (node) => {
  (0, import_invariant.invariant)(import_effect.SchemaAST.isUnion(node), void 0, {
    F: __dxlog_file,
    L: 343,
    S: void 0,
    A: [
      "SchemaAST.isUnion(node)",
      ""
    ]
  });
  if (isOption(node)) {
    return;
  }
  return node.types.reduce((shared, type) => {
    const props = import_effect.SchemaAST.getPropertySignatures(type).filter((p) => import_effect.SchemaAST.isLiteral(p.type)).map((p) => p.name.toString());
    return shared.length === 0 ? props : shared.filter((prop) => props.includes(prop));
  }, []);
};
var getDiscriminatedType = (node, value = {}) => {
  (0, import_invariant.invariant)(import_effect.SchemaAST.isUnion(node), void 0, {
    F: __dxlog_file,
    L: 367,
    S: void 0,
    A: [
      "SchemaAST.isUnion(node)",
      ""
    ]
  });
  (0, import_invariant.invariant)(value, void 0, {
    F: __dxlog_file,
    L: 368,
    S: void 0,
    A: [
      "value",
      ""
    ]
  });
  const props = getDiscriminatingProps(node);
  if (!props?.length) {
    return;
  }
  for (const type of node.types) {
    const match = import_effect.SchemaAST.getPropertySignatures(type).filter((prop) => props?.includes(prop.name.toString())).every((prop) => {
      (0, import_invariant.invariant)(import_effect.SchemaAST.isLiteral(prop.type), void 0, {
        F: __dxlog_file,
        L: 379,
        S: void 0,
        A: [
          "SchemaAST.isLiteral(prop.type)",
          ""
        ]
      });
      return prop.type.literal === value[prop.name.toString()];
    });
    if (match) {
      return type;
    }
  }
  const fields = Object.fromEntries(props.map((prop) => {
    const literals = node.types.map((type) => {
      const literal = import_effect.SchemaAST.getPropertySignatures(type).find((p) => p.name.toString() === prop);
      (0, import_invariant.invariant)(import_effect.SchemaAST.isLiteral(literal.type), void 0, {
        F: __dxlog_file,
        L: 397,
        S: void 0,
        A: [
          "SchemaAST.isLiteral(literal.type)",
          ""
        ]
      });
      return literal.type.literal;
    }).filter(import_util.isNonNullable);
    return literals.length ? [
      prop,
      import_effect.Schema.Literal(...literals)
    ] : void 0;
  }).filter(import_util.isNonNullable));
  const schema = import_effect.Schema.Struct(fields);
  return schema.ast;
};
var mapAst = (ast, f) => {
  switch (ast._tag) {
    case "TypeLiteral": {
      return new import_effect.SchemaAST.TypeLiteral(ast.propertySignatures.map((prop) => new import_effect.SchemaAST.PropertySignature(prop.name, f(prop.type, prop.name), prop.isOptional, prop.isReadonly, prop.annotations)), ast.indexSignatures);
    }
    case "Union": {
      return import_effect.SchemaAST.Union.make(ast.types.map(f), ast.annotations);
    }
    case "TupleType": {
      return new import_effect.SchemaAST.TupleType(ast.elements.map((t, index) => new import_effect.SchemaAST.OptionalType(f(t.type, index), t.isOptional, t.annotations)), ast.rest.map((t) => new import_effect.SchemaAST.Type(f(t.type, void 0), t.annotations)), ast.isReadonly, ast.annotations);
    }
    case "Suspend": {
      const newAst = f(ast.f(), void 0);
      return new import_effect.SchemaAST.Suspend(() => newAst, ast.annotations);
    }
    default: {
      return ast;
    }
  }
};
var SimpleType;
var __dxlog_file2 = "/home/runner/work/dxos/dxos/packages/common/effect/src/jsonPath.ts";
var PATH_REGEX = /^($|[a-zA-Z_$][\w$]*(?:\.[a-zA-Z_$][\w$]*|\[\d+\](?:\.)?)*$)/;
var PROP_REGEX = /^\w+$/;
var JsonPath = import_effect2.Schema.String.pipe(import_effect2.Schema.pattern(PATH_REGEX)).annotations({
  title: "JSON path",
  description: "JSON path to a property"
});
var JsonProp = import_effect2.Schema.NonEmptyString.pipe(import_effect2.Schema.pattern(PROP_REGEX, {
  message: () => "Property name must contain only letters, numbers, and underscores"
}));
var isJsonPath = (value) => {
  return import_effect2.Option.isSome(import_effect2.Schema.validateOption(JsonPath)(value));
};
var createJsonPath = (path) => {
  const candidatePath = path.map((p, i) => {
    if (typeof p === "number") {
      return `[${p}]`;
    } else {
      return i === 0 ? p : `.${p}`;
    }
  }).join("");
  (0, import_invariant2.invariant)(isJsonPath(candidatePath), `Invalid JsonPath: ${candidatePath}`, {
    F: __dxlog_file2,
    L: 63,
    S: void 0,
    A: [
      "isJsonPath(candidatePath)",
      "`Invalid JsonPath: ${candidatePath}`"
    ]
  });
  return candidatePath;
};
var fromEffectValidationPath = (effectPath) => {
  const jsonPath = effectPath.replace(/\.\[(\d+)\]/g, "[$1]");
  (0, import_invariant2.invariant)(isJsonPath(jsonPath), `Invalid JsonPath: ${jsonPath}`, {
    F: __dxlog_file2,
    L: 74,
    S: void 0,
    A: [
      "isJsonPath(jsonPath)",
      "`Invalid JsonPath: ${jsonPath}`"
    ]
  });
  return jsonPath;
};
var splitJsonPath = (path) => {
  if (!isJsonPath(path)) {
    return [];
  }
  return path.match(/[a-zA-Z_$][\w$]*|\[\d+\]/g)?.map((part) => part.startsWith("[") ? part.replace(/[[\]]/g, "") : part) ?? [];
};
var getField = (object, path) => {
  return (0, import_jsonpath_plus.JSONPath)({
    path,
    json: object
  })[0];
};
var ParamKeyAnnotationId = Symbol.for("@dxos/schema/annotation/ParamKey");
var getParamKeyAnnotation = import_effect3.SchemaAST.getAnnotation(ParamKeyAnnotationId);
var ParamKeyAnnotation = (value) => (self) => self.annotations({
  [ParamKeyAnnotationId]: value
});
var UrlParser = class {
  constructor(_schema) {
    this._schema = _schema;
  }
  /**
  * Parse URL params.
  */
  parse(_url) {
    const url = new URL(_url);
    return Object.entries(this._schema.fields).reduce((params, [key, type]) => {
      let value = url.searchParams.get((0, import_util2.decamelize)(key));
      if (value == null) {
        value = url.searchParams.get(key);
      }
      if (value != null) {
        if (import_effect3.SchemaAST.isNumberKeyword(type.ast)) {
          params[key] = parseInt(value);
        } else if (import_effect3.SchemaAST.isBooleanKeyword(type.ast)) {
          params[key] = value === "true" || value === "1";
        } else {
          params[key] = value;
        }
      }
      return params;
    }, {});
  }
  /**
  * Return URL with encoded params.
  */
  create(_url, params) {
    const url = new URL(_url);
    Object.entries(params).forEach(([key, value]) => {
      if (value !== void 0) {
        const field = this._schema.fields[key];
        if (field) {
          const { key: serializedKey } = (0, import_effect3.pipe)(getParamKeyAnnotation(field.ast), import_effect3.Option.getOrElse(() => ({
            key: (0, import_util2.decamelize)(key)
          })));
          url.searchParams.set(serializedKey, String(value));
        }
      }
    });
    return url;
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  JsonPath,
  JsonProp,
  ParamKeyAnnotation,
  SimpleType,
  UrlParser,
  VisitResult,
  createJsonPath,
  findAnnotation,
  findNode,
  findProperty,
  fromEffectValidationPath,
  getAnnotation,
  getDiscriminatedType,
  getDiscriminatingProps,
  getField,
  getParamKeyAnnotation,
  getSimpleType,
  isDiscriminatedUnion,
  isJsonPath,
  isLiteralUnion,
  isOption,
  isSimpleType,
  mapAst,
  splitJsonPath,
  visit
});
//# sourceMappingURL=index.cjs.map
