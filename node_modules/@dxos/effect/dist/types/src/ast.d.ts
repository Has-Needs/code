import { SchemaAST, Schema } from 'effect';
import { type JsonPath, type JsonProp } from './jsonPath';
export type SimpleType = 'object' | 'string' | 'number' | 'boolean' | 'enum' | 'literal';
/**
 * Get the base type; e.g., traverse through refinements.
 */
export declare const getSimpleType: (node: SchemaAST.AST) => SimpleType | undefined;
export declare const isSimpleType: (node: SchemaAST.AST) => boolean;
export declare namespace SimpleType {
    /**
     * Returns the default empty value for a given SimpleType.
     * Used for initializing new array values etc.
     */
    const getDefaultValue: (type: SimpleType) => any;
}
export declare enum VisitResult {
    CONTINUE = 0,
    /**
     * Skip visiting children.
     */
    SKIP = 1,
    /**
     * Stop traversing immediately.
     */
    EXIT = 2
}
export type Path = (string | number)[];
export type TestFn = (node: SchemaAST.AST, path: Path, depth: number) => VisitResult | boolean | undefined;
export type VisitorFn = (node: SchemaAST.AST, path: Path, depth: number) => void;
/**
 * Visit leaf nodes.
 * Refs:
 * - https://github.com/syntax-tree/unist-util-visit?tab=readme-ov-file#visitor
 * - https://github.com/syntax-tree/unist-util-is?tab=readme-ov-file#test
 */
export declare const visit: {
    (node: SchemaAST.AST, visitor: VisitorFn): void;
    (node: SchemaAST.AST, test: TestFn, visitor: VisitorFn): void;
};
/**
 * Recursively descend into AST to find first node that passes the test.
 */
export declare const findNode: (node: SchemaAST.AST, test: (node: SchemaAST.AST) => boolean) => SchemaAST.AST | undefined;
/**
 * Get the AST node for the given property (dot-path).
 */
export declare const findProperty: (schema: Schema.Schema.AnyNoContext, path: JsonPath | JsonProp) => SchemaAST.AST | undefined;
/**
 * Get annotation or return undefined.
 * @param annotationId
 * @param noDefault If true, then return undefined for effect library defined values.
 */
export declare const getAnnotation: <T>(annotationId: symbol, noDefault?: boolean) => (node: SchemaAST.AST) => T | undefined;
/**
 * Recursively descend into AST to find first matching annotations.
 * Optionally skips default annotations for basic types (e.g., 'a string').
 */
export declare const findAnnotation: <T>(node: SchemaAST.AST, annotationId: symbol, noDefault?: boolean) => T | undefined;
/**
 * Effect Schema.optional creates a union type with undefined as the second type.
 */
export declare const isOption: (node: SchemaAST.AST) => boolean;
/**
 * Determines if the node is a union of literal types.
 */
export declare const isLiteralUnion: (node: SchemaAST.AST) => boolean;
/**
 * Determines if the node is a discriminated union.
 */
export declare const isDiscriminatedUnion: (node: SchemaAST.AST) => boolean;
/**
 * Get the discriminating properties for the given union type.
 */
export declare const getDiscriminatingProps: (node: SchemaAST.AST) => string[] | undefined;
/**
 * Get the discriminated type for the given value.
 */
export declare const getDiscriminatedType: (node: SchemaAST.AST, value?: Record<string, any>) => SchemaAST.AST | undefined;
/**
 * Maps AST nodes.
 * The user is responsible for recursively calling {@link mapAst} on the SchemaAST.
 * NOTE: Will evaluate suspended ASTs.
 */
export declare const mapAst: (ast: SchemaAST.AST, f: (ast: SchemaAST.AST, key: keyof any | undefined) => SchemaAST.AST) => SchemaAST.AST;
//# sourceMappingURL=ast.d.ts.map