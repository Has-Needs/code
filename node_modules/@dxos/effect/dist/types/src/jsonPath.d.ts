import { Schema } from 'effect';
export type JsonProp = string & {
    __JsonPath: true;
    __JsonProp: true;
};
export type JsonPath = string & {
    __JsonPath: true;
};
/**
 * https://www.ietf.org/archive/id/draft-goessner-dispatch-jsonpath-00.html
 */
export declare const JsonPath: Schema.Schema<JsonPath>;
export declare const JsonProp: Schema.Schema<JsonProp>;
export declare const isJsonPath: (value: unknown) => value is JsonPath;
/**
 * Creates a JsonPath from an array of path segments.
 *
 * Currently supports:
 * - Simple property access (e.g., 'foo.bar')
 * - Array indexing with non-negative integers (e.g., 'foo[0]')
 * - Identifiers starting with letters, underscore, or $ (e.g., '$foo', '_bar')
 * - Dot notation for nested properties (e.g., 'foo.bar.baz')
 *
 * Does not support (yet?).
 * - Recursive descent (..)
 * - Wildcards (*)
 * - Array slicing
 * - Filters
 * - Negative indices
 *
 * @param path Array of string or number segments
 * @returns Valid JsonPath or undefined if invalid
 */
export declare const createJsonPath: (path: (string | number)[]) => JsonPath;
/**
 * Converts Effect validation path format (e.g. "addresses.[0].zip")
 * to JsonPath format (e.g., "addresses[0].zip")
 */
export declare const fromEffectValidationPath: (effectPath: string) => JsonPath;
/**
 * Splits a JsonPath into its constituent parts.
 * Handles property access and array indexing.
 */
export declare const splitJsonPath: (path: JsonPath) => string[];
/**
 * Applies a JsonPath to an object.
 */
export declare const getField: (object: any, path: JsonPath) => any;
//# sourceMappingURL=jsonPath.d.ts.map