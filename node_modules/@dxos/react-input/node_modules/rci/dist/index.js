import { useCodeInput } from 'use-code-input';
export { useCodeInput } from 'use-code-input';
import { jsx, Fragment, jsxs } from 'react/jsx-runtime';
import React, { useContext } from 'react';

const LengthContext = React.createContext(6);
const useLengthContext = () => useContext(LengthContext);
const SelectionContext = React.createContext(null);
const useSelectionContext = () => useContext(SelectionContext);
const Context = (props) => (jsx(LengthContext.Provider, { value: props.length, children: jsx(SelectionContext.Provider, { value: props.selection, children: props.children }) }));

const getSegmentState = (index, [start, end]) => {
    if (typeof start !== 'number')
        return null;
    if (typeof end !== 'number')
        return null;
    if (start === end && start === index)
        return 'cursor';
    if (index >= start && index < end)
        return 'selected';
    return null;
};
const getSegmentPosition = (index, [start, end]) => {
    return index < start ? -1 : index >= end ? 1 : 0;
};
const getSegmentArray = (size, selection) => {
    const array = Array(size).fill(null);
    return array.map((_, index) => ({
        state: getSegmentState(index, selection),
        position: getSegmentPosition(index, selection),
    }));
};

const Absolute = (props) => (jsx("div", { ...props, "aria-hidden": true, style: {
        position: 'absolute',
        left: 0,
        right: 0,
        top: 0,
        bottom: 0,
        display: 'flex',
        justifyContent: 'space-between',
        zIndex: -1,
        ...props.style,
    } }));
const handleScroll = (event) => {
    event.preventDefault();
    event.stopPropagation();
    event.currentTarget.scrollTop = 0;
    event.currentTarget.scrollLeft = 0;
};
const InputScrollWrapper = (props) => {
    return (jsx("div", { ...props, onScroll: handleScroll, style: {
            ...props.style,
            height: '100%',
            overflow: 'hidden',
        } }));
};
const Input = React.forwardRef((props, ref) => {
    const length = useLengthContext();
    return (jsx("input", { ...props, width: undefined, minLength: length, maxLength: length, ref: ref, style: {
            ...props.style,
            font: 'inherit',
            letterSpacing: 'inherit',
            textIndent: 'inherit',
            background: 'transparent',
            appearance: 'none',
            display: 'block',
            width: props.width || '200%',
            padding: '0',
            margin: '0',
            border: '0 solid transparent',
            outline: 'none',
        } }));
});
const SegmentRenderer = (props) => {
    const selection = useSelectionContext();
    const length = useLengthContext();
    // TODO: fix non-null assertion
    const _selection = selection;
    const segmentArray = getSegmentArray(length, _selection);
    const content = segmentArray.map(({ state, position }, index) => {
        return props.children({ index, state, position, selection: _selection });
    });
    return jsx(Fragment, { children: content });
};

var RCI = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Absolute: Absolute,
  Context: Context,
  Input: Input,
  InputScrollWrapper: InputScrollWrapper,
  SegmentRenderer: SegmentRenderer
});

const CodeInput = ({ renderSegment, length = 6, fontFamily = "'SF Mono', SFMono-Regular, ui-monospace, Menlo, Monaco, 'Cascadia Mono', 'Segoe UI Mono', 'Roboto Mono', monospace", fontSize = '2rem', padding = '0.25rem', paddingY = padding, paddingX = padding, spacing = '0.5rem', characterWidth = '1ch', style, className, inputClassName, inputStyle, segmentWidth = `calc(${characterWidth} + ${paddingX} * 2)`, inputWidth = `calc(100% + ${segmentWidth} + ${spacing})`, inputRef, scrollWrapperClassName, segmentWrapperClassName, rootProps, ...rest }) => {
    const selection = useCodeInput(inputRef);
    const rootStyle = {
        ...style,
        position: 'relative',
        width: `calc(${segmentWidth} * ${length} + ${spacing} * ${length - 1})`,
        fontFamily,
        fontSize,
        textIndent: paddingX,
        letterSpacing: `calc(${paddingX} * 2 + ${spacing})`,
        lineHeight: `calc(${fontSize} + ${paddingY} * 2)`,
        zIndex: 0,
    };
    const inputProps = {
        className: inputClassName,
        style: inputStyle,
        ref: inputRef,
    };
    return (jsx(Context, { length: length, selection: selection, children: jsxs("div", { ...rootProps, className: className, style: rootStyle, children: [jsx(Absolute, { className: segmentWrapperClassName, children: jsx(SegmentRenderer, { children: renderSegment }) }), jsx(InputScrollWrapper, { className: scrollWrapperClassName, onMouseDownCapture: (event) => {
                        if (event.button !== 0 || event.ctrlKey)
                            return;
                        if (event.shiftKey || event.metaKey)
                            return;
                        if (!(event.currentTarget instanceof HTMLElement))
                            return;
                        if (!(inputRef.current instanceof HTMLInputElement))
                            return;
                        event.stopPropagation();
                        event.preventDefault();
                        const { left, width } = event.currentTarget.getBoundingClientRect();
                        const eventX = event.clientX - left;
                        const index = Math.floor((eventX / width) * length);
                        if (document.activeElement !== inputRef.current) {
                            inputRef.current?.focus();
                        }
                        inputRef.current?.setSelectionRange(index, index + 1);
                    }, onDoubleClickCapture: () => {
                        inputRef.current?.setSelectionRange(0, length);
                    }, children: jsx(Input, { width: inputWidth, ...rest, ...inputProps }) })] }) }));
};

/** paddingX must be a valid [CSS length](https://developer.mozilla.org/en-US/docs/Web/CSS/length). */
const getSegmentCssWidth = (paddingX) => {
    return `calc(1ch + ${paddingX} * 2)`;
};

export { CodeInput, RCI, getSegmentCssWidth, useLengthContext, useSelectionContext };
//# sourceMappingURL=index.js.map
