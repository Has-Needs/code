import { createRequire } from 'node:module';const require = createRequire(import.meta.url);

// packages/ui/primitives/react-hooks/src/useAsyncEffect.ts
import { useEffect } from "react";
import { log } from "@dxos/log";
var useAsyncEffect = (callback, destructor, deps) => {
  const [effectDestructor, effectDeps] = typeof destructor === "function" ? [
    destructor,
    deps
  ] : [
    void 0,
    destructor
  ];
  useEffect(() => {
    let mounted = true;
    let value;
    const asyncResult = callback(() => mounted);
    void Promise.resolve(asyncResult).then((result) => {
      value = result;
    }).catch(log.catch);
    return () => {
      mounted = false;
      effectDestructor?.(value);
    };
  }, effectDeps);
};

// packages/ui/primitives/react-hooks/src/useAsyncState.ts
import { useEffect as useEffect2, useState } from "react";
var useAsyncState = (cb, deps = []) => {
  const [value, setValue] = useState();
  useEffect2(() => {
    let disposed = false;
    queueMicrotask(async () => {
      const data = await cb();
      if (!disposed) {
        setValue(data);
      }
    });
    return () => {
      disposed = true;
    };
  }, deps);
  return [
    value,
    setValue
  ];
};

// packages/ui/primitives/react-hooks/src/useControlledState.ts
import { useEffect as useEffect3, useState as useState2 } from "react";
var useControlledState = (controlledValue, ...deps) => {
  const [value, setValue] = useState2(controlledValue);
  useEffect3(() => {
    if (controlledValue !== void 0) {
      setValue(controlledValue);
    }
  }, [
    controlledValue,
    ...deps
  ]);
  return [
    value,
    setValue
  ];
};

// packages/ui/primitives/react-hooks/src/useDebugReactDeps.ts
import { useEffect as useEffect4, useRef } from "react";
var useDebugReactDeps = (deps = []) => {
  const lastDeps = useRef([]);
  useEffect4(() => {
    console.group("deps changed", {
      old: lastDeps.current.length,
      new: deps.length
    });
    for (let i = 0; i < Math.max(lastDeps.current.length ?? 0, deps.length ?? 0); i++) {
      console.log(i, lastDeps.current[i] === deps[i] ? "SAME" : "CHANGED", {
        previous: lastDeps.current[i],
        current: deps[i]
      });
    }
    console.groupEnd();
    lastDeps.current = deps;
  }, deps);
};

// packages/ui/primitives/react-hooks/src/useDefaultValue.ts
import { useEffect as useEffect5, useState as useState3, useMemo } from "react";
var useDefaultValue = (reactiveValue, getDefaultValue) => {
  const stableDefaultValue = useMemo(getDefaultValue, []);
  const [value, setValue] = useState3(reactiveValue ?? stableDefaultValue);
  useEffect5(() => {
    setValue(reactiveValue ?? stableDefaultValue);
  }, [
    reactiveValue,
    stableDefaultValue
  ]);
  return value;
};

// packages/ui/primitives/react-hooks/src/useDynamicRef.ts
import { useEffect as useEffect6, useRef as useRef2 } from "react";
var useDynamicRef = (value) => {
  const ref = useRef2(value);
  useEffect6(() => {
    ref.current = value;
  }, [
    value
  ]);
  return ref;
};

// packages/ui/primitives/react-hooks/src/useFileDownload.ts
import { useMemo as useMemo2 } from "react";
var useFileDownload = () => {
  return useMemo2(() => (data, filename) => {
    const url = typeof data === "string" ? data : URL.createObjectURL(data);
    const element = document.createElement("a");
    element.setAttribute("href", url);
    element.setAttribute("download", filename);
    element.setAttribute("target", "download");
    element.click();
  }, []);
};

// packages/ui/primitives/react-hooks/src/useForwardedRef.ts
import { useRef as useRef3, useEffect as useEffect7 } from "react";
var useForwardedRef = (ref) => {
  const innerRef = useRef3(null);
  useEffect7(() => {
    if (!ref) {
      return;
    }
    if (typeof ref === "function") {
      ref(innerRef.current);
    } else {
      ref.current = innerRef.current;
    }
  });
  return innerRef;
};

// packages/ui/primitives/react-hooks/src/useId.ts
import alea from "alea";
import { useMemo as useMemo3 } from "react";
var Alea = alea;
var prng = new Alea("@dxos/react-hooks");
var randomString = (n = 4) => prng().toString(16).slice(2, n + 2);
var useId = (namespace, propsId, opts) => useMemo3(() => makeId(namespace, propsId, opts), [
  propsId
]);
var makeId = (namespace, propsId, opts) => propsId ?? `${namespace}-${randomString(opts?.n ?? 4)}`;

// packages/ui/primitives/react-hooks/src/useIsFocused.ts
import { useEffect as useEffect8, useRef as useRef4, useState as useState4 } from "react";
var useIsFocused = (inputRef) => {
  const [isFocused, setIsFocused] = useState4(void 0);
  const isFocusedRef = useRef4(isFocused);
  isFocusedRef.current = isFocused;
  useEffect8(() => {
    const input = inputRef.current;
    if (!input) {
      return;
    }
    const onFocus = () => setIsFocused(true);
    const onBlur = () => setIsFocused(false);
    input.addEventListener("focus", onFocus);
    input.addEventListener("blur", onBlur);
    if (isFocusedRef.current === void 0) {
      setIsFocused(document.activeElement === input);
    }
    return () => {
      input.removeEventListener("focus", onFocus);
      input.removeEventListener("blur", onBlur);
    };
  }, [
    inputRef,
    setIsFocused
  ]);
  return isFocused;
};

// packages/ui/primitives/react-hooks/src/useMediaQuery.ts
import { useEffect as useEffect9, useState as useState5 } from "react";
var breakpointMediaQueries = {
  sm: "(min-width: 640px)",
  md: "(min-width: 768px)",
  lg: "(min-width: 1024px)",
  xl: "(min-width: 1280px)",
  "2xl": "(min-width: 1536px)"
};
var useMediaQuery = (query, options = {}) => {
  const { ssr = true, fallback } = options;
  const queries = (Array.isArray(query) ? query : [
    query
  ]).map((query2) => query2 in breakpointMediaQueries ? breakpointMediaQueries[query2] : query2);
  let fallbackValues = Array.isArray(fallback) ? fallback : [
    fallback
  ];
  fallbackValues = fallbackValues.filter((v) => v != null);
  const [value, setValue] = useState5(() => {
    return queries.map((query2, index) => ({
      media: query2,
      matches: ssr ? !!fallbackValues[index] : document.defaultView?.matchMedia(query2).matches
    }));
  });
  useEffect9(() => {
    setValue(queries.map((query2) => ({
      media: query2,
      matches: document.defaultView?.matchMedia(query2).matches
    })));
    const mql = queries.map((query2) => document.defaultView?.matchMedia(query2));
    const handler = (evt) => {
      setValue((prev) => {
        return prev.slice().map((item) => {
          if (item.media === evt.media) {
            return {
              ...item,
              matches: evt.matches
            };
          }
          return item;
        });
      });
    };
    mql.forEach((mql2) => {
      if (typeof mql2?.addListener === "function") {
        mql2?.addListener(handler);
      } else {
        mql2?.addEventListener("change", handler);
      }
    });
    return () => {
      mql.forEach((mql2) => {
        if (typeof mql2?.removeListener === "function") {
          mql2?.removeListener(handler);
        } else {
          mql2?.removeEventListener("change", handler);
        }
      });
    };
  }, [
    document.defaultView
  ]);
  return value.map((item) => !!item.matches);
};

// packages/ui/primitives/react-hooks/src/useMulticastObservable.ts
import { useMemo as useMemo4, useSyncExternalStore } from "react";
var useMulticastObservable = (observable) => {
  const subscribeFn = useMemo4(() => (listener) => {
    const subscription = observable.subscribe(listener);
    return () => subscription.unsubscribe();
  }, [
    observable
  ]);
  return useSyncExternalStore(subscribeFn, () => observable.get());
};

// packages/ui/primitives/react-hooks/src/useRefCallback.ts
import { useState as useState6 } from "react";
var useRefCallback = () => {
  const [value, setValue] = useState6(null);
  return {
    refCallback: (value2) => setValue(value2),
    value
  };
};

// packages/ui/primitives/react-hooks/src/useResize.ts
import { useLayoutEffect, useMemo as useMemo5 } from "react";
var useResize = (handler, deps = [], delay = 800) => {
  const debouncedHandler = useMemo5(() => {
    let timeout;
    return (event) => {
      clearTimeout(timeout);
      timeout = setTimeout(() => {
        handler(event);
      }, delay);
    };
  }, [
    handler,
    delay
  ]);
  return useLayoutEffect(() => {
    window.visualViewport?.addEventListener("resize", debouncedHandler);
    debouncedHandler();
    return () => window.visualViewport?.removeEventListener("resize", debouncedHandler);
  }, [
    debouncedHandler,
    ...deps
  ]);
};

// packages/ui/primitives/react-hooks/src/useTrackProps.ts
import { useRef as useRef5, useEffect as useEffect10 } from "react";
import { log as log2 } from "@dxos/log";
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/ui/primitives/react-hooks/src/useTrackProps.ts";
var useTrackProps = (props, componentName = "Component", active = true) => {
  const prevProps = useRef5(props);
  useEffect10(() => {
    const changes = Object.entries(props).filter(([key]) => props[key] !== prevProps.current[key]);
    if (changes.length > 0) {
      if (active) {
        log2.info("props changed", {
          componentName,
          keys: changes.map(([key]) => key).join(","),
          props: Object.fromEntries(changes.map(([key]) => [
            key,
            {
              from: prevProps.current[key],
              to: props[key]
            }
          ]))
        }, {
          F: __dxlog_file,
          L: 22,
          S: void 0,
          C: (f, a) => f(...a)
        });
      }
    }
    prevProps.current = props;
  });
};

// packages/ui/primitives/react-hooks/src/useTransitions.ts
import { useRef as useRef6, useEffect as useEffect11, useState as useState7 } from "react";
var isFunction = (functionToCheck) => {
  return functionToCheck instanceof Function;
};
var useDidTransition = (currentValue, fromValue, toValue) => {
  const [hasTransitioned, setHasTransitioned] = useState7(false);
  const previousValue = useRef6(currentValue);
  useEffect11(() => {
    const toValueValid = isFunction(toValue) ? toValue(currentValue) : toValue === currentValue;
    const fromValueValid = isFunction(fromValue) ? fromValue(previousValue.current) : fromValue === previousValue.current;
    if (fromValueValid && toValueValid && !hasTransitioned) {
      setHasTransitioned(true);
    } else if ((!fromValueValid || !toValueValid) && hasTransitioned) {
      setHasTransitioned(false);
    }
    previousValue.current = currentValue;
  }, [
    currentValue,
    fromValue,
    toValue,
    hasTransitioned
  ]);
  return hasTransitioned;
};
var useOnTransition = (currentValue, fromValue, toValue, callback) => {
  const dirty = useRef6(false);
  const hasTransitioned = useDidTransition(currentValue, fromValue, toValue);
  useEffect11(() => {
    dirty.current = false;
  }, [
    currentValue,
    dirty
  ]);
  useEffect11(() => {
    if (hasTransitioned && !dirty.current) {
      callback();
      dirty.current = true;
    }
  }, [
    hasTransitioned,
    dirty,
    callback
  ]);
};
export {
  makeId,
  randomString,
  useAsyncEffect,
  useAsyncState,
  useControlledState,
  useDebugReactDeps,
  useDefaultValue,
  useDidTransition,
  useDynamicRef,
  useFileDownload,
  useForwardedRef,
  useId,
  useIsFocused,
  useMediaQuery,
  useMulticastObservable,
  useOnTransition,
  useRefCallback,
  useResize,
  useTrackProps
};
//# sourceMappingURL=index.mjs.map
