"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var node_exports = {};
__export(node_exports, {
  makeId: () => makeId,
  randomString: () => randomString,
  useAsyncEffect: () => useAsyncEffect,
  useAsyncState: () => useAsyncState,
  useControlledState: () => useControlledState,
  useDebugReactDeps: () => useDebugReactDeps,
  useDefaultValue: () => useDefaultValue,
  useDidTransition: () => useDidTransition,
  useDynamicRef: () => useDynamicRef,
  useFileDownload: () => useFileDownload,
  useForwardedRef: () => useForwardedRef,
  useId: () => useId,
  useIsFocused: () => useIsFocused,
  useMediaQuery: () => useMediaQuery,
  useMulticastObservable: () => useMulticastObservable,
  useOnTransition: () => useOnTransition,
  useRefCallback: () => useRefCallback,
  useResize: () => useResize,
  useTrackProps: () => useTrackProps
});
module.exports = __toCommonJS(node_exports);
var import_react = require("react");
var import_log = require("@dxos/log");
var import_react2 = require("react");
var import_react3 = require("react");
var import_react4 = require("react");
var import_react5 = require("react");
var import_react6 = require("react");
var import_react7 = require("react");
var import_react8 = require("react");
var import_alea = __toESM(require("alea"));
var import_react9 = require("react");
var import_react10 = require("react");
var import_react11 = require("react");
var import_react12 = require("react");
var import_react13 = require("react");
var import_react14 = require("react");
var import_react15 = require("react");
var import_log2 = require("@dxos/log");
var import_react16 = require("react");
var useAsyncEffect = (callback, destructor, deps) => {
  const [effectDestructor, effectDeps] = typeof destructor === "function" ? [
    destructor,
    deps
  ] : [
    void 0,
    destructor
  ];
  (0, import_react.useEffect)(() => {
    let mounted = true;
    let value;
    const asyncResult = callback(() => mounted);
    void Promise.resolve(asyncResult).then((result) => {
      value = result;
    }).catch(import_log.log.catch);
    return () => {
      mounted = false;
      effectDestructor?.(value);
    };
  }, effectDeps);
};
var useAsyncState = (cb, deps = []) => {
  const [value, setValue] = (0, import_react2.useState)();
  (0, import_react2.useEffect)(() => {
    let disposed = false;
    queueMicrotask(async () => {
      const data = await cb();
      if (!disposed) {
        setValue(data);
      }
    });
    return () => {
      disposed = true;
    };
  }, deps);
  return [
    value,
    setValue
  ];
};
var useControlledState = (controlledValue, ...deps) => {
  const [value, setValue] = (0, import_react3.useState)(controlledValue);
  (0, import_react3.useEffect)(() => {
    if (controlledValue !== void 0) {
      setValue(controlledValue);
    }
  }, [
    controlledValue,
    ...deps
  ]);
  return [
    value,
    setValue
  ];
};
var useDebugReactDeps = (deps = []) => {
  const lastDeps = (0, import_react4.useRef)([]);
  (0, import_react4.useEffect)(() => {
    console.group("deps changed", {
      old: lastDeps.current.length,
      new: deps.length
    });
    for (let i = 0; i < Math.max(lastDeps.current.length ?? 0, deps.length ?? 0); i++) {
      console.log(i, lastDeps.current[i] === deps[i] ? "SAME" : "CHANGED", {
        previous: lastDeps.current[i],
        current: deps[i]
      });
    }
    console.groupEnd();
    lastDeps.current = deps;
  }, deps);
};
var useDefaultValue = (reactiveValue, getDefaultValue) => {
  const stableDefaultValue = (0, import_react5.useMemo)(getDefaultValue, []);
  const [value, setValue] = (0, import_react5.useState)(reactiveValue ?? stableDefaultValue);
  (0, import_react5.useEffect)(() => {
    setValue(reactiveValue ?? stableDefaultValue);
  }, [
    reactiveValue,
    stableDefaultValue
  ]);
  return value;
};
var useDynamicRef = (value) => {
  const ref = (0, import_react6.useRef)(value);
  (0, import_react6.useEffect)(() => {
    ref.current = value;
  }, [
    value
  ]);
  return ref;
};
var useFileDownload = () => {
  return (0, import_react7.useMemo)(() => (data, filename) => {
    const url = typeof data === "string" ? data : URL.createObjectURL(data);
    const element = document.createElement("a");
    element.setAttribute("href", url);
    element.setAttribute("download", filename);
    element.setAttribute("target", "download");
    element.click();
  }, []);
};
var useForwardedRef = (ref) => {
  const innerRef = (0, import_react8.useRef)(null);
  (0, import_react8.useEffect)(() => {
    if (!ref) {
      return;
    }
    if (typeof ref === "function") {
      ref(innerRef.current);
    } else {
      ref.current = innerRef.current;
    }
  });
  return innerRef;
};
var Alea = import_alea.default;
var prng = new Alea("@dxos/react-hooks");
var randomString = (n = 4) => prng().toString(16).slice(2, n + 2);
var useId = (namespace, propsId, opts) => (0, import_react9.useMemo)(() => makeId(namespace, propsId, opts), [
  propsId
]);
var makeId = (namespace, propsId, opts) => propsId ?? `${namespace}-${randomString(opts?.n ?? 4)}`;
var useIsFocused = (inputRef) => {
  const [isFocused, setIsFocused] = (0, import_react10.useState)(void 0);
  const isFocusedRef = (0, import_react10.useRef)(isFocused);
  isFocusedRef.current = isFocused;
  (0, import_react10.useEffect)(() => {
    const input = inputRef.current;
    if (!input) {
      return;
    }
    const onFocus = () => setIsFocused(true);
    const onBlur = () => setIsFocused(false);
    input.addEventListener("focus", onFocus);
    input.addEventListener("blur", onBlur);
    if (isFocusedRef.current === void 0) {
      setIsFocused(document.activeElement === input);
    }
    return () => {
      input.removeEventListener("focus", onFocus);
      input.removeEventListener("blur", onBlur);
    };
  }, [
    inputRef,
    setIsFocused
  ]);
  return isFocused;
};
var breakpointMediaQueries = {
  sm: "(min-width: 640px)",
  md: "(min-width: 768px)",
  lg: "(min-width: 1024px)",
  xl: "(min-width: 1280px)",
  "2xl": "(min-width: 1536px)"
};
var useMediaQuery = (query, options = {}) => {
  const { ssr = true, fallback } = options;
  const queries = (Array.isArray(query) ? query : [
    query
  ]).map((query2) => query2 in breakpointMediaQueries ? breakpointMediaQueries[query2] : query2);
  let fallbackValues = Array.isArray(fallback) ? fallback : [
    fallback
  ];
  fallbackValues = fallbackValues.filter((v) => v != null);
  const [value, setValue] = (0, import_react11.useState)(() => {
    return queries.map((query2, index) => ({
      media: query2,
      matches: ssr ? !!fallbackValues[index] : document.defaultView?.matchMedia(query2).matches
    }));
  });
  (0, import_react11.useEffect)(() => {
    setValue(queries.map((query2) => ({
      media: query2,
      matches: document.defaultView?.matchMedia(query2).matches
    })));
    const mql = queries.map((query2) => document.defaultView?.matchMedia(query2));
    const handler = (evt) => {
      setValue((prev) => {
        return prev.slice().map((item) => {
          if (item.media === evt.media) {
            return {
              ...item,
              matches: evt.matches
            };
          }
          return item;
        });
      });
    };
    mql.forEach((mql2) => {
      if (typeof mql2?.addListener === "function") {
        mql2?.addListener(handler);
      } else {
        mql2?.addEventListener("change", handler);
      }
    });
    return () => {
      mql.forEach((mql2) => {
        if (typeof mql2?.removeListener === "function") {
          mql2?.removeListener(handler);
        } else {
          mql2?.removeEventListener("change", handler);
        }
      });
    };
  }, [
    document.defaultView
  ]);
  return value.map((item) => !!item.matches);
};
var useMulticastObservable = (observable) => {
  const subscribeFn = (0, import_react12.useMemo)(() => (listener) => {
    const subscription = observable.subscribe(listener);
    return () => subscription.unsubscribe();
  }, [
    observable
  ]);
  return (0, import_react12.useSyncExternalStore)(subscribeFn, () => observable.get());
};
var useRefCallback = () => {
  const [value, setValue] = (0, import_react13.useState)(null);
  return {
    refCallback: (value2) => setValue(value2),
    value
  };
};
var useResize = (handler, deps = [], delay = 800) => {
  const debouncedHandler = (0, import_react14.useMemo)(() => {
    let timeout;
    return (event) => {
      clearTimeout(timeout);
      timeout = setTimeout(() => {
        handler(event);
      }, delay);
    };
  }, [
    handler,
    delay
  ]);
  return (0, import_react14.useLayoutEffect)(() => {
    window.visualViewport?.addEventListener("resize", debouncedHandler);
    debouncedHandler();
    return () => window.visualViewport?.removeEventListener("resize", debouncedHandler);
  }, [
    debouncedHandler,
    ...deps
  ]);
};
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/ui/primitives/react-hooks/src/useTrackProps.ts";
var useTrackProps = (props, componentName = "Component", active = true) => {
  const prevProps = (0, import_react15.useRef)(props);
  (0, import_react15.useEffect)(() => {
    const changes = Object.entries(props).filter(([key]) => props[key] !== prevProps.current[key]);
    if (changes.length > 0) {
      if (active) {
        import_log2.log.info("props changed", {
          componentName,
          keys: changes.map(([key]) => key).join(","),
          props: Object.fromEntries(changes.map(([key]) => [
            key,
            {
              from: prevProps.current[key],
              to: props[key]
            }
          ]))
        }, {
          F: __dxlog_file,
          L: 22,
          S: void 0,
          C: (f, a) => f(...a)
        });
      }
    }
    prevProps.current = props;
  });
};
var isFunction = (functionToCheck) => {
  return functionToCheck instanceof Function;
};
var useDidTransition = (currentValue, fromValue, toValue) => {
  const [hasTransitioned, setHasTransitioned] = (0, import_react16.useState)(false);
  const previousValue = (0, import_react16.useRef)(currentValue);
  (0, import_react16.useEffect)(() => {
    const toValueValid = isFunction(toValue) ? toValue(currentValue) : toValue === currentValue;
    const fromValueValid = isFunction(fromValue) ? fromValue(previousValue.current) : fromValue === previousValue.current;
    if (fromValueValid && toValueValid && !hasTransitioned) {
      setHasTransitioned(true);
    } else if ((!fromValueValid || !toValueValid) && hasTransitioned) {
      setHasTransitioned(false);
    }
    previousValue.current = currentValue;
  }, [
    currentValue,
    fromValue,
    toValue,
    hasTransitioned
  ]);
  return hasTransitioned;
};
var useOnTransition = (currentValue, fromValue, toValue, callback) => {
  const dirty = (0, import_react16.useRef)(false);
  const hasTransitioned = useDidTransition(currentValue, fromValue, toValue);
  (0, import_react16.useEffect)(() => {
    dirty.current = false;
  }, [
    currentValue,
    dirty
  ]);
  (0, import_react16.useEffect)(() => {
    if (hasTransitioned && !dirty.current) {
      callback();
      dirty.current = true;
    }
  }, [
    hasTransitioned,
    dirty,
    callback
  ]);
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  makeId,
  randomString,
  useAsyncEffect,
  useAsyncState,
  useControlledState,
  useDebugReactDeps,
  useDefaultValue,
  useDidTransition,
  useDynamicRef,
  useFileDownload,
  useForwardedRef,
  useId,
  useIsFocused,
  useMediaQuery,
  useMulticastObservable,
  useOnTransition,
  useRefCallback,
  useResize,
  useTrackProps
});
//# sourceMappingURL=index.cjs.map
