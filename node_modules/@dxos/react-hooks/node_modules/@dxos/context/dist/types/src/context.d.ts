import { inspect } from 'node:util';
import { type CallMetadata } from '@dxos/log';
export type ContextErrorHandler = (error: Error, ctx: Context) => void;
export type DisposeCallback = () => any | Promise<any>;
export type CreateContextParams = {
    name?: string;
    parent?: Context;
    attributes?: Record<string, any>;
    onError?: ContextErrorHandler;
};
/**
 * NOTE: Context is not reusable after it is disposed.
 */
export declare class Context {
    #private;
    static default(): Context;
    maxSafeDisposeCallbacks: number;
    constructor(params?: CreateContextParams, callMeta?: Partial<CallMetadata>);
    get disposed(): boolean;
    get disposeCallbacksLength(): number;
    /**
     * Schedules a callback to run when the context is disposed.
     * May be async, in this case the disposer might choose to wait for all resource to released.
     * Throwing an error inside the callback will result in the error being logged, but not re-thrown.
     *
     * NOTE: Will call the callback immediately if the context is already disposed.
     *
     * @returns A function that can be used to remove the callback from the dispose list.
     */
    onDispose(callback: DisposeCallback): () => void;
    /**
     * Runs all dispose callbacks.
     * Callbacks are run in the reverse order they were added.
     * This function never throws.
     * It is safe to ignore the returned promise if the caller does not wish to wait for callbacks to complete.
     * Disposing context means that onDispose will throw an error and any errors raised will be logged and not propagated.
     * @returns true if there were no errors during the dispose process.
     */
    dispose(throwOnError?: boolean): Promise<boolean>;
    /**
     * Raise the error inside the context.
     * The error will be propagated to the error handler.
     * IF the error handler is not set, the error will dispose the context and cause an unhandled rejection.
     */
    raise(error: Error): void;
    derive({ onError, attributes }?: CreateContextParams): Context;
    getAttribute(key: string): any;
    [Symbol.toStringTag]: string;
    [inspect.custom]: () => string;
    toString(): string;
    [Symbol.asyncDispose](): Promise<void>;
}
//# sourceMappingURL=context.d.ts.map