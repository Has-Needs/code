import { type IConversionOptions } from 'protobufjs';
import type protobufjs from 'protobufjs';
import { type Any, type EncodingOptions, type WithTypeUrl } from './common';
import { type BidirectionalMapingDescriptors } from './mapping';
import type { Schema } from './schema';
export declare const OBJECT_CONVERSION_OPTIONS: IConversionOptions;
/**
 * Defines a generic encoder/decoder.
 */
export interface Codec<T> {
    encode(obj: T, opts?: EncodingOptions): Uint8Array;
    decode(buffer: Uint8Array, opts?: EncodingOptions): T;
}
/**
 * Protocol buffer codec.
 */
export declare class ProtoCodec<T = any> implements Codec<T> {
    private readonly _type;
    private readonly _mapping;
    private readonly _schema;
    private readonly _encodeMapper;
    private readonly _decodeMapper;
    constructor(_type: protobufjs.Type, _mapping: BidirectionalMapingDescriptors, _schema: Schema<any>);
    /**
     * Underlying protobuf.js type descriptor.
     */
    get protoType(): protobufjs.Type;
    get substitutionMappings(): BidirectionalMapingDescriptors;
    /**
     * Reference to the protobuf schema this codec was created from.
     */
    get schema(): Schema<any>;
    encode(value: T, options?: EncodingOptions): Uint8Array;
    decode(data: Uint8Array, options?: EncodingOptions): T;
    encodeAsAny(value: T, options?: EncodingOptions): WithTypeUrl<Any>;
    fromObject(obj: any): T;
    /**
     * Dynamically add new definitions to this codec. Mutates the underlying schema.
     */
    addJson(schema: any): void;
    encodeToJson(value: T, options?: EncodingOptions): any;
    decodeFromJson(data: any, options?: EncodingOptions): T;
}
//# sourceMappingURL=codec.d.ts.map