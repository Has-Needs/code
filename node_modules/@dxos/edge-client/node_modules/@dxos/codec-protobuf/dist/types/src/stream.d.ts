import { Context } from '@dxos/context';
import { type MaybePromise } from '@dxos/util';
type Callbacks<T> = {
    ctx: Context;
    /**
     * Advises that the producer is ready to stream the data.
     * Called automatically with the first call to `next`.
     */
    ready: () => void;
    /**
     * Sends a message into the stream.
     */
    next: (message: T) => void;
    /**
     * Closes the stream.
     * Optional error can be provided.
     */
    close: (err?: Error) => void;
};
type Producer<T> = (callbacks: Callbacks<T>) => ((err?: Error) => void) | void;
export type StreamItem<T> = {
    ready: true;
} | {
    data: T;
} | {
    closed: true;
    error?: Error;
};
/**
 * Represents a typed stream of data.
 * In concept it's a Promise that can resolve multiple times.
 * Can only have one subscriber.
 * `close` must be called to clean-up the resources.
 */
export declare class Stream<T> {
    /**
     * Consumes the entire stream to the end until it closes and returns a promise with the resulting items.
     */
    static consume<T>(stream: Stream<T>): Promise<StreamItem<T>[]>;
    static consumeData<T>(stream: Stream<T>): Promise<T[]>;
    static first<T>(stream: Stream<T>): Promise<T | undefined>;
    /**
     * Maps all data coming through the stream.
     */
    static map<T, U>(source: Stream<T>, map: (data: T) => U): Stream<U>;
    /**
     * Converts Promise<Stream<T>> to Stream<T>.
     */
    static unwrapPromise<T>(streamPromise: MaybePromise<Stream<T>>): Stream<T>;
    static fromPromise<T>(promise: Promise<T>): Stream<T>;
    private readonly _ctx;
    private _messageHandler?;
    private _closeHandler?;
    private _readyHandler?;
    private _isClosed;
    private _closeError;
    private _producerCleanup;
    private _readyPromise;
    private _resolveReadyPromise;
    private _isReady;
    /**
     * Buffer messages before subscription. Set to null when buffer is no longer needed.
     */
    private _buffer;
    constructor(producer: Producer<T>);
    private _markAsReady;
    subscribe(onMessage: (msg: T) => void, onClose?: (err?: Error) => void): void;
    /**
     * Resolves when stream is ready.
     */
    waitUntilReady(): Promise<void>;
    /**
     * Registers a callback to be called when stream is ready.
     */
    onReady(onReady: () => void): void;
    /**
     * Close the stream and dispose of any resources.
     */
    close(): Promise<void>;
}
export {};
//# sourceMappingURL=stream.d.ts.map