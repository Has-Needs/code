import type pb from 'protobufjs';
import { type Any, type EncodingOptions } from './common';
import { type RequestOptions } from './request-options';
import type { Schema } from './schema';
import { Stream } from './stream';
/**
 * Service endpoint.
 */
export interface ServiceBackend {
    call(method: string, request: Any, requestOptions?: RequestOptions): Promise<Any>;
    callStream(method: string, request: Any, requestOptions?: RequestOptions): Stream<Any>;
}
export type ServiceProvider<Service> = Service | (() => Service) | (() => Promise<Service>);
/**
 * Client/server service wrapper.
 */
export declare class ServiceDescriptor<S> {
    private readonly _service;
    private readonly _schema;
    constructor(_service: pb.Service, _schema: Schema<any>);
    get serviceProto(): pb.Service;
    get name(): string;
    createClient(backend: ServiceBackend, encodingOptions?: EncodingOptions): Service & S;
    createServer(handlers: ServiceProvider<S>, encodingOptions?: EncodingOptions): ServiceHandler<S>;
}
/**
 * Represents service instance.
 */
export declare class Service {
    constructor(backend: ServiceBackend, service: pb.Service, schema: Schema<any>, encodingOptions?: EncodingOptions);
}
/**
 * Represents service endpoint implementation.
 */
export declare class ServiceHandler<S = {}> implements ServiceBackend {
    private readonly _serviceDefinition;
    private readonly _schema;
    private readonly _serviceProvider;
    private readonly _encodingOptions?;
    constructor(_serviceDefinition: pb.Service, _schema: Schema<any>, _serviceProvider: ServiceProvider<S>, _encodingOptions?: EncodingOptions | undefined);
    /**
     * Request/response method call.
     */
    call(methodName: string, request: Any, options?: RequestOptions): Promise<Any>;
    /**
     * Streaming method call.
     */
    callStream(methodName: string, request: Any, options?: RequestOptions): Stream<Any>;
    private _getHandler;
    private _getMethodInfo;
}
//# sourceMappingURL=service.d.ts.map