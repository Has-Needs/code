{
  "version": 3,
  "sources": ["../../../src/did.ts", "../../../src/invitations.ts", "../../../src/seedphrase.ts", "../../../src/passcode.ts", "../../../src/credentials/signing.ts", "../../../src/presentations/signing.ts", "../../../src/credentials/assertions.ts", "../../../src/credentials/credential-factory.ts", "../../../src/credentials/verifier.ts", "../../../src/credentials/credential-generator.ts", "../../../src/presentations/presentation.ts", "../../../src/presentations/verifier.ts", "../../../src/state-machine/space-state-machine.ts", "../../../src/state-machine/feed-state-machine.ts", "../../../src/state-machine/invitation-state-machine.ts", "../../../src/state-machine/member-state-machine.ts", "../../../src/graph/credential-graph.ts", "../../../src/processor/device-state-machine.ts", "../../../src/processor/profile-state-machine.ts"],
  "sourcesContent": ["//\n// Copyright 2025 DXOS.org\n//\n\nimport { subtleCrypto } from '@dxos/crypto';\nimport { PublicKey, IdentityDid } from '@dxos/keys';\nimport { ComplexMap } from '@dxos/util';\n\nconst IDENTITY_DIDS_CACHE = new ComplexMap<PublicKey, IdentityDid>(PublicKey.hash);\n\n/**\n * Identity DIDs are generated by creating a keypair, and then taking the first 20 bytes of the SHA-256 hash of the public key and encoding them to multibase RFC4648 base-32 format (prefixed with B, see Multibase Table).\n * Inspired by how ethereum addresses are derived.\n */\nexport const createDidFromIdentityKey = async (identityKey: PublicKey): Promise<IdentityDid> => {\n  const cachedValue = IDENTITY_DIDS_CACHE.get(identityKey);\n  if (cachedValue !== undefined) {\n    return cachedValue;\n  }\n\n  const digest = await subtleCrypto.digest('SHA-256', identityKey.asUint8Array());\n\n  const bytes = new Uint8Array(digest).slice(0, IdentityDid.byteLength);\n  const identityDid = IdentityDid.encode(bytes);\n  IDENTITY_DIDS_CACHE.set(identityKey, identityDid);\n  return identityDid;\n};\n", "//\n// Copyright 2019 DXOS.org\n//\n\n/**\n * Info required for offline invitations.\n */\n// TODO(burdon): Define types.\nexport interface SecretInfo {\n  id: any;\n  authNonce: any;\n}\n\n/**\n * Provides a shared secret during an invitation process.\n */\nexport type SecretProvider = (info?: SecretInfo) => Promise<Buffer>;\n\n/**\n * Validates the shared secret during an invitation process.\n */\nexport type SecretValidator = (invitation: never, secret: Buffer) => Promise<boolean>;\n\nexport const defaultSecretProvider: SecretProvider = async () => Buffer.from('0000');\n\nexport const defaultSecretValidator: SecretValidator = async (invitation, secret) => true;\n", "//\n// Copyright 2020 DXOS.org\n//\n\nimport { generateMnemonic, mnemonicToSeedSync } from 'bip39';\n\nimport { createKeyPair } from '@dxos/crypto';\nimport { invariant } from '@dxos/invariant';\nimport { type KeyPair } from '@dxos/keys';\n\n/**\n * Generate bip39 seed phrase (aka mnemonic).\n */\nexport const generateSeedPhrase = (): string => generateMnemonic();\n\n/**\n * Generate key pair from seed phrase.\n */\nexport const keyPairFromSeedPhrase = (seedPhrase: string): KeyPair => {\n  invariant(seedPhrase);\n  const seed = mnemonicToSeedSync(seedPhrase);\n  return createKeyPair(seed);\n};\n", "//\n// Copyright 2019 DXOS.org\n//\n\n/**\n * Generates a numeric passcode.\n * @param {number} length\n * @returns {string}\n */\nexport const generatePasscode = (length = 4) => {\n  let passcode = '';\n  for (let i = 0; i < length; i++) {\n    passcode += `${Math.floor(Math.random() * 10)}`;\n  }\n\n  return passcode;\n};\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport stableStringify from 'json-stable-stringify';\n\nimport { PublicKey } from '@dxos/keys';\nimport { type Credential } from '@dxos/protocols/proto/dxos/halo/credentials';\nimport { Timeframe } from '@dxos/timeframe';\nimport { arrayToBuffer } from '@dxos/util';\n\n/**\n * @returns The input message to be signed for a given credential.\n */\n// TODO(nf): rename, this returns not the proof itself, but the payload for verifying against the proof.\nexport const getCredentialProofPayload = (credential: Credential): Uint8Array => {\n  const copy = {\n    ...credential,\n    proof: {\n      ...credential.proof,\n      value: new Uint8Array(),\n      chain: undefined,\n    },\n  };\n  if (copy.parentCredentialIds?.length === 0) {\n    delete copy.parentCredentialIds;\n  }\n  delete copy.id; // ID is not part of the signature payload.\n\n  return Buffer.from(canonicalStringify(copy));\n};\n\n/**\n * Utility method to produce stable output for signing/verifying.\n */\nexport const canonicalStringify = (obj: any): string =>\n  stableStringify(obj, {\n    /* The point of signing and verifying is not that the internal, private state of the objects be\n     * identical, but that the public contents can be verified not to have been altered. For that reason,\n     * really private fields (indicated by '__') are not included in the signature.\n     * This gives a mechanism for attaching other attributes to an object without breaking the signature.\n     * We also skip @type.\n     */\n    // TODO(dmaretskyi): Should we actually skip the @type field?\n    replacer: function (this: any, key: any, value: any) {\n      if (key.toString().startsWith('__') || key.toString() === '@type') {\n        return undefined;\n      }\n\n      if (value === null) {\n        return undefined;\n      }\n\n      // Value before .toJSON() is called.\n      const original = this[key];\n\n      if (value) {\n        if (PublicKey.isPublicKey(value)) {\n          return value.toHex();\n        }\n        if (Buffer.isBuffer(value)) {\n          return value.toString('hex');\n        }\n\n        if (value instanceof Uint8Array) {\n          return arrayToBuffer(value).toString('hex');\n        }\n        if (value.data && value.type === 'Buffer') {\n          return Buffer.from(value).toString('hex');\n        }\n        if (original instanceof Timeframe) {\n          // Uses old key truncation method (339d...9d66) to keep backwards compatibility.\n          return original.frames().reduce((frames: Record<string, number>, [key, seq]) => {\n            frames[truncateKey(key)] = seq;\n            return frames;\n          }, {});\n        }\n      }\n\n      return value;\n    },\n  }) as string;\n\n/**\n * Old key truncation method (339d...9d66) to keep backwards compatibility with credentials signed with old method\n */\nconst truncateKey = (key: PublicKey) => {\n  const str = key.toHex();\n  return `${str.substring(0, 4)}...${str.substring(str.length - 4)}`;\n};\n\n/**\n * export const truncateKey = (key: any, { length = 8, start }: TruncateKeyOptions = {}) => {\nconst str = String(key);\nif (str.length <= length) {\n  return str;\n}\n\nreturn start\n  ? `${str.slice(0, length)}...`\n  : `${str.substring(0, length / 2)}...${str.substring(str.length - length / 2)}`;\n};\n\n{\n\"04009285\": 20,\n\"0415004f\": 0,\n\"0415e6d7\": 9964,\n\"042a4fa9\": 8,\n\"0448e62f\": 3,\n\"04775053\": 257,\n\"04a6b603\": 97,\n\"04bc5c9d\": 198,\n\"04da9930\": 59,\n\"04df0449\": 676,\n\"04e122ae\": 5435,\n\"04ee588b\": 1703\n}\n\n */\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { type Credential, type Proof } from '@dxos/protocols/proto/dxos/halo/credentials';\n\nimport { canonicalStringify } from '../credentials/signing';\n\nexport const getPresentationProofPayload = (credentials: Credential[], proof: Proof): Uint8Array => {\n  const copy = {\n    credentials: credentials.map((credential) => removeEmptyParentCredentialIds(credential)),\n    proof: {\n      ...proof,\n      value: new Uint8Array(),\n      chain: undefined,\n    },\n  };\n\n  return Buffer.from(canonicalStringify(copy));\n};\n\nconst removeEmptyParentCredentialIds = (credential: Credential): Credential => {\n  const copy = {\n    ...credential,\n    proof: credential.proof\n      ? {\n          ...credential.proof,\n          chain: credential.proof.chain\n            ? { credential: removeEmptyParentCredentialIds(credential.proof.chain.credential) }\n            : undefined,\n        }\n      : undefined,\n  };\n  if (copy.parentCredentialIds?.length === 0) {\n    delete copy.parentCredentialIds;\n  }\n  return copy;\n};\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { type PublicKey } from '@dxos/keys';\nimport { type TypedMessage, type TYPES } from '@dxos/protocols/proto';\nimport { type Credential } from '@dxos/protocols/proto/dxos/halo/credentials';\n\nexport const getCredentialAssertion = (credential: Credential): TypedMessage => credential.subject.assertion;\n\nexport const isValidAuthorizedDeviceCredential = (\n  credential: Credential,\n  identityKey: PublicKey,\n  deviceKey: PublicKey,\n): boolean => {\n  const assertion = getCredentialAssertion(credential);\n  return (\n    credential.subject.id.equals(deviceKey) &&\n    credential.issuer.equals(identityKey) &&\n    assertion['@type'] === 'dxos.halo.credentials.AuthorizedDevice' &&\n    assertion.identityKey.equals(identityKey) &&\n    assertion.deviceKey.equals(deviceKey)\n  );\n};\n\nexport type SpecificCredential<T> = Omit<Credential, 'subject'> & {\n  subject: Omit<Credential['subject'], 'assertion'> & { assertion: T };\n};\n\nexport const checkCredentialType = <K extends keyof TYPES>(\n  credential: Credential,\n  type: K,\n): credential is SpecificCredential<TYPES[K]> => credential.subject.assertion['@type'] === type;\n\nexport const credentialTypeFilter =\n  <K extends keyof TYPES>(type: K) =>\n  (credential: Credential): credential is SpecificCredential<TYPES[K]> =>\n    checkCredentialType(credential, type);\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { type Signer, subtleCrypto } from '@dxos/crypto';\nimport { invariant } from '@dxos/invariant';\nimport { PublicKey } from '@dxos/keys';\nimport { type TypedMessage } from '@dxos/protocols/proto';\nimport { type Chain, type Credential } from '@dxos/protocols/proto/dxos/halo/credentials';\n\nimport { getCredentialProofPayload } from './signing';\nimport { SIGNATURE_TYPE_ED25519, verifyChain } from './verifier';\n\nexport type CreateCredentialSignerParams = {\n  subject: PublicKey;\n  assertion: TypedMessage;\n  nonce?: Uint8Array;\n  parentCredentialIds?: PublicKey[];\n};\n\nexport type CreateCredentialParams = {\n  signer: Signer;\n  issuer: PublicKey;\n  signingKey?: PublicKey;\n\n  // Provided only if signer is different from issuer.\n  chain?: Chain;\n\n  subject: PublicKey;\n  assertion: TypedMessage;\n  nonce?: Uint8Array;\n  parentCredentialIds?: PublicKey[];\n};\n\n/**\n * Construct a signed credential message.\n */\nexport const createCredential = async ({\n  signer,\n  issuer,\n  subject,\n  assertion,\n  signingKey,\n  chain,\n  nonce,\n  parentCredentialIds,\n}: CreateCredentialParams): Promise<Credential> => {\n  invariant(assertion['@type'], 'Invalid assertion.');\n  invariant(!!signingKey === !!chain, 'Chain must be provided if and only if the signing key differs from the issuer.');\n  if (chain) {\n    const result = await verifyChain(chain, issuer, signingKey!);\n    invariant(result.kind === 'pass', 'Invalid chain.');\n  }\n\n  // Create the credential with proof value and chain fields missing (for signature payload).\n  const credential: Credential = {\n    issuer,\n    issuanceDate: new Date(),\n    subject: {\n      id: subject,\n      assertion,\n    },\n    parentCredentialIds,\n    proof: {\n      type: SIGNATURE_TYPE_ED25519,\n      creationDate: new Date(),\n      signer: signingKey ?? issuer,\n      value: new Uint8Array(),\n      nonce,\n    },\n  };\n\n  // Set proof after creating signature.\n  const signedPayload = getCredentialProofPayload(credential);\n  credential.proof!.value = await signer.sign(signingKey ?? issuer, signedPayload);\n  if (chain) {\n    credential.proof!.chain = chain;\n  }\n\n  credential.id = PublicKey.from(await subtleCrypto.digest('SHA-256', signedPayload));\n\n  return credential;\n};\n\n// TODO(burdon): Use consistently (merge halo/echo protocol packages).\nexport const createCredentialMessage = (credential: Credential) => {\n  return {\n    '@type': 'dxos.echo.feed.CredentialsMessage',\n    credential,\n  };\n};\n\n// TODO(burdon): Vs. Signer.\nexport interface CredentialSigner {\n  getIssuer(): PublicKey;\n  createCredential: (params: CreateCredentialSignerParams) => Promise<Credential>;\n}\n\n/**\n * Issue credentials directly signed by the issuer.\n */\nexport const createCredentialSignerWithKey = (signer: Signer, issuer: PublicKey): CredentialSigner => ({\n  getIssuer: () => issuer,\n  createCredential: ({ subject, assertion, nonce, parentCredentialIds }) =>\n    createCredential({\n      signer,\n      issuer,\n      subject,\n      assertion,\n      nonce,\n      parentCredentialIds,\n    }),\n});\n\n/**\n * Issue credentials with transitive proof via a chain.\n */\nexport const createCredentialSignerWithChain = (\n  signer: Signer,\n  chain: Chain,\n  signingKey: PublicKey,\n): CredentialSigner => ({\n  getIssuer: () => chain.credential.issuer,\n  createCredential: ({ subject, assertion, nonce, parentCredentialIds }) =>\n    createCredential({\n      signer,\n      issuer: chain.credential.issuer,\n      signingKey,\n      chain,\n      subject,\n      assertion,\n      nonce,\n      parentCredentialIds,\n    }),\n});\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { verifySignature } from '@dxos/crypto';\nimport { type PublicKey } from '@dxos/keys';\nimport { type Chain, type Credential } from '@dxos/protocols/proto/dxos/halo/credentials';\n\nimport { isValidAuthorizedDeviceCredential } from './assertions';\nimport { getCredentialProofPayload } from './signing';\n\nexport const SIGNATURE_TYPE_ED25519 = 'ED25519Signature';\n\nexport type VerificationResult = { kind: 'pass' } | { kind: 'fail'; errors: string[] };\n\nexport const verifyCredential = async (credential: Credential): Promise<VerificationResult> => {\n  if (credential.parentCredentialIds?.length === 0) {\n    delete credential.parentCredentialIds;\n  }\n\n  if (!credential.issuer.equals(credential.proof!.signer)) {\n    if (!credential.proof!.chain) {\n      return {\n        kind: 'fail',\n        errors: ['Delegated credential is missing credential chain.'],\n      };\n    }\n\n    const result = await verifyChain(credential.proof!.chain, credential.issuer, credential.proof!.signer);\n    if (result.kind === 'fail') {\n      return result;\n    }\n  }\n\n  const result = await verifyCredentialSignature(credential);\n  if (result.kind === 'fail') {\n    return result;\n  }\n\n  return { kind: 'pass' };\n};\n\n/**\n * Verifies that the signature is valid and was made by the signer.\n * Does not validate other semantics (e.g. chains).\n */\nexport const verifyCredentialSignature = async (credential: Credential): Promise<VerificationResult> => {\n  if (credential.proof!.type !== SIGNATURE_TYPE_ED25519) {\n    return {\n      kind: 'fail',\n      errors: [`Invalid signature type: ${credential.proof!.type}`],\n    };\n  }\n\n  const signData = getCredentialProofPayload(credential);\n  if (!(await verifySignature(credential.proof!.signer, signData, credential.proof!.value))) {\n    return { kind: 'fail', errors: ['Invalid signature'] };\n  }\n\n  return { kind: 'pass' };\n};\n\n/**\n * Verifies that the signer has the delegated authority to create credentials on behalf of the issuer.\n */\nexport const verifyChain = async (\n  chain: Chain,\n  authority: PublicKey,\n  subject: PublicKey,\n): Promise<VerificationResult> => {\n  const result = await verifyCredential(chain.credential);\n  if (result.kind === 'fail') {\n    return result;\n  }\n\n  if (!isValidAuthorizedDeviceCredential(chain.credential, authority, subject)) {\n    return {\n      kind: 'fail',\n      errors: [`Invalid credential chain: invalid assertion for key: ${subject}`],\n    };\n  }\n\n  return { kind: 'pass' };\n};\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { type Signer } from '@dxos/crypto';\nimport { type PublicKey } from '@dxos/keys';\nimport { type TypedMessage } from '@dxos/protocols/proto';\nimport { type FeedMessage } from '@dxos/protocols/proto/dxos/echo/feed';\nimport {\n  AdmittedFeed,\n  type Credential,\n  type DeviceProfileDocument,\n  type ProfileDocument,\n  SpaceMember,\n} from '@dxos/protocols/proto/dxos/halo/credentials';\nimport { type DelegateSpaceInvitation } from '@dxos/protocols/proto/dxos/halo/invitations';\nimport { Timeframe } from '@dxos/timeframe';\n\nimport { createCredential, type CredentialSigner } from './credential-factory';\n\n// TODO(burdon): Normalize generate and functions below.\n//  Use throughout stack and in tests.\n\n/**\n * Utility class for generating credential messages, where the issuer is the current identity or device.\n */\nexport class CredentialGenerator {\n  constructor(\n    private readonly _signer: Signer,\n    private readonly _identityKey: PublicKey,\n    private readonly _deviceKey: PublicKey,\n  ) {}\n\n  /**\n   * Create genesis messages for new Space.\n   */\n  async createSpaceGenesis(\n    spaceKey: PublicKey,\n    controlKey: PublicKey,\n    creatorProfile?: ProfileDocument,\n  ): Promise<Credential[]> {\n    return [\n      await createCredential({\n        signer: this._signer,\n        issuer: spaceKey,\n        subject: spaceKey,\n        assertion: {\n          '@type': 'dxos.halo.credentials.SpaceGenesis',\n          spaceKey,\n        },\n      }),\n\n      await createCredential({\n        signer: this._signer,\n        issuer: spaceKey,\n        subject: this._identityKey,\n        assertion: {\n          '@type': 'dxos.halo.credentials.SpaceMember',\n          spaceKey,\n          role: SpaceMember.Role.ADMIN,\n          profile: creatorProfile,\n          genesisFeedKey: controlKey,\n        },\n      }),\n\n      await this.createFeedAdmission(spaceKey, controlKey, AdmittedFeed.Designation.CONTROL),\n    ];\n  }\n\n  /**\n   * Create invitation.\n   * Admit identity and control and data feeds.\n   */\n  // TODO(burdon): Reconcile with above (esp. Signer).\n  async createMemberInvitation(\n    spaceKey: PublicKey,\n    identityKey: PublicKey,\n    deviceKey: PublicKey,\n    controlKey: PublicKey,\n    dataKey: PublicKey,\n    genesisFeedKey: PublicKey,\n  ): Promise<Credential[]> {\n    return [\n      await createCredential({\n        signer: this._signer,\n        issuer: this._identityKey,\n        subject: identityKey,\n        assertion: {\n          '@type': 'dxos.halo.credentials.SpaceMember',\n          spaceKey,\n          role: SpaceMember.Role.EDITOR,\n          genesisFeedKey,\n        },\n      }),\n\n      await this.createFeedAdmission(spaceKey, controlKey, AdmittedFeed.Designation.CONTROL),\n      await this.createFeedAdmission(spaceKey, dataKey, AdmittedFeed.Designation.DATA),\n    ];\n  }\n\n  /**\n   * Add device to space.\n   */\n  // TODO(burdon): Reconcile with below.\n  async createDeviceAuthorization(deviceKey: PublicKey): Promise<Credential> {\n    return createCredential({\n      signer: this._signer,\n      issuer: this._identityKey,\n      subject: deviceKey,\n      assertion: {\n        '@type': 'dxos.halo.credentials.AuthorizedDevice',\n        identityKey: this._identityKey,\n        deviceKey,\n      },\n    });\n  }\n\n  /**\n   * Add device metadata.\n   */\n  async createDeviceProfile(profile: DeviceProfileDocument): Promise<Credential> {\n    return createCredential({\n      signer: this._signer,\n      issuer: this._identityKey,\n      subject: this._deviceKey,\n      assertion: {\n        '@type': 'dxos.halo.credentials.DeviceProfile',\n        profile,\n      },\n    });\n  }\n\n  /**\n   * Add feed to space.\n   */\n  async createFeedAdmission(\n    spaceKey: PublicKey,\n    feedKey: PublicKey,\n    designation: AdmittedFeed.Designation,\n  ): Promise<Credential> {\n    return createCredential({\n      signer: this._signer,\n      issuer: this._identityKey,\n      subject: feedKey,\n      assertion: {\n        '@type': 'dxos.halo.credentials.AdmittedFeed',\n        spaceKey,\n        identityKey: this._identityKey,\n        deviceKey: this._deviceKey,\n        designation,\n      },\n    });\n  }\n\n  async createProfileCredential(profile: ProfileDocument): Promise<Credential> {\n    return createCredential({\n      signer: this._signer,\n      issuer: this._identityKey,\n      subject: this._identityKey,\n      assertion: {\n        '@type': 'dxos.halo.credentials.IdentityProfile',\n        profile,\n      },\n    });\n  }\n\n  async createEpochCredential(spaceKey: PublicKey): Promise<Credential> {\n    return createCredential({\n      signer: this._signer,\n      issuer: this._identityKey,\n      subject: spaceKey,\n      assertion: {\n        '@type': 'dxos.halo.credentials.Epoch',\n        number: 0,\n        timeframe: new Timeframe(),\n      },\n    });\n  }\n}\n\n// TODO(burdon): Reconcile with above (esp. Signer).\nexport const createDeviceAuthorization = async (\n  signer: CredentialSigner,\n  identityKey: PublicKey,\n  deviceKey: PublicKey,\n): Promise<TypedMessage[]> => {\n  const credentials = await Promise.all([\n    await signer.createCredential({\n      subject: deviceKey,\n      assertion: {\n        '@type': 'dxos.halo.credentials.AuthorizedDevice',\n        identityKey,\n        deviceKey,\n      },\n    }),\n  ]);\n\n  return credentials.map((credential) => ({\n    '@type': 'dxos.echo.feed.CredentialsMessage',\n    credential,\n  }));\n};\n\n// TODO(burdon): Reconcile with above (esp. Signer).\n/**\n * @param signer - invitation signer.\n * @param identityKey - identity key of the admitted member.\n * @param spaceKey - subject space key.\n * @param genesisFeedKey - genesis feed key of the space.\n * @param role - role of the newly added member.\n * @param membershipChainHeads - ids of the last known SpaceMember credentials (branching possible).\n * @param profile - profile of the newly added member.\n * @param invitationCredentialId - id of the delegated invitation credential in case one was used to add the member.\n */\nexport const createAdmissionCredentials = async (\n  signer: CredentialSigner,\n  identityKey: PublicKey,\n  spaceKey: PublicKey,\n  genesisFeedKey: PublicKey,\n  role: SpaceMember.Role = SpaceMember.Role.ADMIN,\n  membershipChainHeads: PublicKey[] = [],\n  profile?: ProfileDocument,\n  invitationCredentialId?: PublicKey,\n): Promise<FeedMessage.Payload[]> => {\n  const credentials = await Promise.all([\n    await signer.createCredential({\n      subject: identityKey,\n      parentCredentialIds: membershipChainHeads,\n      assertion: {\n        '@type': 'dxos.halo.credentials.SpaceMember',\n        spaceKey,\n        role,\n        profile,\n        genesisFeedKey,\n        invitationCredentialId,\n      },\n    }),\n  ]);\n\n  return credentials.map((credential) => ({\n    credential: { credential },\n  }));\n};\n\nexport const createDelegatedSpaceInvitationCredential = async (\n  signer: CredentialSigner,\n  subject: PublicKey,\n  invitation: DelegateSpaceInvitation,\n): Promise<FeedMessage.Payload> => {\n  const credential = await signer.createCredential({\n    subject,\n    assertion: {\n      '@type': 'dxos.halo.invitations.DelegateSpaceInvitation',\n      invitationId: invitation.invitationId,\n      authMethod: invitation.authMethod,\n      swarmKey: invitation.swarmKey,\n      role: invitation.role,\n      guestKey: invitation.guestKey,\n      expiresOn: invitation.expiresOn,\n      multiUse: invitation.multiUse,\n    },\n  });\n  return { credential: { credential } };\n};\n\n/**\n * @param signer - credential issuer.\n * @param subject - key of the space the invitation was for.\n * @param invitationCredentialId id of a dxos.halo.invitations.DelegateSpaceInvitation credential.\n */\nexport const createCancelDelegatedSpaceInvitationCredential = async (\n  signer: CredentialSigner,\n  subject: PublicKey,\n  invitationCredentialId: PublicKey,\n): Promise<FeedMessage.Payload> => {\n  const credential = await signer.createCredential({\n    subject,\n    assertion: {\n      '@type': 'dxos.halo.invitations.CancelDelegatedInvitation',\n      credentialId: invitationCredentialId,\n    },\n  });\n  return { credential: { credential } };\n};\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { type Signer } from '@dxos/crypto';\nimport { type PublicKey } from '@dxos/keys';\nimport { type Chain, type Presentation, type Proof } from '@dxos/protocols/proto/dxos/halo/credentials';\n\nimport { getPresentationProofPayload } from './signing';\nimport { SIGNATURE_TYPE_ED25519 } from '../credentials';\n\n// TODO(burdon): Rename createPresentation?\nexport const signPresentation = async ({\n  presentation,\n  signer,\n  signerKey,\n  chain,\n  nonce,\n}: {\n  presentation: Presentation;\n  signer: Signer;\n  signerKey: PublicKey;\n  chain?: Chain;\n  nonce?: Uint8Array;\n}): Promise<Presentation> => {\n  const proof: Proof = {\n    type: SIGNATURE_TYPE_ED25519,\n    value: new Uint8Array(),\n    creationDate: new Date(),\n    signer: signerKey,\n    nonce,\n  };\n\n  const signedPayload = getPresentationProofPayload(presentation.credentials ?? [], proof);\n  proof.value = await signer.sign(signerKey, signedPayload);\n  if (chain) {\n    proof.chain = chain;\n  }\n\n  return {\n    credentials: presentation.credentials,\n    proofs: [...(presentation.proofs ?? []), proof],\n  };\n};\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { verifySignature } from '@dxos/crypto';\nimport { type Presentation, type Proof } from '@dxos/protocols/proto/dxos/halo/credentials';\n\nimport { getPresentationProofPayload } from './signing';\nimport { SIGNATURE_TYPE_ED25519, type VerificationResult, verifyChain, verifyCredential } from '../credentials';\n\nexport const verifyPresentation = async (presentation: Presentation): Promise<VerificationResult> => {\n  const errors: string[] = [];\n\n  // Verify all credentials.\n  const credentialsVerifications = await Promise.all(\n    presentation.credentials?.map((credential) => verifyCredential(credential)) ?? [],\n  );\n  for (const verification of credentialsVerifications) {\n    if (verification.kind === 'fail') {\n      errors.push(...verification.errors);\n    }\n  }\n\n  // Verify all proofs.\n  const proofVerification = await Promise.all(\n    presentation.proofs?.map(async (proof) => {\n      const chainVerification = await verifyPresentationChain(presentation, proof);\n      if (chainVerification.kind === 'fail') {\n        return chainVerification;\n      }\n      const signatureVerification = await verifyPresentationSignature(presentation, proof);\n      if (signatureVerification.kind === 'fail') {\n        return signatureVerification;\n      }\n      return { kind: 'pass' } as VerificationResult;\n    }) ?? [],\n  );\n  for (const verification of proofVerification) {\n    if (verification.kind === 'fail') {\n      errors.push(...verification.errors);\n    }\n  }\n\n  if (errors.length === 0) {\n    return { kind: 'pass' };\n  }\n  {\n    return {\n      kind: 'fail',\n      errors,\n    };\n  }\n};\n\nexport const verifyPresentationChain = async (\n  presentation: Presentation,\n  proof: Proof,\n): Promise<VerificationResult> => {\n  for (const credential of presentation.credentials ?? []) {\n    if (!credential.issuer.equals(proof.signer)) {\n      if (!proof.chain) {\n        return {\n          kind: 'fail',\n          errors: ['Delegated credential is missing credential chain.'],\n        };\n      }\n\n      const chainVerification = await verifyChain(proof.chain, credential.subject.id, proof.signer);\n      if (chainVerification.kind === 'fail') {\n        return chainVerification;\n      }\n    }\n  }\n\n  return { kind: 'pass' };\n};\n\n/**\n * Verifies that the signature is valid and was made by the signer.\n * Does not validate other semantics (e.g. chains).\n */\nexport const verifyPresentationSignature = async (\n  presentation: Presentation,\n  proof: Proof,\n): Promise<VerificationResult> => {\n  if (proof.type !== SIGNATURE_TYPE_ED25519) {\n    return {\n      kind: 'fail',\n      errors: [`Invalid signature type: ${proof.type}`],\n    };\n  }\n\n  const signData = getPresentationProofPayload(presentation.credentials ?? [], proof);\n  if (!(await verifySignature(proof.signer, signData, proof.value))) {\n    return { kind: 'fail', errors: ['Invalid signature'] };\n  }\n\n  return { kind: 'pass' };\n};\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { runInContextAsync, synchronized } from '@dxos/async';\nimport { Context } from '@dxos/context';\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { type TypedMessage } from '@dxos/protocols/proto';\nimport { type Credential, SpaceMember } from '@dxos/protocols/proto/dxos/halo/credentials';\nimport { type DelegateSpaceInvitation } from '@dxos/protocols/proto/dxos/halo/invitations';\nimport { type AsyncCallback, Callback, ComplexMap, ComplexSet } from '@dxos/util';\n\nimport { type FeedInfo, FeedStateMachine } from './feed-state-machine';\nimport { InvitationStateMachine } from './invitation-state-machine';\nimport { MemberStateMachine, type MemberInfo } from './member-state-machine';\nimport { getCredentialAssertion, verifyCredential } from '../credentials';\nimport { type CredentialProcessor } from '../processor/credential-processor';\n\nexport interface SpaceState {\n  readonly members: ReadonlyMap<PublicKey, MemberInfo>;\n  readonly membershipChainHeads: PublicKey[];\n  readonly feeds: ReadonlyMap<PublicKey, FeedInfo>;\n  readonly credentials: Credential[];\n  readonly genesisCredential: Credential | undefined;\n  readonly creator: MemberInfo | undefined;\n  readonly invitations: ReadonlyMap<PublicKey, DelegateSpaceInvitation>;\n\n  addCredentialProcessor(processor: CredentialProcessor): Promise<void>;\n  removeCredentialProcessor(processor: CredentialProcessor): Promise<void>;\n\n  getCredentialsOfType(type: TypedMessage['@type']): Credential[];\n\n  getMemberRole(memberKey: PublicKey): SpaceMember.Role;\n  hasMembershipManagementPermission(memberKey: PublicKey): boolean;\n}\n\nexport type ProcessOptions = {\n  sourceFeed: PublicKey;\n  skipVerification?: boolean;\n};\n\nexport type CredentialEntry = {\n  credential: Credential;\n  sourceFeed: PublicKey;\n  revoked: boolean;\n};\n\n/**\n * Validates and processes credentials for a single space.\n * Keeps a list of members and feeds.\n * Keeps and in-memory index of credentials and allows to query them.\n */\nexport class SpaceStateMachine implements SpaceState {\n  private readonly _members = new MemberStateMachine(this._spaceKey);\n  private readonly _feeds = new FeedStateMachine(this._spaceKey);\n  private readonly _invitations = new InvitationStateMachine();\n  private readonly _credentials: CredentialEntry[] = [];\n  private readonly _credentialsById = new ComplexMap<PublicKey, CredentialEntry>(PublicKey.hash);\n  private readonly _processedCredentials = new ComplexSet<PublicKey>(PublicKey.hash);\n\n  private _genesisCredential: Credential | undefined;\n  private _credentialProcessors: CredentialConsumer<any>[] = [];\n\n  readonly onCredentialProcessed = new Callback<AsyncCallback<Credential>>();\n  readonly onMemberRoleChanged = this._members.onMemberRoleChanged;\n  readonly onFeedAdmitted = this._feeds.onFeedAdmitted;\n  readonly onDelegatedInvitation = this._invitations.onDelegatedInvitation;\n  readonly onDelegatedInvitationRemoved = this._invitations.onDelegatedInvitationRemoved;\n\n  constructor(private readonly _spaceKey: PublicKey) {}\n\n  get creator(): MemberInfo | undefined {\n    return this._members.creator;\n  }\n\n  get members(): ReadonlyMap<PublicKey, MemberInfo> {\n    return this._members.members;\n  }\n\n  get membershipChainHeads(): PublicKey[] {\n    return this._members.membershipChainHeads;\n  }\n\n  get feeds(): ReadonlyMap<PublicKey, FeedInfo> {\n    return this._feeds.feeds;\n  }\n\n  get credentials(): Credential[] {\n    return this._credentials.map((entry) => entry.credential);\n  }\n\n  get credentialEntries(): CredentialEntry[] {\n    return this._credentials;\n  }\n\n  get genesisCredential(): Credential | undefined {\n    return this._genesisCredential;\n  }\n\n  get invitations(): ReadonlyMap<PublicKey, DelegateSpaceInvitation> {\n    return this._invitations.invitations;\n  }\n\n  async addCredentialProcessor(processor: CredentialProcessor): Promise<void> {\n    if (this._credentialProcessors.find((p) => p.processor === processor)) {\n      throw new Error('Credential processor already added.');\n    }\n\n    const consumer = new CredentialConsumer(\n      processor,\n      async () => {\n        for (const credential of this.credentials) {\n          await consumer._process(credential);\n        }\n\n        // NOTE: It is important to set this flag after immediately after processing existing credentials.\n        // Otherwise, we might miss some credentials.\n        // Having an `await` statement between the end of the loop and setting the flag would cause a race condition.\n        consumer._isReadyForLiveCredentials = true;\n      },\n      async () => {\n        this._credentialProcessors = this._credentialProcessors.filter((p) => p !== consumer);\n      },\n    );\n    this._credentialProcessors.push(consumer);\n\n    await consumer.open();\n  }\n\n  async removeCredentialProcessor(processor: CredentialProcessor): Promise<void> {\n    const consumer = this._credentialProcessors.find((p) => p.processor === processor);\n    await consumer?.close();\n  }\n\n  getCredentialsOfType(type: TypedMessage['@type']): Credential[] {\n    return this.credentials.filter((credential) => getCredentialAssertion(credential)['@type'] === type);\n  }\n\n  /**\n   * @param credential Message to process.\n   * @param fromFeed Key of the feed where this credential is recorded.\n   */\n  @synchronized\n  async process(credential: Credential, { sourceFeed, skipVerification }: ProcessOptions): Promise<boolean> {\n    if (credential.id) {\n      if (this._processedCredentials.has(credential.id)) {\n        return true;\n      }\n      this._processedCredentials.add(credential.id);\n    }\n\n    if (!skipVerification) {\n      const result = await verifyCredential(credential);\n      if (result.kind !== 'pass') {\n        log.warn(`Invalid credential: ${result.errors.join(', ')}`);\n        return false;\n      }\n    }\n\n    const assertion = getCredentialAssertion(credential);\n    switch (assertion['@type']) {\n      case 'dxos.halo.credentials.SpaceGenesis': {\n        if (this._genesisCredential) {\n          log.warn('Space already has a genesis credential.');\n          return false;\n        }\n        if (!credential.issuer.equals(this._spaceKey)) {\n          log.warn('Space genesis credential must be issued by space.');\n          return false;\n        }\n        if (!credential.subject.id.equals(this._spaceKey)) {\n          log.warn('Space genesis credential must be issued to space.');\n          return false;\n        }\n        this._genesisCredential = credential;\n        break;\n      }\n\n      case 'dxos.halo.credentials.SpaceMember': {\n        if (!assertion.spaceKey.equals(this._spaceKey)) {\n          break; // Ignore credentials for other spaces.\n        }\n\n        if (!this._genesisCredential) {\n          log.warn('Space must have a genesis credential before adding members.');\n          return false;\n        }\n        if (!this._canInviteNewMembers(credential.issuer)) {\n          log.warn(`Space member is not authorized to invite new members: ${credential.issuer}`);\n          return false;\n        }\n\n        await this._members.process(credential);\n        await this._invitations.process(credential);\n        break;\n      }\n\n      case 'dxos.halo.credentials.MemberProfile': {\n        if (!this._genesisCredential) {\n          log.warn('Space must have a genesis credential before adding members.');\n          return false;\n        }\n\n        await this._members.process(credential);\n        break;\n      }\n\n      case 'dxos.halo.credentials.AdmittedFeed': {\n        if (!this._genesisCredential) {\n          log.warn('Space must have a genesis credential before admitting feeds.');\n          return false;\n        }\n\n        // We don't do any validation on feed admission since we would perform the same validation on the credentials inside .\n        await this._feeds.process(credential, sourceFeed);\n        break;\n      }\n      case 'dxos.halo.invitations.CancelDelegatedInvitation':\n      case 'dxos.halo.invitations.DelegateSpaceInvitation': {\n        if (!this._canInviteNewMembers(credential.issuer)) {\n          log.warn(`Invalid invitation, space member is not authorized to invite new members: ${credential.issuer}`);\n          return false;\n        }\n        await this._invitations.process(credential);\n        break;\n      }\n    }\n\n    const newEntry: CredentialEntry = { credential, sourceFeed, revoked: false };\n    this._credentials.push(newEntry);\n\n    // TODO(dmaretskyi): Invariant on every credential having an id?\n    if (credential.id) {\n      this._credentialsById.set(credential.id, newEntry);\n    }\n\n    for (const processor of this._credentialProcessors) {\n      if (processor._isReadyForLiveCredentials) {\n        await processor._process(credential);\n      }\n    }\n\n    await this.onCredentialProcessed.callIfSet(credential);\n    return true;\n  }\n\n  public getMemberRole(memberKey: PublicKey): SpaceMember.Role {\n    return this._members.getRole(memberKey);\n  }\n\n  public hasMembershipManagementPermission(memberKey: PublicKey): boolean {\n    return this._canInviteNewMembers(memberKey);\n  }\n\n  private _canInviteNewMembers(key: PublicKey): boolean {\n    return (\n      key.equals(this._spaceKey) ||\n      this._members.getRole(key) === SpaceMember.Role.ADMIN ||\n      this._members.getRole(key) === SpaceMember.Role.OWNER\n    );\n  }\n}\n\n// TODO(dmaretskyi): Simplify.\nclass CredentialConsumer<T extends CredentialProcessor> {\n  private _ctx = new Context();\n\n  /**\n   * @internal\n   * Processor is ready to process live credentials.\n   * NOTE: Setting this flag before all existing credentials are processed will cause them to be processed out of order.\n   * Set externally.\n   */\n  _isReadyForLiveCredentials = false;\n\n  constructor(\n    public readonly processor: T,\n    private readonly _onOpen: () => Promise<void>,\n    private readonly _onClose: () => Promise<void>,\n  ) {}\n\n  /**\n   * @internal\n   */\n  async _process(credential: Credential): Promise<void> {\n    await runInContextAsync(this._ctx, async () => {\n      await this.processor.processCredential(credential);\n    });\n  }\n\n  async open(): Promise<void> {\n    if (this._ctx.disposed) {\n      throw new Error('CredentialProcessor is disposed');\n    }\n\n    await this._onOpen();\n  }\n\n  async close(): Promise<void> {\n    await this._ctx.dispose();\n\n    await this._onClose();\n  }\n}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { invariant } from '@dxos/invariant';\nimport { PublicKey } from '@dxos/keys';\nimport { type AdmittedFeed, type Credential } from '@dxos/protocols/proto/dxos/halo/credentials';\nimport { type AsyncCallback, Callback, ComplexMap } from '@dxos/util';\n\nimport { getCredentialAssertion } from '../credentials';\n\nexport interface FeedInfo {\n  key: PublicKey;\n  /**\n   * Parent feed from the feed tree.\n   * This is the feed where the AdmittedFeed assertion is written.\n   * The genesis feed will have itself as a parent.\n   */\n  parent: PublicKey;\n  credential: Credential;\n  assertion: AdmittedFeed;\n}\n\n/**\n * Tracks the feed tree for a space.\n * Provides a list of admitted feeds.\n */\nexport class FeedStateMachine {\n  private _feeds = new ComplexMap<PublicKey, FeedInfo>(PublicKey.hash);\n\n  readonly onFeedAdmitted = new Callback<AsyncCallback<FeedInfo>>();\n\n  constructor(private readonly _spaceKey: PublicKey) {}\n\n  get feeds(): ReadonlyMap<PublicKey, FeedInfo> {\n    return this._feeds;\n  }\n\n  /**\n   * Processes the AdmittedFeed credential.\n   * Assumes the credential is already pre-verified\n   * and the issuer has been authorized to issue credentials of this type.\n   * @param fromFeed Key of the feed where this credential is recorded.\n   */\n  async process(credential: Credential, fromFeed: PublicKey): Promise<void> {\n    const assertion = getCredentialAssertion(credential);\n    invariant(assertion['@type'] === 'dxos.halo.credentials.AdmittedFeed');\n    invariant(assertion.spaceKey.equals(this._spaceKey));\n\n    const info: FeedInfo = {\n      key: credential.subject.id,\n      credential,\n      assertion,\n      parent: fromFeed,\n    };\n\n    this._feeds.set(credential.subject.id, info);\n    await this.onFeedAdmitted.callIfSet(info);\n  }\n}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { PublicKey } from '@dxos/keys';\nimport { type Credential } from '@dxos/protocols/proto/dxos/halo/credentials';\nimport { type DelegateSpaceInvitation } from '@dxos/protocols/proto/dxos/halo/invitations';\nimport { type AsyncCallback, Callback, ComplexMap, ComplexSet } from '@dxos/util';\n\nimport { getCredentialAssertion } from '../credentials';\n\nexport interface DelegateInvitationCredential {\n  credentialId: PublicKey;\n  invitation: DelegateSpaceInvitation;\n}\n\n/**\n * Tracks the feed tree for a space.\n * Provides a list of admitted feeds.\n */\nexport class InvitationStateMachine {\n  private readonly _invitations = new ComplexMap<PublicKey, DelegateSpaceInvitation>(PublicKey.hash);\n  private readonly _redeemedInvitationCredentialIds = new ComplexSet(PublicKey.hash);\n  private readonly _cancelledInvitationCredentialIds = new ComplexSet(PublicKey.hash);\n\n  readonly onDelegatedInvitation = new Callback<AsyncCallback<DelegateInvitationCredential>>();\n  readonly onDelegatedInvitationRemoved = new Callback<AsyncCallback<DelegateInvitationCredential>>();\n\n  get invitations(): ReadonlyMap<PublicKey, DelegateSpaceInvitation> {\n    return this._invitations;\n  }\n\n  async process(credential: Credential): Promise<void> {\n    const credentialId = credential.id;\n    if (credentialId == null) {\n      return;\n    }\n    const assertion = getCredentialAssertion(credential);\n    switch (assertion['@type']) {\n      case 'dxos.halo.invitations.CancelDelegatedInvitation': {\n        this._cancelledInvitationCredentialIds.add(assertion.credentialId);\n        const existingInvitation = this._invitations.get(assertion.credentialId);\n        if (existingInvitation != null) {\n          this._invitations.delete(assertion.credentialId);\n          await this.onDelegatedInvitationRemoved.callIfSet({\n            credentialId: assertion.credentialId,\n            invitation: existingInvitation,\n          });\n        }\n        break;\n      }\n      case 'dxos.halo.invitations.DelegateSpaceInvitation': {\n        if (credential.id) {\n          const isExpired = assertion.expiresOn && assertion.expiresOn.getTime() < Date.now();\n          const wasUsed = this._redeemedInvitationCredentialIds.has(credential.id) && !assertion.multiUse;\n          const wasCancelled = this._cancelledInvitationCredentialIds.has(credential.id);\n          if (isExpired || wasCancelled || wasUsed) {\n            return;\n          }\n          const invitation: DelegateSpaceInvitation = { ...assertion };\n          this._invitations.set(credential.id, invitation);\n          await this.onDelegatedInvitation.callIfSet({\n            credentialId: credential.id,\n            invitation,\n          });\n        }\n        break;\n      }\n      case 'dxos.halo.credentials.SpaceMember': {\n        if (assertion.invitationCredentialId != null) {\n          this._redeemedInvitationCredentialIds.add(assertion.invitationCredentialId);\n          const existingInvitation = this._invitations.get(assertion.invitationCredentialId);\n          if (existingInvitation != null && !existingInvitation.multiUse) {\n            this._invitations.delete(assertion.invitationCredentialId);\n            await this.onDelegatedInvitationRemoved.callIfSet({\n              credentialId: assertion.invitationCredentialId,\n              invitation: existingInvitation,\n            });\n          }\n        }\n        break;\n      }\n    }\n  }\n}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { invariant } from '@dxos/invariant';\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { type Credential, SpaceMember, type ProfileDocument } from '@dxos/protocols/proto/dxos/halo/credentials';\nimport { ComplexMap } from '@dxos/util';\n\nimport { getCredentialAssertion } from '../credentials';\nimport {\n  type ChainVertex,\n  CredentialGraph,\n  type CredentialGraphStateHandler,\n  type PathState,\n  type StateScope,\n} from '../graph/credential-graph';\n\nexport interface MemberInfo {\n  key: PublicKey;\n  role: SpaceMember.Role;\n  credential: Credential;\n  assertion: SpaceMember;\n  profile?: ProfileDocument;\n}\n\n/**\n * Tracks the list of members (with roles) for the space.\n * Provides a list of admitted feeds.\n */\nexport class MemberStateMachine implements CredentialGraphStateHandler<SpaceMember, MemberInfo> {\n  private _ownerKey: PublicKey | undefined;\n  private _memberProfiles = new ComplexMap<PublicKey, ProfileDocument | undefined>(PublicKey.hash);\n  private _hashgraph = new CredentialGraph<SpaceMember, MemberInfo>(this);\n\n  readonly onMemberRoleChanged = this._hashgraph.onSubjectStateChanged;\n\n  constructor(private readonly _spaceKey: PublicKey) {}\n\n  get creator(): MemberInfo | undefined {\n    return this._ownerKey && this._hashgraph.getSubjectState(this._ownerKey);\n  }\n\n  get members(): ReadonlyMap<PublicKey, MemberInfo> {\n    return this._hashgraph.getState();\n  }\n\n  get membershipChainHeads(): PublicKey[] {\n    return this._hashgraph.getLeafIds();\n  }\n\n  getRole(member: PublicKey): SpaceMember.Role {\n    return this._getRole(this._hashgraph.getGlobalStateScope(), member);\n  }\n\n  /**\n   * Processes the SpaceMember credential.\n   * Assumes the credential is already pre-verified and the issuer has been authorized to issue credentials of this type.\n   */\n  async process(credential: Credential): Promise<void> {\n    const assertion = getCredentialAssertion(credential);\n\n    switch (assertion['@type']) {\n      case 'dxos.halo.credentials.SpaceMember': {\n        invariant(assertion.spaceKey.equals(this._spaceKey));\n        if (this._ownerKey == null && credential.issuer === this._spaceKey) {\n          this._ownerKey = credential.subject.id;\n        }\n        if (assertion.profile != null) {\n          this._memberProfiles.set(credential.subject.id, assertion.profile);\n        }\n        await this._hashgraph.addVertex(credential, assertion);\n        break;\n      }\n      case 'dxos.halo.credentials.MemberProfile': {\n        const member = this._hashgraph.getSubjectState(credential.subject.id);\n        if (member) {\n          member.profile = assertion.profile;\n        } else {\n          log.warn('Member not found', { id: credential.subject.id });\n        }\n        this._memberProfiles.set(credential.subject.id, assertion.profile);\n        break;\n      }\n      default:\n        throw new Error('Invalid assertion type');\n    }\n  }\n\n  public createState(credential: Credential, assertion: SpaceMember): MemberInfo {\n    const memberKey = credential.subject.id;\n    return {\n      key: memberKey,\n      role: assertion.role,\n      credential,\n      assertion,\n      profile: this._memberProfiles.get(memberKey),\n    };\n  }\n\n  public isUpdateAllowed(scope: StateScope<SpaceMember>, credential: Credential, assertion: SpaceMember): boolean {\n    if (assertion.role === SpaceMember.Role.OWNER) {\n      return credential!.issuer.equals(this._spaceKey);\n    }\n    const issuer = credential.issuer;\n    const isChangingOwnRole = issuer.equals(credential.subject.id);\n    if (isChangingOwnRole) {\n      return false;\n    }\n    if (issuer.equals(assertion.spaceKey)) {\n      return true;\n    }\n    const issuerRole = this._getRole(scope, issuer);\n    return issuerRole === SpaceMember.Role.ADMIN || issuerRole === SpaceMember.Role.OWNER;\n  }\n\n  public getConflictingPaths(\n    paths: PathState<SpaceMember>[],\n    update: ChainVertex<SpaceMember>,\n  ): PathState<SpaceMember>[] {\n    // a member can't be an issuer in a concurrent branch if we decided to remove or revoke admin permissions during merge\n    if (update.assertion.role !== SpaceMember.Role.REMOVED && update.assertion.role !== SpaceMember.Role.EDITOR) {\n      return [];\n    }\n    const memberId = update.credential!.subject.id!;\n    return paths.filter((p) => p.forkIssuers.has(memberId));\n  }\n\n  public tryPickWinningUpdate(\n    scope1: StateScope<SpaceMember>,\n    update1: Credential,\n    scope2: StateScope<SpaceMember>,\n    update2: Credential,\n  ): Credential | null {\n    const path1IssuerRole = this._getRole(scope1, update1.issuer);\n    const path2IssuerRole = this._getRole(scope2, update2.issuer);\n    if ((path2IssuerRole === SpaceMember.Role.OWNER) !== (path1IssuerRole === SpaceMember.Role.OWNER)) {\n      log('owner decision used to break the tie');\n      return path1IssuerRole === SpaceMember.Role.OWNER ? update1 : update2;\n    }\n    return null;\n  }\n\n  public toLogString(assertion: SpaceMember | undefined): string {\n    const role = assertion?.role ?? SpaceMember.Role.REMOVED;\n    return Object.entries(SpaceMember.Role).find(([_, value]) => value === role)![0];\n  }\n\n  public hasStateChanged(s1?: MemberInfo, s2?: MemberInfo): boolean {\n    return s1?.role !== s2?.role;\n  }\n\n  private _getRole(scope: StateScope<SpaceMember>, memberId: PublicKey): SpaceMember.Role {\n    if (this._ownerKey?.equals(memberId)) {\n      return SpaceMember.Role.OWNER;\n    }\n    const realRole = scope.state.get(memberId)?.assertion?.role ?? SpaceMember.Role.REMOVED;\n    if (scope.stateOverrides != null) {\n      const override = scope.stateOverrides.get(memberId);\n      if (override != null) {\n        log('member role overridden in path', () => ({\n          headId: scope.head?.id,\n          roleOverride: this.toLogString(override.assertion),\n          realRole: this.toLogString(scope.state.get(memberId)?.assertion),\n        }));\n        return override.assertion.role;\n      }\n    }\n    return realRole;\n  }\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { invariant } from '@dxos/invariant';\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { type Credential } from '@dxos/protocols/proto/dxos/halo/credentials';\nimport { type AsyncCallback, Callback, ComplexMap, ComplexSet } from '@dxos/util';\n\nexport class CredentialGraph<A, State> {\n  /**\n   * Local ids are used during traversals.\n   */\n  private _vertexIdGenerator = 1;\n  /**\n   * All credentials without parent references are connected to the root.\n   */\n  private _root = { id: -1, parents: [], children: [] } as any as ChainVertex<A>;\n  /**\n   * A credential which is not a parent of any other credential has the sentinel as a child.\n   * Sentinel is a virtual merge-point of all credentials.\n   */\n  private _sentinel = { id: -2, parents: [], children: [] } as any as ChainVertex<A>;\n  /**\n   * Vertex references are used for fast credential inserts into the graph.\n   */\n  private _vertexByCredentialId = new ComplexMap<PublicKey, ChainVertex<A>>(PublicKey.hash);\n  /**\n   * The current state of the graph.\n   */\n  private _subjectToVertex = new ComplexMap<PublicKey, ChainVertex<A>>(PublicKey.hash);\n  private _subjectToState = new ComplexMap<PublicKey, State>(PublicKey.hash);\n\n  public onSubjectStateChanged = new Callback<AsyncCallback<State[]>>();\n\n  constructor(private readonly _stateHandler: CredentialGraphStateHandler<A, State>) {}\n\n  public getSubjectState(subjectId: PublicKey): State | undefined {\n    return this._subjectToState.get(subjectId);\n  }\n\n  public getState(): ReadonlyMap<PublicKey, State> {\n    return this._subjectToState;\n  }\n\n  public getLeafIds(): PublicKey[] {\n    return this._sentinel.parents.map((v) => v.credential!.id!);\n  }\n\n  public getGlobalStateScope(): StateScope<A> {\n    return { state: this._subjectToVertex };\n  }\n\n  public addVertex(credential: Credential, assertion: A): Promise<void> {\n    const newVertex: ChainVertex<A> = {\n      id: this._vertexIdGenerator++,\n      credential,\n      assertion,\n      parents: [],\n      children: [],\n    };\n    this._vertexByCredentialId.set(credential.id!, newVertex);\n    const parentIds = credential.parentCredentialIds ?? [];\n    if (parentIds.length === 0) {\n      this._root.children.push(newVertex);\n      newVertex.parents.push(this._root);\n    } else {\n      for (const parentId of parentIds) {\n        const parentVertex = this._vertexByCredentialId.get(parentId);\n        if (parentVertex == null) {\n          log.error('credential skipped because of the unknown parent', { credential, parentId });\n          continue;\n        }\n        parentVertex.children.push(newVertex);\n        newVertex.parents.push(parentVertex);\n        this._removeSentinelConnection(parentVertex);\n      }\n    }\n    newVertex.children.push(this._sentinel);\n    this._sentinel.parents.push(newVertex);\n    return this._onVertexInserted(newVertex);\n  }\n\n  private _removeSentinelConnection(vertex: ChainVertex<A>): void {\n    const sentinelIdx = vertex.children.indexOf(this._sentinel);\n    if (sentinelIdx >= 0) {\n      vertex.children.splice(sentinelIdx, 1);\n      const vertexInSentinelIdx = this._sentinel.parents.indexOf(vertex);\n      invariant(vertexInSentinelIdx >= 0);\n      this._sentinel.parents.splice(vertexInSentinelIdx, 1);\n    }\n  }\n\n  private async _onVertexInserted(newVertex: ChainVertex<A>): Promise<void> {\n    const { credential, assertion } = newVertex;\n    invariant(credential);\n    let changedSubjects: State[] = [];\n    const isUpdateAppliedOnTopOfThePreviousState = this._sentinel.parents.length === 1;\n    if (isUpdateAppliedOnTopOfThePreviousState) {\n      const subjectId = credential.subject.id;\n      if (this._stateHandler.isUpdateAllowed(this.getGlobalStateScope(), credential, assertion)) {\n        const newSubjectState = this._stateHandler.createState(credential, newVertex.assertion);\n        const prevSubjectState = this._subjectToState.get(subjectId);\n        this._subjectToState.set(subjectId, newSubjectState);\n        this._subjectToVertex.set(subjectId, newVertex);\n        if (this._stateHandler.hasStateChanged(newSubjectState, prevSubjectState)) {\n          changedSubjects.push(newSubjectState);\n        }\n      }\n    } else {\n      changedSubjects = this._recomputeState();\n    }\n    if (changedSubjects.length > 0) {\n      await this.onSubjectStateChanged.callIfSet(changedSubjects);\n    }\n  }\n\n  /**\n   * DFS the graph from root to sentinel pausing on merge points (nodes with multiple parents).\n   * Continue after all paths leading to a merge point converge by merging their states.\n   * In case of a concurrent update paths are replayed taking into account the state set\n   * by the winning branch.\n   */\n  private _recomputeState(): State[] {\n    // ID of a merge point to the list of paths that reached the point.\n    const pendingPaths = new Map<number, PathState<A>[]>();\n    const paths: PathState<A>[] = [this._createRootPath()];\n    let lastPath: PathState<A> | null = null;\n    while (lastPath == null) {\n      const path = paths.pop()!;\n      log('visit vertex', { id: path.head.id });\n      this._updatePathState(path);\n      const convergedPaths = this._handleMergePoint(paths, pendingPaths, path);\n      if (convergedPaths == null) {\n        log('waiting for other paths');\n        continue;\n      }\n      const mergeResult = this._mergePaths(convergedPaths);\n      if (mergeResult.type === 'replay_required') {\n        this._replayFailedPaths(paths, pendingPaths, mergeResult, convergedPaths);\n        continue;\n      }\n      const merged = mergeResult.path;\n      if (merged.head.children.length === 0) {\n        lastPath = merged;\n      } else if (merged.head.children.length === 1) {\n        merged.head = merged.head.children[0];\n        paths.push(merged);\n      } else {\n        this._forkTraversal(paths, merged);\n      }\n    }\n    if (paths.length > 0) {\n      log.error('traversal finished while there were active paths', {\n        paths: paths.map((p) => ({ path: toChosenPath(p), head: p.head.id })),\n      });\n    }\n    return this._setCurrentState(lastPath);\n  }\n\n  private _replayFailedPaths(\n    paths: PathState<A>[],\n    pendingPaths: Map<number, PathState<A>[]>,\n    mergeResult: ReplayRequiredMergeResult<A>,\n    convergedPaths: PathState<A>[],\n  ): void {\n    paths.push(\n      ...mergeResult.replay.map((path) => {\n        const stateOverrides = path.stateOverrides ?? new ComplexMap<PublicKey, ChainVertex<A>>(PublicKey.hash);\n        mergeResult.stateOverrides.forEach((value, key) => stateOverrides.set(key, value));\n        return { ...mergeResult.from, chosenPath: path.chosenPath, stateOverrides };\n      }),\n    );\n    log('replay paths', () => ({\n      count: paths.length,\n      paths: paths.map((path) => ({\n        from: mergeResult.from.head.id,\n        path: toChosenPath(path),\n        overrides: path?.stateOverrides?.mapValues((v) => this._stateHandler.toLogString(v.assertion)),\n      })),\n    }));\n    const clearedPending = convergedPaths.filter((l) => !mergeResult.replay.includes(l));\n    pendingPaths.set(convergedPaths[0].head.id, clearedPending);\n  }\n\n  private _handleMergePoint(\n    paths: PathState<A>[],\n    pendingPaths: Map<number, PathState<A>[]>,\n    path: PathState<A>,\n  ): PathState<A>[] | null {\n    const pendingList = pendingPaths.get(path.head.id) ?? [];\n    pendingPaths.set(path.head.id, pendingList);\n    pendingList.push(path);\n    if (pendingList.length < path.head.parents.length) {\n      return null;\n    }\n    if (path.head.id === this._sentinel.id && paths.length > 0) {\n      log('waiting for all the active paths to converge on the sentinel');\n      return null;\n    }\n    pendingPaths.delete(path.head.id);\n    return pendingList;\n  }\n\n  private _updatePathState(path: PathState<A>): void {\n    const headCredential = path.head.credential;\n    if (headCredential == null) {\n      return;\n    }\n    const updatedSubject = headCredential.subject.id;\n    path.credentials.add(headCredential.id!);\n    let isUpdateAllowed = this._stateHandler.isUpdateAllowed(path, headCredential, path.head.assertion);\n    // Compatibility with old credentials where parent references were not specified.\n    if (!isUpdateAllowed && path.head.parents[0]?.id === this._root.id) {\n      const globalState = this.getGlobalStateScope();\n      isUpdateAllowed = this._stateHandler.isUpdateAllowed(globalState, headCredential, path.head.assertion);\n    }\n    if (isUpdateAllowed) {\n      path.forkChangedSubjects.add(updatedSubject);\n      path.forkIssuers.add(headCredential.issuer);\n      path.state.set(updatedSubject, path.head);\n      log('path state updated', () => ({\n        subject: updatedSubject,\n        newState: this._stateHandler.toLogString(path.head.assertion),\n      }));\n    }\n  }\n\n  private _forkTraversal(paths: PathState<A>[], path: PathState<A>): void {\n    const replayChoice = path.chosenPath?.[path.head.id];\n    const choices = replayChoice ?? path.head.children;\n    for (const choice of choices) {\n      log('edge traversal', { from: path.head.id, to: choice.id });\n      const fork: PathState<A> = {\n        forkPoint: path,\n        chosenPath: { ...path.chosenPath, [path.head.id]: [choice] },\n        head: choice,\n        credentials: new ComplexSet(PublicKey.hash, path.credentials),\n        state: new ComplexMap(PublicKey.hash, [...path.state.entries()]),\n        forkIssuers: new ComplexSet(PublicKey.hash),\n        forkChangedSubjects: new ComplexSet(PublicKey.hash),\n        stateOverrides: path.stateOverrides,\n      };\n      paths.push(fork);\n    }\n  }\n\n  /**\n   * Updates the current graph state.\n   * @returns changed states.\n   */\n  private _setCurrentState(path: PathState<A>): State[] {\n    const changedSubjects: State[] = [];\n    const newStateMap = new ComplexMap<PublicKey, State>(PublicKey.hash);\n    const newVertexMap = new ComplexMap<PublicKey, ChainVertex<A>>(PublicKey.hash);\n    for (const [subjectKey, subjectVertex] of path.state.entries()) {\n      const newState = this._stateHandler.createState(subjectVertex.credential!, subjectVertex.assertion);\n      const prevState = this._subjectToState.get(subjectKey);\n      newStateMap.set(subjectKey, newState);\n      newVertexMap.set(subjectKey, subjectVertex);\n      if (this._stateHandler.hasStateChanged(newState, prevState)) {\n        changedSubjects.push(newState);\n      }\n    }\n    this._subjectToState = newStateMap;\n    this._subjectToVertex = newVertexMap;\n    return changedSubjects;\n  }\n\n  /*\n   * Walk up all the fork points and return the first one present in all the paths.\n   * We use local id to determine vertex position in the graph, because nodes can't\n   * be inserted in the middle (between a parent and a child) and ids are monotonically increasing.\n   */\n  private _leastCommonAncestor(paths: PathState<A>[]): PathState<A> {\n    const uniqueForkPoints = paths.reduce((acc, path) => {\n      let it = path.forkPoint;\n      while (it) {\n        acc.set(it.head.id, it);\n        it = it.forkPoint;\n      }\n      return acc;\n    }, new Map<number, PathState<A>>());\n    let maxId = this._root.id;\n    let maxState: PathState<A> | null = null;\n    for (const [id, state] of uniqueForkPoints.entries()) {\n      const headCredential = state.head.credential;\n      if (headCredential != null) {\n        const isPointInEveryPath = paths.every((p) => p.credentials.has(headCredential.id!));\n        if (isPointInEveryPath && id > maxId) {\n          maxId = id;\n          maxState = state;\n        }\n      }\n    }\n    return maxState ?? this._createRootPath();\n  }\n\n  /**\n   * We might be merging paths where some of them had fork points after the initial forking.\n   * We need all the paths to point to the least common fork point and contain all the changes\n   * that happened after it.\n   */\n  private _moveUpToForkPoint(forkPoint: PathState<A>, path: PathState<A>): PathState<A> {\n    const isForkPointInPath = path.chosenPath[forkPoint.head.id] == null || path.forkPoint == null;\n    if (isForkPointInPath) {\n      return path;\n    }\n    if (forkPoint.head.id === path.forkPoint?.head.id) {\n      return path;\n    }\n    let it = path.forkPoint!;\n    while (it.head.id !== forkPoint.head.id) {\n      it.forkIssuers.forEach((iss) => path.forkIssuers.add(iss));\n      it.forkChangedSubjects.forEach((m) => path.forkChangedSubjects.add(m));\n      it = it!.forkPoint!;\n      path.forkPoint = it;\n    }\n    return path;\n  }\n\n  private _mergePaths(convergedPaths: PathState<A>[]): PathMergeResult<A> {\n    invariant(convergedPaths.length >= 1);\n    if (convergedPaths.length === 1) {\n      return { type: 'merged', path: convergedPaths[0] };\n    }\n    const forkPoint = this._leastCommonAncestor(convergedPaths);\n    log('merging paths', () => ({\n      forkPointId: forkPoint.head.id,\n      pathCount: convergedPaths.length,\n      forkPoints: convergedPaths.map((fp) => fp.forkPoint?.head.id),\n    }));\n    const paths = convergedPaths.map((p) => this._moveUpToForkPoint(forkPoint, p));\n    invariant(forkPoint);\n    const result: PathState<A> = {\n      forkPoint: forkPoint.forkPoint,\n      chosenPath: { ...forkPoint.chosenPath, [forkPoint.head.id]: [] },\n      stateOverrides: forkPoint.stateOverrides,\n      credentials: new ComplexSet(PublicKey.hash, forkPoint.credentials),\n      forkIssuers: new ComplexSet(PublicKey.hash, forkPoint.forkIssuers),\n      forkChangedSubjects: new ComplexSet(PublicKey.hash, forkPoint.forkChangedSubjects),\n      state: forkPoint.state.mapValues((v) => v),\n      head: paths[0].head,\n    };\n    const subjectToBranch = new ComplexMap<PublicKey, PathState<A>>(PublicKey.hash);\n    for (const path of paths) {\n      log('processing a path', () => ({\n        choices: toChosenPath(path),\n        modified: path.forkChangedSubjects,\n        forkIssuers: path.forkIssuers,\n        state: path.state.mapValues((v) => this._stateHandler.toLogString(v.assertion)),\n      }));\n      path.forkIssuers.forEach((iss) => result.forkIssuers.add(iss));\n      path.credentials.forEach((cred) => result.credentials.add(cred));\n      result.chosenPath![forkPoint.head.id].push(...(path.chosenPath![forkPoint.head.id] ?? []));\n      for (const modifiedSubject of path.forkChangedSubjects) {\n        const existingBranch = subjectToBranch.get(modifiedSubject);\n        if (existingBranch == null || this._shouldOverrideCredential(existingBranch, path, modifiedSubject)) {\n          subjectToBranch.set(modifiedSubject, path);\n        }\n      }\n    }\n    const replayPaths = new Set<PathState<A>>();\n    const addReplayPath = replayPaths.add.bind(replayPaths);\n    for (const [subject, branch] of subjectToBranch.entries()) {\n      result.forkChangedSubjects.add(subject);\n      const vertex = branch.state.get(subject)!;\n      result.state.set(subject, vertex);\n      log('set subject state', () => ({ subject, state: this._stateHandler.toLogString(vertex.assertion) }));\n      const otherPaths = paths.filter((p) => p !== branch);\n      this._stateHandler.getConflictingPaths(otherPaths, vertex).forEach(addReplayPath);\n    }\n    if (replayPaths.size > 0) {\n      return {\n        type: 'replay_required',\n        replay: [...replayPaths.values()],\n        from: forkPoint,\n        stateOverrides: subjectToBranch.mapValues((v, key) => v.state.get(key)!),\n      };\n    }\n    return { type: 'merged', path: result };\n  }\n\n  /**\n   * A candidate credential is preferred over the existing credential if:\n   *  1. It is the merge-point, because it's the last credential that was issued in awareness of all\n   *  the previously existing ones.\n   *  2. A path where candidate was set contains existing credential in it, which means that the candidate\n   *  was issued after the existing credential by a legitimate issuer.\n   *  3. A state-specific logic (_stateHandler) is able to justify using the candidate credential.\n   *  4. The path where candidate was set has more issuers than the existing path (longer branch).\n   *  5. The issuance time of the candidate is after the issuance time of the existing credential (LWW).\n   */\n  private _shouldOverrideCredential(\n    existing: PathState<A>,\n    candidate: PathState<A>,\n    modifiedSubject: PublicKey,\n  ): boolean {\n    const candidateVertex = candidate.state.get(modifiedSubject)!;\n    const currentVertex = existing.state.get(modifiedSubject)!;\n    if (candidateVertex.id === currentVertex.id) {\n      return false;\n    }\n    // During merge all paths are pointing to the same head, which is the merge point.\n    const mergePointId = existing.head.id;\n    if (candidateVertex.id === mergePointId || currentVertex.id === mergePointId) {\n      log('merge point chosen to break the tie', { mergePointId: existing.head.id });\n      return mergePointId === candidateVertex.id;\n    }\n    const candidateCredential = candidateVertex.credential!;\n    const currentCredential = currentVertex.credential!;\n    // A credential is contained in a branch where another credential for this subject was issued.\n    if (existing.credentials.has(candidateCredential.id!) !== candidate.credentials.has(currentCredential.id!)) {\n      log('one of the credentials was overridden in another branch', {\n        current: currentVertex.id,\n        candidate: candidateVertex.id,\n      });\n      return candidate.credentials.has(currentCredential.id!);\n    }\n    // Give a chance to state-specific conflict resolution logic.\n    const winningCredential = this._stateHandler.tryPickWinningUpdate(\n      existing,\n      currentCredential,\n      candidate,\n      candidateCredential,\n    );\n    if (winningCredential != null) {\n      return winningCredential === candidateCredential;\n    }\n    if (candidate.forkIssuers.size !== existing.forkIssuers.size) {\n      log('longer issuers branch used to break the tie', {\n        issuerCount: [existing.forkIssuers.size, candidate.forkIssuers.size],\n      });\n      return candidate.forkIssuers.size > existing.forkIssuers.size;\n    }\n    log('issuance date used to break the tie');\n    return candidateCredential.issuanceDate.getTime() > currentCredential.issuanceDate.getTime();\n  }\n\n  private _createRootPath(): PathState<A> {\n    return {\n      head: this._root,\n      chosenPath: {},\n      forkIssuers: new ComplexSet(PublicKey.hash),\n      forkChangedSubjects: new ComplexSet(PublicKey.hash),\n      state: new ComplexMap<PublicKey, ChainVertex<A>>(PublicKey.hash),\n      credentials: new ComplexSet(PublicKey.hash),\n    };\n  }\n}\n\nexport interface StateScope<A> {\n  head?: { id: number };\n  state: ReadonlyMap<PublicKey, ChainVertex<A>>;\n  stateOverrides?: ReadonlyMap<PublicKey, ChainVertex<A>>;\n}\n\nexport interface CredentialGraphStateHandler<Assertion, State> {\n  hasStateChanged(s1?: State, s2?: State): boolean;\n\n  createState(credential: Credential, assertion: Assertion): State;\n\n  isUpdateAllowed: (scope: StateScope<Assertion>, update: Credential, assertion: Assertion) => boolean;\n\n  getConflictingPaths(paths: PathState<Assertion>[], update: ChainVertex<Assertion>): PathState<Assertion>[];\n\n  tryPickWinningUpdate(\n    scope1: StateScope<Assertion>,\n    update1: Credential,\n    scope2: StateScope<Assertion>,\n    update2: Credential,\n  ): Credential | null;\n\n  toLogString(assertion: Assertion): string;\n}\n\nexport interface PathState<A> {\n  /**\n   * The current vertex position in path, always advances.\n   */\n  head: ChainVertex<A>;\n  /**\n   * Subject info local to the current path.\n   */\n  state: ComplexMap<PublicKey, ChainVertex<A>>;\n  /**\n   * Used during path replay to throw away cascading concurrent modifications.\n   * Overrides pathState.\n   */\n  stateOverrides?: ComplexMap<PublicKey, ChainVertex<A>>;\n  /**\n   * Used to faster search of conflicting branches. Is different from pathState.keys()\n   * because pathState is not reset on forks.\n   */\n  forkChangedSubjects: ComplexSet<PublicKey>;\n  /**\n   * Used to find winning branches. A branch wins if it had more participants.\n   * Ties are broken using credential issuance date.\n   */\n  forkIssuers: ComplexSet<PublicKey>;\n  /**\n   * All the credentials processed during this path traversal.\n   */\n  credentials: ComplexSet<PublicKey>;\n  /**\n   * PathState where we had multiple children in the current vertex.\n   * Will be merged with child branches when they converge.\n   */\n  forkPoint?: PathState<A>;\n  /**\n   * Used for a particular path replay with stateOverrides for conflict resolution\n   * forkVertexId is mapped to child vertex selection.\n   * Contains choices that lead to the current state. Value is an array when\n   * some branches converged before converging with the remaining branches.\n   */\n  chosenPath: { [forkVertexId: number]: ChainVertex<A>[] };\n}\n\nexport interface ChainVertex<Assertion> {\n  /**\n   * The field is missing on root and sentinel vertices. Assertion is not undefined to avoid\n   * always asserting two fields.\n   */\n  credential?: Credential;\n  assertion: Assertion;\n  /**\n   * Local incrementing counter used to form paths. Is used only for causality resolution.\n   */\n  id: number;\n  /**\n   * Parents references are used to handle divergent branch merge-points.\n   */\n  parents: ChainVertex<Assertion>[];\n  /**\n   * Child references are traversed when computing the current state.\n   */\n  children: ChainVertex<Assertion>[];\n}\n\ntype PathMergeResult<A> = SuccessfulMergeResult<A> | ReplayRequiredMergeResult<A>;\n\ninterface SuccessfulMergeResult<A> {\n  type: 'merged';\n  path: PathState<A>;\n}\n\ninterface ReplayRequiredMergeResult<A> {\n  type: 'replay_required';\n  from: PathState<A>;\n  replay: PathState<A>[];\n  stateOverrides: ComplexMap<PublicKey, ChainVertex<A>>;\n}\n\nconst toChosenPath = <A>(path: PathState<A>) => {\n  return Object.fromEntries(Object.entries(path.chosenPath!).map(([k, vs]) => [k, vs.map((v) => v.id)]));\n};\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { Trigger } from '@dxos/async';\nimport { invariant } from '@dxos/invariant';\nimport { PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { type Chain, type Credential, type DeviceProfileDocument } from '@dxos/protocols/proto/dxos/halo/credentials';\nimport { ComplexMap } from '@dxos/util';\n\nimport { type CredentialProcessor } from './credential-processor';\nimport { getCredentialAssertion, isValidAuthorizedDeviceCredential } from '../credentials';\n\nexport type DeviceStateMachineParams = {\n  identityKey: PublicKey;\n  deviceKey: PublicKey;\n  onUpdate?: () => void;\n};\n\n/**\n * Processes device invitation credentials.\n */\nexport class DeviceStateMachine implements CredentialProcessor {\n  // TODO(burdon): Return values via getter.\n  public readonly authorizedDeviceKeys = new ComplexMap<PublicKey, DeviceProfileDocument>(PublicKey.hash);\n\n  public readonly deviceChainReady = new Trigger();\n\n  public deviceCredentialChain?: Chain;\n\n  constructor(private readonly _params: DeviceStateMachineParams) {}\n\n  async processCredential(credential: Credential): Promise<void> {\n    log('processing credential...', {\n      identityKey: this._params.identityKey,\n      deviceKey: this._params.deviceKey,\n      credential,\n    });\n\n    // Save device keychain credential when processed by the space state machine.\n    if (isValidAuthorizedDeviceCredential(credential, this._params.identityKey, this._params.deviceKey)) {\n      this.deviceCredentialChain = { credential };\n      this.deviceChainReady.wake();\n    }\n\n    const assertion = getCredentialAssertion(credential);\n\n    switch (assertion['@type']) {\n      case 'dxos.halo.credentials.AuthorizedDevice': {\n        // We don't need to validate that the device is already added since the credentials are considered idempotent.\n        // In the future, when we will have device-specific attributes, we should join them from all concurrent credentials.\n        this.authorizedDeviceKeys.set(assertion.deviceKey, this.authorizedDeviceKeys.get(assertion.deviceKey) ?? {});\n\n        log('added device', {\n          localDeviceKey: this._params.deviceKey,\n          deviceKey: assertion.deviceKey,\n          size: this.authorizedDeviceKeys.size,\n        });\n        this._params.onUpdate?.();\n        break;\n      }\n\n      case 'dxos.halo.credentials.DeviceProfile': {\n        invariant(this.authorizedDeviceKeys.has(credential.subject.id), 'Device not found.');\n\n        if (assertion && credential.subject.id.equals(this._params.deviceKey)) {\n          log.trace('dxos.halo.device', {\n            deviceKey: credential.subject.id,\n            profile: assertion.profile,\n          });\n        }\n\n        this.authorizedDeviceKeys.set(credential.subject.id, assertion.profile);\n        this._params.onUpdate?.();\n        break;\n      }\n    }\n  }\n}\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { type PublicKey } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport { type Credential, type ProfileDocument } from '@dxos/protocols/proto/dxos/halo/credentials';\n\nimport { type CredentialProcessor } from './credential-processor';\nimport { getCredentialAssertion } from '../credentials';\n\nexport type ProfileStateMachineParams = {\n  identityKey: PublicKey;\n  onUpdate?: () => void;\n};\n\n/**\n * Processes device invitation credentials.\n */\nexport class ProfileStateMachine implements CredentialProcessor {\n  // TODO(burdon): Return values via getter.\n  public profile?: ProfileDocument;\n\n  constructor(private readonly _params: ProfileStateMachineParams) {}\n\n  async processCredential(credential: Credential): Promise<void> {\n    const assertion = getCredentialAssertion(credential);\n    switch (assertion['@type']) {\n      case 'dxos.halo.credentials.IdentityProfile': {\n        if (\n          !credential.issuer.equals(this._params.identityKey) ||\n          !credential.subject.id.equals(this._params.identityKey)\n        ) {\n          log.warn('Invalid profile credential', { expectedIdentity: this._params.identityKey, credential });\n          return;\n        }\n\n        // TODO(dmaretskyi): Extra validation for the credential?\n        this.profile = assertion.profile;\n        log('updated profile', {\n          identityKey: this._params.identityKey,\n          profile: this.profile,\n        });\n        this._params.onUpdate?.();\n        break;\n      }\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": ["import_crypto", "import_keys", "import_util", "import_invariant", "import_timeframe", "import_credentials", "import_log", "import_async", "IDENTITY_DIDS_CACHE", "ComplexMap", "PublicKey", "hash", "createDidFromIdentityKey", "identityKey", "cachedValue", "get", "undefined", "digest", "subtleCrypto", "asUint8Array", "bytes", "Uint8Array", "slice", "IdentityDid", "byteLength", "identityDid", "encode", "set", "defaultSecretProvider", "Buffer", "from", "defaultSecretValidator", "invitation", "secret", "generateSeedPhrase", "generateMnemonic", "keyPairFromSeedPhrase", "seedPhrase", "invariant", "seed", "mnemonicToSeedSync", "createKeyPair", "generatePasscode", "length", "passcode", "i", "Math", "floor", "random", "getCredentialProofPayload", "credential", "copy", "proof", "value", "chain", "parentCredentialIds", "id", "canonicalStringify", "obj", "stableStringify", "replacer", "key", "toString", "startsWith", "original", "isPublicKey", "toHex", "isBuffer", "arrayToBuffer", "data", "type", "Timeframe", "frames", "reduce", "seq", "truncateKey", "str", "substring", "getPresentationProofPayload", "credentials", "map", "removeEmptyParentCredentialIds", "getCredentialAssertion", "subject", "assertion", "isValidAuthorizedDeviceCredential", "deviceKey", "equals", "issuer", "checkCredentialType", "credentialTypeFilter", "SIGNATURE_TYPE_ED25519", "verifyCredential", "signer", "kind", "errors", "result", "verifyChain", "verifyCredentialSignature", "signData", "verifySignature", "authority", "createCredential", "signingKey", "nonce", "issuanceDate", "Date", "creationDate", "signedPayload", "sign", "createCredentialMessage", "createCredentialSignerWithKey", "getIssuer", "createCredentialSignerWithChain", "CredentialGenerator", "_signer", "_identityKey", "_deviceKey", "createSpaceGenesis", "spaceKey", "controlKey", "creatorProfile", "role", "SpaceMember", "Role", "ADMIN", "profile", "genesisFeedKey", "createFeedAdmission", "AdmittedFeed", "Designation", "CONTROL", "createMemberInvitation", "dataKey", "EDITOR", "DATA", "createDeviceAuthorization", "createDeviceProfile", "feedKey", "designation", "createProfileCredential", "createEpochCredential", "number", "timeframe", "Promise", "all", "createAdmissionCredentials", "membershipChainHeads", "invitationCredentialId", "createDelegatedSpaceInvitationCredential", "invitationId", "authMethod", "swarmKey", "guestKey", "expiresOn", "multiUse", "createCancelDelegatedSpaceInvitationCredential", "credentialId", "signPresentation", "presentation", "signerKey", "proofs", "verifyPresentation", "credentialsVerifications", "verification", "push", "proofVerification", "chainVerification", "verifyPresentationChain", "signatureVerification", "verifyPresentationSignature", "FeedStateMachine", "_spaceKey", "_feeds", "onFeedAdmitted", "Callback", "feeds", "process", "fromFeed", "info", "parent", "callIfSet", "InvitationStateMachine", "_invitations", "_redeemedInvitationCredentialIds", "ComplexSet", "_cancelledInvitationCredentialIds", "onDelegatedInvitation", "onDelegatedInvitationRemoved", "invitations", "add", "existingInvitation", "delete", "isExpired", "getTime", "now", "wasUsed", "has", "wasCancelled", "CredentialGraph", "_stateHandler", "_vertexIdGenerator", "_root", "parents", "children", "_sentinel", "_vertexByCredentialId", "_subjectToVertex", "_subjectToState", "onSubjectStateChanged", "getSubjectState", "subjectId", "getState", "getLeafIds", "v", "getGlobalStateScope", "state", "addVertex", "newVertex", "parentIds", "parentId", "parentVertex", "log", "error", "_removeSentinelConnection", "_onVertexInserted", "vertex", "sentinelIdx", "indexOf", "splice", "vertexInSentinelIdx", "changedSubjects", "isUpdateAppliedOnTopOfThePreviousState", "isUpdateAllowed", "newSubjectState", "createState", "prevSubjectState", "hasStateChanged", "_recomputeState", "pendingPaths", "Map", "paths", "_createRootPath", "lastPath", "path", "pop", "head", "_updatePathState", "convergedPaths", "_handleMergePoint", "mergeResult", "_mergePaths", "_replayFailedPaths", "merged", "_forkTraversal", "p", "toChosenPath", "_setCurrentState", "replay", "stateOverrides", "forEach", "chosenPath", "count", "overrides", "mapValues", "toLogString", "clearedPending", "filter", "l", "includes", "pendingList", "headCredential", "updatedSubject", "globalState", "forkChangedSubjects", "forkIssuers", "newState", "replayChoice", "choices", "choice", "to", "fork", "forkPoint", "entries", "newStateMap", "newVertexMap", "subjectKey", "subjectVertex", "prevState", "_leastCommonAncestor", "uniqueForkPoints", "acc", "it", "maxId", "maxState", "isPointInEveryPath", "every", "_moveUpToForkPoint", "isForkPointInPath", "iss", "m", "forkPointId", "pathCount", "forkPoints", "fp", "subjectToBranch", "modified", "cred", "modifiedSubject", "existingBranch", "_shouldOverrideCredential", "replayPaths", "Set", "addReplayPath", "bind", "branch", "otherPaths", "getConflictingPaths", "size", "values", "existing", "candidate", "candidateVertex", "currentVertex", "mergePointId", "candidateCredential", "currentCredential", "current", "winningCredential", "tryPickWinningUpdate", "issuerCount", "Object", "fromEntries", "k", "vs", "MemberStateMachine", "_memberProfiles", "_hashgraph", "onMemberRoleChanged", "creator", "_ownerKey", "members", "getRole", "member", "_getRole", "warn", "Error", "memberKey", "scope", "OWNER", "isChangingOwnRole", "issuerRole", "update", "REMOVED", "memberId", "scope1", "update1", "scope2", "update2", "path1IssuerRole", "path2IssuerRole", "find", "_", "s1", "s2", "realRole", "override", "headId", "roleOverride", "SpaceStateMachine", "_members", "_credentials", "_credentialsById", "_processedCredentials", "_credentialProcessors", "onCredentialProcessed", "entry", "credentialEntries", "genesisCredential", "_genesisCredential", "addCredentialProcessor", "processor", "consumer", "CredentialConsumer", "_process", "_isReadyForLiveCredentials", "open", "removeCredentialProcessor", "close", "getCredentialsOfType", "sourceFeed", "skipVerification", "join", "_canInviteNewMembers", "newEntry", "revoked", "getMemberRole", "hasMembershipManagementPermission", "_onOpen", "_onClose", "_ctx", "Context", "runInContextAsync", "processCredential", "disposed", "dispose", "DeviceStateMachine", "_params", "authorizedDeviceKeys", "deviceChainReady", "Trigger", "deviceCredentialChain", "wake", "localDeviceKey", "onUpdate", "trace", "ProfileStateMachine", "expectedIdentity"]
}
