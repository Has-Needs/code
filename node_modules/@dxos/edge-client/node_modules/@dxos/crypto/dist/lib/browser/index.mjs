import "@dxos/node-std/globals";

// packages/common/crypto/src/keys.ts
import { invariant } from "@dxos/invariant";
import { PublicKey, PUBLIC_KEY_LENGTH, SECRET_KEY_LENGTH } from "@dxos/keys";
import crypto2 from "#hypercore-crypto";
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/common/crypto/src/keys.ts";
var SIGNATURE_LENGTH = 64;
var createId = () => PublicKey.stringify(randomBytes(32));
var createKeyPair = (seed) => {
  if (seed) {
    invariant(seed.length >= 32, "Seedphrase too sort. Expecting length of 32.", {
      F: __dxlog_file,
      L: 20,
      S: void 0,
      A: [
        "seed.length >= 32",
        "'Seedphrase too sort. Expecting length of 32.'"
      ]
    });
    return crypto2.keyPair(seed.slice(0, 32));
  }
  return crypto2.keyPair();
};
var validateKeyPair = (publicKey, secretKey) => crypto2.validateKeyPair({
  publicKey: publicKey.asBuffer(),
  secretKey
});
var discoveryKey = (key) => crypto2.discoveryKey(PublicKey.from(key).asBuffer().slice(1));
var randomBytes = (length = 32) => crypto2.randomBytes(length);
var sign = (message, secretKey) => {
  invariant(Buffer.isBuffer(message), void 0, {
    F: __dxlog_file,
    L: 50,
    S: void 0,
    A: [
      "Buffer.isBuffer(message)",
      ""
    ]
  });
  invariant(Buffer.isBuffer(secretKey) && secretKey.length === SECRET_KEY_LENGTH, void 0, {
    F: __dxlog_file,
    L: 51,
    S: void 0,
    A: [
      "Buffer.isBuffer(secretKey) && secretKey.length === SECRET_KEY_LENGTH",
      ""
    ]
  });
  return crypto2.sign(message, secretKey);
};
var verify = (message, signature, publicKey) => {
  invariant(Buffer.isBuffer(message), void 0, {
    F: __dxlog_file,
    L: 64,
    S: void 0,
    A: [
      "Buffer.isBuffer(message)",
      ""
    ]
  });
  invariant(Buffer.isBuffer(signature) && signature.length === SIGNATURE_LENGTH, void 0, {
    F: __dxlog_file,
    L: 65,
    S: void 0,
    A: [
      "Buffer.isBuffer(signature) && signature.length === SIGNATURE_LENGTH",
      ""
    ]
  });
  invariant(Buffer.isBuffer(publicKey) && publicKey.length === PUBLIC_KEY_LENGTH, void 0, {
    F: __dxlog_file,
    L: 66,
    S: void 0,
    A: [
      "Buffer.isBuffer(publicKey) && publicKey.length === PUBLIC_KEY_LENGTH",
      ""
    ]
  });
  return crypto2.verify(message, signature, publicKey);
};

// packages/common/crypto/src/browser/subtle.ts
var subtleCrypto = crypto.subtle;
var webcrypto = crypto;

// packages/common/crypto/src/validator.ts
import { PublicKey as PublicKey2 } from "@dxos/keys";
import { verify as verify2 } from "#hypercore-crypto";
var getSignatureValidator = (publicKey) => (message, signature) => verify2(message, signature, PublicKey2.bufferize(publicKey));

// packages/common/crypto/src/verify.ts
var verifySignature = async (key, message, signature, algorithm = {
  name: "ECDSA",
  namedCurve: "P-256"
}) => {
  let publicKey;
  try {
    publicKey = await subtleCrypto.importKey("raw", key.asUint8Array(), algorithm, true, [
      "verify"
    ]);
  } catch {
    return false;
  }
  return subtleCrypto.verify({
    name: algorithm.name,
    hash: "SHA-256"
  }, publicKey, signature, message);
};

// packages/common/crypto/src/uuid.ts
var randomUUID = () => {
  return webcrypto.randomUUID();
};
export {
  SIGNATURE_LENGTH,
  createId,
  createKeyPair,
  discoveryKey,
  getSignatureValidator,
  randomBytes,
  randomUUID,
  sign,
  subtleCrypto,
  validateKeyPair,
  verify,
  verifySignature,
  webcrypto
};
//# sourceMappingURL=index.mjs.map
