"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var node_exports = {};
__export(node_exports, {
  SIGNATURE_LENGTH: () => SIGNATURE_LENGTH,
  createId: () => createId,
  createKeyPair: () => createKeyPair,
  discoveryKey: () => discoveryKey,
  getSignatureValidator: () => getSignatureValidator,
  randomBytes: () => randomBytes,
  randomUUID: () => randomUUID,
  sign: () => sign,
  subtleCrypto: () => subtleCrypto,
  validateKeyPair: () => validateKeyPair,
  verify: () => verify,
  verifySignature: () => verifySignature,
  webcrypto: () => webcrypto2
});
module.exports = __toCommonJS(node_exports);
var import_invariant = require("@dxos/invariant");
var import_keys = require("@dxos/keys");
var import_hypercore_crypto = __toESM(require("#hypercore-crypto"));
var nodeCrypto = __toESM(require("node:crypto"));
var import_keys2 = require("@dxos/keys");
var import_hypercore_crypto2 = require("#hypercore-crypto");
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/common/crypto/src/keys.ts";
var SIGNATURE_LENGTH = 64;
var createId = () => import_keys.PublicKey.stringify(randomBytes(32));
var createKeyPair = (seed) => {
  if (seed) {
    (0, import_invariant.invariant)(seed.length >= 32, "Seedphrase too sort. Expecting length of 32.", {
      F: __dxlog_file,
      L: 20,
      S: void 0,
      A: [
        "seed.length >= 32",
        "'Seedphrase too sort. Expecting length of 32.'"
      ]
    });
    return import_hypercore_crypto.default.keyPair(seed.slice(0, 32));
  }
  return import_hypercore_crypto.default.keyPair();
};
var validateKeyPair = (publicKey, secretKey) => import_hypercore_crypto.default.validateKeyPair({
  publicKey: publicKey.asBuffer(),
  secretKey
});
var discoveryKey = (key) => import_hypercore_crypto.default.discoveryKey(import_keys.PublicKey.from(key).asBuffer().slice(1));
var randomBytes = (length = 32) => import_hypercore_crypto.default.randomBytes(length);
var sign = (message, secretKey) => {
  (0, import_invariant.invariant)(Buffer.isBuffer(message), void 0, {
    F: __dxlog_file,
    L: 50,
    S: void 0,
    A: [
      "Buffer.isBuffer(message)",
      ""
    ]
  });
  (0, import_invariant.invariant)(Buffer.isBuffer(secretKey) && secretKey.length === import_keys.SECRET_KEY_LENGTH, void 0, {
    F: __dxlog_file,
    L: 51,
    S: void 0,
    A: [
      "Buffer.isBuffer(secretKey) && secretKey.length === SECRET_KEY_LENGTH",
      ""
    ]
  });
  return import_hypercore_crypto.default.sign(message, secretKey);
};
var verify = (message, signature, publicKey) => {
  (0, import_invariant.invariant)(Buffer.isBuffer(message), void 0, {
    F: __dxlog_file,
    L: 64,
    S: void 0,
    A: [
      "Buffer.isBuffer(message)",
      ""
    ]
  });
  (0, import_invariant.invariant)(Buffer.isBuffer(signature) && signature.length === SIGNATURE_LENGTH, void 0, {
    F: __dxlog_file,
    L: 65,
    S: void 0,
    A: [
      "Buffer.isBuffer(signature) && signature.length === SIGNATURE_LENGTH",
      ""
    ]
  });
  (0, import_invariant.invariant)(Buffer.isBuffer(publicKey) && publicKey.length === import_keys.PUBLIC_KEY_LENGTH, void 0, {
    F: __dxlog_file,
    L: 66,
    S: void 0,
    A: [
      "Buffer.isBuffer(publicKey) && publicKey.length === PUBLIC_KEY_LENGTH",
      ""
    ]
  });
  return import_hypercore_crypto.default.verify(message, signature, publicKey);
};
var subtleCrypto = nodeCrypto.webcrypto.subtle;
var webcrypto2 = nodeCrypto.webcrypto;
var getSignatureValidator = (publicKey) => (message, signature) => (0, import_hypercore_crypto2.verify)(message, signature, import_keys2.PublicKey.bufferize(publicKey));
var verifySignature = async (key, message, signature, algorithm = {
  name: "ECDSA",
  namedCurve: "P-256"
}) => {
  let publicKey;
  try {
    publicKey = await subtleCrypto.importKey("raw", key.asUint8Array(), algorithm, true, [
      "verify"
    ]);
  } catch {
    return false;
  }
  return subtleCrypto.verify({
    name: algorithm.name,
    hash: "SHA-256"
  }, publicKey, signature, message);
};
var randomUUID = () => {
  return webcrypto2.randomUUID();
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  SIGNATURE_LENGTH,
  createId,
  createKeyPair,
  discoveryKey,
  getSignatureValidator,
  randomBytes,
  randomUUID,
  sign,
  subtleCrypto,
  validateKeyPair,
  verify,
  verifySignature,
  webcrypto
});
//# sourceMappingURL=index.cjs.map
