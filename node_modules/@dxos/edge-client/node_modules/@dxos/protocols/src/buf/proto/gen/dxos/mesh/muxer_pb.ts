//
// Copyright 2020 DXOS.org
//

// @generated by protoc-gen-es v2.1.0 with parameter "target=ts,import_extension=js"
// @generated from file dxos/mesh/muxer.proto (package dxos.mesh.muxer, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file dxos/mesh/muxer.proto.
 */
export const file_dxos_mesh_muxer: GenFile = /*@__PURE__*/
  fileDesc("ChVkeG9zL21lc2gvbXV4ZXIucHJvdG8SD2R4b3MubWVzaC5tdXhlciLHAQoHQ29tbWFuZBI0CgxvcGVuX2NoYW5uZWwYASABKAsyHC5keG9zLm1lc2gubXV4ZXIuT3BlbkNoYW5uZWxIABIlCgRkYXRhGAIgASgLMhUuZHhvcy5tZXNoLm11eGVyLkRhdGFIABIrCgdkZXN0cm95GAMgASgLMhguZHhvcy5tZXNoLm11eGVyLkRlc3Ryb3lIABInCgVjbG9zZRgEIAEoCzIWLmR4b3MubWVzaC5tdXhlci5DbG9zZUgAQgkKB3BheWxvYWQiUgoLT3BlbkNoYW5uZWwSCgoCaWQYASABKAUSCwoDdGFnGAIgASgJEhkKDGNvbnRlbnRfdHlwZRgDIAEoCUgAiAEBQg8KDV9jb250ZW50X3R5cGUiKAoERGF0YRISCgpjaGFubmVsX2lkGAEgASgFEgwKBGRhdGEYAiABKAwiJwoHRGVzdHJveRISCgVlcnJvchgBIAEoCUgAiAEBQggKBl9lcnJvciIlCgVDbG9zZRISCgVlcnJvchgBIAEoCUgAiAEBQggKBl9lcnJvcmIGcHJvdG8z");

/**
 * / Root type for messages sent over the stream.
 *
 * @generated from message dxos.mesh.muxer.Command
 */
export type Command = Message<"dxos.mesh.muxer.Command"> & {
  /**
   * @generated from oneof dxos.mesh.muxer.Command.payload
   */
  payload: {
    /**
     * @generated from field: dxos.mesh.muxer.OpenChannel open_channel = 1;
     */
    value: OpenChannel;
    case: "openChannel";
  } | {
    /**
     * @generated from field: dxos.mesh.muxer.Data data = 2;
     */
    value: Data;
    case: "data";
  } | {
    /**
     * deprecated.
     *
     * @generated from field: dxos.mesh.muxer.Destroy destroy = 3;
     */
    value: Destroy;
    case: "destroy";
  } | {
    /**
     * @generated from field: dxos.mesh.muxer.Close close = 4;
     */
    value: Close;
    case: "close";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message dxos.mesh.muxer.Command.
 * Use `create(CommandSchema)` to create a new message.
 */
export const CommandSchema: GenMessage<Command> = /*@__PURE__*/
  messageDesc(file_dxos_mesh_muxer, 0);

/**
 * *
 * Notify the remote peer that we are opening a channel.
 *
 * Means that we are ready to receive data on the channel.
 * The remote peer could now send data messages with this channel id that will be atributed to this channel.
 *
 * The local peer must buffer any data messages until the remote peer replies with OpenChannel for this tag. 
 *
 * @generated from message dxos.mesh.muxer.OpenChannel
 */
export type OpenChannel = Message<"dxos.mesh.muxer.OpenChannel"> & {
  /**
   * / Session-specific ID for the channel.
   *
   * @generated from field: int32 id = 1;
   */
  id: number;

  /**
   * / Stable identifier for the channel that is agreed upon by both peers.
   *
   * @generated from field: string tag = 2;
   */
  tag: string;

  /**
   * / Optional Mime-type or URL describing the protocol that is hosted ober this stream. Used for introspection.
   *
   * @generated from field: optional string content_type = 3;
   */
  contentType?: string;
};

/**
 * Describes the message dxos.mesh.muxer.OpenChannel.
 * Use `create(OpenChannelSchema)` to create a new message.
 */
export const OpenChannelSchema: GenMessage<OpenChannel> = /*@__PURE__*/
  messageDesc(file_dxos_mesh_muxer, 1);

/**
 * @generated from message dxos.mesh.muxer.Data
 */
export type Data = Message<"dxos.mesh.muxer.Data"> & {
  /**
   * *
   * Identifier for the channel as assigned by the remote peer.
   * NOTE: An OpenChannel message must received before any data is sent on a channel.
   * Any data messages sent before that, should be ignored.
   *
   * @generated from field: int32 channel_id = 1;
   */
  channelId: number;

  /**
   * @generated from field: bytes data = 2;
   */
  data: Uint8Array;
};

/**
 * Describes the message dxos.mesh.muxer.Data.
 * Use `create(DataSchema)` to create a new message.
 */
export const DataSchema: GenMessage<Data> = /*@__PURE__*/
  messageDesc(file_dxos_mesh_muxer, 2);

/**
 * / Terminate the connection. The other peer can expect the connection to be closed.
 *
 * @generated from message dxos.mesh.muxer.Destroy
 */
export type Destroy = Message<"dxos.mesh.muxer.Destroy"> & {
  /**
   * / Error that caused the termination.
   *
   * @generated from field: optional string error = 1;
   */
  error?: string;
};

/**
 * Describes the message dxos.mesh.muxer.Destroy.
 * Use `create(DestroySchema)` to create a new message.
 */
export const DestroySchema: GenMessage<Destroy> = /*@__PURE__*/
  messageDesc(file_dxos_mesh_muxer, 3);

/**
 * @generated from message dxos.mesh.muxer.Close
 */
export type Close = Message<"dxos.mesh.muxer.Close"> & {
  /**
   * / Error that caused the termination.
   *
   * @generated from field: optional string error = 1;
   */
  error?: string;
};

/**
 * Describes the message dxos.mesh.muxer.Close.
 * Use `create(CloseSchema)` to create a new message.
 */
export const CloseSchema: GenMessage<Close> = /*@__PURE__*/
  messageDesc(file_dxos_mesh_muxer, 4);

