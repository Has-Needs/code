//
// Copyright 2022 DXOS.org
//

// @generated by protoc-gen-es v2.1.0 with parameter "target=ts,import_extension=js"
// @generated from file dxos/halo/credentials.proto (package dxos.halo.credentials, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import type { Any, Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_any, file_google_protobuf_struct, file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { TimeframeVector } from "../echo/timeframe_pb.js";
import { file_dxos_echo_timeframe } from "../echo/timeframe_pb.js";
import type { PublicKey } from "../keys_pb.js";
import { file_dxos_keys } from "../keys_pb.js";
import type { JsonObject, Message } from "@bufbuild/protobuf";

/**
 * Describes the file dxos/halo/credentials.proto.
 */
export const file_dxos_halo_credentials: GenFile = /*@__PURE__*/
  fileDesc("ChtkeG9zL2hhbG8vY3JlZGVudGlhbHMucHJvdG8SFWR4b3MuaGFsby5jcmVkZW50aWFscyI3CgxTcGFjZUdlbmVzaXMSJwoJc3BhY2Vfa2V5GAEgASgLMhQuZHhvcy5rZXlzLlB1YmxpY0tleSKRAwoLU3BhY2VNZW1iZXISJwoJc3BhY2Vfa2V5GAEgASgLMhQuZHhvcy5rZXlzLlB1YmxpY0tleRI1CgRyb2xlGAIgASgOMicuZHhvcy5oYWxvLmNyZWRlbnRpYWxzLlNwYWNlTWVtYmVyLlJvbGUSPAoHcHJvZmlsZRgDIAEoCzImLmR4b3MuaGFsby5jcmVkZW50aWFscy5Qcm9maWxlRG9jdW1lbnRIAIgBARIuChBnZW5lc2lzX2ZlZWRfa2V5GAQgASgLMhQuZHhvcy5rZXlzLlB1YmxpY0tleRI7ChhpbnZpdGF0aW9uX2NyZWRlbnRpYWxfaWQYBSABKAsyFC5keG9zLmtleXMuUHVibGljS2V5SAGIAQEiTgoEUm9sZRILCgdJTlZBTElEEAASCQoFQURNSU4QARIKCgZFRElUT1IQAhIKCgZSRUFERVIQAxIJCgVPV05FUhAEEgsKB1JFTU9WRUQQBUIKCghfcHJvZmlsZUIbChlfaW52aXRhdGlvbl9jcmVkZW50aWFsX2lkIlkKDU1lbWJlclByb2ZpbGUSPAoHcHJvZmlsZRgDIAEoCzImLmR4b3MuaGFsby5jcmVkZW50aWFscy5Qcm9maWxlRG9jdW1lbnRIAIgBAUIKCghfcHJvZmlsZSJoChBBdXRob3JpemVkRGV2aWNlEioKDGlkZW50aXR5X2tleRgBIAEoCzIULmR4b3Mua2V5cy5QdWJsaWNLZXkSKAoKZGV2aWNlX2tleRgCIAEoCzIULmR4b3Mua2V5cy5QdWJsaWNLZXkihgIKDEFkbWl0dGVkRmVlZBInCglzcGFjZV9rZXkYASABKAsyFC5keG9zLmtleXMuUHVibGljS2V5EioKDGlkZW50aXR5X2tleRgCIAEoCzIULmR4b3Mua2V5cy5QdWJsaWNLZXkSKAoKZGV2aWNlX2tleRgDIAEoCzIULmR4b3Mua2V5cy5QdWJsaWNLZXkSRAoLZGVzaWduYXRpb24YBCABKA4yLy5keG9zLmhhbG8uY3JlZGVudGlhbHMuQWRtaXR0ZWRGZWVkLkRlc2lnbmF0aW9uIjEKC0Rlc2lnbmF0aW9uEgsKB0dFTkVSQUwQABILCgdDT05UUk9MEAESCAoEREFUQRACIuwBCgVFcG9jaBIOCgZudW1iZXIYASABKA0SLgoLcHJldmlvdXNfaWQYAiABKAsyFC5keG9zLmtleXMuUHVibGljS2V5SACIAQESNwoJdGltZWZyYW1lGAogASgLMiQuZHhvcy5lY2hvLnRpbWVmcmFtZS5UaW1lZnJhbWVWZWN0b3ISGQoMc25hcHNob3RfY2lkGAsgASgJSAGIAQESGwoOYXV0b21lcmdlX3Jvb3QYDCABKAlIAogBAUIOCgxfcHJldmlvdXNfaWRCDwoNX3NuYXBzaG90X2NpZEIRCg9fYXV0b21lcmdlX3Jvb3QiXwoJSGFsb1NwYWNlEioKDGlkZW50aXR5X2tleRgBIAEoCzIULmR4b3Mua2V5cy5QdWJsaWNLZXkSJgoIaGFsb19rZXkYAiABKAsyFC5keG9zLmtleXMuUHVibGljS2V5Is4BChBJZGVudGl0eVJlY292ZXJ5EioKDGlkZW50aXR5X2tleRgBIAEoCzIULmR4b3Mua2V5cy5QdWJsaWNLZXkSKgoMcmVjb3Zlcnlfa2V5GAIgASgLMhQuZHhvcy5rZXlzLlB1YmxpY0tleRIWCglhbGdvcml0aG0YAyABKAlIAIgBARItCgpsb29rdXBfa2V5GAQgASgLMhQuZHhvcy5rZXlzLlB1YmxpY0tleUgBiAEBQgwKCl9hbGdvcml0aG1CDQoLX2xvb2t1cF9rZXkimgEKD1Byb2ZpbGVEb2N1bWVudBIZCgxkaXNwbGF5X25hbWUYASABKAlIAIgBARIXCgphdmF0YXJfY2lkGAIgASgJSAGIAQESKgoEZGF0YRgKIAEoCzIXLmdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3RIAogBAUIPCg1fZGlzcGxheV9uYW1lQg0KC19hdmF0YXJfY2lkQgcKBV9kYXRhIkoKD0lkZW50aXR5UHJvZmlsZRI3Cgdwcm9maWxlGAEgASgLMiYuZHhvcy5oYWxvLmNyZWRlbnRpYWxzLlByb2ZpbGVEb2N1bWVudCK4AgoVRGV2aWNlUHJvZmlsZURvY3VtZW50EhIKBWxhYmVsGAEgASgJSACIAQESFQoIcGxhdGZvcm0YAiABKAlIAYgBARIdChBwbGF0Zm9ybV92ZXJzaW9uGAMgASgJSAKIAQESGQoMYXJjaGl0ZWN0dXJlGAQgASgJSAOIAQESDwoCb3MYBSABKAlIBIgBARIXCgpvc192ZXJzaW9uGAYgASgJSAWIAQESNAoEdHlwZRgHIAEoDjIhLmR4b3MuaGFsby5jcmVkZW50aWFscy5EZXZpY2VUeXBlSAaIAQFCCAoGX2xhYmVsQgsKCV9wbGF0Zm9ybUITChFfcGxhdGZvcm1fdmVyc2lvbkIPCg1fYXJjaGl0ZWN0dXJlQgUKA19vc0INCgtfb3NfdmVyc2lvbkIHCgVfdHlwZSJOCg1EZXZpY2VQcm9maWxlEj0KB3Byb2ZpbGUYASABKAsyLC5keG9zLmhhbG8uY3JlZGVudGlhbHMuRGV2aWNlUHJvZmlsZURvY3VtZW50IiAKDERlZmF1bHRTcGFjZRIQCghzcGFjZV9pZBgBIAEoCSJ2CgpLdWJlQWNjZXNzEiYKCGt1YmVfa2V5GAEgASgLMhQuZHhvcy5rZXlzLlB1YmxpY0tleRIqCgxpZGVudGl0eV9rZXkYAiABKAsyFC5keG9zLmtleXMuUHVibGljS2V5EhQKDGNhcGFiaWxpdGllcxgDIAMoCSLbAQoNU2VydmljZUFjY2VzcxITCgtzZXJ2ZXJfbmFtZRgBIAEoCRI1Cg9zZXJ2ZXJfbWV0YWRhdGEYAiABKAsyFy5nb29nbGUucHJvdG9idWYuU3RydWN0SACIAQESKAoKc2VydmVyX2tleRgDIAEoCzIULmR4b3Mua2V5cy5QdWJsaWNLZXkSKgoMaWRlbnRpdHlfa2V5GAQgASgLMhQuZHhvcy5rZXlzLlB1YmxpY0tleRIUCgxjYXBhYmlsaXRpZXMYBSADKAlCEgoQX3NlcnZlcl9tZXRhZGF0YSIlCgdLZXlJbmZvEhEKBG5hbWUYASABKAlIAIgBAUIHCgVfbmFtZSIGCgRBdXRoIlIKBUNsYWltEiAKAmlkGAEgASgLMhQuZHhvcy5rZXlzLlB1YmxpY0tleRInCglhc3NlcnRpb24YAiABKAsyFC5nb29nbGUucHJvdG9idWYuQW55ItcBCgVQcm9vZhIMCgR0eXBlGAEgASgJEjEKDWNyZWF0aW9uX2RhdGUYAiABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEiQKBnNpZ25lchgDIAEoCzIULmR4b3Mua2V5cy5QdWJsaWNLZXkSEgoFbm9uY2UYBCABKAxIAIgBARINCgV2YWx1ZRgFIAEoDBIwCgVjaGFpbhgGIAEoCzIcLmR4b3MuaGFsby5jcmVkZW50aWFscy5DaGFpbkgBiAEBQggKBl9ub25jZUIICgZfY2hhaW4iPgoFQ2hhaW4SNQoKY3JlZGVudGlhbBgBIAEoCzIhLmR4b3MuaGFsby5jcmVkZW50aWFscy5DcmVkZW50aWFsIrEDCgpDcmVkZW50aWFsEiUKAmlkGAEgASgLMhQuZHhvcy5rZXlzLlB1YmxpY0tleUgAiAEBEiQKBmlzc3VlchgCIAEoCzIULmR4b3Mua2V5cy5QdWJsaWNLZXkSMQoNaXNzdWFuY2VfZGF0ZRgDIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASOAoPZXhwaXJhdGlvbl9kYXRlGAQgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEgBiAEBEhsKDmV4cGlyYXRpb25fcmVmGAUgASgMSAKIAQESLQoHc3ViamVjdBgKIAEoCzIcLmR4b3MuaGFsby5jcmVkZW50aWFscy5DbGFpbRIwCgVwcm9vZhgLIAEoCzIcLmR4b3MuaGFsby5jcmVkZW50aWFscy5Qcm9vZkgDiAEBEjMKFXBhcmVudF9jcmVkZW50aWFsX2lkcxgMIAMoCzIULmR4b3Mua2V5cy5QdWJsaWNLZXlCBQoDX2lkQhIKEF9leHBpcmF0aW9uX2RhdGVCEQoPX2V4cGlyYXRpb25fcmVmQggKBl9wcm9vZiJ0CgxQcmVzZW50YXRpb24SNgoLY3JlZGVudGlhbHMYASADKAsyIS5keG9zLmhhbG8uY3JlZGVudGlhbHMuQ3JlZGVudGlhbBIsCgZwcm9vZnMYAiADKAsyHC5keG9zLmhhbG8uY3JlZGVudGlhbHMuUHJvb2YqXAoKRGV2aWNlVHlwZRILCgdVTktOT1dOEAASCwoHQlJPV1NFUhABEgoKBk5BVElWRRACEgkKBUFHRU5UEAMSEQoNQUdFTlRfTUFOQUdFRBAEEgoKBk1PQklMRRAFQjZaNGdpdGh1Yi5jb20vZHhvcy9keG9zL3Byb3RvL2RlZi9keG9zL2hhbG8vY3JlZGVudGlhbHNiBnByb3RvMw", [file_google_protobuf_any, file_google_protobuf_struct, file_google_protobuf_timestamp, file_dxos_echo_timeframe, file_dxos_keys]);

/**
 * [ASSERTION]
 *
 * @generated from message dxos.halo.credentials.SpaceGenesis
 */
export type SpaceGenesis = Message<"dxos.halo.credentials.SpaceGenesis"> & {
  /**
   * Feeds belong to Spaces.
   *
   * @generated from field: dxos.keys.PublicKey space_key = 1;
   */
  spaceKey?: PublicKey;
};

/**
 * Describes the message dxos.halo.credentials.SpaceGenesis.
 * Use `create(SpaceGenesisSchema)` to create a new message.
 */
export const SpaceGenesisSchema: GenMessage<SpaceGenesis> = /*@__PURE__*/
  messageDesc(file_dxos_halo_credentials, 0);

/**
 * TODO(burdon): Reconcile with dxos.client.SpaceMember.
 * [ASSERTION]: Agent is authorized to access Space.
 *
 * @generated from message dxos.halo.credentials.SpaceMember
 */
export type SpaceMember = Message<"dxos.halo.credentials.SpaceMember"> & {
  /**
   * @generated from field: dxos.keys.PublicKey space_key = 1;
   */
  spaceKey?: PublicKey;

  /**
   * @generated from field: dxos.halo.credentials.SpaceMember.Role role = 2;
   */
  role: SpaceMember_Role;

  /**
   * TODO(burdon): Identity key?
   *
   * @generated from field: optional dxos.halo.credentials.ProfileDocument profile = 3;
   */
  profile?: ProfileDocument;

  /**
   * / Genesis feed of the space.
   * / Needed so that the admitted member can start replicating the space based on this credential alone.
   *
   * @generated from field: dxos.keys.PublicKey genesis_feed_key = 4;
   */
  genesisFeedKey?: PublicKey;

  /**
   * / Present to associate SpaceMember admissions with delegated invitations.
   *
   * @generated from field: optional dxos.keys.PublicKey invitation_credential_id = 5;
   */
  invitationCredentialId?: PublicKey;
};

/**
 * Describes the message dxos.halo.credentials.SpaceMember.
 * Use `create(SpaceMemberSchema)` to create a new message.
 */
export const SpaceMemberSchema: GenMessage<SpaceMember> = /*@__PURE__*/
  messageDesc(file_dxos_halo_credentials, 1);

/**
 * TODO(burdon): Consider union of capabilities; e.g., APPEND_ONLY, READ_ONLY, EPOCH_GENERATOR?
 *
 * @generated from enum dxos.halo.credentials.SpaceMember.Role
 */
export enum SpaceMember_Role {
  /**
   * @generated from enum value: INVALID = 0;
   */
  INVALID = 0,

  /**
   * / Manage members.
   *
   * @generated from enum value: ADMIN = 1;
   */
  ADMIN = 1,

  /**
   * / Read and write.
   *
   * @generated from enum value: EDITOR = 2;
   */
  EDITOR = 2,

  /**
   * / Read-only.
   *
   * @generated from enum value: READER = 3;
   */
  READER = 3,

  /**
   * / Admin that can't be removed.
   *
   * @generated from enum value: OWNER = 4;
   */
  OWNER = 4,

  /**
   * / Revoked membership.
   *
   * @generated from enum value: REMOVED = 5;
   */
  REMOVED = 5,
}

/**
 * Describes the enum dxos.halo.credentials.SpaceMember.Role.
 */
export const SpaceMember_RoleSchema: GenEnum<SpaceMember_Role> = /*@__PURE__*/
  enumDesc(file_dxos_halo_credentials, 1, 0);

/**
 * @generated from message dxos.halo.credentials.MemberProfile
 */
export type MemberProfile = Message<"dxos.halo.credentials.MemberProfile"> & {
  /**
   * @generated from field: optional dxos.halo.credentials.ProfileDocument profile = 3;
   */
  profile?: ProfileDocument;
};

/**
 * Describes the message dxos.halo.credentials.MemberProfile.
 * Use `create(MemberProfileSchema)` to create a new message.
 */
export const MemberProfileSchema: GenMessage<MemberProfile> = /*@__PURE__*/
  messageDesc(file_dxos_halo_credentials, 2);

/**
 * [ASSERTION]: Device is authorized to sign messages for a given Agent (Identity).
 * NOTE: Devices are Admitted to Identities.
 *
 * @generated from message dxos.halo.credentials.AuthorizedDevice
 */
export type AuthorizedDevice = Message<"dxos.halo.credentials.AuthorizedDevice"> & {
  /**
   * @generated from field: dxos.keys.PublicKey identity_key = 1;
   */
  identityKey?: PublicKey;

  /**
   * Existing authorized device.
   *
   * @generated from field: dxos.keys.PublicKey device_key = 2;
   */
  deviceKey?: PublicKey;
};

/**
 * Describes the message dxos.halo.credentials.AuthorizedDevice.
 * Use `create(AuthorizedDeviceSchema)` to create a new message.
 */
export const AuthorizedDeviceSchema: GenMessage<AuthorizedDevice> = /*@__PURE__*/
  messageDesc(file_dxos_halo_credentials, 3);

/**
 * [ASSERTION]: Feed is admitted to the Space for replication.
 * NOTE: Feeds are Admitted to Spaces.
 *
 * @generated from message dxos.halo.credentials.AdmittedFeed
 */
export type AdmittedFeed = Message<"dxos.halo.credentials.AdmittedFeed"> & {
  /**
   * @generated from field: dxos.keys.PublicKey space_key = 1;
   */
  spaceKey?: PublicKey;

  /**
   * / Owning identity.
   *
   * Could be derived.
   *
   * @generated from field: dxos.keys.PublicKey identity_key = 2;
   */
  identityKey?: PublicKey;

  /**
   * / Owning device.
   *
   * @generated from field: dxos.keys.PublicKey device_key = 3;
   */
  deviceKey?: PublicKey;

  /**
   * / Controls sets the feed designation.
   * / Feeds with different designations are consumed by separate pipelines.
   *
   * @generated from field: dxos.halo.credentials.AdmittedFeed.Designation designation = 4;
   */
  designation: AdmittedFeed_Designation;
};

/**
 * Describes the message dxos.halo.credentials.AdmittedFeed.
 * Use `create(AdmittedFeedSchema)` to create a new message.
 */
export const AdmittedFeedSchema: GenMessage<AdmittedFeed> = /*@__PURE__*/
  messageDesc(file_dxos_halo_credentials, 4);

/**
 * @generated from enum dxos.halo.credentials.AdmittedFeed.Designation
 */
export enum AdmittedFeed_Designation {
  /**
   * / Classic general purpose feeds for both HALO and ECHO messages together. To be deprecated.
   *
   * @generated from enum value: GENERAL = 0;
   */
  GENERAL = 0,

  /**
   * / Contain system-level messages messages, such as credentials and epochs.
   *
   * @generated from enum value: CONTROL = 1;
   */
  CONTROL = 1,

  /**
   * / Database mutations.
   *
   * @generated from enum value: DATA = 2;
   */
  DATA = 2,
}

/**
 * Describes the enum dxos.halo.credentials.AdmittedFeed.Designation.
 */
export const AdmittedFeed_DesignationSchema: GenEnum<AdmittedFeed_Designation> = /*@__PURE__*/
  enumDesc(file_dxos_halo_credentials, 4, 0);

/**
 * [ASSERTION]: New epoch is started in the space.
 * Subject is the space.
 *
 * @generated from message dxos.halo.credentials.Epoch
 */
export type Epoch = Message<"dxos.halo.credentials.Epoch"> & {
  /**
   * / Epoch number.
   *
   * @generated from field: uint32 number = 1;
   */
  number: number;

  /**
   * / Id of the previous epoch. Identified by the credential id.
   *
   * @generated from field: optional dxos.keys.PublicKey previous_id = 2;
   */
  previousId?: PublicKey;

  /**
   * TODO(dmaretskyi): Deprecate.
   * / Epoch start timeframe. Indexes correspond to last mutations included into the snapshot.
   *
   * @generated from field: dxos.echo.timeframe.TimeframeVector timeframe = 10;
   */
  timeframe?: TimeframeVector;

  /**
   * / Epoch start snapshot.
   *
   * @generated from field: optional string snapshot_cid = 11;
   */
  snapshotCid?: string;

  /**
   * / URL of the automerge document representing the space root.
   *
   * @generated from field: optional string automerge_root = 12;
   */
  automergeRoot?: string;
};

/**
 * Describes the message dxos.halo.credentials.Epoch.
 * Use `create(EpochSchema)` to create a new message.
 */
export const EpochSchema: GenMessage<Epoch> = /*@__PURE__*/
  messageDesc(file_dxos_halo_credentials, 5);

/**
 * / [ASSERTION]: Associates a space that will implement Agent's HALO with an Identity.
 *
 * @generated from message dxos.halo.credentials.HaloSpace
 */
export type HaloSpace = Message<"dxos.halo.credentials.HaloSpace"> & {
  /**
   * @generated from field: dxos.keys.PublicKey identity_key = 1;
   */
  identityKey?: PublicKey;

  /**
   * / Space key.
   *
   * @generated from field: dxos.keys.PublicKey halo_key = 2;
   */
  haloKey?: PublicKey;
};

/**
 * Describes the message dxos.halo.credentials.HaloSpace.
 * Use `create(HaloSpaceSchema)` to create a new message.
 */
export const HaloSpaceSchema: GenMessage<HaloSpace> = /*@__PURE__*/
  messageDesc(file_dxos_halo_credentials, 6);

/**
 * / [ASSERTION]: Grants recovery permissions to a recovery key.
 *
 * @generated from message dxos.halo.credentials.IdentityRecovery
 */
export type IdentityRecovery = Message<"dxos.halo.credentials.IdentityRecovery"> & {
  /**
   * @generated from field: dxos.keys.PublicKey identity_key = 1;
   */
  identityKey?: PublicKey;

  /**
   * / Public key derived from the recovery seedphrase.
   *
   * @generated from field: dxos.keys.PublicKey recovery_key = 2;
   */
  recoveryKey?: PublicKey;

  /**
   * / Algorithm used to derive the recovery key (e.g., ED25519, ES256, etc.).
   *
   * @generated from field: optional string algorithm = 3;
   */
  algorithm?: string;

  /**
   * / Public key used to identify the recovery key (e.g., passkey user handle).
   *
   * @generated from field: optional dxos.keys.PublicKey lookup_key = 4;
   */
  lookupKey?: PublicKey;
};

/**
 * Describes the message dxos.halo.credentials.IdentityRecovery.
 * Use `create(IdentityRecoverySchema)` to create a new message.
 */
export const IdentityRecoverySchema: GenMessage<IdentityRecovery> = /*@__PURE__*/
  messageDesc(file_dxos_halo_credentials, 7);

/**
 * @generated from message dxos.halo.credentials.ProfileDocument
 */
export type ProfileDocument = Message<"dxos.halo.credentials.ProfileDocument"> & {
  /**
   * @generated from field: optional string display_name = 1;
   */
  displayName?: string;

  /**
   * @generated from field: optional string avatar_cid = 2;
   */
  avatarCid?: string;

  /**
   * / Custom user data.
   *
   * @generated from field: optional google.protobuf.Struct data = 10;
   */
  data?: JsonObject;
};

/**
 * Describes the message dxos.halo.credentials.ProfileDocument.
 * Use `create(ProfileDocumentSchema)` to create a new message.
 */
export const ProfileDocumentSchema: GenMessage<ProfileDocument> = /*@__PURE__*/
  messageDesc(file_dxos_halo_credentials, 8);

/**
 * / [ASSERTION]: Sets profile information.
 *
 * @generated from message dxos.halo.credentials.IdentityProfile
 */
export type IdentityProfile = Message<"dxos.halo.credentials.IdentityProfile"> & {
  /**
   * TODO(dmaretskyi): This could also be a DXNS link or stored in user's public HALO (we could also index the public HALO in the DMG).
   *
   * @generated from field: dxos.halo.credentials.ProfileDocument profile = 1;
   */
  profile?: ProfileDocument;
};

/**
 * Describes the message dxos.halo.credentials.IdentityProfile.
 * Use `create(IdentityProfileSchema)` to create a new message.
 */
export const IdentityProfileSchema: GenMessage<IdentityProfile> = /*@__PURE__*/
  messageDesc(file_dxos_halo_credentials, 9);

/**
 * @generated from message dxos.halo.credentials.DeviceProfileDocument
 */
export type DeviceProfileDocument = Message<"dxos.halo.credentials.DeviceProfileDocument"> & {
  /**
   * TODO(mykola): Use for user defined label.
   *
   * @generated from field: optional string label = 1;
   */
  label?: string;

  /**
   * @generated from field: optional string platform = 2;
   */
  platform?: string;

  /**
   * @generated from field: optional string platform_version = 3;
   */
  platformVersion?: string;

  /**
   * @generated from field: optional string architecture = 4;
   */
  architecture?: string;

  /**
   * @generated from field: optional string os = 5;
   */
  os?: string;

  /**
   * @generated from field: optional string os_version = 6;
   */
  osVersion?: string;

  /**
   * @generated from field: optional dxos.halo.credentials.DeviceType type = 7;
   */
  type?: DeviceType;
};

/**
 * Describes the message dxos.halo.credentials.DeviceProfileDocument.
 * Use `create(DeviceProfileDocumentSchema)` to create a new message.
 */
export const DeviceProfileDocumentSchema: GenMessage<DeviceProfileDocument> = /*@__PURE__*/
  messageDesc(file_dxos_halo_credentials, 10);

/**
 * / [ASSERTION]: Sets device profile information.
 *
 * @generated from message dxos.halo.credentials.DeviceProfile
 */
export type DeviceProfile = Message<"dxos.halo.credentials.DeviceProfile"> & {
  /**
   * @generated from field: dxos.halo.credentials.DeviceProfileDocument profile = 1;
   */
  profile?: DeviceProfileDocument;
};

/**
 * Describes the message dxos.halo.credentials.DeviceProfile.
 * Use `create(DeviceProfileSchema)` to create a new message.
 */
export const DeviceProfileSchema: GenMessage<DeviceProfile> = /*@__PURE__*/
  messageDesc(file_dxos_halo_credentials, 11);

/**
 * / [ASSERTION]: Sets default space for identity.
 *
 * @generated from message dxos.halo.credentials.DefaultSpace
 */
export type DefaultSpace = Message<"dxos.halo.credentials.DefaultSpace"> & {
  /**
   * @generated from field: string space_id = 1;
   */
  spaceId: string;
};

/**
 * Describes the message dxos.halo.credentials.DefaultSpace.
 * Use `create(DefaultSpaceSchema)` to create a new message.
 */
export const DefaultSpaceSchema: GenMessage<DefaultSpace> = /*@__PURE__*/
  messageDesc(file_dxos_halo_credentials, 12);

/**
 * [ASSERTION]: Identity is authorized to access a KUBE.
 *
 * @generated from message dxos.halo.credentials.KubeAccess
 */
export type KubeAccess = Message<"dxos.halo.credentials.KubeAccess"> & {
  /**
   * @generated from field: dxos.keys.PublicKey kube_key = 1;
   */
  kubeKey?: PublicKey;

  /**
   * @generated from field: dxos.keys.PublicKey identity_key = 2;
   */
  identityKey?: PublicKey;

  /**
   * @generated from field: repeated string capabilities = 3;
   */
  capabilities: string[];
};

/**
 * Describes the message dxos.halo.credentials.KubeAccess.
 * Use `create(KubeAccessSchema)` to create a new message.
 */
export const KubeAccessSchema: GenMessage<KubeAccess> = /*@__PURE__*/
  messageDesc(file_dxos_halo_credentials, 13);

/**
 * [ASSERTION]: Identity is authorized to access an external server.
 *
 * @generated from message dxos.halo.credentials.ServiceAccess
 */
export type ServiceAccess = Message<"dxos.halo.credentials.ServiceAccess"> & {
  /**
   * @generated from field: string server_name = 1;
   */
  serverName: string;

  /**
   * @generated from field: optional google.protobuf.Struct server_metadata = 2;
   */
  serverMetadata?: JsonObject;

  /**
   * @generated from field: dxos.keys.PublicKey server_key = 3;
   */
  serverKey?: PublicKey;

  /**
   * @generated from field: dxos.keys.PublicKey identity_key = 4;
   */
  identityKey?: PublicKey;

  /**
   * @generated from field: repeated string capabilities = 5;
   */
  capabilities: string[];
};

/**
 * Describes the message dxos.halo.credentials.ServiceAccess.
 * Use `create(ServiceAccessSchema)` to create a new message.
 */
export const ServiceAccessSchema: GenMessage<ServiceAccess> = /*@__PURE__*/
  messageDesc(file_dxos_halo_credentials, 14);

/**
 * / Metadata associated with a key.
 * / Subject must be a key being referenced.
 *
 * @generated from message dxos.halo.credentials.KeyInfo
 */
export type KeyInfo = Message<"dxos.halo.credentials.KeyInfo"> & {
  /**
   * @generated from field: optional string name = 1;
   */
  name?: string;
};

/**
 * Describes the message dxos.halo.credentials.KeyInfo.
 * Use `create(KeyInfoSchema)` to create a new message.
 */
export const KeyInfoSchema: GenMessage<KeyInfo> = /*@__PURE__*/
  messageDesc(file_dxos_halo_credentials, 15);

/**
 * / Assertion for agents authenticating in the space swarm.
 *
 * @generated from message dxos.halo.credentials.Auth
 */
export type Auth = Message<"dxos.halo.credentials.Auth"> & {
};

/**
 * Describes the message dxos.halo.credentials.Auth.
 * Use `create(AuthSchema)` to create a new message.
 */
export const AuthSchema: GenMessage<Auth> = /*@__PURE__*/
  messageDesc(file_dxos_halo_credentials, 16);

/**
 * @generated from message dxos.halo.credentials.Claim
 */
export type Claim = Message<"dxos.halo.credentials.Claim"> & {
  /**
   * Subject of claim (e.g., Agent, Device, Feed).
   *
   * @generated from field: dxos.keys.PublicKey id = 1;
   */
  id?: PublicKey;

  /**
   * @generated from field: google.protobuf.Any assertion = 2;
   */
  assertion?: Any;
};

/**
 * Describes the message dxos.halo.credentials.Claim.
 * Use `create(ClaimSchema)` to create a new message.
 */
export const ClaimSchema: GenMessage<Claim> = /*@__PURE__*/
  messageDesc(file_dxos_halo_credentials, 17);

/**
 * @generated from message dxos.halo.credentials.Proof
 */
export type Proof = Message<"dxos.halo.credentials.Proof"> & {
  /**
   * Type of proof (e.g., "Ed25519Signature2020").
   *
   * @generated from field: string type = 1;
   */
  type: string;

  /**
   * @generated from field: google.protobuf.Timestamp creation_date = 2;
   */
  creationDate?: Timestamp;

  /**
   * Entity that created the proof (e.g., Agent, Device, Space).
   *
   * @generated from field: dxos.keys.PublicKey signer = 3;
   */
  signer?: PublicKey;

  /**
   * Used in Presentations to protect against replay attacks.
   *
   * @generated from field: optional bytes nonce = 4;
   */
  nonce?: Uint8Array;

  /**
   * / Signature (excluded from signed data).
   *
   * @generated from field: bytes value = 5;
   */
  value: Uint8Array;

  /**
   * *
   * Must be present if signer is not credential issuer.
   * Establishes the authority of the signer. Proves that the signer can issue such credentials.
   * Excluded from signed data.
   *
   * @generated from field: optional dxos.halo.credentials.Chain chain = 6;
   */
  chain?: Chain;
};

/**
 * Describes the message dxos.halo.credentials.Proof.
 * Use `create(ProofSchema)` to create a new message.
 */
export const ProofSchema: GenMessage<Proof> = /*@__PURE__*/
  messageDesc(file_dxos_halo_credentials, 18);

/**
 * *
 * A chain of credentials that establishes the delegated authority to issue new credentials.
 * Each key in the chain has an assotiated credential that establishes the authrity of that specific key.
 *
 * Example:
 *   Alice/Device-2 => Alice/Device-1 => Alice
 *
 * This chain would include 2 credentials:
 *   1. Giving Alice/Device-2 the authority to issue credentials on behalf of Alice, signed by Alice/Device-1.
 *   2. Giving Alice/Device-1 the authority to issue credentials on behalf of Alice, signed by Alice.
 *
 * @generated from message dxos.halo.credentials.Chain
 */
export type Chain = Message<"dxos.halo.credentials.Chain"> & {
  /**
   * / Credential that authorizes the subject to issue new credentials (can be recursive).
   *
   * @generated from field: dxos.halo.credentials.Credential credential = 1;
   */
  credential?: Credential;
};

/**
 * Describes the message dxos.halo.credentials.Chain.
 * Use `create(ChainSchema)` to create a new message.
 */
export const ChainSchema: GenMessage<Chain> = /*@__PURE__*/
  messageDesc(file_dxos_halo_credentials, 19);

/**
 * @generated from message dxos.halo.credentials.Credential
 */
export type Credential = Message<"dxos.halo.credentials.Credential"> & {
  /**
   * Credential identifier (e.g., for storage indexing).
   *
   * @generated from field: optional dxos.keys.PublicKey id = 1;
   */
  id?: PublicKey;

  /**
   * key = { Space (genesis) | Identity (genesis) | (authorized) Device }
   *
   * @generated from field: dxos.keys.PublicKey issuer = 2;
   */
  issuer?: PublicKey;

  /**
   * @generated from field: google.protobuf.Timestamp issuance_date = 3;
   */
  issuanceDate?: Timestamp;

  /**
   * @generated from field: optional google.protobuf.Timestamp expiration_date = 4;
   */
  expirationDate?: Timestamp;

  /**
   * Could reference blockchain or epoch number.
   *
   * @generated from field: optional bytes expiration_ref = 5;
   */
  expirationRef?: Uint8Array;

  /**
   * @generated from field: dxos.halo.credentials.Claim subject = 10;
   */
  subject?: Claim;

  /**
   * @generated from field: optional dxos.halo.credentials.Proof proof = 11;
   */
  proof?: Proof;

  /**
   * Can be used for resolution of concurrent mutually exclusive actions
   *
   * @generated from field: repeated dxos.keys.PublicKey parent_credential_ids = 12;
   */
  parentCredentialIds: PublicKey[];
};

/**
 * Describes the message dxos.halo.credentials.Credential.
 * Use `create(CredentialSchema)` to create a new message.
 */
export const CredentialSchema: GenMessage<Credential> = /*@__PURE__*/
  messageDesc(file_dxos_halo_credentials, 20);

/**
 * @generated from message dxos.halo.credentials.Presentation
 */
export type Presentation = Message<"dxos.halo.credentials.Presentation"> & {
  /**
   * @generated from field: repeated dxos.halo.credentials.Credential credentials = 1;
   */
  credentials: Credential[];

  /**
   * @generated from field: repeated dxos.halo.credentials.Proof proofs = 2;
   */
  proofs: Proof[];
};

/**
 * Describes the message dxos.halo.credentials.Presentation.
 * Use `create(PresentationSchema)` to create a new message.
 */
export const PresentationSchema: GenMessage<Presentation> = /*@__PURE__*/
  messageDesc(file_dxos_halo_credentials, 21);

/**
 * @generated from enum dxos.halo.credentials.DeviceType
 */
export enum DeviceType {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * @generated from enum value: BROWSER = 1;
   */
  BROWSER = 1,

  /**
   * @generated from enum value: NATIVE = 2;
   */
  NATIVE = 2,

  /**
   * @generated from enum value: AGENT = 3;
   */
  AGENT = 3,

  /**
   * @generated from enum value: AGENT_MANAGED = 4;
   */
  AGENT_MANAGED = 4,

  /**
   * @generated from enum value: MOBILE = 5;
   */
  MOBILE = 5,
}

/**
 * Describes the enum dxos.halo.credentials.DeviceType.
 */
export const DeviceTypeSchema: GenEnum<DeviceType> = /*@__PURE__*/
  enumDesc(file_dxos_halo_credentials, 0);

