{
  "version": 3,
  "sources": ["../../../src/assert.ts", "../../../src/error-handler.ts", "../../../src/error-stream.ts", "../../../src/fail.ts", "../../../src/inspect.ts", "../../../src/log-method.ts", "../../../src/raise.ts", "../../../src/snoop.ts", "../../../src/stack-trace.ts", "../../../src/strings.ts", "../../../src/throw.ts", "../../../src/timeout-warning.ts", "../../../src/todo.ts", "../../../src/devtools-formatter.ts", "../../../src/equality.ts", "../../../src/exposed-modules.ts", "../../../src/inspect-custom.ts"],
  "sourcesContent": ["//\n// Copyright 2020 DXOS.org\n//\n\n/**\n * A simple syntax sugar to write `value as T` as a statement.\n *\n * NOTE: This does not provide any type safety.\n * It's just for convenience so that autocomplete works for value.\n * It's recommended to check the type URL manually beforehand or use `assertAnyType` instead.\n * @param value\n */\nexport const checkType = <T>(value: T): T => value;\n", "//\n// Copyright 2020 DXOS.org\n//\n\nimport { EventEmitter } from 'node:events';\n\n/**\n * Listens for global errors.\n */\nexport class ErrorHandler extends EventEmitter {\n  _listener: EventListener;\n\n  constructor() {\n    super();\n\n    this._listener = (event: any) => {\n      const cause = event.error || event.reason || event;\n      const message = cause.stack || cause.message || cause.toString();\n      this.emit('error', message);\n\n      // Default logging.\n      // code event.preventDefault();\n    };\n\n    // https://developer.mozilla.org/en-US/docs/Web/API/Window/error_event\n    window.addEventListener('error', this._listener);\n\n    // https://developer.mozilla.org/en-US/docs/Web/API/Window/unhandledrejection_event\n    window.addEventListener('unhandledrejection', this._listener);\n  }\n\n  reset(): void {\n    window.removeEventListener('error', this._listener);\n    window.removeEventListener('unhandledrejection', this._listener);\n  }\n}\n", "//\n// Copyright 2021 DXOS.org\n//\n\nexport type ErrorHandlerCallback = (error: Error) => void;\n\n/**\n * Represents a stream of errors that entities can expose.\n */\nexport class ErrorStream {\n  private _handler: ErrorHandlerCallback | undefined;\n\n  private _unhandledErrors = 0;\n\n  assertNoUnhandledErrors(): void {\n    if (this._unhandledErrors > 0) {\n      throw new Error(\n        `Assertion failed: expected no unhandled errors to be thrown, but ${this._unhandledErrors} were thrown.`,\n      );\n    }\n  }\n\n  raise(error: Error): void {\n    if (this._handler) {\n      this._handler(error);\n    } else {\n      this._unhandledError(error);\n    }\n  }\n\n  handle(handler: ErrorHandlerCallback): void {\n    this._handler = handler;\n  }\n\n  pipeTo(receiver: ErrorStream): void {\n    this.handle((error) => receiver.raise(error));\n  }\n\n  private _unhandledError(error: Error): void {\n    this._unhandledErrors++;\n\n    setTimeout(() => {\n      throw error;\n    });\n  }\n}\n", "//\n// Copyright 2021 DXOS.org\n//\n\n/**\n * Should be used in expressions where values are cheked not to be null or undefined.\n *\n * Example:\n *\n * ```\n * const value: string | undefined;\n *\n * callMethod(value ?? failUndefined());\n * ```\n */\n// TODO(burdon): Rename failIfUndefined().\nexport const failUndefined = () => {\n  throw new Error('Required value was null or undefined.');\n};\n", "//\n// Copyright 2022 DXOS.org\n//\n\nimport { inspect } from 'node:util';\n\n/**\n * Utility to automatically log debug info.\n *\n * ```\n *   // Called via `console.log`.\n *   [inspect.custom] () {\n *     return inspectObject(this);\n *   }\n *\n *   // Called via `JSON.stringify`.\n *   toJSON () {\n *     return { ... };\n *   }\n * ```\n */\nexport const inspectObject = (obj: any) => {\n  const name = Object.getPrototypeOf(obj).constructor.name;\n  return obj.toJSON ? `${name}(${inspect(obj.toJSON())})` : String(obj);\n};\n", "//\n// Copyright 2021 DXOS.org\n//\n\nexport function logMethod(\n  target: any,\n  propertyName: string,\n  descriptor: TypedPropertyDescriptor<(...args: any) => any>,\n): void {\n  const method = descriptor.value!;\n  descriptor.value = function (this: any, ...args: any) {\n    console.log(`Called ${target.constructor.name}.${propertyName} ${args}`);\n    try {\n      const result = method.apply(this, args);\n      if (typeof result.catch === 'function') {\n        result.catch((err: any) => {\n          console.log(`Rejected ${target.constructor.name}.${propertyName}`, err);\n        });\n      }\n      return result;\n    } catch (err: any) {\n      console.log(`Thrown ${target.constructor.name}.${propertyName}`, err);\n      throw err;\n    }\n  };\n}\n", "//\n// Copyright 2020 DXOS.org\n//\n\n/**\n * Immediatelly throws an error passed as an argument.\n *\n * Usefull for throwing errors from inside expressions.\n * For example:\n * ```\n * const item = model.getById(someId) ?? raise(new Error('Not found'));\n * ```\n * @param error\n */\nexport const raise = (error: Error): never => {\n  throw error;\n};\n", "//\n// Copyright 2022 DXOS.org\n//\n\nexport enum SnoopLevel {\n  DEFAULT = 0,\n  VERBOSE = 1,\n  BOLD = 2,\n}\n\n/**\n * Utils for debug logging of functions.\n */\n// TODO(burdon): Integrate with log/spyglass.\nexport class Snoop {\n  static stackFunction(err: Error): string | undefined {\n    const stack = err.stack!.split('\\n');\n    const match = stack[2].match(/.+\\((.+)\\).*/);\n    if (match) {\n      const [file, line] = match[1].split(':');\n      return `[${file.substring(file.lastIndexOf('/') + 1)}:${line}]`;\n    }\n  }\n\n  constructor(private readonly _context?: string) {}\n\n  get verbose() {\n    return SnoopLevel.VERBOSE;\n  }\n\n  get bold() {\n    return SnoopLevel.BOLD;\n  }\n\n  format(prefix: string, name: string, args: string, level: SnoopLevel): string {\n    const pre = prefix.repeat(level === SnoopLevel.BOLD ? 8 : 2);\n    const label = this._context ? `${this._context}.${name}` : name;\n    const line = `${pre} ${label}${args}`;\n    return level === SnoopLevel.BOLD ? [pre, line, pre].join('\\n') : line;\n  }\n\n  in(label: string, level: SnoopLevel, ...args: any[]): string {\n    return this.format('<', label, level === SnoopLevel.DEFAULT ? '' : `(${String(...args)})`, level);\n  }\n\n  out(label: string, level: SnoopLevel, result: any): string {\n    return this.format('>', label, level === SnoopLevel.DEFAULT ? '' : ` = ${String(result)}`, level);\n  }\n\n  sync(f: any, label?: string, level: SnoopLevel = SnoopLevel.VERBOSE) {\n    label = label ?? Snoop.stackFunction(new Error());\n    return (...args: any[]) => {\n      console.log(this.in(label ?? '', level, ...args));\n      const r = f(...args);\n      console.log(this.out(label ?? '', level, r));\n      return r;\n    };\n  }\n\n  async(f: any, label?: string, level: SnoopLevel = SnoopLevel.VERBOSE) {\n    label = label ?? Snoop.stackFunction(new Error());\n    return async (...args: any[]) => {\n      console.log(this.in(label ?? '', level, ...args));\n      const r = await f(...args);\n      console.log(this.out(label ?? '', level, r));\n      return r;\n    };\n  }\n}\n\nexport const snoop = new Snoop();\n", "//\n// Copyright 2021 DXOS.org\n//\n\n/**\n * Will capture the stack trace at the point where the class is created.\n * Stack traces are formatted lazily only when `getStack` is called.\n * Formatting is significantly more expensive than capture so only call getStack when you need them.\n */\nexport class StackTrace {\n  private _stack: Error;\n\n  constructor() {\n    this._stack = new Error();\n  }\n\n  /**\n   * Get stack formatted as string.\n   * @param skipFrames Number of frames to skip. By default, the first frame would be the invocation of the StackTrace constructor.\n   * @returns\n   */\n  getStack(skipFrames = 0): string {\n    const stack = this._stack.stack!.split('\\n');\n    return stack.slice(skipFrames + 2).join('\\n');\n  }\n\n  getStackArray(skipFrames = 0): string[] {\n    const stack = this._stack.stack!.split('\\n');\n    return stack.slice(skipFrames + 2);\n  }\n}\n", "//\n// Copyright 2020 DXOS.org\n//\n\nexport const truncate = (str = '', length = 8, pad: boolean | string = false) => {\n  if (str.length >= length - 1) {\n    return str.substring(0, length - 1) + 'â€¦';\n  } else {\n    return pad ? str.padEnd(length, typeof pad === 'boolean' ? ' ' : pad[0]) : str;\n  }\n};\n\nexport const truncateKey = (key: any, length = 8) => {\n  const str = String(key);\n  if (str.length <= length) {\n    return str;\n  }\n\n  return str.slice(0, length);\n\n  // return start\n  //   ? `${str.slice(0, length)}...`\n  //   : `${str.substring(0, length / 2)}...${str.substring(str.length - length / 2)}`;\n};\n", "//\n// Copyright 2020 DXOS.org\n//\n\n/**\n * Wrapper for async tests.\n * @param {Function} test - Async test\n * @param errType\n * @return {Promise<void>}\n *\n * @deprecated Use vitests `expect(() => ...).toThrowError();` instead.\n */\nexport const expectToThrow = async (test: () => void, errType = Error) => {\n  let thrown;\n  try {\n    await test();\n  } catch (err) {\n    thrown = err;\n  }\n\n  if (thrown === undefined || !(thrown instanceof errType)) {\n    throw new Error(`Expected function to throw instance of ${errType.prototype.name}`);\n  }\n};\n", "//\n// Copyright 2020 DXOS.org\n//\n\nimport { StackTrace } from './stack-trace';\n\n/**\n * Prints a warning to console if the action takes longer then specified timeout. No errors are thrown.\n *\n * @param timeout Timeout in milliseconds after which warning is printed.\n * @param context Context description that would be included in the printed message.\n * @param body Action which is timed.\n */\nexport const warnAfterTimeout = async <T>(timeout: number, context: string, body: () => Promise<T>): Promise<T> => {\n  const stack = new StackTrace();\n  const timeoutId = setTimeout(() => {\n    console.warn(\n      `Action \\`${context}\\` is taking more then ${timeout.toLocaleString()}ms to complete. This might be a bug.\\n${stack.getStack()}`,\n    );\n  }, timeout);\n  try {\n    return await body();\n  } finally {\n    clearTimeout(timeoutId);\n  }\n};\n\n/**\n * A decorator that prints a warning to console if method execution time exceeds specified timeout.\n *\n * ```typescript\n * class Foo {\n *   @timed(5_000)\n *   async doStuff() {\n *     // long task\n *   }\n * }\n * ```\n *\n * This is useful for debugging code that might deadlock.\n *\n * @param timeout Timeout in milliseconds after which the warning is printed.\n */\nexport function timed(timeout: number) {\n  return (target: any, propertyName: string, descriptor: TypedPropertyDescriptor<(...args: any) => any>) => {\n    const method = descriptor.value!;\n    descriptor.value = function (this: any, ...args: any) {\n      return warnAfterTimeout(timeout, `${target.constructor.name}.${propertyName}`, () => method.apply(this, args));\n    };\n  };\n}\n", "//\n// Copyright 2020 DXOS.org\n//\n\n/**\n * Throws an error. Can be used in an expression instead of a value\n */\nexport const todo = (message?: string): never => {\n  throw new Error(message ?? 'Not implemented.');\n};\n", "//\n// Copyright 2023 DXOS.org\n//\n\n/**\n * Lets types provide custom formatters for the Chrome Devtools.\n *\n * https://www.mattzeunert.com/2016/02/19/custom-chrome-devtools-object-formatters.html\n * NOTE: Must be enabled in chrome devtools preferences.\n *\n * @example\n * ```typescript\n * class MyType {\n *  get [devtoolsFormatter] (): DevtoolsFormatter {\n *    ...\n *  }\n * ```\n */\n\nexport const devtoolsFormatter = Symbol.for('devtoolsFormatter');\n\nexport type JsonML = [string, Record<string, any>?, ...(JsonML | string)[]];\n\nexport interface DevtoolsFormatter {\n  /**\n   * NOTE: Make sure to do an instance check and return null if the object is not of the correct type.\n   */\n  header: (config?: any) => JsonML | null;\n  hasBody?: (config?: any) => boolean;\n  body?: (config?: any) => JsonML | null;\n}\n\n/**\n * Types that implement this interface can provide custom formatters for the Chrome Devtools.\n *\n * https://firefox-source-docs.mozilla.org/devtools-user/custom_formatters/index.html\n */\nexport interface CustomDevtoolsFormattable {\n  get [devtoolsFormatter](): DevtoolsFormatter;\n}\n\nconst register = () => {\n  if (typeof window !== 'undefined') {\n    ((window as any).devtoolsFormatters ??= []).push({\n      header: (value: any, config: any) => {\n        const formatter = value[devtoolsFormatter];\n        if (formatter === undefined) {\n          return null;\n        }\n        if (typeof formatter !== 'object' || formatter === null || typeof formatter.header !== 'function') {\n          throw new Error(`Invalid devtools formatter for ${value.constructor.name}`);\n        }\n\n        return formatter.header(config);\n      },\n      hasBody: (value: any, config: any) => {\n        const formatter = value[devtoolsFormatter];\n        if (!formatter || !formatter.hasBody) {\n          return false;\n        }\n\n        return formatter.hasBody(config);\n      },\n      body: (value: any, config: any) => {\n        const formatter = value[devtoolsFormatter];\n        if (!formatter || !formatter.body) {\n          return null;\n        }\n\n        return formatter.body(config);\n      },\n    });\n  }\n};\n\nregister();\n", "//\n// Copyright 2023 DXOS.org\n//\n\nexport const equalsSymbol = Symbol.for('dxos.common.equals');\n\nexport interface Equatable {\n  [equalsSymbol]: (other: any) => boolean;\n}\n\n// TODO(dmaretskyi): export to @dxos/traits.\n// TODO(dmaretskyi): Hash trait for maps?\n\nexport const isEquatable = (value: any): value is Equatable => {\n  return typeof value === 'object' && value !== null && typeof value[equalsSymbol] === 'function';\n};\n\nexport const isEqual = (value: Equatable, other: any) => {\n  return value[equalsSymbol](other);\n};\n\n/**\n * Feed this as a third argument to `_.isEqualWith` to compare objects with `Equatable` interface.\n */\nexport const loadashEqualityFn = (value: any, other: any): boolean | undefined => {\n  if (!isEquatable(value)) {\n    return undefined;\n  }\n  return isEqual(value, other);\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\n/**\n * Allows to register a module to be used later during debugging.\n *\n * ```ts\n * import * as keys from '@dxos/keys';\n * exposeModule('@dxos/keys', keys);\n *\n * ...\n *\n * const { PublicKey } = importModule('@dxos/keys');\n * ```\n *\n * Overwrites the module if it already exists.\n */\nexport const exposeModule = (name: string, module: any) => {\n  EXPOSED_MODULES[name] = module;\n};\n\n/**\n * Imports a previously exposed module by its name.\n * Throws an error if the module is not found.\n *\n * @param {string} name - The name of the module to import.\n * @returns {any} The imported module.\n * @throws {Error} If the module is not exposed.\n */\nexport const importModule = (name: string) => {\n  if (EXPOSED_MODULES[name]) {\n    return EXPOSED_MODULES[name];\n  } else {\n    throw new Error(`Module ${name} is not exposed.`);\n  }\n};\n\nconst EXPOSED_MODULES: Record<string, any> = {};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport type { InspectOptionsStylized, inspect as inspectFn } from 'node:util';\n\n/**\n * Using this allows code to be written in a portable fashion, so that the custom inspect function is used in an Node.js environment and ignored in the browser.\n */\nexport const inspectCustom = Symbol.for('nodejs.util.inspect.custom');\n\nexport type CustomInspectFunction<T = any> = (\n  this: T,\n  depth: number,\n  options: InspectOptionsStylized,\n  inspect: typeof inspectFn,\n) => any; // TODO: , inspect: inspect\n\nexport interface CustomInspectable {\n  [inspectCustom]: CustomInspectFunction;\n}\n"],
  "mappings": "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",
  "names": ["checkType", "value", "ErrorHandler", "EventEmitter", "_listener", "event", "cause", "error", "reason", "message", "stack", "toString", "emit", "window", "addEventListener", "reset", "removeEventListener", "ErrorStream", "_unhandledErrors", "assertNoUnhandledErrors", "Error", "raise", "_handler", "_unhandledError", "handle", "handler", "pipeTo", "receiver", "setTimeout", "failUndefined", "inspectObject", "obj", "name", "Object", "getPrototypeOf", "toJSON", "inspect", "String", "logMethod", "target", "propertyName", "descriptor", "method", "args", "console", "log", "result", "apply", "catch", "err", "SnoopLevel", "Snoop", "stackFunction", "split", "match", "file", "line", "substring", "lastIndexOf", "_context", "verbose", "bold", "format", "prefix", "level", "pre", "repeat", "label", "join", "in", "out", "sync", "f", "r", "async", "snoop", "StackTrace", "_stack", "getStack", "skipFrames", "slice", "getStackArray", "truncate", "str", "length", "pad", "padEnd", "truncateKey", "key", "expectToThrow", "test", "errType", "thrown", "undefined", "prototype", "warnAfterTimeout", "timeout", "context", "body", "timeoutId", "warn", "toLocaleString", "clearTimeout", "timed", "todo", "devtoolsFormatter", "Symbol", "for", "register", "devtoolsFormatters", "push", "header", "config", "formatter", "hasBody", "equalsSymbol", "isEquatable", "isEqual", "other", "loadashEqualityFn", "exposeModule", "module", "EXPOSED_MODULES", "importModule", "inspectCustom"]
}
