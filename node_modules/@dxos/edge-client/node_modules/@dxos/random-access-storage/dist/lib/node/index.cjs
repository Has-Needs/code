"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var node_exports = {};
__export(node_exports, {
  AbstractStorage: () => AbstractStorage,
  Directory: () => Directory,
  MemoryStorage: () => MemoryStorage,
  StorageType: () => StorageType,
  createStorage: () => createStorage,
  getFullPath: () => getFullPath,
  stringDiff: () => stringDiff,
  wrapFile: () => wrapFile
});
module.exports = __toCommonJS(node_exports);
var import_node_path = require("node:path");
var import_node_util = require("node:util");
var import_debug = require("@dxos/debug");
var import_log = require("@dxos/log");
var import_node_path2 = require("node:path");
var import_pify = __toESM(require("pify"));
var import_log2 = require("@dxos/log");
var import_random_access_memory = __toESM(require("random-access-memory"));
var import_util = require("@dxos/util");
var import_del = __toESM(require("del"));
var import_node_fs = require("node:fs");
var import_promises = require("node:fs/promises");
var import_node_path3 = require("node:path");
var import_random_access_file = __toESM(require("random-access-file"));
var stringDiff = (first, second) => first.split(second).join("");
var getFullPath = (root, path) => (0, import_node_path2.join)(root, stringDiff(path, root));
var Directory = class _Directory {
  constructor({ type, path, list, getOrCreateFile, remove, onFlush }) {
    this.type = type;
    this.path = path;
    this._list = list;
    this._getOrCreateFile = getOrCreateFile;
    this._remove = remove;
    this._onFlush = onFlush;
  }
  toString() {
    return `Directory(${JSON.stringify({
      type: this.type,
      path: this.path
    })})`;
  }
  /**
  * Create a new sub-directory.
  */
  createDirectory(path) {
    return new _Directory({
      type: this.type,
      path: getFullPath(this.path, path),
      list: this._list,
      getOrCreateFile: this._getOrCreateFile,
      remove: this._remove
    });
  }
  /**
  * Get all files in the current directory.
  */
  list() {
    return this._list(this.path);
  }
  /**
  * Get or create a new file.
  */
  getOrCreateFile(filename, opts) {
    return this._getOrCreateFile(this.path, filename, opts);
  }
  async flush() {
    await this._onFlush?.();
  }
  /**
  * Close and delete all files in the directory and all its sub-directories.
  */
  async delete() {
    await this._remove();
  }
};
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/common/random-access-storage/src/common/file.ts";
var MAX_STORAGE_OPERATION_TIME = 50;
var pifyFields = (object, type, fields) => {
  for (const field of fields) {
    if (!object[field]) {
    } else {
      const fn = (0, import_pify.default)(object[field].bind(object));
      object[field] = async (...args) => {
        const before = performance.now();
        const res = await fn(...args);
        const elapsed = performance.now() - before;
        if (elapsed > MAX_STORAGE_OPERATION_TIME) {
          (0, import_log2.log)("Slow storage operation", {
            type,
            operation: field,
            elapsed
          }, {
            F: __dxlog_file,
            L: 62,
            S: void 0,
            C: (f, a) => f(...a)
          });
        }
        return res;
      };
    }
  }
  return object;
};
var wrapFile = (native, type) => {
  const file = pifyFields(native, type, [
    "write",
    "read",
    "del",
    "stat",
    "close",
    "destroy",
    "truncate"
  ]);
  return Object.assign(file, {
    type,
    native
  });
};
var __dxlog_file2 = "/home/runner/work/dxos/dxos/packages/common/random-access-storage/src/common/abstract-storage.ts";
var AbstractStorage = class {
  // TODO(burdon): Make required.
  constructor(path) {
    this.path = path;
    this._files = /* @__PURE__ */ new Map();
  }
  [import_node_util.inspect.custom]() {
    return (0, import_debug.inspectObject)(this);
  }
  toJSON() {
    return {
      type: this.type,
      path: this.path
    };
  }
  get size() {
    return this._files.size;
  }
  // TODO(burdon): Make required.
  createDirectory(sub = "") {
    return new Directory({
      type: this.type,
      path: getFullPath(this.path, sub),
      list: this._list.bind(this),
      getOrCreateFile: (...args) => this.getOrCreateFile(...args),
      remove: () => this._remove(sub)
    });
  }
  /**
  * Delete all files.
  */
  async reset() {
    try {
      import_log.log.info("Erasing all data...", void 0, {
        F: __dxlog_file2,
        L: 60,
        S: this,
        C: (f, a) => f(...a)
      });
      await this._closeFilesInPath("");
      await this._remove("");
      await this._destroy();
      (0, import_log.log)("Erased...", void 0, {
        F: __dxlog_file2,
        L: 64,
        S: this,
        C: (f, a) => f(...a)
      });
    } catch (err) {
      import_log.log.catch(err, void 0, {
        F: __dxlog_file2,
        L: 66,
        S: this,
        C: (f, a) => f(...a)
      });
    }
  }
  async _list(path) {
    return Array.from((await this._getFiles(path)).keys()).map((filename) => {
      let name = filename.replace(path, "");
      if (name.startsWith("/")) {
        name = name.substring(1);
      }
      return name;
    });
  }
  getOrCreateFile(path, filename, opts) {
    const fullPath = (0, import_node_path.join)(path, filename);
    let native;
    let file = this._getFileIfExists(fullPath);
    if (file) {
      if (!file.closed) {
        return file;
      }
      native = this._openFile(file.native);
    }
    if (!native) {
      native = this._createFile(path, filename, opts);
    }
    file = wrapFile(native, this.type);
    this._files.set(fullPath, file);
    return file;
  }
  _destroy() {
    return void 0;
  }
  /**
  * Attempt to reopen file.
  */
  _openFile(file) {
    return void 0;
  }
  _getFileIfExists(filename) {
    if (this._files.has(filename)) {
      const file = this._files.get(filename);
      if (file && !file.destroyed) {
        return file;
      }
    }
  }
  async _getFiles(path) {
    const fullPath = getFullPath(this.path, path);
    return new Map([
      ...this._files.entries()
    ].filter(([path2, file]) => path2.includes(fullPath) && file.destroyed !== true));
  }
  async _closeFilesInPath(path) {
    await Promise.all(Array.from((await this._getFiles(path)).values()).map((file) => file.close().catch((err) => import_log.log.catch(err, void 0, {
      F: __dxlog_file2,
      L: 134,
      S: this,
      C: (f, a) => f(...a)
    }))));
  }
  async close() {
    await this._closeFilesInPath("");
  }
  // TODO(burdon): Delete directory (not just listed files).
  async _remove(path) {
    await Promise.all(Array.from(await this._getFiles(path)).map(([path2, file]) => {
      return file.destroy().then(() => this._files.delete(path2)).catch((err) => import_log.log.error(err.message, void 0, {
        F: __dxlog_file2,
        L: 149,
        S: this,
        C: (f, a) => f(...a)
      }));
    }));
  }
};
var StorageType = /* @__PURE__ */ function(StorageType2) {
  StorageType2["RAM"] = "ram";
  StorageType2["IDB"] = "idb";
  StorageType2["CHROME"] = "chrome";
  StorageType2["FIREFOX"] = "firefox";
  StorageType2["NODE"] = "node";
  StorageType2["WEBFS"] = "webfs";
  return StorageType2;
}({});
var MemoryStorage = class extends AbstractStorage {
  constructor() {
    super(...arguments);
    this.type = StorageType.RAM;
  }
  _createFile(path, filename) {
    return this._patchFile((0, import_random_access_memory.default)());
  }
  _openFile(file) {
    const newFile = file.clone();
    newFile.closed = false;
    return this._patchFile(newFile);
  }
  _patchFile(file) {
    const trueRead = file.read.bind(file);
    file.read = (offset, size, cb) => trueRead(offset, size, (err, data) => {
      if (err) {
        return cb(err);
      } else {
        return cb(err, (0, import_util.arrayToBuffer)(data));
      }
    });
    return file;
  }
  async getDiskInfo() {
    let used = 0;
    for (const file of this._files.values()) {
      const size = file.length;
      used += Number.isNaN(size) ? 0 : size;
    }
    return {
      used
    };
  }
};
var NodeStorage = class extends AbstractStorage {
  constructor() {
    super(...arguments);
    this.type = StorageType.NODE;
    this._initialized = false;
  }
  async _loadFiles(path) {
    if (!(0, import_node_fs.existsSync)(path)) {
      return;
    }
    const dir = await (0, import_promises.readdir)(path);
    for (const entry of dir) {
      const fullPath = (0, import_node_path3.join)(path, entry);
      if (this._files.has(fullPath)) {
        continue;
      }
      const entryInfo = await (0, import_promises.stat)(fullPath);
      if (entryInfo.isDirectory()) {
        await this._loadFiles(fullPath);
      } else if (entryInfo.isFile()) {
        const file = this._createFile(path, entry);
        this._files.set(fullPath, wrapFile(file, this.type));
      }
    }
  }
  _createFile(path, filename, opts = {}) {
    const file = (0, import_random_access_file.default)(filename, {
      directory: path,
      ...opts
    });
    file.write(0, Buffer.from(""));
    return file;
  }
  async _destroy() {
    await (0, import_del.default)(this.path, {
      force: true
    });
  }
  async _getFiles(path) {
    if (!this._initialized) {
      await this._loadFiles(this.path);
      this._initialized = true;
    }
    return super._getFiles(path);
  }
  async getDiskInfo() {
    let used = 0;
    const recurse = async (path) => {
      const pathStats = await (0, import_promises.stat)(path);
      if (pathStats.isDirectory()) {
        const entries = await (0, import_promises.readdir)(path);
        await Promise.all(entries.map((entry) => recurse((0, import_node_path3.join)(path, entry))));
      } else {
        used += pathStats.size;
      }
    };
    await recurse(this.path);
    return {
      used
    };
  }
};
var createStorage = ({ type, root = "/tmp/dxos/testing" } = {}) => {
  if (type === void 0) {
    return new NodeStorage(root);
  }
  switch (type) {
    case StorageType.RAM: {
      return new MemoryStorage(root);
    }
    case StorageType.NODE: {
      return new NodeStorage(root);
    }
    default: {
      throw new Error(`Invalid type: ${type}`);
    }
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AbstractStorage,
  Directory,
  MemoryStorage,
  StorageType,
  createStorage,
  getFullPath,
  stringDiff,
  wrapFile
});
//# sourceMappingURL=index.cjs.map
