import '@dxos/util';
/**
 * A locking mechanism to ensure that a given section of the code is executed by only one single "thread" at a time.
 *
 * Functions are chained in a structure similar to a linked list.
 * `_lastPromise` always contains the function that will finish executing last.
 *
 * Initially it is set to `Promise.resolve()` -- a promise that resolves immediately.
 * Enqueuing is done by attaching provided function to the `_lastPromise` via a `.then()` call
 * then updating the `_lastPromise` variable.
 *
 * It is important that enqueuing is done atomically:
 * there are no `await`s in `executeSynchronized` and it's not async while still returning a promise.
 *
 * Java docs reference on synchronized sections:
 * https://docs.oracle.com/javase/tutorial/essential/concurrency/locksync.html
 */
export declare class Mutex {
    private _queue;
    private _queueLength;
    private _tag;
    get tag(): string | null;
    isLocked(): boolean;
    /**
     * Acquires the lock.
     * Caller is responsible for releasing the lock using the returned callback.
     * NOTE: Using `executeSynchronized` is preferred over using `acquire` directly.
     * @returns Release callback
     */
    acquire(tag?: string): Promise<MutexGuard>;
    /**
     * Waits for all previous executions to complete and then executes a given function.
     * Only a single function can be executed at a time.
     * Function are executed in the same order as `executeSynchronized` is called.
     * WARNING: Calling `executeSynchronized` inside of `executeSynchronized` on the same lock instance is a deadlock.
     */
    executeSynchronized<T>(fun: () => Promise<T>): Promise<T>;
}
export declare class MutexGuard {
    private readonly _release;
    constructor(_release: () => void);
    /**
     * Releases the lock.
     */
    release(): void;
    [Symbol.dispose](): void;
}
/**
 * Same as `synchronized` in Java.
 * Uses a lock global to the current class instance.
 * This way every synchronized method on the same instance will share a single lock.
 */
export declare const synchronized: (target: any, propertyName: string, descriptor: TypedPropertyDescriptor<(...args: any) => Promise<any>>) => void;
//# sourceMappingURL=mutex.d.ts.map