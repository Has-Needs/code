"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var node_exports = {};
__export(node_exports, {
  Keyring: () => Keyring,
  generateJWKKeyPair: () => generateJWKKeyPair,
  parseJWKKeyPair: () => parseJWKKeyPair
});
module.exports = __toCommonJS(node_exports);
var import_async = require("@dxos/async");
var import_crypto = require("@dxos/crypto");
var import_debug = require("@dxos/debug");
var import_invariant = require("@dxos/invariant");
var import_keys = require("@dxos/keys");
var import_proto = require("@dxos/protocols/proto");
var import_random_access_storage = require("@dxos/random-access-storage");
var import_util = require("@dxos/util");
var import_crypto2 = require("@dxos/crypto");
function _ts_decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/core/halo/keyring/src/keyring.ts";
var KeyRecord = import_proto.schema.getCodecForType("dxos.halo.keyring.KeyRecord");
var Keyring = class {
  constructor(_storage = (0, import_random_access_storage.createStorage)({
    type: import_random_access_storage.StorageType.RAM
  }).createDirectory("keyring")) {
    this._storage = _storage;
    this._keyCache = new import_util.ComplexMap(import_keys.PublicKey.hash);
    this.keysUpdate = new import_async.Event();
    (0, import_invariant.invariant)(import_crypto.subtleCrypto, "SubtleCrypto not available in this environment.", {
      F: __dxlog_file,
      L: 30,
      S: this,
      A: [
        "subtleCrypto",
        "'SubtleCrypto not available in this environment.'"
      ]
    });
  }
  async sign(key, message) {
    const keyPair = await this._getKey(key);
    return new Uint8Array(await import_crypto.subtleCrypto.sign({
      name: "ECDSA",
      hash: "SHA-256"
    }, keyPair.privateKey, message));
  }
  async createKey() {
    const keyPair = await import_crypto.subtleCrypto.generateKey({
      name: "ECDSA",
      namedCurve: "P-256"
    }, true, [
      "sign",
      "verify"
    ]);
    await this._setKey(keyPair);
    return keyPairToPublicKey(keyPair);
  }
  async _getKey(key) {
    if (!this._keyCache.has(key)) {
      const file = this._storage.getOrCreateFile(key.toHex());
      const { size } = await file.stat();
      if (size === 0) {
        throw new Error(`Key not found: ${key.toHex()}`);
      }
      const recordBytes = await file.read(0, size);
      await file.close();
      const record = KeyRecord.decode(recordBytes);
      const publicKey = import_keys.PublicKey.from(record.publicKey);
      (0, import_invariant.invariant)(key.equals(publicKey), "Corrupted keyring: Key mismatch", {
        F: __dxlog_file,
        L: 77,
        S: this,
        A: [
          "key.equals(publicKey)",
          "'Corrupted keyring: Key mismatch'"
        ]
      });
      (0, import_invariant.invariant)(record.privateKey, "Corrupted keyring: Missing private key", {
        F: __dxlog_file,
        L: 78,
        S: this,
        A: [
          "record.privateKey",
          "'Corrupted keyring: Missing private key'"
        ]
      });
      const keyPair = {
        publicKey: await import_crypto.subtleCrypto.importKey("raw", record.publicKey, {
          name: "ECDSA",
          namedCurve: "P-256"
        }, true, [
          "verify"
        ]),
        privateKey: await import_crypto.subtleCrypto.importKey("pkcs8", record.privateKey, {
          name: "ECDSA",
          namedCurve: "P-256"
        }, true, [
          "sign"
        ])
      };
      this._keyCache.set(publicKey, keyPair);
    }
    return this._keyCache.get(key);
  }
  async _setKey(keyPair) {
    const publicKey = await keyPairToPublicKey(keyPair);
    this._keyCache.set(publicKey, keyPair);
    const record = {
      publicKey: publicKey.asUint8Array(),
      privateKey: new Uint8Array(await import_crypto.subtleCrypto.exportKey("pkcs8", keyPair.privateKey))
    };
    const file = this._storage.getOrCreateFile(publicKey.toHex());
    await file.write(0, (0, import_util.arrayToBuffer)(KeyRecord.encode(record)));
    await file.close();
    await file.flush?.();
    this.keysUpdate.emit();
  }
  // TODO(burdon): ???
  deleteKey(key) {
    return (0, import_debug.todo)("We need a method to delete a file.");
  }
  async list() {
    const keys = [];
    for (const path of await this._storage.list()) {
      const fileName = path.split("/").pop();
      (0, import_invariant.invariant)(fileName, "Invalid file name", {
        F: __dxlog_file,
        L: 134,
        S: this,
        A: [
          "fileName",
          "'Invalid file name'"
        ]
      });
      keys.push({
        publicKey: import_keys.PublicKey.fromHex(fileName).asUint8Array()
      });
    }
    return keys;
  }
  async importKeyPair(keyPair) {
    await this._setKey(keyPair);
    return keyPairToPublicKey(keyPair);
  }
};
_ts_decorate([
  import_async.synchronized
], Keyring.prototype, "_getKey", null);
_ts_decorate([
  import_async.synchronized
], Keyring.prototype, "_setKey", null);
var keyPairToPublicKey = async (keyPair) => {
  return import_keys.PublicKey.from(new Uint8Array(await import_crypto.subtleCrypto.exportKey("raw", keyPair.publicKey)));
};
var generateJWKKeyPair = async () => {
  const keyPair = await import_crypto2.subtleCrypto.generateKey({
    name: "ECDSA",
    namedCurve: "P-256"
  }, true, [
    "sign",
    "verify"
  ]);
  const privateKeyExported = await import_crypto2.subtleCrypto.exportKey("jwk", keyPair.privateKey);
  const publicKeyExported = await import_crypto2.subtleCrypto.exportKey("jwk", keyPair.publicKey);
  const publicKeyBuffer = new Uint8Array(await import_crypto2.subtleCrypto.exportKey("raw", keyPair.publicKey));
  const publicKeyHex = Array.from(publicKeyBuffer).map((byte) => byte.toString(16).padStart(2, "0")).join("");
  return {
    privateKey: privateKeyExported,
    publicKey: publicKeyExported,
    publicKeyHex
  };
};
var parseJWKKeyPair = async (privateKey, publicKey) => {
  return {
    privateKey: await import_crypto2.subtleCrypto.importKey("jwk", privateKey, {
      name: "ECDSA",
      namedCurve: "P-256"
    }, true, [
      "sign"
    ]),
    publicKey: await import_crypto2.subtleCrypto.importKey("jwk", publicKey, {
      name: "ECDSA",
      namedCurve: "P-256"
    }, true, [
      "verify"
    ])
  };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Keyring,
  generateJWKKeyPair,
  parseJWKKeyPair
});
//# sourceMappingURL=index.cjs.map
