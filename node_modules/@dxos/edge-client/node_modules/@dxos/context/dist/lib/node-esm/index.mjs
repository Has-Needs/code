import { createRequire } from 'node:module';const require = createRequire(import.meta.url);

// packages/common/context/src/context.ts
import { inspect } from "node:util";
import { StackTrace } from "@dxos/debug";
import { log } from "@dxos/log";
import { safeInstanceof } from "@dxos/util";

// packages/common/context/src/context-disposed-error.ts
var ContextDisposedError = class extends Error {
  constructor() {
    super("Context disposed.");
  }
};

// packages/common/context/src/context.ts
function _ts_decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/common/context/src/context.ts";
var DEBUG_LOG_DISPOSE = false;
var MAX_SAFE_DISPOSE_CALLBACKS = 300;
var DEFAULT_ERROR_HANDLER = (error, ctx) => {
  if (error instanceof ContextDisposedError) {
    return;
  }
  void ctx.dispose();
  throw error;
};
var CONTEXT_FLAG_IS_DISPOSED = 1 << 0;
var CONTEXT_FLAG_LEAK_DETECTED = 1 << 1;
var _a, _b;
var Context = class _Context {
  constructor(params = {}, callMeta) {
    this.#disposeCallbacks = [];
    this.#name = void 0;
    this.#parent = void 0;
    this.#flags = 0;
    this.#disposePromise = void 0;
    this.maxSafeDisposeCallbacks = MAX_SAFE_DISPOSE_CALLBACKS;
    this[_b] = "Context";
    this[_a] = () => this.toString();
    this.#name = getContextName(params, callMeta);
    this.#parent = params.parent;
    this.#attributes = params.attributes ?? {};
    this.#onError = params.onError ?? DEFAULT_ERROR_HANDLER;
  }
  static default() {
    return new _Context();
  }
  #disposeCallbacks;
  #name;
  #parent;
  #attributes;
  #onError;
  #flags;
  #disposePromise;
  get #isDisposed() {
    return !!(this.#flags & CONTEXT_FLAG_IS_DISPOSED);
  }
  set #isDisposed(value) {
    this.#flags = value ? this.#flags | CONTEXT_FLAG_IS_DISPOSED : this.#flags & ~CONTEXT_FLAG_IS_DISPOSED;
  }
  get #leakDetected() {
    return !!(this.#flags & CONTEXT_FLAG_LEAK_DETECTED);
  }
  set #leakDetected(value) {
    this.#flags = value ? this.#flags | CONTEXT_FLAG_LEAK_DETECTED : this.#flags & ~CONTEXT_FLAG_LEAK_DETECTED;
  }
  get disposed() {
    return this.#isDisposed;
  }
  get disposeCallbacksLength() {
    return this.#disposeCallbacks.length;
  }
  /**
  * Schedules a callback to run when the context is disposed.
  * May be async, in this case the disposer might choose to wait for all resource to released.
  * Throwing an error inside the callback will result in the error being logged, but not re-thrown.
  *
  * NOTE: Will call the callback immediately if the context is already disposed.
  *
  * @returns A function that can be used to remove the callback from the dispose list.
  */
  onDispose(callback) {
    if (this.#isDisposed) {
      void (async () => {
        try {
          await callback();
        } catch (error) {
          log.catch(error, {
            context: this.#name
          }, {
            F: __dxlog_file,
            L: 119,
            S: this,
            C: (f, a) => f(...a)
          });
        }
      })();
    }
    this.#disposeCallbacks.push(callback);
    if (this.#disposeCallbacks.length > this.maxSafeDisposeCallbacks && !this.#leakDetected) {
      this.#leakDetected = true;
      const callSite = new StackTrace().getStackArray(1)[0].trim();
      log.warn("Context has a large number of dispose callbacks (this might be a memory leak).", {
        context: this.#name,
        callSite,
        count: this.#disposeCallbacks.length
      }, {
        F: __dxlog_file,
        L: 128,
        S: this,
        C: (f, a) => f(...a)
      });
    }
    return () => {
      const index = this.#disposeCallbacks.indexOf(callback);
      if (index !== -1) {
        this.#disposeCallbacks.splice(index, 1);
      }
    };
  }
  /**
  * Runs all dispose callbacks.
  * Callbacks are run in the reverse order they were added.
  * This function never throws.
  * It is safe to ignore the returned promise if the caller does not wish to wait for callbacks to complete.
  * Disposing context means that onDispose will throw an error and any errors raised will be logged and not propagated.
  * @returns true if there were no errors during the dispose process.
  */
  async dispose(throwOnError = false) {
    if (this.#disposePromise) {
      return this.#disposePromise;
    }
    this.#isDisposed = true;
    let resolveDispose;
    const promise = new Promise((resolve) => {
      resolveDispose = resolve;
    });
    this.#disposePromise = promise;
    const callbacks = Array.from(this.#disposeCallbacks).reverse();
    this.#disposeCallbacks.length = 0;
    if (DEBUG_LOG_DISPOSE) {
      log("disposing", {
        context: this.#name,
        count: callbacks.length
      }, {
        F: __dxlog_file,
        L: 173,
        S: this,
        C: (f, a) => f(...a)
      });
    }
    let i = 0;
    let clean = true;
    const errors = [];
    for (const callback of callbacks) {
      try {
        await callback();
        i++;
      } catch (err) {
        clean = false;
        if (throwOnError) {
          errors.push(err);
        } else {
          log.catch(err, {
            context: this.#name,
            callback: i,
            count: callbacks.length
          }, {
            F: __dxlog_file,
            L: 188,
            S: this,
            C: (f, a) => f(...a)
          });
        }
      }
    }
    if (errors.length > 0) {
      throw new AggregateError(errors);
    }
    resolveDispose(clean);
    if (DEBUG_LOG_DISPOSE) {
      log("disposed", {
        context: this.#name
      }, {
        F: __dxlog_file,
        L: 199,
        S: this,
        C: (f, a) => f(...a)
      });
    }
    return clean;
  }
  /**
  * Raise the error inside the context.
  * The error will be propagated to the error handler.
  * IF the error handler is not set, the error will dispose the context and cause an unhandled rejection.
  */
  raise(error) {
    if (this.#isDisposed) {
      return;
    }
    try {
      this.#onError(error, this);
    } catch (err) {
      void Promise.reject(err);
    }
  }
  derive({ onError, attributes } = {}) {
    const newCtx = new _Context({
      // TODO(dmaretskyi): Optimize to not require allocating a new closure for every context.
      onError: async (error) => {
        if (!onError) {
          this.raise(error);
        } else {
          try {
            await onError(error, this);
          } catch {
            this.raise(error);
          }
        }
      },
      attributes
    });
    const clearDispose = this.onDispose(() => newCtx.dispose());
    newCtx.onDispose(clearDispose);
    return newCtx;
  }
  getAttribute(key) {
    if (key in this.#attributes) {
      return this.#attributes[key];
    }
    if (this.#parent) {
      return this.#parent.getAttribute(key);
    }
    return void 0;
  }
  toString() {
    return `Context(${this.#isDisposed ? "disposed" : "active"})`;
  }
  async [(_b = Symbol.toStringTag, _a = inspect.custom, Symbol.asyncDispose)]() {
    await this.dispose();
  }
};
Context = _ts_decorate([
  safeInstanceof("Context")
], Context);
var getContextName = (params, callMeta) => {
  if (params.name) {
    return params.name;
  }
  if (callMeta?.F?.length) {
    const pathSegments = callMeta?.F.split("/");
    return `${pathSegments[pathSegments.length - 1]}#${callMeta?.L ?? 0}`;
  }
  return void 0;
};

// packages/common/context/src/promise-utils.ts
var rejectOnDispose = (ctx, error = new ContextDisposedError()) => new Promise((resolve, reject) => {
  ctx.onDispose(() => reject(error));
});
var cancelWithContext = (ctx, promise) => {
  let clearDispose;
  return Promise.race([
    promise,
    new Promise((resolve, reject) => {
      clearDispose = ctx.onDispose(() => reject(new ContextDisposedError()));
    })
  ]).finally(() => clearDispose?.());
};

// packages/common/context/src/resource.ts
import { throwUnhandledError } from "@dxos/util";
var LifecycleState = /* @__PURE__ */ function(LifecycleState2) {
  LifecycleState2["CLOSED"] = "CLOSED";
  LifecycleState2["OPEN"] = "OPEN";
  LifecycleState2["ERROR"] = "ERROR";
  return LifecycleState2;
}({});
var CLOSE_RESOURCE_ON_UNHANDLED_ERROR = false;
var Resource = class {
  #lifecycleState = "CLOSED";
  #openPromise = null;
  #closePromise = null;
  /**
  * Managed internally by the resource.
  * Recreated on close.
  * Errors are propagated to the `_catch` method and the parent context.
  */
  #internalCtx = this.#createContext();
  /**
  * Context that is used to bubble up errors that are not handled by the resource.
  * Provided in the open method.
  */
  #parentCtx = this.#createParentContext();
  get #name() {
    return Object.getPrototypeOf(this).constructor.name;
  }
  get isOpen() {
    return this.#lifecycleState === "OPEN" && this.#closePromise == null;
  }
  get _lifecycleState() {
    return this.#lifecycleState;
  }
  get _ctx() {
    return this.#internalCtx;
  }
  /**
  * To be overridden by subclasses.
  */
  async _open(ctx) {
  }
  /**
  * To be overridden by subclasses.
  */
  async _close(ctx) {
  }
  /**
  * Error handler for errors that are caught by the context.
  * By default, errors are bubbled up to the parent context which is passed to the open method.
  */
  async _catch(err) {
    if (CLOSE_RESOURCE_ON_UNHANDLED_ERROR) {
      try {
        await this.close();
      } catch (doubleErr) {
        throwUnhandledError(doubleErr);
      }
    }
    throw err;
  }
  /**
  * Opens the resource.
  * If the resource is already open, it does nothing.
  * If the resource is in an error state, it throws an error.
  * If the resource is closed, it waits for it to close and then opens it.
  * @param ctx - Context to use for opening the resource. This context will receive errors that are not handled in `_catch`.
  */
  async open(ctx) {
    switch (this.#lifecycleState) {
      case "OPEN":
        return this;
      case "ERROR":
        throw new Error(`Invalid state: ${this.#lifecycleState}`);
      default:
    }
    await this.#closePromise;
    await (this.#openPromise ??= this.#open(ctx));
    return this;
  }
  /**
  * Closes the resource.
  * If the resource is already closed, it does nothing.
  */
  async close(ctx) {
    if (this.#lifecycleState === "CLOSED") {
      return this;
    }
    await this.#openPromise;
    await (this.#closePromise ??= this.#close(ctx));
    return this;
  }
  /**
  * Waits until the resource is open.
  */
  async waitUntilOpen() {
    switch (this.#lifecycleState) {
      case "OPEN":
        return;
      case "ERROR":
        throw new Error(`Invalid state: ${this.#lifecycleState}`);
    }
    if (!this.#openPromise) {
      throw new Error("Resource is not being opened");
    }
    await this.#openPromise;
  }
  async [Symbol.asyncDispose]() {
    await this.close();
  }
  async #open(ctx) {
    this.#closePromise = null;
    this.#parentCtx = ctx?.derive({
      name: this.#name
    }) ?? this.#createParentContext();
    await this._open(this.#parentCtx);
    this.#lifecycleState = "OPEN";
  }
  async #close(ctx = Context.default()) {
    this.#openPromise = null;
    await this.#internalCtx.dispose();
    await this._close(ctx);
    this.#internalCtx = this.#createContext();
    this.#lifecycleState = "CLOSED";
  }
  #createContext() {
    return new Context({
      name: this.#name,
      onError: (error) => queueMicrotask(async () => {
        try {
          await this._catch(error);
        } catch (err) {
          this.#lifecycleState = "ERROR";
          this.#parentCtx.raise(err);
        }
      })
    });
  }
  #createParentContext() {
    return new Context({
      name: this.#name
    });
  }
};
var openInContext = async (ctx, resource) => {
  await resource.open?.(ctx);
  ctx.onDispose(() => resource.close?.());
  return resource;
};
export {
  Context,
  ContextDisposedError,
  LifecycleState,
  Resource,
  cancelWithContext,
  openInContext,
  rejectOnDispose
};
//# sourceMappingURL=index.mjs.map
