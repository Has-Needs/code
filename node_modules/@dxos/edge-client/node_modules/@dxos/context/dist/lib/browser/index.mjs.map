{
  "version": 3,
  "sources": ["../../../src/context.ts", "../../../src/context-disposed-error.ts", "../../../src/promise-utils.ts", "../../../src/resource.ts"],
  "sourcesContent": ["//\n// Copyright 2022 DXOS.org\n//\n\nimport { inspect } from 'node:util';\n\nimport { StackTrace } from '@dxos/debug';\nimport { type CallMetadata, log } from '@dxos/log';\nimport { safeInstanceof } from '@dxos/util';\n\nimport { ContextDisposedError } from './context-disposed-error';\n\nexport type ContextErrorHandler = (error: Error, ctx: Context) => void;\n\nexport type DisposeCallback = () => any | Promise<any>;\n\nexport type CreateContextParams = {\n  name?: string;\n  parent?: Context;\n  attributes?: Record<string, any>;\n  onError?: ContextErrorHandler;\n};\n\nconst DEBUG_LOG_DISPOSE = false;\n\n/**\n * Maximum number of dispose callbacks before we start logging warnings.\n */\nconst MAX_SAFE_DISPOSE_CALLBACKS = 300;\n\nconst DEFAULT_ERROR_HANDLER: ContextErrorHandler = (error, ctx) => {\n  if (error instanceof ContextDisposedError) {\n    return;\n  }\n\n  void ctx.dispose();\n\n  // Will generate an unhandled rejection.\n  throw error;\n};\n\ntype ContextFlags = number;\n\nconst CONTEXT_FLAG_IS_DISPOSED: ContextFlags = 1 << 0;\n\n/**\n * Whether the dispose callback leak was detected.\n */\nconst CONTEXT_FLAG_LEAK_DETECTED: ContextFlags = 1 << 1;\n\n/**\n * NOTE: Context is not reusable after it is disposed.\n */\n@safeInstanceof('Context')\nexport class Context {\n  static default(): Context {\n    return new Context();\n  }\n\n  readonly #disposeCallbacks: DisposeCallback[] = [];\n\n  readonly #name?: string = undefined;\n  readonly #parent?: Context = undefined;\n  readonly #attributes: Record<string, any>;\n  readonly #onError: ContextErrorHandler;\n\n  #flags: ContextFlags = 0;\n  #disposePromise?: Promise<boolean> = undefined;\n\n  public maxSafeDisposeCallbacks = MAX_SAFE_DISPOSE_CALLBACKS;\n\n  constructor(params: CreateContextParams = {}, callMeta?: Partial<CallMetadata>) {\n    this.#name = getContextName(params, callMeta);\n    this.#parent = params.parent;\n    this.#attributes = params.attributes ?? {};\n    this.#onError = params.onError ?? DEFAULT_ERROR_HANDLER;\n  }\n\n  get #isDisposed() {\n    return !!(this.#flags & CONTEXT_FLAG_IS_DISPOSED);\n  }\n\n  set #isDisposed(value: boolean) {\n    this.#flags = value ? this.#flags | CONTEXT_FLAG_IS_DISPOSED : this.#flags & ~CONTEXT_FLAG_IS_DISPOSED;\n  }\n\n  get #leakDetected() {\n    return !!(this.#flags & CONTEXT_FLAG_LEAK_DETECTED);\n  }\n\n  set #leakDetected(value: boolean) {\n    this.#flags = value ? this.#flags | CONTEXT_FLAG_LEAK_DETECTED : this.#flags & ~CONTEXT_FLAG_LEAK_DETECTED;\n  }\n\n  get disposed() {\n    return this.#isDisposed;\n  }\n\n  get disposeCallbacksLength() {\n    return this.#disposeCallbacks.length;\n  }\n\n  /**\n   * Schedules a callback to run when the context is disposed.\n   * May be async, in this case the disposer might choose to wait for all resource to released.\n   * Throwing an error inside the callback will result in the error being logged, but not re-thrown.\n   *\n   * NOTE: Will call the callback immediately if the context is already disposed.\n   *\n   * @returns A function that can be used to remove the callback from the dispose list.\n   */\n  onDispose(callback: DisposeCallback): () => void {\n    if (this.#isDisposed) {\n      // Call the callback immediately if the context is already disposed.\n      void (async () => {\n        try {\n          await callback();\n        } catch (error: any) {\n          log.catch(error, { context: this.#name });\n        }\n      })();\n    }\n\n    this.#disposeCallbacks.push(callback);\n    if (this.#disposeCallbacks.length > this.maxSafeDisposeCallbacks && !this.#leakDetected) {\n      this.#leakDetected = true;\n      const callSite = new StackTrace().getStackArray(1)[0].trim();\n      log.warn('Context has a large number of dispose callbacks (this might be a memory leak).', {\n        context: this.#name,\n        callSite,\n        count: this.#disposeCallbacks.length,\n      });\n    }\n\n    // Remove handler.\n    return () => {\n      const index = this.#disposeCallbacks.indexOf(callback);\n      if (index !== -1) {\n        this.#disposeCallbacks.splice(index, 1);\n      }\n    };\n  }\n\n  /**\n   * Runs all dispose callbacks.\n   * Callbacks are run in the reverse order they were added.\n   * This function never throws.\n   * It is safe to ignore the returned promise if the caller does not wish to wait for callbacks to complete.\n   * Disposing context means that onDispose will throw an error and any errors raised will be logged and not propagated.\n   * @returns true if there were no errors during the dispose process.\n   */\n  async dispose(throwOnError = false): Promise<boolean> {\n    if (this.#disposePromise) {\n      return this.#disposePromise;\n    }\n\n    // TODO(burdon): Probably should not be set until the dispose is complete, but causes tests to fail if moved.\n    this.#isDisposed = true;\n\n    // Set the promise before running the callbacks.\n    let resolveDispose!: (value: boolean) => void;\n    const promise = new Promise<boolean>((resolve) => {\n      resolveDispose = resolve;\n    });\n    this.#disposePromise = promise;\n\n    // Process last first.\n    // Clone the array so that any mutations to the original array don't affect the dispose process.\n    const callbacks = Array.from(this.#disposeCallbacks).reverse();\n    this.#disposeCallbacks.length = 0;\n\n    if (DEBUG_LOG_DISPOSE) {\n      log('disposing', { context: this.#name, count: callbacks.length });\n    }\n\n    let i = 0;\n    let clean = true;\n    const errors: Error[] = [];\n    for (const callback of callbacks) {\n      try {\n        await callback();\n        i++;\n      } catch (err: any) {\n        clean = false;\n        if (throwOnError) {\n          errors.push(err);\n        } else {\n          log.catch(err, { context: this.#name, callback: i, count: callbacks.length });\n        }\n      }\n    }\n\n    if (errors.length > 0) {\n      throw new AggregateError(errors);\n    }\n\n    resolveDispose(clean);\n    if (DEBUG_LOG_DISPOSE) {\n      log('disposed', { context: this.#name });\n    }\n\n    return clean;\n  }\n\n  /**\n   * Raise the error inside the context.\n   * The error will be propagated to the error handler.\n   * IF the error handler is not set, the error will dispose the context and cause an unhandled rejection.\n   */\n  raise(error: Error): void {\n    if (this.#isDisposed) {\n      // TODO(dmaretskyi): Don't log those.\n      // log.warn('Error in disposed context', error);\n      return;\n    }\n\n    try {\n      this.#onError(error, this);\n    } catch (err) {\n      // Generate an unhandled rejection and stop the error propagation.\n      void Promise.reject(err);\n    }\n  }\n\n  derive({ onError, attributes }: CreateContextParams = {}): Context {\n    const newCtx = new Context({\n      // TODO(dmaretskyi): Optimize to not require allocating a new closure for every context.\n      onError: async (error) => {\n        if (!onError) {\n          this.raise(error);\n        } else {\n          try {\n            await onError(error, this);\n          } catch {\n            this.raise(error);\n          }\n        }\n      },\n      attributes,\n    });\n\n    const clearDispose = this.onDispose(() => newCtx.dispose());\n    newCtx.onDispose(clearDispose);\n    return newCtx;\n  }\n\n  getAttribute(key: string): any {\n    if (key in this.#attributes) {\n      return this.#attributes[key];\n    }\n    if (this.#parent) {\n      return this.#parent.getAttribute(key);\n    }\n\n    return undefined;\n  }\n\n  [Symbol.toStringTag] = 'Context';\n  [inspect.custom] = () => this.toString();\n\n  toString(): string {\n    return `Context(${this.#isDisposed ? 'disposed' : 'active'})`;\n  }\n\n  async [Symbol.asyncDispose](): Promise<void> {\n    await this.dispose();\n  }\n}\n\nconst getContextName = (params: CreateContextParams, callMeta?: Partial<CallMetadata>): string | undefined => {\n  if (params.name) {\n    return params.name;\n  }\n  if (callMeta?.F?.length) {\n    const pathSegments = callMeta?.F.split('/');\n    return `${pathSegments[pathSegments.length - 1]}#${callMeta?.L ?? 0}`;\n  }\n  return undefined;\n};\n", "//\n// Copyright 2023 DXOS.org\n//\n\nexport class ContextDisposedError extends Error {\n  constructor() {\n    super('Context disposed.');\n  }\n}\n", "//\n// Copyright 2023 DXOS.org\n//\n\nimport { type Context } from './context';\nimport { ContextDisposedError } from './context-disposed-error';\n\n/**\n * @returns A promise that rejects when the context is disposed.\n */\n// TODO(dmaretskyi): Memory leak.\nexport const rejectOnDispose = (ctx: Context, error = new ContextDisposedError()): Promise<never> =>\n  new Promise((resolve, reject) => {\n    ctx.onDispose(() => reject(error));\n  });\n\n/**\n * Rejects the promise if the context is disposed.\n */\nexport const cancelWithContext = <T>(ctx: Context, promise: Promise<T>): Promise<T> => {\n  let clearDispose: () => void;\n  return Promise.race([\n    promise,\n    new Promise<never>((resolve, reject) => {\n      // Will be called before .finally() handlers.\n      clearDispose = ctx.onDispose(() => reject(new ContextDisposedError()));\n    }),\n  ]).finally(() => clearDispose?.());\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { throwUnhandledError } from '@dxos/util';\n\nimport { Context } from './context';\n\nexport enum LifecycleState {\n  CLOSED = 'CLOSED',\n  OPEN = 'OPEN',\n  ERROR = 'ERROR',\n}\n\nexport interface Lifecycle {\n  open?(ctx?: Context): Promise<any> | any;\n  close?(): Promise<any> | any;\n}\n\n// Feature flag to be enabled later.\nconst CLOSE_RESOURCE_ON_UNHANDLED_ERROR = false;\n\n/**\n * Base class for resources that need to be opened and closed.\n */\nexport abstract class Resource implements Lifecycle {\n  #lifecycleState = LifecycleState.CLOSED;\n  #openPromise: Promise<void> | null = null;\n  #closePromise: Promise<void> | null = null;\n\n  /**\n   * Managed internally by the resource.\n   * Recreated on close.\n   * Errors are propagated to the `_catch` method and the parent context.\n   */\n  #internalCtx: Context = this.#createContext();\n\n  /**\n   * Context that is used to bubble up errors that are not handled by the resource.\n   * Provided in the open method.\n   */\n  #parentCtx: Context = this.#createParentContext();\n\n  get #name() {\n    return Object.getPrototypeOf(this).constructor.name;\n  }\n\n  get isOpen() {\n    return this.#lifecycleState === LifecycleState.OPEN && this.#closePromise == null;\n  }\n\n  protected get _lifecycleState() {\n    return this.#lifecycleState;\n  }\n\n  protected get _ctx() {\n    return this.#internalCtx;\n  }\n\n  /**\n   * To be overridden by subclasses.\n   */\n  protected async _open(ctx: Context): Promise<void> {}\n\n  /**\n   * To be overridden by subclasses.\n   */\n  protected async _close(ctx: Context): Promise<void> {}\n\n  /**\n   * Error handler for errors that are caught by the context.\n   * By default, errors are bubbled up to the parent context which is passed to the open method.\n   */\n  protected async _catch(err: Error): Promise<void> {\n    if (CLOSE_RESOURCE_ON_UNHANDLED_ERROR) {\n      try {\n        await this.close();\n      } catch (doubleErr: any) {\n        throwUnhandledError(doubleErr);\n      }\n    }\n    throw err;\n  }\n\n  /**\n   * Opens the resource.\n   * If the resource is already open, it does nothing.\n   * If the resource is in an error state, it throws an error.\n   * If the resource is closed, it waits for it to close and then opens it.\n   * @param ctx - Context to use for opening the resource. This context will receive errors that are not handled in `_catch`.\n   */\n  async open(ctx?: Context): Promise<this> {\n    switch (this.#lifecycleState) {\n      case LifecycleState.OPEN:\n        return this;\n      case LifecycleState.ERROR:\n        throw new Error(`Invalid state: ${this.#lifecycleState}`);\n      default:\n    }\n\n    await this.#closePromise;\n    await (this.#openPromise ??= this.#open(ctx));\n\n    return this;\n  }\n\n  /**\n   * Closes the resource.\n   * If the resource is already closed, it does nothing.\n   */\n  async close(ctx?: Context): Promise<this> {\n    if (this.#lifecycleState === LifecycleState.CLOSED) {\n      return this;\n    }\n    await this.#openPromise;\n    await (this.#closePromise ??= this.#close(ctx));\n\n    return this;\n  }\n\n  /**\n   * Waits until the resource is open.\n   */\n  async waitUntilOpen(): Promise<void> {\n    switch (this.#lifecycleState) {\n      case LifecycleState.OPEN:\n        return;\n      case LifecycleState.ERROR:\n        throw new Error(`Invalid state: ${this.#lifecycleState}`);\n    }\n\n    if (!this.#openPromise) {\n      throw new Error('Resource is not being opened');\n    }\n    await this.#openPromise;\n  }\n\n  async [Symbol.asyncDispose](): Promise<void> {\n    await this.close();\n  }\n\n  async #open(ctx?: Context): Promise<void> {\n    this.#closePromise = null;\n    this.#parentCtx = ctx?.derive({ name: this.#name }) ?? this.#createParentContext();\n    await this._open(this.#parentCtx);\n    this.#lifecycleState = LifecycleState.OPEN;\n  }\n\n  async #close(ctx = Context.default()): Promise<void> {\n    this.#openPromise = null;\n    await this.#internalCtx.dispose();\n    await this._close(ctx);\n    this.#internalCtx = this.#createContext();\n    this.#lifecycleState = LifecycleState.CLOSED;\n  }\n\n  #createContext(): Context {\n    return new Context({\n      name: this.#name,\n      onError: (error) =>\n        queueMicrotask(async () => {\n          try {\n            await this._catch(error);\n          } catch (err: any) {\n            this.#lifecycleState = LifecycleState.ERROR;\n            this.#parentCtx.raise(err);\n          }\n        }),\n    });\n  }\n\n  #createParentContext(): Context {\n    return new Context({ name: this.#name });\n  }\n}\n\nexport const openInContext = async <T extends Lifecycle>(ctx: Context, resource: T): Promise<T> => {\n  await resource.open?.(ctx);\n  ctx.onDispose(() => resource.close?.());\n  return resource;\n};\n"],
  "mappings": "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",
  "names": ["inspect", "StackTrace", "log", "safeInstanceof", "ContextDisposedError", "Error", "DEBUG_LOG_DISPOSE", "MAX_SAFE_DISPOSE_CALLBACKS", "DEFAULT_ERROR_HANDLER", "error", "ctx", "ContextDisposedError", "dispose", "CONTEXT_FLAG_IS_DISPOSED", "CONTEXT_FLAG_LEAK_DETECTED", "Context", "params", "callMeta", "undefined", "maxSafeDisposeCallbacks", "Symbol", "inspect", "toString", "getContextName", "parent", "attributes", "onError", "default", "value", "disposed", "disposeCallbacksLength", "length", "onDispose", "callback", "log", "catch", "context", "push", "callSite", "StackTrace", "getStackArray", "trim", "warn", "count", "index", "indexOf", "splice", "throwOnError", "resolveDispose", "promise", "Promise", "resolve", "callbacks", "Array", "from", "reverse", "i", "clean", "errors", "err", "AggregateError", "raise", "reject", "derive", "newCtx", "clearDispose", "getAttribute", "key", "toStringTag", "custom", "asyncDispose", "name", "F", "pathSegments", "split", "L", "rejectOnDispose", "ctx", "error", "ContextDisposedError", "Promise", "resolve", "reject", "onDispose", "cancelWithContext", "promise", "clearDispose", "race", "finally", "throwUnhandledError", "LifecycleState", "CLOSE_RESOURCE_ON_UNHANDLED_ERROR", "Resource", "Object", "getPrototypeOf", "name", "isOpen", "_lifecycleState", "_ctx", "_open", "ctx", "_close", "_catch", "err", "close", "doubleErr", "throwUnhandledError", "open", "Error", "waitUntilOpen", "Symbol", "asyncDispose", "derive", "Context", "default", "dispose", "onError", "error", "queueMicrotask", "raise", "openInContext", "resource", "onDispose"]
}
