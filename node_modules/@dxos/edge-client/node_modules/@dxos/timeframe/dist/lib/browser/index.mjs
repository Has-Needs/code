import "@dxos/node-std/globals";

// packages/common/timeframe/src/timeframe.ts
import { inspect } from "@dxos/node-std/util";
import { equalsSymbol } from "@dxos/debug";
var Timeframe = class _Timeframe {
  constructor(frames = []) {
    this._frames = /* @__PURE__ */ new Map();
    for (const [key, seq] of frames) {
      this.set(key, seq);
    }
  }
  toJSON() {
    return this.frames().reduce((frames, [key, seq]) => {
      frames[key.truncate()] = seq;
      return frames;
    }, {});
  }
  toString() {
    return `(${this.frames().map(([key, seq]) => `${key.truncate()}[${seq}]`).join(", ")})`;
  }
  equals(object) {
    return this.size() === object.size() && this.frames().every(([key, seq]) => object.get(key) === seq);
  }
  // TODO(burdon): Rename getFrame.
  get(key) {
    return this._frames.get(key.toHex())?.seq;
  }
  // TODO(burdon): Rename setFrame.
  set(key, seq) {
    const hex = key.toHex();
    this._frames.set(hex, {
      key,
      seq
    });
  }
  // TODO(burdon): Change to getter.
  frames() {
    return Array.from(this._frames.values()).map(({ key, seq }) => [
      key,
      seq
    ]);
  }
  // TODO(burdon): Change to getter.
  size() {
    return this._frames.size;
  }
  // TODO(burdon): Change to getter (empty).
  isEmpty() {
    return this.size() === 0;
  }
  /**
  * Returns a new timeframe with specified keys removed.
  * @param keys
  */
  withoutKeys(keys) {
    return new _Timeframe(this.frames().filter(([frameKey]) => keys.every((key) => !key.equals(frameKey))));
  }
  map(fn) {
    return new _Timeframe(this.frames().map(fn));
  }
  /**
  * Returns a total amount of messages represented by this timeframe.
  */
  totalMessages() {
    return Array.from(this._frames.values()).reduce((result, { seq }) => result + seq + 1, 0);
  }
  /**
  * Returns a total amount of messages that are present in this timeframe but are missing in `base`.
  */
  newMessages(base) {
    return Array.from(this._frames.entries()).reduce((result, [hex, { seq }]) => result + Math.max(seq - (base._frames.get(hex)?.seq ?? -1), 0), 0);
  }
  /**
  * Used by NodeJS to get textual representation of this object in `console.log`.
  */
  [inspect.custom]() {
    return `Timeframe${this.toString()}`;
  }
  [equalsSymbol](other) {
    if (!(other instanceof _Timeframe)) {
      return false;
    }
    return this.equals(other);
  }
  /**
  * Merges the values, updating the highest sequence numbers.
  * @param timeframes
  */
  static merge(...timeframes) {
    const result = new _Timeframe();
    for (const timeframe of timeframes) {
      for (const [hex, entry] of timeframe._frames) {
        const currentEntry = result._frames.get(hex);
        if (currentEntry === void 0 || entry.seq > currentEntry.seq) {
          result._frames.set(hex, entry);
        }
      }
    }
    return result;
  }
  /**
  * Compares two timeframes and returns an array of frames from the first timeframe where the sequence number
  * is greater than the associated sequence number from the second timeframe.
  */
  static dependencies(tf1, tf2) {
    const result = new _Timeframe();
    for (const [hex, entry] of tf1._frames) {
      const otherEntry = tf2._frames.get(hex);
      if (otherEntry === void 0 || otherEntry.seq < entry.seq) {
        result._frames.set(hex, entry);
      }
    }
    return result;
  }
};
export {
  Timeframe
};
//# sourceMappingURL=index.mjs.map
