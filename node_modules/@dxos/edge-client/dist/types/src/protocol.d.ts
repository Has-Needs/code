import { buf } from '@dxos/protocols/buf';
import { type Message, type PeerSchema } from '@dxos/protocols/buf/dxos/edge/messenger_pb';
export type PeerData = buf.MessageInitShape<typeof PeerSchema>;
export declare const getTypename: (typeName: string) => string;
/**
 * NOTE: The type registry should be extended with all message types.
 */
export declare class Protocol {
    private readonly _typeRegistry;
    constructor(types: buf.DescMessage[]);
    get typeRegistry(): buf.Registry;
    toJson(message: Message): any;
    /**
     * Return the payload with the given type.
     */
    getPayload<Desc extends buf.DescMessage>(message: Message, type: Desc): buf.MessageShape<Desc>;
    /**
     * Get the payload type.
     */
    getPayloadType(message: Message): string | undefined;
    /**
     * Create a packed message.
     */
    createMessage<Desc extends buf.DescMessage>(type: Desc, { source, target, payload, serviceId, }: {
        source?: PeerData;
        target?: PeerData[];
        payload?: buf.MessageInitShape<Desc>;
        serviceId?: string;
    }): Message;
}
/**
 * Convert websocket data to Uint8Array.
 */
export declare const toUint8Array: (data: any) => Promise<Uint8Array>;
//# sourceMappingURL=protocol.d.ts.map