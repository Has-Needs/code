import { createRequire } from 'node:module';const require = createRequire(import.meta.url);

// packages/core/mesh/edge-client/src/edge-ws-muxer.ts
import { Trigger } from "@dxos/async";
import { log } from "@dxos/log";
import { buf as buf2 } from "@dxos/protocols/buf";
import { MessageSchema as MessageSchema2 } from "@dxos/protocols/buf/dxos/edge/messenger_pb";

// packages/core/mesh/edge-client/src/defs.ts
import { bufWkt as bufWkt2 } from "@dxos/protocols/buf";
import { SwarmRequestSchema, SwarmResponseSchema, TextMessageSchema } from "@dxos/protocols/buf/dxos/edge/messenger_pb";

// packages/core/mesh/edge-client/src/protocol.ts
import { invariant } from "@dxos/invariant";
import { buf, bufWkt } from "@dxos/protocols/buf";
import { MessageSchema } from "@dxos/protocols/buf/dxos/edge/messenger_pb";
import { bufferToArray } from "@dxos/util";
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/core/mesh/edge-client/src/protocol.ts";
var getTypename = (typeName) => `type.googleapis.com/${typeName}`;
var Protocol = class {
  constructor(types) {
    this._typeRegistry = buf.createRegistry(...types);
  }
  get typeRegistry() {
    return this._typeRegistry;
  }
  toJson(message) {
    try {
      return buf.toJson(MessageSchema, message, {
        registry: this.typeRegistry
      });
    } catch (err) {
      return {
        type: this.getPayloadType(message)
      };
    }
  }
  /**
  * Return the payload with the given type.
  */
  getPayload(message, type) {
    invariant(message.payload, void 0, {
      F: __dxlog_file,
      L: 40,
      S: this,
      A: [
        "message.payload",
        ""
      ]
    });
    const payloadTypename = this.getPayloadType(message);
    if (type && type.typeName !== payloadTypename) {
      throw new Error(`Unexpected payload type: ${payloadTypename}; expected ${type.typeName}`);
    }
    invariant(bufWkt.anyIs(message.payload, type), `Unexpected payload type: ${payloadTypename}}`, {
      F: __dxlog_file,
      L: 46,
      S: this,
      A: [
        "bufWkt.anyIs(message.payload, type)",
        "`Unexpected payload type: ${payloadTypename}}`"
      ]
    });
    const payload = bufWkt.anyUnpack(message.payload, this.typeRegistry);
    invariant(payload, `Empty payload: ${payloadTypename}}`, {
      F: __dxlog_file,
      L: 48,
      S: this,
      A: [
        "payload",
        "`Empty payload: ${payloadTypename}}`"
      ]
    });
    return payload;
  }
  /**
  * Get the payload type.
  */
  getPayloadType(message) {
    if (!message.payload) {
      return void 0;
    }
    const [, type] = message.payload.typeUrl.split("/");
    return type;
  }
  /**
  * Create a packed message.
  */
  createMessage(type, { source, target, payload, serviceId }) {
    return buf.create(MessageSchema, {
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      source,
      target,
      serviceId,
      payload: payload ? bufWkt.anyPack(type, buf.create(type, payload)) : void 0
    });
  }
};
var toUint8Array = async (data) => {
  if (data instanceof Buffer) {
    return bufferToArray(data);
  }
  if (data instanceof Blob) {
    return new Uint8Array(await data.arrayBuffer());
  }
  throw new Error(`Unexpected datatype: ${data}`);
};

// packages/core/mesh/edge-client/src/defs.ts
var protocol = new Protocol([
  SwarmRequestSchema,
  SwarmResponseSchema,
  TextMessageSchema,
  bufWkt2.AnySchema
]);

// packages/core/mesh/edge-client/src/edge-ws-muxer.ts
var __dxlog_file2 = "/home/runner/work/dxos/dxos/packages/core/mesh/edge-client/src/edge-ws-muxer.ts";
var FLAG_SEGMENT_SEQ = 1;
var FLAG_SEGMENT_SEQ_TERMINATED = 1 << 1;
var CLOUDFLARE_MESSAGE_MAX_BYTES = 1e3 * 1e3;
var CLOUDFLARE_RPC_MAX_BYTES = 32 * 1e3 * 1e3;
var MAX_CHUNK_LENGTH = 16384;
var MAX_BUFFERED_AMOUNT = CLOUDFLARE_MESSAGE_MAX_BYTES;
var BUFFER_FULL_BACKOFF_TIMEOUT = 100;
var WebSocketMuxer = class {
  constructor(_ws, config) {
    this._ws = _ws;
    this._inMessageAccumulator = /* @__PURE__ */ new Map();
    this._outMessageChunks = /* @__PURE__ */ new Map();
    this._outMessageChannelByService = /* @__PURE__ */ new Map();
    this._maxChunkLength = config?.maxChunkLength ?? MAX_CHUNK_LENGTH;
  }
  /**
  * Resolves when all the message chunks get enqueued for sending.
  */
  async send(message) {
    const binary = buf2.toBinary(MessageSchema2, message);
    const channelId = this._resolveChannel(message);
    if (channelId == null && binary.byteLength > CLOUDFLARE_MESSAGE_MAX_BYTES || binary.byteLength > CLOUDFLARE_RPC_MAX_BYTES) {
      log.error("Large message dropped", {
        byteLength: binary.byteLength,
        serviceId: message.serviceId,
        payload: protocol.getPayloadType(message),
        channelId
      }, {
        F: __dxlog_file2,
        L: 62,
        S: this,
        C: (f, a) => f(...a)
      });
      return;
    }
    if (channelId == null || binary.length < this._maxChunkLength) {
      const flags = Buffer.from([
        0
      ]);
      this._ws.send(Buffer.concat([
        flags,
        binary
      ]));
      return;
    }
    const terminatorSentTrigger = new Trigger();
    const messageChunks = [];
    for (let i = 0; i < binary.length; i += this._maxChunkLength) {
      const chunk = binary.slice(i, i + this._maxChunkLength);
      const isLastChunk = i + this._maxChunkLength >= binary.length;
      if (isLastChunk) {
        const flags = Buffer.from([
          FLAG_SEGMENT_SEQ | FLAG_SEGMENT_SEQ_TERMINATED,
          channelId
        ]);
        messageChunks.push({
          payload: Buffer.concat([
            flags,
            chunk
          ]),
          trigger: terminatorSentTrigger
        });
      } else {
        const flags = Buffer.from([
          FLAG_SEGMENT_SEQ,
          channelId
        ]);
        messageChunks.push({
          payload: Buffer.concat([
            flags,
            chunk
          ])
        });
      }
    }
    const queuedMessages = this._outMessageChunks.get(channelId);
    if (queuedMessages) {
      queuedMessages.push(...messageChunks);
    } else {
      this._outMessageChunks.set(channelId, messageChunks);
    }
    this._sendChunkedMessages();
    return terminatorSentTrigger.wait();
  }
  receiveData(data) {
    if ((data[0] & FLAG_SEGMENT_SEQ) === 0) {
      return buf2.fromBinary(MessageSchema2, data.slice(1));
    }
    const [flags, channelId, ...payload] = data;
    let chunkAccumulator = this._inMessageAccumulator.get(channelId);
    if (chunkAccumulator) {
      chunkAccumulator.push(Buffer.from(payload));
    } else {
      chunkAccumulator = [
        Buffer.from(payload)
      ];
      this._inMessageAccumulator.set(channelId, chunkAccumulator);
    }
    if ((flags & FLAG_SEGMENT_SEQ_TERMINATED) === 0) {
      return void 0;
    }
    const message = buf2.fromBinary(MessageSchema2, Buffer.concat(chunkAccumulator));
    this._inMessageAccumulator.delete(channelId);
    return message;
  }
  destroy() {
    if (this._sendTimeout) {
      clearTimeout(this._sendTimeout);
      this._sendTimeout = void 0;
    }
    for (const channelChunks of this._outMessageChunks.values()) {
      channelChunks.forEach((chunk) => chunk.trigger?.wake());
    }
    this._outMessageChunks.clear();
    this._inMessageAccumulator.clear();
    this._outMessageChannelByService.clear();
  }
  _sendChunkedMessages() {
    if (this._sendTimeout) {
      return;
    }
    const send = () => {
      if (this._ws.readyState === 2 || this._ws.readyState === 3) {
        log.warn("send called for closed websocket", void 0, {
          F: __dxlog_file2,
          L: 146,
          S: this,
          C: (f, a) => f(...a)
        });
        this._sendTimeout = void 0;
        return;
      }
      let timeout = 0;
      const emptyChannels = [];
      for (const [channelId, messages] of this._outMessageChunks.entries()) {
        if (this._ws.bufferedAmount != null) {
          if (this._ws.bufferedAmount + MAX_CHUNK_LENGTH > MAX_BUFFERED_AMOUNT) {
            timeout = BUFFER_FULL_BACKOFF_TIMEOUT;
            break;
          }
        }
        const nextMessage = messages.shift();
        if (nextMessage) {
          this._ws.send(nextMessage.payload);
          nextMessage.trigger?.wake();
        } else {
          emptyChannels.push(channelId);
        }
      }
      emptyChannels.forEach((channelId) => this._outMessageChunks.delete(channelId));
      if (this._outMessageChunks.size > 0) {
        this._sendTimeout = setTimeout(send, timeout);
      } else {
        this._sendTimeout = void 0;
      }
    };
    this._sendTimeout = setTimeout(send);
  }
  _resolveChannel(message) {
    if (!message.serviceId) {
      return void 0;
    }
    let id = this._outMessageChannelByService.get(message.serviceId);
    if (!id) {
      id = this._outMessageChannelByService.size + 1;
      this._outMessageChannelByService.set(message.serviceId, id);
    }
    return id;
  }
};

export {
  getTypename,
  Protocol,
  toUint8Array,
  protocol,
  CLOUDFLARE_MESSAGE_MAX_BYTES,
  CLOUDFLARE_RPC_MAX_BYTES,
  WebSocketMuxer
};
//# sourceMappingURL=chunk-HGQUUFIJ.mjs.map
