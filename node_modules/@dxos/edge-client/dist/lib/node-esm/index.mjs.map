{
  "version": 3,
  "sources": ["../../../src/index.ts", "../../../src/edge-client.ts", "../../../src/edge-identity.ts", "../../../src/edge-ws-connection.ts", "../../../src/errors.ts", "../../../src/utils.ts", "../../../src/auth.ts", "../../../src/edge-http-client.ts"],
  "sourcesContent": ["//\n// Copyright 2024 DXOS.org\n//\n\nexport * from '@dxos/protocols/buf/dxos/edge/messenger_pb';\n\nexport * from './edge-client';\nexport * from './defs';\nexport * from './protocol';\nexport * from './errors';\nexport * from './auth';\nexport * from './edge-http-client';\nexport * from './edge-identity';\nexport * from './edge-ws-muxer';\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { Trigger, scheduleMicroTask, TriggerState, PersistentLifecycle, Event } from '@dxos/async';\nimport { Resource, type Lifecycle } from '@dxos/context';\nimport { log, logInfo } from '@dxos/log';\nimport { type Message } from '@dxos/protocols/buf/dxos/edge/messenger_pb';\nimport { EdgeStatus } from '@dxos/protocols/proto/dxos/client/services';\n\nimport { protocol } from './defs';\nimport { type EdgeIdentity, handleAuthChallenge } from './edge-identity';\nimport { EdgeWsConnection } from './edge-ws-connection';\nimport { EdgeConnectionClosedError, EdgeIdentityChangedError } from './errors';\nimport { type Protocol } from './protocol';\nimport { getEdgeUrlWithProtocol } from './utils';\n\nconst DEFAULT_TIMEOUT = 10_000;\n\nexport type MessageListener = (message: Message) => void;\nexport type ReconnectListener = () => void;\n\nexport interface EdgeConnection extends Required<Lifecycle> {\n  statusChanged: Event<EdgeStatus>;\n  get info(): any;\n  get identityKey(): string;\n  get peerKey(): string;\n  get isOpen(): boolean;\n  get status(): EdgeStatus;\n  setIdentity(identity: EdgeIdentity): void;\n  onMessage(listener: MessageListener): () => void;\n  onReconnected(listener: ReconnectListener): () => void;\n  send(message: Message): Promise<void>;\n}\n\nexport type MessengerConfig = {\n  socketEndpoint: string;\n  timeout?: number;\n  protocol?: Protocol;\n  disableAuth?: boolean;\n};\n\n/**\n * Messenger client for EDGE:\n *  - While open, uses PersistentLifecycle to keep an open EdgeWsConnection, reconnecting on failures.\n *  - Manages identity and re-create EdgeWsConnection when identity changes.\n *  - Dispatches connection state and message notifications.\n */\nexport class EdgeClient extends Resource implements EdgeConnection {\n  public readonly statusChanged = new Event<EdgeStatus>();\n\n  private readonly _persistentLifecycle = new PersistentLifecycle<EdgeWsConnection>({\n    start: async () => this._connect(),\n    stop: async (state: EdgeWsConnection) => this._disconnect(state),\n  });\n\n  private readonly _messageListeners = new Set<MessageListener>();\n  private readonly _reconnectListeners = new Set<ReconnectListener>();\n  private readonly _baseWsUrl: string;\n  private readonly _baseHttpUrl: string;\n  private _currentConnection?: EdgeWsConnection = undefined;\n  private _ready = new Trigger();\n\n  constructor(\n    private _identity: EdgeIdentity,\n    private readonly _config: MessengerConfig,\n  ) {\n    super();\n    this._baseWsUrl = getEdgeUrlWithProtocol(_config.socketEndpoint, 'ws');\n    this._baseHttpUrl = getEdgeUrlWithProtocol(_config.socketEndpoint, 'http');\n  }\n\n  @logInfo\n  public get info() {\n    return {\n      open: this.isOpen,\n      status: this.status,\n      identity: this._identity.identityKey,\n      device: this._identity.peerKey,\n    };\n  }\n\n  get status(): EdgeStatus {\n    return Boolean(this._currentConnection) && this._ready.state === TriggerState.RESOLVED\n      ? EdgeStatus.CONNECTED\n      : EdgeStatus.NOT_CONNECTED;\n  }\n\n  get identityKey() {\n    return this._identity.identityKey;\n  }\n\n  get peerKey() {\n    return this._identity.peerKey;\n  }\n\n  setIdentity(identity: EdgeIdentity): void {\n    if (identity.identityKey !== this._identity.identityKey || identity.peerKey !== this._identity.peerKey) {\n      log('Edge identity changed', { identity, oldIdentity: this._identity });\n      this._identity = identity;\n      this._closeCurrentConnection(new EdgeIdentityChangedError());\n      void this._persistentLifecycle.scheduleRestart();\n    }\n  }\n\n  public onMessage(listener: MessageListener): () => void {\n    this._messageListeners.add(listener);\n    return () => this._messageListeners.delete(listener);\n  }\n\n  public onReconnected(listener: () => void): () => void {\n    this._reconnectListeners.add(listener);\n    if (this._ready.state === TriggerState.RESOLVED) {\n      // Microtask so that listener is always called asynchronously, no matter the state of the ready trigger\n      // at the moment of registration.\n      scheduleMicroTask(this._ctx, () => {\n        if (this._reconnectListeners.has(listener)) {\n          try {\n            listener();\n          } catch (error) {\n            log.catch(error);\n          }\n        }\n      });\n    }\n    return () => this._reconnectListeners.delete(listener);\n  }\n\n  /**\n   * Open connection to messaging service.\n   */\n  protected override async _open(): Promise<void> {\n    log('opening...', { info: this.info });\n    this._persistentLifecycle.open().catch((err) => {\n      log.warn('Error while opening connection', { err });\n    });\n  }\n\n  /**\n   * Close connection and free resources.\n   */\n  protected override async _close(): Promise<void> {\n    log('closing...', { peerKey: this._identity.peerKey });\n    this._closeCurrentConnection();\n    await this._persistentLifecycle.close();\n  }\n\n  private async _connect(): Promise<EdgeWsConnection | undefined> {\n    if (this._ctx.disposed) {\n      return undefined;\n    }\n\n    const identity = this._identity;\n    const path = `/ws/${identity.identityKey}/${identity.peerKey}`;\n    const protocolHeader = this._config.disableAuth ? undefined : await this._createAuthHeader(path);\n    if (this._identity !== identity) {\n      log('identity changed during auth header request');\n      return undefined;\n    }\n\n    const restartRequired = new Trigger();\n    const url = new URL(path, this._baseWsUrl);\n    log('Opening websocket', { url: url.toString(), protocolHeader });\n    const connection = new EdgeWsConnection(\n      identity,\n      { url, protocolHeader },\n      {\n        onConnected: () => {\n          if (this._isActive(connection)) {\n            this._ready.wake();\n            this._notifyReconnected();\n          } else {\n            log.verbose('connected callback ignored, because connection is not active');\n          }\n        },\n        onRestartRequired: () => {\n          if (this._isActive(connection)) {\n            this._closeCurrentConnection();\n            void this._persistentLifecycle.scheduleRestart();\n          } else {\n            log.verbose('restart requested by inactive connection');\n          }\n          restartRequired.wake();\n        },\n        onMessage: (message) => {\n          if (this._isActive(connection)) {\n            this._notifyMessageReceived(message);\n          } else {\n            log.verbose('ignored a message on inactive connection', {\n              from: message.source,\n              type: message.payload?.typeUrl,\n            });\n          }\n        },\n      },\n    );\n    this._currentConnection = connection;\n\n    await connection.open();\n    // Race with restartRequired so that restart is not blocked by _connect execution.\n    // Wait on ready to attempt a reconnect if it times out.\n    await Promise.race([this._ready.wait({ timeout: this._config.timeout ?? DEFAULT_TIMEOUT }), restartRequired]);\n\n    return connection;\n  }\n\n  private async _disconnect(state: EdgeWsConnection): Promise<void> {\n    await state.close();\n    this.statusChanged.emit(this.status);\n  }\n\n  private _closeCurrentConnection(error: Error = new EdgeConnectionClosedError()): void {\n    this._currentConnection = undefined;\n    this._ready.throw(error);\n    this._ready.reset();\n    this.statusChanged.emit(this.status);\n  }\n\n  private _notifyReconnected(): void {\n    this.statusChanged.emit(this.status);\n    for (const listener of this._reconnectListeners) {\n      try {\n        listener();\n      } catch (err) {\n        log.error('ws reconnect listener failed', { err });\n      }\n    }\n  }\n\n  private _notifyMessageReceived(message: Message): void {\n    for (const listener of this._messageListeners) {\n      try {\n        listener(message);\n      } catch (err) {\n        log.error('ws incoming message processing failed', { err, payload: protocol.getPayloadType(message) });\n      }\n    }\n  }\n\n  /**\n   * Send message.\n   * NOTE: The message is guaranteed to be delivered but the service must respond with a message to confirm processing.\n   */\n  public async send(message: Message): Promise<void> {\n    if (this._ready.state !== TriggerState.RESOLVED) {\n      log('waiting for websocket to become ready');\n      await this._ready.wait({ timeout: this._config.timeout ?? DEFAULT_TIMEOUT });\n    }\n\n    if (!this._currentConnection) {\n      throw new EdgeConnectionClosedError();\n    }\n\n    if (\n      message.source &&\n      (message.source.peerKey !== this._identity.peerKey || message.source.identityKey !== this.identityKey)\n    ) {\n      throw new EdgeIdentityChangedError();\n    }\n\n    this._currentConnection.send(message);\n  }\n\n  private async _createAuthHeader(path: string): Promise<string | undefined> {\n    const httpUrl = new URL(path, this._baseHttpUrl);\n    httpUrl.protocol = getEdgeUrlWithProtocol(this._baseWsUrl.toString(), 'http');\n    const response = await fetch(httpUrl, { method: 'GET' });\n    if (response.status === 401) {\n      return encodePresentationWsAuthHeader(await handleAuthChallenge(response, this._identity));\n    } else {\n      log.warn('no auth challenge from edge', { status: response.status, statusText: response.statusText });\n      return undefined;\n    }\n  }\n\n  private _isActive = (connection: EdgeWsConnection) => connection === this._currentConnection;\n}\n\nconst encodePresentationWsAuthHeader = (encodedPresentation: Uint8Array): string => {\n  // = and / characters are not allowed in the WebSocket subprotocol header.\n  const encodedToken = Buffer.from(encodedPresentation).toString('base64').replace(/=*$/, '').replaceAll('/', '|');\n  return `base64url.bearer.authorization.dxos.org.${encodedToken}`;\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { invariant } from '@dxos/invariant';\nimport { schema } from '@dxos/protocols/proto';\nimport { type Presentation } from '@dxos/protocols/proto/dxos/halo/credentials';\n\nexport interface EdgeIdentity {\n  peerKey: string;\n  identityKey: string;\n  /**\n   * Returns credential presentation issued by the identity key.\n   * Presentation must have the provided challenge.\n   * Presentation may include ServiceAccess credentials.\n   */\n  presentCredentials({ challenge }: { challenge: Uint8Array }): Promise<Presentation>;\n}\n\nexport const handleAuthChallenge = async (failedResponse: Response, identity: EdgeIdentity): Promise<Uint8Array> => {\n  invariant(failedResponse.status === 401);\n\n  const headerValue = failedResponse.headers.get('Www-Authenticate');\n  invariant(headerValue?.startsWith('VerifiablePresentation challenge='));\n\n  const challenge = headerValue?.slice('VerifiablePresentation challenge='.length);\n  invariant(challenge);\n\n  const presentation = await identity.presentCredentials({ challenge: Buffer.from(challenge, 'base64') });\n  return schema.getCodecForType('dxos.halo.credentials.Presentation').encode(presentation);\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport WebSocket from 'isomorphic-ws';\n\nimport { scheduleTask, scheduleTaskInterval } from '@dxos/async';\nimport { Context, Resource } from '@dxos/context';\nimport { invariant } from '@dxos/invariant';\nimport { log, logInfo } from '@dxos/log';\nimport { EdgeWebsocketProtocol } from '@dxos/protocols';\nimport { buf } from '@dxos/protocols/buf';\nimport { MessageSchema, type Message } from '@dxos/protocols/buf/dxos/edge/messenger_pb';\n\nimport { protocol } from './defs';\nimport { type EdgeIdentity } from './edge-identity';\nimport { CLOUDFLARE_MESSAGE_MAX_BYTES, WebSocketMuxer } from './edge-ws-muxer';\nimport { toUint8Array } from './protocol';\n\nconst SIGNAL_KEEPALIVE_INTERVAL = 4_000;\nconst SIGNAL_KEEPALIVE_TIMEOUT = 12_000;\n\nexport type EdgeWsConnectionCallbacks = {\n  onConnected: () => void;\n  onMessage: (message: Message) => void;\n  onRestartRequired: () => void;\n};\n\nexport class EdgeWsConnection extends Resource {\n  private _inactivityTimeoutCtx: Context | undefined;\n  private _ws: WebSocket | undefined;\n  private _wsMuxer: WebSocketMuxer | undefined;\n\n  constructor(\n    private readonly _identity: EdgeIdentity,\n    private readonly _connectionInfo: { url: URL; protocolHeader?: string },\n    private readonly _callbacks: EdgeWsConnectionCallbacks,\n  ) {\n    super();\n  }\n\n  @logInfo\n  public get info() {\n    return {\n      open: this.isOpen,\n      identity: this._identity.identityKey,\n      device: this._identity.peerKey,\n    };\n  }\n\n  public send(message: Message): void {\n    invariant(this._ws);\n    invariant(this._wsMuxer);\n    log('sending...', { peerKey: this._identity.peerKey, payload: protocol.getPayloadType(message) });\n    if (this._ws?.protocol.includes(EdgeWebsocketProtocol.V0)) {\n      const binary = buf.toBinary(MessageSchema, message);\n      if (binary.length > CLOUDFLARE_MESSAGE_MAX_BYTES) {\n        log.error('Message dropped because it was too large (>1MB).', {\n          byteLength: binary.byteLength,\n          serviceId: message.serviceId,\n          payload: protocol.getPayloadType(message),\n        });\n        return;\n      }\n      this._ws.send(binary);\n    } else {\n      this._wsMuxer.send(message).catch((e) => log.catch(e));\n    }\n  }\n\n  protected override async _open(): Promise<void> {\n    const baseProtocols = [...Object.values(EdgeWebsocketProtocol)];\n    this._ws = new WebSocket(\n      this._connectionInfo.url.toString(),\n      this._connectionInfo.protocolHeader\n        ? [...baseProtocols, this._connectionInfo.protocolHeader]\n        : [...baseProtocols],\n    );\n    const muxer = new WebSocketMuxer(this._ws);\n    this._wsMuxer = muxer;\n\n    this._ws.onopen = () => {\n      if (this.isOpen) {\n        log('connected');\n        this._callbacks.onConnected();\n        this._scheduleHeartbeats();\n      } else {\n        log.verbose('connected after becoming inactive', { currentIdentity: this._identity });\n      }\n    };\n    this._ws.onclose = (event) => {\n      if (this.isOpen) {\n        log.warn('disconnected while being open', { code: event.code, reason: event.reason });\n        this._callbacks.onRestartRequired();\n        muxer.destroy();\n      }\n    };\n    this._ws.onerror = (event) => {\n      if (this.isOpen) {\n        log.warn('edge connection socket error', { error: event.error, info: event.message });\n        this._callbacks.onRestartRequired();\n      } else {\n        log.verbose('error ignored on closed connection', { error: event.error });\n      }\n    };\n    /**\n     * https://developer.mozilla.org/en-US/docs/Web/API/MessageEvent/data\n     */\n    this._ws.onmessage = async (event) => {\n      if (!this.isOpen) {\n        log.verbose('message ignored on closed connection', { event: event.type });\n        return;\n      }\n      if (event.data === '__pong__') {\n        this._rescheduleHeartbeatTimeout();\n        return;\n      }\n      const bytes = await toUint8Array(event.data);\n      if (!this.isOpen) {\n        return;\n      }\n\n      const message = this._ws?.protocol?.includes(EdgeWebsocketProtocol.V0)\n        ? buf.fromBinary(MessageSchema, bytes)\n        : muxer.receiveData(bytes);\n\n      if (message) {\n        log('received', { from: message.source, payload: protocol.getPayloadType(message) });\n        this._callbacks.onMessage(message);\n      }\n    };\n  }\n\n  protected override async _close(): Promise<void> {\n    void this._inactivityTimeoutCtx?.dispose().catch(() => {});\n\n    try {\n      this._ws?.close();\n      this._ws = undefined;\n      this._wsMuxer?.destroy();\n      this._wsMuxer = undefined;\n    } catch (err) {\n      if (err instanceof Error && err.message.includes('WebSocket is closed before the connection is established.')) {\n        return;\n      }\n      log.warn('Error closing websocket', { err });\n    }\n  }\n\n  private _scheduleHeartbeats(): void {\n    invariant(this._ws);\n    scheduleTaskInterval(\n      this._ctx,\n      async () => {\n        // TODO(mykola): use RFC6455 ping/pong once implemented in the browser?\n        // Cloudflare's worker responds to this `without interrupting hibernation`. https://developers.cloudflare.com/durable-objects/api/websockets/#setwebsocketautoresponse\n        this._ws?.send('__ping__');\n      },\n      SIGNAL_KEEPALIVE_INTERVAL,\n    );\n    this._ws.send('__ping__');\n    this._rescheduleHeartbeatTimeout();\n  }\n\n  private _rescheduleHeartbeatTimeout(): void {\n    if (!this.isOpen) {\n      return;\n    }\n    void this._inactivityTimeoutCtx?.dispose();\n    this._inactivityTimeoutCtx = new Context();\n    scheduleTask(\n      this._inactivityTimeoutCtx,\n      () => {\n        if (this.isOpen) {\n          log.warn('restart due to inactivity timeout');\n          this._callbacks.onRestartRequired();\n        }\n      },\n      SIGNAL_KEEPALIVE_TIMEOUT,\n    );\n  }\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nexport class EdgeConnectionClosedError extends Error {\n  constructor() {\n    super('Edge connection closed.');\n  }\n}\n\nexport class EdgeIdentityChangedError extends Error {\n  constructor() {\n    super('Edge identity changed.');\n  }\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nexport const getEdgeUrlWithProtocol = (baseUrl: string, protocol: 'http' | 'ws') => {\n  const isSecure = baseUrl.startsWith('https') || baseUrl.startsWith('wss');\n  const url = new URL(baseUrl);\n  url.protocol = protocol + (isSecure ? 's' : '');\n  return url.toString();\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { createCredential, signPresentation } from '@dxos/credentials';\nimport { type Signer } from '@dxos/crypto';\nimport { invariant } from '@dxos/invariant';\nimport { Keyring } from '@dxos/keyring';\nimport { PublicKey } from '@dxos/keys';\nimport { type Chain, type Credential } from '@dxos/protocols/proto/dxos/halo/credentials';\n\nimport type { EdgeIdentity } from './edge-identity';\n\n/**\n * Edge identity backed by a device key without a credential chain.\n */\nexport const createDeviceEdgeIdentity = async (signer: Signer, key: PublicKey): Promise<EdgeIdentity> => {\n  return {\n    identityKey: key.toHex(),\n    peerKey: key.toHex(),\n    presentCredentials: async ({ challenge }) => {\n      return signPresentation({\n        presentation: {\n          credentials: [\n            // Verifier requires at least one credential in the presentation to establish the subject.\n            await createCredential({\n              assertion: {\n                '@type': 'dxos.halo.credentials.Auth',\n              },\n              issuer: key,\n              subject: key,\n              signer,\n            }),\n          ],\n        },\n        signer,\n        signerKey: key,\n        nonce: challenge,\n      });\n    },\n  };\n};\n\n/**\n * Edge identity backed by a chain of credentials.\n */\nexport const createChainEdgeIdentity = async (\n  signer: Signer,\n  identityKey: PublicKey,\n  peerKey: PublicKey,\n  chain: Chain | undefined,\n  credentials: Credential[],\n): Promise<EdgeIdentity> => {\n  const credentialsToSign =\n    credentials.length > 0\n      ? credentials\n      : [\n          await createCredential({\n            assertion: {\n              '@type': 'dxos.halo.credentials.Auth',\n            },\n            issuer: identityKey,\n            subject: identityKey,\n            signer,\n            chain,\n            signingKey: peerKey,\n          }),\n        ];\n\n  return {\n    identityKey: identityKey.toHex(),\n    peerKey: peerKey.toHex(),\n    presentCredentials: async ({ challenge }) => {\n      // TODO: make chain required after device invitation flow update release\n      invariant(chain);\n      return signPresentation({\n        presentation: {\n          credentials: credentialsToSign,\n        },\n        signer,\n        nonce: challenge,\n        signerKey: peerKey,\n        chain,\n      });\n    },\n  };\n};\n\n/**\n * Edge identity backed by a random ephemeral key without HALO.\n */\nexport const createEphemeralEdgeIdentity = async (): Promise<EdgeIdentity> => {\n  const keyring = new Keyring();\n  const key = await keyring.createKey();\n  return createDeviceEdgeIdentity(keyring, key);\n};\n\n/**\n * Creates a HALO chain of credentials to act as an edge identity.\n */\nexport const createTestHaloEdgeIdentity = async (\n  signer: Signer,\n  identityKey: PublicKey,\n  deviceKey: PublicKey,\n): Promise<EdgeIdentity> => {\n  const deviceAdmission = await createCredential({\n    assertion: {\n      '@type': 'dxos.halo.credentials.AuthorizedDevice',\n      deviceKey,\n      identityKey,\n    },\n    issuer: identityKey,\n    subject: deviceKey,\n    signer,\n  });\n  return createChainEdgeIdentity(signer, identityKey, deviceKey, { credential: deviceAdmission }, [\n    await createCredential({\n      assertion: {\n        '@type': 'dxos.halo.credentials.Auth',\n      },\n      issuer: identityKey,\n      subject: identityKey,\n      signer,\n    }),\n  ]);\n};\n\nexport const createStubEdgeIdentity = (): EdgeIdentity => {\n  const identityKey = PublicKey.random();\n  const deviceKey = PublicKey.random();\n  return {\n    identityKey: identityKey.toHex(),\n    peerKey: deviceKey.toHex(),\n    presentCredentials: async () => {\n      throw new Error('Stub identity does not support authentication.');\n    },\n  };\n};\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { sleep } from '@dxos/async';\nimport { Context } from '@dxos/context';\nimport { type PublicKey, type SpaceId } from '@dxos/keys';\nimport { log } from '@dxos/log';\nimport {\n  EdgeCallFailedError,\n  type EdgeHttpResponse,\n  type GetNotarizationResponseBody,\n  type PostNotarizationRequestBody,\n  type JoinSpaceRequest,\n  type JoinSpaceResponseBody,\n  EdgeAuthChallengeError,\n  type CreateAgentResponseBody,\n  type CreateAgentRequestBody,\n  type GetAgentStatusResponseBody,\n  type RecoverIdentityRequest,\n  type RecoverIdentityResponseBody,\n  type UploadFunctionRequest,\n  type UploadFunctionResponseBody,\n  type ObjectId,\n  type ExecuteWorkflowResponseBody,\n  type QueueQuery,\n  type QueryResult,\n  type InitiateOAuthFlowRequest,\n  type InitiateOAuthFlowResponse,\n  type CreateSpaceRequest,\n  type CreateSpaceResponseBody,\n} from '@dxos/protocols';\n\nimport { type EdgeIdentity, handleAuthChallenge } from './edge-identity';\nimport { getEdgeUrlWithProtocol } from './utils';\n\nconst DEFAULT_RETRY_TIMEOUT = 1500;\nconst DEFAULT_RETRY_JITTER = 500;\nconst DEFAULT_MAX_RETRIES_COUNT = 3;\n\nexport class EdgeHttpClient {\n  private readonly _baseUrl: string;\n\n  private _edgeIdentity: EdgeIdentity | undefined;\n\n  /**\n   * Auth header is cached until receiving the next 401 from EDGE, at which point it gets refreshed.\n   */\n  private _authHeader: string | undefined;\n\n  constructor(baseUrl: string) {\n    this._baseUrl = getEdgeUrlWithProtocol(baseUrl, 'http');\n    log('created', { url: this._baseUrl });\n  }\n\n  get baseUrl() {\n    return this._baseUrl;\n  }\n\n  setIdentity(identity: EdgeIdentity): void {\n    if (this._edgeIdentity?.identityKey !== identity.identityKey || this._edgeIdentity?.peerKey !== identity.peerKey) {\n      this._edgeIdentity = identity;\n      this._authHeader = undefined;\n    }\n  }\n\n  public createAgent(body: CreateAgentRequestBody, args?: EdgeHttpGetArgs): Promise<CreateAgentResponseBody> {\n    return this._call('/agents/create', { ...args, method: 'POST', body });\n  }\n\n  public getAgentStatus(\n    request: { ownerIdentityKey: PublicKey },\n    args?: EdgeHttpGetArgs,\n  ): Promise<GetAgentStatusResponseBody> {\n    return this._call(`/users/${request.ownerIdentityKey.toHex()}/agent/status`, { ...args, method: 'GET' });\n  }\n\n  public getCredentialsForNotarization(spaceId: SpaceId, args?: EdgeHttpGetArgs): Promise<GetNotarizationResponseBody> {\n    return this._call(`/spaces/${spaceId}/notarization`, { ...args, method: 'GET' });\n  }\n\n  public async notarizeCredentials(\n    spaceId: SpaceId,\n    body: PostNotarizationRequestBody,\n    args?: EdgeHttpGetArgs,\n  ): Promise<void> {\n    await this._call(`/spaces/${spaceId}/notarization`, { ...args, body, method: 'POST' });\n  }\n\n  public async joinSpaceByInvitation(\n    spaceId: SpaceId,\n    body: JoinSpaceRequest,\n    args?: EdgeHttpGetArgs,\n  ): Promise<JoinSpaceResponseBody> {\n    return this._call(`/spaces/${spaceId}/join`, { ...args, body, method: 'POST' });\n  }\n\n  public async recoverIdentity(\n    body: RecoverIdentityRequest,\n    args?: EdgeHttpGetArgs,\n  ): Promise<RecoverIdentityResponseBody> {\n    return this._call('/identity/recover', { ...args, body, method: 'POST' });\n  }\n\n  public async executeWorkflow(\n    spaceId: SpaceId,\n    graphId: ObjectId,\n    input: any,\n    args?: EdgeHttpGetArgs,\n  ): Promise<ExecuteWorkflowResponseBody> {\n    return this._call(`/workflows/${spaceId}/${graphId}`, { ...args, body: input, method: 'POST' });\n  }\n\n  public async uploadFunction(\n    pathParts: { functionId?: string },\n    body: UploadFunctionRequest,\n    args?: EdgeHttpGetArgs,\n  ): Promise<UploadFunctionResponseBody> {\n    const path = ['functions', ...(pathParts.functionId ? [pathParts.functionId] : [])].join('/');\n    return this._call(path, { ...args, body, method: 'PUT' });\n  }\n\n  public async initiateOAuthFlow(\n    body: InitiateOAuthFlowRequest,\n    args?: EdgeHttpGetArgs,\n  ): Promise<InitiateOAuthFlowResponse> {\n    return this._call('/oauth/initiate', { ...args, body, method: 'POST' });\n  }\n\n  public async queryQueue(\n    subspaceTag: string,\n    spaceId: SpaceId,\n    query: QueueQuery,\n    args?: EdgeHttpGetArgs,\n  ): Promise<QueryResult> {\n    const { queueId } = query;\n    const queryParams = new URLSearchParams();\n    if (query.after != null) {\n      queryParams.set('after', query.after);\n    }\n    if (query.before != null) {\n      queryParams.set('before', query.before);\n    }\n    if (query.limit != null) {\n      queryParams.set('limit', query.limit.toString());\n    }\n    if (query.reverse != null) {\n      queryParams.set('reverse', query.reverse.toString());\n    }\n    if (query.objectIds != null) {\n      queryParams.set('objectIds', query.objectIds.join(','));\n    }\n    return this._call(`/spaces/${subspaceTag}/${spaceId}/queue/${queueId}/query?${queryParams.toString()}`, {\n      ...args,\n      method: 'GET',\n    });\n  }\n\n  public async insertIntoQueue(\n    subspaceTag: string,\n    spaceId: SpaceId,\n    queueId: ObjectId,\n    objects: unknown[],\n    args?: EdgeHttpGetArgs,\n  ): Promise<void> {\n    return this._call(`/spaces/${subspaceTag}/${spaceId}/queue/${queueId}`, {\n      ...args,\n      body: { objects },\n      method: 'POST',\n    });\n  }\n\n  async deleteFromQueue(\n    subspaceTag: string,\n    spaceId: SpaceId,\n    queueId: ObjectId,\n    objectIds: ObjectId[],\n    args?: EdgeHttpGetArgs,\n  ): Promise<void> {\n    return this._call(`/spaces/${subspaceTag}/${spaceId}/queue/${queueId}`, {\n      ...args,\n      query: { ids: objectIds.join(',') },\n      method: 'DELETE',\n    });\n  }\n\n  async createSpace(body: CreateSpaceRequest, args?: EdgeHttpGetArgs): Promise<CreateSpaceResponseBody> {\n    return this._call('/spaces/create', { ...args, body, method: 'POST' });\n  }\n\n  private async _call<T>(path: string, args: EdgeHttpCallArgs): Promise<T> {\n    const requestContext = args.context ?? new Context();\n    const shouldRetry = createRetryHandler(args);\n    let url = `${this._baseUrl}${path.startsWith('/') ? path.slice(1) : path}`;\n\n    if (args.query) {\n      const queryParams = new URLSearchParams();\n      for (const [key, value] of Object.entries(args.query)) {\n        queryParams.set(key, value.toString());\n      }\n      url += `?${queryParams.toString()}`;\n    }\n\n    log('call', { method: args.method, path, request: args.body });\n\n    let handledAuth = false;\n    let authHeader = this._authHeader;\n    while (true) {\n      let processingError: EdgeCallFailedError;\n      let retryAfterHeaderValue: number = Number.NaN;\n      try {\n        const request = createRequest(args, authHeader);\n        const response = await fetch(url, request);\n\n        retryAfterHeaderValue = Number(response.headers.get('Retry-After'));\n\n        if (response.ok) {\n          const body = (await response.json()) as EdgeHttpResponse<T>;\n          if (body.success) {\n            return body.data;\n          }\n\n          log('unsuccessful edge response', { path, body });\n\n          if (body.errorData?.type === 'auth_challenge' && typeof body.errorData?.challenge === 'string') {\n            processingError = new EdgeAuthChallengeError(body.errorData.challenge, body.errorData);\n          } else {\n            processingError = EdgeCallFailedError.fromUnsuccessfulResponse(response, body);\n          }\n        } else if (response.status === 401 && !handledAuth) {\n          authHeader = await this._handleUnauthorized(response);\n          handledAuth = true;\n          continue;\n        } else {\n          processingError = EdgeCallFailedError.fromHttpFailure(response);\n        }\n      } catch (error: any) {\n        processingError = EdgeCallFailedError.fromProcessingFailureCause(error);\n      }\n\n      if (processingError.isRetryable && (await shouldRetry(requestContext, retryAfterHeaderValue))) {\n        log('retrying edge request', { path, processingError });\n      } else {\n        throw processingError;\n      }\n    }\n  }\n\n  private async _handleUnauthorized(response: Response): Promise<string> {\n    if (!this._edgeIdentity) {\n      log.warn('edge unauthorized response received before identity was set');\n      throw EdgeCallFailedError.fromHttpFailure(response);\n    }\n    const challenge = await handleAuthChallenge(response, this._edgeIdentity);\n    this._authHeader = encodeAuthHeader(challenge);\n    log('auth header updated');\n    return this._authHeader;\n  }\n}\n\nconst createRetryHandler = (args: EdgeHttpCallArgs) => {\n  if (!args.retry || args.retry.count < 1) {\n    return async () => false;\n  }\n  let retries = 0;\n  const maxRetries = args.retry.count ?? DEFAULT_MAX_RETRIES_COUNT;\n  const baseTimeout = args.retry.timeout ?? DEFAULT_RETRY_TIMEOUT;\n  const jitter = args.retry.jitter ?? DEFAULT_RETRY_JITTER;\n  return async (ctx: Context, retryAfter: number) => {\n    if (++retries > maxRetries || ctx.disposed) {\n      return false;\n    }\n\n    if (retryAfter) {\n      await sleep(retryAfter);\n    } else {\n      const timeout = baseTimeout + Math.random() * jitter;\n      await sleep(timeout);\n    }\n\n    return true;\n  };\n};\n\nexport type RetryConfig = {\n  /**\n   * A number of call retries, not counting the initial request.\n   */\n  count: number;\n  /**\n   * Delay before retries in ms.\n   */\n  timeout?: number;\n  /**\n   * A random amount of time before retrying to help prevent large bursts of requests.\n   */\n  jitter?: number;\n};\n\nexport type EdgeHttpGetArgs = { context?: Context; retry?: RetryConfig };\n\nexport type EdgeHttpPostArgs = { context?: Context; body?: any; retry?: RetryConfig };\n\ntype EdgeHttpCallArgs = {\n  method: string;\n  body?: any;\n  context?: Context;\n  retry?: RetryConfig;\n  query?: Record<string, string>;\n};\n\nconst createRequest = (args: EdgeHttpCallArgs, authHeader: string | undefined): RequestInit => {\n  return {\n    method: args.method,\n    body: args.body && JSON.stringify(args.body),\n    headers: authHeader ? { Authorization: authHeader } : undefined,\n  };\n};\n\nconst encodeAuthHeader = (challenge: Uint8Array) => {\n  const encodedChallenge = Buffer.from(challenge).toString('base64');\n  return `VerifiablePresentation pb;base64,${encodedChallenge}`;\n};\n"],
  "mappings": "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",
  "names": ["Trigger", "scheduleMicroTask", "TriggerState", "PersistentLifecycle", "Event", "Resource", "log", "logInfo", "EdgeStatus", "invariant", "schema", "handleAuthChallenge", "failedResponse", "identity", "status", "headerValue", "headers", "get", "startsWith", "challenge", "slice", "length", "presentation", "presentCredentials", "Buffer", "from", "getCodecForType", "encode", "WebSocket", "scheduleTask", "scheduleTaskInterval", "Context", "Resource", "invariant", "log", "logInfo", "EdgeWebsocketProtocol", "buf", "MessageSchema", "SIGNAL_KEEPALIVE_INTERVAL", "SIGNAL_KEEPALIVE_TIMEOUT", "EdgeWsConnection", "Resource", "_identity", "_connectionInfo", "_callbacks", "info", "open", "isOpen", "identity", "identityKey", "device", "peerKey", "send", "message", "invariant", "_ws", "_wsMuxer", "log", "payload", "protocol", "getPayloadType", "includes", "EdgeWebsocketProtocol", "V0", "binary", "buf", "toBinary", "MessageSchema", "length", "CLOUDFLARE_MESSAGE_MAX_BYTES", "error", "byteLength", "serviceId", "catch", "e", "_open", "baseProtocols", "Object", "values", "WebSocket", "url", "toString", "protocolHeader", "muxer", "WebSocketMuxer", "onopen", "onConnected", "_scheduleHeartbeats", "verbose", "currentIdentity", "onclose", "event", "warn", "code", "reason", "onRestartRequired", "destroy", "onerror", "onmessage", "type", "data", "_rescheduleHeartbeatTimeout", "bytes", "toUint8Array", "fromBinary", "receiveData", "from", "source", "onMessage", "_close", "_inactivityTimeoutCtx", "dispose", "close", "undefined", "err", "Error", "scheduleTaskInterval", "_ctx", "Context", "scheduleTask", "EdgeConnectionClosedError", "Error", "EdgeIdentityChangedError", "getEdgeUrlWithProtocol", "baseUrl", "protocol", "isSecure", "startsWith", "url", "URL", "toString", "DEFAULT_TIMEOUT", "EdgeClient", "Resource", "_identity", "_config", "statusChanged", "Event", "_persistentLifecycle", "PersistentLifecycle", "start", "_connect", "stop", "state", "_disconnect", "_messageListeners", "Set", "_reconnectListeners", "_currentConnection", "undefined", "_ready", "Trigger", "_isActive", "connection", "_baseWsUrl", "getEdgeUrlWithProtocol", "socketEndpoint", "_baseHttpUrl", "info", "open", "isOpen", "status", "identity", "identityKey", "device", "peerKey", "Boolean", "TriggerState", "RESOLVED", "EdgeStatus", "CONNECTED", "NOT_CONNECTED", "setIdentity", "log", "oldIdentity", "_closeCurrentConnection", "EdgeIdentityChangedError", "scheduleRestart", "onMessage", "listener", "add", "delete", "onReconnected", "scheduleMicroTask", "_ctx", "has", "error", "catch", "_open", "err", "warn", "_close", "close", "disposed", "path", "protocolHeader", "disableAuth", "_createAuthHeader", "restartRequired", "url", "URL", "toString", "EdgeWsConnection", "onConnected", "wake", "_notifyReconnected", "verbose", "onRestartRequired", "message", "_notifyMessageReceived", "from", "source", "type", "payload", "typeUrl", "Promise", "race", "wait", "timeout", "emit", "EdgeConnectionClosedError", "throw", "reset", "protocol", "getPayloadType", "send", "httpUrl", "response", "fetch", "method", "encodePresentationWsAuthHeader", "handleAuthChallenge", "statusText", "encodedPresentation", "encodedToken", "Buffer", "replace", "replaceAll", "createCredential", "signPresentation", "invariant", "Keyring", "PublicKey", "createDeviceEdgeIdentity", "signer", "key", "identityKey", "toHex", "peerKey", "presentCredentials", "challenge", "presentation", "credentials", "assertion", "issuer", "subject", "signerKey", "nonce", "createChainEdgeIdentity", "chain", "credentialsToSign", "length", "signingKey", "createEphemeralEdgeIdentity", "keyring", "createKey", "createTestHaloEdgeIdentity", "deviceKey", "deviceAdmission", "credential", "createStubEdgeIdentity", "random", "Error", "sleep", "Context", "log", "EdgeCallFailedError", "EdgeAuthChallengeError", "DEFAULT_RETRY_TIMEOUT", "DEFAULT_RETRY_JITTER", "DEFAULT_MAX_RETRIES_COUNT", "EdgeHttpClient", "baseUrl", "_baseUrl", "getEdgeUrlWithProtocol", "log", "url", "setIdentity", "identity", "_edgeIdentity", "identityKey", "peerKey", "_authHeader", "undefined", "createAgent", "body", "args", "_call", "method", "getAgentStatus", "request", "ownerIdentityKey", "toHex", "getCredentialsForNotarization", "spaceId", "notarizeCredentials", "joinSpaceByInvitation", "recoverIdentity", "executeWorkflow", "graphId", "input", "uploadFunction", "pathParts", "path", "functionId", "join", "initiateOAuthFlow", "queryQueue", "subspaceTag", "query", "queueId", "queryParams", "URLSearchParams", "after", "set", "before", "limit", "toString", "reverse", "objectIds", "insertIntoQueue", "objects", "deleteFromQueue", "ids", "createSpace", "requestContext", "context", "Context", "shouldRetry", "createRetryHandler", "startsWith", "slice", "key", "value", "Object", "entries", "handledAuth", "authHeader", "processingError", "retryAfterHeaderValue", "Number", "NaN", "createRequest", "response", "fetch", "headers", "get", "ok", "json", "success", "data", "errorData", "type", "challenge", "EdgeAuthChallengeError", "EdgeCallFailedError", "fromUnsuccessfulResponse", "status", "_handleUnauthorized", "fromHttpFailure", "error", "fromProcessingFailureCause", "isRetryable", "warn", "handleAuthChallenge", "encodeAuthHeader", "retry", "count", "retries", "maxRetries", "baseTimeout", "timeout", "jitter", "ctx", "retryAfter", "disposed", "sleep", "Math", "random", "JSON", "stringify", "Authorization", "encodedChallenge", "Buffer", "from"]
}
