import {
  CLOUDFLARE_MESSAGE_MAX_BYTES,
  CLOUDFLARE_RPC_MAX_BYTES,
  Protocol,
  WebSocketMuxer,
  getTypename,
  protocol,
  toUint8Array
} from "./chunk-VHS3XEIX.mjs";

// packages/core/mesh/edge-client/src/index.ts
export * from "@dxos/protocols/buf/dxos/edge/messenger_pb";

// packages/core/mesh/edge-client/src/edge-client.ts
import { Trigger, scheduleMicroTask, TriggerState, PersistentLifecycle, Event } from "@dxos/async";
import { Resource as Resource2 } from "@dxos/context";
import { log as log2, logInfo as logInfo2 } from "@dxos/log";
import { EdgeStatus } from "@dxos/protocols/proto/dxos/client/services";

// packages/core/mesh/edge-client/src/edge-identity.ts
import { invariant } from "@dxos/invariant";
import { schema } from "@dxos/protocols/proto";
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/core/mesh/edge-client/src/edge-identity.ts";
var handleAuthChallenge = async (failedResponse, identity) => {
  invariant(failedResponse.status === 401, void 0, {
    F: __dxlog_file,
    L: 21,
    S: void 0,
    A: [
      "failedResponse.status === 401",
      ""
    ]
  });
  const headerValue = failedResponse.headers.get("Www-Authenticate");
  invariant(headerValue?.startsWith("VerifiablePresentation challenge="), void 0, {
    F: __dxlog_file,
    L: 24,
    S: void 0,
    A: [
      "headerValue?.startsWith('VerifiablePresentation challenge=')",
      ""
    ]
  });
  const challenge = headerValue?.slice("VerifiablePresentation challenge=".length);
  invariant(challenge, void 0, {
    F: __dxlog_file,
    L: 27,
    S: void 0,
    A: [
      "challenge",
      ""
    ]
  });
  const presentation = await identity.presentCredentials({
    challenge: Buffer.from(challenge, "base64")
  });
  return schema.getCodecForType("dxos.halo.credentials.Presentation").encode(presentation);
};

// packages/core/mesh/edge-client/src/edge-ws-connection.ts
import WebSocket from "isomorphic-ws";
import { scheduleTask, scheduleTaskInterval } from "@dxos/async";
import { Context, Resource } from "@dxos/context";
import { invariant as invariant2 } from "@dxos/invariant";
import { log, logInfo } from "@dxos/log";
import { EdgeWebsocketProtocol } from "@dxos/protocols";
import { buf } from "@dxos/protocols/buf";
import { MessageSchema } from "@dxos/protocols/buf/dxos/edge/messenger_pb";
function _ts_decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file2 = "/home/runner/work/dxos/dxos/packages/core/mesh/edge-client/src/edge-ws-connection.ts";
var SIGNAL_KEEPALIVE_INTERVAL = 4e3;
var SIGNAL_KEEPALIVE_TIMEOUT = 12e3;
var EdgeWsConnection = class extends Resource {
  constructor(_identity, _connectionInfo, _callbacks) {
    super(), this._identity = _identity, this._connectionInfo = _connectionInfo, this._callbacks = _callbacks;
  }
  get info() {
    return {
      open: this.isOpen,
      identity: this._identity.identityKey,
      device: this._identity.peerKey
    };
  }
  send(message) {
    invariant2(this._ws, void 0, {
      F: __dxlog_file2,
      L: 52,
      S: this,
      A: [
        "this._ws",
        ""
      ]
    });
    invariant2(this._wsMuxer, void 0, {
      F: __dxlog_file2,
      L: 53,
      S: this,
      A: [
        "this._wsMuxer",
        ""
      ]
    });
    log("sending...", {
      peerKey: this._identity.peerKey,
      payload: protocol.getPayloadType(message)
    }, {
      F: __dxlog_file2,
      L: 54,
      S: this,
      C: (f, a) => f(...a)
    });
    if (this._ws?.protocol.includes(EdgeWebsocketProtocol.V0)) {
      const binary = buf.toBinary(MessageSchema, message);
      if (binary.length > CLOUDFLARE_MESSAGE_MAX_BYTES) {
        log.error("Message dropped because it was too large (>1MB).", {
          byteLength: binary.byteLength,
          serviceId: message.serviceId,
          payload: protocol.getPayloadType(message)
        }, {
          F: __dxlog_file2,
          L: 58,
          S: this,
          C: (f, a) => f(...a)
        });
        return;
      }
      this._ws.send(binary);
    } else {
      this._wsMuxer.send(message).catch((e) => log.catch(e, void 0, {
        F: __dxlog_file2,
        L: 67,
        S: this,
        C: (f, a) => f(...a)
      }));
    }
  }
  async _open() {
    const baseProtocols = [
      ...Object.values(EdgeWebsocketProtocol)
    ];
    this._ws = new WebSocket(this._connectionInfo.url.toString(), this._connectionInfo.protocolHeader ? [
      ...baseProtocols,
      this._connectionInfo.protocolHeader
    ] : [
      ...baseProtocols
    ]);
    const muxer = new WebSocketMuxer(this._ws);
    this._wsMuxer = muxer;
    this._ws.onopen = () => {
      if (this.isOpen) {
        log("connected", void 0, {
          F: __dxlog_file2,
          L: 84,
          S: this,
          C: (f, a) => f(...a)
        });
        this._callbacks.onConnected();
        this._scheduleHeartbeats();
      } else {
        log.verbose("connected after becoming inactive", {
          currentIdentity: this._identity
        }, {
          F: __dxlog_file2,
          L: 88,
          S: this,
          C: (f, a) => f(...a)
        });
      }
    };
    this._ws.onclose = (event) => {
      if (this.isOpen) {
        log.warn("disconnected while being open", {
          code: event.code,
          reason: event.reason
        }, {
          F: __dxlog_file2,
          L: 93,
          S: this,
          C: (f, a) => f(...a)
        });
        this._callbacks.onRestartRequired();
        muxer.destroy();
      }
    };
    this._ws.onerror = (event) => {
      if (this.isOpen) {
        log.warn("edge connection socket error", {
          error: event.error,
          info: event.message
        }, {
          F: __dxlog_file2,
          L: 100,
          S: this,
          C: (f, a) => f(...a)
        });
        this._callbacks.onRestartRequired();
      } else {
        log.verbose("error ignored on closed connection", {
          error: event.error
        }, {
          F: __dxlog_file2,
          L: 103,
          S: this,
          C: (f, a) => f(...a)
        });
      }
    };
    this._ws.onmessage = async (event) => {
      if (!this.isOpen) {
        log.verbose("message ignored on closed connection", {
          event: event.type
        }, {
          F: __dxlog_file2,
          L: 111,
          S: this,
          C: (f, a) => f(...a)
        });
        return;
      }
      if (event.data === "__pong__") {
        this._rescheduleHeartbeatTimeout();
        return;
      }
      const bytes = await toUint8Array(event.data);
      if (!this.isOpen) {
        return;
      }
      const message = this._ws?.protocol?.includes(EdgeWebsocketProtocol.V0) ? buf.fromBinary(MessageSchema, bytes) : muxer.receiveData(bytes);
      if (message) {
        log("received", {
          from: message.source,
          payload: protocol.getPayloadType(message)
        }, {
          F: __dxlog_file2,
          L: 128,
          S: this,
          C: (f, a) => f(...a)
        });
        this._callbacks.onMessage(message);
      }
    };
  }
  async _close() {
    void this._inactivityTimeoutCtx?.dispose().catch(() => {
    });
    try {
      this._ws?.close();
      this._ws = void 0;
      this._wsMuxer?.destroy();
      this._wsMuxer = void 0;
    } catch (err) {
      if (err instanceof Error && err.message.includes("WebSocket is closed before the connection is established.")) {
        return;
      }
      log.warn("Error closing websocket", {
        err
      }, {
        F: __dxlog_file2,
        L: 146,
        S: this,
        C: (f, a) => f(...a)
      });
    }
  }
  _scheduleHeartbeats() {
    invariant2(this._ws, void 0, {
      F: __dxlog_file2,
      L: 151,
      S: this,
      A: [
        "this._ws",
        ""
      ]
    });
    scheduleTaskInterval(this._ctx, async () => {
      this._ws?.send("__ping__");
    }, SIGNAL_KEEPALIVE_INTERVAL);
    this._ws.send("__ping__");
    this._rescheduleHeartbeatTimeout();
  }
  _rescheduleHeartbeatTimeout() {
    if (!this.isOpen) {
      return;
    }
    void this._inactivityTimeoutCtx?.dispose();
    this._inactivityTimeoutCtx = new Context(void 0, {
      F: __dxlog_file2,
      L: 170
    });
    scheduleTask(this._inactivityTimeoutCtx, () => {
      if (this.isOpen) {
        log.warn("restart due to inactivity timeout", void 0, {
          F: __dxlog_file2,
          L: 175,
          S: this,
          C: (f, a) => f(...a)
        });
        this._callbacks.onRestartRequired();
      }
    }, SIGNAL_KEEPALIVE_TIMEOUT);
  }
};
_ts_decorate([
  logInfo
], EdgeWsConnection.prototype, "info", null);

// packages/core/mesh/edge-client/src/errors.ts
var EdgeConnectionClosedError = class extends Error {
  constructor() {
    super("Edge connection closed.");
  }
};
var EdgeIdentityChangedError = class extends Error {
  constructor() {
    super("Edge identity changed.");
  }
};

// packages/core/mesh/edge-client/src/utils.ts
var getEdgeUrlWithProtocol = (baseUrl, protocol2) => {
  const isSecure = baseUrl.startsWith("https") || baseUrl.startsWith("wss");
  const url = new URL(baseUrl);
  url.protocol = protocol2 + (isSecure ? "s" : "");
  return url.toString();
};

// packages/core/mesh/edge-client/src/edge-client.ts
function _ts_decorate2(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file3 = "/home/runner/work/dxos/dxos/packages/core/mesh/edge-client/src/edge-client.ts";
var DEFAULT_TIMEOUT = 1e4;
var EdgeClient = class extends Resource2 {
  constructor(_identity, _config) {
    super(), this._identity = _identity, this._config = _config, this.statusChanged = new Event(), this._persistentLifecycle = new PersistentLifecycle({
      start: async () => this._connect(),
      stop: async (state) => this._disconnect(state)
    }), this._messageListeners = /* @__PURE__ */ new Set(), this._reconnectListeners = /* @__PURE__ */ new Set(), this._currentConnection = void 0, this._ready = new Trigger(), this._isActive = (connection) => connection === this._currentConnection;
    this._baseWsUrl = getEdgeUrlWithProtocol(_config.socketEndpoint, "ws");
    this._baseHttpUrl = getEdgeUrlWithProtocol(_config.socketEndpoint, "http");
  }
  get info() {
    return {
      open: this.isOpen,
      status: this.status,
      identity: this._identity.identityKey,
      device: this._identity.peerKey
    };
  }
  get status() {
    return Boolean(this._currentConnection) && this._ready.state === TriggerState.RESOLVED ? EdgeStatus.CONNECTED : EdgeStatus.NOT_CONNECTED;
  }
  get identityKey() {
    return this._identity.identityKey;
  }
  get peerKey() {
    return this._identity.peerKey;
  }
  setIdentity(identity) {
    if (identity.identityKey !== this._identity.identityKey || identity.peerKey !== this._identity.peerKey) {
      log2("Edge identity changed", {
        identity,
        oldIdentity: this._identity
      }, {
        F: __dxlog_file3,
        L: 99,
        S: this,
        C: (f, a) => f(...a)
      });
      this._identity = identity;
      this._closeCurrentConnection(new EdgeIdentityChangedError());
      void this._persistentLifecycle.scheduleRestart();
    }
  }
  onMessage(listener) {
    this._messageListeners.add(listener);
    return () => this._messageListeners.delete(listener);
  }
  onReconnected(listener) {
    this._reconnectListeners.add(listener);
    if (this._ready.state === TriggerState.RESOLVED) {
      scheduleMicroTask(this._ctx, () => {
        if (this._reconnectListeners.has(listener)) {
          try {
            listener();
          } catch (error) {
            log2.catch(error, void 0, {
              F: __dxlog_file3,
              L: 121,
              S: this,
              C: (f, a) => f(...a)
            });
          }
        }
      });
    }
    return () => this._reconnectListeners.delete(listener);
  }
  /**
  * Open connection to messaging service.
  */
  async _open() {
    log2("opening...", {
      info: this.info
    }, {
      F: __dxlog_file3,
      L: 133,
      S: this,
      C: (f, a) => f(...a)
    });
    this._persistentLifecycle.open().catch((err) => {
      log2.warn("Error while opening connection", {
        err
      }, {
        F: __dxlog_file3,
        L: 135,
        S: this,
        C: (f, a) => f(...a)
      });
    });
  }
  /**
  * Close connection and free resources.
  */
  async _close() {
    log2("closing...", {
      peerKey: this._identity.peerKey
    }, {
      F: __dxlog_file3,
      L: 143,
      S: this,
      C: (f, a) => f(...a)
    });
    this._closeCurrentConnection();
    await this._persistentLifecycle.close();
  }
  async _connect() {
    if (this._ctx.disposed) {
      return void 0;
    }
    const identity = this._identity;
    const path = `/ws/${identity.identityKey}/${identity.peerKey}`;
    const protocolHeader = this._config.disableAuth ? void 0 : await this._createAuthHeader(path);
    if (this._identity !== identity) {
      log2("identity changed during auth header request", void 0, {
        F: __dxlog_file3,
        L: 157,
        S: this,
        C: (f, a) => f(...a)
      });
      return void 0;
    }
    const restartRequired = new Trigger();
    const url = new URL(path, this._baseWsUrl);
    log2("Opening websocket", {
      url: url.toString(),
      protocolHeader
    }, {
      F: __dxlog_file3,
      L: 163,
      S: this,
      C: (f, a) => f(...a)
    });
    const connection = new EdgeWsConnection(identity, {
      url,
      protocolHeader
    }, {
      onConnected: () => {
        if (this._isActive(connection)) {
          this._ready.wake();
          this._notifyReconnected();
        } else {
          log2.verbose("connected callback ignored, because connection is not active", void 0, {
            F: __dxlog_file3,
            L: 173,
            S: this,
            C: (f, a) => f(...a)
          });
        }
      },
      onRestartRequired: () => {
        if (this._isActive(connection)) {
          this._closeCurrentConnection();
          void this._persistentLifecycle.scheduleRestart();
        } else {
          log2.verbose("restart requested by inactive connection", void 0, {
            F: __dxlog_file3,
            L: 181,
            S: this,
            C: (f, a) => f(...a)
          });
        }
        restartRequired.wake();
      },
      onMessage: (message) => {
        if (this._isActive(connection)) {
          this._notifyMessageReceived(message);
        } else {
          log2.verbose("ignored a message on inactive connection", {
            from: message.source,
            type: message.payload?.typeUrl
          }, {
            F: __dxlog_file3,
            L: 189,
            S: this,
            C: (f, a) => f(...a)
          });
        }
      }
    });
    this._currentConnection = connection;
    await connection.open();
    await Promise.race([
      this._ready.wait({
        timeout: this._config.timeout ?? DEFAULT_TIMEOUT
      }),
      restartRequired
    ]);
    return connection;
  }
  async _disconnect(state) {
    await state.close();
    this.statusChanged.emit(this.status);
  }
  _closeCurrentConnection(error = new EdgeConnectionClosedError()) {
    this._currentConnection = void 0;
    this._ready.throw(error);
    this._ready.reset();
    this.statusChanged.emit(this.status);
  }
  _notifyReconnected() {
    this.statusChanged.emit(this.status);
    for (const listener of this._reconnectListeners) {
      try {
        listener();
      } catch (err) {
        log2.error("ws reconnect listener failed", {
          err
        }, {
          F: __dxlog_file3,
          L: 225,
          S: this,
          C: (f, a) => f(...a)
        });
      }
    }
  }
  _notifyMessageReceived(message) {
    for (const listener of this._messageListeners) {
      try {
        listener(message);
      } catch (err) {
        log2.error("ws incoming message processing failed", {
          err,
          payload: protocol.getPayloadType(message)
        }, {
          F: __dxlog_file3,
          L: 235,
          S: this,
          C: (f, a) => f(...a)
        });
      }
    }
  }
  /**
  * Send message.
  * NOTE: The message is guaranteed to be delivered but the service must respond with a message to confirm processing.
  */
  async send(message) {
    if (this._ready.state !== TriggerState.RESOLVED) {
      log2("waiting for websocket to become ready", void 0, {
        F: __dxlog_file3,
        L: 246,
        S: this,
        C: (f, a) => f(...a)
      });
      await this._ready.wait({
        timeout: this._config.timeout ?? DEFAULT_TIMEOUT
      });
    }
    if (!this._currentConnection) {
      throw new EdgeConnectionClosedError();
    }
    if (message.source && (message.source.peerKey !== this._identity.peerKey || message.source.identityKey !== this.identityKey)) {
      throw new EdgeIdentityChangedError();
    }
    this._currentConnection.send(message);
  }
  async _createAuthHeader(path) {
    const httpUrl = new URL(path, this._baseHttpUrl);
    httpUrl.protocol = getEdgeUrlWithProtocol(this._baseWsUrl.toString(), "http");
    const response = await fetch(httpUrl, {
      method: "GET"
    });
    if (response.status === 401) {
      return encodePresentationWsAuthHeader(await handleAuthChallenge(response, this._identity));
    } else {
      log2.warn("no auth challenge from edge", {
        status: response.status,
        statusText: response.statusText
      }, {
        F: __dxlog_file3,
        L: 271,
        S: this,
        C: (f, a) => f(...a)
      });
      return void 0;
    }
  }
};
_ts_decorate2([
  logInfo2
], EdgeClient.prototype, "info", null);
var encodePresentationWsAuthHeader = (encodedPresentation) => {
  const encodedToken = Buffer.from(encodedPresentation).toString("base64").replace(/=*$/, "").replaceAll("/", "|");
  return `base64url.bearer.authorization.dxos.org.${encodedToken}`;
};

// packages/core/mesh/edge-client/src/auth.ts
import { createCredential, signPresentation } from "@dxos/credentials";
import { invariant as invariant3 } from "@dxos/invariant";
import { Keyring } from "@dxos/keyring";
import { PublicKey } from "@dxos/keys";
var __dxlog_file4 = "/home/runner/work/dxos/dxos/packages/core/mesh/edge-client/src/auth.ts";
var createDeviceEdgeIdentity = async (signer, key) => {
  return {
    identityKey: key.toHex(),
    peerKey: key.toHex(),
    presentCredentials: async ({ challenge }) => {
      return signPresentation({
        presentation: {
          credentials: [
            // Verifier requires at least one credential in the presentation to establish the subject.
            await createCredential({
              assertion: {
                "@type": "dxos.halo.credentials.Auth"
              },
              issuer: key,
              subject: key,
              signer
            })
          ]
        },
        signer,
        signerKey: key,
        nonce: challenge
      });
    }
  };
};
var createChainEdgeIdentity = async (signer, identityKey, peerKey, chain, credentials) => {
  const credentialsToSign = credentials.length > 0 ? credentials : [
    await createCredential({
      assertion: {
        "@type": "dxos.halo.credentials.Auth"
      },
      issuer: identityKey,
      subject: identityKey,
      signer,
      chain,
      signingKey: peerKey
    })
  ];
  return {
    identityKey: identityKey.toHex(),
    peerKey: peerKey.toHex(),
    presentCredentials: async ({ challenge }) => {
      invariant3(chain, void 0, {
        F: __dxlog_file4,
        L: 75,
        S: void 0,
        A: [
          "chain",
          ""
        ]
      });
      return signPresentation({
        presentation: {
          credentials: credentialsToSign
        },
        signer,
        nonce: challenge,
        signerKey: peerKey,
        chain
      });
    }
  };
};
var createEphemeralEdgeIdentity = async () => {
  const keyring = new Keyring();
  const key = await keyring.createKey();
  return createDeviceEdgeIdentity(keyring, key);
};
var createTestHaloEdgeIdentity = async (signer, identityKey, deviceKey) => {
  const deviceAdmission = await createCredential({
    assertion: {
      "@type": "dxos.halo.credentials.AuthorizedDevice",
      deviceKey,
      identityKey
    },
    issuer: identityKey,
    subject: deviceKey,
    signer
  });
  return createChainEdgeIdentity(signer, identityKey, deviceKey, {
    credential: deviceAdmission
  }, [
    await createCredential({
      assertion: {
        "@type": "dxos.halo.credentials.Auth"
      },
      issuer: identityKey,
      subject: identityKey,
      signer
    })
  ]);
};
var createStubEdgeIdentity = () => {
  const identityKey = PublicKey.random();
  const deviceKey = PublicKey.random();
  return {
    identityKey: identityKey.toHex(),
    peerKey: deviceKey.toHex(),
    presentCredentials: async () => {
      throw new Error("Stub identity does not support authentication.");
    }
  };
};

// packages/core/mesh/edge-client/src/edge-http-client.ts
import { sleep } from "@dxos/async";
import { Context as Context2 } from "@dxos/context";
import { log as log3 } from "@dxos/log";
import { EdgeCallFailedError, EdgeAuthChallengeError } from "@dxos/protocols";
var __dxlog_file5 = "/home/runner/work/dxos/dxos/packages/core/mesh/edge-client/src/edge-http-client.ts";
var DEFAULT_RETRY_TIMEOUT = 1500;
var DEFAULT_RETRY_JITTER = 500;
var DEFAULT_MAX_RETRIES_COUNT = 3;
var EdgeHttpClient = class {
  constructor(baseUrl) {
    this._baseUrl = getEdgeUrlWithProtocol(baseUrl, "http");
    log3("created", {
      url: this._baseUrl
    }, {
      F: __dxlog_file5,
      L: 53,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  get baseUrl() {
    return this._baseUrl;
  }
  setIdentity(identity) {
    if (this._edgeIdentity?.identityKey !== identity.identityKey || this._edgeIdentity?.peerKey !== identity.peerKey) {
      this._edgeIdentity = identity;
      this._authHeader = void 0;
    }
  }
  createAgent(body, args) {
    return this._call("/agents/create", {
      ...args,
      method: "POST",
      body
    });
  }
  getAgentStatus(request, args) {
    return this._call(`/users/${request.ownerIdentityKey.toHex()}/agent/status`, {
      ...args,
      method: "GET"
    });
  }
  getCredentialsForNotarization(spaceId, args) {
    return this._call(`/spaces/${spaceId}/notarization`, {
      ...args,
      method: "GET"
    });
  }
  async notarizeCredentials(spaceId, body, args) {
    await this._call(`/spaces/${spaceId}/notarization`, {
      ...args,
      body,
      method: "POST"
    });
  }
  async joinSpaceByInvitation(spaceId, body, args) {
    return this._call(`/spaces/${spaceId}/join`, {
      ...args,
      body,
      method: "POST"
    });
  }
  async recoverIdentity(body, args) {
    return this._call("/identity/recover", {
      ...args,
      body,
      method: "POST"
    });
  }
  async executeWorkflow(spaceId, graphId, input, args) {
    return this._call(`/workflows/${spaceId}/${graphId}`, {
      ...args,
      body: input,
      method: "POST"
    });
  }
  async uploadFunction(pathParts, body, args) {
    const path = [
      "functions",
      ...pathParts.functionId ? [
        pathParts.functionId
      ] : []
    ].join("/");
    return this._call(path, {
      ...args,
      body,
      method: "PUT"
    });
  }
  async initiateOAuthFlow(body, args) {
    return this._call("/oauth/initiate", {
      ...args,
      body,
      method: "POST"
    });
  }
  async queryQueue(subspaceTag, spaceId, query, args) {
    const { queueId } = query;
    const queryParams = new URLSearchParams();
    if (query.after != null) {
      queryParams.set("after", query.after);
    }
    if (query.before != null) {
      queryParams.set("before", query.before);
    }
    if (query.limit != null) {
      queryParams.set("limit", query.limit.toString());
    }
    if (query.reverse != null) {
      queryParams.set("reverse", query.reverse.toString());
    }
    if (query.objectIds != null) {
      queryParams.set("objectIds", query.objectIds.join(","));
    }
    return this._call(`/spaces/${subspaceTag}/${spaceId}/queue/${queueId}/query?${queryParams.toString()}`, {
      ...args,
      method: "GET"
    });
  }
  async insertIntoQueue(subspaceTag, spaceId, queueId, objects, args) {
    return this._call(`/spaces/${subspaceTag}/${spaceId}/queue/${queueId}`, {
      ...args,
      body: {
        objects
      },
      method: "POST"
    });
  }
  async deleteFromQueue(subspaceTag, spaceId, queueId, objectIds, args) {
    return this._call(`/spaces/${subspaceTag}/${spaceId}/queue/${queueId}`, {
      ...args,
      query: {
        ids: objectIds.join(",")
      },
      method: "DELETE"
    });
  }
  async createSpace(body, args) {
    return this._call("/spaces/create", {
      ...args,
      body,
      method: "POST"
    });
  }
  async _call(path, args) {
    const requestContext = args.context ?? new Context2(void 0, {
      F: __dxlog_file5,
      L: 192
    });
    const shouldRetry = createRetryHandler(args);
    let url = `${this._baseUrl}${path.startsWith("/") ? path.slice(1) : path}`;
    if (args.query) {
      const queryParams = new URLSearchParams();
      for (const [key, value] of Object.entries(args.query)) {
        queryParams.set(key, value.toString());
      }
      url += `?${queryParams.toString()}`;
    }
    log3("call", {
      method: args.method,
      path,
      request: args.body
    }, {
      F: __dxlog_file5,
      L: 204,
      S: this,
      C: (f, a) => f(...a)
    });
    let handledAuth = false;
    let authHeader = this._authHeader;
    while (true) {
      let processingError;
      let retryAfterHeaderValue = Number.NaN;
      try {
        const request = createRequest(args, authHeader);
        const response = await fetch(url, request);
        retryAfterHeaderValue = Number(response.headers.get("Retry-After"));
        if (response.ok) {
          const body = await response.json();
          if (body.success) {
            return body.data;
          }
          log3("unsuccessful edge response", {
            path,
            body
          }, {
            F: __dxlog_file5,
            L: 223,
            S: this,
            C: (f, a) => f(...a)
          });
          if (body.errorData?.type === "auth_challenge" && typeof body.errorData?.challenge === "string") {
            processingError = new EdgeAuthChallengeError(body.errorData.challenge, body.errorData);
          } else {
            processingError = EdgeCallFailedError.fromUnsuccessfulResponse(response, body);
          }
        } else if (response.status === 401 && !handledAuth) {
          authHeader = await this._handleUnauthorized(response);
          handledAuth = true;
          continue;
        } else {
          processingError = EdgeCallFailedError.fromHttpFailure(response);
        }
      } catch (error) {
        processingError = EdgeCallFailedError.fromProcessingFailureCause(error);
      }
      if (processingError.isRetryable && await shouldRetry(requestContext, retryAfterHeaderValue)) {
        log3("retrying edge request", {
          path,
          processingError
        }, {
          F: __dxlog_file5,
          L: 242,
          S: this,
          C: (f, a) => f(...a)
        });
      } else {
        throw processingError;
      }
    }
  }
  async _handleUnauthorized(response) {
    if (!this._edgeIdentity) {
      log3.warn("edge unauthorized response received before identity was set", void 0, {
        F: __dxlog_file5,
        L: 251,
        S: this,
        C: (f, a) => f(...a)
      });
      throw EdgeCallFailedError.fromHttpFailure(response);
    }
    const challenge = await handleAuthChallenge(response, this._edgeIdentity);
    this._authHeader = encodeAuthHeader(challenge);
    log3("auth header updated", void 0, {
      F: __dxlog_file5,
      L: 256,
      S: this,
      C: (f, a) => f(...a)
    });
    return this._authHeader;
  }
};
var createRetryHandler = (args) => {
  if (!args.retry || args.retry.count < 1) {
    return async () => false;
  }
  let retries = 0;
  const maxRetries = args.retry.count ?? DEFAULT_MAX_RETRIES_COUNT;
  const baseTimeout = args.retry.timeout ?? DEFAULT_RETRY_TIMEOUT;
  const jitter = args.retry.jitter ?? DEFAULT_RETRY_JITTER;
  return async (ctx, retryAfter) => {
    if (++retries > maxRetries || ctx.disposed) {
      return false;
    }
    if (retryAfter) {
      await sleep(retryAfter);
    } else {
      const timeout = baseTimeout + Math.random() * jitter;
      await sleep(timeout);
    }
    return true;
  };
};
var createRequest = (args, authHeader) => {
  return {
    method: args.method,
    body: args.body && JSON.stringify(args.body),
    headers: authHeader ? {
      Authorization: authHeader
    } : void 0
  };
};
var encodeAuthHeader = (challenge) => {
  const encodedChallenge = Buffer.from(challenge).toString("base64");
  return `VerifiablePresentation pb;base64,${encodedChallenge}`;
};
export {
  CLOUDFLARE_MESSAGE_MAX_BYTES,
  CLOUDFLARE_RPC_MAX_BYTES,
  EdgeClient,
  EdgeConnectionClosedError,
  EdgeHttpClient,
  EdgeIdentityChangedError,
  Protocol,
  WebSocketMuxer,
  createChainEdgeIdentity,
  createDeviceEdgeIdentity,
  createEphemeralEdgeIdentity,
  createStubEdgeIdentity,
  createTestHaloEdgeIdentity,
  getTypename,
  handleAuthChallenge,
  protocol,
  toUint8Array
};
//# sourceMappingURL=index.mjs.map
