{
  "version": 3,
  "sources": ["../../../src/edge-ws-muxer.ts", "../../../src/defs.ts", "../../../src/protocol.ts"],
  "sourcesContent": ["//\n// Copyright 2025 DXOS.org\n//\n\nimport { Trigger } from '@dxos/async';\nimport { log } from '@dxos/log';\nimport { buf } from '@dxos/protocols/buf';\nimport { MessageSchema, type Message } from '@dxos/protocols/buf/dxos/edge/messenger_pb';\n\nimport { protocol } from './defs';\n\n/**\n * 0000 0001 - message contains a part of segmented message chunk sequence.\n * The next byte defines a channel id and the rest of the message contains a part of Message proto binary.\n * Messages from different channels might interleave.\n * When the flag is NOT set the rest of the message should be interpreted as the valid Message proto binary.\n */\nconst FLAG_SEGMENT_SEQ = 1;\n/**\n * 0000 0010 - message terminates a segmented message chunk sequence.\n * All the chunks accumulated for the channel specified by the second byte can be concatenated\n * and interpreted as a valid Message proto binary.\n */\nconst FLAG_SEGMENT_SEQ_TERMINATED = 1 << 1;\n\n/**\n * https://developers.cloudflare.com/durable-objects/platform/limits/\n */\nexport const CLOUDFLARE_MESSAGE_MAX_BYTES = 1000 * 1000; // 1MB\nexport const CLOUDFLARE_RPC_MAX_BYTES = 32 * 1000 * 1000; // 32MB\n\nconst MAX_CHUNK_LENGTH = 16384;\nconst MAX_BUFFERED_AMOUNT = CLOUDFLARE_MESSAGE_MAX_BYTES;\nconst BUFFER_FULL_BACKOFF_TIMEOUT = 100;\n\nexport class WebSocketMuxer {\n  private readonly _inMessageAccumulator = new Map<number, Buffer[]>();\n  private readonly _outMessageChunks = new Map<number, MessageChunk[]>();\n  private readonly _outMessageChannelByService = new Map<string, number>();\n\n  private _sendTimeout: any | undefined;\n\n  private readonly _maxChunkLength: number;\n\n  constructor(\n    private readonly _ws: WebSocketCompat,\n    config?: { maxChunkLength: number },\n  ) {\n    this._maxChunkLength = config?.maxChunkLength ?? MAX_CHUNK_LENGTH;\n  }\n\n  /**\n   * Resolves when all the message chunks get enqueued for sending.\n   */\n  public async send(message: Message): Promise<void> {\n    const binary = buf.toBinary(MessageSchema, message);\n    const channelId = this._resolveChannel(message);\n    if (\n      (channelId == null && binary.byteLength > CLOUDFLARE_MESSAGE_MAX_BYTES) ||\n      binary.byteLength > CLOUDFLARE_RPC_MAX_BYTES\n    ) {\n      log.error('Large message dropped', {\n        byteLength: binary.byteLength,\n        serviceId: message.serviceId,\n        payload: protocol.getPayloadType(message),\n        channelId,\n      });\n      return;\n    }\n\n    if (channelId == null || binary.length < this._maxChunkLength) {\n      const flags = Buffer.from([0]);\n      this._ws.send(Buffer.concat([flags, binary]));\n      return;\n    }\n\n    const terminatorSentTrigger = new Trigger();\n    const messageChunks: MessageChunk[] = [];\n    for (let i = 0; i < binary.length; i += this._maxChunkLength) {\n      const chunk = binary.slice(i, i + this._maxChunkLength);\n      const isLastChunk = i + this._maxChunkLength >= binary.length;\n      if (isLastChunk) {\n        const flags = Buffer.from([FLAG_SEGMENT_SEQ | FLAG_SEGMENT_SEQ_TERMINATED, channelId]);\n        messageChunks.push({ payload: Buffer.concat([flags, chunk]), trigger: terminatorSentTrigger });\n      } else {\n        const flags = Buffer.from([FLAG_SEGMENT_SEQ, channelId]);\n        messageChunks.push({ payload: Buffer.concat([flags, chunk]) });\n      }\n    }\n\n    const queuedMessages = this._outMessageChunks.get(channelId);\n    if (queuedMessages) {\n      queuedMessages.push(...messageChunks);\n    } else {\n      this._outMessageChunks.set(channelId, messageChunks);\n    }\n\n    this._sendChunkedMessages();\n\n    return terminatorSentTrigger.wait();\n  }\n\n  public receiveData(data: Uint8Array): Message | undefined {\n    if ((data[0] & FLAG_SEGMENT_SEQ) === 0) {\n      return buf.fromBinary(MessageSchema, data.slice(1));\n    }\n\n    const [flags, channelId, ...payload] = data;\n    let chunkAccumulator = this._inMessageAccumulator.get(channelId);\n    if (chunkAccumulator) {\n      chunkAccumulator.push(Buffer.from(payload));\n    } else {\n      chunkAccumulator = [Buffer.from(payload)];\n      this._inMessageAccumulator.set(channelId, chunkAccumulator);\n    }\n\n    if ((flags & FLAG_SEGMENT_SEQ_TERMINATED) === 0) {\n      return undefined;\n    }\n\n    const message = buf.fromBinary(MessageSchema, Buffer.concat(chunkAccumulator));\n    this._inMessageAccumulator.delete(channelId);\n    return message;\n  }\n\n  public destroy(): void {\n    if (this._sendTimeout) {\n      clearTimeout(this._sendTimeout);\n      this._sendTimeout = undefined;\n    }\n    for (const channelChunks of this._outMessageChunks.values()) {\n      channelChunks.forEach((chunk) => chunk.trigger?.wake());\n    }\n    this._outMessageChunks.clear();\n    this._inMessageAccumulator.clear();\n    this._outMessageChannelByService.clear();\n  }\n\n  private _sendChunkedMessages(): void {\n    if (this._sendTimeout) {\n      return;\n    }\n\n    const send = () => {\n      if (this._ws.readyState === WebSocket.CLOSING || this._ws.readyState === WebSocket.CLOSED) {\n        log.warn('send called for closed websocket');\n        this._sendTimeout = undefined;\n        return;\n      }\n\n      let timeout = 0;\n      const emptyChannels: number[] = [];\n      for (const [channelId, messages] of this._outMessageChunks.entries()) {\n        if (this._ws.bufferedAmount != null) {\n          if (this._ws.bufferedAmount + MAX_CHUNK_LENGTH > MAX_BUFFERED_AMOUNT) {\n            timeout = BUFFER_FULL_BACKOFF_TIMEOUT;\n            break;\n          }\n        }\n\n        const nextMessage = messages.shift();\n        if (nextMessage) {\n          this._ws.send(nextMessage.payload);\n          nextMessage.trigger?.wake();\n        } else {\n          emptyChannels.push(channelId);\n        }\n      }\n\n      emptyChannels.forEach((channelId) => this._outMessageChunks.delete(channelId));\n\n      if (this._outMessageChunks.size > 0) {\n        this._sendTimeout = setTimeout(send, timeout);\n      } else {\n        this._sendTimeout = undefined;\n      }\n    };\n    this._sendTimeout = setTimeout(send);\n  }\n\n  private _resolveChannel(message: Message): number | undefined {\n    if (!message.serviceId) {\n      return undefined;\n    }\n    let id = this._outMessageChannelByService.get(message.serviceId);\n    if (!id) {\n      id = this._outMessageChannelByService.size + 1;\n      this._outMessageChannelByService.set(message.serviceId, id);\n    }\n    return id;\n  }\n}\n\ntype WebSocketCompat = {\n  readonly readyState: number;\n  /**\n   * Not available in workerd.\n   */\n  bufferedAmount?: number;\n  send(message: (ArrayBuffer | ArrayBufferView) | string): void;\n};\n\ntype MessageChunk = {\n  payload: Buffer;\n  /**\n   * Wakes when the payload is enqueued by WebSocket.\n   */\n  trigger?: Trigger;\n};\n\n/**\n * To avoid using isomorphic-ws on edge.\n */\nenum WebSocket {\n  CLOSING = 2,\n  CLOSED = 3,\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { bufWkt } from '@dxos/protocols/buf';\nimport { SwarmRequestSchema, SwarmResponseSchema, TextMessageSchema } from '@dxos/protocols/buf/dxos/edge/messenger_pb';\n\nimport { Protocol } from './protocol';\n\nexport const protocol = new Protocol([SwarmRequestSchema, SwarmResponseSchema, TextMessageSchema, bufWkt.AnySchema]);\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { invariant } from '@dxos/invariant';\nimport { buf, bufWkt } from '@dxos/protocols/buf';\nimport { type Message, MessageSchema, type PeerSchema } from '@dxos/protocols/buf/dxos/edge/messenger_pb';\nimport { bufferToArray } from '@dxos/util';\n\nexport type PeerData = buf.MessageInitShape<typeof PeerSchema>;\n\nexport const getTypename = (typeName: string) => `type.googleapis.com/${typeName}`;\n\n/**\n * NOTE: The type registry should be extended with all message types.\n */\nexport class Protocol {\n  private readonly _typeRegistry: buf.Registry;\n\n  constructor(types: buf.DescMessage[]) {\n    this._typeRegistry = buf.createRegistry(...types);\n  }\n\n  get typeRegistry(): buf.Registry {\n    return this._typeRegistry;\n  }\n\n  toJson(message: Message): any {\n    try {\n      return buf.toJson(MessageSchema, message, { registry: this.typeRegistry });\n    } catch (err) {\n      return { type: this.getPayloadType(message) };\n    }\n  }\n\n  /**\n   * Return the payload with the given type.\n   */\n  getPayload<Desc extends buf.DescMessage>(message: Message, type: Desc): buf.MessageShape<Desc> {\n    invariant(message.payload);\n    const payloadTypename = this.getPayloadType(message);\n    if (type && type.typeName !== payloadTypename) {\n      throw new Error(`Unexpected payload type: ${payloadTypename}; expected ${type.typeName}`);\n    }\n\n    invariant(bufWkt.anyIs(message.payload, type), `Unexpected payload type: ${payloadTypename}}`);\n    const payload = bufWkt.anyUnpack(message.payload, this.typeRegistry) as buf.MessageShape<Desc>;\n    invariant(payload, `Empty payload: ${payloadTypename}}`);\n    return payload;\n  }\n\n  /**\n   * Get the payload type.\n   */\n  getPayloadType(message: Message): string | undefined {\n    if (!message.payload) {\n      return undefined;\n    }\n\n    const [, type] = message.payload.typeUrl.split('/');\n    return type;\n  }\n\n  /**\n   * Create a packed message.\n   */\n  createMessage<Desc extends buf.DescMessage>(\n    type: Desc,\n    {\n      source,\n      target,\n      payload,\n      serviceId,\n    }: {\n      source?: PeerData;\n      target?: PeerData[];\n      payload?: buf.MessageInitShape<Desc>;\n      serviceId?: string;\n    },\n  ): Message {\n    return buf.create(MessageSchema, {\n      timestamp: new Date().toISOString(),\n      source,\n      target,\n      serviceId,\n      payload: payload ? bufWkt.anyPack(type, buf.create(type, payload)) : undefined,\n    });\n  }\n}\n\n/**\n * Convert websocket data to Uint8Array.\n */\nexport const toUint8Array = async (data: any): Promise<Uint8Array> => {\n  // Node.\n  if (data instanceof Buffer) {\n    return bufferToArray(data);\n  }\n\n  // Browser.\n  if (data instanceof Blob) {\n    return new Uint8Array(await (data as Blob).arrayBuffer());\n  }\n\n  throw new Error(`Unexpected datatype: ${data}`);\n};\n"],
  "mappings": "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",
  "names": ["Trigger", "log", "buf", "MessageSchema", "bufWkt", "SwarmRequestSchema", "SwarmResponseSchema", "TextMessageSchema", "invariant", "buf", "bufWkt", "MessageSchema", "bufferToArray", "getTypename", "typeName", "Protocol", "types", "_typeRegistry", "createRegistry", "typeRegistry", "toJson", "message", "registry", "err", "type", "getPayloadType", "getPayload", "payload", "payloadTypename", "Error", "anyIs", "anyUnpack", "undefined", "typeUrl", "split", "createMessage", "source", "target", "serviceId", "create", "timestamp", "Date", "toISOString", "anyPack", "toUint8Array", "data", "Buffer", "Blob", "Uint8Array", "arrayBuffer", "protocol", "Protocol", "SwarmRequestSchema", "SwarmResponseSchema", "TextMessageSchema", "bufWkt", "AnySchema", "FLAG_SEGMENT_SEQ", "FLAG_SEGMENT_SEQ_TERMINATED", "CLOUDFLARE_MESSAGE_MAX_BYTES", "CLOUDFLARE_RPC_MAX_BYTES", "MAX_CHUNK_LENGTH", "MAX_BUFFERED_AMOUNT", "BUFFER_FULL_BACKOFF_TIMEOUT", "WebSocketMuxer", "_ws", "config", "_inMessageAccumulator", "Map", "_outMessageChunks", "_outMessageChannelByService", "_maxChunkLength", "maxChunkLength", "send", "message", "binary", "buf", "toBinary", "MessageSchema", "channelId", "_resolveChannel", "byteLength", "log", "error", "serviceId", "payload", "protocol", "getPayloadType", "length", "flags", "Buffer", "from", "concat", "terminatorSentTrigger", "Trigger", "messageChunks", "i", "chunk", "slice", "isLastChunk", "push", "trigger", "queuedMessages", "get", "set", "_sendChunkedMessages", "wait", "receiveData", "data", "fromBinary", "chunkAccumulator", "undefined", "delete", "destroy", "_sendTimeout", "clearTimeout", "channelChunks", "values", "forEach", "wake", "clear", "readyState", "warn", "timeout", "emptyChannels", "messages", "entries", "bufferedAmount", "nextMessage", "shift", "size", "setTimeout", "id"]
}
