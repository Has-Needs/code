"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var chunk_XNHBUTNB_exports = {};
__export(chunk_XNHBUTNB_exports, {
  CLOUDFLARE_MESSAGE_MAX_BYTES: () => CLOUDFLARE_MESSAGE_MAX_BYTES,
  CLOUDFLARE_RPC_MAX_BYTES: () => CLOUDFLARE_RPC_MAX_BYTES,
  Protocol: () => Protocol,
  WebSocketMuxer: () => WebSocketMuxer,
  getTypename: () => getTypename,
  protocol: () => protocol,
  toUint8Array: () => toUint8Array
});
module.exports = __toCommonJS(chunk_XNHBUTNB_exports);
var import_async = require("@dxos/async");
var import_log = require("@dxos/log");
var import_buf = require("@dxos/protocols/buf");
var import_messenger_pb = require("@dxos/protocols/buf/dxos/edge/messenger_pb");
var import_buf2 = require("@dxos/protocols/buf");
var import_messenger_pb2 = require("@dxos/protocols/buf/dxos/edge/messenger_pb");
var import_invariant = require("@dxos/invariant");
var import_buf3 = require("@dxos/protocols/buf");
var import_messenger_pb3 = require("@dxos/protocols/buf/dxos/edge/messenger_pb");
var import_util = require("@dxos/util");
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/core/mesh/edge-client/src/protocol.ts";
var getTypename = (typeName) => `type.googleapis.com/${typeName}`;
var Protocol = class {
  constructor(types) {
    this._typeRegistry = import_buf3.buf.createRegistry(...types);
  }
  get typeRegistry() {
    return this._typeRegistry;
  }
  toJson(message) {
    try {
      return import_buf3.buf.toJson(import_messenger_pb3.MessageSchema, message, {
        registry: this.typeRegistry
      });
    } catch (err) {
      return {
        type: this.getPayloadType(message)
      };
    }
  }
  /**
  * Return the payload with the given type.
  */
  getPayload(message, type) {
    (0, import_invariant.invariant)(message.payload, void 0, {
      F: __dxlog_file,
      L: 40,
      S: this,
      A: [
        "message.payload",
        ""
      ]
    });
    const payloadTypename = this.getPayloadType(message);
    if (type && type.typeName !== payloadTypename) {
      throw new Error(`Unexpected payload type: ${payloadTypename}; expected ${type.typeName}`);
    }
    (0, import_invariant.invariant)(import_buf3.bufWkt.anyIs(message.payload, type), `Unexpected payload type: ${payloadTypename}}`, {
      F: __dxlog_file,
      L: 46,
      S: this,
      A: [
        "bufWkt.anyIs(message.payload, type)",
        "`Unexpected payload type: ${payloadTypename}}`"
      ]
    });
    const payload = import_buf3.bufWkt.anyUnpack(message.payload, this.typeRegistry);
    (0, import_invariant.invariant)(payload, `Empty payload: ${payloadTypename}}`, {
      F: __dxlog_file,
      L: 48,
      S: this,
      A: [
        "payload",
        "`Empty payload: ${payloadTypename}}`"
      ]
    });
    return payload;
  }
  /**
  * Get the payload type.
  */
  getPayloadType(message) {
    if (!message.payload) {
      return void 0;
    }
    const [, type] = message.payload.typeUrl.split("/");
    return type;
  }
  /**
  * Create a packed message.
  */
  createMessage(type, { source, target, payload, serviceId }) {
    return import_buf3.buf.create(import_messenger_pb3.MessageSchema, {
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      source,
      target,
      serviceId,
      payload: payload ? import_buf3.bufWkt.anyPack(type, import_buf3.buf.create(type, payload)) : void 0
    });
  }
};
var toUint8Array = async (data) => {
  if (data instanceof Buffer) {
    return (0, import_util.bufferToArray)(data);
  }
  if (data instanceof Blob) {
    return new Uint8Array(await data.arrayBuffer());
  }
  throw new Error(`Unexpected datatype: ${data}`);
};
var protocol = new Protocol([
  import_messenger_pb2.SwarmRequestSchema,
  import_messenger_pb2.SwarmResponseSchema,
  import_messenger_pb2.TextMessageSchema,
  import_buf2.bufWkt.AnySchema
]);
var __dxlog_file2 = "/home/runner/work/dxos/dxos/packages/core/mesh/edge-client/src/edge-ws-muxer.ts";
var FLAG_SEGMENT_SEQ = 1;
var FLAG_SEGMENT_SEQ_TERMINATED = 1 << 1;
var CLOUDFLARE_MESSAGE_MAX_BYTES = 1e3 * 1e3;
var CLOUDFLARE_RPC_MAX_BYTES = 32 * 1e3 * 1e3;
var MAX_CHUNK_LENGTH = 16384;
var MAX_BUFFERED_AMOUNT = CLOUDFLARE_MESSAGE_MAX_BYTES;
var BUFFER_FULL_BACKOFF_TIMEOUT = 100;
var WebSocketMuxer = class {
  constructor(_ws, config) {
    this._ws = _ws;
    this._inMessageAccumulator = /* @__PURE__ */ new Map();
    this._outMessageChunks = /* @__PURE__ */ new Map();
    this._outMessageChannelByService = /* @__PURE__ */ new Map();
    this._maxChunkLength = config?.maxChunkLength ?? MAX_CHUNK_LENGTH;
  }
  /**
  * Resolves when all the message chunks get enqueued for sending.
  */
  async send(message) {
    const binary = import_buf.buf.toBinary(import_messenger_pb.MessageSchema, message);
    const channelId = this._resolveChannel(message);
    if (channelId == null && binary.byteLength > CLOUDFLARE_MESSAGE_MAX_BYTES || binary.byteLength > CLOUDFLARE_RPC_MAX_BYTES) {
      import_log.log.error("Large message dropped", {
        byteLength: binary.byteLength,
        serviceId: message.serviceId,
        payload: protocol.getPayloadType(message),
        channelId
      }, {
        F: __dxlog_file2,
        L: 62,
        S: this,
        C: (f, a) => f(...a)
      });
      return;
    }
    if (channelId == null || binary.length < this._maxChunkLength) {
      const flags = Buffer.from([
        0
      ]);
      this._ws.send(Buffer.concat([
        flags,
        binary
      ]));
      return;
    }
    const terminatorSentTrigger = new import_async.Trigger();
    const messageChunks = [];
    for (let i = 0; i < binary.length; i += this._maxChunkLength) {
      const chunk = binary.slice(i, i + this._maxChunkLength);
      const isLastChunk = i + this._maxChunkLength >= binary.length;
      if (isLastChunk) {
        const flags = Buffer.from([
          FLAG_SEGMENT_SEQ | FLAG_SEGMENT_SEQ_TERMINATED,
          channelId
        ]);
        messageChunks.push({
          payload: Buffer.concat([
            flags,
            chunk
          ]),
          trigger: terminatorSentTrigger
        });
      } else {
        const flags = Buffer.from([
          FLAG_SEGMENT_SEQ,
          channelId
        ]);
        messageChunks.push({
          payload: Buffer.concat([
            flags,
            chunk
          ])
        });
      }
    }
    const queuedMessages = this._outMessageChunks.get(channelId);
    if (queuedMessages) {
      queuedMessages.push(...messageChunks);
    } else {
      this._outMessageChunks.set(channelId, messageChunks);
    }
    this._sendChunkedMessages();
    return terminatorSentTrigger.wait();
  }
  receiveData(data) {
    if ((data[0] & FLAG_SEGMENT_SEQ) === 0) {
      return import_buf.buf.fromBinary(import_messenger_pb.MessageSchema, data.slice(1));
    }
    const [flags, channelId, ...payload] = data;
    let chunkAccumulator = this._inMessageAccumulator.get(channelId);
    if (chunkAccumulator) {
      chunkAccumulator.push(Buffer.from(payload));
    } else {
      chunkAccumulator = [
        Buffer.from(payload)
      ];
      this._inMessageAccumulator.set(channelId, chunkAccumulator);
    }
    if ((flags & FLAG_SEGMENT_SEQ_TERMINATED) === 0) {
      return void 0;
    }
    const message = import_buf.buf.fromBinary(import_messenger_pb.MessageSchema, Buffer.concat(chunkAccumulator));
    this._inMessageAccumulator.delete(channelId);
    return message;
  }
  destroy() {
    if (this._sendTimeout) {
      clearTimeout(this._sendTimeout);
      this._sendTimeout = void 0;
    }
    for (const channelChunks of this._outMessageChunks.values()) {
      channelChunks.forEach((chunk) => chunk.trigger?.wake());
    }
    this._outMessageChunks.clear();
    this._inMessageAccumulator.clear();
    this._outMessageChannelByService.clear();
  }
  _sendChunkedMessages() {
    if (this._sendTimeout) {
      return;
    }
    const send = () => {
      if (this._ws.readyState === 2 || this._ws.readyState === 3) {
        import_log.log.warn("send called for closed websocket", void 0, {
          F: __dxlog_file2,
          L: 146,
          S: this,
          C: (f, a) => f(...a)
        });
        this._sendTimeout = void 0;
        return;
      }
      let timeout = 0;
      const emptyChannels = [];
      for (const [channelId, messages] of this._outMessageChunks.entries()) {
        if (this._ws.bufferedAmount != null) {
          if (this._ws.bufferedAmount + MAX_CHUNK_LENGTH > MAX_BUFFERED_AMOUNT) {
            timeout = BUFFER_FULL_BACKOFF_TIMEOUT;
            break;
          }
        }
        const nextMessage = messages.shift();
        if (nextMessage) {
          this._ws.send(nextMessage.payload);
          nextMessage.trigger?.wake();
        } else {
          emptyChannels.push(channelId);
        }
      }
      emptyChannels.forEach((channelId) => this._outMessageChunks.delete(channelId));
      if (this._outMessageChunks.size > 0) {
        this._sendTimeout = setTimeout(send, timeout);
      } else {
        this._sendTimeout = void 0;
      }
    };
    this._sendTimeout = setTimeout(send);
  }
  _resolveChannel(message) {
    if (!message.serviceId) {
      return void 0;
    }
    let id = this._outMessageChannelByService.get(message.serviceId);
    if (!id) {
      id = this._outMessageChannelByService.size + 1;
      this._outMessageChannelByService.set(message.serviceId, id);
    }
    return id;
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  CLOUDFLARE_MESSAGE_MAX_BYTES,
  CLOUDFLARE_RPC_MAX_BYTES,
  Protocol,
  WebSocketMuxer,
  getTypename,
  protocol,
  toUint8Array
});
//# sourceMappingURL=chunk-XNHBUTNB.cjs.map
