{
  "version": 3,
  "sources": ["../../../src/edge-ws-muxer.ts", "../../../src/defs.ts", "../../../src/protocol.ts"],
  "sourcesContent": ["//\n// Copyright 2025 DXOS.org\n//\n\nimport { Trigger } from '@dxos/async';\nimport { log } from '@dxos/log';\nimport { buf } from '@dxos/protocols/buf';\nimport { MessageSchema, type Message } from '@dxos/protocols/buf/dxos/edge/messenger_pb';\n\nimport { protocol } from './defs';\n\n/**\n * 0000 0001 - message contains a part of segmented message chunk sequence.\n * The next byte defines a channel id and the rest of the message contains a part of Message proto binary.\n * Messages from different channels might interleave.\n * When the flag is NOT set the rest of the message should be interpreted as the valid Message proto binary.\n */\nconst FLAG_SEGMENT_SEQ = 1;\n/**\n * 0000 0010 - message terminates a segmented message chunk sequence.\n * All the chunks accumulated for the channel specified by the second byte can be concatenated\n * and interpreted as a valid Message proto binary.\n */\nconst FLAG_SEGMENT_SEQ_TERMINATED = 1 << 1;\n\n/**\n * https://developers.cloudflare.com/durable-objects/platform/limits/\n */\nexport const CLOUDFLARE_MESSAGE_MAX_BYTES = 1000 * 1000; // 1MB\nexport const CLOUDFLARE_RPC_MAX_BYTES = 32 * 1000 * 1000; // 32MB\n\nconst MAX_CHUNK_LENGTH = 16384;\nconst MAX_BUFFERED_AMOUNT = CLOUDFLARE_MESSAGE_MAX_BYTES;\nconst BUFFER_FULL_BACKOFF_TIMEOUT = 100;\n\nexport class WebSocketMuxer {\n  private readonly _inMessageAccumulator = new Map<number, Buffer[]>();\n  private readonly _outMessageChunks = new Map<number, MessageChunk[]>();\n  private readonly _outMessageChannelByService = new Map<string, number>();\n\n  private _sendTimeout: any | undefined;\n\n  private readonly _maxChunkLength: number;\n\n  constructor(\n    private readonly _ws: WebSocketCompat,\n    config?: { maxChunkLength: number },\n  ) {\n    this._maxChunkLength = config?.maxChunkLength ?? MAX_CHUNK_LENGTH;\n  }\n\n  /**\n   * Resolves when all the message chunks get enqueued for sending.\n   */\n  public async send(message: Message): Promise<void> {\n    const binary = buf.toBinary(MessageSchema, message);\n    const channelId = this._resolveChannel(message);\n    if (\n      (channelId == null && binary.byteLength > CLOUDFLARE_MESSAGE_MAX_BYTES) ||\n      binary.byteLength > CLOUDFLARE_RPC_MAX_BYTES\n    ) {\n      log.error('Large message dropped', {\n        byteLength: binary.byteLength,\n        serviceId: message.serviceId,\n        payload: protocol.getPayloadType(message),\n        channelId,\n      });\n      return;\n    }\n\n    if (channelId == null || binary.length < this._maxChunkLength) {\n      const flags = Buffer.from([0]);\n      this._ws.send(Buffer.concat([flags, binary]));\n      return;\n    }\n\n    const terminatorSentTrigger = new Trigger();\n    const messageChunks: MessageChunk[] = [];\n    for (let i = 0; i < binary.length; i += this._maxChunkLength) {\n      const chunk = binary.slice(i, i + this._maxChunkLength);\n      const isLastChunk = i + this._maxChunkLength >= binary.length;\n      if (isLastChunk) {\n        const flags = Buffer.from([FLAG_SEGMENT_SEQ | FLAG_SEGMENT_SEQ_TERMINATED, channelId]);\n        messageChunks.push({ payload: Buffer.concat([flags, chunk]), trigger: terminatorSentTrigger });\n      } else {\n        const flags = Buffer.from([FLAG_SEGMENT_SEQ, channelId]);\n        messageChunks.push({ payload: Buffer.concat([flags, chunk]) });\n      }\n    }\n\n    const queuedMessages = this._outMessageChunks.get(channelId);\n    if (queuedMessages) {\n      queuedMessages.push(...messageChunks);\n    } else {\n      this._outMessageChunks.set(channelId, messageChunks);\n    }\n\n    this._sendChunkedMessages();\n\n    return terminatorSentTrigger.wait();\n  }\n\n  public receiveData(data: Uint8Array): Message | undefined {\n    if ((data[0] & FLAG_SEGMENT_SEQ) === 0) {\n      return buf.fromBinary(MessageSchema, data.slice(1));\n    }\n\n    const [flags, channelId, ...payload] = data;\n    let chunkAccumulator = this._inMessageAccumulator.get(channelId);\n    if (chunkAccumulator) {\n      chunkAccumulator.push(Buffer.from(payload));\n    } else {\n      chunkAccumulator = [Buffer.from(payload)];\n      this._inMessageAccumulator.set(channelId, chunkAccumulator);\n    }\n\n    if ((flags & FLAG_SEGMENT_SEQ_TERMINATED) === 0) {\n      return undefined;\n    }\n\n    const message = buf.fromBinary(MessageSchema, Buffer.concat(chunkAccumulator));\n    this._inMessageAccumulator.delete(channelId);\n    return message;\n  }\n\n  public destroy(): void {\n    if (this._sendTimeout) {\n      clearTimeout(this._sendTimeout);\n      this._sendTimeout = undefined;\n    }\n    for (const channelChunks of this._outMessageChunks.values()) {\n      channelChunks.forEach((chunk) => chunk.trigger?.wake());\n    }\n    this._outMessageChunks.clear();\n    this._inMessageAccumulator.clear();\n    this._outMessageChannelByService.clear();\n  }\n\n  private _sendChunkedMessages(): void {\n    if (this._sendTimeout) {\n      return;\n    }\n\n    const send = () => {\n      if (this._ws.readyState === WebSocket.CLOSING || this._ws.readyState === WebSocket.CLOSED) {\n        log.warn('send called for closed websocket');\n        this._sendTimeout = undefined;\n        return;\n      }\n\n      let timeout = 0;\n      const emptyChannels: number[] = [];\n      for (const [channelId, messages] of this._outMessageChunks.entries()) {\n        if (this._ws.bufferedAmount != null) {\n          if (this._ws.bufferedAmount + MAX_CHUNK_LENGTH > MAX_BUFFERED_AMOUNT) {\n            timeout = BUFFER_FULL_BACKOFF_TIMEOUT;\n            break;\n          }\n        }\n\n        const nextMessage = messages.shift();\n        if (nextMessage) {\n          this._ws.send(nextMessage.payload);\n          nextMessage.trigger?.wake();\n        } else {\n          emptyChannels.push(channelId);\n        }\n      }\n\n      emptyChannels.forEach((channelId) => this._outMessageChunks.delete(channelId));\n\n      if (this._outMessageChunks.size > 0) {\n        this._sendTimeout = setTimeout(send, timeout);\n      } else {\n        this._sendTimeout = undefined;\n      }\n    };\n    this._sendTimeout = setTimeout(send);\n  }\n\n  private _resolveChannel(message: Message): number | undefined {\n    if (!message.serviceId) {\n      return undefined;\n    }\n    let id = this._outMessageChannelByService.get(message.serviceId);\n    if (!id) {\n      id = this._outMessageChannelByService.size + 1;\n      this._outMessageChannelByService.set(message.serviceId, id);\n    }\n    return id;\n  }\n}\n\ntype WebSocketCompat = {\n  readonly readyState: number;\n  /**\n   * Not available in workerd.\n   */\n  bufferedAmount?: number;\n  send(message: (ArrayBuffer | ArrayBufferView) | string): void;\n};\n\ntype MessageChunk = {\n  payload: Buffer;\n  /**\n   * Wakes when the payload is enqueued by WebSocket.\n   */\n  trigger?: Trigger;\n};\n\n/**\n * To avoid using isomorphic-ws on edge.\n */\nenum WebSocket {\n  CLOSING = 2,\n  CLOSED = 3,\n}\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { bufWkt } from '@dxos/protocols/buf';\nimport { SwarmRequestSchema, SwarmResponseSchema, TextMessageSchema } from '@dxos/protocols/buf/dxos/edge/messenger_pb';\n\nimport { Protocol } from './protocol';\n\nexport const protocol = new Protocol([SwarmRequestSchema, SwarmResponseSchema, TextMessageSchema, bufWkt.AnySchema]);\n", "//\n// Copyright 2024 DXOS.org\n//\n\nimport { invariant } from '@dxos/invariant';\nimport { buf, bufWkt } from '@dxos/protocols/buf';\nimport { type Message, MessageSchema, type PeerSchema } from '@dxos/protocols/buf/dxos/edge/messenger_pb';\nimport { bufferToArray } from '@dxos/util';\n\nexport type PeerData = buf.MessageInitShape<typeof PeerSchema>;\n\nexport const getTypename = (typeName: string) => `type.googleapis.com/${typeName}`;\n\n/**\n * NOTE: The type registry should be extended with all message types.\n */\nexport class Protocol {\n  private readonly _typeRegistry: buf.Registry;\n\n  constructor(types: buf.DescMessage[]) {\n    this._typeRegistry = buf.createRegistry(...types);\n  }\n\n  get typeRegistry(): buf.Registry {\n    return this._typeRegistry;\n  }\n\n  toJson(message: Message): any {\n    try {\n      return buf.toJson(MessageSchema, message, { registry: this.typeRegistry });\n    } catch (err) {\n      return { type: this.getPayloadType(message) };\n    }\n  }\n\n  /**\n   * Return the payload with the given type.\n   */\n  getPayload<Desc extends buf.DescMessage>(message: Message, type: Desc): buf.MessageShape<Desc> {\n    invariant(message.payload);\n    const payloadTypename = this.getPayloadType(message);\n    if (type && type.typeName !== payloadTypename) {\n      throw new Error(`Unexpected payload type: ${payloadTypename}; expected ${type.typeName}`);\n    }\n\n    invariant(bufWkt.anyIs(message.payload, type), `Unexpected payload type: ${payloadTypename}}`);\n    const payload = bufWkt.anyUnpack(message.payload, this.typeRegistry) as buf.MessageShape<Desc>;\n    invariant(payload, `Empty payload: ${payloadTypename}}`);\n    return payload;\n  }\n\n  /**\n   * Get the payload type.\n   */\n  getPayloadType(message: Message): string | undefined {\n    if (!message.payload) {\n      return undefined;\n    }\n\n    const [, type] = message.payload.typeUrl.split('/');\n    return type;\n  }\n\n  /**\n   * Create a packed message.\n   */\n  createMessage<Desc extends buf.DescMessage>(\n    type: Desc,\n    {\n      source,\n      target,\n      payload,\n      serviceId,\n    }: {\n      source?: PeerData;\n      target?: PeerData[];\n      payload?: buf.MessageInitShape<Desc>;\n      serviceId?: string;\n    },\n  ): Message {\n    return buf.create(MessageSchema, {\n      timestamp: new Date().toISOString(),\n      source,\n      target,\n      serviceId,\n      payload: payload ? bufWkt.anyPack(type, buf.create(type, payload)) : undefined,\n    });\n  }\n}\n\n/**\n * Convert websocket data to Uint8Array.\n */\nexport const toUint8Array = async (data: any): Promise<Uint8Array> => {\n  // Node.\n  if (data instanceof Buffer) {\n    return bufferToArray(data);\n  }\n\n  // Browser.\n  if (data instanceof Blob) {\n    return new Uint8Array(await (data as Blob).arrayBuffer());\n  }\n\n  throw new Error(`Unexpected datatype: ${data}`);\n};\n"],
  "mappings": "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",
  "names": ["import_buf", "import_messenger_pb", "getTypename", "typeName", "Protocol", "types", "_typeRegistry", "buf", "createRegistry", "typeRegistry", "toJson", "message", "MessageSchema", "registry", "err", "type", "getPayloadType", "getPayload", "invariant", "payload", "payloadTypename", "Error", "bufWkt", "anyIs", "anyUnpack", "undefined", "typeUrl", "split", "createMessage", "source", "target", "serviceId", "create", "timestamp", "Date", "toISOString", "anyPack", "toUint8Array", "data", "Buffer", "bufferToArray", "Blob", "Uint8Array", "arrayBuffer", "protocol", "SwarmRequestSchema", "SwarmResponseSchema", "TextMessageSchema", "AnySchema", "FLAG_SEGMENT_SEQ", "FLAG_SEGMENT_SEQ_TERMINATED", "CLOUDFLARE_MESSAGE_MAX_BYTES", "CLOUDFLARE_RPC_MAX_BYTES", "MAX_CHUNK_LENGTH", "MAX_BUFFERED_AMOUNT", "BUFFER_FULL_BACKOFF_TIMEOUT", "WebSocketMuxer", "_ws", "config", "_inMessageAccumulator", "Map", "_outMessageChunks", "_outMessageChannelByService", "_maxChunkLength", "maxChunkLength", "send", "binary", "toBinary", "channelId", "_resolveChannel", "byteLength", "log", "error", "length", "flags", "from", "concat", "terminatorSentTrigger", "Trigger", "messageChunks", "i", "chunk", "slice", "isLastChunk", "push", "trigger", "queuedMessages", "get", "set", "_sendChunkedMessages", "wait", "receiveData", "fromBinary", "chunkAccumulator", "delete", "destroy", "_sendTimeout", "clearTimeout", "channelChunks", "values", "forEach", "wake", "clear", "readyState", "warn", "timeout", "emptyChannels", "messages", "entries", "bufferedAmount", "nextMessage", "shift", "size", "setTimeout", "id"]
}
