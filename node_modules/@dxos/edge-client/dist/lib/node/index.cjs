"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var node_exports = {};
__export(node_exports, {
  CLOUDFLARE_MESSAGE_MAX_BYTES: () => import_chunk_XNHBUTNB.CLOUDFLARE_MESSAGE_MAX_BYTES,
  CLOUDFLARE_RPC_MAX_BYTES: () => import_chunk_XNHBUTNB.CLOUDFLARE_RPC_MAX_BYTES,
  EdgeClient: () => EdgeClient,
  EdgeConnectionClosedError: () => EdgeConnectionClosedError,
  EdgeHttpClient: () => EdgeHttpClient,
  EdgeIdentityChangedError: () => EdgeIdentityChangedError,
  Protocol: () => import_chunk_XNHBUTNB.Protocol,
  WebSocketMuxer: () => import_chunk_XNHBUTNB.WebSocketMuxer,
  createChainEdgeIdentity: () => createChainEdgeIdentity,
  createDeviceEdgeIdentity: () => createDeviceEdgeIdentity,
  createEphemeralEdgeIdentity: () => createEphemeralEdgeIdentity,
  createStubEdgeIdentity: () => createStubEdgeIdentity,
  createTestHaloEdgeIdentity: () => createTestHaloEdgeIdentity,
  getTypename: () => import_chunk_XNHBUTNB.getTypename,
  handleAuthChallenge: () => handleAuthChallenge,
  protocol: () => import_chunk_XNHBUTNB.protocol,
  toUint8Array: () => import_chunk_XNHBUTNB.toUint8Array
});
module.exports = __toCommonJS(node_exports);
var import_chunk_XNHBUTNB = require("./chunk-XNHBUTNB.cjs");
__reExport(node_exports, require("@dxos/protocols/buf/dxos/edge/messenger_pb"), module.exports);
var import_async = require("@dxos/async");
var import_context = require("@dxos/context");
var import_log = require("@dxos/log");
var import_services = require("@dxos/protocols/proto/dxos/client/services");
var import_invariant = require("@dxos/invariant");
var import_proto = require("@dxos/protocols/proto");
var import_isomorphic_ws = __toESM(require("isomorphic-ws"));
var import_async2 = require("@dxos/async");
var import_context2 = require("@dxos/context");
var import_invariant2 = require("@dxos/invariant");
var import_log2 = require("@dxos/log");
var import_protocols = require("@dxos/protocols");
var import_buf = require("@dxos/protocols/buf");
var import_messenger_pb = require("@dxos/protocols/buf/dxos/edge/messenger_pb");
var import_credentials = require("@dxos/credentials");
var import_invariant3 = require("@dxos/invariant");
var import_keyring = require("@dxos/keyring");
var import_keys = require("@dxos/keys");
var import_async3 = require("@dxos/async");
var import_context3 = require("@dxos/context");
var import_log3 = require("@dxos/log");
var import_protocols2 = require("@dxos/protocols");
var __dxlog_file = "/home/runner/work/dxos/dxos/packages/core/mesh/edge-client/src/edge-identity.ts";
var handleAuthChallenge = async (failedResponse, identity) => {
  (0, import_invariant.invariant)(failedResponse.status === 401, void 0, {
    F: __dxlog_file,
    L: 21,
    S: void 0,
    A: [
      "failedResponse.status === 401",
      ""
    ]
  });
  const headerValue = failedResponse.headers.get("Www-Authenticate");
  (0, import_invariant.invariant)(headerValue?.startsWith("VerifiablePresentation challenge="), void 0, {
    F: __dxlog_file,
    L: 24,
    S: void 0,
    A: [
      "headerValue?.startsWith('VerifiablePresentation challenge=')",
      ""
    ]
  });
  const challenge = headerValue?.slice("VerifiablePresentation challenge=".length);
  (0, import_invariant.invariant)(challenge, void 0, {
    F: __dxlog_file,
    L: 27,
    S: void 0,
    A: [
      "challenge",
      ""
    ]
  });
  const presentation = await identity.presentCredentials({
    challenge: Buffer.from(challenge, "base64")
  });
  return import_proto.schema.getCodecForType("dxos.halo.credentials.Presentation").encode(presentation);
};
function _ts_decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file2 = "/home/runner/work/dxos/dxos/packages/core/mesh/edge-client/src/edge-ws-connection.ts";
var SIGNAL_KEEPALIVE_INTERVAL = 4e3;
var SIGNAL_KEEPALIVE_TIMEOUT = 12e3;
var EdgeWsConnection = class extends import_context2.Resource {
  constructor(_identity, _connectionInfo, _callbacks) {
    super(), this._identity = _identity, this._connectionInfo = _connectionInfo, this._callbacks = _callbacks;
  }
  get info() {
    return {
      open: this.isOpen,
      identity: this._identity.identityKey,
      device: this._identity.peerKey
    };
  }
  send(message) {
    (0, import_invariant2.invariant)(this._ws, void 0, {
      F: __dxlog_file2,
      L: 52,
      S: this,
      A: [
        "this._ws",
        ""
      ]
    });
    (0, import_invariant2.invariant)(this._wsMuxer, void 0, {
      F: __dxlog_file2,
      L: 53,
      S: this,
      A: [
        "this._wsMuxer",
        ""
      ]
    });
    (0, import_log2.log)("sending...", {
      peerKey: this._identity.peerKey,
      payload: import_chunk_XNHBUTNB.protocol.getPayloadType(message)
    }, {
      F: __dxlog_file2,
      L: 54,
      S: this,
      C: (f, a) => f(...a)
    });
    if (this._ws?.protocol.includes(import_protocols.EdgeWebsocketProtocol.V0)) {
      const binary = import_buf.buf.toBinary(import_messenger_pb.MessageSchema, message);
      if (binary.length > import_chunk_XNHBUTNB.CLOUDFLARE_MESSAGE_MAX_BYTES) {
        import_log2.log.error("Message dropped because it was too large (>1MB).", {
          byteLength: binary.byteLength,
          serviceId: message.serviceId,
          payload: import_chunk_XNHBUTNB.protocol.getPayloadType(message)
        }, {
          F: __dxlog_file2,
          L: 58,
          S: this,
          C: (f, a) => f(...a)
        });
        return;
      }
      this._ws.send(binary);
    } else {
      this._wsMuxer.send(message).catch((e) => import_log2.log.catch(e, void 0, {
        F: __dxlog_file2,
        L: 67,
        S: this,
        C: (f, a) => f(...a)
      }));
    }
  }
  async _open() {
    const baseProtocols = [
      ...Object.values(import_protocols.EdgeWebsocketProtocol)
    ];
    this._ws = new import_isomorphic_ws.default(this._connectionInfo.url.toString(), this._connectionInfo.protocolHeader ? [
      ...baseProtocols,
      this._connectionInfo.protocolHeader
    ] : [
      ...baseProtocols
    ]);
    const muxer = new import_chunk_XNHBUTNB.WebSocketMuxer(this._ws);
    this._wsMuxer = muxer;
    this._ws.onopen = () => {
      if (this.isOpen) {
        (0, import_log2.log)("connected", void 0, {
          F: __dxlog_file2,
          L: 84,
          S: this,
          C: (f, a) => f(...a)
        });
        this._callbacks.onConnected();
        this._scheduleHeartbeats();
      } else {
        import_log2.log.verbose("connected after becoming inactive", {
          currentIdentity: this._identity
        }, {
          F: __dxlog_file2,
          L: 88,
          S: this,
          C: (f, a) => f(...a)
        });
      }
    };
    this._ws.onclose = (event) => {
      if (this.isOpen) {
        import_log2.log.warn("disconnected while being open", {
          code: event.code,
          reason: event.reason
        }, {
          F: __dxlog_file2,
          L: 93,
          S: this,
          C: (f, a) => f(...a)
        });
        this._callbacks.onRestartRequired();
        muxer.destroy();
      }
    };
    this._ws.onerror = (event) => {
      if (this.isOpen) {
        import_log2.log.warn("edge connection socket error", {
          error: event.error,
          info: event.message
        }, {
          F: __dxlog_file2,
          L: 100,
          S: this,
          C: (f, a) => f(...a)
        });
        this._callbacks.onRestartRequired();
      } else {
        import_log2.log.verbose("error ignored on closed connection", {
          error: event.error
        }, {
          F: __dxlog_file2,
          L: 103,
          S: this,
          C: (f, a) => f(...a)
        });
      }
    };
    this._ws.onmessage = async (event) => {
      if (!this.isOpen) {
        import_log2.log.verbose("message ignored on closed connection", {
          event: event.type
        }, {
          F: __dxlog_file2,
          L: 111,
          S: this,
          C: (f, a) => f(...a)
        });
        return;
      }
      if (event.data === "__pong__") {
        this._rescheduleHeartbeatTimeout();
        return;
      }
      const bytes = await (0, import_chunk_XNHBUTNB.toUint8Array)(event.data);
      if (!this.isOpen) {
        return;
      }
      const message = this._ws?.protocol?.includes(import_protocols.EdgeWebsocketProtocol.V0) ? import_buf.buf.fromBinary(import_messenger_pb.MessageSchema, bytes) : muxer.receiveData(bytes);
      if (message) {
        (0, import_log2.log)("received", {
          from: message.source,
          payload: import_chunk_XNHBUTNB.protocol.getPayloadType(message)
        }, {
          F: __dxlog_file2,
          L: 128,
          S: this,
          C: (f, a) => f(...a)
        });
        this._callbacks.onMessage(message);
      }
    };
  }
  async _close() {
    void this._inactivityTimeoutCtx?.dispose().catch(() => {
    });
    try {
      this._ws?.close();
      this._ws = void 0;
      this._wsMuxer?.destroy();
      this._wsMuxer = void 0;
    } catch (err) {
      if (err instanceof Error && err.message.includes("WebSocket is closed before the connection is established.")) {
        return;
      }
      import_log2.log.warn("Error closing websocket", {
        err
      }, {
        F: __dxlog_file2,
        L: 146,
        S: this,
        C: (f, a) => f(...a)
      });
    }
  }
  _scheduleHeartbeats() {
    (0, import_invariant2.invariant)(this._ws, void 0, {
      F: __dxlog_file2,
      L: 151,
      S: this,
      A: [
        "this._ws",
        ""
      ]
    });
    (0, import_async2.scheduleTaskInterval)(this._ctx, async () => {
      this._ws?.send("__ping__");
    }, SIGNAL_KEEPALIVE_INTERVAL);
    this._ws.send("__ping__");
    this._rescheduleHeartbeatTimeout();
  }
  _rescheduleHeartbeatTimeout() {
    if (!this.isOpen) {
      return;
    }
    void this._inactivityTimeoutCtx?.dispose();
    this._inactivityTimeoutCtx = new import_context2.Context(void 0, {
      F: __dxlog_file2,
      L: 170
    });
    (0, import_async2.scheduleTask)(this._inactivityTimeoutCtx, () => {
      if (this.isOpen) {
        import_log2.log.warn("restart due to inactivity timeout", void 0, {
          F: __dxlog_file2,
          L: 175,
          S: this,
          C: (f, a) => f(...a)
        });
        this._callbacks.onRestartRequired();
      }
    }, SIGNAL_KEEPALIVE_TIMEOUT);
  }
};
_ts_decorate([
  import_log2.logInfo
], EdgeWsConnection.prototype, "info", null);
var EdgeConnectionClosedError = class extends Error {
  constructor() {
    super("Edge connection closed.");
  }
};
var EdgeIdentityChangedError = class extends Error {
  constructor() {
    super("Edge identity changed.");
  }
};
var getEdgeUrlWithProtocol = (baseUrl, protocol2) => {
  const isSecure = baseUrl.startsWith("https") || baseUrl.startsWith("wss");
  const url = new URL(baseUrl);
  url.protocol = protocol2 + (isSecure ? "s" : "");
  return url.toString();
};
function _ts_decorate2(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var __dxlog_file3 = "/home/runner/work/dxos/dxos/packages/core/mesh/edge-client/src/edge-client.ts";
var DEFAULT_TIMEOUT = 1e4;
var EdgeClient = class extends import_context.Resource {
  constructor(_identity, _config) {
    super(), this._identity = _identity, this._config = _config, this.statusChanged = new import_async.Event(), this._persistentLifecycle = new import_async.PersistentLifecycle({
      start: async () => this._connect(),
      stop: async (state) => this._disconnect(state)
    }), this._messageListeners = /* @__PURE__ */ new Set(), this._reconnectListeners = /* @__PURE__ */ new Set(), this._currentConnection = void 0, this._ready = new import_async.Trigger(), this._isActive = (connection) => connection === this._currentConnection;
    this._baseWsUrl = getEdgeUrlWithProtocol(_config.socketEndpoint, "ws");
    this._baseHttpUrl = getEdgeUrlWithProtocol(_config.socketEndpoint, "http");
  }
  get info() {
    return {
      open: this.isOpen,
      status: this.status,
      identity: this._identity.identityKey,
      device: this._identity.peerKey
    };
  }
  get status() {
    return Boolean(this._currentConnection) && this._ready.state === import_async.TriggerState.RESOLVED ? import_services.EdgeStatus.CONNECTED : import_services.EdgeStatus.NOT_CONNECTED;
  }
  get identityKey() {
    return this._identity.identityKey;
  }
  get peerKey() {
    return this._identity.peerKey;
  }
  setIdentity(identity) {
    if (identity.identityKey !== this._identity.identityKey || identity.peerKey !== this._identity.peerKey) {
      (0, import_log.log)("Edge identity changed", {
        identity,
        oldIdentity: this._identity
      }, {
        F: __dxlog_file3,
        L: 99,
        S: this,
        C: (f, a) => f(...a)
      });
      this._identity = identity;
      this._closeCurrentConnection(new EdgeIdentityChangedError());
      void this._persistentLifecycle.scheduleRestart();
    }
  }
  onMessage(listener) {
    this._messageListeners.add(listener);
    return () => this._messageListeners.delete(listener);
  }
  onReconnected(listener) {
    this._reconnectListeners.add(listener);
    if (this._ready.state === import_async.TriggerState.RESOLVED) {
      (0, import_async.scheduleMicroTask)(this._ctx, () => {
        if (this._reconnectListeners.has(listener)) {
          try {
            listener();
          } catch (error) {
            import_log.log.catch(error, void 0, {
              F: __dxlog_file3,
              L: 121,
              S: this,
              C: (f, a) => f(...a)
            });
          }
        }
      });
    }
    return () => this._reconnectListeners.delete(listener);
  }
  /**
  * Open connection to messaging service.
  */
  async _open() {
    (0, import_log.log)("opening...", {
      info: this.info
    }, {
      F: __dxlog_file3,
      L: 133,
      S: this,
      C: (f, a) => f(...a)
    });
    this._persistentLifecycle.open().catch((err) => {
      import_log.log.warn("Error while opening connection", {
        err
      }, {
        F: __dxlog_file3,
        L: 135,
        S: this,
        C: (f, a) => f(...a)
      });
    });
  }
  /**
  * Close connection and free resources.
  */
  async _close() {
    (0, import_log.log)("closing...", {
      peerKey: this._identity.peerKey
    }, {
      F: __dxlog_file3,
      L: 143,
      S: this,
      C: (f, a) => f(...a)
    });
    this._closeCurrentConnection();
    await this._persistentLifecycle.close();
  }
  async _connect() {
    if (this._ctx.disposed) {
      return void 0;
    }
    const identity = this._identity;
    const path = `/ws/${identity.identityKey}/${identity.peerKey}`;
    const protocolHeader = this._config.disableAuth ? void 0 : await this._createAuthHeader(path);
    if (this._identity !== identity) {
      (0, import_log.log)("identity changed during auth header request", void 0, {
        F: __dxlog_file3,
        L: 157,
        S: this,
        C: (f, a) => f(...a)
      });
      return void 0;
    }
    const restartRequired = new import_async.Trigger();
    const url = new URL(path, this._baseWsUrl);
    (0, import_log.log)("Opening websocket", {
      url: url.toString(),
      protocolHeader
    }, {
      F: __dxlog_file3,
      L: 163,
      S: this,
      C: (f, a) => f(...a)
    });
    const connection = new EdgeWsConnection(identity, {
      url,
      protocolHeader
    }, {
      onConnected: () => {
        if (this._isActive(connection)) {
          this._ready.wake();
          this._notifyReconnected();
        } else {
          import_log.log.verbose("connected callback ignored, because connection is not active", void 0, {
            F: __dxlog_file3,
            L: 173,
            S: this,
            C: (f, a) => f(...a)
          });
        }
      },
      onRestartRequired: () => {
        if (this._isActive(connection)) {
          this._closeCurrentConnection();
          void this._persistentLifecycle.scheduleRestart();
        } else {
          import_log.log.verbose("restart requested by inactive connection", void 0, {
            F: __dxlog_file3,
            L: 181,
            S: this,
            C: (f, a) => f(...a)
          });
        }
        restartRequired.wake();
      },
      onMessage: (message) => {
        if (this._isActive(connection)) {
          this._notifyMessageReceived(message);
        } else {
          import_log.log.verbose("ignored a message on inactive connection", {
            from: message.source,
            type: message.payload?.typeUrl
          }, {
            F: __dxlog_file3,
            L: 189,
            S: this,
            C: (f, a) => f(...a)
          });
        }
      }
    });
    this._currentConnection = connection;
    await connection.open();
    await Promise.race([
      this._ready.wait({
        timeout: this._config.timeout ?? DEFAULT_TIMEOUT
      }),
      restartRequired
    ]);
    return connection;
  }
  async _disconnect(state) {
    await state.close();
    this.statusChanged.emit(this.status);
  }
  _closeCurrentConnection(error = new EdgeConnectionClosedError()) {
    this._currentConnection = void 0;
    this._ready.throw(error);
    this._ready.reset();
    this.statusChanged.emit(this.status);
  }
  _notifyReconnected() {
    this.statusChanged.emit(this.status);
    for (const listener of this._reconnectListeners) {
      try {
        listener();
      } catch (err) {
        import_log.log.error("ws reconnect listener failed", {
          err
        }, {
          F: __dxlog_file3,
          L: 225,
          S: this,
          C: (f, a) => f(...a)
        });
      }
    }
  }
  _notifyMessageReceived(message) {
    for (const listener of this._messageListeners) {
      try {
        listener(message);
      } catch (err) {
        import_log.log.error("ws incoming message processing failed", {
          err,
          payload: import_chunk_XNHBUTNB.protocol.getPayloadType(message)
        }, {
          F: __dxlog_file3,
          L: 235,
          S: this,
          C: (f, a) => f(...a)
        });
      }
    }
  }
  /**
  * Send message.
  * NOTE: The message is guaranteed to be delivered but the service must respond with a message to confirm processing.
  */
  async send(message) {
    if (this._ready.state !== import_async.TriggerState.RESOLVED) {
      (0, import_log.log)("waiting for websocket to become ready", void 0, {
        F: __dxlog_file3,
        L: 246,
        S: this,
        C: (f, a) => f(...a)
      });
      await this._ready.wait({
        timeout: this._config.timeout ?? DEFAULT_TIMEOUT
      });
    }
    if (!this._currentConnection) {
      throw new EdgeConnectionClosedError();
    }
    if (message.source && (message.source.peerKey !== this._identity.peerKey || message.source.identityKey !== this.identityKey)) {
      throw new EdgeIdentityChangedError();
    }
    this._currentConnection.send(message);
  }
  async _createAuthHeader(path) {
    const httpUrl = new URL(path, this._baseHttpUrl);
    httpUrl.protocol = getEdgeUrlWithProtocol(this._baseWsUrl.toString(), "http");
    const response = await fetch(httpUrl, {
      method: "GET"
    });
    if (response.status === 401) {
      return encodePresentationWsAuthHeader(await handleAuthChallenge(response, this._identity));
    } else {
      import_log.log.warn("no auth challenge from edge", {
        status: response.status,
        statusText: response.statusText
      }, {
        F: __dxlog_file3,
        L: 271,
        S: this,
        C: (f, a) => f(...a)
      });
      return void 0;
    }
  }
};
_ts_decorate2([
  import_log.logInfo
], EdgeClient.prototype, "info", null);
var encodePresentationWsAuthHeader = (encodedPresentation) => {
  const encodedToken = Buffer.from(encodedPresentation).toString("base64").replace(/=*$/, "").replaceAll("/", "|");
  return `base64url.bearer.authorization.dxos.org.${encodedToken}`;
};
var __dxlog_file4 = "/home/runner/work/dxos/dxos/packages/core/mesh/edge-client/src/auth.ts";
var createDeviceEdgeIdentity = async (signer, key) => {
  return {
    identityKey: key.toHex(),
    peerKey: key.toHex(),
    presentCredentials: async ({ challenge }) => {
      return (0, import_credentials.signPresentation)({
        presentation: {
          credentials: [
            // Verifier requires at least one credential in the presentation to establish the subject.
            await (0, import_credentials.createCredential)({
              assertion: {
                "@type": "dxos.halo.credentials.Auth"
              },
              issuer: key,
              subject: key,
              signer
            })
          ]
        },
        signer,
        signerKey: key,
        nonce: challenge
      });
    }
  };
};
var createChainEdgeIdentity = async (signer, identityKey, peerKey, chain, credentials) => {
  const credentialsToSign = credentials.length > 0 ? credentials : [
    await (0, import_credentials.createCredential)({
      assertion: {
        "@type": "dxos.halo.credentials.Auth"
      },
      issuer: identityKey,
      subject: identityKey,
      signer,
      chain,
      signingKey: peerKey
    })
  ];
  return {
    identityKey: identityKey.toHex(),
    peerKey: peerKey.toHex(),
    presentCredentials: async ({ challenge }) => {
      (0, import_invariant3.invariant)(chain, void 0, {
        F: __dxlog_file4,
        L: 75,
        S: void 0,
        A: [
          "chain",
          ""
        ]
      });
      return (0, import_credentials.signPresentation)({
        presentation: {
          credentials: credentialsToSign
        },
        signer,
        nonce: challenge,
        signerKey: peerKey,
        chain
      });
    }
  };
};
var createEphemeralEdgeIdentity = async () => {
  const keyring = new import_keyring.Keyring();
  const key = await keyring.createKey();
  return createDeviceEdgeIdentity(keyring, key);
};
var createTestHaloEdgeIdentity = async (signer, identityKey, deviceKey) => {
  const deviceAdmission = await (0, import_credentials.createCredential)({
    assertion: {
      "@type": "dxos.halo.credentials.AuthorizedDevice",
      deviceKey,
      identityKey
    },
    issuer: identityKey,
    subject: deviceKey,
    signer
  });
  return createChainEdgeIdentity(signer, identityKey, deviceKey, {
    credential: deviceAdmission
  }, [
    await (0, import_credentials.createCredential)({
      assertion: {
        "@type": "dxos.halo.credentials.Auth"
      },
      issuer: identityKey,
      subject: identityKey,
      signer
    })
  ]);
};
var createStubEdgeIdentity = () => {
  const identityKey = import_keys.PublicKey.random();
  const deviceKey = import_keys.PublicKey.random();
  return {
    identityKey: identityKey.toHex(),
    peerKey: deviceKey.toHex(),
    presentCredentials: async () => {
      throw new Error("Stub identity does not support authentication.");
    }
  };
};
var __dxlog_file5 = "/home/runner/work/dxos/dxos/packages/core/mesh/edge-client/src/edge-http-client.ts";
var DEFAULT_RETRY_TIMEOUT = 1500;
var DEFAULT_RETRY_JITTER = 500;
var DEFAULT_MAX_RETRIES_COUNT = 3;
var EdgeHttpClient = class {
  constructor(baseUrl) {
    this._baseUrl = getEdgeUrlWithProtocol(baseUrl, "http");
    (0, import_log3.log)("created", {
      url: this._baseUrl
    }, {
      F: __dxlog_file5,
      L: 53,
      S: this,
      C: (f, a) => f(...a)
    });
  }
  get baseUrl() {
    return this._baseUrl;
  }
  setIdentity(identity) {
    if (this._edgeIdentity?.identityKey !== identity.identityKey || this._edgeIdentity?.peerKey !== identity.peerKey) {
      this._edgeIdentity = identity;
      this._authHeader = void 0;
    }
  }
  createAgent(body, args) {
    return this._call("/agents/create", {
      ...args,
      method: "POST",
      body
    });
  }
  getAgentStatus(request, args) {
    return this._call(`/users/${request.ownerIdentityKey.toHex()}/agent/status`, {
      ...args,
      method: "GET"
    });
  }
  getCredentialsForNotarization(spaceId, args) {
    return this._call(`/spaces/${spaceId}/notarization`, {
      ...args,
      method: "GET"
    });
  }
  async notarizeCredentials(spaceId, body, args) {
    await this._call(`/spaces/${spaceId}/notarization`, {
      ...args,
      body,
      method: "POST"
    });
  }
  async joinSpaceByInvitation(spaceId, body, args) {
    return this._call(`/spaces/${spaceId}/join`, {
      ...args,
      body,
      method: "POST"
    });
  }
  async recoverIdentity(body, args) {
    return this._call("/identity/recover", {
      ...args,
      body,
      method: "POST"
    });
  }
  async executeWorkflow(spaceId, graphId, input, args) {
    return this._call(`/workflows/${spaceId}/${graphId}`, {
      ...args,
      body: input,
      method: "POST"
    });
  }
  async uploadFunction(pathParts, body, args) {
    const path = [
      "functions",
      ...pathParts.functionId ? [
        pathParts.functionId
      ] : []
    ].join("/");
    return this._call(path, {
      ...args,
      body,
      method: "PUT"
    });
  }
  async initiateOAuthFlow(body, args) {
    return this._call("/oauth/initiate", {
      ...args,
      body,
      method: "POST"
    });
  }
  async queryQueue(subspaceTag, spaceId, query, args) {
    const { queueId } = query;
    const queryParams = new URLSearchParams();
    if (query.after != null) {
      queryParams.set("after", query.after);
    }
    if (query.before != null) {
      queryParams.set("before", query.before);
    }
    if (query.limit != null) {
      queryParams.set("limit", query.limit.toString());
    }
    if (query.reverse != null) {
      queryParams.set("reverse", query.reverse.toString());
    }
    if (query.objectIds != null) {
      queryParams.set("objectIds", query.objectIds.join(","));
    }
    return this._call(`/spaces/${subspaceTag}/${spaceId}/queue/${queueId}/query?${queryParams.toString()}`, {
      ...args,
      method: "GET"
    });
  }
  async insertIntoQueue(subspaceTag, spaceId, queueId, objects, args) {
    return this._call(`/spaces/${subspaceTag}/${spaceId}/queue/${queueId}`, {
      ...args,
      body: {
        objects
      },
      method: "POST"
    });
  }
  async deleteFromQueue(subspaceTag, spaceId, queueId, objectIds, args) {
    return this._call(`/spaces/${subspaceTag}/${spaceId}/queue/${queueId}`, {
      ...args,
      query: {
        ids: objectIds.join(",")
      },
      method: "DELETE"
    });
  }
  async createSpace(body, args) {
    return this._call("/spaces/create", {
      ...args,
      body,
      method: "POST"
    });
  }
  async _call(path, args) {
    const requestContext = args.context ?? new import_context3.Context(void 0, {
      F: __dxlog_file5,
      L: 192
    });
    const shouldRetry = createRetryHandler(args);
    let url = `${this._baseUrl}${path.startsWith("/") ? path.slice(1) : path}`;
    if (args.query) {
      const queryParams = new URLSearchParams();
      for (const [key, value] of Object.entries(args.query)) {
        queryParams.set(key, value.toString());
      }
      url += `?${queryParams.toString()}`;
    }
    (0, import_log3.log)("call", {
      method: args.method,
      path,
      request: args.body
    }, {
      F: __dxlog_file5,
      L: 204,
      S: this,
      C: (f, a) => f(...a)
    });
    let handledAuth = false;
    let authHeader = this._authHeader;
    while (true) {
      let processingError;
      let retryAfterHeaderValue = Number.NaN;
      try {
        const request = createRequest(args, authHeader);
        const response = await fetch(url, request);
        retryAfterHeaderValue = Number(response.headers.get("Retry-After"));
        if (response.ok) {
          const body = await response.json();
          if (body.success) {
            return body.data;
          }
          (0, import_log3.log)("unsuccessful edge response", {
            path,
            body
          }, {
            F: __dxlog_file5,
            L: 223,
            S: this,
            C: (f, a) => f(...a)
          });
          if (body.errorData?.type === "auth_challenge" && typeof body.errorData?.challenge === "string") {
            processingError = new import_protocols2.EdgeAuthChallengeError(body.errorData.challenge, body.errorData);
          } else {
            processingError = import_protocols2.EdgeCallFailedError.fromUnsuccessfulResponse(response, body);
          }
        } else if (response.status === 401 && !handledAuth) {
          authHeader = await this._handleUnauthorized(response);
          handledAuth = true;
          continue;
        } else {
          processingError = import_protocols2.EdgeCallFailedError.fromHttpFailure(response);
        }
      } catch (error) {
        processingError = import_protocols2.EdgeCallFailedError.fromProcessingFailureCause(error);
      }
      if (processingError.isRetryable && await shouldRetry(requestContext, retryAfterHeaderValue)) {
        (0, import_log3.log)("retrying edge request", {
          path,
          processingError
        }, {
          F: __dxlog_file5,
          L: 242,
          S: this,
          C: (f, a) => f(...a)
        });
      } else {
        throw processingError;
      }
    }
  }
  async _handleUnauthorized(response) {
    if (!this._edgeIdentity) {
      import_log3.log.warn("edge unauthorized response received before identity was set", void 0, {
        F: __dxlog_file5,
        L: 251,
        S: this,
        C: (f, a) => f(...a)
      });
      throw import_protocols2.EdgeCallFailedError.fromHttpFailure(response);
    }
    const challenge = await handleAuthChallenge(response, this._edgeIdentity);
    this._authHeader = encodeAuthHeader(challenge);
    (0, import_log3.log)("auth header updated", void 0, {
      F: __dxlog_file5,
      L: 256,
      S: this,
      C: (f, a) => f(...a)
    });
    return this._authHeader;
  }
};
var createRetryHandler = (args) => {
  if (!args.retry || args.retry.count < 1) {
    return async () => false;
  }
  let retries = 0;
  const maxRetries = args.retry.count ?? DEFAULT_MAX_RETRIES_COUNT;
  const baseTimeout = args.retry.timeout ?? DEFAULT_RETRY_TIMEOUT;
  const jitter = args.retry.jitter ?? DEFAULT_RETRY_JITTER;
  return async (ctx, retryAfter) => {
    if (++retries > maxRetries || ctx.disposed) {
      return false;
    }
    if (retryAfter) {
      await (0, import_async3.sleep)(retryAfter);
    } else {
      const timeout = baseTimeout + Math.random() * jitter;
      await (0, import_async3.sleep)(timeout);
    }
    return true;
  };
};
var createRequest = (args, authHeader) => {
  return {
    method: args.method,
    body: args.body && JSON.stringify(args.body),
    headers: authHeader ? {
      Authorization: authHeader
    } : void 0
  };
};
var encodeAuthHeader = (challenge) => {
  const encodedChallenge = Buffer.from(challenge).toString("base64");
  return `VerifiablePresentation pb;base64,${encodedChallenge}`;
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  CLOUDFLARE_MESSAGE_MAX_BYTES,
  CLOUDFLARE_RPC_MAX_BYTES,
  EdgeClient,
  EdgeConnectionClosedError,
  EdgeHttpClient,
  EdgeIdentityChangedError,
  Protocol,
  WebSocketMuxer,
  createChainEdgeIdentity,
  createDeviceEdgeIdentity,
  createEphemeralEdgeIdentity,
  createStubEdgeIdentity,
  createTestHaloEdgeIdentity,
  getTypename,
  handleAuthChallenge,
  protocol,
  toUint8Array,
  ...require("@dxos/protocols/buf/dxos/edge/messenger_pb")
});
//# sourceMappingURL=index.cjs.map
