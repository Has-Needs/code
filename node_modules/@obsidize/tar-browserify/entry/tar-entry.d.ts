import { ArchiveContext } from '../common/archive-context';
import { AsyncUint8ArrayLike } from '../common/async-uint8-array';
import { TarSerializable } from '../common/tar-utility';
import { TarHeader } from '../header/tar-header';
import { UstarHeaderLike } from '../header/ustar/ustar-header-like';
import { UstarHeaderLinkIndicatorType } from '../header/ustar/ustar-header-link-indicator-type';
export interface TarEntryOptions {
    header?: TarHeader;
    content?: Uint8Array | null;
    offset?: number;
    context?: ArchiveContext | null;
}
/**
 * Container for metadata and content of a tarball entry.
 *
 * Here, we consider an "entry" to be a tuple of:
 * 1. The parsed USTAR header sector content (AKA TarHeader)
 * 2. The aggregate of the proceeding file content sectors, based on the header's file size attribute
 */
export declare class TarEntry implements UstarHeaderLike, TarSerializable {
    protected mHeader: TarHeader;
    protected mContent: Uint8Array | null;
    protected mOffset: number;
    protected mContext: ArchiveContext | null;
    constructor(options?: TarEntryOptions);
    static isTarEntry(v: any): boolean;
    /**
     * Convenience parser
     * @param attrs - partial header data POJO
     * @param content - content of the entry (if it is a file)
     */
    static from(attrs: UstarHeaderLike | Partial<UstarHeaderLike>, content?: Uint8Array | null): TarEntry;
    protected initialize(options: TarEntryOptions): this;
    get fileName(): string;
    get fileSize(): number;
    get fileMode(): number;
    get ownerUserId(): number;
    get groupUserId(): number;
    get lastModified(): number;
    get headerChecksum(): number;
    get linkedFileName(): string;
    get typeFlag(): UstarHeaderLinkIndicatorType;
    get ustarIndicator(): string;
    get ustarVersion(): string;
    get ownerUserName(): string;
    get ownerGroupName(): string;
    get deviceMajorNumber(): string;
    get deviceMinorNumber(): string;
    get fileNamePrefix(): string;
    /**
     * The header metadata parsed out for this entry.
     * See TarHeaderFieldDefinition for details.
     */
    get header(): TarHeader;
    /**
     * The file content for this entry.
     * This may be null for entries loaded asynchronously, or
     * for non-file entries like directories.
     */
    get content(): Uint8Array | null | undefined;
    /**
     * The context (if any) from which this entry was parsed.
     * The context will include global data about things such as
     * the origin of the archive and global pax headers.
     */
    get context(): ArchiveContext | null | undefined;
    /**
     * The starting absolute index (inclusive) in the source buffer that this entry was parsed from.
     * Returns zero by default if this was not parsed by a source buffer.
     */
    get bufferStartIndex(): number;
    /**
     * The ending absolute index (exclusive) in the source buffer that this entry was parsed from.
     * Returns sectorByteLength by default if this was not parsed by a source buffer.
     */
    get bufferEndIndex(): number;
    /**
     * The total exact byte length of this entry, including the header.
     */
    get byteLength(): number;
    /**
     * The total byte length of this entry, including the header,
     * which is a multiple of the standard tar sector size.
     */
    get sectorByteLength(): number;
    /**
     * The starting index (inclusive) of the content of this entry.
     * Note that this will always be the first index of the header, regardless of
     * whether or not this is a file.
     */
    get contentStartIndex(): number;
    /**
     * The ending index (exclusive) of the content of this entry.
     * If this entry is not a file, or the file is empty, this will be
     * the same as the content starting index.
     */
    get contentEndIndex(): number;
    /**
     * Convenience for decoding the current content buffer as a string.
     * Note that if the content was not loaded for whatever reason, this
     * will return an empty string.
     * @returns The decoded string data from the currently assigned content,
     * or an empty string if there is no content assigned.
     */
    getContentAsText(): string;
    isDirectory(): boolean;
    isFile(): boolean;
    /**
     * Only necessary if this entry was extracted from an async buffer, since the entry
     * does not hold the content of async buffers by default.
     *
     * If the entry was extracted synchronously, its content will be available via the "content" property.
     */
    readContentFrom(buffer: AsyncUint8ArrayLike, offset?: number, length?: number): Promise<Uint8Array>;
    /**
     * Writes the header and content of this entry to the given output
     * @param output - the buffer to be written to
     * @param offset - the offset in the buffer to start writing entry data
     * @returns true if this entry was successfully written to the output
     */
    writeTo(output: Uint8Array, offset: number): boolean;
    /**
     * @returns This instance serialized as a single slice for a tar buffer
     */
    toUint8Array(): Uint8Array;
    /**
     * Overridden to prevent circular reference errors / huge memory spikes that would
     * include the underlying content by default.
     */
    toJSON(): Record<string, unknown>;
}
