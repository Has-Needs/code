{"version":3,"file":"babel.cjs","sources":["../../src/babel.ts"],"sourcesContent":["// this is small alteration of original transform to do not transform hooks\n// https://github.com/preactjs/signals/blob/76babcb520594bb200fd69ac4840a7df5f259752/packages/react-transform/src/index.ts\nimport {\n  types as BabelTypes,\n  template as BabelTemplate,\n  PluginObj,\n  PluginPass,\n  NodePath,\n  template,\n} from \"@babel/core\";\nimport { isModule, addNamed } from \"@babel/helper-module-imports\";\nimport type { VisitNodeObject } from \"@babel/traverse\";\nimport debug from \"debug\";\n\ninterface PluginArgs {\n  types: typeof BabelTypes;\n  template: typeof BabelTemplate;\n}\n\nconst optOutCommentIdentifier = /(^|\\s)@noUseSignals(\\s|$)/;\nconst optInCommentIdentifier = /(^|\\s)@useSignals(\\s|$)/;\nconst dataNamespace = \"@preact-signals/safe-react/babel\";\nconst defaultImportSource = \"@preact-signals/safe-react/tracking\";\nconst importName = \"useSignals\";\nconst getHookIdentifier = \"getHookIdentifier\";\nconst maybeUsesSignal = \"maybeUsesSignal\";\nconst containsJSX = \"containsJSX\";\nconst alreadyTransformed = \"alreadyTransformed\";\n\nconst logger = {\n  transformed: debug(\"signals:react-transform:transformed\"),\n  skipped: debug(\"signals:react-transform:skipped\"),\n};\n\nconst get = (pass: PluginPass, name: any) =>\n  pass.get(`${dataNamespace}/${name}`);\nconst set = (pass: PluginPass, name: string, v: any) =>\n  pass.set(`${dataNamespace}/${name}`, v);\n\ninterface DataContainer {\n  getData(name: string): any;\n  setData(name: string, value: any): void;\n}\nconst setData = (node: DataContainer, name: string, value: any) =>\n  node.setData(`${dataNamespace}/${name}`, value);\nconst getData = (node: DataContainer, name: string) =>\n  node.getData(`${dataNamespace}/${name}`);\n\nfunction setOnFunctionScope(path: NodePath, key: string, value: any) {\n  const functionScope = path.scope.getFunctionParent();\n  if (functionScope) {\n    setData(functionScope, key, value);\n  }\n}\n\ntype FunctionLike =\n  | BabelTypes.ArrowFunctionExpression\n  | BabelTypes.FunctionExpression\n  | BabelTypes.FunctionDeclaration\n  | BabelTypes.ObjectMethod;\n\n/**\n * Simple \"best effort\" to get the base name of a file path. Not fool proof but\n * works in browsers and servers. Good enough for our purposes.\n */\nfunction basename(filename: string | undefined): string | undefined {\n  return filename?.split(/[\\\\/]/).pop();\n}\n\nconst DefaultExportSymbol = Symbol(\"DefaultExportSymbol\");\n\nfunction getObjectPropertyKey(\n  node: BabelTypes.ObjectProperty | BabelTypes.ObjectMethod\n): string | null {\n  if (node.key.type === \"Identifier\") {\n    return node.key.name;\n  } else if (node.key.type === \"StringLiteral\") {\n    return node.key.value;\n  }\n\n  return null;\n}\n/**\n * If the function node has a name (i.e. is a function declaration with a\n * name), return that. Else return null.\n */\nfunction getFunctionNodeName(path: NodePath<FunctionLike>): string | null {\n  if (\n    (path.node.type === \"FunctionDeclaration\" ||\n      path.node.type === \"FunctionExpression\") &&\n    path.node.id\n  ) {\n    return path.node.id.name;\n  } else if (path.node.type === \"ObjectMethod\") {\n    return getObjectPropertyKey(path.node);\n  }\n\n  return null;\n}\n\n/**\n * Given a function path's parent path, determine the \"name\" associated with the\n * function. If the function is an inline default export (e.g. `export default\n * () => {}`), returns a symbol indicating it is a default export. If the\n * function is an anonymous function wrapped in higher order functions (e.g.\n * memo(() => {})) we'll climb through the higher order functions to find the\n * name of the variable that the function is assigned to, if any. Other cases\n * handled too (see implementation). Else returns null.\n */\nfunction getFunctionNameFromParent(\n  parentPath: NodePath<BabelTypes.Node>\n): string | null | typeof DefaultExportSymbol {\n  if (\n    parentPath.node.type === \"VariableDeclarator\" &&\n    parentPath.node.id.type === \"Identifier\"\n  ) {\n    return parentPath.node.id.name;\n  } else if (parentPath.node.type === \"AssignmentExpression\") {\n    const left = parentPath.node.left;\n    if (left.type === \"Identifier\") {\n      return left.name;\n    } else if (left.type === \"MemberExpression\") {\n      let property = left.property;\n      while (property.type === \"MemberExpression\") {\n        property = property.property;\n      }\n\n      if (property.type === \"Identifier\") {\n        return property.name;\n      } else if (property.type === \"StringLiteral\") {\n        return property.value;\n      }\n\n      return null;\n    } else {\n      return null;\n    }\n  } else if (parentPath.node.type === \"ObjectProperty\") {\n    return getObjectPropertyKey(parentPath.node);\n  } else if (parentPath.node.type === \"ExportDefaultDeclaration\") {\n    return DefaultExportSymbol;\n  } else if (\n    parentPath.node.type === \"CallExpression\" &&\n    parentPath.parentPath != null\n  ) {\n    // If our parent is a Call Expression, then this function expression is\n    // wrapped in some higher order functions. Recurse through the higher order\n    // functions to determine if this expression is assigned to a name we can\n    // use as the function name\n    return getFunctionNameFromParent(parentPath.parentPath);\n  } else {\n    return null;\n  }\n}\n\n/* Determine the name of a function */\nfunction getFunctionName(\n  path: NodePath<FunctionLike>\n): string | typeof DefaultExportSymbol | null {\n  let nodeName = getFunctionNodeName(path);\n  if (nodeName) {\n    return nodeName;\n  }\n\n  return getFunctionNameFromParent(path.parentPath);\n}\n\nfunction isComponentName(name: string | null): boolean {\n  return name?.match(/^[A-Z]/) != null ?? false;\n}\n\nfunction hasLeadingComment(path: NodePath, comment: RegExp): boolean {\n  const comments = path.node.leadingComments;\n  return comments?.some((c) => c.value.match(comment) !== null) ?? false;\n}\n\nfunction hasLeadingOptInComment(path: NodePath) {\n  return hasLeadingComment(path, optInCommentIdentifier);\n}\n\nfunction hasLeadingOptOutComment(path: NodePath) {\n  return hasLeadingComment(path, optOutCommentIdentifier);\n}\n\nfunction isOptedIntoSignalTracking(path: NodePath | null): boolean {\n  if (!path) return false;\n\n  switch (path.node.type) {\n    case \"ArrowFunctionExpression\":\n    case \"FunctionExpression\":\n    case \"FunctionDeclaration\":\n    case \"ObjectMethod\":\n    case \"ObjectExpression\":\n    case \"VariableDeclarator\":\n    case \"VariableDeclaration\":\n    case \"AssignmentExpression\":\n    case \"CallExpression\":\n      return (\n        hasLeadingOptInComment(path) ||\n        isOptedIntoSignalTracking(path.parentPath)\n      );\n    case \"ExportDefaultDeclaration\":\n    case \"ExportNamedDeclaration\":\n    case \"ObjectProperty\":\n    case \"ExpressionStatement\":\n      return hasLeadingOptInComment(path);\n    default:\n      return false;\n  }\n}\n\nfunction isOptedOutOfSignalTracking(path: NodePath | null): boolean {\n  if (!path) return false;\n\n  switch (path.node.type) {\n    case \"ArrowFunctionExpression\":\n    case \"FunctionExpression\":\n    case \"FunctionDeclaration\":\n    case \"ObjectMethod\":\n    case \"ObjectExpression\":\n    case \"VariableDeclarator\":\n    case \"VariableDeclaration\":\n    case \"AssignmentExpression\":\n    case \"CallExpression\":\n      return (\n        hasLeadingOptOutComment(path) ||\n        isOptedOutOfSignalTracking(path.parentPath)\n      );\n    case \"ExportDefaultDeclaration\":\n    case \"ExportNamedDeclaration\":\n    case \"ObjectProperty\":\n    case \"ExpressionStatement\":\n      return hasLeadingOptOutComment(path);\n    default:\n      return false;\n  }\n}\n\nfunction isComponentFunction(\n  path: NodePath<FunctionLike>,\n  functionName: string | null\n): boolean {\n  return (\n    getData(path.scope, containsJSX) === true && // Function contains JSX\n    isComponentName(functionName) // Function name indicates it's a component\n  );\n}\n\nfunction shouldTransform(\n  path: NodePath<FunctionLike>,\n  functionName: string | null,\n  options: PluginOptions\n): boolean {\n  // Opt-out takes first precedence\n  if (isOptedOutOfSignalTracking(path)) return false;\n  // Opt-in opts in to transformation regardless of mode\n  if (isOptedIntoSignalTracking(path)) return true;\n\n  if (options.mode === \"all\") {\n    return isComponentFunction(path, functionName);\n  }\n\n  if (options.mode == null || options.mode === \"auto\") {\n    return (\n      getData(path.scope, maybeUsesSignal) === true && // Function appears to use signals;\n      isComponentFunction(path, functionName)\n    );\n  }\n\n  return false;\n}\n\nfunction isValueMemberExpression(\n  path: NodePath<BabelTypes.MemberExpression>\n): boolean {\n  return (\n    (path.node.property.type === \"Identifier\" &&\n      path.node.property.name === \"value\") ||\n    (path.node.property.type === \"StringLiteral\" &&\n      path.node.property.value === \"value\")\n  );\n}\n\nconst tryCatchTemplate = template.statements`var STORE_IDENTIFIER = HOOK_IDENTIFIER();\ntry {\n\tBODY\n} finally {\n\tSTORE_IDENTIFIER.f();\n}`;\n\nfunction wrapInTryFinally(\n  t: typeof BabelTypes,\n  path: NodePath<FunctionLike>,\n  state: PluginPass\n): FunctionLike {\n  const stopTrackingIdentifier = path.scope.generateUidIdentifier(\"effect\");\n\n  const newFunction = t.cloneNode(path.node);\n  newFunction.body = t.blockStatement(\n    tryCatchTemplate({\n      STORE_IDENTIFIER: stopTrackingIdentifier,\n      HOOK_IDENTIFIER: get(state, getHookIdentifier)(),\n      BODY: t.isBlockStatement(path.node.body)\n        ? path.node.body.body // TODO: Is it okay to elide the block statement here?\n        : t.returnStatement(path.node.body),\n    })\n  );\n\n  return newFunction;\n}\n\nfunction transformFunction(\n  t: typeof BabelTypes,\n  options: PluginOptions,\n  path: NodePath<FunctionLike>,\n  functionName: string | null,\n  state: PluginPass\n) {\n  const newFunction: FunctionLike = wrapInTryFinally(t, path, state);\n  // if (isCustomHook(functionName) || options.experimental?.noTryFinally) {\n  //   // For custom hooks, we don't need to wrap the function body in a\n  //   // try/finally block because later code in the function's render body could\n  //   // read signals and we want to track and associate those signals with this\n  //   // component. The try/finally in the component's body will stop tracking\n  //   // signals for us instead.\n  //   newFunction = prependUseSignals(t, path, state);\n  // } else {\n  // }\n\n  // Using replaceWith keeps the existing leading comments already so\n  // we'll clear our cloned node's leading comments to ensure they\n  // aren't duplicated in the output.\n  newFunction.leadingComments = newFunction.leadingComments?.filter(\n    (c) =>\n      !c.value.match(optOutCommentIdentifier) &&\n      !c.value.match(optInCommentIdentifier)\n  );\n\n  setData(path, alreadyTransformed, true);\n  path.replaceWith(newFunction);\n}\n\nfunction createImportLazily(\n  t: typeof BabelTypes,\n  pass: PluginPass,\n  path: NodePath<BabelTypes.Program>,\n  importName: string,\n  source: string\n): () => BabelTypes.Identifier | BabelTypes.MemberExpression {\n  return () => {\n    if (isModule(path)) {\n      let reference: BabelTypes.Identifier = get(pass, `imports/${importName}`);\n      if (reference) return t.cloneNode(reference);\n      /* const direcitves: BabelTypes.Statement[] = [];\n      for (let statement of path.get(\"body\")) {\n        if (statement.isStringLiteral()) {\n          direcitves.push(statement.node);\n        }\n      } */\n      reference = addNamed(path, importName, source, {\n        importedInterop: \"uncompiled\",\n        importPosition: \"after\",\n      });\n      set(pass, `imports/${importName}`, reference);\n\n      const matchesImportName = (\n        s: BabelTypes.ImportDeclaration[\"specifiers\"][0]\n      ) => {\n        if (s.type !== \"ImportSpecifier\") return false;\n        return (\n          (s.imported.type === \"Identifier\" &&\n            s.imported.name === importName) ||\n          (s.imported.type === \"StringLiteral\" &&\n            s.imported.value === importName)\n        );\n      };\n\n      for (let statement of path.get(\"body\")) {\n        if (\n          statement.isImportDeclaration() &&\n          statement.node.source.value === source &&\n          statement.node.specifiers.some(matchesImportName)\n        ) {\n          path.scope.registerDeclaration(statement);\n          break;\n        }\n      }\n      return reference;\n    } else {\n      let reference = get(pass, `requires/${importName}`);\n      if (reference) {\n        reference = t.cloneNode(reference);\n      } else {\n        reference = addNamed(path, importName, source, {\n          importedInterop: \"uncompiled\",\n        });\n        set(pass, `requires/${importName}`, reference);\n      }\n\n      return reference;\n    }\n  };\n}\n\nexport interface PluginOptions {\n  /**\n   * Specify the mode to use:\n   * - `auto`: Automatically wrap all components that use signals.\n   * - `manual`: Only wrap components that are annotated with `@useSignals` in a JSX comment.\n   * - `all`: Makes all components reactive to signals.\n   *   @default \"all\"\n   */\n  mode?: \"auto\" | \"manual\" | \"all\";\n  /** Specify a custom package to import the `useSignals` hook from.\n   * @default \"@preact-signals/safe-react/tracking\"\n   */\n  importSource?: string;\n  experimental?: {\n    // apliable only to swc plugin\n    addHookUsageFlag?: boolean;\n  };\n}\n\nfunction log(\n  transformed: boolean,\n  path: NodePath<FunctionLike>,\n  functionName: string | null,\n  currentFile: string | undefined\n) {\n  if (!logger.transformed.enabled && !logger.skipped.enabled) return;\n\n  let cwd = \"\";\n  if (typeof process !== undefined && typeof process.cwd == \"function\") {\n    cwd = process.cwd().replace(/\\\\([^ ])/g, \"/$1\");\n    cwd = cwd.endsWith(\"/\") ? cwd : cwd + \"/\";\n  }\n\n  const relativePath = currentFile?.replace(cwd, \"\") ?? \"\";\n  const lineNum = path.node.loc?.start.line;\n  functionName = functionName ?? \"<anonymous>\";\n\n  if (transformed) {\n    logger.transformed(`${functionName} (${relativePath}:${lineNum})`);\n  } else {\n    logger.skipped(`${functionName} (${relativePath}:${lineNum}) %o`, {\n      hasSignals: getData(path.scope, maybeUsesSignal) ?? false,\n      hasJSX: getData(path.scope, containsJSX) ?? false,\n    });\n  }\n}\n\nfunction isComponentLike(\n  path: NodePath<FunctionLike>,\n  functionName: string | null\n): boolean {\n  return !getData(path, alreadyTransformed) && isComponentName(functionName);\n}\n\nexport default function signalsTransform(\n  { types: t }: PluginArgs,\n  options: PluginOptions\n): PluginObj {\n  options.mode ??= \"all\";\n  // TODO: Consider alternate implementation, where on enter of a function\n  // expression, we run our own manual scan the AST to determine if the\n  // function uses signals and is a component. This manual scan once upon\n  // seeing a function would probably be faster than running an entire\n  // babel pass with plugins on components twice.\n  const visitFunction: VisitNodeObject<PluginPass, FunctionLike> = {\n    exit(path, state) {\n      if (getData(path, alreadyTransformed) === true) return false;\n\n      let functionName = getFunctionName(path);\n      if (functionName === DefaultExportSymbol) {\n        functionName = basename(this.filename) ?? null;\n      }\n\n      if (shouldTransform(path, functionName, state.opts)) {\n        transformFunction(t, state.opts, path, functionName, state);\n        log(true, path, functionName, this.filename);\n      } else if (isComponentLike(path, functionName)) {\n        log(false, path, functionName, this.filename);\n      }\n    },\n  };\n\n  return {\n    name: dataNamespace,\n    visitor: {\n      Program: {\n        enter(path, state) {\n          // Following the pattern of babel-plugin-transform-react-jsx, we\n          // lazily create the import statement for the useSignalTracking hook.\n          // We create a function and store it in the PluginPass object, so that\n          // on the first usage of the hook, we can create the import statement.\n          set(\n            state,\n            getHookIdentifier,\n            createImportLazily(\n              t,\n              state,\n              path,\n              importName,\n              options.importSource ?? defaultImportSource\n            )\n          );\n        },\n      },\n\n      ArrowFunctionExpression: visitFunction,\n      FunctionExpression: visitFunction,\n      FunctionDeclaration: visitFunction,\n      ObjectMethod: visitFunction,\n\n      MemberExpression(path) {\n        if (isValueMemberExpression(path)) {\n          setOnFunctionScope(path, maybeUsesSignal, true);\n        }\n      },\n\n      JSXElement(path) {\n        setOnFunctionScope(path, containsJSX, true);\n      },\n      JSXFragment(path) {\n        setOnFunctionScope(path, containsJSX, true);\n      },\n    },\n  };\n}\n"],"names":["template","importName","isModule","addNamed","_a"],"mappings":"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"}