declare const _exports: {
    createElement: import("./types").JSXFunction;
    createFactory<T extends HTMLElement>(type: keyof React.ReactHTML): React.HTMLFactory<T>;
    createFactory(type: keyof React.ReactSVG): React.SVGFactory;
    createFactory<P extends React.DOMAttributes<T_1>, T_1 extends Element>(type: string): React.DOMFactory<P, T_1>;
    createFactory<P_1>(type: React.FunctionComponent<P_1>): React.FunctionComponentFactory<P_1>;
    createFactory<P_2, T_2 extends React.Component<P_2, any, any>, C extends React.ComponentClass<P_2, any>>(type: React.ClassType<P_2, T_2, C>): React.CFactory<P_2, T_2>;
    createFactory<P_3>(type: React.ComponentClass<P_3, any>): React.Factory<P_3>;
    cloneElement<P_4 extends React.HTMLAttributes<T_3>, T_3 extends HTMLElement>(element: React.DetailedReactHTMLElement<P_4, T_3>, props?: P_4 | undefined, ...children: React.ReactNode[]): React.DetailedReactHTMLElement<P_4, T_3>;
    cloneElement<P_5 extends React.HTMLAttributes<T_4>, T_4 extends HTMLElement>(element: React.ReactHTMLElement<T_4>, props?: P_5 | undefined, ...children: React.ReactNode[]): React.ReactHTMLElement<T_4>;
    cloneElement<P_6 extends React.SVGAttributes<T_5>, T_5 extends SVGElement>(element: React.ReactSVGElement, props?: P_6 | undefined, ...children: React.ReactNode[]): React.ReactSVGElement;
    cloneElement<P_7 extends React.DOMAttributes<T_6>, T_6 extends Element>(element: React.DOMElement<P_7, T_6>, props?: (React.DOMAttributes<T_6> & P_7) | undefined, ...children: React.ReactNode[]): React.DOMElement<P_7, T_6>;
    cloneElement<P_8>(element: React.FunctionComponentElement<P_8>, props?: (Partial<P_8> & React.Attributes) | undefined, ...children: React.ReactNode[]): React.FunctionComponentElement<P_8>;
    cloneElement<P_9, T_7 extends React.Component<P_9, any, any>>(element: React.CElement<P_9, T_7>, props?: (Partial<P_9> & React.ClassAttributes<T_7>) | undefined, ...children: React.ReactNode[]): React.CElement<P_9, T_7>;
    cloneElement<P_10>(element: React.ReactElement<P_10, string | React.JSXElementConstructor<any>>, props?: (Partial<P_10> & React.Attributes) | undefined, ...children: React.ReactNode[]): React.ReactElement<P_10, string | React.JSXElementConstructor<any>>;
    createContext<T_8>(defaultValue: T_8): React.Context<T_8>;
    isValidElement<P_11>(object: {} | null | undefined): object is React.ReactElement<P_11, string | React.JSXElementConstructor<any>>;
    createRef<T_9>(): React.RefObject<T_9>;
    forwardRef<T_10, P_12 = {}>(render: React.ForwardRefRenderFunction<T_10, P_12>): React.ForwardRefExoticComponent<React.PropsWithoutRef<P_12> & React.RefAttributes<T_10>>;
    memo<P_13 extends object>(Component: React.FunctionComponent<P_13>, propsAreEqual?: ((prevProps: Readonly<P_13>, nextProps: Readonly<P_13>) => boolean) | undefined): React.NamedExoticComponent<P_13>;
    memo<T_11 extends React.ComponentType<any>>(Component: T_11, propsAreEqual?: ((prevProps: Readonly<React.ComponentProps<T_11>>, nextProps: Readonly<React.ComponentProps<T_11>>) => boolean) | undefined): React.MemoExoticComponent<T_11>;
    lazy<T_12 extends React.ComponentType<any>>(load: () => Promise<{
        default: T_12;
    }>): React.LazyExoticComponent<T_12>;
    useContext<T_13>(context: React.Context<T_13>): T_13;
    useState<S>(initialState: S | (() => S)): [S, React.Dispatch<React.SetStateAction<S>>];
    useState<S_1 = undefined>(): [S_1 | undefined, React.Dispatch<React.SetStateAction<S_1 | undefined>>];
    useReducer<R extends React.ReducerWithoutAction<any>, I>(reducer: R, initializerArg: I, initializer: (arg: I) => React.ReducerStateWithoutAction<R>): [React.ReducerStateWithoutAction<R>, React.DispatchWithoutAction];
    useReducer<R_1 extends React.ReducerWithoutAction<any>>(reducer: R_1, initializerArg: React.ReducerStateWithoutAction<R_1>, initializer?: undefined): [React.ReducerStateWithoutAction<R_1>, React.DispatchWithoutAction];
    useReducer<R_2 extends React.Reducer<any, any>, I_1>(reducer: R_2, initializerArg: I_1 & React.ReducerState<R_2>, initializer: (arg: I_1 & React.ReducerState<R_2>) => React.ReducerState<R_2>): [React.ReducerState<R_2>, React.Dispatch<React.ReducerAction<R_2>>];
    useReducer<R_3 extends React.Reducer<any, any>, I_2>(reducer: R_3, initializerArg: I_2, initializer: (arg: I_2) => React.ReducerState<R_3>): [React.ReducerState<R_3>, React.Dispatch<React.ReducerAction<R_3>>];
    useReducer<R_4 extends React.Reducer<any, any>>(reducer: R_4, initialState: React.ReducerState<R_4>, initializer?: undefined): [React.ReducerState<R_4>, React.Dispatch<React.ReducerAction<R_4>>];
    useRef<T_14>(initialValue: T_14): React.MutableRefObject<T_14>;
    useRef<T_15>(initialValue: T_15 | null): React.RefObject<T_15>;
    useRef<T_16 = undefined>(): React.MutableRefObject<T_16 | undefined>;
    useLayoutEffect(effect: React.EffectCallback, deps?: React.DependencyList | undefined): void;
    useEffect(effect: React.EffectCallback, deps?: React.DependencyList | undefined): void;
    useImperativeHandle<T_17, R_5 extends T_17>(ref: React.Ref<T_17> | undefined, init: () => R_5, deps?: React.DependencyList | undefined): void;
    useCallback<T_18 extends Function>(callback: T_18, deps: React.DependencyList): T_18;
    useMemo<T_19>(factory: () => T_19, deps: React.DependencyList): T_19;
    useDebugValue<T_20>(value: T_20, format?: ((value: T_20) => any) | undefined): void;
    useDeferredValue<T_21>(value: T_21): T_21;
    useTransition(): [boolean, React.TransitionStartFunction];
    startTransition(scope: React.TransitionFunction): void;
    useId(): string;
    useInsertionEffect(effect: React.EffectCallback, deps?: React.DependencyList | undefined): void;
    useSyncExternalStore<Snapshot>(subscribe: (onStoreChange: () => void) => () => void, getSnapshot: () => Snapshot, getServerSnapshot?: (() => Snapshot) | undefined): Snapshot;
    Children: {
        map<T_22, C_1>(children: C_1 | readonly C_1[], fn: (child: C_1, index: number) => T_22): C_1 extends null | undefined ? C_1 : Exclude<T_22, boolean | null | undefined>[];
        forEach<C_2>(children: C_2 | readonly C_2[], fn: (child: C_2, index: number) => void): void;
        count(children: any): number;
        only<C_3>(children: C_3): C_3 extends any[] ? never : C_3;
        toArray(children: React.ReactNode | React.ReactNode[]): (string | number | React.ReactElement<any, string | React.JSXElementConstructor<any>> | Iterable<React.ReactNode> | React.ReactPortal)[];
    };
    Fragment: React.ExoticComponent<{
        children?: React.ReactNode;
    }>;
    StrictMode: React.ExoticComponent<{
        children?: React.ReactNode;
    }>;
    Suspense: React.ExoticComponent<React.SuspenseProps>;
    version: string;
    Profiler: React.ExoticComponent<React.ProfilerProps>;
    Component: typeof React.Component;
    PureComponent: typeof React.PureComponent;
};
export = _exports;
import React = require("react");
