declare const symDispose: unique symbol;
declare const enum EffectFields {
    startTracking = "S",
    onDepsChange = "c",
    dispose = "d"
}
interface Effect {
    [EffectFields.startTracking](): () => void;
    [EffectFields.onDepsChange](): void;
    [EffectFields.dispose](): void;
}
declare const enum EffectStoreFields {
    startTracking = "s",
    finishTracking = "f",
    resetSyncRerenders = "r"
}
export interface EffectStore {
    effect: Effect;
    subscribe(onStoreChange: () => void): () => void;
    getSnapshot(): number;
    /** finishEffect - stop tracking the signals used in this component */
    [EffectStoreFields.finishTracking](): void;
    [EffectStoreFields.startTracking](): void;
    [EffectStoreFields.resetSyncRerenders](): void;
    [symDispose](): void;
}
/**
 * @description this hook is for `@preact/signals-react-transform`. You should not use it until you know what you do. If s.f() is not called - reactivity will break
 * @example
 * ```tsx
 * const Component = () => {
 *  const s = useSignals()
 *  try {
 *    // reading signals and using hooks here
 *    const counter = useSignal(0)
 *
 *    return (
 *      <button onClick={() => counter.value++}>Click here: {counter.value * 2}</button>
 *    )
 *  } finally {
 *    s.f()
 *  }
 * }
 * ```
 * Custom hook to create the effect to track signals used during render and
 * subscribe to changes to rerender the component when the signals change.
 */
export declare function useSignals(): EffectStore;
export {};
