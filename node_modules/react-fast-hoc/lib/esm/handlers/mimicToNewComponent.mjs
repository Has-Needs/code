class MimicToNewComponentHandler {
  constructor() {
    this._componentProps = /* @__PURE__ */ new WeakMap();
  }
  get(target, p, receiver) {
    const overridenProps = this._componentProps.get(target);
    if (overridenProps && overridenProps.has(p)) {
      return overridenProps.get(p);
    }
    return Reflect.get(target, p, receiver);
  }
  set(target, p, value) {
    const overridenProps = this._componentProps.get(target);
    if (overridenProps) {
      overridenProps.set(p, value);
      return true;
    }
    this._componentProps.set(target, /* @__PURE__ */ new Map([[p, value]]));
    return true;
  }
  defineProperty(target, property, attributes) {
    if (!("value" in attributes)) {
      console.error("Only value property is supported");
      return false;
    }
    const overridenProps = this._componentProps.get(target);
    if (overridenProps) {
      overridenProps.set(property, attributes.value);
      return true;
    }
    this._componentProps.set(target, /* @__PURE__ */ new Map([[property, attributes.value]]));
    return true;
  }
  deleteProperty(target, p) {
    const overridenProps = this._componentProps.get(target);
    if (overridenProps) {
      overridenProps.delete(p);
      return true;
    }
    return Reflect.deleteProperty(target, p);
  }
  has(target, prop) {
    var _a;
    return ((_a = this._componentProps.get(target)) == null ? void 0 : _a.has(prop)) || Reflect.has(target, prop);
  }
}

export { MimicToNewComponentHandler };
//# sourceMappingURL=mimicToNewComponent.mjs.map
