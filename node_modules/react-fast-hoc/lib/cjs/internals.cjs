'use strict';

const toFunctional = require('./toFunctional.cjs');

const isRef = (maybeRef) => maybeRef === null || typeof maybeRef === "function" || !!maybeRef && typeof maybeRef === "object" && "current" in maybeRef;
const wrapPropsTransformer = (transformer) => (args) => {
  let [_props, ref] = args;
  const props = Object.assign(/* @__PURE__ */ Object.create(null), _props);
  const hasRef = isRef(ref);
  if (hasRef) {
    props.ref = ref;
  }
  const resultProps = transformer(props);
  const resultRef = "ref" in resultProps && resultProps["ref"];
  if ("ref" in resultProps) {
    delete resultProps.ref;
  }
  return [resultProps, hasRef && isRef(resultRef) ? resultRef : ref];
};
const REACT_MEMO_TYPE = Symbol.for("react.memo");
const REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
const REACT_LAZY_TYPE = Symbol.for("react.lazy");
const wrapFCWithForwardRefOrPlain = (Component, handler) => {
  if ("$$typeof" in Component && Component["$$typeof"] === REACT_FORWARD_REF_TYPE) {
    return {
      $$typeof: REACT_FORWARD_REF_TYPE,
      render: new Proxy(
        Component.render,
        handler
      )
    };
  }
  return new Proxy(
    Component,
    handler
  );
};
const wrapComponentIntoHoc = (Component, handler, mimicToNewComponentHandler) => {
  if (toFunctional.isClassComponent(Component)) {
    return wrapFCWithForwardRefOrPlain(
      toFunctional.toFunctional(Component),
      handler
    );
  }
  if ("$$typeof" in Component && Component["$$typeof"] === REACT_MEMO_TYPE) {
    return {
      $$typeof: REACT_MEMO_TYPE,
      type: wrapComponentIntoHoc(Component.type, handler, null),
      compare: Component.compare
    };
  }
  if ("$$typeof" in Component && Component["$$typeof"] === REACT_FORWARD_REF_TYPE) {
    return {
      $$typeof: REACT_FORWARD_REF_TYPE,
      // render is always function
      render: new Proxy(Component.render, handler)
    };
  }
  if ("$$typeof" in Component && Component["$$typeof"] === REACT_LAZY_TYPE) {
    let result;
    return {
      $$typeof: REACT_LAZY_TYPE,
      _payload: Component._payload,
      _init: (arg) => {
        const initRes = Component._init(arg);
        if (!result) {
          result = wrapComponentIntoHoc(
            initRes,
            handler,
            null
          );
        }
        return result;
      }
    };
  }
  const proxied = new Proxy(Component, handler);
  return mimicToNewComponentHandler ? new Proxy(
    proxied,
    mimicToNewComponentHandler
  ) : proxied;
};

exports.isRef = isRef;
exports.wrapComponentIntoHoc = wrapComponentIntoHoc;
exports.wrapPropsTransformer = wrapPropsTransformer;
//# sourceMappingURL=internals.cjs.map
