{"version":3,"file":"internals.cjs","sources":["../../src/internals.ts"],"sourcesContent":["import React, { isValidElement, type ReactNode, type Ref } from \"react\";\nimport type { HocTransformer, MimicToNewComponentHandler } from \"./handlers\";\nimport { isClassComponent, toFunctional, type Get } from \"./toFunctional\";\n\nexport const isRef = <T = unknown>(maybeRef: unknown): maybeRef is Ref<T> =>\n  maybeRef === null ||\n  typeof maybeRef === \"function\" ||\n  (!!maybeRef && typeof maybeRef === \"object\" && \"current\" in maybeRef);\n\nexport const wrapPropsTransformer =\n  <T extends object, R extends object>(transformer: (arg: T) => R) =>\n  (args: [Omit<T, \"ref\">, Get<T, \"ref\">]) => {\n    let [_props, ref] = args;\n    // props are immutable, because of should stable while rerenders,\n    // so wrapping it into props transform hoc has overhead\n    const props = Object.assign(Object.create(null), _props);\n\n    const hasRef = isRef(ref);\n    if (hasRef) {\n      (props as any).ref = ref;\n    }\n\n    type RealProps = T & { ref: Get<T, \"ref\"> };\n\n    const resultProps = transformer(props as RealProps);\n    const resultRef = \"ref\" in resultProps && resultProps[\"ref\"];\n    if (\"ref\" in resultProps) {\n      delete (resultProps as R & { ref?: unknown }).ref;\n    }\n\n    return [resultProps, hasRef && isRef(resultRef) ? resultRef : ref] as const;\n  };\n\nconst REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\nconst REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\nconst REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n\ntype RealComponentType<TProps extends object, IRef = unknown> =\n  | {\n      $$typeof: typeof REACT_FORWARD_REF_TYPE;\n      render: (props: TProps, ref: null | Ref<IRef>) => ReactNode;\n    }\n  | {\n      $$typeof: typeof REACT_MEMO_TYPE;\n      compare: null | ((a: TProps, b: TProps) => boolean);\n      type: RealComponentType<TProps, IRef>;\n    }\n  | {\n      $$typeof: typeof REACT_LAZY_TYPE;\n      _payload: {\n        _status: -1 | 0 | 1 | 2;\n        _result: unknown;\n      };\n      // returns component or throws promise\n      _init: (arg: unknown) => React.ComponentType<unknown>;\n    }\n  | React.ComponentClass<TProps>\n  | React.FC<TProps>;\n\ntype ReactFunctionalComponentType<\n  TProps extends object,\n  IRef = unknown\n> = Extract<\n  RealComponentType<TProps, IRef>,\n  { $$typeof: typeof REACT_FORWARD_REF_TYPE } | React.FC<TProps>\n>;\n\ntype ForwardRefComponent<TProps extends object> = Extract<\n  ReactFunctionalComponentType<TProps>,\n  { $$typeof: typeof REACT_FORWARD_REF_TYPE }\n>;\ntype RegularFunctionComponent<TProps extends object> = Exclude<\n  ReactFunctionalComponentType<TProps>,\n  ForwardRefComponent<TProps>\n>;\nconst wrapFCWithForwardRefOrPlain = <TProps extends object>(\n  Component: ReactFunctionalComponentType<TProps>,\n  handler: HocTransformer\n): ForwardRefComponent<TProps> | ReactFunctionalComponentType<TProps> => {\n  if (\n    \"$$typeof\" in Component &&\n    Component[\"$$typeof\"] === REACT_FORWARD_REF_TYPE\n  ) {\n    return {\n      $$typeof: REACT_FORWARD_REF_TYPE,\n      render: new Proxy(\n        (Component as ForwardRefComponent<TProps>).render,\n        handler\n      ),\n    } as ForwardRefComponent<TProps>;\n  }\n  return new Proxy(\n    Component as Function,\n    handler\n  ) as RegularFunctionComponent<TProps>;\n};\n\n// I don't know why but typescript is not helpful at all\n\n// Component can be memo class component or wrapped in hoc functional component\n/**\n *\n * @internal\n * @param Component\n * @param handler\n * @param mimicToNewComponentHandler\n * @returns\n */\nexport const wrapComponentIntoHoc = <TProps extends object>(\n  Component: RealComponentType<TProps>,\n  handler: HocTransformer,\n  mimicToNewComponentHandler: null | MimicToNewComponentHandler\n): unknown => {\n  // should use isValidElementType\n  // if (process.env.NODE_ENV === \"development\" && !isValidElement(Component)) {\n  //   console.warn(\"react-fast-hoc: passed incorrect component for transform\");\n  //   return Component;\n  // }\n  // this case assumes that it's ClassComponent\n  if (isClassComponent(Component)) {\n    return wrapFCWithForwardRefOrPlain(\n      toFunctional(Component) as React.FC<TProps>,\n      handler\n    );\n  }\n\n  if (\"$$typeof\" in Component && Component[\"$$typeof\"] === REACT_MEMO_TYPE) {\n    return {\n      $$typeof: REACT_MEMO_TYPE,\n      type: wrapComponentIntoHoc(Component.type, handler, null),\n      compare: Component.compare,\n    };\n  }\n\n  if (\n    \"$$typeof\" in Component &&\n    Component[\"$$typeof\"] === REACT_FORWARD_REF_TYPE\n  ) {\n    return {\n      $$typeof: REACT_FORWARD_REF_TYPE,\n      // render is always function\n      render: new Proxy(Component.render, handler),\n    };\n  }\n  if (\"$$typeof\" in Component && Component[\"$$typeof\"] === REACT_LAZY_TYPE) {\n    let result: RealComponentType<any>;\n    return {\n      $$typeof: REACT_LAZY_TYPE,\n      _payload: Component._payload,\n      _init: (arg: unknown) => {\n        const initRes = Component._init(arg);\n        if (!result) {\n          result = wrapComponentIntoHoc(\n            initRes,\n            handler,\n            null\n          ) as RealComponentType<any>;\n        }\n        return result;\n      },\n    } as RealComponentType<any>;\n  }\n\n  const proxied = new Proxy(Component, handler);\n\n  return mimicToNewComponentHandler\n    ? (new Proxy(\n        proxied,\n        mimicToNewComponentHandler\n      ) as RealComponentType<TProps>)\n    : proxied;\n};\n"],"names":["isClassComponent","toFunctional"],"mappings":"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"}