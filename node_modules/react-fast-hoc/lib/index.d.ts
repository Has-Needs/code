import { ComposeLeft, Objects, Booleans, Fn, Call, Identity } from 'hotscript';
import { Simplify } from 'type-fest';
import * as React$1 from 'react';
import React__default, { ComponentPropsWithRef, ComponentType, MemoExoticComponent, ForwardRefExoticComponent, FunctionComponent, ElementType, ReactNode } from 'react';

/**
 * type alias for the result of the transformProps function.
 */
type TransformPropsReturn<TComponent extends React.ComponentType<any>, TNewProps extends PropsBase> = WrappedComponent<ComposeLeft<[Objects.OmitBy<Booleans.Not<never>>, Objects.Assign<TNewProps>]>, any, TComponent>;
type TransformProps = <TComponent extends React.ComponentType<any>, TNewProps extends PropsBase = ComponentPropsWithRef<TComponent>, TPreviousProps extends ComponentPropsWithRef<TComponent> = ComponentPropsWithRef<TComponent>>(Component: TComponent, transformer: (props: TNewProps) => TPreviousProps, options?: CreateTransformPropsOptions) => TransformPropsReturn<TComponent, TNewProps>;
type PropsBase = Record<string | number | symbol, any>;
/**
 * Returns new comonent types after wrapping into hoc
 */
type ChangeComponentProps<TComponent extends ComponentType<any>, TNewProps> = TComponent extends MemoExoticComponent<infer TNested> ? MemoExoticComponent<TNested extends React.ComponentClass<any, any> ? ForwardRefExoticComponent<TNewProps> : FunctionComponent<TNewProps>> : TComponent extends ForwardRefExoticComponent<any> ? ForwardRefExoticComponent<TNewProps> : TComponent extends React.ComponentClass<any, any> ? ForwardRefExoticComponent<TNewProps> : TComponent extends FunctionComponent<any> ? FunctionComponent<TNewProps> : never;
/**
 * Returns a wrapped component with transformed props
 */
type WrappedComponent<TPipeTransform extends Fn, TComponentPropsExtends extends object, TComponent extends ComponentType<any>, TComputedProps extends TComponentPropsExtends = TComponent extends ElementType<any> ? ComponentPropsWithRef<TComponent> : never> = ChangeComponentProps<TComponent, Call<TPipeTransform, TComputedProps>>;
type HocTypeTransform<TType extends "props" | "component", T extends Fn> = {
    type: TType;
    fn: T;
};
/**
 * Higher-order component that wraps the input component
 * with the provided transformation pipeline and new component props.
 */
type WrappedComponentCreator<TPipeTransform extends HocTypeTransform<any, any>, TComponentPropsExtends extends object> = <TComponent extends ComponentType<any> = React.FC<any>>(component: TComponent) => TPipeTransform extends HocTypeTransform<"props", infer TPropsTransform> ? WrappedComponent<TPropsTransform, TComponentPropsExtends, TComponent> : TPipeTransform extends HocTypeTransform<"component", infer TComponentTransform> ? Call<TComponentTransform, TComponent> : never;
type CreateHocReturn<TPipeTransform extends HocTypeTransform<any, any>, TComponentPropsExtends extends PropsBase = PropsBase> = WrappedComponentCreator<TPipeTransform, TComponentPropsExtends>;
type PropsTransformer = (props: Record<string | symbol | number, unknown>) => Record<string | symbol | number, unknown>;
type DisplayNameTransform = Extract<CreateHocNameOption, {
    displayNameTransform: {};
}>["displayNameTransform"];
type CreateHocNameOption = {
    /** @deprecated use displayNameTransform */
    nameRewrite: string;
} | {
    /** @deprecated use displayNameTransform */
    namePrefix: string;
} | {
    /**
     * @description its to useful to know what component is wrapped in hoc in devtools
     */
    displayNameTransform: {
        type: "rewrite";
        value: string;
    } | {
        type: "prefix";
        value: string;
    } | {
        type: "rewrite-dynamic";
        value: (name: string) => string;
    };
};
type CreateHocSharedOptions = {
    /**
     * @deprecated I have not found a use case for this option
     * @description This feature has overhead in terms of using another proxy
     * to you can easilty mutate and define new properties, and not change inital component
     * @default false
     */
    mimicToNewComponent?: boolean;
};
type CreateHocComponentOptions = Simplify<CreateHocNameOption & CreateHocSharedOptions>;
type CreateTransformPropsOptions = Simplify<Partial<CreateHocNameOption> & CreateHocSharedOptions>;
/**
 * represents the argument object for the createHoc function. It contains
 * the props and result transformers, and options for name prefix or rewrite.
 */
type CreateHocOptions = {
    /**
     * @description you can mutate props object
     */
    propsTransformer: null | PropsTransformer;
    resultTransformer: null | ((jsx: ReactNode) => ReactNode);
} & CreateHocComponentOptions;

/**
 * @description *Transformations is not typesafe, you should [hotscript](https://github.com/gvergnaud/HOTScript) for type transformation*
 * @param propsTransformer You can use react hooks in the transformer function.
 * @param displayNamePrefix
 * @returns
 */
declare const createHoc: <TPipeTransform extends Fn[] | HocTypeTransform<any, any>, TComponentPropsExtends extends PropsBase = PropsBase, TActualTransform extends HocTypeTransform<any, any> = TPipeTransform extends Fn[] ? HocTypeTransform<"props", ComposeLeft<TPipeTransform>> : TPipeTransform>(params: CreateHocOptions) => CreateHocReturn<TActualTransform, TComponentPropsExtends>;

/**
 *
 * @description create a hoc that automagically applies proxy to component. *Transformations is not typesafe, you should [hotscript](https://github.com/gvergnaud/HOTScript) for type transformation*
 * @example
 * ```tsx
 * const withProps = createTransformProps<[], { newProp: string }>((props) => ({
 *  ...props,
 *  newProp: props?.newProp ?? "newProp",
 * }));
 * ```
 * @param propsTransformer You can use react hooks in the transformer function
 * @param options
 * @returns
 */
declare const createTransformProps: <TPipeTransform extends Fn[] | HocTypeTransform<any, any> = HocTypeTransform<"props", Identity>, ComponentPropsExtends extends PropsBase = PropsBase, TActualTransform extends HocTypeTransform<any, any> = TPipeTransform extends Fn[] ? HocTypeTransform<"props", ComposeLeft<TPipeTransform>> : TPipeTransform>(propsTransformer: PropsTransformer, options?: CreateTransformPropsOptions) => CreateHocReturn<TActualTransform extends Fn[] ? HocTypeTransform<"props", ComposeLeft<TActualTransform>> : TActualTransform, ComponentPropsExtends>;

declare class HocTransformer implements ProxyHandler<Function> {
    private transformer;
    private resultTransformer;
    private displayNameTransform;
    _displayNameField: symbol;
    constructor(transformer: null | ((...args: readonly any[]) => ReadonlyArray<any> | any[]), resultTransformer: null | ((result: ReactNode) => ReactNode), displayNameTransform: null | DisplayNameTransform);
    apply(target: Function, self: Function, args: any[]): any;
    get(target: Function, p: string | symbol, receiver: any): any;
    set(target: Function, p: string | symbol, value: any): boolean;
}

declare class MimicToNewComponentHandler implements ProxyHandler<object> {
    private _componentProps;
    get(target: Function, p: PropertyKey, receiver: any): any;
    set(target: Function, p: PropertyKey, value: any): boolean;
    defineProperty(target: Function, property: PropertyKey, attributes: PropertyDescriptor): boolean;
    deleteProperty(target: Function, p: PropertyKey): boolean;
    has(target: Function, prop: PropertyKey): boolean;
}

type ComponentArgs = [props: Record<any, unknown>, ref: React__default.Ref<unknown>];
declare class RewriteCall implements ProxyHandler<Function> {
    private handler;
    constructor(handler: (props: {
        args: ComponentArgs;
        renderComponent: (...args: ComponentArgs) => React__default.ReactNode;
    }) => React__default.ReactNode);
    apply(target: Function, self: Function, args: any[]): React__default.ReactNode;
}

declare const isRef: <T = unknown>(maybeRef: unknown) => maybeRef is React__default.Ref<T>;

/**
 * transformProps is a function that takes a component, a props transformer function, and an
 * optional display name prefix, and returns a higher-order component that wraps the input
 * component with the specified props transformations.
 *
 * @param Component The input component to be wrapped with the props transformations.
 * @param transformer A function that takes the new props and returns the previous props for the input component.
 * @param options Optional string to prefix the display name of the resulting component.
 * @returns A higher-order component that wraps the input component with the specified props transformations.
 */
declare const transformProps: TransformProps;

/**
 * allows to wrap component into the proxy as functional component
 */
declare const wrapIntoProxy: (proxy: ProxyHandler<Function>) => <T extends React$1.ComponentType<any>>(Component: T) => WrappedComponent<Identity, PropsBase, T>;

export { ChangeComponentProps, CreateHocComponentOptions, CreateHocNameOption, CreateHocOptions, CreateHocReturn, CreateHocSharedOptions, CreateTransformPropsOptions, DisplayNameTransform, HocTransformer, HocTypeTransform, MimicToNewComponentHandler, PropsBase, PropsTransformer, RewriteCall, TransformProps, TransformPropsReturn, WrappedComponent, WrappedComponentCreator, createHoc, createTransformProps, isRef, transformProps, wrapIntoProxy };
